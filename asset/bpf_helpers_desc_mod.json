[{"bpf_map_lookup_elem": {"Project": "libbpf", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}, "bpf_map_update_elem": {"Project": "libbpf", "Return Type": "int", "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_map_update_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}", "{Type:  const void ,Var: *value}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_update"]}, "bpf_map_delete_elem": {"Project": "libbpf", "Return Type": "int", "Description": "Delete entry with <[ key ]>(IP: 1) from map. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_map_delete_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_update"]}, "bpf_probe_read": {"Project": "libbpf", "Return Type": "int", "Description": "For tracing programs , safely attempt to read <[ size ]>(IP: 1) bytes from address <[ src ]>(IP: 2) and store the data in dst. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_probe_read", "Input Params": ["{Type: void ,Var: *dst}", "{Type:  u32 ,Var: size}", "{Type:  const void ,Var: *src}"], "compatible_hookpoints": ["kprobe", "tracepoint", "perf_event", "raw_tracepoint", "raw_tracepoint_writable"], "capabilities": ["read_sys_info"]}, "bpf_ktime_get_ns": {"Project": "bcc", "FunctionName": "bpf_ktime_get_ns", "Return Type": "u64", "Description": "u64 bpf_ktime_get_ns(void) Return: u64 number of nanoseconds. Starts at system boot time but stops during suspend. Examples in situ: \"https://github.com/iovisor/bcc/search?q=bpf_ktime_get_ns+path%3Aexamples&type=Code search /examples , \"https://github.com/iovisor/bcc/search?q=bpf_ktime_get_ns+path%3Atools&type=Code search /tools ", "Return": "u64 number of nanoseconds", "Input Prameters": [], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "raw_tracepoint_writable"], "capabilities": ["read_sys_info"]}, "bpf_trace_printk": {"Project": "bcc", "FunctionName": "bpf_trace_printk", "Return Type": "int", "Description": "int bpf_trace_printk(const char *fmt, ...) Return: 0 on success A simple kernel facility for printf to the common trace_pipe (/sys/kernel/debug/tracing/trace_pipe). This is ok for some quick examples, but has limitations: 3 args max, 1 %s only, and trace_pipe is globally shared, so concurrent programs will have clashing output. A better interface is via BPF_PERF_OUTPUT. Note that calling this helper is made simpler than the original kernel version, which has fmt_size as the second parameter. Examples in situ: \"https://github.com/iovisor/bcc/search?q=bpf_trace_printk+path%3Aexamples&type=Code search /examples , \"https://github.com/iovisor/bcc/search?q=bpf_trace_printk+path%3Atools&type=Code search /tools ", "Return": " 0 on success", "Input Prameters": ["{Type: const char* ,Var: fmt}", "{Type: ... ,Var: }"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": []}, "bpf_get_prandom_u32": {"Project": "bcc", "FunctionName": "bpf_get_prandom_u32", "Return Type": "u32", "Description": "u32 bpf_get_prandom_u32 Returns a pseudo-random u32. Example in situ: \"https://github.com/iovisor/bcc/search?q=bpf_get_prandom_u32+path%3Aexamples&type=Code search /examples , \"https://github.com/iovisor/bcc/search?q=bpf_get_prandom_u32+path%3Atools&type=Code search /tools ", "Return": "Returns a pseudo-random u32", "Input Prameters": [], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "raw_tracepoint_writable"], "capabilities": ["read_sys_info"]}, "bpf_get_smp_processor_id": {"Project": "libbpf", "Return Type": "u32", "Description": "Get the SMP (symmetric multiprocessing) processor id. Note that all programs run with preemption disabled , which means that the SMP processor id is stable during all the execution of the program. ", "Return": " The SMP id of the processor running the program.", "Function Name": "bpf_get_smp_processor_id", "Input Params": ["{Type: voi ,Var: void}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "raw_tracepoint_writable"], "capabilities": ["read_sys_info"]}, "bpf_skb_store_bytes": {"Project": "libbpf", "Return Type": "int", "Description": "Store <[ len ]>(IP: 3) bytes <[ from ]>(IP: 2) address <[ from ]>(IP: 2) into the packet associated to <[ skb ]>(IP: 0) , at offset. <[ flags ]>(IP: 4) are a combination of BPF_F_RECOMPUTE_CSUM (automatically recompute the checksum for the packet after storing the bytes) and BPF_F_INVALIDATE_HASH (set skb->hash , skb->swhash and skb->l4hash to 0). A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_skb_store_bytes", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  u32 ,Var: offset}", "{Type:  const void ,Var: *from}", "{Type:  u32 ,Var: len}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["sched_cls", "sched_act", "lwt_xmit", "sk_skb"], "capabilities": ["update_pkt"]}, "bpf_l3_csum_replace": {"Project": "libbpf", "Return Type": "int", "Description": "Recompute the layer 3 (e. g. IP) checksum for the packet associated <[ to ]>(IP: 3) skb. Computation is incremental , so the helper must know the former value of the header field that was modified (from) , the new value of this field (to) , and the number of bytes (2 or 4) for this field , stored in size. Alternatively , it is possible <[ to ]>(IP: 3) store the difference between the previous and the new values of the header field in <[ to ]>(IP: 3) , by setting <[ from ]>(IP: 2) and <[ size ]>(IP: 4) <[ to ]>(IP: 3) 0. For both methods , <[ offset ]>(IP: 1) indicates the location of the IP checksum within the packet. This helper works in combination with bpf_csum_diff() , which does not update the checksum in-place , but offers more flexibility and can handle sizes larger than 2 or 4 for the checksum <[ to ]>(IP: 3) update. A call <[ to ]>(IP: 3) this helper is susceptible <[ to ]>(IP: 3) change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_l3_csum_replace", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  u32 ,Var: offset}", "{Type:  u64 ,Var: from}", "{Type:  u64 ,Var: to}", "{Type:  u64 ,Var: size}"], "compatible_hookpoints": ["sched_cls", "sched_act", "lwt_xmit"], "capabilities": ["update_pkt"]}, "bpf_l4_csum_replace": {"Project": "libbpf", "Return Type": "int", "Description": "Recompute the layer 4 (e. g. TCP , UDP or ICMP) checksum for the packet associated <[ to ]>(IP: 3) skb. Computation is incremental , so the helper must know the former value of the header field that was modified (from) , the new value of this field (to) , and the number of bytes (2 or 4) for this field , stored on the lowest four bits of flags. Alternatively , it is possible <[ to ]>(IP: 3) store the difference between the previous and the new values of the header field in <[ to ]>(IP: 3) , by setting <[ from ]>(IP: 2) and the four lowest bits of <[ flags ]>(IP: 4) <[ to ]>(IP: 3) 0. For both methods , <[ offset ]>(IP: 1) indicates the location of the IP checksum within the packet. In addition <[ to ]>(IP: 3) the size of the field , <[ flags ]>(IP: 4) can be added (bitwise OR) actual flags. With BPF_F_MARK_MANGLED_0 , a null checksum is left untouched (unless BPF_F_MARK_ENFORCE is added as well) , and for updates resulting in a null checksum the value is set <[ to ]>(IP: 3) CSUM_MANGLED_0 instead. Flag BPF_F_PSEUDO_HDR indicates the checksum is <[ to ]>(IP: 3) be computed against a pseudo-header. This helper works in combination with bpf_csum_diff() , which does not update the checksum in-place , but offers more flexibility and can handle sizes larger than 2 or 4 for the checksum <[ to ]>(IP: 3) update. A call <[ to ]>(IP: 3) this helper is susceptible <[ to ]>(IP: 3) change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_l4_csum_replace", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  u32 ,Var: offset}", "{Type:  u64 ,Var: from}", "{Type:  u64 ,Var: to}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["sched_cls", "sched_act", "lwt_xmit"], "capabilities": ["update_pkt"]}, "bpf_tail_call": {"Project": "libbpf", "Return Type": "int", "Description": "This special helper is used to trigger a \" tail call \" , or in other words , to jump into another eBPF program. The same stack frame is used (but values on stack and in registers for the caller are not accessible to the callee). This mechanism allows for program chaining , either for raising the maximum number of available eBPF instructions , or to execute given programs in conditional blocks. For security reasons , there is an upper limit to the number of successive tail calls that can be performed. Upon call of this helper , the program attempts to jump into a program referenced at <[ index ]>(IP: 2) index in <[ prog_array_map ]>(IP: 1) , a special map of type BPF_MAP_TYPE_PROG_ARRAY , and passes <[ ctx ]>(IP: 0) , a pointer to the context. If the call succeeds , the kernel immediately runs the first instruction of the new program. This is not a function call , and it never returns to the previous program. If the call fails , then the helper has no effect , and the caller continues to run its subsequent instructions. A call can fail if the destination program for the jump does not exist (i. e. <[ index ]>(IP: 2) is superior to the number of entries in prog_array_map) , or if the maximum number of tail calls has been reached for this chain of programs. This limit is defined in the kernel by the macro MAX_TAIL_CALL_CNT (not accessible to user space) , which is currently set to 32. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_tail_call", "Input Params": ["{Type: void ,Var: *ctx}", "{Type:  struct bpf_map ,Var: *prog_array_map}", "{Type:  u32 ,Var: index}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "raw_tracepoint_writable"], "capabilities": []}, "bpf_clone_redirect": {"Project": "libbpf", "Return Type": "int", "Description": "Clone and redirect the packet associated to <[ skb ]>(IP: 0) to another net device of index ifindex. Both ingress and egress interfaces can be used for redirection. The BPF_F_INGRESS value in <[ flags ]>(IP: 2) is used to make the distinction (ingress path is selected if the flag is present , egress path otherwise). This is the only flag supported for now. In comparison with bpf_redirect() helper , bpf_clone_redirect() has the associated cost of duplicating the packet buffer , but this can be executed out of the eBPF program. Conversely , bpf_redirect() is more efficient , but it is handled through an action code where the redirection happens only after the eBPF program has returned. A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_clone_redirect", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  u32 ,Var: ifindex}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["sched_cls", "sched_act", "lwt_xmit"], "capabilities": []}, "bpf_get_current_pid_tgid": {"Project": "bcc", "FunctionName": "bpf_get_current_pid_tgid", "Return Type": "u64", "Description": "u64 bpf_get_current_pid_tgid(void) Return: current->tgid << 32 | current->pid Returns the process ID in the lower 32 bits (kernel's view of the PID, which in user space is usually presented as the thread ID), and the thread group ID in the upper 32 bits (what user space often thinks of as the PID). By directly setting this to a u32, we discard the upper 32 bits. Examples in situ: \"https://github.com/iovisor/bcc/search?q=bpf_get_current_pid_tgid+path%3Aexamples&type=Code search /examples , \"https://github.com/iovisor/bcc/search?q=bpf_get_current_pid_tgid+path%3Atools&type=Code search /tools ", "Return": "current->tgid << 32 | current->pid Returns the process ID in the lower 32 bits (kernel's view of the PID, which in user space is usually presented as the thread ID), and the thread group ID in the upper 32 bits (what user space often thinks of as the PID)", "Input Prameters": [], "compatible_hookpoints": ["kprobe", "tracepoint", "perf_event", "raw_tracepoint", "raw_tracepoint_writable"], "capabilities": ["read_sys_info"]}, "bpf_get_current_uid_gid": {"Project": "bcc", "FunctionName": "bpf_get_current_uid_gid", "Return Type": null, "Description": "u64 bpf_get_current_uid_gid(void) Return: current_gid << 32 | current_uid Returns the user ID and group IDs. Examples in situ: \"https://github.com/iovisor/bcc/search?q=bpf_get_current_uid_gid+path%3Aexamples&type=Code search /examples , \"https://github.com/iovisor/bcc/search?q=bpf_get_current_uid_gid+path%3Atools&type=Code search /tools ", "Return": null, "Input Prameters": [], "compatible_hookpoints": ["kprobe", "tracepoint", "perf_event", "cgroup_sock", "cgroup_device", "raw_tracepoint", "cgroup_sock_addr", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["read_sys_info"]}, "bpf_get_current_comm": {"Project": "bcc", "FunctionName": "bpf_get_current_comm", "Return Type": "int", "Description": "bpf_get_current_comm(char *buf, int size_of_buf) Return: 0 on success Populates the first argument address with the current process name. It should be a pointer to a char array of at least size TASK_COMM_LEN, which is defined in linux/sched.h. For example: ```C include ", "Return": "0 on success", "Input Prameters": ["{Type: char* ,Var: buf}", "{Type: int ,Var: size_of_buf}"], "compatible_hookpoints": ["kprobe", "tracepoint", "perf_event", "raw_tracepoint", "raw_tracepoint_writable"], "capabilities": ["read_sys_info"]}, "bpf_get_cgroup_classid": {"Project": "libbpf", "Return Type": "u32", "Description": "Retrieve the classid for the current task , i. e. for the net_cls cgroup to which <[ skb ]>(IP: 0) belongs. This helper can be used on TC egress path , but not on ingress. The net_cls cgroup provides an interface to tag network packets based on a user-provided identifier for all traffic coming from the tasks belonging to the related cgroup. See also the related kernel documentation , available from the Linux sources in file Documentation/admin-guide/cgroup-v1/net_cls. rst. The Linux kernel has two versions for cgroups: there are cgroups v1 and cgroups v2. Both are available to users , who can use a mixture of them , but note that the net_cls cgroup is for cgroup v1 only. This makes it incompatible with BPF programs run on cgroups , which is a cgroup-v2-only feature (a socket can only hold data for one version of cgroups at a time). This helper is only available is the kernel was compiled with the CONFIG_CGROUP_NET_CLASSID configuration option set to \"y\" or to \"m\" ", "Return": " The classid, or 0 for the default unconfigured classid.", "Function Name": "bpf_get_cgroup_classid", "Input Params": ["{Type: struct sk_buff ,Var: *skb}"], "compatible_hookpoints": ["sched_cls", "sched_act", "lwt_in", "lwt_out", "lwt_xmit", "lwt_seg6local"], "capabilities": ["read_sys_info"]}, "bpf_skb_vlan_push": {"Project": "libbpf", "Return Type": "int", "Description": "Push a <[ vlan_tci ]>(IP: 2) (VLAN tag control information) of protocol <[ vlan_proto ]>(IP: 1) to the packet associated to <[ skb ]>(IP: 0) , then update the checksum. Note that if <[ vlan_proto ]>(IP: 1) is different from ETH_P_8021Q and ETH_P_8021AD , it is considered to be ETH_P_8021Q. A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_skb_vlan_push", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  __be16 ,Var: vlan_proto}", "{Type:  u16 ,Var: vlan_tci}"], "compatible_hookpoints": ["sched_cls", "sched_act"], "capabilities": ["update_pkt"]}, "bpf_skb_vlan_pop": {"Project": "libbpf", "Return Type": "int", "Description": "Pop a VLAN header from the packet associated to skb. A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_skb_vlan_pop", "Input Params": ["{Type: struct sk_buff ,Var: *skb}"], "compatible_hookpoints": ["sched_cls", "sched_act"], "capabilities": ["update_pkt"]}, "bpf_skb_get_tunnel_key": {"Project": "libbpf", "Return Type": "int", "Description": "Get tunnel metadata. This helper takes a pointer <[ key ]>(IP: 1) to an empty struct bpf_tunnel_key of <[ size ]>(IP: 2) , that will be filled with tunnel metadata for the packet associated to skb. The <[ flags ]>(IP: 3) can be set to BPF_F_TUNINFO_IPV6 , which indicates that the tunnel is based on IPv6 protocol instead of IPv4. The struct bpf_tunnel_key is an object that generalizes the principal parameters used by various tunneling protocols into a single struct. This way , it can be used to easily make a decision based on the contents of the encapsulation header , \"summarized\" in this struct. In particular , it holds the IP address of the remote end (IPv4 or IPv6 , depending on the case) in key->remote_ipv4 or key->remote_ipv6. Also , this struct exposes the key->tunnel_id , which is generally mapped to a VNI (Virtual Network Identifier) , making it programmable together with the bpf_skb_set_tunnel_key() helper. Let's imagine that the following code is part of a program attached to the TC ingress interface , on one end of a GRE tunnel , and is supposed to filter out all messages coming from remote ends with IPv4 address other than 10. 0. 0. 1: int ret; struct bpf_tunnel_key <[ key ]>(IP: 1) = {}; ret = bpf_skb_get_tunnel_key(skb , &key , sizeof(key) , 0); if (ret < 0) return TC_ACT_SHOT; // drop packet if (key. remote_ipv4 != 0x0a000001) return TC_ACT_SHOT; // drop packet return TC_ACT_OK; // accept packet This interface can also be used with all encapsulation devices that can operate in \"collect metadata\" mode: instead of having one network device per specific configuration , the \"collect metadata\" mode only requires a single device where the configuration can be extracted from this helper. This can be used together with various tunnels such as VXLan , Geneve , GRE or IP in IP (IPIP). ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_skb_get_tunnel_key", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  struct bpf_tunnel_key ,Var: *key}", "{Type:  u32 ,Var: size}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["sched_cls", "sched_act", "lwt_xmit"], "capabilities": ["read_skb", "read_sys_info"]}, "bpf_skb_set_tunnel_key": {"Project": "libbpf", "Return Type": "int", "Description": "Populate tunnel metadata for packet associated to skb. The tunnel metadata is set to the contents of <[ key ]>(IP: 1) , of size. The <[ flags ]>(IP: 3) can be set to a combination of the following values: BPF_F_TUNINFO_IPV6 Indicate that the tunnel is based on IPv6 protocol instead of IPv4. BPF_F_ZERO_CSUM_TX For IPv4 packets , add a flag to tunnel metadata indicating that checksum computation should be skipped and checksum set to zeroes. BPF_F_DONT_FRAGMENT Add a flag to tunnel metadata indicating that the packet should not be fragmented. BPF_F_SEQ_NUMBER Add a flag to tunnel metadata indicating that a sequence number should be added to tunnel header before sending the packet. This flag was added for GRE encapsulation , but might be used with other protocols as well in the future. Here is a typical usage on the transmit path: struct bpf_tunnel_key key; populate <[ key ]>(IP: 1) . . . bpf_skb_set_tunnel_key(skb , &key , sizeof(key) , 0); bpf_clone_redirect(skb , vxlan_dev_ifindex , 0); See also the description of the bpf_skb_get_tunnel_key() helper for additional information. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_skb_set_tunnel_key", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  struct bpf_tunnel_key ,Var: *key}", "{Type:  u32 ,Var: size}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["sched_cls", "sched_act", "lwt_xmit"], "capabilities": ["update_pkt"]}, "bpf_perf_event_read": {"Project": "libbpf", "Return Type": "u64", "Description": "Read the value of a perf event counter. This helper relies on a <[ map ]>(IP: 0) of type BPF_MAP_TYPE_PERF_EVENT_ARRAY. The nature of the perf event counter is selected when <[ map ]>(IP: 0) is updated with perf event file descriptors. The <[ map ]>(IP: 0) is an array whose size is the number of available CPUs , and each cell contains a value relative to one CPU. The value to retrieve is indicated by <[ flags ]>(IP: 1) , that contains the index of the CPU to look up , masked with BPF_F_INDEX_MASK. Alternatively , <[ flags ]>(IP: 1) can be set to BPF_F_CURRENT_CPU to indicate that the value for the current CPU should be retrieved. Note that before Linux 4. 13 , only hardware perf event can be retrieved. Also , be aware that the newer helper bpf_perf_event_read_value() is recommended over bpf_perf_event_read() in general. The latter has some ABI quirks where error and counter value are used as a return code (which is wrong to do since ranges may overlap). This issue is fixed with bpf_perf_event_read_value() , which at the same time provides more features over the bpf_perf_event_read() interface. Please refer to the description of bpf_perf_event_read_value() for details. ", "Return": " The value of the perf event counter read from the map, or a  negative  error                     code in case of failure.", "Function Name": "bpf_perf_event_read", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["kprobe", "tracepoint", "perf_event", "raw_tracepoint", "raw_tracepoint_writable"], "capabilities": ["read_sys_info"]}, "bpf_redirect": {"Project": "libbpf", "Return Type": "int", "Description": "Redirect the packet to another net device of index ifindex. This helper is somewhat similar to bpf_clone_redirect() , except that the packet is not cloned , which provides increased performance. Except for XDP , both ingress and egress interfaces can be used for redirection. The BPF_F_INGRESS value in <[ flags ]>(IP: 1) is used to make the distinction (ingress path is selected if the flag is present , egress path otherwise). Currently , XDP only supports redirection to the egress interface , and accepts no flag at all. The same effect can be attained with the more generic bpf_redirect_map() , which requires specific maps to be used but offers better performance. ", "Return": " For XDP, the helper returns XDP_REDIRECT on success or XDP_ABORTED on error.                     For  other  program  types,  the  values  are  TC_ACT_REDIRECT on success or                     TC_ACT_SHOT on error.", "Function Name": "bpf_redirect", "Input Params": ["{Type: u32 ,Var: ifindex}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp", "lwt_xmit"], "capabilities": []}, "bpf_get_route_realm": {"Project": "libbpf", "Return Type": "u32", "Description": "Retrieve the realm or the route , that is to say the tclassid field of the destination for the skb. The indentifier retrieved is a user-provided tag , similar to the one used with the net_cls cgroup (see description for bpf_get_cgroup_classid() helper) , but here this tag is held by a route (a destination entry) , not by a task. Retrieving this identifier works with the clsact TC egress hook (see also tc-bpf(8)) , or alternatively on conventional classful egress qdiscs , but not on TC ingress path. In case of clsact TC egress hook , this has the advantage that , internally , the destination entry has not been dropped yet in the transmit path. Therefore , the destination entry does not need to be artificially held via netif_keep_dst() for a classful qdisc until the <[ skb ]>(IP: 0) is freed. This helper is available only if the kernel was compiled with CONFIG_IP_ROUTE_CLASSID configuration option. ", "Return": " The  realm  of  the route for the packet associated to skb, or 0 if none was                     found.", "Function Name": "bpf_get_route_realm", "Input Params": ["{Type: struct sk_buff ,Var: *skb}"], "compatible_hookpoints": ["sched_cls", "sched_act", "lwt_in", "lwt_out", "lwt_xmit", "lwt_seg6local"], "capabilities": ["read_sys_info"]}, "bpf_perf_event_output": {"Project": "libbpf", "Return Type": "int", "Description": "Write raw <[ data ]>(IP: 3) blob into a special BPF perf event held by <[ map ]>(IP: 1) of type BPF_MAP_TYPE_PERF_EVENT_ARRAY. This perf event must have the following attributes: PERF_SAMPLE_RAW as sample_type , PERF_TYPE_SOFTWARE as type , and PERF_COUNT_SW_BPF_OUTPUT as config. The <[ flags ]>(IP: 2) are used to indicate the index in <[ map ]>(IP: 1) for which the value must be put , masked with BPF_F_INDEX_MASK. Alternatively , <[ flags ]>(IP: 2) can be set to BPF_F_CURRENT_CPU to indicate that the index of the current CPU core should be used. The value to write , of <[ size ]>(IP: 4) , is passed through eBPF stack and pointed by data. The context of the program <[ ctx ]>(IP: 0) needs also be passed to the helper. On user space , a program willing to read the values needs to call perf_event_open() on the perf event (either for one or for all CPUs) and to store the file descriptor into the map. This must be done before the eBPF program can send <[ data ]>(IP: 3) into it. An example is available in file samples/bpf/trace_output_user. c in the Linux kernel source tree (the eBPF program counterpart is in samples/bpf/trace_output_kern. c). bpf_perf_event_output() achieves better performance than bpf_trace_printk() for sharing <[ data ]>(IP: 3) with user space , and is much better suitable for streaming <[ data ]>(IP: 3) from eBPF programs. Note that this helper is not restricted to tracing use cases and can be used with programs attached to TC or XDP as well , where it allows for passing <[ data ]>(IP: 3) to user space listeners. Data can be: \u00b7 Only custom structs , \u00b7 Only the packet payload , or \u00b7 A combination of both. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_perf_event_output", "Input Params": ["{Type: struct pt_regs ,Var: *ctx}", "{Type:  struct bpf_map ,Var: *map}", "{Type:  u64 ,Var: flags}", "{Type:  void ,Var: *data}", "{Type:  u64 ,Var: size}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "raw_tracepoint", "lwt_seg6local", "raw_tracepoint_writable"], "capabilities": []}, "bpf_skb_load_bytes": {"Project": "libbpf", "Return Type": "int", "Description": "This helper was provided as an easy way <[ to ]>(IP: 2) load data from a packet. It can be used <[ to ]>(IP: 2) load <[ len ]>(IP: 3) bytes from <[ offset ]>(IP: 1) from the packet associated <[ to ]>(IP: 2) <[ skb ]>(IP: 0) , into the buffer pointed by to. Since Linux 4. 7 , usage of this helper has mostly been replaced by \"direct packet access\" , enabling packet data <[ to ]>(IP: 2) be manipulated with skb->data and skb->data_end pointing respectively <[ to ]>(IP: 2) the first byte of packet data and <[ to ]>(IP: 2) the byte after the last byte of packet data. However , it remains useful if one wishes <[ to ]>(IP: 2) read large quantities of data at once from a packet into the eBPF stack. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_skb_load_bytes", "Input Params": ["{Type: const struct sk_buff ,Var: *skb}", "{Type:  u32 ,Var: offset}", "{Type:  void ,Var: *to}", "{Type:  u32 ,Var: len}"], "compatible_hookpoints": ["socket_filter", "sched_cls", "sched_act", "cgroup_skb", "lwt_in", "lwt_out", "lwt_xmit", "sk_skb", "lwt_seg6local", "sk_reuseport", "flow_dissector"], "capabilities": ["read_skb"]}, "bpf_get_stackid": {"Project": "libbpf", "Return Type": "int", "Description": "Walk a user or a kernel stack and return its id. To achieve this , the helper needs <[ ctx ]>(IP: 0) , which is a pointer to the context on which the tracing program is executed , and a pointer to a <[ map ]>(IP: 1) of type BPF_MAP_TYPE_STACK_TRACE. The last argument , <[ flags ]>(IP: 2) , holds the number of stack frames to skip (from 0 to 255) , masked with BPF_F_SKIP_FIELD_MASK. The next bits can be used to set a combination of the following flags: BPF_F_USER_STACK Collect a user space stack instead of a kernel stack. BPF_F_FAST_STACK_CMP Compare stacks by hash only. BPF_F_REUSE_STACKID If two different stacks hash into the same stackid , discard the old one. The stack id retrieved is a 32 bit long integer handle which can be further combined with other data (including other stack ids) and used as a key into maps. This can be useful for generating a variety of graphs (such as flame graphs or off-cpu graphs). For walking a stack , this helper is an improvement over bpf_probe_read() , which can be used with unrolled loops but is not efficient and consumes a lot of eBPF instructions. Instead , bpf_get_stackid() can collect up to PERF_MAX_STACK_DEPTH both kernel and user frames. Note that this limit can be controlled with the sysctl program , and that it should be manually increased in order to profile long user stacks (such as stacks for Java programs). To do so , use: # sysctl kernel. perf_event_max_stack=<new value> ", "Return": " The positive or null stack id on success, or a negative  error  in  case  of                     failure.", "Function Name": "bpf_get_stackid", "Input Params": ["{Type: struct pt_regs ,Var: *ctx}", "{Type:  struct bpf_map ,Var: *map}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["kprobe", "tracepoint", "perf_event", "raw_tracepoint", "raw_tracepoint_writable"], "capabilities": ["read_sys_info"]}, "bpf_csum_diff": {"Project": "libbpf", "Return Type": "s64", "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with bpf_l3_csum_replace() and bpf_l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with bpf_csum_diff(). ", "Return": " The checksum result, or a negative error code in case of failure.", "Function Name": "bpf_csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp", "lwt_in", "lwt_out", "lwt_xmit", "lwt_seg6local"], "capabilities": ["read_skb"]}, "bpf_skb_get_tunnel_opt": {"Project": "libbpf", "Return Type": "int", "Description": "Retrieve tunnel options metadata for the packet associated to <[ skb ]>(IP: 0) , and store the raw tunnel option data to the buffer <[ opt ]>(IP: 1) of size. This helper can be used with encapsulation devices that can operate in \"collect metadata\" mode (please refer to the related note in the description of bpf_skb_get_tunnel_key() for more details). A particular example where this can be used is in combination with the Geneve encapsulation protocol , where it allows for pushing (with bpf_skb_get_tunnel_opt() helper) and retrieving arbitrary TLVs (Type-Length-Value headers) from the eBPF program. This allows for full customization of these headers. ", "Return": " The size of the option data retrieved.", "Function Name": "bpf_skb_get_tunnel_opt", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  u8 ,Var: *opt}", "{Type:  u32 ,Var: size}"], "compatible_hookpoints": ["sched_cls", "sched_act", "lwt_xmit"], "capabilities": ["read_skb", "read_sys_info"]}, "bpf_skb_set_tunnel_opt": {"Project": "libbpf", "Return Type": "int", "Description": "Set tunnel options metadata for the packet associated to <[ skb ]>(IP: 0) to the option data contained in the raw buffer <[ opt ]>(IP: 1) of size. See also the description of the bpf_skb_get_tunnel_opt() helper for additional information. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_skb_set_tunnel_opt", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  u8 ,Var: *opt}", "{Type:  u32 ,Var: size}"], "compatible_hookpoints": ["sched_cls", "sched_act", "lwt_xmit"], "capabilities": ["update_pkt"]}, "bpf_skb_change_proto": {"Project": "libbpf", "Return Type": "int", "Description": "Change the protocol of the <[ skb ]>(IP: 0) to proto. Currently supported are transition from IPv4 to IPv6 , and from IPv6 to IPv4. The helper takes care of the groundwork for the transition , including resizing the socket buffer. The eBPF program is expected to fill the new headers , if any , via skb_store_bytes() and to recompute the checksums with bpf_l3_csum_replace() and bpf_l4_csum_replace(). The main case for this helper is to perform NAT64 operations out of an eBPF program. Internally , the GSO type is marked as dodgy so that headers are checked and segments are recalculated by the GSO/GRO engine. The size for GSO target is adapted as well. All values for <[ flags ]>(IP: 2) are reserved for future usage , and must be left at zero. A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_skb_change_proto", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  __be16 ,Var: proto}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["sched_cls", "sched_act"], "capabilities": ["update_pkt"]}, "bpf_skb_change_type": {"Project": "libbpf", "Return Type": "int", "Description": "Change the packet <[ type ]>(IP: 1) for the packet associated to skb. This comes down to setting skb->pkt_type to <[ type ]>(IP: 1) , except the eBPF program does not have a write access to skb->pkt_type beside this helper. Using a helper here allows for graceful handling of errors. The major use case is to change incoming skb*s to **PACKET_HOST* in a programmatic way instead of having to recirculate via redirect(. . . , BPF_F_INGRESS) , for example. Note that <[ type ]>(IP: 1) only allows certain values. At this time , they are: PACKET_HOST Packet is for us. PACKET_BROADCAST Send packet to all. PACKET_MULTICAST Send packet to group. PACKET_OTHERHOST Send packet to someone else. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_skb_change_type", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  u32 ,Var: type}"], "compatible_hookpoints": ["sched_cls", "sched_act"], "capabilities": ["update_pkt"]}, "bpf_skb_under_cgroup": {"Project": "libbpf", "Return Type": "int", "Description": "Check whether <[ skb ]>(IP: 0) is a descendant of the cgroup2 held by <[ map ]>(IP: 1) of type BPF_MAP_TYPE_CGROUP_ARRAY , at index. ", "Return": " The return value depends on the result of the test, and can be:                     \u00b7 0, if the skb failed the cgroup2 descendant test.                     \u00b7 1, if the skb succeeded the cgroup2 descendant test.                     \u00b7 A negative error code, if an error occurred.", "Function Name": "bpf_skb_under_cgroup", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  struct bpf_map ,Var: *map}", "{Type:  u32 ,Var: index}"], "compatible_hookpoints": ["sched_cls", "sched_act", "lwt_in", "lwt_out", "lwt_xmit", "lwt_seg6local"], "capabilities": ["read_skb", "read_sys_info"]}, "bpf_get_hash_recalc": {"Project": "libbpf", "Return Type": "u32", "Description": "Retrieve the hash of the packet , skb->hash. If it is not set , in particular if the hash was cleared due to mangling , recompute this hash. Later accesses to the hash can be done directly with skb->hash. Calling bpf_set_hash_invalid() , changing a packet prototype with bpf_skb_change_proto() , or calling bpf_skb_store_bytes() with the BPF_F_INVALIDATE_HASH are actions susceptible to clear the hash and to trigger a new computation for the next call to bpf_get_hash_recalc(). ", "Return": " The 32-bit hash.", "Function Name": "bpf_get_hash_recalc", "Input Params": ["{Type: struct sk_buff ,Var: *skb}"], "compatible_hookpoints": ["sched_cls", "sched_act", "lwt_in", "lwt_out", "lwt_xmit", "lwt_seg6local"], "capabilities": ["read_sys_info"]}, "bpf_get_current_task": {"Project": "bcc", "FunctionName": "bpf_get_current_task", "Return Type": "struct task_struct *", "Description": "bpf_get_current_task Return: current task as a pointer to struct task_struct. Returns a pointer to the current task's task_struct object. This helper can be used to compute the on-CPU time for a process, identify kernel threads, get the current CPU's run queue, or retrieve many other pieces of information. With Linux 4.13, due to issues with field randomization, you may need two #define directives before the includes:```C define randomized_struct_fields_start  struct {  define randomized_struct_fields_end    };  include ", "Return": "current task as a pointer to struct task_struct. Returns a pointer to the current task's task_struct object.", "Input Prameters": [], "compatible_hookpoints": ["kprobe", "tracepoint", "perf_event", "raw_tracepoint", "raw_tracepoint_writable"], "capabilities": ["read_sys_info"]}, "bpf_probe_write_user": {"Project": "libbpf", "Return Type": "int", "Description": "Attempt in a safe way to write <[ len ]>(IP: 2) bytes from the buffer <[ src ]>(IP: 1) to <[ dst ]>(IP: 0) in memory. It only works for threads that are in user context , and <[ dst ]>(IP: 0) must be a valid user space address. This helper should not be used to implement any kind of security mechanism because of TOC-TOU attacks , but rather to debug , divert , and manipulate execution of semi-cooperative processes. Keep in mind that this feature is meant for experiments , and it has a risk of crashing the system and running programs. Therefore , when an eBPF program using this helper is attached , a warning including PID and process name is printed to kernel logs. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_probe_write_user", "Input Params": ["{Type: void ,Var: *dst}", "{Type:  const void ,Var: *src}", "{Type:  u32 ,Var: len}"], "compatible_hookpoints": ["kprobe", "tracepoint", "perf_event", "raw_tracepoint", "raw_tracepoint_writable"], "capabilities": []}, "bpf_current_task_under_cgroup": {"Project": "libbpf", "Return Type": "int", "Description": "Check whether the probe is being run is the context of a given subset of the cgroup2 hierarchy. The cgroup2 to test is held by <[ map ]>(IP: 0) of type BPF_MAP_TYPE_CGROUP_ARRAY , at index. ", "Return": " The return value depends on the result of the test, and can be:                     \u00b7 0, if the skb task belongs to the cgroup2.                     \u00b7 1, if the skb task does not belong to the cgroup2.                     \u00b7 A negative error code, if an error occurred.", "Function Name": "bpf_current_task_under_cgroup", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  u32 ,Var: index}"], "compatible_hookpoints": ["kprobe", "tracepoint", "perf_event", "raw_tracepoint", "raw_tracepoint_writable"], "capabilities": ["read_sys_info"]}, "bpf_skb_change_tail": {"Project": "libbpf", "Return Type": "int", "Description": "Resize (trim or grow) the packet associated to <[ skb ]>(IP: 0) to the new len. The <[ flags ]>(IP: 2) are reserved for future usage , and must be left at zero. The basic idea is that the helper performs the needed work to change the size of the packet , then the eBPF program rewrites the rest via helpers like bpf_skb_store_bytes() , bpf_l3_csum_replace() , bpf_l3_csum_replace() and others. This helper is a slow path utility intended for replies with control messages. And because it is targeted for slow path , the helper itself can afford to be slow: it implicitly linearizes , unclones and drops offloads from the skb. A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_skb_change_tail", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  u32 ,Var: len}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["sched_cls", "sched_act", "lwt_xmit", "sk_skb"], "capabilities": ["update_pkt"]}, "bpf_skb_pull_data": {"Project": "libbpf", "Return Type": "int", "Description": "Pull in non-linear data in case the <[ skb ]>(IP: 0) is non-linear and not all of <[ len ]>(IP: 1) are part of the linear section. Make <[ len ]>(IP: 1) bytes from <[ skb ]>(IP: 0) readable and writable. If a zero value is passed for <[ len ]>(IP: 1) , then the whole length of the <[ skb ]>(IP: 0) is pulled. This helper is only needed for reading and writing with direct packet access. For direct packet access , testing that offsets to access are within packet boundaries (test on skb->data_end) is susceptible to fail if offsets are invalid , or if the requested data is in non-linear parts of the skb. On failure the program can just bail out , or in the case of a non-linear buffer , use a helper to make the data available. The bpf_skb_load_bytes() helper is a first solution to access the data. Another one consists in using bpf_skb_pull_data to pull in once the non-linear parts , then retesting and eventually access the data. At the same time , this also makes sure the <[ skb ]>(IP: 0) is uncloned , which is a necessary condition for direct write. As this needs to be an invariant for the write part only , the verifier detects writes and adds a prologue that is calling bpf_skb_pull_data() to effectively unclone the <[ skb ]>(IP: 0) from the very beginning in case it is indeed cloned. A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_skb_pull_data", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  u32 ,Var: len}"], "compatible_hookpoints": ["sched_cls", "sched_act", "lwt_in", "lwt_out", "lwt_xmit", "sk_skb", "lwt_seg6local"], "capabilities": ["update_pkt"]}, "bpf_csum_update": {"Project": "libbpf", "Return Type": "s64", "Description": "Add the checksum <[ csum ]>(IP: 1) into skb->csum in case the driver has supplied a checksum for the entire packet into that field. Return an error otherwise. This helper is intended to be used in combination with bpf_csum_diff() , in particular when the checksum needs to be updated after data has been written into the packet through direct packet access. ", "Return": " The checksum on success, or a negative error code in case of failure.", "Function Name": "bpf_csum_update", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  __wsum ,Var: csum}"], "compatible_hookpoints": ["sched_cls", "sched_act", "lwt_xmit"], "capabilities": ["update_pkt"]}, "bpf_set_hash_invalid": {"Project": "libbpf", "Return Type": "void", "Description": "Invalidate the current skb->hash. It can be used after mangling on headers through direct packet access , in order to indicate that the hash is outdated and to trigger a recalculation the next time the kernel tries to access this hash or when the bpf_get_hash_recalc() helper is called. ", "Function Name": "bpf_set_hash_invalid", "Input Params": ["{Type: struct sk_buff ,Var: *skb}"], "compatible_hookpoints": ["sched_cls", "sched_act", "lwt_xmit"], "capabilities": ["update_pkt"]}, "bpf_get_numa_node_id": {"Project": "libbpf", "Return Type": "int", "Description": "Return the id of the current NUMA node. The primary use case for this helper is the selection of sockets for the local NUMA node , when the program is attached to sockets using the SO_ATTACH_REUSEPORT_EBPF option (see also socket(7)) , but the helper is also available to other eBPF program types , similarly to bpf_get_smp_processor_id(). ", "Return": " The id of current NUMA node.", "Function Name": "bpf_get_numa_node_id", "Input Params": ["{Type: voi ,Var: void}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "raw_tracepoint_writable"], "capabilities": ["read_sys_info"]}, "bpf_skb_change_head": {"Project": "libbpf", "Return Type": "int", "Description": "Grows headroom of packet associated to <[ skb ]>(IP: 0) and adjusts the offset of the MAC header accordingly , adding <[ len ]>(IP: 1) bytes of space. It automatically extends and reallocates memory as required. This helper can be used on a layer 3 <[ skb ]>(IP: 0) to push a MAC header for redirection into a layer 2 device. All values for <[ flags ]>(IP: 2) are reserved for future usage , and must be left at zero. A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_skb_change_head", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  u32 ,Var: len}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["sched_cls", "sched_act", "lwt_xmit", "sk_skb"], "capabilities": ["update_pkt"]}, "bpf_xdp_adjust_head": {"Project": "libbpf", "Return Type": "int", "Description": "Adjust (move) xdp_md->data by <[ delta ]>(IP: 1) bytes. Note that it is possible to use a negative value for delta. This helper can be used to prepare the packet for pushing or popping headers. A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_xdp_adjust_head", "Input Params": ["{Type: struct xdp_buff ,Var: *xdp_md}", "{Type:  int ,Var: delta}"], "compatible_hookpoints": ["xdp"], "capabilities": ["update_pkt"]}, "bpf_probe_read_str": {"Project": "libbpf", "Return Type": "int", "Description": "Copy a NUL terminated string from an unsafe address <[ unsafe_ptr ]>(IP: 2) to dst. The <[ size ]>(IP: 1) should include the terminating NUL byte. In case the string length is smaller than <[ size ]>(IP: 1) , the target is not padded with further NUL bytes. If the string length is larger than <[ size ]>(IP: 1) , just size-1 bytes are copied and the last byte is set to NUL. On success , the length of the copied string is returned. This makes this helper useful in tracing programs for reading strings , and more importantly to get its length at runtime. See the following snippet: SEC(\"kprobe / sys_open\") void bpf_sys_open(struct pt_regs *ctx) { char buf[PATHLEN]; // PATHLEN is defined to 256 int res = bpf_probe_read_str(buf , sizeof(buf) , ctx->di); // Consume buf , for example push it to // userspace via bpf_perf_event_output(); we // can use res (the string length) as event // <[ size ]>(IP: 1) , after checking its boundaries. } In comparison , using bpf_probe_read() helper here instead to read the string would require to estimate the length at compile time , and would often result in copying more memory than necessary. Another useful use case is when parsing individual process arguments or individual environment variables navigating current->mm->arg_start and current->mm->env_start: using this helper and the return value , one can quickly iterate at the right offset of the memory area. ", "Return": " On  success,  the  strictly  positive  length  of  the string, including the                     trailing NUL character. On error, a negative value.", "Function Name": "bpf_probe_read_str", "Input Params": ["{Type: void ,Var: *dst}", "{Type:  int ,Var: size}", "{Type:  const void ,Var: *unsafe_ptr}"], "compatible_hookpoints": ["kprobe", "tracepoint", "perf_event", "raw_tracepoint", "raw_tracepoint_writable"], "capabilities": ["read_sys_info"]}, "bpf_get_socket_cookie": {"Project": "libbpf", "Return Type": "u64", "Description": "Equivalent to bpf_get_socket_cookie() helper that accepts skb , but gets socket from struct bpf_sock_ops context. ", "Return": " A 8-byte long non-decreasing number.", "Function Name": "bpf_get_socket_cookie", "Input Params": ["{Type: struct bpf_sock_ops ,Var: *ctx}"], "compatible_hookpoints": ["socket_filter", "sched_cls", "sched_act", "cgroup_skb", "sock_ops", "sk_skb", "cgroup_sock_addr"], "capabilities": ["read_sys_info"]}, "bpf_get_socket_uid": {"Project": "libbpf", "Return Type": "u32", "Return": " The owner UID of the socket associated to skb. If the socket is NULL, or  if                     it  is  not  a  full  socket  (i.e. if it is a time-wait or a request socket                     instead), overflowuid value is returned (note that overflowuid might also be                     the actual UID value for the socket).", "Function Name": "bpf_get_socket_uid", "Input Params": ["{Type: struct sk_buff ,Var: *skb}"], "Description": "The owner UID of the socket associated to skb. If the socket is NULL , or if it is not a full socket (i. e. if it is a time-wait or a request socket instead) , overflowuid value is returned (note that overflowuid might also be the actual UID value for the socket). ", "compatible_hookpoints": ["socket_filter", "sched_cls", "sched_act", "cgroup_skb", "sk_skb"], "capabilities": ["read_sys_info"]}, "bpf_set_hash": {"Project": "libbpf", "Return Type": "u32", "Description": "Set the full <[ hash ]>(IP: 1) for <[ skb ]>(IP: 0) (set the field skb->hash) to value hash. ", "Return": " 0", "Function Name": "bpf_set_hash", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  u32 ,Var: hash}"], "compatible_hookpoints": ["sched_cls", "sched_act"], "capabilities": ["update_pkt"]}, "bpf_setsockopt": {"Project": "libbpf", "Return Type": "int", "Description": "Emulate a call to setsockopt() on the socket associated to <[ bpf_socket ]>(IP: 0) , which must be a full socket. The <[ level ]>(IP: 1) at which the option resides and the name <[ optname ]>(IP: 2) of the option must be specified , see setsockopt(2) for more information. The option value of length <[ optlen ]>(IP: 4) is pointed by optval. This helper actually implements a subset of setsockopt(). It supports the following levels: \u00b7 SOL_SOCKET , which supports the following optnames: SO_RCVBUF , SO_SNDBUF , SO_MAX_PACING_RATE , SO_PRIORITY , SO_RCVLOWAT , SO_MARK. \u00b7 IPPROTO_TCP , which supports the following optnames: TCP_CONGESTION , TCP_BPF_IW , TCP_BPF_SNDCWND_CLAMP. \u00b7 IPPROTO_IP , which supports <[ optname ]>(IP: 2) IP_TOS. \u00b7 IPPROTO_IPV6 , which supports <[ optname ]>(IP: 2) IPV6_TCLASS. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_setsockopt", "Input Params": ["{Type: struct bpf_sock_ops ,Var: *bpf_socket}", "{Type:  int ,Var: level}", "{Type:  int ,Var: optname}", "{Type:  char ,Var: *optval}", "{Type:  int ,Var: optlen}"], "compatible_hookpoints": ["sock_ops"], "capabilities": ["update_pkt"]}, "bpf_skb_adjust_room": {"Project": "libbpf", "Return Type": "int", "Description": "Grow or shrink the room for data in the packet associated to <[ skb ]>(IP: 0) by <[ len_diff ]>(IP: 1) , and according to the selected mode. There are two supported modes at this time: \u00b7 BPF_ADJ_ROOM_MAC: Adjust room at the mac layer (room space is added or removed below the layer 2 header). \u00b7 BPF_ADJ_ROOM_NET: Adjust room at the network layer (room space is added or removed below the layer 3 header). The following <[ flags ]>(IP: 3) are supported at this time: \u00b7 BPF_F_ADJ_ROOM_FIXED_GSO: Do not adjust gso_size. Adjusting mss in this way is not allowed for datagrams. \u00b7 BPF_F_ADJ_ROOM_ENCAP_L3_IPV4 , BPF_F_ADJ_ROOM_ENCAP_L3_IPV6: Any new space is reserved to hold a tunnel header. Configure <[ skb ]>(IP: 0) offsets and other fields accordingly. \u00b7 BPF_F_ADJ_ROOM_ENCAP_L4_GRE , BPF_F_ADJ_ROOM_ENCAP_L4_UDP: Use with ENCAP_L3 <[ flags ]>(IP: 3) to further specify the tunnel type. \u00b7 BPF_F_ADJ_ROOM_ENCAP_L2(len): Use with ENCAP_L3/L4 <[ flags ]>(IP: 3) to further specify the tunnel type; len is the length of the inner MAC header. A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_skb_adjust_room", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  s32 ,Var: len_diff}", "{Type:  u32 ,Var: mode}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["sched_cls", "sched_act"], "capabilities": ["update_pkt"]}, "bpf_redirect_map": {"Project": "libbpf", "Return Type": "int", "Description": "Redirect the packet to the endpoint referenced by <[ map ]>(IP: 0) at index key. Depending on its type , this <[ map ]>(IP: 0) can contain references to net devices (for forwarding packets through other ports) , or to CPUs (for redirecting XDP frames to another CPU; but this is only implemented for native XDP (with driver support) as of this writing). The lower two bits of <[ flags ]>(IP: 2) are used as the return code if the <[ map ]>(IP: 0) lookup fails. This is so that the return value can be one of the XDP program return codes up to XDP_TX , as chosen by the caller. Any higher bits in the <[ flags ]>(IP: 2) argument must be unset. When used to redirect packets to net devices , this helper provides a high performance increase over bpf_redirect(). This is due to various implementation details of the underlying mechanisms , one of which is the fact that bpf_redirect_map() tries to send packet as a \"bulk\" to the device. ", "Return": " XDP_REDIRECT on success, or XDP_ABORTED on error.", "Function Name": "bpf_redirect_map", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  u32 ,Var: key}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["xdp"], "capabilities": []}, "bpf_sk_redirect_map": {"Project": "libbpf", "Return Type": "int", "Description": "Redirect the packet to the socket referenced by <[ map ]>(IP: 0) (of type BPF_MAP_TYPE_SOCKMAP) at index key. Both ingress and egress interfaces can be used for redirection. The BPF_F_INGRESS value in <[ flags ]>(IP: 2) is used to make the distinction (ingress path is selected if the flag is present , egress path otherwise). This is the only flag supported for now. ", "Return": " SK_PASS on success, or SK_DROP on error.", "Function Name": "bpf_sk_redirect_map", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  u32 ,Var: key}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["sk_skb"], "capabilities": []}, "bpf_sock_map_update": {"Project": "libbpf", "Return Type": "int", "Description": "Add an entry to , or update a <[ map ]>(IP: 1) referencing sockets. The <[ skops ]>(IP: 0) is used as a new value for the entry associated to key. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 2) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 2) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. If the <[ map ]>(IP: 1) has eBPF programs (parser and verdict) , those will be inherited by the socket being added. If the socket is already attached to eBPF programs , this results in an error. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_sock_map_update", "Input Params": ["{Type: struct bpf_sock_ops ,Var: *skops}", "{Type:  struct bpf_map ,Var: *map}", "{Type:  void ,Var: *key}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["sock_ops"], "capabilities": ["map_update"]}, "bpf_xdp_adjust_meta": {"Project": "libbpf", "Return Type": "int", "Description": "Adjust the address pointed by xdp_md->data_meta by <[ delta ]>(IP: 1) (which can be positive or negative). Note that this operation modifies the address stored in xdp_md->data , so the latter must be loaded only after the helper has been called. The use of xdp_md->data_meta is optional and programs are not required to use it. The rationale is that when the packet is processed with XDP (e. g. as DoS filter) , it is possible to push further meta data along with it before passing to the stack , and to give the guarantee that an ingress eBPF program attached as a TC classifier on the same device can pick this up for further post-processing. Since TC works with socket buffers , it remains possible to set from XDP the mark or priority pointers , or other pointers for the socket buffer. Having this scratch space generic and programmable allows for more flexibility as the user is free to store whatever meta data they need. A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_xdp_adjust_meta", "Input Params": ["{Type: struct xdp_buff ,Var: *xdp_md}", "{Type:  int ,Var: delta}"], "compatible_hookpoints": ["xdp"], "capabilities": ["update_pkt"]}, "bpf_perf_event_read_value": {"Project": "libbpf", "Return Type": "int", "Description": "Read the value of a perf event counter , and store it into <[ buf ]>(IP: 2) of size buf_size. This helper relies on a <[ map ]>(IP: 0) of type BPF_MAP_TYPE_PERF_EVENT_ARRAY. The nature of the perf event counter is selected when <[ map ]>(IP: 0) is updated with perf event file descriptors. The <[ map ]>(IP: 0) is an array whose size is the number of available CPUs , and each cell contains a value relative to one CPU. The value to retrieve is indicated by <[ flags ]>(IP: 1) , that contains the index of the CPU to look up , masked with BPF_F_INDEX_MASK. Alternatively , <[ flags ]>(IP: 1) can be set to BPF_F_CURRENT_CPU to indicate that the value for the current CPU should be retrieved. This helper behaves in a way close to bpf_perf_event_read() helper , save that instead of just returning the value observed , it fills the <[ buf ]>(IP: 2) structure. This allows for additional data to be retrieved: in particular , the enabled and running times (in buf->enabled and buf->running , respectively) are copied. In general , bpf_perf_event_read_value() is recommended over bpf_perf_event_read() , which has some ABI issues and provides fewer functionalities. These values are interesting , because hardware PMU (Performance Monitoring Unit) counters are limited resources. When there are more PMU based perf events opened than available counters , kernel will multiplex these events so each event gets certain percentage (but not all) of the PMU time. In case that multiplexing happens , the number of samples or counter value will not reflect the case compared to when no multiplexing occurs. This makes comparison between different runs difficult. Typically , the counter value should be normalized before comparing to other experiments. The usual normalization is done as follows. normalized_counter = counter * t_enabled / t_running Where t_enabled is the time enabled for event and t_running is the time running for event since last normalization. The enabled and running times are accumulated since the perf event open. To achieve scaling factor between two invocations of an eBPF program , users can can use CPU id as the key (which is typical for perf array usage model) to remember the previous value and do the calculation inside the eBPF program. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_perf_event_read_value", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  u64 ,Var: flags}", "{Type:  struct bpf_perf_event_value ,Var: *buf}", "{Type:  u32 ,Var: buf_size}"], "compatible_hookpoints": ["kprobe"], "capabilities": ["read_sys_info"]}, "bpf_perf_prog_read_value": {"Project": "libbpf", "Return Type": "int", "Description": "For en eBPF program attached to a perf event , retrieve the value of the event counter associated to <[ ctx ]>(IP: 0) and store it in the structure pointed by <[ buf ]>(IP: 1) and of size buf_size. Enabled and running times are also stored in the structure (see description of helper bpf_perf_event_read_value() for more details). ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_perf_prog_read_value", "Input Params": ["{Type: struct bpf_perf_event_data ,Var: *ctx}", "{Type:  struct bpf_perf_event_value ,Var: *buf}", "{Type:  u32 ,Var: buf_size}"], "compatible_hookpoints": ["perf_event"], "capabilities": ["read_sys_info"]}, "bpf_getsockopt": {"Project": "libbpf", "Return Type": "int", "Description": "Emulate a call to getsockopt() on the socket associated to <[ bpf_socket ]>(IP: 0) , which must be a full socket. The <[ level ]>(IP: 1) at which the option resides and the name <[ optname ]>(IP: 2) of the option must be specified , see getsockopt(2) for more information. The retrieved value is stored in the structure pointed by opval and of length optlen. This helper actually implements a subset of getsockopt(). It supports the following levels: \u00b7 IPPROTO_TCP , which supports <[ optname ]>(IP: 2) TCP_CONGESTION. \u00b7 IPPROTO_IP , which supports <[ optname ]>(IP: 2) IP_TOS. \u00b7 IPPROTO_IPV6 , which supports <[ optname ]>(IP: 2) IPV6_TCLASS. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_getsockopt", "Input Params": ["{Type: struct bpf_sock_ops ,Var: *bpf_socket}", "{Type:  int ,Var: level}", "{Type:  int ,Var: optname}", "{Type:  char ,Var: *optval}", "{Type:  int ,Var: optlen}"], "compatible_hookpoints": ["sock_ops"], "capabilities": ["read_sys_info"]}, "bpf_override_return": {"Project": "bcc", "FunctionName": "bpf_override_return", "Return Type": "int", "Description": "int bpf_override_return(struct pt_regs *, unsigned long rc) Return: 0 on success When used in a program attached to a function entry kprobe, causes theexecution of the function to be skipped, immediately returning rc instead.This is used for targeted error injection. bpf_override_return will only work when the kprobed function is whitelisted toallow error injections. Whitelisting entails tagging a function withALLOW_ERROR_INJECTION in the kernel source tree; see io_ctl_init foran example. If the kprobed function is not whitelisted, the bpf program willfail to attach with ioctl(PERF_EVENT_IOC_SET_BPF): Invalid argument Cint kprobe__io_ctl_init(void *ctx) {    bpf_override_return(ctx, -ENOMEM);    return 0;}", "Return": " 0 on success", "Input Prameters": ["{Type: struct pt_regs * ,Var: }", "{Type: unsigned long ,Var: rc}"], "compatible_hookpoints": ["kprobe"], "capabilities": []}, "bpf_sock_ops_cb_flags_set": {"Project": "libbpf", "Return Type": "int", "Description": "Attempt to set the value of the bpf_sock_ops_cb_flags field for the full TCP socket associated to bpf_sock_ops to argval. The primary use of this field is to determine if there should be calls to eBPF programs of type BPF_PROG_TYPE_SOCK_OPS at various points in the TCP code. A program of the same type can change its value , per connection and as necessary , when the connection is established. This field is directly accessible for reading , but this helper must be used for updates in order to return an error if an eBPF program tries to set a callback that is not supported in the current kernel. <[ argval ]>(IP: 1) is a flag array which can combine these flags: \u00b7 BPF_SOCK_OPS_RTO_CB_FLAG (retransmission time out) \u00b7 BPF_SOCK_OPS_RETRANS_CB_FLAG (retransmission) \u00b7 BPF_SOCK_OPS_STATE_CB_FLAG (TCP state change) \u00b7 BPF_SOCK_OPS_RTT_CB_FLAG (every RTT) Therefore , this function can be used to clear a callback flag by setting the appropriate bit to zero. e. g. to disable the RTO callback: bpf_sock_ops_cb_flags_set(bpf_sock , bpf_sock->bpf_sock_ops_cb_flags & ~BPF_SOCK_OPS_RTO_CB_FLAG) Here are some examples of where one could call such eBPF program: \u00b7 When RTO fires. \u00b7 When a packet is retransmitted. \u00b7 When the connection terminates. \u00b7 When a packet is sent. \u00b7 When a packet is received. ", "Return": " Code -EINVAL if the socket is not a full TCP socket; otherwise,  a  positive                     number  containing  the  bits that could not be set is returned (which comes                     down to 0 if all bits were set as required).", "Function Name": "bpf_sock_ops_cb_flags_set", "Input Params": ["{Type: struct bpf_sock_ops ,Var: *bpf_sock}", "{Type:  int ,Var: argval}"], "compatible_hookpoints": ["sock_ops"], "capabilities": ["update_pkt"]}, "bpf_msg_redirect_map": {"Project": "libbpf", "Return Type": "int", "Description": "This helper is used in programs implementing policies at the socket level. If the message <[ msg ]>(IP: 0) is allowed to pass (i. e. if the verdict eBPF program returns SK_PASS) , redirect it to the socket referenced by <[ map ]>(IP: 1) (of type BPF_MAP_TYPE_SOCKMAP) at index key. Both ingress and egress interfaces can be used for redirection. The BPF_F_INGRESS value in <[ flags ]>(IP: 3) is used to make the distinction (ingress path is selected if the flag is present , egress path otherwise). This is the only flag supported for now. ", "Return": " SK_PASS on success, or SK_DROP on error.", "Function Name": "bpf_msg_redirect_map", "Input Params": ["{Type: struct sk_msg_buff ,Var: *msg}", "{Type:  struct bpf_map ,Var: *map}", "{Type:  u32 ,Var: key}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["sk_msg"], "capabilities": []}, "bpf_msg_apply_bytes": {"Project": "libbpf", "Return Type": "int", "Description": "For socket policies , apply the verdict of the eBPF program to the next <[ bytes ]>(IP: 1) (number of bytes) of message msg. For example , this helper can be used in the following cases: \u00b7 A single sendmsg() or sendfile() system call contains multiple logical messages that the eBPF program is supposed to read and for which it should apply a verdict. \u00b7 An eBPF program only cares to read the first <[ bytes ]>(IP: 1) of a msg. If the message has a large payload , then setting up and calling the eBPF program repeatedly for all <[ bytes ]>(IP: 1) , even though the verdict is already known , would create unnecessary overhead. When called from within an eBPF program , the helper sets a counter internal to the BPF infrastructure , that is used to apply the last verdict to the next bytes. If <[ bytes ]>(IP: 1) is smaller than the current data being processed from a sendmsg() or sendfile() system call , the first <[ bytes ]>(IP: 1) will be sent and the eBPF program will be re-run with the pointer for start of data pointing to byte number <[ bytes ]>(IP: 1) + 1. If <[ bytes ]>(IP: 1) is larger than the current data being processed , then the eBPF verdict will be applied to multiple sendmsg() or sendfile() calls until <[ bytes ]>(IP: 1) are consumed. Note that if a socket closes with the internal counter holding a non-zero value , this is not a problem because data is not being buffered for <[ bytes ]>(IP: 1) and is sent as it is received. ", "Return": " 0", "Function Name": "bpf_msg_apply_bytes", "Input Params": ["{Type: struct sk_msg_buff ,Var: *msg}", "{Type:  u32 ,Var: bytes}"], "compatible_hookpoints": ["sk_msg"], "capabilities": []}, "bpf_msg_cork_bytes": {"Project": "libbpf", "Return Type": "int", "Description": "For socket policies , prevent the execution of the verdict eBPF program for message <[ msg ]>(IP: 0) until <[ bytes ]>(IP: 1) (byte number) have been accumulated. This can be used when one needs a specific number of <[ bytes ]>(IP: 1) before a verdict can be assigned , even if the data spans multiple sendmsg() or sendfile() calls. The extreme case would be a user calling sendmsg() repeatedly with 1-byte long message segments. Obviously , this is bad for performance , but it is still valid. If the eBPF program needs <[ bytes ]>(IP: 1) bytes to validate a header , this helper can be used to prevent the eBPF program to be called again until <[ bytes ]>(IP: 1) have been accumulated. ", "Return": " 0", "Function Name": "bpf_msg_cork_bytes", "Input Params": ["{Type: struct sk_msg_buff ,Var: *msg}", "{Type:  u32 ,Var: bytes}"], "compatible_hookpoints": ["sk_msg"], "capabilities": []}, "bpf_msg_pull_data": {"Project": "libbpf", "Return Type": "int", "Description": "For socket policies , pull in non-linear data from user space for <[ msg ]>(IP: 0) and set pointers msg->data and msg->data_end to <[ start ]>(IP: 1) and <[ end ]>(IP: 2) bytes offsets into <[ msg ]>(IP: 0) , respectively. If a program of type BPF_PROG_TYPE_SK_MSG is run on a <[ msg ]>(IP: 0) it can only parse data that the (data , data_end) pointers have already consumed. For sendmsg() hooks this is likely the first scatterlist element. But for calls relying on the sendpage handler (e. g. sendfile()) this will be the range (0 , 0) because the data is shared with user space and by default the objective is to avoid allowing user space to modify data while (or after) eBPF verdict is being decided. This helper can be used to pull in data and to set the <[ start ]>(IP: 1) and <[ end ]>(IP: 2) pointer to given values. Data will be copied if necessary (i. e. if data was not linear and if <[ start ]>(IP: 1) and <[ end ]>(IP: 2) pointers do not point to the same chunk). A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. All values for <[ flags ]>(IP: 3) are reserved for future usage , and must be left at zero. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_msg_pull_data", "Input Params": ["{Type: struct sk_msg_buff ,Var: *msg}", "{Type:  u32 ,Var: start}", "{Type:  u32 ,Var: end}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["sk_msg"], "capabilities": ["update_pkt"]}, "bpf_bind": {"Project": "libbpf", "Return Type": "int", "Description": "Bind the socket associated to <[ ctx ]>(IP: 0) to the address pointed by <[ addr ]>(IP: 1) , of length addr_len. This allows for making outgoing connection from the desired IP address , which can be useful for example when all processes inside a cgroup should use one single IP address on a host that has multiple IP configured. This helper works for IPv4 and IPv6 , TCP and UDP sockets. The domain (addr->sa_family) must be AF_INET (or AF_INET6). Looking for a free port to bind to can be expensive , therefore binding to port is not permitted by the helper: addr->sin_port (or sin6_port , respectively) must be set to zero. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_bind", "Input Params": ["{Type: struct bpf_sock_addr ,Var: *ctx}", "{Type:  struct sockaddr ,Var: *addr}", "{Type:  int ,Var: addr_len}"], "compatible_hookpoints": ["cgroup_sock_addr"], "capabilities": []}, "bpf_xdp_adjust_tail": {"Project": "libbpf", "Return Type": "int", "Description": "Adjust (move) xdp_md->data_end by <[ delta ]>(IP: 1) bytes. It is only possible to shrink the packet as of this writing , therefore <[ delta ]>(IP: 1) must be a negative integer. A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_xdp_adjust_tail", "Input Params": ["{Type: struct xdp_buff ,Var: *xdp_md}", "{Type:  int ,Var: delta}"], "compatible_hookpoints": ["xdp"], "capabilities": ["update_pkt"]}, "bpf_skb_get_xfrm_state": {"Project": "libbpf", "Return Type": "int", "Description": "Retrieve the XFRM state (IP transform framework , see also ip-xfrm(8)) at <[ index ]>(IP: 1) in XFRM \"security path\" for skb. The retrieved value is stored in the struct bpf_xfrm_state pointed by <[ xfrm_state ]>(IP: 2) and of length size. All values for <[ flags ]>(IP: 4) are reserved for future usage , and must be left at zero. This helper is available only if the kernel was compiled with CONFIG_XFRM configuration option. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_skb_get_xfrm_state", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  u32 ,Var: index}", "{Type:  struct bpf_xfrm_state ,Var: *xfrm_state}", "{Type:  u32 ,Var: size}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["sched_cls", "sched_act"], "capabilities": ["read_skb", "read_sys_info"]}, "bpf_get_stack": {"Project": "libbpf", "Return Type": "int", "Description": "Return a user or a kernel stack in bpf program provided buffer. To achieve this , the helper needs ctx , which is a pointer to the context on which the tracing program is executed. To store the stacktrace , the bpf program provides <[ buf ]>(IP: 1) with a nonnegative size. The last argument , <[ flags ]>(IP: 3) , holds the number of stack frames to skip (from 0 to 255) , masked with BPF_F_SKIP_FIELD_MASK. The next bits can be used to set the following flags: BPF_F_USER_STACK Collect a user space stack instead of a kernel stack. BPF_F_USER_BUILD_ID Collect buildid+offset instead of ips for user stack , only valid if BPF_F_USER_STACK is also specified. bpf_get_stack() can collect up to PERF_MAX_STACK_DEPTH both kernel and user frames , subject to sufficient large buffer size. Note that this limit can be controlled with the sysctl program , and that it should be manually increased in order to profile long user stacks (such as stacks for Java programs). To do so , use: # sysctl kernel. perf_event_max_stack=<new value> ", "Return": " A non-negative value equal to or less than size on success,  or  a  negative                     error in case of failure.", "Function Name": "bpf_get_stack", "Input Params": ["{Type: struct pt_regs ,Var: *regs}", "{Type:  void ,Var: *buf}", "{Type:  u32 ,Var: size}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["kprobe", "tracepoint", "perf_event", "raw_tracepoint", "raw_tracepoint_writable"], "capabilities": ["read_sys_info"]}, "bpf_skb_load_bytes_relative": {"Project": "libbpf", "Return Type": "int", "Description": "This helper is similar <[ to ]>(IP: 2) bpf_skb_load_bytes() in that it provides an easy way <[ to ]>(IP: 2) load <[ len ]>(IP: 3) bytes from <[ offset ]>(IP: 1) from the packet associated <[ to ]>(IP: 2) <[ skb ]>(IP: 0) , into the buffer pointed by to. The difference <[ to ]>(IP: 2) bpf_skb_load_bytes() is that a fifth argument <[ start_header ]>(IP: 4) exists in order <[ to ]>(IP: 2) select a base <[ offset ]>(IP: 1) <[ to ]>(IP: 2) start from. <[ start_header ]>(IP: 4) can be one of: BPF_HDR_START_MAC Base <[ offset ]>(IP: 1) <[ to ]>(IP: 2) load data from is skb's mac header. BPF_HDR_START_NET Base <[ offset ]>(IP: 1) <[ to ]>(IP: 2) load data from is skb's network header. In general , \"direct packet access\" is the preferred method <[ to ]>(IP: 2) access packet data , however , this helper is in particular useful in socket filters where skb->data does not always point <[ to ]>(IP: 2) the start of the mac header and where \"direct packet access\" is not available. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_skb_load_bytes_relative", "Input Params": ["{Type: const struct sk_buff ,Var: *skb}", "{Type:  u32 ,Var: offset}", "{Type:  void ,Var: *to}", "{Type:  u32 ,Var: len}", "{Type:  u32 ,Var: start_header}"], "compatible_hookpoints": ["socket_filter", "sched_cls", "sched_act", "cgroup_skb", "sk_reuseport"], "capabilities": ["read_skb"]}, "bpf_fib_lookup": {"Project": "libbpf", "Return Type": "int", "Description": "Do FIB lookup in kernel tables using parameters in params. If lookup is successful and result shows packet is to be forwarded , the neighbor tables are searched for the nexthop. If successful (ie. , FIB lookup shows forwarding and nexthop is resolved) , the nexthop address is returned in ipv4_dst or ipv6_dst based on family , smac is set to mac address of egress device , dmac is set to nexthop mac address , rt_metric is set to metric from route (IPv4/IPv6 only) , and ifindex is set to the device index of the nexthop from the FIB lookup. <[ plen ]>(IP: 2) argument is the size of the passed in struct. <[ flags ]>(IP: 3) argument can be a combination of one or more of the following values: BPF_FIB_LOOKUP_DIRECT Do a direct table lookup vs full lookup using FIB rules. BPF_FIB_LOOKUP_OUTPUT Perform lookup from an egress perspective (default is ingress). <[ ctx ]>(IP: 0) is either struct xdp_md for XDP programs or struct sk_buff tc cls_act programs. Return \u00b7 < 0 if any input argument is invalid \u00b7 0 on success (packet is forwarded , nexthop neighbor exists) \u00b7 > 0 one of BPF_FIB_LKUP_RET_ codes explaining why the packet is not forwarded or needs assist from full stack ", "Function Name": "bpf_fib_lookup", "Input Params": ["{Type: void ,Var: *ctx}", "{Type:  struct bpf_fib_lookup ,Var: *params}", "{Type:  int ,Var: plen}", "{Type:  u32 ,Var: flags}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp"], "capabilities": ["read_sys_info"]}, "bpf_sock_hash_update": {"Project": "libbpf", "Return Type": "int", "Description": "Add an entry to , or update a sockhash <[ map ]>(IP: 1) referencing sockets. The <[ skops ]>(IP: 0) is used as a new value for the entry associated to key. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 2) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 2) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. If the <[ map ]>(IP: 1) has eBPF programs (parser and verdict) , those will be inherited by the socket being added. If the socket is already attached to eBPF programs , this results in an error. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_sock_hash_update", "Input Params": ["{Type: struct bpf_sock_ops_kern ,Var: *skops}", "{Type:  struct bpf_map ,Var: *map}", "{Type:  void ,Var: *key}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["sock_ops"], "capabilities": []}, "bpf_msg_redirect_hash": {"Project": "libbpf", "Return Type": "int", "Description": "This helper is used in programs implementing policies at the socket level. If the message <[ msg ]>(IP: 0) is allowed to pass (i. e. if the verdict eBPF program returns SK_PASS) , redirect it to the socket referenced by <[ map ]>(IP: 1) (of type BPF_MAP_TYPE_SOCKHASH) using hash key. Both ingress and egress interfaces can be used for redirection. The BPF_F_INGRESS value in <[ flags ]>(IP: 3) is used to make the distinction (ingress path is selected if the flag is present , egress path otherwise). This is the only flag supported for now. ", "Return": " SK_PASS on success, or SK_DROP on error.", "Function Name": "bpf_msg_redirect_hash", "Input Params": ["{Type: struct sk_msg_buff ,Var: *msg}", "{Type:  struct bpf_map ,Var: *map}", "{Type:  void ,Var: *key}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["sk_msg"], "capabilities": []}, "bpf_sk_redirect_hash": {"Project": "libbpf", "Return Type": "int", "Description": "This helper is used in programs implementing policies at the <[ skb ]>(IP: 0) socket level. If the sk_buff <[ skb ]>(IP: 0) is allowed to pass (i. e. if the verdeict eBPF program returns SK_PASS) , redirect it to the socket referenced by <[ map ]>(IP: 1) (of type BPF_MAP_TYPE_SOCKHASH) using hash key. Both ingress and egress interfaces can be used for redirection. The BPF_F_INGRESS value in <[ flags ]>(IP: 3) is used to make the distinction (ingress path is selected if the flag is present , egress otherwise). This is the only flag supported for now. ", "Return": " SK_PASS on success, or SK_DROP on error.", "Function Name": "bpf_sk_redirect_hash", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  struct bpf_map ,Var: *map}", "{Type:  void ,Var: *key}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["sk_skb"], "capabilities": []}, "bpf_lwt_push_encap": {"Project": "libbpf", "Return Type": "int", "Description": "Encapsulate the packet associated to <[ skb ]>(IP: 0) within a Layer 3 protocol header. This header is provided in the buffer at address <[ hdr ]>(IP: 2) , with <[ len ]>(IP: 3) its size in bytes. <[ type ]>(IP: 1) indicates the protocol of the header and can be one of: BPF_LWT_ENCAP_SEG6 IPv6 encapsulation with Segment Routing Header (struct ipv6_sr_hdr). <[ hdr ]>(IP: 2) only contains the SRH , the IPv6 header is computed by the kernel. BPF_LWT_ENCAP_SEG6_INLINE Only works if <[ skb ]>(IP: 0) contains an IPv6 packet. Insert a Segment Routing Header (struct ipv6_sr_hdr) inside the IPv6 header. BPF_LWT_ENCAP_IP IP encapsulation (GRE/GUE/IPIP/etc). The outer header must be IPv4 or IPv6 , followed by zero or more additional headers , up to LWT_BPF_MAX_HEADROOM total bytes in all prepended headers. Please note that if skb_is_gso(skb) is true , no more than two headers can be prepended , and the inner header , if present , should be either GRE or UDP/GUE. BPF_LWT_ENCAP_SEG6* types can be called by BPF programs of <[ type ]>(IP: 1) BPF_PROG_TYPE_LWT_IN; BPF_LWT_ENCAP_IP <[ type ]>(IP: 1) can be called by bpf programs of types BPF_PROG_TYPE_LWT_IN and BPF_PROG_TYPE_LWT_XMIT. A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_lwt_push_encap", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  u32 ,Var: type}", "{Type:  void ,Var: *hdr}", "{Type:  u32 ,Var: len}"], "compatible_hookpoints": ["lwt_in", "lwt_xmit"], "capabilities": ["update_pkt"]}, "bpf_lwt_seg6_store_bytes": {"Project": "libbpf", "Return Type": "int", "Description": "Store <[ len ]>(IP: 3) bytes <[ from ]>(IP: 2) address <[ from ]>(IP: 2) into the packet associated to <[ skb ]>(IP: 0) , at offset. Only the flags , tag and TLVs inside the outermost IPv6 Segment Routing Header can be modified through this helper. A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_lwt_seg6_store_bytes", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  u32 ,Var: offset}", "{Type:  const void ,Var: *from}", "{Type:  u32 ,Var: len}"], "compatible_hookpoints": ["lwt_seg6local"], "capabilities": ["update_pkt"]}, "bpf_lwt_seg6_adjust_srh": {"Project": "libbpf", "Return Type": "int", "Description": "Adjust the size allocated to TLVs in the outermost IPv6 Segment Routing Header contained in the packet associated to <[ skb ]>(IP: 0) , at position <[ offset ]>(IP: 1) by <[ delta ]>(IP: 2) bytes. Only offsets after the segments are accepted. <[ delta ]>(IP: 2) can be as well positive (growing) as negative (shrinking). A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_lwt_seg6_adjust_srh", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  u32 ,Var: offset}", "{Type:  s32 ,Var: delta}"], "compatible_hookpoints": ["lwt_seg6local"], "capabilities": ["update_pkt"]}, "bpf_lwt_seg6_action": {"Project": "libbpf", "Return Type": "int", "Description": "Apply an IPv6 Segment Routing <[ action ]>(IP: 1) of type <[ action ]>(IP: 1) to the packet associated to skb. Each <[ action ]>(IP: 1) takes a parameter contained at address <[ param ]>(IP: 2) , and of length <[ param_len ]>(IP: 3) bytes. <[ action ]>(IP: 1) can be one of: SEG6_LOCAL_ACTION_END_X End. X action: Endpoint with Layer-3 cross-connect. Type of param: struct in6_addr. SEG6_LOCAL_ACTION_END_T End. T action: Endpoint with specific IPv6 table lookup. Type of param: int. SEG6_LOCAL_ACTION_END_B6 End. B6 action: Endpoint bound to an SRv6 policy. Type of param: struct ipv6_sr_hdr. SEG6_LOCAL_ACTION_END_B6_ENCAP End. B6. Encap action: Endpoint bound to an SRv6 encapsulation policy. Type of param: struct ipv6_sr_hdr. A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_lwt_seg6_action", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  u32 ,Var: action}", "{Type:  void ,Var: *param}", "{Type:  u32 ,Var: param_len}"], "compatible_hookpoints": ["lwt_seg6local"], "capabilities": ["update_pkt"]}, "bpf_rc_repeat": {"Project": "libbpf", "Return Type": "int", "Description": "This helper is used in programs implementing IR decoding , to report a successfully decoded repeat key message. This delays the generation of a key up event for previously generated key down event. Some IR protocols like NEC have a special IR message for repeating last button , for when a button is held down. The <[ ctx ]>(IP: 0) should point to the lirc sample as passed into the program. This helper is only available is the kernel was compiled with the CONFIG_BPF_LIRC_MODE2 configuration option set to \"y\". ", "Return": " 0", "Function Name": "bpf_rc_repeat", "Input Params": ["{Type: void ,Var: *ctx}"], "capabilities": []}, "bpf_rc_keydown": {"Project": "libbpf", "Return Type": "int", "Description": "This helper is used in programs implementing IR decoding , to report a successfully decoded key press with <[ scancode ]>(IP: 2) , <[ toggle ]>(IP: 3) value in the given protocol. The <[ scancode ]>(IP: 2) will be translated to a keycode using the rc keymap , and reported as an input key down event. After a period a key up event is generated. This period can be extended by calling either bpf_rc_keydown() again with the same values , or calling bpf_rc_repeat(). Some protocols include a <[ toggle ]>(IP: 3) bit , in case the button was released and pressed again between consecutive scancodes. The <[ ctx ]>(IP: 0) should point to the lirc sample as passed into the program. The <[ protocol ]>(IP: 1) is the decoded <[ protocol ]>(IP: 1) number (see enum rc_proto for some predefined values). This helper is only available is the kernel was compiled with the CONFIG_BPF_LIRC_MODE2 configuration option set to \"y\". ", "Return": " 0", "Function Name": "bpf_rc_keydown", "Input Params": ["{Type: void ,Var: *ctx}", "{Type:  u32 ,Var: protocol}", "{Type:  u64 ,Var: scancode}", "{Type:  u32 ,Var: toggle}"], "capabilities": []}, "bpf_skb_cgroup_id": {"Project": "libbpf", "Return Type": "u64", "Description": "Return the cgroup v2 id of the socket associated with the skb. This is roughly similar to the bpf_get_cgroup_classid() helper for cgroup v1 by providing a tag resp. identifier that can be matched on or used for map lookups e. g. to implement policy. The cgroup v2 id of a given path in the hierarchy is exposed in user space through the f_handle API in order to get to the same 64-bit id. This helper can be used on TC egress path , but not on ingress , and is available only if the kernel was compiled with the CONFIG_SOCK_CGROUP_DATA configuration option. ", "Return": " The id is returned or 0 in case the id could not be retrieved.", "Function Name": "bpf_skb_cgroup_id", "Input Params": ["{Type: struct sk_buff ,Var: *skb}"], "compatible_hookpoints": ["sched_cls", "sched_act", "cgroup_skb"], "capabilities": ["read_skb", "read_sys_info"]}, "bpf_get_current_cgroup_id": {"Project": "libbpf", "Return Type": "u64", "Return": " A 64-bit integer containing the current cgroup id based on the cgroup within                     which the current task is running.", "Function Name": "bpf_get_current_cgroup_id", "Input Params": ["{Type: voi ,Var: void}"], "Description": "A 64-bit integer containing the current cgroup id based on the cgroup within which the current task is running. ", "compatible_hookpoints": ["kprobe", "tracepoint", "perf_event", "cgroup_device", "raw_tracepoint", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["read_sys_info"]}, "bpf_get_local_storage": {"Project": "libbpf", "Return Type": "void", "Description": "Get the pointer to the local storage area. The type and the size of the local storage is defined by the <[ map ]>(IP: 0) argument. The <[ flags ]>(IP: 1) meaning is specific for each <[ map ]>(IP: 0) type , and has to be 0 for cgroup local storage. Depending on the BPF program type , a local storage area can be shared between multiple instances of the BPF program , running simultaneously. A user should care about the synchronization by himself. For example , by using the BPF_STX_XADD instruction to alter the shared data. ", "Return": " A pointer to the local storage area.", "Function Name": "bpf_get_local_storage", "Input Params": ["{Type: void ,Var: *map}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["cgroup_skb", "cgroup_sock", "sock_ops", "cgroup_device", "cgroup_sock_addr", "cgroup_sysctl"], "capabilities": ["read_sys_info"]}, "bpf_sk_select_reuseport": {"Project": "libbpf", "Return Type": "int*", "Description": "Select a SO_REUSEPORT socket from a BPF_MAP_TYPE_REUSEPORT_ARRAY map. It checks the selected socket is matching the incoming request in the socket buffer. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_sk_select_reuseport", "Input Params": ["{Type: struct sk_reuseport_md ,Var: *reuse}", "{Type:  struct bpf_map ,Var: *map}", "{Type:  void ,Var: *key}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["sk_reuseport"], "capabilities": []}, "bpf_skb_ancestor_cgroup_id": {"Project": "libbpf", "Return Type": "u64", "Description": "Return id of cgroup v2 that is ancestor of cgroup associated with the <[ skb ]>(IP: 0) at the ancestor_level. The root cgroup is at <[ ancestor_level ]>(IP: 1) zero and each step down the hierarchy increments the level. If <[ ancestor_level ]>(IP: 1) == level of cgroup associated with <[ skb ]>(IP: 0) , then return value will be same as that of bpf_skb_cgroup_id(). The helper is useful to implement policies based on cgroups that are upper in hierarchy than immediate cgroup associated with skb. The format of returned id and helper limitations are same as in bpf_skb_cgroup_id(). ", "Return": " The id is returned or 0 in case the id could not be retrieved.", "Function Name": "bpf_skb_ancestor_cgroup_id", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  int ,Var: ancestor_level}"], "compatible_hookpoints": ["sched_cls", "sched_act"], "capabilities": ["read_skb", "read_sys_info"]}, "bpf_sk_lookup_tcp": {"Project": "libbpf", "Return Type": "struct bpf_sock*", "Description": "Look for TCP socket matching <[ tuple ]>(IP: 1) , optionally in a child network namespace netns. The return value must be checked , and if non-NULL , released via bpf_sk_release(). The <[ ctx ]>(IP: 0) should point to the context of the program , such as the skb or socket (depending on the hook in use). This is used to determine the base network namespace for the lookup. <[ tuple_size ]>(IP: 2) must be one of: sizeof(tuple->ipv4) Look for an IPv4 socket. sizeof(tuple->ipv6) Look for an IPv6 socket. If the <[ netns ]>(IP: 3) is a negative signed 32-bit integer , then the socket lookup table in the <[ netns ]>(IP: 3) associated with the <[ ctx ]>(IP: 0) will will be used. For the TC hooks , this is the <[ netns ]>(IP: 3) of the device in the skb. For socket hooks , this is the <[ netns ]>(IP: 3) of the socket. If <[ netns ]>(IP: 3) is any other signed 32-bit value greater than or equal to zero then it specifies the ID of the <[ netns ]>(IP: 3) relative to the <[ netns ]>(IP: 3) associated with the ctx. <[ netns ]>(IP: 3) values beyond the range of 32-bit integers are reserved for future use. All values for <[ flags ]>(IP: 4) are reserved for future usage , and must be left at zero. This helper is available only if the kernel was compiled with CONFIG_NET configuration option. ", "Return": " Pointer to struct  bpf_sock, or NULL in case of failure.   For  sockets  with                     reuseport  option,  the  struct  bpf_sock result is from reuse->socks[] using                     the hash of the tuple.", "Function Name": "bpf_sk_lookup_tcp", "Input Params": ["{Type: void ,Var: *ctx}", "{Type:  struct bpf_sock_tuple ,Var: *tuple}", "{Type:  u32 ,Var: tuple_size}", "{Type:  u64 ,Var: netns}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp", "sk_skb", "cgroup_sock_addr"], "capabilities": ["read_sys_info"]}, "bpf_sk_lookup_udp": {"Project": "libbpf", "Return Type": "struct bpf_sock*", "Description": "Look for UDP socket matching <[ tuple ]>(IP: 1) , optionally in a child network namespace netns. The return value must be checked , and if non-NULL , released via bpf_sk_release(). The <[ ctx ]>(IP: 0) should point to the context of the program , such as the skb or socket (depending on the hook in use). This is used to determine the base network namespace for the lookup. <[ tuple_size ]>(IP: 2) must be one of: sizeof(tuple->ipv4) Look for an IPv4 socket. sizeof(tuple->ipv6) Look for an IPv6 socket. If the <[ netns ]>(IP: 3) is a negative signed 32-bit integer , then the socket lookup table in the <[ netns ]>(IP: 3) associated with the <[ ctx ]>(IP: 0) will will be used. For the TC hooks , this is the <[ netns ]>(IP: 3) of the device in the skb. For socket hooks , this is the <[ netns ]>(IP: 3) of the socket. If <[ netns ]>(IP: 3) is any other signed 32-bit value greater than or equal to zero then it specifies the ID of the <[ netns ]>(IP: 3) relative to the <[ netns ]>(IP: 3) associated with the ctx. <[ netns ]>(IP: 3) values beyond the range of 32-bit integers are reserved for future use. All values for <[ flags ]>(IP: 4) are reserved for future usage , and must be left at zero. This helper is available only if the kernel was compiled with CONFIG_NET configuration option. ", "Return": " Pointer  to  struct  bpf_sock, or NULL in case of failure.  For sockets with                     reuseport option, the struct  bpf_sock result is  from  reuse->socks[]  using                     the hash of the tuple.", "Function Name": "bpf_sk_lookup_udp", "Input Params": ["{Type: void ,Var: *ctx}", "{Type:  struct bpf_sock_tuple ,Var: *tuple}", "{Type:  u32 ,Var: tuple_size}", "{Type:  u64 ,Var: netns}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp", "sk_skb", "cgroup_sock_addr"], "capabilities": ["read_sys_info"]}, "bpf_sk_release": {"Project": "libbpf", "Return Type": "int", "Description": "Release the reference held by sock. <[ sock ]>(IP: 0) must be a non-NULL pointer that was returned from bpf_sk_lookup_xxx(). ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_sk_release", "Input Params": ["{Type: struct bpf_sock ,Var: *sock}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp", "sk_skb", "cgroup_sock_addr"], "capabilities": []}, "bpf_map_push_elem": {"Project": "libbpf", "Return Type": "int", "Description": "Push an element <[ value ]>(IP: 1) in map. <[ flags ]>(IP: 2) is one of: BPF_EXIST If the queue/stack is full , the oldest element is removed to make room for this. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_map_push_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *value}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_update"]}, "bpf_map_pop_elem": {"Project": "libbpf", "Return Type": "int", "Description": "Pop an element from map. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_map_pop_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  void ,Var: *value}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read", "map_update"]}, "bpf_map_peek_elem": {"Project": "libbpf", "Return Type": "int", "Description": "Get an element from <[ map ]>(IP: 0) without removing it. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_map_peek_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  void ,Var: *value}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}, "bpf_msg_push_data": {"Project": "libbpf", "Return Type": "int", "Description": "For socket policies , insert <[ len ]>(IP: 2) bytes into msg at offset start. If a program of type BPF_PROG_TYPE_SK_MSG is run on a msg it may want to insert metadata or options into the msg. This can later be read and used by any of the lower layer BPF hooks. This helper may fail if under memory pressure (a malloc fails) in these cases BPF programs will get an appropriate error and BPF programs will need to handle them. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_msg_push_data", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  u32 ,Var: start}", "{Type:  u32 ,Var: len}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["sk_msg"], "capabilities": ["update_pkt"]}, "bpf_msg_pop_data": {"Project": "libbpf", "Return Type": "int", "Description": "Will remove <[ pop ]>(IP: 2) bytes from a <[ msg ]>(IP: 0) starting at byte start. This may result in ENOMEM errors under certain situations if an allocation and copy are required due to a full ring buffer. However , the helper will try to avoid doing the allocation if possible. Other errors can occur if input parameters are invalid either due to <[ start ]>(IP: 1) byte not being valid part of <[ msg ]>(IP: 0) payload and/or <[ pop ]>(IP: 2) value being to large. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_msg_pop_data", "Input Params": ["{Type: struct sk_msg_buff ,Var: *msg}", "{Type:  u32 ,Var: start}", "{Type:  u32 ,Var: pop}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["sk_msg"], "capabilities": ["update_pkt"]}, "bpf_rc_pointer_rel": {"Project": "libbpf", "Return Type": "int", "Description": "This helper is used in programs implementing IR decoding , to report a successfully decoded pointer movement. The <[ ctx ]>(IP: 0) should point to the lirc sample as passed into the program. This helper is only available is the kernel was compiled with the CONFIG_BPF_LIRC_MODE2 configuration option set to \"y\". ", "Return": " 0", "Function Name": "bpf_rc_pointer_rel", "Input Params": ["{Type: void ,Var: *ctx}", "{Type:  s32 ,Var: rel_x}", "{Type:  s32 ,Var: rel_y}"], "capabilities": []}, "bpf_spin_lock": {"Project": "libbpf", "Return Type": "int", "Description": "Acquire a spinlock represented by the pointer <[ lock ]>(IP: 0) , which is stored as part of a value of a map. Taking the <[ lock ]>(IP: 0) allows to safely update the rest of the fields in that value. The spinlock can (and must) later be released with a call to bpf_spin_unlock(lock). Spinlocks in BPF programs come with a number of restrictions and constraints: \u00b7 bpf_spin_lock objects are only allowed inside maps of types BPF_MAP_TYPE_HASH and BPF_MAP_TYPE_ARRAY (this list could be extended in the future). \u00b7 BTF description of the map is mandatory. \u00b7 The BPF program can take ONE <[ lock ]>(IP: 0) at a time , since taking two or more could cause dead locks. \u00b7 Only one struct bpf_spin_lock is allowed per map element. \u00b7 When the <[ lock ]>(IP: 0) is taken , calls (either BPF to BPF or helpers) are not allowed. \u00b7 The BPF_LD_ABS and BPF_LD_IND instructions are not allowed inside a spinlock-ed region. \u00b7 The BPF program MUST call bpf_spin_unlock() to release the <[ lock ]>(IP: 0) , on all execution paths , before it returns. \u00b7 The BPF program can access struct bpf_spin_lock only via the bpf_spin_lock() and bpf_spin_unlock() helpers. Loading or storing data into the struct bpf_spin_lock lock; field of a map is not allowed. \u00b7 To use the bpf_spin_lock() helper , the BTF description of the map value must be a struct and have struct bpf_spin_lock anyname; field at the top level. Nested <[ lock ]>(IP: 0) inside another struct is not allowed. \u00b7 The struct bpf_spin_lock <[ lock ]>(IP: 0) field in a map value must be aligned on a multiple of 4 bytes in that value. \u00b7 Syscall with command BPF_MAP_LOOKUP_ELEM does not copy the bpf_spin_lock field to user space. \u00b7 Syscall with command BPF_MAP_UPDATE_ELEM , or update from a BPF program , do not update the bpf_spin_lock field. \u00b7 bpf_spin_lock cannot be on the stack or inside a networking packet (it can only be inside of a map values). \u00b7 bpf_spin_lock is available to root only. \u00b7 Tracing programs and socket filter programs cannot use bpf_spin_lock() due to insufficient preemption checks (but this may change in the future). bpf_spin_lock is not allowed in inner maps of map-in-map. ", "Return": " 0", "Function Name": "bpf_spin_lock", "Input Params": ["{Type: struct bpf_spin_lock ,Var: *lock}"], "compatible_hookpoints": ["socket_filter", "sched_cls", "sched_act", "xdp", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "sk_msg", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector"], "capabilities": []}, "bpf_spin_unlock": {"Project": "libbpf", "Return Type": "int", "Description": "Release the <[ lock ]>(IP: 0) previously locked by a call to bpf_spin_lock(lock). ", "Return": " 0", "Function Name": "bpf_spin_unlock", "Input Params": ["{Type: struct bpf_spin_lock ,Var: *lock}"], "compatible_hookpoints": ["socket_filter", "sched_cls", "sched_act", "xdp", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "sk_msg", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector"], "capabilities": []}, "bpf_sk_fullsock": {"Project": "libbpf", "Return Type": "struct bpf_sock*", "Description": "This helper gets a struct bpf_sock pointer such that all the fields in this bpf_sock can be accessed. ", "Return": " A struct  bpf_sock pointer on success, or NULL in case of failure.", "Function Name": "bpf_sk_fullsock", "Input Params": ["{Type: struct bpf_sock ,Var: *sk}"], "compatible_hookpoints": ["sched_cls", "sched_act", "cgroup_skb"], "capabilities": []}, "bpf_tcp_sock": {"Project": "libbpf", "Return Type": "struct", "Description": "This helper gets a struct bpf_tcp_sock pointer from a struct bpf_sock pointer. ", "Return": "A struct  bpf_tcp_sock pointer on success, or NULL in case of failure.", "Function Name": "bpf_tcp_sock *bpf_tcp_sock", "Input Params": ["{Type: struct bpf_sock ,Var: *sk}"], "compatible_hookpoints": ["sched_cls", "sched_act", "cgroup_skb", "sock_ops"], "capabilities": []}, "bpf_skb_ecn_set_ce": {"Project": "libbpf", "Return Type": "int", "Description": "Set ECN (Explicit Congestion Notification) field of IP header to CE(Congestion Encountered) if current value is ECT (ECN Capable Transport). Otherwise , do nothing. Works with IPv6 and IPv4. ", "Return": " 1 if the CE flag is set (either by the current helper call or because it was already present), 0 if it is not set.", "Function Name": "bpf_skb_ecn_set_ce", "Input Params": ["{Type: struct sk_buf ,Var: *skb}"], "compatible_hookpoints": ["sched_cls", "sched_act", "cgroup_skb"], "capabilities": ["update_pkt"]}, "bpf_get_listener_sock": {"Project": "libbpf", "Return Type": "struct bpf_sock*", "Description": "Return a struct bpf_sock pointer in TCP_LISTEN state. bpf_sk_release() is unnecessary and not allowed. ", "Return": " A struct  bpf_sock pointer on success, or NULL in case of failure.", "Function Name": "bpf_get_listener_sock", "Input Params": ["{Type: struct bpf_sock ,Var: *sk}"], "compatible_hookpoints": ["sched_cls", "sched_act", "cgroup_skb"], "capabilities": ["read_sys_info"]}, "bpf_skc_lookup_tcp": {"Project": "libbpf", "Return Type": "struct bpf_sock*", "Description": "Look for TCP socket matching <[ tuple ]>(IP: 1) , optionally in a child network namespace netns. The return value must be checked , and if non-NULL , released via bpf_sk_release(). This function is identical to bpf_sk_lookup_tcp() , except that it also returns timewait or request sockets. Use bpf_sk_fullsock() or bpf_tcp_sock() to access the full structure. This helper is available only if the kernel was compiled with CONFIG_NET configuration option. ", "Return": " Pointer  to  struct  bpf_sock, or NULL in case of failure.  For sockets with                     reuseport option, the struct  bpf_sock result is  from  reuse->socks[]  using                     the hash of the tuple.", "Function Name": "bpf_skc_lookup_tcp", "Input Params": ["{Type: void ,Var: *ctx}", "{Type:  struct bpf_sock_tuple ,Var: *tuple}", "{Type:  u32 ,Var: tuple_size}", "{Type:  u64 ,Var: netns}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp", "sk_skb", "cgroup_sock_addr"], "capabilities": ["read_sys_info"]}, "bpf_tcp_check_syncookie": {"Project": "libbpf", "Return Type": "int", "Description": "Check whether <[ iph ]>(IP: 1) and <[ th ]>(IP: 3) contain a valid SYN cookie ACK for the listening socket in sk. <[ iph ]>(IP: 1) points to the start of the IPv4 or IPv6 header , while <[ iph_len ]>(IP: 2) contains sizeof(struct iphdr) or sizeof(struct ip6hdr). <[ th ]>(IP: 3) points to the start of the TCP header , while <[ th_len ]>(IP: 4) contains sizeof(struct tcphdr). ", "Return": " 0 if iph and th are a valid SYN cookie ACK, or a negative error otherwise.", "Function Name": "bpf_tcp_check_syncookie", "Input Params": ["{Type: struct bpf_sock ,Var: *sk}", "{Type:  void ,Var: *iph}", "{Type:  u32 ,Var: iph_len}", "{Type:  struct tcphdr ,Var: *th}", "{Type:  u32 ,Var: th_len}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp"], "capabilities": ["read_skb"]}, "bpf_sysctl_get_name": {"Project": "libbpf", "Return Type": "int", "Description": "Get name of sysctl in /proc/sys/ and copy it into provided by program buffer <[ buf ]>(IP: 1) of size buf_len. The buffer is always NUL terminated , unless it's zero-sized. If <[ flags ]>(IP: 3) is zero , full name (e. g. \"net / ipv4 / tcp_mem\") is copied. Use BPF_F_SYSCTL_BASE_NAME flag to copy base name only (e. g. \"tcp_mem\"). ", "Return": " Number of character copied (not including the trailing NUL).                     -E2BIG  if  the buffer wasn't big enough (buf will contain truncated name in                     this case).", "Function Name": "bpf_sysctl_get_name", "Input Params": ["{Type: struct bpf_sysctl ,Var: *ctx}", "{Type:  char ,Var: *buf}", "{Type:  size_t ,Var: buf_len}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["cgroup_sysctl"], "capabilities": ["read_sys_info"]}, "bpf_sysctl_get_current_value": {"Project": "libbpf", "Return Type": "int", "Description": "Get current value of sysctl as it is presented in /proc/sys (incl. newline , etc) , and copy it as a string into provided by program buffer <[ buf ]>(IP: 1) of size buf_len. The whole value is copied , no matter what file position user space issued e. g. sys_read at. The buffer is always NUL terminated , unless it's zero-sized. ", "Return": " Number of character copied (not including the trailing NUL).                     -E2BIG  if  the buffer wasn't big enough (buf will contain truncated name in                     this case).                     -EINVAL  if  current  value  was  unavailable,  e.g.   because   sysctl   is                     uninitialized and read returns -EIO for it.", "Function Name": "bpf_sysctl_get_current_value", "Input Params": ["{Type: struct bpf_sysctl ,Var: *ctx}", "{Type:  char ,Var: *buf}", "{Type:  size_t ,Var: buf_len}"], "compatible_hookpoints": ["cgroup_sysctl"], "capabilities": ["read_sys_info"]}, "bpf_sysctl_get_new_value": {"Project": "libbpf", "Return Type": "int", "Description": "Get new value being written by user space to sysctl (before the actual write happens) and copy it as a string into provided by program buffer <[ buf ]>(IP: 1) of size buf_len. User space may write new value at file position > 0. The buffer is always NUL terminated , unless it's zero-sized. ", "Return": " Number of character copied (not including the trailing NUL).                     -E2BIG  if  the buffer wasn't big enough (buf will contain truncated name in                     this case).                     -EINVAL if sysctl is being read.", "Function Name": "bpf_sysctl_get_new_value", "Input Params": ["{Type: struct bpf_sysctl ,Var: *ctx}", "{Type:  char ,Var: *buf}", "{Type:  size_t ,Var: buf_len}"], "compatible_hookpoints": ["cgroup_sysctl"], "capabilities": ["read_sys_info"]}, "bpf_sysctl_set_new_value": {"Project": "libbpf", "Return Type": "int", "Description": "Override new value being written by user space to sysctl with value provided by program in buffer <[ buf ]>(IP: 1) of size buf_len. <[ buf ]>(IP: 1) should contain a string in same form as provided by user space on sysctl write. User space may write new value at file position > 0. To override the whole sysctl value file position should be set to zero. ", "Return": " 0 on success.                     -E2BIG if the buf_len is too big.                     -EINVAL if sysctl is being read.", "Function Name": "bpf_sysctl_set_new_value", "Input Params": ["{Type: struct bpf_sysctl ,Var: *ctx}", "{Type:  const char ,Var: *buf}", "{Type:  size_t ,Var: buf_len}"], "compatible_hookpoints": ["cgroup_sysctl"], "capabilities": []}, "bpf_strtol": {"Project": "libbpf", "Return Type": "int", "Description": "Convert the initial part of the string from buffer <[ buf ]>(IP: 0) of size <[ buf_len ]>(IP: 1) to a long integer according to the given base and save the result in res. The string may begin with an arbitrary amount of white space (as determined by isspace(3)) followed by a single optional '-' sign. Five least significant bits of <[ flags ]>(IP: 2) encode base , other bits are currently unused. Base must be either 8 , 10 , 16 or 0 to detect it automatically similar to user space strtol(3). ", "Return": " Number  of characters consumed on success. Must be positive but no more than                     buf_len.                     -EINVAL if no valid digits were found or unsupported base was provided.                     -ERANGE if resulting value was out of range.", "Function Name": "bpf_strtol", "Input Params": ["{Type: const char ,Var: *buf}", "{Type:  size_t ,Var: buf_len}", "{Type:  u64 ,Var: flags}", "{Type:  long ,Var: *res}"], "compatible_hookpoints": ["cgroup_sysctl"], "capabilities": []}, "bpf_strtoul": {"Project": "libbpf", "Return Type": "int", "Description": "Convert the initial part of the string from buffer <[ buf ]>(IP: 0) of size <[ buf_len ]>(IP: 1) to an unsigned long integer according to the given base and save the result in res. The string may begin with an arbitrary amount of white space (as determined by isspace(3)). Five least significant bits of <[ flags ]>(IP: 2) encode base , other bits are currently unused. Base must be either 8 , 10 , 16 or 0 to detect it automatically similar to user space strtoul(3). ", "Return": " Number  of characters consumed on success. Must be positive but no more than                     buf_len.                     -EINVAL if no valid digits were found or unsupported base was provided.                     -ERANGE if resulting value was out of range.", "Function Name": "bpf_strtoul", "Input Params": ["{Type: const char ,Var: *buf}", "{Type:  size_t ,Var: buf_len}", "{Type:  u64 ,Var: flags}", "{Type:  unsigned long ,Var: *res}"], "compatible_hookpoints": ["cgroup_sysctl"], "capabilities": []}, "bpf_sk_storage_get": {"Project": "libbpf", "Return Type": "void*", "Description": "Get a bpf-local-storage from a sk. Logically , it could be thought of getting the <[ value ]>(IP: 2) from a <[ map ]>(IP: 0) with <[ sk ]>(IP: 1) as the key. From this perspective , the usage is not much different from bpf_map_lookup_elem(map , &sk) except this helper enforces the key must be a full socket and the <[ map ]>(IP: 0) must be a BPF_MAP_TYPE_SK_STORAGE also. Underneath , the <[ value ]>(IP: 2) is stored locally at <[ sk ]>(IP: 1) instead of the map. The <[ map ]>(IP: 0) is used as the bpf-local-storage \"type\". The bpf-local-storage \"type\" (i. e. the map) is searched against all bpf-local-storages residing at sk. An optional <[ flags ]>(IP: 3) (BPF_SK_STORAGE_GET_F_CREATE) can be used such that a new bpf-local-storage will be created if one does not exist. <[ value ]>(IP: 2) can be used together with BPF_SK_STORAGE_GET_F_CREATE to specify the initial <[ value ]>(IP: 2) of a bpf-local-storage. If <[ value ]>(IP: 2) is NULL , the new bpf-local-storage will be zero initialized. ", "Return": " A bpf-local-storage pointer is returned on success.                     NULL if not found or there was an error in adding a new bpf-local-storage.", "Function Name": "bpf_sk_storage_get", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  struct bpf_sock ,Var: *sk}", "{Type:  void ,Var: *value}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["sched_cls", "sched_act", "cgroup_skb", "sock_ops", "cgroup_sock_addr"], "capabilities": ["read_sys_info"]}, "bpf_sk_storage_delete": {"Project": "libbpf", "Return Type": "int", "Description": "Delete a bpf-local-storage from a sk. ", "Return": " 0 on success.                     -ENOENT if the bpf-local-storage cannot be found.", "Function Name": "bpf_sk_storage_delete", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  struct bpf_sock ,Var: *sk}"], "compatible_hookpoints": ["sched_cls", "sched_act", "cgroup_skb", "sock_ops", "cgroup_sock_addr"], "capabilities": []}, "bpf_send_signal": {"Project": "libbpf", "Return Type": "int", "Description": "Send signal <[ sig ]>(IP: 0) to the current task. ", "Return": " 0 on success or successfully queued.                     -EBUSY if work queue under nmi is full.                     -EINVAL if sig is invalid.                     -EPERM if no permission to send the sig.                     -EAGAIN if bpf program can try again.", "Function Name": "bpf_send_signal", "Input Params": ["{Type: u32 ,Var: sig}"], "compatible_hookpoints": ["kprobe", "tracepoint", "perf_event", "raw_tracepoint", "raw_tracepoint_writable"], "capabilities": []}, "bpf_tcp_gen_syncookie": {"Project": "libbpf", "Return Type": "s64", "Description": "Try to issue a SYN cookie for the packet with corresponding IP/TCP headers , <[ iph ]>(IP: 1) and <[ th ]>(IP: 3) , on the listening socket in sk. <[ iph ]>(IP: 1) points to the start of the IPv4 or IPv6 header , while <[ iph_len ]>(IP: 2) contains sizeof(struct iphdr) or sizeof(struct ip6hdr). <[ th ]>(IP: 3) points to the start of the TCP header , while <[ th_len ]>(IP: 4) contains the length of the TCP header. ", "Return": " On  success,  lower  32 bits hold the generated SYN cookie in followed by 16                     bits which hold the MSS value for that cookie,  and  the  top  16  bits  are                     unused.                     On failure, the returned value is one of the following:                     -EINVAL SYN cookie cannot be issued due to error                     -ENOENT SYN cookie should not be issued (no SYN flood)                     -EOPNOTSUPP kernel configuration does not enable SYN cookies                     -EPROTONOSUPPORT IP packet version is not 4 or 6", "Function Name": "bpf_tcp_gen_syncookie", "Input Params": ["{Type: struct bpf_sock ,Var: *sk}", "{Type:  void ,Var: *iph}", "{Type:  u32 ,Var: iph_len}", "{Type:  struct tcphdr ,Var: *th}", "{Type:  u32 ,Var: th_len}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp"], "capabilities": []}, "TC_ACT_UNSPEC": {"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_UNSPEC", "Return": -1, "Description": "unspecified action and is used in three cases, i) when an offloaded tc BPF program is attached and the tc ingress hook is run where the cls_bpf representation for the offloaded program will return TC_ACT_UNSPEC, ii) in order to continue with the next tc BPF program in cls_bpf for the multi-program case. The latter also works in combination with offloaded tc BPF programs from point i) where the TC_ACT_UNSPEC from there continues with a next tc BPF program solely running in non-offloaded case. Last but not least, iii) TC_ACT_UNSPEC is also used for the single program case to simply tell the kernel to continue with the skb without additional side-effects. TC_ACT_UNSPEC is very similar to the TC_ACT_OK action code in the sense that both pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. The only difference to TC_ACT_OK is that TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}, "TC_ACT_OK": {"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}, "TC_ACT_RECLASSIFY": {"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_RECLASSIFY", "Return": 1, "Description": " will terminate the packet processing pipeline and start classification from the beginning. pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}, "TC_ACT_SHOT": {"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_SHOT", "Return": 2, "Description": "instructs the kernel to drop the packet, meaning, upper layers of the networking stack will never see the skb on ingress and similarly the packet will never be submitted for transmission on egress. TC_ACT_SHOT and TC_ACT_STOLEN are both similar in nature with few differences: TC_ACT_SHOT will indicate to the kernel that the skb was released through kfree_skb() and return NET_XMIT_DROP to the callers for immediate feedback, whereas TC_ACT_STOLEN will release the skb through consume_skb() and pretend to upper layers that the transmission was successful through NET_XMIT_SUCCESS. The perf\u2019s drop monitor which records traces of kfree_skb() will therefore also not see any drop indications from TC_ACT_STOLEN since its semantics are such that the skb has been \u201cconsumed\u201d or queued but certainly not \"dropped\".", "compatible_hookpoints": ["sched_cls", "sched_act"], "capabilities": ["pkt_stop_processing_drop_packet"]}, "TC_ACT_PIPE": {"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_PIPE", "Return": 3, "Description": "will iterate to the next action, if available", "compatible_hookpoints": ["sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}, "TC_ACT_STOLEN": {"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_STOLEN", "Return": 4, "Description": "instructs the kernel to drop the packet, meaning, upper layers of the networking stack will never see the skb on ingress and similarly the packet will never be submitted for transmission on egress. TC_ACT_SHOT and TC_ACT_STOLEN are both similar in nature with few differences: TC_ACT_SHOT will indicate to the kernel that the skb was released through kfree_skb() and return NET_XMIT_DROP to the callers for immediate feedback, whereas TC_ACT_STOLEN will release the skb through consume_skb() and pretend to upper layers that the transmission was successful through NET_XMIT_SUCCESS. The perf\u2019s drop monitor which records traces of kfree_skb() will therefore also not see any drop indications from TC_ACT_STOLEN since its semantics are such that the skb has been \u201cconsumed\u201d or queued but certainly not \"dropped\".", "compatible_hookpoints": ["sched_cls", "sched_act"], "capabilities": ["pkt_stop_processing_drop_packet"]}, "TC_ACT_QUEUED": {"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_QUEUED", "Return": 5, "Description": "NA", "compatible_hookpoints": ["sched_cls", "sched_act"], "capabilities": []}, "TC_ACT_REPEAT": {"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_REPEAT", "Return": 6, "Description": "NA", "compatible_hookpoints": ["sched_cls", "sched_act"], "capabilities": ["pkt_alter_or_redo_processing_or_interface"]}, "TC_ACT_REDIRECT": {"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_REDIRECT", "Return": 7, "Description": "This allows to redirect the skb to the same or another\u2019s device ingress or egress path together with the bpf_redirect() helper. Being able to inject the packet into another device\u2019s ingress or egress direction allows for full flexibility in packet forwarding with BPF. There are no requirements on the target networking device other than being a networking device itself, there is no need to run another instance of cls_bpf on the target device or other such restrictions.", "compatible_hookpoints": ["sched_cls", "sched_act"], "capabilities": ["pkt_alter_or_redo_processing_or_interface"]}, "TC_ACT_TRAP": {"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_TRAP", "Return": 8, "Description": " For hw path, this means \"trap to cpu\" and don't further process the frame in hardware. For sw path, this is equivalent of TC_ACT_STOLEN - drop the skb and act like everything is alright. TC_ACT_STOLEN: instructs the kernel to drop the packet, meaning, upper layers of the networking stack will never see the skb on ingress and similarly the packet will never be submitted for transmission on egress. TC_ACT_SHOT and TC_ACT_STOLEN are both similar in nature with few differences: TC_ACT_SHOT will indicate to the kernel that the skb was released through kfree_skb() and return NET_XMIT_DROP to the callers for immediate feedback, whereas TC_ACT_STOLEN will release the skb through consume_skb() and pretend to upper layers that the transmission was successful through NET_XMIT_SUCCESS. The perf\u2019s drop monitor which records traces of kfree_skb() will therefore also not see any drop indications from TC_ACT_STOLEN since its semantics are such that the skb has been \u201cconsumed\u201d or queued but certainly not \"dropped\".", "compatible_hookpoints": ["sched_cls", "sched_act"], "capabilities": ["pkt_stop_processing_drop_packet"]}, "XDP_ABORTED": {"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_ABORTED", "Return": 0, "Description": "which serves denoting an exception like state from the program and has the same behavior as XDP_DROP only that XDP_ABORTED passes the trace_xdp_exception tracepoint which can be additionally monitored to detect misbehavior.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_stop_processing_drop_packet"]}, "XDP_DROP": {"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_DROP", "Return": 1, "Description": "will drop the packet right at the driver level without wasting any further resources. This is in particular useful for BPF programs implementing DDoS mitigation mechanisms or firewalling in general.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_stop_processing_drop_packet"]}, "XDP_PASS": {"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_PASS", "Return": 2, "Description": "The XDP_PASS return code means that the packet is allowed to be passed up to the kernel\u2019s networking stack. Meaning, the current CPU that was processing this packet now allocates a skb, populates it, and passes it onwards into the GRO engine. This would be equivalent to the default packet handling behavior without XDP.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_go_to_next_module"]}, "XDP_TX": {"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_TX", "Return": 3, "Description": "an efficient option to transmit the network packet out of the same NIC it just arrived on again. This is typically useful when few nodes are implementing, for example, firewalling with subsequent load balancing in a cluster and thus act as a hairpinned load balancer pushing the incoming packets back into the switch after rewriting them in XDP BPF.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_alter_or_redo_processing_or_interface"]}, "XDP_REDIRECT": {"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_REDIRECT", "Return": 4, "Description": "is similar to XDP_TX in that it is able to transmit the XDP packet, but through another NIC. Another option for the XDP_REDIRECT case is to redirect into a BPF cpumap, meaning, the CPUs serving XDP on the NIC\u2019s receive queues can continue to do so and push the packet for processing the upper kernel stack to a remote CPU. This is similar to XDP_PASS, but with the ability that the XDP BPF program can keep serving the incoming high load as opposed to temporarily spend work on the current packet for pushing into upper layers.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_alter_or_redo_processing_or_interface"]}, "map_lookup_elem": {"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}, "map_update_elem": {"Project": "cilium", "Return Type": "int", "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "map_update_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}", "{Type:  const void ,Var: *value}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_update"]}, "map_delete_elem": {"Project": "cilium", "Return Type": "int", "Description": "Delete entry with <[ key ]>(IP: 1) from map. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "map_delete_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_update"]}, "probe_read": {"Project": "cilium", "Return Type": "int", "Description": "For tracing programs , safely attempt to read <[ size ]>(IP: 1) bytes from address <[ src ]>(IP: 2) and store the data in dst. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "probe_read", "Input Params": ["{Type: void ,Var: *dst}", "{Type:  u32 ,Var: size}", "{Type:  const void ,Var: *src}"], "compatible_hookpoints": ["kprobe", "tracepoint", "perf_event", "raw_tracepoint", "raw_tracepoint_writable"], "capabilities": ["read_sys_info"]}, "ktime_get_ns": {"Project": "cilium", "Return Type": "u64", "Description": "Return the time elapsed since system boot , in nanoseconds. ", "Return": " Current ktime.", "Function Name": "ktime_get_ns", "Input Params": ["{Type: voi ,Var: void}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "raw_tracepoint_writable"], "capabilities": ["read_sys_info"]}, "trace_printk": {"Project": "cilium", "Return Type": "int", "Description": "This helper is a \"printk() - like \" facility for debugging. It prints a message defined by format <[ fmt ]>(IP: 0) (of size fmt_size) to file /sys/kernel/debug/tracing/trace from DebugFS , if available. It can take up to three additional u64 arguments (as an eBPF helpers , the total number of arguments is limited to five). Each time the helper is called , it appends a line to the trace. Lines are discarded while /sys/kernel/debug/tracing/trace is open , use /sys/kernel/debug/tracing/trace_pipe to avoid this. The format of the trace is customizable , and the exact output one will get depends on the options set in /sys/kernel/debug/tracing/trace_options (see also the README file under the same directory). However , it usually defaults to something like: telnet-470 [001] . N. . 419421. 045894: 0x00000001: <formatted msg> In the above: \u00b7 telnet is the name of the current task. \u00b7 470 is the PID of the current task. \u00b7 001 is the CPU number on which the task is running. \u00b7 In . N. . , each character refers to a set of options (whether irqs are enabled , scheduling options , whether hard/softirqs are running , level of preempt_disabled respectively). N means that TIF_NEED_RESCHED and PREEMPT_NEED_RESCHED are set. \u00b7 419421. 045894 is a timestamp. \u00b7 0x00000001 is a fake value used by BPF for the instruction pointer register. \u00b7 <formatted msg> is the message formatted with fmt. The conversion specifiers supported by <[ fmt ]>(IP: 0) are similar , but more limited than for printk(). They are %d , %i , %u , %x , %ld , %li , %lu , %lx , %lld , %lli , %llu , %llx , %p , %s. No modifier (size of field , padding with zeroes , etc. ) is available , and the helper will return -EINVAL (but print nothing) if it encounters an unknown specifier. Also , note that trace_printk() is slow , and should only be used for debugging purposes. For this reason , a notice bloc (spanning several lines) is printed to kernel logs and states that the helper should not be used for production use \" the first time this helper is used (or more precisely , when trace_printk() buffers are allocated). For passing values to user space , perf events should be preferred. ", "Return": " The number of bytes written to the buffer, or a negative error  in  case  of     failure.", "Function Name": "trace_printk", "Input Params": ["{Type: const char ,Var: *fmt}", "{Type:  u32 ,Var: fmt_size}", "{Type:  ,Var: ...}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": []}, "get_prandom_u32": {"Project": "cilium", "Return Type": "u32", "Description": "Get a pseudo-random number. From a security point of view , this helper uses its own pseudo-random internal state , and cannot be used to infer the seed of other random functions in the kernel. However , it is essential to note that the generator used by the helper is not cryptographically secure. ", "Return": " A random 32-bit unsigned value.", "Function Name": "get_prandom_u32", "Input Params": ["{Type: voi ,Var: void}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "raw_tracepoint_writable"], "capabilities": ["read_sys_info"]}, "get_smp_processor_id": {"Project": "cilium", "Return Type": "u32", "Description": "Get the SMP (symmetric multiprocessing) processor id. Note that all programs run with preemption disabled , which means that the SMP processor id is stable during all the execution of the program. ", "Return": " The SMP id of the processor running the program.", "Function Name": "get_smp_processor_id", "Input Params": ["{Type: voi ,Var: void}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "raw_tracepoint_writable"], "capabilities": ["read_sys_info"]}, "skb_store_bytes": {"Project": "cilium", "Return Type": "int", "Description": "Store <[ len ]>(IP: 3) bytes <[ from ]>(IP: 2) address <[ from ]>(IP: 2) into the packet associated to <[ skb ]>(IP: 0) , at offset. <[ flags ]>(IP: 4) are a combination of BPF_F_RECOMPUTE_CSUM (automatically recompute the checksum for the packet after storing the bytes) and BPF_F_INVALIDATE_HASH (set skb->hash , skb->swhash and skb->l4hash to 0). A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "skb_store_bytes", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  u32 ,Var: offset}", "{Type:  const void ,Var: *from}", "{Type:  u32 ,Var: len}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["sched_cls", "sched_act", "lwt_xmit", "sk_skb"], "capabilities": ["update_pkt"]}, "l3_csum_replace": {"Project": "cilium", "Return Type": "int", "Description": "Recompute the layer 3 (e. g. IP) checksum for the packet associated <[ to ]>(IP: 3) skb. Computation is incremental , so the helper must know the former value of the header field that was modified (from) , the new value of this field (to) , and the number of bytes (2 or 4) for this field , stored in size. Alternatively , it is possible <[ to ]>(IP: 3) store the difference between the previous and the new values of the header field in <[ to ]>(IP: 3) , by setting <[ from ]>(IP: 2) and <[ size ]>(IP: 4) <[ to ]>(IP: 3) 0. For both methods , <[ offset ]>(IP: 1) indicates the location of the IP checksum within the packet. This helper works in combination with csum_diff() , which does not update the checksum in-place , but offers more flexibility and can handle sizes larger than 2 or 4 for the checksum <[ to ]>(IP: 3) update. A call <[ to ]>(IP: 3) this helper is susceptible <[ to ]>(IP: 3) change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "l3_csum_replace", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  u32 ,Var: offset}", "{Type:  u64 ,Var: from}", "{Type:  u64 ,Var: to}", "{Type:  u64 ,Var: size}"], "compatible_hookpoints": ["sched_cls", "sched_act", "lwt_xmit"], "capabilities": ["update_pkt"]}, "l4_csum_replace": {"Project": "cilium", "Return Type": "int", "Description": "Recompute the layer 4 (e. g. TCP , UDP or ICMP) checksum for the packet associated <[ to ]>(IP: 3) skb. Computation is incremental , so the helper must know the former value of the header field that was modified (from) , the new value of this field (to) , and the number of bytes (2 or 4) for this field , stored on the lowest four bits of flags. Alternatively , it is possible <[ to ]>(IP: 3) store the difference between the previous and the new values of the header field in <[ to ]>(IP: 3) , by setting <[ from ]>(IP: 2) and the four lowest bits of <[ flags ]>(IP: 4) <[ to ]>(IP: 3) 0. For both methods , <[ offset ]>(IP: 1) indicates the location of the IP checksum within the packet. In addition <[ to ]>(IP: 3) the size of the field , <[ flags ]>(IP: 4) can be added (bitwise OR) actual flags. With BPF_F_MARK_MANGLED_0 , a null checksum is left untouched (unless BPF_F_MARK_ENFORCE is added as well) , and for updates resulting in a null checksum the value is set <[ to ]>(IP: 3) CSUM_MANGLED_0 instead. Flag BPF_F_PSEUDO_HDR indicates the checksum is <[ to ]>(IP: 3) be computed against a pseudo-header. This helper works in combination with csum_diff() , which does not update the checksum in-place , but offers more flexibility and can handle sizes larger than 2 or 4 for the checksum <[ to ]>(IP: 3) update. A call <[ to ]>(IP: 3) this helper is susceptible <[ to ]>(IP: 3) change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "l4_csum_replace", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  u32 ,Var: offset}", "{Type:  u64 ,Var: from}", "{Type:  u64 ,Var: to}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["sched_cls", "sched_act", "lwt_xmit"], "capabilities": ["update_pkt"]}, "tail_call": {"Project": "cilium", "Return Type": "int", "Description": "This special helper is used to trigger a \" tail call \" , or in other words , to jump into another eBPF program. The same stack frame is used (but values on stack and in registers for the caller are not accessible to the callee). This mechanism allows for program chaining , either for raising the maximum number of available eBPF instructions , or to execute given programs in conditional blocks. For security reasons , there is an upper limit to the number of successive tail calls that can be performed. Upon call of this helper , the program attempts to jump into a program referenced at <[ index ]>(IP: 2) index in <[ prog_array_map ]>(IP: 1) , a special map of type BPF_MAP_TYPE_PROG_ARRAY , and passes <[ ctx ]>(IP: 0) , a pointer to the context. If the call succeeds , the kernel immediately runs the first instruction of the new program. This is not a function call , and it never returns to the previous program. If the call fails , then the helper has no effect , and the caller continues to run its subsequent instructions. A call can fail if the destination program for the jump does not exist (i. e. <[ index ]>(IP: 2) is superior to the number of entries in prog_array_map) , or if the maximum number of tail calls has been reached for this chain of programs. This limit is defined in the kernel by the macro MAX_TAIL_CALL_CNT (not accessible to user space) , which is currently set to 32. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "tail_call", "Input Params": ["{Type: void ,Var: *ctx}", "{Type:  struct map ,Var: *prog_array_map}", "{Type:  u32 ,Var: index}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "raw_tracepoint_writable"], "capabilities": []}, "clone_redirect": {"Project": "cilium", "Return Type": "int", "Description": "Clone and redirect the packet associated to <[ skb ]>(IP: 0) to another net device of index ifindex. Both ingress and egress interfaces can be used for redirection. The BPF_F_INGRESS value in <[ flags ]>(IP: 2) is used to make the distinction (ingress path is selected if the flag is present , egress path otherwise). This is the only flag supported for now. In comparison with redirect() helper , clone_redirect() has the associated cost of duplicating the packet buffer , but this can be executed out of the eBPF program. Conversely , redirect() is more efficient , but it is handled through an action code where the redirection happens only after the eBPF program has returned. A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "clone_redirect", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  u32 ,Var: ifindex}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["sched_cls", "sched_act", "lwt_xmit"], "capabilities": []}, "get_current_pid_tgid": {"Project": "cilium", "Return Type": "u64", "Return": " A 64-bit integer containing the current tgid and pid, and created  as  such:                     current_task->tgid << 32 | current_task->pid.", "Function Name": "get_current_pid_tgid", "Input Params": ["{Type: voi ,Var: void}"], "Description": "A 64-bit integer containing the current tgid and pid , and created as such: current_task->tgid << 32 | current_task->pid. ", "compatible_hookpoints": ["kprobe", "tracepoint", "perf_event", "raw_tracepoint", "raw_tracepoint_writable"], "capabilities": ["read_sys_info"]}, "get_current_uid_gid": {"Project": "cilium", "Return Type": "u64", "Return": " A  64-bit  integer  containing the current GID and UID, and created as such:                     current_gid << 32 | current_uid.", "Function Name": "get_current_uid_gid", "Input Params": ["{Type: voi ,Var: void}"], "Description": "A 64-bit integer containing the current GID and UID , and created as such: current_gid << 32 | current_uid. ", "compatible_hookpoints": ["kprobe", "tracepoint", "perf_event", "cgroup_sock", "cgroup_device", "raw_tracepoint", "cgroup_sock_addr", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["read_sys_info"]}, "get_current_comm": {"Project": "cilium", "Return Type": "int", "Description": "Copy the comm attribute of the current task into <[ buf ]>(IP: 0) of size_of_buf. The comm attribute contains the name of the executable (excluding the path) for the current task. The <[ size_of_buf ]>(IP: 1) must be strictly positive. On success , the helper makes sure that the <[ buf ]>(IP: 0) is NUL-terminated. On failure , it is filled with zeroes. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "get_current_comm", "Input Params": ["{Type: char ,Var: *buf}", "{Type:  u32 ,Var: size_of_buf}"], "compatible_hookpoints": ["kprobe", "tracepoint", "perf_event", "raw_tracepoint", "raw_tracepoint_writable"], "capabilities": ["read_sys_info"]}, "get_cgroup_classid": {"Project": "cilium", "Return Type": "u32", "Description": "Retrieve the classid for the current task , i. e. for the net_cls cgroup to which <[ skb ]>(IP: 0) belongs. This helper can be used on TC egress path , but not on ingress. The net_cls cgroup provides an interface to tag network packets based on a user-provided identifier for all traffic coming from the tasks belonging to the related cgroup. See also the related kernel documentation , available from the Linux sources in file Documentation/admin-guide/cgroup-v1/net_cls. rst. The Linux kernel has two versions for cgroups: there are cgroups v1 and cgroups v2. Both are available to users , who can use a mixture of them , but note that the net_cls cgroup is for cgroup v1 only. This makes it incompatible with BPF programs run on cgroups , which is a cgroup-v2-only feature (a socket can only hold data for one version of cgroups at a time). This helper is only available is the kernel was compiled with the CONFIG_CGROUP_NET_CLASSID configuration option set to \"y\" or to \"m\" ", "Return": " The classid, or 0 for the default unconfigured classid.", "Function Name": "get_cgroup_classid", "Input Params": ["{Type: struct sk_buff ,Var: *skb}"], "compatible_hookpoints": ["sched_cls", "sched_act", "lwt_in", "lwt_out", "lwt_xmit", "lwt_seg6local"], "capabilities": ["read_sys_info"]}, "skb_vlan_push": {"Project": "cilium", "Return Type": "int", "Description": "Push a <[ vlan_tci ]>(IP: 2) (VLAN tag control information) of protocol <[ vlan_proto ]>(IP: 1) to the packet associated to <[ skb ]>(IP: 0) , then update the checksum. Note that if <[ vlan_proto ]>(IP: 1) is different from ETH_P_8021Q and ETH_P_8021AD , it is considered to be ETH_P_8021Q. A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "skb_vlan_push", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  __be16 ,Var: vlan_proto}", "{Type:  u16 ,Var: vlan_tci}"], "compatible_hookpoints": ["sched_cls", "sched_act"], "capabilities": ["update_pkt"]}, "skb_vlan_pop": {"Project": "cilium", "Return Type": "int", "Description": "Pop a VLAN header from the packet associated to skb. A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "skb_vlan_pop", "Input Params": ["{Type: struct sk_buff ,Var: *skb}"], "compatible_hookpoints": ["sched_cls", "sched_act"], "capabilities": ["update_pkt"]}, "skb_get_tunnel_key": {"Project": "cilium", "Return Type": "int", "Description": "Get tunnel metadata. This helper takes a pointer <[ key ]>(IP: 1) to an empty struct tunnel_key of <[ size ]>(IP: 2) , that will be filled with tunnel metadata for the packet associated to skb. The <[ flags ]>(IP: 3) can be set to BPF_F_TUNINFO_IPV6 , which indicates that the tunnel is based on IPv6 protocol instead of IPv4. The struct tunnel_key is an object that generalizes the principal parameters used by various tunneling protocols into a single struct. This way , it can be used to easily make a decision based on the contents of the encapsulation header , \"summarized\" in this struct. In particular , it holds the IP address of the remote end (IPv4 or IPv6 , depending on the case) in key->remote_ipv4 or key->remote_ipv6. Also , this struct exposes the key->tunnel_id , which is generally mapped to a VNI (Virtual Network Identifier) , making it programmable together with the skb_set_tunnel_key() helper. Let's imagine that the following code is part of a program attached to the TC ingress interface , on one end of a GRE tunnel , and is supposed to filter out all messages coming from remote ends with IPv4 address other than 10. 0. 0. 1: int ret; struct tunnel_key <[ key ]>(IP: 1) = {}; ret = skb_get_tunnel_key(skb , &key , sizeof(key) , 0); if (ret < 0) return TC_ACT_SHOT; // drop packet if (key. remote_ipv4 != 0x0a000001) return TC_ACT_SHOT; // drop packet return TC_ACT_OK; // accept packet This interface can also be used with all encapsulation devices that can operate in \"collect metadata\" mode: instead of having one network device per specific configuration , the \"collect metadata\" mode only requires a single device where the configuration can be extracted from this helper. This can be used together with various tunnels such as VXLan , Geneve , GRE or IP in IP (IPIP). ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "skb_get_tunnel_key", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  struct tunnel_key ,Var: *key}", "{Type:  u32 ,Var: size}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["sched_cls", "sched_act", "lwt_xmit"], "capabilities": ["read_skb", "read_sys_info"]}, "skb_set_tunnel_key": {"Project": "cilium", "Return Type": "int", "Description": "Populate tunnel metadata for packet associated to skb. The tunnel metadata is set to the contents of <[ key ]>(IP: 1) , of size. The <[ flags ]>(IP: 3) can be set to a combination of the following values: BPF_F_TUNINFO_IPV6 Indicate that the tunnel is based on IPv6 protocol instead of IPv4. BPF_F_ZERO_CSUM_TX For IPv4 packets , add a flag to tunnel metadata indicating that checksum computation should be skipped and checksum set to zeroes. BPF_F_DONT_FRAGMENT Add a flag to tunnel metadata indicating that the packet should not be fragmented. BPF_F_SEQ_NUMBER Add a flag to tunnel metadata indicating that a sequence number should be added to tunnel header before sending the packet. This flag was added for GRE encapsulation , but might be used with other protocols as well in the future. Here is a typical usage on the transmit path: struct tunnel_key key; populate <[ key ]>(IP: 1) . . . skb_set_tunnel_key(skb , &key , sizeof(key) , 0); clone_redirect(skb , vxlan_dev_ifindex , 0); See also the description of the skb_get_tunnel_key() helper for additional information. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "skb_set_tunnel_key", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  struct tunnel_key ,Var: *key}", "{Type:  u32 ,Var: size}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["sched_cls", "sched_act", "lwt_xmit"], "capabilities": ["update_pkt"]}, "perf_event_read": {"Project": "cilium", "Return Type": "u64", "Description": "Read the value of a perf event counter. This helper relies on a <[ map ]>(IP: 0) of type BPF_MAP_TYPE_PERF_EVENT_ARRAY. The nature of the perf event counter is selected when <[ map ]>(IP: 0) is updated with perf event file descriptors. The <[ map ]>(IP: 0) is an array whose size is the number of available CPUs , and each cell contains a value relative to one CPU. The value to retrieve is indicated by <[ flags ]>(IP: 1) , that contains the index of the CPU to look up , masked with BPF_F_INDEX_MASK. Alternatively , <[ flags ]>(IP: 1) can be set to BPF_F_CURRENT_CPU to indicate that the value for the current CPU should be retrieved. Note that before Linux 4. 13 , only hardware perf event can be retrieved. Also , be aware that the newer helper perf_event_read_value() is recommended over perf_event_read() in general. The latter has some ABI quirks where error and counter value are used as a return code (which is wrong to do since ranges may overlap). This issue is fixed with perf_event_read_value() , which at the same time provides more features over the perf_event_read() interface. Please refer to the description of perf_event_read_value() for details. ", "Return": " The value of the perf event counter read from the map, or a  negative  error                     code in case of failure.", "Function Name": "perf_event_read", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["kprobe", "tracepoint", "perf_event", "raw_tracepoint", "raw_tracepoint_writable"], "capabilities": ["read_sys_info"]}, "redirect": {"Project": "cilium", "Return Type": "int", "Description": "Redirect the packet to another net device of index ifindex. This helper is somewhat similar to clone_redirect() , except that the packet is not cloned , which provides increased performance. Except for XDP , both ingress and egress interfaces can be used for redirection. The BPF_F_INGRESS value in <[ flags ]>(IP: 1) is used to make the distinction (ingress path is selected if the flag is present , egress path otherwise). Currently , XDP only supports redirection to the egress interface , and accepts no flag at all. The same effect can be attained with the more generic redirect_map() , which requires specific maps to be used but offers better performance. ", "Return": " For XDP, the helper returns XDP_REDIRECT on success or XDP_ABORTED on error.                     For  other  program  types,  the  values  are  TC_ACT_REDIRECT on success or                     TC_ACT_SHOT on error.", "Function Name": "redirect", "Input Params": ["{Type: u32 ,Var: ifindex}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp", "lwt_xmit"], "capabilities": []}, "get_route_realm": {"Project": "cilium", "Return Type": "u32", "Description": "Retrieve the realm or the route , that is to say the tclassid field of the destination for the skb. The indentifier retrieved is a user-provided tag , similar to the one used with the net_cls cgroup (see description for get_cgroup_classid() helper) , but here this tag is held by a route (a destination entry) , not by a task. Retrieving this identifier works with the clsact TC egress hook (see also tc-bpf(8)) , or alternatively on conventional classful egress qdiscs , but not on TC ingress path. In case of clsact TC egress hook , this has the advantage that , internally , the destination entry has not been dropped yet in the transmit path. Therefore , the destination entry does not need to be artificially held via netif_keep_dst() for a classful qdisc until the <[ skb ]>(IP: 0) is freed. This helper is available only if the kernel was compiled with CONFIG_IP_ROUTE_CLASSID configuration option. ", "Return": " The  realm  of  the route for the packet associated to skb, or 0 if none was                     found.", "Function Name": "get_route_realm", "Input Params": ["{Type: struct sk_buff ,Var: *skb}"], "compatible_hookpoints": ["sched_cls", "sched_act", "lwt_in", "lwt_out", "lwt_xmit", "lwt_seg6local"], "capabilities": ["read_sys_info"]}, "perf_event_output": {"Project": "cilium", "Return Type": "int", "Description": "Write raw <[ data ]>(IP: 3) blob into a special BPF perf event held by <[ map ]>(IP: 1) of type BPF_MAP_TYPE_PERF_EVENT_ARRAY. This perf event must have the following attributes: PERF_SAMPLE_RAW as sample_type , PERF_TYPE_SOFTWARE as type , and PERF_COUNT_SW_BPF_OUTPUT as config. The <[ flags ]>(IP: 2) are used to indicate the index in <[ map ]>(IP: 1) for which the value must be put , masked with BPF_F_INDEX_MASK. Alternatively , <[ flags ]>(IP: 2) can be set to BPF_F_CURRENT_CPU to indicate that the index of the current CPU core should be used. The value to write , of <[ size ]>(IP: 4) , is passed through eBPF stack and pointed by data. The context of the program <[ ctx ]>(IP: 0) needs also be passed to the helper. On user space , a program willing to read the values needs to call perf_event_open() on the perf event (either for one or for all CPUs) and to store the file descriptor into the map. This must be done before the eBPF program can send <[ data ]>(IP: 3) into it. An example is available in file samples/bpf/trace_output_user. c in the Linux kernel source tree (the eBPF program counterpart is in samples/bpf/trace_output_kern. c). perf_event_output() achieves better performance than trace_printk() for sharing <[ data ]>(IP: 3) with user space , and is much better suitable for streaming <[ data ]>(IP: 3) from eBPF programs. Note that this helper is not restricted to tracing use cases and can be used with programs attached to TC or XDP as well , where it allows for passing <[ data ]>(IP: 3) to user space listeners. Data can be: \u00b7 Only custom structs , \u00b7 Only the packet payload , or \u00b7 A combination of both. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "perf_event_output", "Input Params": ["{Type: struct pt_regs ,Var: *ctx}", "{Type:  struct map ,Var: *map}", "{Type:  u64 ,Var: flags}", "{Type:  void ,Var: *data}", "{Type:  u64 ,Var: size}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "raw_tracepoint", "lwt_seg6local", "raw_tracepoint_writable"], "capabilities": []}, "skb_load_bytes": {"Project": "cilium", "Return Type": "int", "Description": "This helper was provided as an easy way <[ to ]>(IP: 2) load data from a packet. It can be used <[ to ]>(IP: 2) load <[ len ]>(IP: 3) bytes from <[ offset ]>(IP: 1) from the packet associated <[ to ]>(IP: 2) <[ skb ]>(IP: 0) , into the buffer pointed by to. Since Linux 4. 7 , usage of this helper has mostly been replaced by \"direct packet access\" , enabling packet data <[ to ]>(IP: 2) be manipulated with skb->data and skb->data_end pointing respectively <[ to ]>(IP: 2) the first byte of packet data and <[ to ]>(IP: 2) the byte after the last byte of packet data. However , it remains useful if one wishes <[ to ]>(IP: 2) read large quantities of data at once from a packet into the eBPF stack. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "skb_load_bytes", "Input Params": ["{Type: const struct sk_buff ,Var: *skb}", "{Type:  u32 ,Var: offset}", "{Type:  void ,Var: *to}", "{Type:  u32 ,Var: len}"], "compatible_hookpoints": ["socket_filter", "sched_cls", "sched_act", "cgroup_skb", "lwt_in", "lwt_out", "lwt_xmit", "sk_skb", "lwt_seg6local", "sk_reuseport", "flow_dissector"], "capabilities": ["read_skb"]}, "get_stackid": {"Project": "cilium", "Return Type": "int", "Description": "Walk a user or a kernel stack and return its id. To achieve this , the helper needs <[ ctx ]>(IP: 0) , which is a pointer to the context on which the tracing program is executed , and a pointer to a <[ map ]>(IP: 1) of type BPF_MAP_TYPE_STACK_TRACE. The last argument , <[ flags ]>(IP: 2) , holds the number of stack frames to skip (from 0 to 255) , masked with BPF_F_SKIP_FIELD_MASK. The next bits can be used to set a combination of the following flags: BPF_F_USER_STACK Collect a user space stack instead of a kernel stack. BPF_F_FAST_STACK_CMP Compare stacks by hash only. BPF_F_REUSE_STACKID If two different stacks hash into the same stackid , discard the old one. The stack id retrieved is a 32 bit long integer handle which can be further combined with other data (including other stack ids) and used as a key into maps. This can be useful for generating a variety of graphs (such as flame graphs or off-cpu graphs). For walking a stack , this helper is an improvement over probe_read() , which can be used with unrolled loops but is not efficient and consumes a lot of eBPF instructions. Instead , get_stackid() can collect up to PERF_MAX_STACK_DEPTH both kernel and user frames. Note that this limit can be controlled with the sysctl program , and that it should be manually increased in order to profile long user stacks (such as stacks for Java programs). To do so , use: # sysctl kernel. perf_event_max_stack=<new value> ", "Return": " The positive or null stack id on success, or a negative  error  in  case  of                     failure.", "Function Name": "get_stackid", "Input Params": ["{Type: struct pt_regs ,Var: *ctx}", "{Type:  struct map ,Var: *map}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["kprobe", "tracepoint", "perf_event", "raw_tracepoint", "raw_tracepoint_writable"], "capabilities": ["read_sys_info"]}, "csum_diff": {"Project": "cilium", "Return Type": "s64", "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ", "Return": " The checksum result, or a negative error code in case of failure.", "Function Name": "csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp", "lwt_in", "lwt_out", "lwt_xmit", "lwt_seg6local"], "capabilities": ["read_skb"]}, "skb_get_tunnel_opt": {"Project": "cilium", "Return Type": "int", "Description": "Retrieve tunnel options metadata for the packet associated to <[ skb ]>(IP: 0) , and store the raw tunnel option data to the buffer <[ opt ]>(IP: 1) of size. This helper can be used with encapsulation devices that can operate in \"collect metadata\" mode (please refer to the related note in the description of skb_get_tunnel_key() for more details). A particular example where this can be used is in combination with the Geneve encapsulation protocol , where it allows for pushing (with skb_get_tunnel_opt() helper) and retrieving arbitrary TLVs (Type-Length-Value headers) from the eBPF program. This allows for full customization of these headers. ", "Return": " The size of the option data retrieved.", "Function Name": "skb_get_tunnel_opt", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  u8 ,Var: *opt}", "{Type:  u32 ,Var: size}"], "compatible_hookpoints": ["sched_cls", "sched_act", "lwt_xmit"], "capabilities": ["read_skb", "read_sys_info"]}, "skb_set_tunnel_opt": {"Project": "cilium", "Return Type": "int", "Description": "Set tunnel options metadata for the packet associated to <[ skb ]>(IP: 0) to the option data contained in the raw buffer <[ opt ]>(IP: 1) of size. See also the description of the skb_get_tunnel_opt() helper for additional information. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "skb_set_tunnel_opt", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  u8 ,Var: *opt}", "{Type:  u32 ,Var: size}"], "compatible_hookpoints": ["sched_cls", "sched_act", "lwt_xmit"], "capabilities": ["update_pkt"]}, "skb_change_proto": {"Project": "cilium", "Return Type": "int", "Description": "Change the protocol of the <[ skb ]>(IP: 0) to proto. Currently supported are transition from IPv4 to IPv6 , and from IPv6 to IPv4. The helper takes care of the groundwork for the transition , including resizing the socket buffer. The eBPF program is expected to fill the new headers , if any , via skb_store_bytes() and to recompute the checksums with l3_csum_replace() and l4_csum_replace(). The main case for this helper is to perform NAT64 operations out of an eBPF program. Internally , the GSO type is marked as dodgy so that headers are checked and segments are recalculated by the GSO/GRO engine. The size for GSO target is adapted as well. All values for <[ flags ]>(IP: 2) are reserved for future usage , and must be left at zero. A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "skb_change_proto", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  __be16 ,Var: proto}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["sched_cls", "sched_act"], "capabilities": ["update_pkt"]}, "skb_change_type": {"Project": "cilium", "Return Type": "int", "Description": "Change the packet <[ type ]>(IP: 1) for the packet associated to skb. This comes down to setting skb->pkt_type to <[ type ]>(IP: 1) , except the eBPF program does not have a write access to skb->pkt_type beside this helper. Using a helper here allows for graceful handling of errors. The major use case is to change incoming skb*s to **PACKET_HOST* in a programmatic way instead of having to recirculate via redirect(. . . , BPF_F_INGRESS) , for example. Note that <[ type ]>(IP: 1) only allows certain values. At this time , they are: PACKET_HOST Packet is for us. PACKET_BROADCAST Send packet to all. PACKET_MULTICAST Send packet to group. PACKET_OTHERHOST Send packet to someone else. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "skb_change_type", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  u32 ,Var: type}"], "compatible_hookpoints": ["sched_cls", "sched_act"], "capabilities": ["update_pkt"]}, "skb_under_cgroup": {"Project": "cilium", "Return Type": "int", "Description": "Check whether <[ skb ]>(IP: 0) is a descendant of the cgroup2 held by <[ map ]>(IP: 1) of type BPF_MAP_TYPE_CGROUP_ARRAY , at index. ", "Return": " The return value depends on the result of the test, and can be:                     \u00b7 0, if the skb failed the cgroup2 descendant test.                     \u00b7 1, if the skb succeeded the cgroup2 descendant test.                     \u00b7 A negative error code, if an error occurred.", "Function Name": "skb_under_cgroup", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  struct map ,Var: *map}", "{Type:  u32 ,Var: index}"], "compatible_hookpoints": ["sched_cls", "sched_act", "lwt_in", "lwt_out", "lwt_xmit", "lwt_seg6local"], "capabilities": ["read_skb", "read_sys_info"]}, "get_hash_recalc": {"Project": "cilium", "Return Type": "u32", "Description": "Retrieve the hash of the packet , skb->hash. If it is not set , in particular if the hash was cleared due to mangling , recompute this hash. Later accesses to the hash can be done directly with skb->hash. Calling set_hash_invalid() , changing a packet prototype with skb_change_proto() , or calling skb_store_bytes() with the BPF_F_INVALIDATE_HASH are actions susceptible to clear the hash and to trigger a new computation for the next call to get_hash_recalc(). ", "Return": " The 32-bit hash.", "Function Name": "get_hash_recalc", "Input Params": ["{Type: struct sk_buff ,Var: *skb}"], "compatible_hookpoints": ["sched_cls", "sched_act", "lwt_in", "lwt_out", "lwt_xmit", "lwt_seg6local"], "capabilities": ["read_sys_info"]}, "get_current_task": {"Project": "cilium", "Return Type": "u64", "Return": " A pointer to the current task struct.", "Function Name": "get_current_task", "Input Params": ["{Type: voi ,Var: void}"], "Description": "A pointer to the current task struct. ", "compatible_hookpoints": ["kprobe", "tracepoint", "perf_event", "raw_tracepoint", "raw_tracepoint_writable"], "capabilities": ["read_sys_info"]}, "probe_write_user": {"Project": "cilium", "Return Type": "int", "Description": "Attempt in a safe way to write <[ len ]>(IP: 2) bytes from the buffer <[ src ]>(IP: 1) to <[ dst ]>(IP: 0) in memory. It only works for threads that are in user context , and <[ dst ]>(IP: 0) must be a valid user space address. This helper should not be used to implement any kind of security mechanism because of TOC-TOU attacks , but rather to debug , divert , and manipulate execution of semi-cooperative processes. Keep in mind that this feature is meant for experiments , and it has a risk of crashing the system and running programs. Therefore , when an eBPF program using this helper is attached , a warning including PID and process name is printed to kernel logs. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "probe_write_user", "Input Params": ["{Type: void ,Var: *dst}", "{Type:  const void ,Var: *src}", "{Type:  u32 ,Var: len}"], "compatible_hookpoints": ["kprobe", "tracepoint", "perf_event", "raw_tracepoint", "raw_tracepoint_writable"], "capabilities": []}, "current_task_under_cgroup": {"Project": "cilium", "Return Type": "int", "Description": "Check whether the probe is being run is the context of a given subset of the cgroup2 hierarchy. The cgroup2 to test is held by <[ map ]>(IP: 0) of type BPF_MAP_TYPE_CGROUP_ARRAY , at index. ", "Return": " The return value depends on the result of the test, and can be:                     \u00b7 0, if the skb task belongs to the cgroup2.                     \u00b7 1, if the skb task does not belong to the cgroup2.                     \u00b7 A negative error code, if an error occurred.", "Function Name": "current_task_under_cgroup", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  u32 ,Var: index}"], "compatible_hookpoints": ["kprobe", "tracepoint", "perf_event", "raw_tracepoint", "raw_tracepoint_writable"], "capabilities": ["read_sys_info"]}, "skb_change_tail": {"Project": "cilium", "Return Type": "int", "Description": "Resize (trim or grow) the packet associated to <[ skb ]>(IP: 0) to the new len. The <[ flags ]>(IP: 2) are reserved for future usage , and must be left at zero. The basic idea is that the helper performs the needed work to change the size of the packet , then the eBPF program rewrites the rest via helpers like skb_store_bytes() , l3_csum_replace() , l3_csum_replace() and others. This helper is a slow path utility intended for replies with control messages. And because it is targeted for slow path , the helper itself can afford to be slow: it implicitly linearizes , unclones and drops offloads from the skb. A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "skb_change_tail", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  u32 ,Var: len}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["sched_cls", "sched_act", "lwt_xmit", "sk_skb"], "capabilities": ["update_pkt"]}, "skb_pull_data": {"Project": "cilium", "Return Type": "int", "Description": "Pull in non-linear data in case the <[ skb ]>(IP: 0) is non-linear and not all of <[ len ]>(IP: 1) are part of the linear section. Make <[ len ]>(IP: 1) bytes from <[ skb ]>(IP: 0) readable and writable. If a zero value is passed for <[ len ]>(IP: 1) , then the whole length of the <[ skb ]>(IP: 0) is pulled. This helper is only needed for reading and writing with direct packet access. For direct packet access , testing that offsets to access are within packet boundaries (test on skb->data_end) is susceptible to fail if offsets are invalid , or if the requested data is in non-linear parts of the skb. On failure the program can just bail out , or in the case of a non-linear buffer , use a helper to make the data available. The skb_load_bytes() helper is a first solution to access the data. Another one consists in using skb_pull_data to pull in once the non-linear parts , then retesting and eventually access the data. At the same time , this also makes sure the <[ skb ]>(IP: 0) is uncloned , which is a necessary condition for direct write. As this needs to be an invariant for the write part only , the verifier detects writes and adds a prologue that is calling skb_pull_data() to effectively unclone the <[ skb ]>(IP: 0) from the very beginning in case it is indeed cloned. A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "skb_pull_data", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  u32 ,Var: len}"], "compatible_hookpoints": ["sched_cls", "sched_act", "lwt_in", "lwt_out", "lwt_xmit", "sk_skb", "lwt_seg6local"], "capabilities": ["update_pkt"]}, "csum_update": {"Project": "cilium", "Return Type": "s64", "Description": "Add the checksum <[ csum ]>(IP: 1) into skb->csum in case the driver has supplied a checksum for the entire packet into that field. Return an error otherwise. This helper is intended to be used in combination with csum_diff() , in particular when the checksum needs to be updated after data has been written into the packet through direct packet access. ", "Return": " The checksum on success, or a negative error code in case of failure.", "Function Name": "csum_update", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  __wsum ,Var: csum}"], "compatible_hookpoints": ["sched_cls", "sched_act", "lwt_xmit"], "capabilities": ["update_pkt"]}, "set_hash_invalid": {"Project": "cilium", "Return Type": "void", "Description": "Invalidate the current skb->hash. It can be used after mangling on headers through direct packet access , in order to indicate that the hash is outdated and to trigger a recalculation the next time the kernel tries to access this hash or when the get_hash_recalc() helper is called. ", "Function Name": "set_hash_invalid", "Input Params": ["{Type: struct sk_buff ,Var: *skb}"], "compatible_hookpoints": ["sched_cls", "sched_act", "lwt_xmit"], "capabilities": ["update_pkt"]}, "get_numa_node_id": {"Project": "cilium", "Return Type": "int", "Description": "Return the id of the current NUMA node. The primary use case for this helper is the selection of sockets for the local NUMA node , when the program is attached to sockets using the SO_ATTACH_REUSEPORT_EBPF option (see also socket(7)) , but the helper is also available to other eBPF program types , similarly to get_smp_processor_id(). ", "Return": " The id of current NUMA node.", "Function Name": "get_numa_node_id", "Input Params": ["{Type: voi ,Var: void}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "raw_tracepoint_writable"], "capabilities": ["read_sys_info"]}, "skb_change_head": {"Project": "cilium", "Return Type": "int", "Description": "Grows headroom of packet associated to <[ skb ]>(IP: 0) and adjusts the offset of the MAC header accordingly , adding <[ len ]>(IP: 1) bytes of space. It automatically extends and reallocates memory as required. This helper can be used on a layer 3 <[ skb ]>(IP: 0) to push a MAC header for redirection into a layer 2 device. All values for <[ flags ]>(IP: 2) are reserved for future usage , and must be left at zero. A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "skb_change_head", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  u32 ,Var: len}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["sched_cls", "sched_act", "lwt_xmit", "sk_skb"], "capabilities": ["update_pkt"]}, "xdp_adjust_head": {"Project": "cilium", "Return Type": "int", "Description": "Adjust (move) xdp_md->data by <[ delta ]>(IP: 1) bytes. Note that it is possible to use a negative value for delta. This helper can be used to prepare the packet for pushing or popping headers. A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "xdp_adjust_head", "Input Params": ["{Type: struct xdp_buff ,Var: *xdp_md}", "{Type:  int ,Var: delta}"], "compatible_hookpoints": ["xdp"], "capabilities": ["update_pkt"]}, "probe_read_str": {"Project": "cilium", "Return Type": "int", "Description": "Copy a NUL terminated string from an unsafe address <[ unsafe_ptr ]>(IP: 2) to dst. The <[ size ]>(IP: 1) should include the terminating NUL byte. In case the string length is smaller than <[ size ]>(IP: 1) , the target is not padded with further NUL bytes. If the string length is larger than <[ size ]>(IP: 1) , just size-1 bytes are copied and the last byte is set to NUL. On success , the length of the copied string is returned. This makes this helper useful in tracing programs for reading strings , and more importantly to get its length at runtime. See the following snippet: SEC(\"kprobe / sys_open\") void sys_open(struct pt_regs *ctx) { char buf[PATHLEN]; // PATHLEN is defined to 256 int res = probe_read_str(buf , sizeof(buf) , ctx->di); // Consume buf , for example push it to // userspace via perf_event_output(); we // can use res (the string length) as event // <[ size ]>(IP: 1) , after checking its boundaries. } In comparison , using probe_read() helper here instead to read the string would require to estimate the length at compile time , and would often result in copying more memory than necessary. Another useful use case is when parsing individual process arguments or individual environment variables navigating current->mm->arg_start and current->mm->env_start: using this helper and the return value , one can quickly iterate at the right offset of the memory area. ", "Return": " On  success,  the  strictly  positive  length  of  the string, including the                     trailing NUL character. On error, a negative value.", "Function Name": "probe_read_str", "Input Params": ["{Type: void ,Var: *dst}", "{Type:  int ,Var: size}", "{Type:  const void ,Var: *unsafe_ptr}"], "compatible_hookpoints": ["kprobe", "tracepoint", "perf_event", "raw_tracepoint", "raw_tracepoint_writable"], "capabilities": ["read_sys_info"]}, "get_socket_cookie": {"Project": "cilium", "Return Type": "u64", "Description": "Equivalent to get_socket_cookie() helper that accepts skb , but gets socket from struct sock_ops context. ", "Return": " A 8-byte long non-decreasing number.", "Function Name": "get_socket_cookie", "Input Params": ["{Type: struct sock_ops ,Var: *ctx}"], "compatible_hookpoints": ["socket_filter", "sched_cls", "sched_act", "cgroup_skb", "sock_ops", "sk_skb", "cgroup_sock_addr"], "capabilities": ["read_sys_info"]}, "get_socket_uid": {"Project": "cilium", "Return Type": "u32", "Return": " The owner UID of the socket associated to skb. If the socket is NULL, or  if                     it  is  not  a  full  socket  (i.e. if it is a time-wait or a request socket                     instead), overflowuid value is returned (note that overflowuid might also be                     the actual UID value for the socket).", "Function Name": "get_socket_uid", "Input Params": ["{Type: struct sk_buff ,Var: *skb}"], "Description": "The owner UID of the socket associated to skb. If the socket is NULL , or if it is not a full socket (i. e. if it is a time-wait or a request socket instead) , overflowuid value is returned (note that overflowuid might also be the actual UID value for the socket). ", "compatible_hookpoints": ["socket_filter", "sched_cls", "sched_act", "cgroup_skb", "sk_skb"], "capabilities": ["read_sys_info"]}, "set_hash": {"Project": "cilium", "Return Type": "u32", "Description": "Set the full <[ hash ]>(IP: 1) for <[ skb ]>(IP: 0) (set the field skb->hash) to value hash. ", "Return": " 0", "Function Name": "set_hash", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  u32 ,Var: hash}"], "compatible_hookpoints": ["sched_cls", "sched_act"], "capabilities": ["update_pkt"]}, "setsockopt": {"Project": "cilium", "Return Type": "int", "Description": "Emulate a call to setsockopt() on the socket associated to <[ socket ]>(IP: 0) , which must be a full socket. The <[ level ]>(IP: 1) at which the option resides and the name <[ optname ]>(IP: 2) of the option must be specified , see setsockopt(2) for more information. The option value of length <[ optlen ]>(IP: 4) is pointed by optval. This helper actually implements a subset of setsockopt(). It supports the following levels: \u00b7 SOL_SOCKET , which supports the following optnames: SO_RCVBUF , SO_SNDBUF , SO_MAX_PACING_RATE , SO_PRIORITY , SO_RCVLOWAT , SO_MARK. \u00b7 IPPROTO_TCP , which supports the following optnames: TCP_CONGESTION , TCP_BPF_IW , TCP_BPF_SNDCWND_CLAMP. \u00b7 IPPROTO_IP , which supports <[ optname ]>(IP: 2) IP_TOS. \u00b7 IPPROTO_IPV6 , which supports <[ optname ]>(IP: 2) IPV6_TCLASS. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "setsockopt", "Input Params": ["{Type: struct sock_ops ,Var: *socket}", "{Type:  int ,Var: level}", "{Type:  int ,Var: optname}", "{Type:  char ,Var: *optval}", "{Type:  int ,Var: optlen}"], "compatible_hookpoints": ["sock_ops"], "capabilities": ["update_pkt"]}, "skb_adjust_room": {"Project": "cilium", "Return Type": "int", "Description": "Grow or shrink the room for data in the packet associated to <[ skb ]>(IP: 0) by <[ len_diff ]>(IP: 1) , and according to the selected mode. There are two supported modes at this time: \u00b7 BPF_ADJ_ROOM_MAC: Adjust room at the mac layer (room space is added or removed below the layer 2 header). \u00b7 BPF_ADJ_ROOM_NET: Adjust room at the network layer (room space is added or removed below the layer 3 header). The following <[ flags ]>(IP: 3) are supported at this time: \u00b7 BPF_F_ADJ_ROOM_FIXED_GSO: Do not adjust gso_size. Adjusting mss in this way is not allowed for datagrams. \u00b7 BPF_F_ADJ_ROOM_ENCAP_L3_IPV4 , BPF_F_ADJ_ROOM_ENCAP_L3_IPV6: Any new space is reserved to hold a tunnel header. Configure <[ skb ]>(IP: 0) offsets and other fields accordingly. \u00b7 BPF_F_ADJ_ROOM_ENCAP_L4_GRE , BPF_F_ADJ_ROOM_ENCAP_L4_UDP: Use with ENCAP_L3 <[ flags ]>(IP: 3) to further specify the tunnel type. \u00b7 BPF_F_ADJ_ROOM_ENCAP_L2(len): Use with ENCAP_L3/L4 <[ flags ]>(IP: 3) to further specify the tunnel type; len is the length of the inner MAC header. A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "skb_adjust_room", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  s32 ,Var: len_diff}", "{Type:  u32 ,Var: mode}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["sched_cls", "sched_act"], "capabilities": ["update_pkt"]}, "redirect_map": {"Project": "cilium", "Return Type": "int", "Description": "Redirect the packet to the endpoint referenced by <[ map ]>(IP: 0) at index key. Depending on its type , this <[ map ]>(IP: 0) can contain references to net devices (for forwarding packets through other ports) , or to CPUs (for redirecting XDP frames to another CPU; but this is only implemented for native XDP (with driver support) as of this writing). The lower two bits of <[ flags ]>(IP: 2) are used as the return code if the <[ map ]>(IP: 0) lookup fails. This is so that the return value can be one of the XDP program return codes up to XDP_TX , as chosen by the caller. Any higher bits in the <[ flags ]>(IP: 2) argument must be unset. When used to redirect packets to net devices , this helper provides a high performance increase over redirect(). This is due to various implementation details of the underlying mechanisms , one of which is the fact that redirect_map() tries to send packet as a \"bulk\" to the device. ", "Return": " XDP_REDIRECT on success, or XDP_ABORTED on error.", "Function Name": "redirect_map", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  u32 ,Var: key}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["xdp"], "capabilities": []}, "sk_redirect_map": {"Project": "cilium", "Return Type": "int", "Description": "Redirect the packet to the socket referenced by <[ map ]>(IP: 0) (of type BPF_MAP_TYPE_SOCKMAP) at index key. Both ingress and egress interfaces can be used for redirection. The BPF_F_INGRESS value in <[ flags ]>(IP: 2) is used to make the distinction (ingress path is selected if the flag is present , egress path otherwise). This is the only flag supported for now. ", "Return": " SK_PASS on success, or SK_DROP on error.", "Function Name": "sk_redirect_map", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  u32 ,Var: key}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["sk_skb"], "capabilities": []}, "sock_map_update": {"Project": "cilium", "Return Type": "int", "Description": "Add an entry to , or update a <[ map ]>(IP: 1) referencing sockets. The <[ skops ]>(IP: 0) is used as a new value for the entry associated to key. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 2) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 2) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. If the <[ map ]>(IP: 1) has eBPF programs (parser and verdict) , those will be inherited by the socket being added. If the socket is already attached to eBPF programs , this results in an error. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "sock_map_update", "Input Params": ["{Type: struct sock_ops ,Var: *skops}", "{Type:  struct map ,Var: *map}", "{Type:  void ,Var: *key}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["sock_ops"], "capabilities": ["map_update"]}, "xdp_adjust_meta": {"Project": "cilium", "Return Type": "int", "Description": "Adjust the address pointed by xdp_md->data_meta by <[ delta ]>(IP: 1) (which can be positive or negative). Note that this operation modifies the address stored in xdp_md->data , so the latter must be loaded only after the helper has been called. The use of xdp_md->data_meta is optional and programs are not required to use it. The rationale is that when the packet is processed with XDP (e. g. as DoS filter) , it is possible to push further meta data along with it before passing to the stack , and to give the guarantee that an ingress eBPF program attached as a TC classifier on the same device can pick this up for further post-processing. Since TC works with socket buffers , it remains possible to set from XDP the mark or priority pointers , or other pointers for the socket buffer. Having this scratch space generic and programmable allows for more flexibility as the user is free to store whatever meta data they need. A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "xdp_adjust_meta", "Input Params": ["{Type: struct xdp_buff ,Var: *xdp_md}", "{Type:  int ,Var: delta}"], "compatible_hookpoints": ["xdp"], "capabilities": ["update_pkt"]}, "perf_event_read_value": {"Project": "cilium", "Return Type": "int", "Description": "Read the value of a perf event counter , and store it into <[ buf ]>(IP: 2) of size buf_size. This helper relies on a <[ map ]>(IP: 0) of type BPF_MAP_TYPE_PERF_EVENT_ARRAY. The nature of the perf event counter is selected when <[ map ]>(IP: 0) is updated with perf event file descriptors. The <[ map ]>(IP: 0) is an array whose size is the number of available CPUs , and each cell contains a value relative to one CPU. The value to retrieve is indicated by <[ flags ]>(IP: 1) , that contains the index of the CPU to look up , masked with BPF_F_INDEX_MASK. Alternatively , <[ flags ]>(IP: 1) can be set to BPF_F_CURRENT_CPU to indicate that the value for the current CPU should be retrieved. This helper behaves in a way close to perf_event_read() helper , save that instead of just returning the value observed , it fills the <[ buf ]>(IP: 2) structure. This allows for additional data to be retrieved: in particular , the enabled and running times (in buf->enabled and buf->running , respectively) are copied. In general , perf_event_read_value() is recommended over perf_event_read() , which has some ABI issues and provides fewer functionalities. These values are interesting , because hardware PMU (Performance Monitoring Unit) counters are limited resources. When there are more PMU based perf events opened than available counters , kernel will multiplex these events so each event gets certain percentage (but not all) of the PMU time. In case that multiplexing happens , the number of samples or counter value will not reflect the case compared to when no multiplexing occurs. This makes comparison between different runs difficult. Typically , the counter value should be normalized before comparing to other experiments. The usual normalization is done as follows. normalized_counter = counter * t_enabled / t_running Where t_enabled is the time enabled for event and t_running is the time running for event since last normalization. The enabled and running times are accumulated since the perf event open. To achieve scaling factor between two invocations of an eBPF program , users can can use CPU id as the key (which is typical for perf array usage model) to remember the previous value and do the calculation inside the eBPF program. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "perf_event_read_value", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  u64 ,Var: flags}", "{Type:  struct perf_event_value ,Var: *buf}", "{Type:  u32 ,Var: buf_size}"], "compatible_hookpoints": ["kprobe"], "capabilities": ["read_sys_info"]}, "perf_prog_read_value": {"Project": "cilium", "Return Type": "int", "Description": "For en eBPF program attached to a perf event , retrieve the value of the event counter associated to <[ ctx ]>(IP: 0) and store it in the structure pointed by <[ buf ]>(IP: 1) and of size buf_size. Enabled and running times are also stored in the structure (see description of helper perf_event_read_value() for more details). ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "perf_prog_read_value", "Input Params": ["{Type: struct perf_event_data ,Var: *ctx}", "{Type:  struct perf_event_value ,Var: *buf}", "{Type:  u32 ,Var: buf_size}"], "compatible_hookpoints": ["perf_event"], "capabilities": ["read_sys_info"]}, "getsockopt": {"Project": "cilium", "Return Type": "int", "Description": "Emulate a call to getsockopt() on the socket associated to <[ socket ]>(IP: 0) , which must be a full socket. The <[ level ]>(IP: 1) at which the option resides and the name <[ optname ]>(IP: 2) of the option must be specified , see getsockopt(2) for more information. The retrieved value is stored in the structure pointed by opval and of length optlen. This helper actually implements a subset of getsockopt(). It supports the following levels: \u00b7 IPPROTO_TCP , which supports <[ optname ]>(IP: 2) TCP_CONGESTION. \u00b7 IPPROTO_IP , which supports <[ optname ]>(IP: 2) IP_TOS. \u00b7 IPPROTO_IPV6 , which supports <[ optname ]>(IP: 2) IPV6_TCLASS. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "getsockopt", "Input Params": ["{Type: struct sock_ops ,Var: *socket}", "{Type:  int ,Var: level}", "{Type:  int ,Var: optname}", "{Type:  char ,Var: *optval}", "{Type:  int ,Var: optlen}"], "compatible_hookpoints": ["sock_ops"], "capabilities": ["read_sys_info"]}, "override_return": {"Project": "cilium", "Return Type": "int", "Description": "Used for error injection , this helper uses kprobes to override the return value of the probed function , and to set it to rc. The first argument is the context <[ regs ]>(IP: 0) on which the kprobe works. This helper works by setting setting the PC (program counter) to an override function which is run in place of the original probed function. This means the probed function is not run at all. The replacement function just returns with the required value. This helper has security implications , and thus is subject to restrictions. It is only available if the kernel was compiled with the CONFIG_BPF_KPROBE_OVERRIDE configuration option , and in this case it only works on functions tagged with ALLOW_ERROR_INJECTION in the kernel code. Also , the helper is only available for the architectures having the CONFIG_FUNCTION_ERROR_INJECTION option. As of this writing , x86 architecture is the only one to support this feature. ", "Return": " 0", "Function Name": "override_return", "Input Params": ["{Type: struct pt_regs ,Var: *regs}", "{Type:  u64 ,Var: rc}"], "compatible_hookpoints": ["kprobe"], "capabilities": []}, "sock_ops_cb_flags_set": {"Project": "cilium", "Return Type": "int", "Description": "Attempt to set the value of the sock_ops_cb_flags field for the full TCP socket associated to sock_ops to argval. The primary use of this field is to determine if there should be calls to eBPF programs of type BPF_PROG_TYPE_SOCK_OPS at various points in the TCP code. A program of the same type can change its value , per connection and as necessary , when the connection is established. This field is directly accessible for reading , but this helper must be used for updates in order to return an error if an eBPF program tries to set a callback that is not supported in the current kernel. <[ argval ]>(IP: 1) is a flag array which can combine these flags: \u00b7 BPF_SOCK_OPS_RTO_CB_FLAG (retransmission time out) \u00b7 BPF_SOCK_OPS_RETRANS_CB_FLAG (retransmission) \u00b7 BPF_SOCK_OPS_STATE_CB_FLAG (TCP state change) \u00b7 BPF_SOCK_OPS_RTT_CB_FLAG (every RTT) Therefore , this function can be used to clear a callback flag by setting the appropriate bit to zero. e. g. to disable the RTO callback: sock_ops_cb_flags_set(sock , sock->sock_ops_cb_flags & ~BPF_SOCK_OPS_RTO_CB_FLAG) Here are some examples of where one could call such eBPF program: \u00b7 When RTO fires. \u00b7 When a packet is retransmitted. \u00b7 When the connection terminates. \u00b7 When a packet is sent. \u00b7 When a packet is received. ", "Return": " Code -EINVAL if the socket is not a full TCP socket; otherwise,  a  positive                     number  containing  the  bits that could not be set is returned (which comes                     down to 0 if all bits were set as required).", "Function Name": "sock_ops_cb_flags_set", "Input Params": ["{Type: struct sock_ops ,Var: *sock}", "{Type:  int ,Var: argval}"], "compatible_hookpoints": ["sock_ops"], "capabilities": ["update_pkt"]}, "msg_redirect_map": {"Project": "cilium", "Return Type": "int", "Description": "This helper is used in programs implementing policies at the socket level. If the message <[ msg ]>(IP: 0) is allowed to pass (i. e. if the verdict eBPF program returns SK_PASS) , redirect it to the socket referenced by <[ map ]>(IP: 1) (of type BPF_MAP_TYPE_SOCKMAP) at index key. Both ingress and egress interfaces can be used for redirection. The BPF_F_INGRESS value in <[ flags ]>(IP: 3) is used to make the distinction (ingress path is selected if the flag is present , egress path otherwise). This is the only flag supported for now. ", "Return": " SK_PASS on success, or SK_DROP on error.", "Function Name": "msg_redirect_map", "Input Params": ["{Type: struct sk_msg_buff ,Var: *msg}", "{Type:  struct map ,Var: *map}", "{Type:  u32 ,Var: key}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["sk_msg"], "capabilities": []}, "msg_apply_bytes": {"Project": "cilium", "Return Type": "int", "Description": "For socket policies , apply the verdict of the eBPF program to the next <[ bytes ]>(IP: 1) (number of bytes) of message msg. For example , this helper can be used in the following cases: \u00b7 A single sendmsg() or sendfile() system call contains multiple logical messages that the eBPF program is supposed to read and for which it should apply a verdict. \u00b7 An eBPF program only cares to read the first <[ bytes ]>(IP: 1) of a msg. If the message has a large payload , then setting up and calling the eBPF program repeatedly for all <[ bytes ]>(IP: 1) , even though the verdict is already known , would create unnecessary overhead. When called from within an eBPF program , the helper sets a counter internal to the BPF infrastructure , that is used to apply the last verdict to the next bytes. If <[ bytes ]>(IP: 1) is smaller than the current data being processed from a sendmsg() or sendfile() system call , the first <[ bytes ]>(IP: 1) will be sent and the eBPF program will be re-run with the pointer for start of data pointing to byte number <[ bytes ]>(IP: 1) + 1. If <[ bytes ]>(IP: 1) is larger than the current data being processed , then the eBPF verdict will be applied to multiple sendmsg() or sendfile() calls until <[ bytes ]>(IP: 1) are consumed. Note that if a socket closes with the internal counter holding a non-zero value , this is not a problem because data is not being buffered for <[ bytes ]>(IP: 1) and is sent as it is received. ", "Return": " 0", "Function Name": "msg_apply_bytes", "Input Params": ["{Type: struct sk_msg_buff ,Var: *msg}", "{Type:  u32 ,Var: bytes}"], "compatible_hookpoints": ["sk_msg"], "capabilities": []}, "msg_cork_bytes": {"Project": "cilium", "Return Type": "int", "Description": "For socket policies , prevent the execution of the verdict eBPF program for message <[ msg ]>(IP: 0) until <[ bytes ]>(IP: 1) (byte number) have been accumulated. This can be used when one needs a specific number of <[ bytes ]>(IP: 1) before a verdict can be assigned , even if the data spans multiple sendmsg() or sendfile() calls. The extreme case would be a user calling sendmsg() repeatedly with 1-byte long message segments. Obviously , this is bad for performance , but it is still valid. If the eBPF program needs <[ bytes ]>(IP: 1) bytes to validate a header , this helper can be used to prevent the eBPF program to be called again until <[ bytes ]>(IP: 1) have been accumulated. ", "Return": " 0", "Function Name": "msg_cork_bytes", "Input Params": ["{Type: struct sk_msg_buff ,Var: *msg}", "{Type:  u32 ,Var: bytes}"], "compatible_hookpoints": ["sk_msg"], "capabilities": []}, "msg_pull_data": {"Project": "cilium", "Return Type": "int", "Description": "For socket policies , pull in non-linear data from user space for <[ msg ]>(IP: 0) and set pointers msg->data and msg->data_end to <[ start ]>(IP: 1) and <[ end ]>(IP: 2) bytes offsets into <[ msg ]>(IP: 0) , respectively. If a program of type BPF_PROG_TYPE_SK_MSG is run on a <[ msg ]>(IP: 0) it can only parse data that the (data , data_end) pointers have already consumed. For sendmsg() hooks this is likely the first scatterlist element. But for calls relying on the sendpage handler (e. g. sendfile()) this will be the range (0 , 0) because the data is shared with user space and by default the objective is to avoid allowing user space to modify data while (or after) eBPF verdict is being decided. This helper can be used to pull in data and to set the <[ start ]>(IP: 1) and <[ end ]>(IP: 2) pointer to given values. Data will be copied if necessary (i. e. if data was not linear and if <[ start ]>(IP: 1) and <[ end ]>(IP: 2) pointers do not point to the same chunk). A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. All values for <[ flags ]>(IP: 3) are reserved for future usage , and must be left at zero. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "msg_pull_data", "Input Params": ["{Type: struct sk_msg_buff ,Var: *msg}", "{Type:  u32 ,Var: start}", "{Type:  u32 ,Var: end}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["sk_msg"], "capabilities": ["update_pkt"]}, "bind": {"Project": "cilium", "Return Type": "int", "Description": "Bind the socket associated to <[ ctx ]>(IP: 0) to the address pointed by <[ addr ]>(IP: 1) , of length addr_len. This allows for making outgoing connection from the desired IP address , which can be useful for example when all processes inside a cgroup should use one single IP address on a host that has multiple IP configured. This helper works for IPv4 and IPv6 , TCP and UDP sockets. The domain (addr->sa_family) must be AF_INET (or AF_INET6). Looking for a free port to bind to can be expensive , therefore binding to port is not permitted by the helper: addr->sin_port (or sin6_port , respectively) must be set to zero. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bind", "Input Params": ["{Type: struct sock_addr ,Var: *ctx}", "{Type:  struct sockaddr ,Var: *addr}", "{Type:  int ,Var: addr_len}"], "compatible_hookpoints": ["cgroup_sock_addr"], "capabilities": []}, "xdp_adjust_tail": {"Project": "cilium", "Return Type": "int", "Description": "Adjust (move) xdp_md->data_end by <[ delta ]>(IP: 1) bytes. It is only possible to shrink the packet as of this writing , therefore <[ delta ]>(IP: 1) must be a negative integer. A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "xdp_adjust_tail", "Input Params": ["{Type: struct xdp_buff ,Var: *xdp_md}", "{Type:  int ,Var: delta}"], "compatible_hookpoints": ["xdp"], "capabilities": ["update_pkt"]}, "skb_get_xfrm_state": {"Project": "cilium", "Return Type": "int", "Description": "Retrieve the XFRM state (IP transform framework , see also ip-xfrm(8)) at <[ index ]>(IP: 1) in XFRM \"security path\" for skb. The retrieved value is stored in the struct xfrm_state pointed by <[ xfrm_state ]>(IP: 2) and of length size. All values for <[ flags ]>(IP: 4) are reserved for future usage , and must be left at zero. This helper is available only if the kernel was compiled with CONFIG_XFRM configuration option. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "skb_get_xfrm_state", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  u32 ,Var: index}", "{Type:  struct xfrm_state ,Var: *xfrm_state}", "{Type:  u32 ,Var: size}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["sched_cls", "sched_act"], "capabilities": ["read_skb", "read_sys_info"]}, "get_stack": {"Project": "cilium", "Return Type": "int", "Description": "Return a user or a kernel stack in bpf program provided buffer. To achieve this , the helper needs ctx , which is a pointer to the context on which the tracing program is executed. To store the stacktrace , the bpf program provides <[ buf ]>(IP: 1) with a nonnegative size. The last argument , <[ flags ]>(IP: 3) , holds the number of stack frames to skip (from 0 to 255) , masked with BPF_F_SKIP_FIELD_MASK. The next bits can be used to set the following flags: BPF_F_USER_STACK Collect a user space stack instead of a kernel stack. BPF_F_USER_BUILD_ID Collect buildid+offset instead of ips for user stack , only valid if BPF_F_USER_STACK is also specified. get_stack() can collect up to PERF_MAX_STACK_DEPTH both kernel and user frames , subject to sufficient large buffer size. Note that this limit can be controlled with the sysctl program , and that it should be manually increased in order to profile long user stacks (such as stacks for Java programs). To do so , use: # sysctl kernel. perf_event_max_stack=<new value> ", "Return": " A non-negative value equal to or less than size on success,  or  a  negative                     error in case of failure.", "Function Name": "get_stack", "Input Params": ["{Type: struct pt_regs ,Var: *regs}", "{Type:  void ,Var: *buf}", "{Type:  u32 ,Var: size}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["kprobe", "tracepoint", "perf_event", "raw_tracepoint", "raw_tracepoint_writable"], "capabilities": ["read_sys_info"]}, "skb_load_bytes_relative": {"Project": "cilium", "Return Type": "int", "Description": "This helper is similar <[ to ]>(IP: 2) skb_load_bytes() in that it provides an easy way <[ to ]>(IP: 2) load <[ len ]>(IP: 3) bytes from <[ offset ]>(IP: 1) from the packet associated <[ to ]>(IP: 2) <[ skb ]>(IP: 0) , into the buffer pointed by to. The difference <[ to ]>(IP: 2) skb_load_bytes() is that a fifth argument <[ start_header ]>(IP: 4) exists in order <[ to ]>(IP: 2) select a base <[ offset ]>(IP: 1) <[ to ]>(IP: 2) start from. <[ start_header ]>(IP: 4) can be one of: BPF_HDR_START_MAC Base <[ offset ]>(IP: 1) <[ to ]>(IP: 2) load data from is skb's mac header. BPF_HDR_START_NET Base <[ offset ]>(IP: 1) <[ to ]>(IP: 2) load data from is skb's network header. In general , \"direct packet access\" is the preferred method <[ to ]>(IP: 2) access packet data , however , this helper is in particular useful in socket filters where skb->data does not always point <[ to ]>(IP: 2) the start of the mac header and where \"direct packet access\" is not available. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "skb_load_bytes_relative", "Input Params": ["{Type: const struct sk_buff ,Var: *skb}", "{Type:  u32 ,Var: offset}", "{Type:  void ,Var: *to}", "{Type:  u32 ,Var: len}", "{Type:  u32 ,Var: start_header}"], "compatible_hookpoints": ["socket_filter", "sched_cls", "sched_act", "cgroup_skb", "sk_reuseport"], "capabilities": ["read_skb"]}, "fib_lookup": {"Project": "cilium", "Return Type": "int", "Description": "Do FIB lookup in kernel tables using parameters in params. If lookup is successful and result shows packet is to be forwarded , the neighbor tables are searched for the nexthop. If successful (ie. , FIB lookup shows forwarding and nexthop is resolved) , the nexthop address is returned in ipv4_dst or ipv6_dst based on family , smac is set to mac address of egress device , dmac is set to nexthop mac address , rt_metric is set to metric from route (IPv4/IPv6 only) , and ifindex is set to the device index of the nexthop from the FIB lookup. <[ plen ]>(IP: 2) argument is the size of the passed in struct. <[ flags ]>(IP: 3) argument can be a combination of one or more of the following values: BPF_FIB_LOOKUP_DIRECT Do a direct table lookup vs full lookup using FIB rules. BPF_FIB_LOOKUP_OUTPUT Perform lookup from an egress perspective (default is ingress). <[ ctx ]>(IP: 0) is either struct xdp_md for XDP programs or struct sk_buff tc cls_act programs. Return \u00b7 < 0 if any input argument is invalid \u00b7 0 on success (packet is forwarded , nexthop neighbor exists) \u00b7 > 0 one of BPF_FIB_LKUP_RET_ codes explaining why the packet is not forwarded or needs assist from full stack ", "Function Name": "fib_lookup", "Input Params": ["{Type: void ,Var: *ctx}", "{Type:  struct fib_lookup ,Var: *params}", "{Type:  int ,Var: plen}", "{Type:  u32 ,Var: flags}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp"], "capabilities": ["read_sys_info"]}, "sock_hash_update": {"Project": "cilium", "Return Type": "int", "Description": "Add an entry to , or update a sockhash <[ map ]>(IP: 1) referencing sockets. The <[ skops ]>(IP: 0) is used as a new value for the entry associated to key. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 2) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 2) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. If the <[ map ]>(IP: 1) has eBPF programs (parser and verdict) , those will be inherited by the socket being added. If the socket is already attached to eBPF programs , this results in an error. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "sock_hash_update", "Input Params": ["{Type: struct sock_ops_kern ,Var: *skops}", "{Type:  struct map ,Var: *map}", "{Type:  void ,Var: *key}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["sock_ops"], "capabilities": []}, "msg_redirect_hash": {"Project": "cilium", "Return Type": "int", "Description": "This helper is used in programs implementing policies at the socket level. If the message <[ msg ]>(IP: 0) is allowed to pass (i. e. if the verdict eBPF program returns SK_PASS) , redirect it to the socket referenced by <[ map ]>(IP: 1) (of type BPF_MAP_TYPE_SOCKHASH) using hash key. Both ingress and egress interfaces can be used for redirection. The BPF_F_INGRESS value in <[ flags ]>(IP: 3) is used to make the distinction (ingress path is selected if the flag is present , egress path otherwise). This is the only flag supported for now. ", "Return": " SK_PASS on success, or SK_DROP on error.", "Function Name": "msg_redirect_hash", "Input Params": ["{Type: struct sk_msg_buff ,Var: *msg}", "{Type:  struct map ,Var: *map}", "{Type:  void ,Var: *key}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["sk_msg"], "capabilities": []}, "sk_redirect_hash": {"Project": "cilium", "Return Type": "int", "Description": "This helper is used in programs implementing policies at the <[ skb ]>(IP: 0) socket level. If the sk_buff <[ skb ]>(IP: 0) is allowed to pass (i. e. if the verdeict eBPF program returns SK_PASS) , redirect it to the socket referenced by <[ map ]>(IP: 1) (of type BPF_MAP_TYPE_SOCKHASH) using hash key. Both ingress and egress interfaces can be used for redirection. The BPF_F_INGRESS value in <[ flags ]>(IP: 3) is used to make the distinction (ingress path is selected if the flag is present , egress otherwise). This is the only flag supported for now. ", "Return": " SK_PASS on success, or SK_DROP on error.", "Function Name": "sk_redirect_hash", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  struct map ,Var: *map}", "{Type:  void ,Var: *key}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["sk_skb"], "capabilities": []}, "lwt_push_encap": {"Project": "cilium", "Return Type": "int", "Description": "Encapsulate the packet associated to <[ skb ]>(IP: 0) within a Layer 3 protocol header. This header is provided in the buffer at address <[ hdr ]>(IP: 2) , with <[ len ]>(IP: 3) its size in bytes. <[ type ]>(IP: 1) indicates the protocol of the header and can be one of: BPF_LWT_ENCAP_SEG6 IPv6 encapsulation with Segment Routing Header (struct ipv6_sr_hdr). <[ hdr ]>(IP: 2) only contains the SRH , the IPv6 header is computed by the kernel. BPF_LWT_ENCAP_SEG6_INLINE Only works if <[ skb ]>(IP: 0) contains an IPv6 packet. Insert a Segment Routing Header (struct ipv6_sr_hdr) inside the IPv6 header. BPF_LWT_ENCAP_IP IP encapsulation (GRE/GUE/IPIP/etc). The outer header must be IPv4 or IPv6 , followed by zero or more additional headers , up to LWT_BPF_MAX_HEADROOM total bytes in all prepended headers. Please note that if skb_is_gso(skb) is true , no more than two headers can be prepended , and the inner header , if present , should be either GRE or UDP/GUE. BPF_LWT_ENCAP_SEG6* types can be called by BPF programs of <[ type ]>(IP: 1) BPF_PROG_TYPE_LWT_IN; BPF_LWT_ENCAP_IP <[ type ]>(IP: 1) can be called by bpf programs of types BPF_PROG_TYPE_LWT_IN and BPF_PROG_TYPE_LWT_XMIT. A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "lwt_push_encap", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  u32 ,Var: type}", "{Type:  void ,Var: *hdr}", "{Type:  u32 ,Var: len}"], "compatible_hookpoints": ["lwt_in", "lwt_xmit"], "capabilities": ["update_pkt"]}, "lwt_seg6_store_bytes": {"Project": "cilium", "Return Type": "int", "Description": "Store <[ len ]>(IP: 3) bytes <[ from ]>(IP: 2) address <[ from ]>(IP: 2) into the packet associated to <[ skb ]>(IP: 0) , at offset. Only the flags , tag and TLVs inside the outermost IPv6 Segment Routing Header can be modified through this helper. A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "lwt_seg6_store_bytes", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  u32 ,Var: offset}", "{Type:  const void ,Var: *from}", "{Type:  u32 ,Var: len}"], "compatible_hookpoints": ["lwt_seg6local"], "capabilities": ["update_pkt"]}, "lwt_seg6_adjust_srh": {"Project": "cilium", "Return Type": "int", "Description": "Adjust the size allocated to TLVs in the outermost IPv6 Segment Routing Header contained in the packet associated to <[ skb ]>(IP: 0) , at position <[ offset ]>(IP: 1) by <[ delta ]>(IP: 2) bytes. Only offsets after the segments are accepted. <[ delta ]>(IP: 2) can be as well positive (growing) as negative (shrinking). A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "lwt_seg6_adjust_srh", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  u32 ,Var: offset}", "{Type:  s32 ,Var: delta}"], "compatible_hookpoints": ["lwt_seg6local"], "capabilities": ["update_pkt"]}, "lwt_seg6_action": {"Project": "cilium", "Return Type": "int", "Description": "Apply an IPv6 Segment Routing <[ action ]>(IP: 1) of type <[ action ]>(IP: 1) to the packet associated to skb. Each <[ action ]>(IP: 1) takes a parameter contained at address <[ param ]>(IP: 2) , and of length <[ param_len ]>(IP: 3) bytes. <[ action ]>(IP: 1) can be one of: SEG6_LOCAL_ACTION_END_X End. X action: Endpoint with Layer-3 cross-connect. Type of param: struct in6_addr. SEG6_LOCAL_ACTION_END_T End. T action: Endpoint with specific IPv6 table lookup. Type of param: int. SEG6_LOCAL_ACTION_END_B6 End. B6 action: Endpoint bound to an SRv6 policy. Type of param: struct ipv6_sr_hdr. SEG6_LOCAL_ACTION_END_B6_ENCAP End. B6. Encap action: Endpoint bound to an SRv6 encapsulation policy. Type of param: struct ipv6_sr_hdr. A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "lwt_seg6_action", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  u32 ,Var: action}", "{Type:  void ,Var: *param}", "{Type:  u32 ,Var: param_len}"], "compatible_hookpoints": ["lwt_seg6local"], "capabilities": ["update_pkt"]}, "rc_repeat": {"Project": "cilium", "Return Type": "int", "Description": "This helper is used in programs implementing IR decoding , to report a successfully decoded repeat key message. This delays the generation of a key up event for previously generated key down event. Some IR protocols like NEC have a special IR message for repeating last button , for when a button is held down. The <[ ctx ]>(IP: 0) should point to the lirc sample as passed into the program. This helper is only available is the kernel was compiled with the CONFIG_BPF_LIRC_MODE2 configuration option set to \"y\". ", "Return": " 0", "Function Name": "rc_repeat", "Input Params": ["{Type: void ,Var: *ctx}"], "capabilities": []}, "rc_keydown": {"Project": "cilium", "Return Type": "int", "Description": "This helper is used in programs implementing IR decoding , to report a successfully decoded key press with <[ scancode ]>(IP: 2) , <[ toggle ]>(IP: 3) value in the given protocol. The <[ scancode ]>(IP: 2) will be translated to a keycode using the rc keymap , and reported as an input key down event. After a period a key up event is generated. This period can be extended by calling either rc_keydown() again with the same values , or calling rc_repeat(). Some protocols include a <[ toggle ]>(IP: 3) bit , in case the button was released and pressed again between consecutive scancodes. The <[ ctx ]>(IP: 0) should point to the lirc sample as passed into the program. The <[ protocol ]>(IP: 1) is the decoded <[ protocol ]>(IP: 1) number (see enum rc_proto for some predefined values). This helper is only available is the kernel was compiled with the CONFIG_BPF_LIRC_MODE2 configuration option set to \"y\". ", "Return": " 0", "Function Name": "rc_keydown", "Input Params": ["{Type: void ,Var: *ctx}", "{Type:  u32 ,Var: protocol}", "{Type:  u64 ,Var: scancode}", "{Type:  u32 ,Var: toggle}"], "capabilities": []}, "skb_cgroup_id": {"Project": "cilium", "Return Type": "u64", "Description": "Return the cgroup v2 id of the socket associated with the skb. This is roughly similar to the get_cgroup_classid() helper for cgroup v1 by providing a tag resp. identifier that can be matched on or used for map lookups e. g. to implement policy. The cgroup v2 id of a given path in the hierarchy is exposed in user space through the f_handle API in order to get to the same 64-bit id. This helper can be used on TC egress path , but not on ingress , and is available only if the kernel was compiled with the CONFIG_SOCK_CGROUP_DATA configuration option. ", "Return": " The id is returned or 0 in case the id could not be retrieved.", "Function Name": "skb_cgroup_id", "Input Params": ["{Type: struct sk_buff ,Var: *skb}"], "compatible_hookpoints": ["sched_cls", "sched_act", "cgroup_skb"], "capabilities": ["read_skb", "read_sys_info"]}, "get_current_cgroup_id": {"Project": "cilium", "Return Type": "u64", "Return": " A 64-bit integer containing the current cgroup id based on the cgroup within                     which the current task is running.", "Function Name": "get_current_cgroup_id", "Input Params": ["{Type: voi ,Var: void}"], "Description": "A 64-bit integer containing the current cgroup id based on the cgroup within which the current task is running. ", "compatible_hookpoints": ["kprobe", "tracepoint", "perf_event", "cgroup_device", "raw_tracepoint", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["read_sys_info"]}, "get_local_storage": {"Project": "cilium", "Return Type": "void", "Description": "Get the pointer to the local storage area. The type and the size of the local storage is defined by the <[ map ]>(IP: 0) argument. The <[ flags ]>(IP: 1) meaning is specific for each <[ map ]>(IP: 0) type , and has to be 0 for cgroup local storage. Depending on the BPF program type , a local storage area can be shared between multiple instances of the BPF program , running simultaneously. A user should care about the synchronization by himself. For example , by using the BPF_STX_XADD instruction to alter the shared data. ", "Return": " A pointer to the local storage area.", "Function Name": "get_local_storage", "Input Params": ["{Type: void ,Var: *map}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["cgroup_skb", "cgroup_sock", "sock_ops", "cgroup_device", "cgroup_sock_addr", "cgroup_sysctl"], "capabilities": ["read_sys_info"]}, "sk_select_reuseport": {"Project": "cilium", "Return Type": "int*", "Description": "Select a SO_REUSEPORT socket from a BPF_MAP_TYPE_REUSEPORT_ARRAY map. It checks the selected socket is matching the incoming request in the socket buffer. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "sk_select_reuseport", "Input Params": ["{Type: struct sk_reuseport_md ,Var: *reuse}", "{Type:  struct map ,Var: *map}", "{Type:  void ,Var: *key}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["sk_reuseport"], "capabilities": []}, "skb_ancestor_cgroup_id": {"Project": "cilium", "Return Type": "u64", "Description": "Return id of cgroup v2 that is ancestor of cgroup associated with the <[ skb ]>(IP: 0) at the ancestor_level. The root cgroup is at <[ ancestor_level ]>(IP: 1) zero and each step down the hierarchy increments the level. If <[ ancestor_level ]>(IP: 1) == level of cgroup associated with <[ skb ]>(IP: 0) , then return value will be same as that of skb_cgroup_id(). The helper is useful to implement policies based on cgroups that are upper in hierarchy than immediate cgroup associated with skb. The format of returned id and helper limitations are same as in skb_cgroup_id(). ", "Return": " The id is returned or 0 in case the id could not be retrieved.", "Function Name": "skb_ancestor_cgroup_id", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  int ,Var: ancestor_level}"], "compatible_hookpoints": ["sched_cls", "sched_act"], "capabilities": ["read_skb", "read_sys_info"]}, "sk_lookup_tcp": {"Project": "cilium", "Return Type": "struct sock*", "Description": "Look for TCP socket matching <[ tuple ]>(IP: 1) , optionally in a child network namespace netns. The return value must be checked , and if non-NULL , released via sk_release(). The <[ ctx ]>(IP: 0) should point to the context of the program , such as the skb or socket (depending on the hook in use). This is used to determine the base network namespace for the lookup. <[ tuple_size ]>(IP: 2) must be one of: sizeof(tuple->ipv4) Look for an IPv4 socket. sizeof(tuple->ipv6) Look for an IPv6 socket. If the <[ netns ]>(IP: 3) is a negative signed 32-bit integer , then the socket lookup table in the <[ netns ]>(IP: 3) associated with the <[ ctx ]>(IP: 0) will will be used. For the TC hooks , this is the <[ netns ]>(IP: 3) of the device in the skb. For socket hooks , this is the <[ netns ]>(IP: 3) of the socket. If <[ netns ]>(IP: 3) is any other signed 32-bit value greater than or equal to zero then it specifies the ID of the <[ netns ]>(IP: 3) relative to the <[ netns ]>(IP: 3) associated with the ctx. <[ netns ]>(IP: 3) values beyond the range of 32-bit integers are reserved for future use. All values for <[ flags ]>(IP: 4) are reserved for future usage , and must be left at zero. This helper is available only if the kernel was compiled with CONFIG_NET configuration option. ", "Return": " Pointer to struct  sock, or NULL in case of failure.   For  sockets  with                     reuseport  option,  the  struct  sock result is from reuse->socks[] using                     the hash of the tuple.", "Function Name": "sk_lookup_tcp", "Input Params": ["{Type: void ,Var: *ctx}", "{Type:  struct sock_tuple ,Var: *tuple}", "{Type:  u32 ,Var: tuple_size}", "{Type:  u64 ,Var: netns}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp", "sk_skb", "cgroup_sock_addr"], "capabilities": ["read_sys_info"]}, "sk_lookup_udp": {"Project": "cilium", "Return Type": "struct sock*", "Description": "Look for UDP socket matching <[ tuple ]>(IP: 1) , optionally in a child network namespace netns. The return value must be checked , and if non-NULL , released via sk_release(). The <[ ctx ]>(IP: 0) should point to the context of the program , such as the skb or socket (depending on the hook in use). This is used to determine the base network namespace for the lookup. <[ tuple_size ]>(IP: 2) must be one of: sizeof(tuple->ipv4) Look for an IPv4 socket. sizeof(tuple->ipv6) Look for an IPv6 socket. If the <[ netns ]>(IP: 3) is a negative signed 32-bit integer , then the socket lookup table in the <[ netns ]>(IP: 3) associated with the <[ ctx ]>(IP: 0) will will be used. For the TC hooks , this is the <[ netns ]>(IP: 3) of the device in the skb. For socket hooks , this is the <[ netns ]>(IP: 3) of the socket. If <[ netns ]>(IP: 3) is any other signed 32-bit value greater than or equal to zero then it specifies the ID of the <[ netns ]>(IP: 3) relative to the <[ netns ]>(IP: 3) associated with the ctx. <[ netns ]>(IP: 3) values beyond the range of 32-bit integers are reserved for future use. All values for <[ flags ]>(IP: 4) are reserved for future usage , and must be left at zero. This helper is available only if the kernel was compiled with CONFIG_NET configuration option. ", "Return": " Pointer  to  struct  sock, or NULL in case of failure.  For sockets with                     reuseport option, the struct  sock result is  from  reuse->socks[]  using                     the hash of the tuple.", "Function Name": "sk_lookup_udp", "Input Params": ["{Type: void ,Var: *ctx}", "{Type:  struct sock_tuple ,Var: *tuple}", "{Type:  u32 ,Var: tuple_size}", "{Type:  u64 ,Var: netns}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp", "sk_skb", "cgroup_sock_addr"], "capabilities": ["read_sys_info"]}, "sk_release": {"Project": "cilium", "Return Type": "int", "Description": "Release the reference held by sock. <[ sock ]>(IP: 0) must be a non-NULL pointer that was returned from sk_lookup_xxx(). ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "sk_release", "Input Params": ["{Type: struct sock ,Var: *sock}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp", "sk_skb", "cgroup_sock_addr"], "capabilities": []}, "map_push_elem": {"Project": "cilium", "Return Type": "int", "Description": "Push an element <[ value ]>(IP: 1) in map. <[ flags ]>(IP: 2) is one of: BPF_EXIST If the queue/stack is full , the oldest element is removed to make room for this. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "map_push_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *value}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_update"]}, "map_pop_elem": {"Project": "cilium", "Return Type": "int", "Description": "Pop an element from map. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "map_pop_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  void ,Var: *value}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read", "map_update"]}, "map_peek_elem": {"Project": "cilium", "Return Type": "int", "Description": "Get an element from <[ map ]>(IP: 0) without removing it. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "map_peek_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  void ,Var: *value}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}, "msg_push_data": {"Project": "cilium", "Return Type": "int", "Description": "For socket policies , insert <[ len ]>(IP: 2) bytes into msg at offset start. If a program of type BPF_PROG_TYPE_SK_MSG is run on a msg it may want to insert metadata or options into the msg. This can later be read and used by any of the lower layer BPF hooks. This helper may fail if under memory pressure (a malloc fails) in these cases BPF programs will get an appropriate error and BPF programs will need to handle them. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "msg_push_data", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  u32 ,Var: start}", "{Type:  u32 ,Var: len}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["sk_msg"], "capabilities": ["update_pkt"]}, "msg_pop_data": {"Project": "cilium", "Return Type": "int", "Description": "Will remove <[ pop ]>(IP: 2) bytes from a <[ msg ]>(IP: 0) starting at byte start. This may result in ENOMEM errors under certain situations if an allocation and copy are required due to a full ring buffer. However , the helper will try to avoid doing the allocation if possible. Other errors can occur if input parameters are invalid either due to <[ start ]>(IP: 1) byte not being valid part of <[ msg ]>(IP: 0) payload and/or <[ pop ]>(IP: 2) value being to large. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "msg_pop_data", "Input Params": ["{Type: struct sk_msg_buff ,Var: *msg}", "{Type:  u32 ,Var: start}", "{Type:  u32 ,Var: pop}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["sk_msg"], "capabilities": ["update_pkt"]}, "rc_pointer_rel": {"Project": "cilium", "Return Type": "int", "Description": "This helper is used in programs implementing IR decoding , to report a successfully decoded pointer movement. The <[ ctx ]>(IP: 0) should point to the lirc sample as passed into the program. This helper is only available is the kernel was compiled with the CONFIG_BPF_LIRC_MODE2 configuration option set to \"y\". ", "Return": " 0", "Function Name": "rc_pointer_rel", "Input Params": ["{Type: void ,Var: *ctx}", "{Type:  s32 ,Var: rel_x}", "{Type:  s32 ,Var: rel_y}"], "capabilities": []}, "spin_lock": {"Project": "cilium", "Return Type": "int", "Description": "Acquire a spinlock represented by the pointer <[ lock ]>(IP: 0) , which is stored as part of a value of a map. Taking the <[ lock ]>(IP: 0) allows to safely update the rest of the fields in that value. The spinlock can (and must) later be released with a call to spin_unlock(lock). Spinlocks in BPF programs come with a number of restrictions and constraints: \u00b7 spin_lock objects are only allowed inside maps of types BPF_MAP_TYPE_HASH and BPF_MAP_TYPE_ARRAY (this list could be extended in the future). \u00b7 BTF description of the map is mandatory. \u00b7 The BPF program can take ONE <[ lock ]>(IP: 0) at a time , since taking two or more could cause dead locks. \u00b7 Only one struct spin_lock is allowed per map element. \u00b7 When the <[ lock ]>(IP: 0) is taken , calls (either BPF to BPF or helpers) are not allowed. \u00b7 The BPF_LD_ABS and BPF_LD_IND instructions are not allowed inside a spinlock-ed region. \u00b7 The BPF program MUST call spin_unlock() to release the <[ lock ]>(IP: 0) , on all execution paths , before it returns. \u00b7 The BPF program can access struct spin_lock only via the spin_lock() and spin_unlock() helpers. Loading or storing data into the struct spin_lock lock; field of a map is not allowed. \u00b7 To use the spin_lock() helper , the BTF description of the map value must be a struct and have struct spin_lock anyname; field at the top level. Nested <[ lock ]>(IP: 0) inside another struct is not allowed. \u00b7 The struct spin_lock <[ lock ]>(IP: 0) field in a map value must be aligned on a multiple of 4 bytes in that value. \u00b7 Syscall with command BPF_MAP_LOOKUP_ELEM does not copy the spin_lock field to user space. \u00b7 Syscall with command BPF_MAP_UPDATE_ELEM , or update from a BPF program , do not update the spin_lock field. \u00b7 spin_lock cannot be on the stack or inside a networking packet (it can only be inside of a map values). \u00b7 spin_lock is available to root only. \u00b7 Tracing programs and socket filter programs cannot use spin_lock() due to insufficient preemption checks (but this may change in the future). spin_lock is not allowed in inner maps of map-in-map. ", "Return": " 0", "Function Name": "spin_lock", "Input Params": ["{Type: struct spin_lock ,Var: *lock}"], "compatible_hookpoints": ["socket_filter", "sched_cls", "sched_act", "xdp", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "sk_msg", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector"], "capabilities": []}, "spin_unlock": {"Project": "cilium", "Return Type": "int", "Description": "Release the <[ lock ]>(IP: 0) previously locked by a call to spin_lock(lock). ", "Return": " 0", "Function Name": "spin_unlock", "Input Params": ["{Type: struct spin_lock ,Var: *lock}"], "compatible_hookpoints": ["socket_filter", "sched_cls", "sched_act", "xdp", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "sk_msg", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector"], "capabilities": []}, "sk_fullsock": {"Project": "cilium", "Return Type": "struct sock*", "Description": "This helper gets a struct sock pointer such that all the fields in this sock can be accessed. ", "Return": " A struct  sock pointer on success, or NULL in case of failure.", "Function Name": "sk_fullsock", "Input Params": ["{Type: struct sock ,Var: *sk}"], "compatible_hookpoints": ["sched_cls", "sched_act", "cgroup_skb"], "capabilities": []}, "tcp_sock": {"Project": "cilium", "Return Type": "struct", "Description": "This helper gets a struct tcp_sock pointer from a struct sock pointer. ", "Return": "A struct  tcp_sock pointer on success, or NULL in case of failure.", "Function Name": "tcp_sock *tcp_sock", "Input Params": ["{Type: struct sock ,Var: *sk}"], "compatible_hookpoints": ["sched_cls", "sched_act", "cgroup_skb", "sock_ops"], "capabilities": []}, "skb_ecn_set_ce": {"Project": "cilium", "Return Type": "int", "Description": "Set ECN (Explicit Congestion Notification) field of IP header to CE(Congestion Encountered) if current value is ECT (ECN Capable Transport). Otherwise , do nothing. Works with IPv6 and IPv4. ", "Return": " 1 if the CE flag is set (either by the current helper call or because it was already present), 0 if it is not set.", "Function Name": "skb_ecn_set_ce", "Input Params": ["{Type: struct sk_buf ,Var: *skb}"], "compatible_hookpoints": ["sched_cls", "sched_act", "cgroup_skb"], "capabilities": ["update_pkt"]}, "get_listener_sock": {"Project": "cilium", "Return Type": "struct sock*", "Description": "Return a struct sock pointer in TCP_LISTEN state. sk_release() is unnecessary and not allowed. ", "Return": " A struct  sock pointer on success, or NULL in case of failure.", "Function Name": "get_listener_sock", "Input Params": ["{Type: struct sock ,Var: *sk}"], "compatible_hookpoints": ["sched_cls", "sched_act", "cgroup_skb"], "capabilities": ["read_sys_info"]}, "skc_lookup_tcp": {"Project": "cilium", "Return Type": "struct sock*", "Description": "Look for TCP socket matching <[ tuple ]>(IP: 1) , optionally in a child network namespace netns. The return value must be checked , and if non-NULL , released via sk_release(). This function is identical to sk_lookup_tcp() , except that it also returns timewait or request sockets. Use sk_fullsock() or tcp_sock() to access the full structure. This helper is available only if the kernel was compiled with CONFIG_NET configuration option. ", "Return": " Pointer  to  struct  sock, or NULL in case of failure.  For sockets with                     reuseport option, the struct  sock result is  from  reuse->socks[]  using                     the hash of the tuple.", "Function Name": "skc_lookup_tcp", "Input Params": ["{Type: void ,Var: *ctx}", "{Type:  struct sock_tuple ,Var: *tuple}", "{Type:  u32 ,Var: tuple_size}", "{Type:  u64 ,Var: netns}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp", "sk_skb", "cgroup_sock_addr"], "capabilities": ["read_sys_info"]}, "tcp_check_syncookie": {"Project": "cilium", "Return Type": "int", "Description": "Check whether <[ iph ]>(IP: 1) and <[ th ]>(IP: 3) contain a valid SYN cookie ACK for the listening socket in sk. <[ iph ]>(IP: 1) points to the start of the IPv4 or IPv6 header , while <[ iph_len ]>(IP: 2) contains sizeof(struct iphdr) or sizeof(struct ip6hdr). <[ th ]>(IP: 3) points to the start of the TCP header , while <[ th_len ]>(IP: 4) contains sizeof(struct tcphdr). ", "Return": " 0 if iph and th are a valid SYN cookie ACK, or a negative error otherwise.", "Function Name": "tcp_check_syncookie", "Input Params": ["{Type: struct sock ,Var: *sk}", "{Type:  void ,Var: *iph}", "{Type:  u32 ,Var: iph_len}", "{Type:  struct tcphdr ,Var: *th}", "{Type:  u32 ,Var: th_len}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp"], "capabilities": ["read_skb"]}, "sysctl_get_name": {"Project": "cilium", "Return Type": "int", "Description": "Get name of sysctl in /proc/sys/ and copy it into provided by program buffer <[ buf ]>(IP: 1) of size buf_len. The buffer is always NUL terminated , unless it's zero-sized. If <[ flags ]>(IP: 3) is zero , full name (e. g. \"net / ipv4 / tcp_mem\") is copied. Use BPF_F_SYSCTL_BASE_NAME flag to copy base name only (e. g. \"tcp_mem\"). ", "Return": " Number of character copied (not including the trailing NUL).                     -E2BIG  if  the buffer wasn't big enough (buf will contain truncated name in                     this case).", "Function Name": "sysctl_get_name", "Input Params": ["{Type: struct sysctl ,Var: *ctx}", "{Type:  char ,Var: *buf}", "{Type:  size_t ,Var: buf_len}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["cgroup_sysctl"], "capabilities": ["read_sys_info"]}, "sysctl_get_current_value": {"Project": "cilium", "Return Type": "int", "Description": "Get current value of sysctl as it is presented in /proc/sys (incl. newline , etc) , and copy it as a string into provided by program buffer <[ buf ]>(IP: 1) of size buf_len. The whole value is copied , no matter what file position user space issued e. g. sys_read at. The buffer is always NUL terminated , unless it's zero-sized. ", "Return": " Number of character copied (not including the trailing NUL).                     -E2BIG  if  the buffer wasn't big enough (buf will contain truncated name in                     this case).                     -EINVAL  if  current  value  was  unavailable,  e.g.   because   sysctl   is                     uninitialized and read returns -EIO for it.", "Function Name": "sysctl_get_current_value", "Input Params": ["{Type: struct sysctl ,Var: *ctx}", "{Type:  char ,Var: *buf}", "{Type:  size_t ,Var: buf_len}"], "compatible_hookpoints": ["cgroup_sysctl"], "capabilities": ["read_sys_info"]}, "sysctl_get_new_value": {"Project": "cilium", "Return Type": "int", "Description": "Get new value being written by user space to sysctl (before the actual write happens) and copy it as a string into provided by program buffer <[ buf ]>(IP: 1) of size buf_len. User space may write new value at file position > 0. The buffer is always NUL terminated , unless it's zero-sized. ", "Return": " Number of character copied (not including the trailing NUL).                     -E2BIG  if  the buffer wasn't big enough (buf will contain truncated name in                     this case).                     -EINVAL if sysctl is being read.", "Function Name": "sysctl_get_new_value", "Input Params": ["{Type: struct sysctl ,Var: *ctx}", "{Type:  char ,Var: *buf}", "{Type:  size_t ,Var: buf_len}"], "compatible_hookpoints": ["cgroup_sysctl"], "capabilities": ["read_sys_info"]}, "sysctl_set_new_value": {"Project": "cilium", "Return Type": "int", "Description": "Override new value being written by user space to sysctl with value provided by program in buffer <[ buf ]>(IP: 1) of size buf_len. <[ buf ]>(IP: 1) should contain a string in same form as provided by user space on sysctl write. User space may write new value at file position > 0. To override the whole sysctl value file position should be set to zero. ", "Return": " 0 on success.                     -E2BIG if the buf_len is too big.                     -EINVAL if sysctl is being read.", "Function Name": "sysctl_set_new_value", "Input Params": ["{Type: struct sysctl ,Var: *ctx}", "{Type:  const char ,Var: *buf}", "{Type:  size_t ,Var: buf_len}"], "compatible_hookpoints": ["cgroup_sysctl"], "capabilities": []}, "strtol": {"Project": "cilium", "Return Type": "int", "Description": "Convert the initial part of the string from buffer <[ buf ]>(IP: 0) of size <[ buf_len ]>(IP: 1) to a long integer according to the given base and save the result in res. The string may begin with an arbitrary amount of white space (as determined by isspace(3)) followed by a single optional '-' sign. Five least significant bits of <[ flags ]>(IP: 2) encode base , other bits are currently unused. Base must be either 8 , 10 , 16 or 0 to detect it automatically similar to user space strtol(3). ", "Return": " Number  of characters consumed on success. Must be positive but no more than                     buf_len.                     -EINVAL if no valid digits were found or unsupported base was provided.                     -ERANGE if resulting value was out of range.", "Function Name": "strtol", "Input Params": ["{Type: const char ,Var: *buf}", "{Type:  size_t ,Var: buf_len}", "{Type:  u64 ,Var: flags}", "{Type:  long ,Var: *res}"], "compatible_hookpoints": ["cgroup_sysctl"], "capabilities": []}, "strtoul": {"Project": "cilium", "Return Type": "int", "Description": "Convert the initial part of the string from buffer <[ buf ]>(IP: 0) of size <[ buf_len ]>(IP: 1) to an unsigned long integer according to the given base and save the result in res. The string may begin with an arbitrary amount of white space (as determined by isspace(3)). Five least significant bits of <[ flags ]>(IP: 2) encode base , other bits are currently unused. Base must be either 8 , 10 , 16 or 0 to detect it automatically similar to user space strtoul(3). ", "Return": " Number  of characters consumed on success. Must be positive but no more than                     buf_len.                     -EINVAL if no valid digits were found or unsupported base was provided.                     -ERANGE if resulting value was out of range.", "Function Name": "strtoul", "Input Params": ["{Type: const char ,Var: *buf}", "{Type:  size_t ,Var: buf_len}", "{Type:  u64 ,Var: flags}", "{Type:  unsigned long ,Var: *res}"], "compatible_hookpoints": ["cgroup_sysctl"], "capabilities": []}, "sk_storage_get": {"Project": "cilium", "Return Type": "void*", "Description": "Get a bpf-local-storage from a sk. Logically , it could be thought of getting the <[ value ]>(IP: 2) from a <[ map ]>(IP: 0) with <[ sk ]>(IP: 1) as the key. From this perspective , the usage is not much different from map_lookup_elem(map , &sk) except this helper enforces the key must be a full socket and the <[ map ]>(IP: 0) must be a BPF_MAP_TYPE_SK_STORAGE also. Underneath , the <[ value ]>(IP: 2) is stored locally at <[ sk ]>(IP: 1) instead of the map. The <[ map ]>(IP: 0) is used as the bpf-local-storage \"type\". The bpf-local-storage \"type\" (i. e. the map) is searched against all bpf-local-storages residing at sk. An optional <[ flags ]>(IP: 3) (BPF_SK_STORAGE_GET_F_CREATE) can be used such that a new bpf-local-storage will be created if one does not exist. <[ value ]>(IP: 2) can be used together with BPF_SK_STORAGE_GET_F_CREATE to specify the initial <[ value ]>(IP: 2) of a bpf-local-storage. If <[ value ]>(IP: 2) is NULL , the new bpf-local-storage will be zero initialized. ", "Return": " A bpf-local-storage pointer is returned on success.                     NULL if not found or there was an error in adding a new bpf-local-storage.", "Function Name": "sk_storage_get", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  struct sock ,Var: *sk}", "{Type:  void ,Var: *value}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["sched_cls", "sched_act", "cgroup_skb", "sock_ops", "cgroup_sock_addr"], "capabilities": ["read_sys_info"]}, "sk_storage_delete": {"Project": "cilium", "Return Type": "int", "Description": "Delete a bpf-local-storage from a sk. ", "Return": " 0 on success.                     -ENOENT if the bpf-local-storage cannot be found.", "Function Name": "sk_storage_delete", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  struct sock ,Var: *sk}"], "compatible_hookpoints": ["sched_cls", "sched_act", "cgroup_skb", "sock_ops", "cgroup_sock_addr"], "capabilities": []}, "send_signal": {"Project": "cilium", "Return Type": "int", "Description": "Send signal <[ sig ]>(IP: 0) to the current task. ", "Return": " 0 on success or successfully queued.                     -EBUSY if work queue under nmi is full.                     -EINVAL if sig is invalid.                     -EPERM if no permission to send the sig.                     -EAGAIN if bpf program can try again.", "Function Name": "send_signal", "Input Params": ["{Type: u32 ,Var: sig}"], "compatible_hookpoints": ["kprobe", "tracepoint", "perf_event", "raw_tracepoint", "raw_tracepoint_writable"], "capabilities": []}, "tcp_gen_syncookie": {"Project": "cilium", "Return Type": "s64", "Description": "Try to issue a SYN cookie for the packet with corresponding IP/TCP headers , <[ iph ]>(IP: 1) and <[ th ]>(IP: 3) , on the listening socket in sk. <[ iph ]>(IP: 1) points to the start of the IPv4 or IPv6 header , while <[ iph_len ]>(IP: 2) contains sizeof(struct iphdr) or sizeof(struct ip6hdr). <[ th ]>(IP: 3) points to the start of the TCP header , while <[ th_len ]>(IP: 4) contains the length of the TCP header. ", "Return": " On  success,  lower  32 bits hold the generated SYN cookie in followed by 16                     bits which hold the MSS value for that cookie,  and  the  top  16  bits  are                     unused.                     On failure, the returned value is one of the following:                     -EINVAL SYN cookie cannot be issued due to error                     -ENOENT SYN cookie should not be issued (no SYN flood)                     -EOPNOTSUPP kernel configuration does not enable SYN cookies                     -EPROTONOSUPPORT IP packet version is not 4 or 6", "Function Name": "tcp_gen_syncookie", "Input Params": ["{Type: struct sock ,Var: *sk}", "{Type:  void ,Var: *iph}", "{Type:  u32 ,Var: iph_len}", "{Type:  struct tcphdr ,Var: *th}", "{Type:  u32 ,Var: th_len}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp"], "capabilities": []}, "CTX_ACT_OK": {"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}, "CTX_ACT_REDIRECT": {"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "CTX_ACT_REDIRECT", "Return": 7, "Description": "Cilium wrapper. This allows to redirect the skb to the same or another\u2019s device ingress or egress path together with the redirect() helper. Being able to inject the packet into another device\u2019s ingress or egress direction allows for full flexibility in packet forwarding with BPF. There are no requirements on the target networking device other than being a networking device itself, there is no need to run another instance of cls_bpf on the target device or other such restrictions.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_alter_or_redo_processing_or_interface"]}, "CTX_DROP": {"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "CTX_DROP", "Return": 1, "Description": "Cilium wrapper. will drop the packet right at the driver level without wasting any further resources. This is in particular useful for BPF programs implementing DDoS mitigation mechanisms or firewalling in general.", "capabilities": []}, "CTX_ACT_TX": {"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "CTX_ACT_TX", "Return": 3, "Description": "Cilium wrapper. an efficient option to transmit the network packet out of the same NIC it just arrived on again. This is typically useful when few nodes are implementing, for example, firewalling with subsequent load balancing in a cluster and thus act as a hairpinned load balancer pushing the incoming packets back into the switch after rewriting them in XDP BPF.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_alter_or_redo_processing_or_interface"]}, "kprobe__": {"Project": "bcc", "FunctionName": "kprobe__", "Return Type": "int", "Description": "kprobe__kernel_function_name kprobe__ is a special prefix that creates a kprobe (dynamic tracing of a kernel function call) for the kernel function name provided as the remainder. You can also use kprobes by declaring a normal C function, then using the Python BPF.attach_kprobe (covered later) to associate it with a kernel function. Arguments are specified on the function declaration: kprobe__kernel_function_name(struct pt_regs ctx [, argument1* ...]) For example: Cint kprobe__tcp_v4_connect(struct pt_regs *ctx, struct sock *sk) {    [...]} This instruments the tcp_v4_connect kernel function using a kprobe, with the following arguments: struct pt_regs *ctx: Registers and BPF context.  struct sock *sk: First argument to tcp_v4_connect.  ", "Return": "Integer", "Input Prameters": [], "capabilities": []}, "kretprobe__": {"Project": "bcc", "FunctionName": "kretprobe__", "Return Type": "int", "Description": "kretprobe__kernel_function_name kretprobe__ is a special prefix that creates a kretprobe (dynamic tracing of a kernel function return) for the kernel function name provided as the remainder. You can also use kretprobes by declaring a normal C function, then using the Python BPF.attach_kretprobe (covered later) to associate it with a kernel function. Return value is available as PT_REGS_RC(ctx), given a function declaration of: kretprobe__kernel_function_name(struct pt_regs *ctx) For example: int kretprobe__tcp_v4_connect(struct pt_regs *ctx){    int ret = PT_REGS_RC(ctx);    [...]} This instruments the return of the tcp_v4_connect kernel function using a kretprobe, and stores the return value in ret. Examples in situ: \"https://github.com/iovisor/bcc/blob/4afa96a71c5dbfc4c507c3355e20baa6c184a3a8/examples/tracing/tcpv4connect.py#L38 code  ( \"https://github.com/iovisor/bcc/blob/5bd0eb21fd148927b078deb8ac29fff2fb044b66/examples/tracing/tcpv4connect_example.txt#L8 output )", "Return": "int", "Input Prameters": [], "capabilities": []}, "TRACEPOINT_PROBE": {"Project": "bcc", "FunctionName": "TRACEPOINT_PROBE", "Return Type": null, "Description": "TRACEPOINT_PROBE(category, event) This is a macro that instruments the tracepoint defined by category:event. The tracepoint name is <category>:<event>.The probe function name is tracepoint__<category>__<event>. Arguments are available in an args struct, which are the tracepoint arguments. One way to list these is to cat the relevant format file under /sys/kernel/debug/tracing/events/category/event/format. The args struct can be used in place of ctx in each functions requiring a context as an argument. This includes notably  \"#3-perf_submit perf_submit . For example: CTRACEPOINT_PROBE(random, urandom_read) {    // args is from /sys/kernel/debug/tracing/events/random/urandom_read/format    bpf_trace_printk(\"%d\\\\n\", args->got_bits);    return 0;} This instruments the tracepoint random:urandom_read tracepoint, and prints the tracepoint argument got_bits.When using Python API, this probe is automatically attached to the right tracepoint target.For C++, this tracepoint probe can be attached by specifying the tracepoint target and function name explicitly:BPF::attach_tracepoint(\"random:urandom_read\", \"tracepoint__random__urandom_read\")Note the name of the probe function defined above is tracepoint__random__urandom_read. Examples in situ: \"https://github.com/iovisor/bcc/blob/a4159da8c4ea8a05a3c6e402451f530d6e5a8b41/examples/tracing/urandomread.py#L19 code  ( \"https://github.com/iovisor/bcc/commit/e422f5e50ecefb96579b6391a2ada7f6367b83c4#diff-41e5ecfae4a3b38de5f4e0887ed160e5R10 output ), \"https://github.com/iovisor/bcc/search?q=TRACEPOINT_PROBE+path%3Aexamples&type=Code search /examples , \"https://github.com/iovisor/bcc/search?q=TRACEPOINT_PROBE+path%3Atools&type=Code search /tools ", "Return": null, "Input Prameters": [], "capabilities": []}, "attach_uprobe": {"Project": "bcc", "FunctionName": "attach_uprobe", "Return Type": "int", "Description": "These are instrumented by declaring a normal function in C, then associating it as a uprobe probe in Python via BPF.attach_uprobe (covered later). Arguments can be examined using PT_REGS_PARM macros. For example: Cint count(struct pt_regs *ctx) {    char buf[64];    bpf_probe_read_user(&buf, sizeof(buf), (void *)PT_REGS_PARM1(ctx));    bpf_trace_printk(\"%s %d\", buf, PT_REGS_PARM2(ctx));    return(0);} This reads the first argument as a string, and then prints it with the second argument as an integer. Examples in situ: \"https://github.com/iovisor/bcc/blob/4afa96a71c5dbfc4c507c3355e20baa6c184a3a8/examples/tracing/strlen_count.py#L26 code ", "Return": "int", "Input Prameters": [], "capabilities": []}, "attach_uretprobe": {"Project": "bcc", "FunctionName": "attach_uretprobe", "Return Type": "int", "Description": "These are instrumented by declaring a normal function in C, then associating it as a uretprobe probe in Python via BPF.attach_uretprobe (covered later). Return value is available as PT_REGS_RC(ctx), given a function declaration of: function_name(struct pt_regs *ctx) For example: CBPF_HISTOGRAM(dist);int count(struct pt_regs *ctx) {    dist.increment(PT_REGS_RC(ctx));    return 0;} This increments the bucket in the dist histogram that is indexed by the return value. Examples in situ: \"https://github.com/iovisor/bcc/blob/4afa96a71c5dbfc4c507c3355e20baa6c184a3a8/examples/tracing/strlen_hist.py#L39 code  ( \"https://github.com/iovisor/bcc/blob/4afa96a71c5dbfc4c507c3355e20baa6c184a3a8/examples/tracing/strlen_hist.py#L15 output ), \"https://github.com/iovisor/bcc/blob/4afa96a71c5dbfc4c507c3355e20baa6c184a3a8/tools/bashreadline.py code  ( \"https://github.com/iovisor/bcc/commit/aa87997d21e5c1a6a20e2c96dd25eb92adc8e85d#diff-2fd162f9e594206f789246ce97d62cf0R7 output )", "Return": "int", "Input Prameters": [], "capabilities": []}, " bpf_usdt_": {"Project": "bcc", "FunctionName": " bpf_usdt_", "Return Type": "int", "Description": "These are User Statically-Defined Tracing (USDT) probes, which may be placed in some applications or libraries to provide a user-level equivalent of tracepoints. The primary BPF method provided for USDT support method is enable_probe. USDT probes are instrumented by declaring a normal function in C, then associating it as a USDT probe in Python via USDT.enable_probe. Arguments can be read via: bpf_usdt_readarg(index, ctx, &addr) For example: Cint do_trace(struct pt_regs *ctx) {    uint64_t addr;    char path[128];    bpf_usdt_readarg(6, ctx, &addr);    bpf_probe_read_user(&path, sizeof(path), (void *)addr);    bpf_trace_printk(\"path:%s\\\\n\", path);    return 0;}; This reads the sixth USDT argument, and then pulls it in as a string to path. When initializing USDTs via the third argument of BPF::init in the C API, if any USDT fails to init, entire BPF::init will fail. If you're OK with some USDTs failing to init, use BPF::init_usdt before calling BPF::init. Examples in situ: \"https://github.com/iovisor/bcc/commit/4f88a9401357d7b75e917abd994aa6ea97dda4d3#diff-04a7cad583be5646080970344c48c1f4R24 code , \"https://github.com/iovisor/bcc/search?q=bpf_usdt_readarg+path%3Aexamples&type=Code search /examples , \"https://github.com/iovisor/bcc/search?q=bpf_usdt_readarg+path%3Atools&type=Code search /tools ", "Return": "int", "Input Prameters": [], "capabilities": []}, "RAW_TRACEPOINT_PROBE": {"Project": "bcc", "FunctionName": "RAW_TRACEPOINT_PROBE", "Return Type": null, "Description": "RAW_TRACEPOINT_PROBE(event) This is a macro that instruments the raw tracepoint defined by event. The argument is a pointer to struct bpf_raw_tracepoint_args, which is defined in  \"https://github.com/iovisor/bcc/blob/master/src/cc/compat/linux/virtual_bpf.h bpf.h .  The struct field args contains all parameters of the raw tracepoint where you can found at linux tree  \"https://github.com/torvalds/linux/tree/master/include/trace/events include/trace/events directory. For example:```CRAW_TRACEPOINT_PROBE(sched_switch){    // TP_PROTO(bool preempt, struct task_struct prev, struct task_struct next)    struct task_struct prev = (struct task_struct )ctx->args[1];    struct task_struct next= (struct task_struct )ctx->args[2];    s32 prev_tgid, next_tgid;", "Return": null, "Input Prameters": [], "capabilities": []}, "syscall__": {"Project": "bcc", "FunctionName": "syscall__", "Return Type": "int", "Description": "syscall__SYSCALLNAME syscall__ is a special prefix that creates a kprobe for the system call name provided as the remainder. You can use it by declaring a normal C function, then using the Python BPF.get_syscall_fnname(SYSCALLNAME) and BPF.attach_kprobe to associate it. Arguments are specified on the function declaration: syscall__SYSCALLNAME(struct pt_regs *ctx, [, argument1 ...]). For example:Cint syscall__execve(struct pt_regs *ctx,    const char __user *filename,    const char __user *const __user *__argv,    const char __user *const __user *__envp){    [...]} This instruments the execve system call. The first argument is always struct pt_regs *, the remainder are the arguments to the function (they don't need to be specified, if you don't intend to use them). Corresponding Python code:Pythonb = BPF(text=bpf_text)execve_fnname = b.get_syscall_fnname(\"execve\")b.attach_kprobe(event=execve_fnname, fn_name=\"syscall__execve\") Examples in situ: \"https://github.com/iovisor/bcc/blob/552658edda09298afdccc8a4b5e17311a2d8a771/tools/execsnoop.py#L101 code  ( \"https://github.com/iovisor/bcc/blob/552658edda09298afdccc8a4b5e17311a2d8a771/tools/execsnoop_example.txt#L8 output )", "Return": "int", "Input Prameters": [], "capabilities": []}, "KFUNC_PROBE": {"Project": "bcc", "FunctionName": "KFUNC_PROBE", "Return Type": null, "Description": "KFUNC_PROBE(function, typeof(arg1) arg1, typeof(arg2) arge ...) This is a macro that instruments the kernel function via trampolinebefore the function is executed. It's defined by function name andthe function arguments defined as argX. For example:CKFUNC_PROBE(do_sys_open, int dfd, const char *filename, int flags, int mode){    ... This instruments the do_sys_open kernel function and make its argumentsaccessible as standard argument values. Examples in situ: \"https://github.com/iovisor/bcc/search?q=KFUNC_PROBE+path%3Atools&type=Code search /tools ", "Return": null, "Input Prameters": [], "capabilities": []}, "KRETFUNC_PROBE": {"Project": "bcc", "FunctionName": "KRETFUNC_PROBE", "Return Type": null, "Description": "KRETFUNC_PROBE(event, typeof(arg1) arg1, typeof(arg2) arge ..., int ret) This is a macro that instruments the kernel function via trampolineafter the function is executed. It's defined by function name andthe function arguments defined as argX. The last argument of the probe is the return value of the instrumented function. For example:CKRETFUNC_PROBE(do_sys_open, int dfd, const char *filename, int flags, int mode, int ret){    ... This instruments the do_sys_open kernel function and make its argumentsaccessible as standard argument values together with its return value. Examples in situ: \"https://github.com/iovisor/bcc/search?q=KRETFUNC_PROBE+path%3Atools&type=Code search /tools ", "Return": null, "Input Prameters": [], "capabilities": []}, "LSM_PROBE": {"Project": "bcc", "FunctionName": "LSM_PROBE", "Return Type": null, "Description": "LSM_PROBE(hook, typeof(arg1) arg1, typeof(arg2) arg2 ...) This is a macro that instruments an LSM hook as a BPF program. It can beused to audit security events and implement MAC security policies in BPF.It is defined by specifying the hook name followed by its arguments. Hook names can be found in \"https://github.com/torvalds/linux/blob/v5.15/include/linux/security.h#L260 include/linux/security.h by taking functions like security_hookname and taking just the hookname part.For example, security_bpf would simply become bpf. Unlike other BPF program types, the return value specified in an LSM probematters. A return value of 0 allows the hook to succeed, whereasany non-zero return value will cause the hook to fail and deny thesecurity operation. The following example instruments a hook that denies all future BPF operations:CLSM_PROBE(bpf, int cmd, union bpf_attr *attr, unsigned int size){    return -EPERM;} This instruments the security_bpf hook and causes it to return -EPERM.Changing return -EPERM to return 0 would cause the BPF programto allow the operation instead. LSM probes require at least a 5.7+ kernel with the following configuation options set:- CONFIG_BPF_LSM=y- CONFIG_LSM comma separated string must contain \"bpf\" (for example,  CONFIG_LSM=\"lockdown,yama,bpf\") Examples in situ: \"https://github.com/iovisor/bcc/search?q=LSM_PROBE+path%3Atests&type=Code search /tests ", "Return": null, "Input Prameters": [], "capabilities": []}, "BPF_ITER": {"Project": "bcc", "FunctionName": "BPF_ITER", "Return Type": null, "Description": "BPF_ITER(target) This is a macro to define a program signature for a bpf iterator program. The argument target specifies what to iterate for the program. Currently, kernel does not have interface to discover what targets are supported. A good place to find what is supported is in  \"https://github.com/torvalds/linux/blob/master/tools/testing/selftests/bpf/prog_tests/bpf_iter.c tools/testing/selftests/bpf/prog_test/bpf_iter.c  and some sample bpf iter programs are in  \"https://github.com/torvalds/linux/tree/master/tools/testing/selftests/bpf/progs tools/testing/selftests/bpf/progs  with file name prefix bpf_iter. The following example defines a program for target task, which traverses all tasks in the kernel.```CBPF_ITER(task){  struct seq_file seq = ctx->meta->seq;  struct task_struct task = ctx->task; if (task == (void *)0)    return 0; ... task->pid, task->tgid, task->comm, ...  return 0;}``` BPF iterators are introduced in 5.8 kernel for task, task_file, bpf_map, netlink_sock and ipv6_route . In 5.9, support is added to tcp/udp sockets and bpf map element (hashmap, arraymap and sk_local_storage_map) traversal.", "Return": null, "Input Prameters": [], "capabilities": []}, "bpf_probe_read_kernel": {"Project": "bcc", "FunctionName": "bpf_probe_read_kernel", "Return Type": "int", "Description": "int bpf_probe_read_kernel(void *dst, int size, const void *src) Return: 0 on success This copies size bytes from kernel address space to the BPF stack, so that BPF can later operate on it. For safety, all kernel memory reads must pass through bpf_probe_read_kernel. This happens automatically in some cases, such as dereferencing kernel variables, as bcc will rewrite the BPF program to include the necessary bpf_probe_read_kernel. Examples in situ: \"https://github.com/iovisor/bcc/search?q=bpf_probe_read_kernel+path%3Aexamples&type=Code search /examples , \"https://github.com/iovisor/bcc/search?q=bpf_probe_read_kernel+path%3Atools&type=Code search /tools ", "Return": "0 on success. Error on failure", "Input Prameters": ["{Type: void* ,Var: dst}", "{Type: int* ,Var: size}", "{Type: const void* ,Var: src}"], "capabilities": []}, "bpf_probe_read_kernel_str": {"Project": "bcc", "FunctionName": "bpf_probe_read_kernel_str", "Return Type": "int", "Description": "int bpf_probe_read_kernel_str(void *dst, int size, const void *src) Return:  - > 0 length of the string including the trailing NULL on success  - \\< 0 error This copies a NULL terminated string from kernel address space to the BPF stack, so that BPF can later operate on it. In case the string length is smaller than size, the target is not padded with further NULL bytes. In case the string length is larger than size, just size - 1 bytes are copied and the last byte is set to NULL. Examples in situ: \"https://github.com/iovisor/bcc/search?q=bpf_probe_read_kernel_str+path%3Aexamples&type=Code search /examples , \"https://github.com/iovisor/bcc/search?q=bpf_probe_read_kernel_str+path%3Atools&type=Code search /tools ", "Return": "0 on success", "Input Prameters": ["{Type: void* ,Var: dst}", "{Type: int* ,Var: size}", "{Type: const void* ,Var: src}"], "capabilities": []}, "bpf_log2l": {"Project": "bcc", "FunctionName": "bpf_log2l", "Return Type": "int", "Description": "unsigned int bpf_log2l(unsigned long v) Returns the log-2 of the provided value. This is often used to create indexes for histograms, to construct power-of-2 histograms. Examples in situ: \"https://github.com/iovisor/bcc/search?q=bpf_log2l+path%3Aexamples&type=Code search /examples , \"https://github.com/iovisor/bcc/search?q=bpf_log2l+path%3Atools&type=Code search /tools ", "Return": "Returns the log-2 of the provided value", "Input Prameters": ["{Type: unsigned long ,Var: v}"], "capabilities": []}, "bpf_probe_read_user": {"Project": "bcc", "FunctionName": "bpf_probe_read_user", "Return Type": "int", "Description": "int bpf_probe_read_user(void *dst, int size, const void *src) Return: 0 on success This attempts to safely read size bytes from user address space to the BPF stack, so that BPF can later operate on it. For safety, all user address space memory reads must pass through bpf_probe_read_user. Examples in situ: \"https://github.com/iovisor/bcc/search?q=bpf_probe_read_user+path%3Aexamples&type=Code search /examples , \"https://github.com/iovisor/bcc/search?q=bpf_probe_read_user+path%3Atools&type=Code search /tools ", "Return": "0 on success", "Input Prameters": ["{Type: void* ,Var: dst}", "{Type: int* ,Var: size}", "{Type: const void* ,Var: src}"], "capabilities": []}, "bpf_probe_read_user_str": {"Project": "bcc", "FunctionName": "bpf_probe_read_user_str", "Return Type": "int", "Description": "int bpf_probe_read_user_str(void *dst, int size, const void *src) Return:  - > 0 length of the string including the trailing NULL on success  - \\< 0 error This copies a NULL terminated string from user address space to the BPF stack, so that BPF can later operate on it. In case the string length is smaller than size, the target is not padded with further NULL bytes. In case the string length is larger than size, just size - 1 bytes are copied and the last byte is set to NULL. Examples in situ: \"https://github.com/iovisor/bcc/search?q=bpf_probe_read_user_str+path%3Aexamples&type=Code search /examples , \"https://github.com/iovisor/bcc/search?q=bpf_probe_read_user_str+path%3Atools&type=Code search /tools ", "Return": "Return: >0 length of the string including the trailing NULL on success <0 error", "Input Prameters": ["{Type: void* ,Var: dst}", "{Type: int* ,Var: size}", "{Type: const void* ,Var: src}"], "capabilities": []}, "bpf_get_ns_current_pid_tgid": {"Project": "bcc", "FunctionName": "bpf_get_ns_current_pid_tgid", "Return Type": "u32", "Description": "u32 bpf_get_ns_current_pid_tgid(u64 dev, u64 ino, struct bpf_pidns_info* nsdata, u32 size) Values for pid and tgid as seen from the current namespace will be returned in nsdata. Return 0 on success, or one of the following in case of failure: -EINVAL if dev and inum supplied don't match dev_t and inode number with nsfs of current task, or if dev conversion to dev_t lost high bits. -ENOENT if pidns does not exists for the current task. ", "Return": "Return 0 on success,", "Input Prameters": ["{Type: u64 ,Var: dev}", "{Type: u64 ,Var: ino}", "{Type: struct bpf_pidns_info* ,Var: nsdata}", "{Type: u32 ,Var: size}"], "capabilities": []}, "BPF_PERF_OUTPUT": {"Project": "bcc", "FunctionName": "BPF_PERF_OUTPUT", "Return Type": null, "Description": "BPF_PERF_OUTPUT(name) Creates a BPF table for pushing out custom event data to user space via a perf ring buffer. This is the preferred method for pushing per-event data to user space. For example: ```Cstruct data_t {    u32 pid;    u64 ts;    char comm[TASK_COMM_LEN];};BPF_PERF_OUTPUT(events); int hello(struct pt_regs *ctx) {    struct data_t data = {};", "Return": null, "Input Prameters": [], "capabilities": []}, "perf_submit": {"Project": "bcc", "FunctionName": "perf_submit", "Return Type": "int", "Description": "int perf_submit((void *)ctx, (void *)data, u32 data_size) Return: 0 on success A method of a BPF_PERF_OUTPUT table, for submitting custom event data to user space. See the BPF_PERF_OUTPUT entry. (This ultimately calls bpf_perf_event_output.) The ctx parameter is provided in  \"#1-kprobes kprobes  or  \"#2-kretprobes kretprobes . For SCHED_CLS or SOCKET_FILTER programs, the struct __sk_buff *skb must be used instead. Examples in situ: \"https://github.com/iovisor/bcc/search?q=perf_submit+path%3Aexamples&type=Code search /examples , \"https://github.com/iovisor/bcc/search?q=perf_submit+path%3Atools&type=Code search /tools ", "Return": "0 on success", "Input Prameters": ["{Type: void* ,Var: ctx}", "{Type: void* ,Var: data}", "{Type: u32 ,Var: data_size}"], "capabilities": []}, "perf_submit_skb": {"Project": "bcc", "FunctionName": "perf_submit_skb", "Return Type": "int", "Description": "int perf_submit_skb((void *)ctx, u32 packet_size, (void *)data, u32 data_size) Return: 0 on success A method of a BPF_PERF_OUTPUT table available in networking program types, for submitting custom event data to user space, along with the first packet_size bytes of the packet buffer. See the BPF_PERF_OUTPUT entry. (This ultimately calls bpf_perf_event_output.) Examples in situ: \"https://github.com/iovisor/bcc/search?q=perf_submit_skb+path%3Aexamples&type=Code search /examples , \"https://github.com/iovisor/bcc/search?q=perf_submit_skb+path%3Atools&type=Code search /tools ", "Return": null, "Input Prameters": ["{Type: void* ,Var: ctx}", "{Type: u32 ,Var: packet_size}", "{Type: void* ,Var: data}", "{Type: u32 ,Var: data_size}"], "capabilities": []}, "BPF_RINGBUF_OUTPUT": {"Project": "bcc", "FunctionName": "BPF_RINGBUF_OUTPUT", "Return Type": null, "Description": "BPF_RINGBUF_OUTPUT(name, page_cnt) Creates a BPF table for pushing out custom event data to user space via a ringbuf ring buffer.BPF_RINGBUF_OUTPUT has several advantages over BPF_PERF_OUTPUT, summarized as follows: Buffer is shared across all CPUs, meaning no per-CPU allocation  Supports two APIs for BPF programs  map.ringbuf_output works like map.perf_submit (covered in  \"#6-ringbuf_output ringbuf_output )  map.ringbuf_reserve/map.ringbuf_submit/map.ringbuf_discard  split the process of reserving buffer space and submitting events into two steps  (covered in  \"#7-ringbuf_reserve ringbuf_reserve ,  \"#8-ringbuf_submit ringbuf_submit ,  \"#9-ringbuf_discard ringbuf_discard )    BPF APIs do not require access to a CPU ctx argument  Superior performance and latency in userspace thanks to a shared ring buffer manager  Supports two ways of consuming data in userspace  ", "Return": null, "Input Prameters": ["{Type:  ,Var: name}", "{Type:  ,Var: page_cnt}"], "capabilities": []}, "ringbuf_output": {"Project": "bcc", "FunctionName": "ringbuf_output", "Return Type": "int", "Description": "int ringbuf_output((void *)data, u64 data_size, u64 flags) Return: 0 on success Flags: - BPF_RB_NO_WAKEUP: Do not sent notification of new data availability - BPF_RB_FORCE_WAKEUP: Send notification of new data availability unconditionally A method of the BPF_RINGBUF_OUTPUT table, for submitting custom event data to user space. This method works like perf_submit,although it does not require a ctx argument. Examples in situ: ", "Return": "0 on success", "Input Prameters": ["{Type: void* ,Var: data}", "{Type: u32 ,Var: data_size}", "{Type: u64 ,Var: flags}"], "capabilities": []}, "ringbuf_reserve": {"Project": "bcc", "FunctionName": "ringbuf_reserve", "Return Type": "void*", "Description": "void* ringbuf_reserve(u64 data_size) Return: Pointer to data struct on success, NULL on failure A method of the BPF_RINGBUF_OUTPUT table, for reserving space in the ring buffer and simultaenouslyallocating a data struct for output. Must be used with one of ringbuf_submit or ringbuf_discard. Examples in situ: ", "Return": "Pointer to data struct on success, NULL on failure", "Input Prameters": ["{Type: u64 ,Var: data_size}"], "capabilities": []}, "ringbuf_submit": {"Project": "bcc", "FunctionName": "ringbuf_submit", "Return Type": "void", "Description": "void ringbuf_submit((void *)data, u64 flags) Return: Nothing, always succeeds Flags: - BPF_RB_NO_WAKEUP: Do not sent notification of new data availability - BPF_RB_FORCE_WAKEUP: Send notification of new data availability unconditionally A method of the BPF_RINGBUF_OUTPUT table, for submitting custom event data to user space. Must be preceded by a call toringbuf_reserve to reserve space for the data. Examples in situ: ", "Return": " Nothing, always succeeds", "Input Prameters": ["{Type: void* ,Var: data}", "{Type: u64 ,Var: flags}"], "capabilities": []}, "ringbuf_discard": {"Project": "bcc", "FunctionName": "ringbuf_discard", "Return Type": "void", "Description": "void ringbuf_discard((void *)data, u64 flags) Return: Nothing, always succeeds Flags: - BPF_RB_NO_WAKEUP: Do not sent notification of new data availability - BPF_RB_FORCE_WAKEUP: Send notification of new data availability unconditionally A method of the BPF_RINGBUF_OUTPUT table, for discarding custom event data; userspaceignores the data associated with the discarded event. Must be preceded by a call toringbuf_reserve to reserve space for the data. Examples in situ: ", "Return": "Nothing, always succeeds", "Input Prameters": ["{Type: void* ,Var: data}", "{Type: u64 ,Var: flags}"], "capabilities": []}, "BPF_TABLE": {"Project": "bcc", "FunctionName": "BPF_TABLE", "Return Type": null, "Description": "BPF_TABLE(_table_type, _key_type, _leaf_type, _name, _max_entries) Creates a map named _name. Most of the time this will be used via higher-level macros, like BPF_HASH, BPF_ARRAY, BPF_HISTOGRAM, etc. BPF_F_TABLE is a variant that takes a flag in the last parameter. BPF_TABLE(...) is actually a wrapper to BPF_F_TABLE(..., 0 /* flag */). Methods (covered later): map.lookup, map.lookup_or_try_init, map.delete, map.update, map.insert, map.increment. Examples in situ: \"https://github.com/iovisor/bcc/search?q=BPF_TABLE+path%3Aexamples&type=Code search /examples , \"https://github.com/iovisor/bcc/search?q=BPF_TABLE+path%3Atools&type=Code search /tools ", "Return": null, "Input Prameters": ["{Type:  ,Var: _table_type}", "{Type:  ,Var: _key_type}", "{Type:  ,Var: _leaf_type}", "{Type:  ,Var: _name}", "{Type:  ,Var: _max_entries}"], "capabilities": []}, "BPF_HASH": {"Project": "bcc", "FunctionName": "BPF_HASH", "Return Type": null, "Description": "BPF_HASH(name [, key_type [, leaf_type [, size]]]) Creates a hash map (associative array) named name, with optional parameters. Defaults: BPF_HASH(name, key_type=u64, leaf_type=u64, size=10240) For example: CBPF_HASH(start, struct request *); This creates a hash named start where the key is a struct request *, and the value defaults to u64. This hash is used by the disksnoop.py example for saving timestamps for each I/O request, where the key is the pointer to struct request, and the value is the timestamp. This is a wrapper macro for BPF_TABLE(\"hash\", ...). Methods (covered later): map.lookup, map.lookup_or_try_init, map.delete, map.update, map.insert, map.increment. Examples in situ: \"https://github.com/iovisor/bcc/search?q=BPF_HASH+path%3Aexamples&type=Code search /examples , \"https://github.com/iovisor/bcc/search?q=BPF_HASH+path%3Atools&type=Code search /tools ", "Return": null, "Input Prameters": ["{Type:  ,Var: key_type}", "{Type:  ,Var: leaf_type}", "{Type:  ,Var: name}", "{Type:  ,Var: size}"], "capabilities": []}, "BPF_ARRAY": {"Project": "bcc", "FunctionName": "BPF_ARRAY", "Return Type": null, "Description": "BPF_ARRAY(name [, leaf_type [, size]]) Creates an int-indexed array which is optimized for fastest lookup and update, named name, with optional parameters. Defaults: BPF_ARRAY(name, leaf_type=u64, size=10240) For example: CBPF_ARRAY(counts, u64, 32); This creates an array named counts where with 32 buckets and 64-bit integer values. This array is used by the funccount.py example for saving call count of each function. This is a wrapper macro for BPF_TABLE(\"array\", ...). Methods (covered later): map.lookup, map.update, map.increment. Note that all array elements are pre-allocated with zero values and can not be deleted. Examples in situ: \"https://github.com/iovisor/bcc/search?q=BPF_ARRAY+path%3Aexamples&type=Code search /examples , \"https://github.com/iovisor/bcc/search?q=BPF_ARRAY+path%3Atools&type=Code search /tools ", "Return": null, "Input Prameters": ["{Type:  ,Var: leaf_type}", "{Type:  ,Var: name}", "{Type:  ,Var: size}"], "capabilities": []}, "BPF_HISTOGRAM": {"Project": "bcc", "FunctionName": "BPF_HISTOGRAM", "Return Type": null, "Description": "BPF_HISTOGRAM(name [, key_type [, size ]]) Creates a histogram map named name, with optional parameters. Defaults: BPF_HISTOGRAM(name, key_type=int, size=64) For example: CBPF_HISTOGRAM(dist); This creates a histogram named dist, which defaults to 64 buckets indexed by keys of type int. This is a wrapper macro for BPF_TABLE(\"histgram\", ...). Methods (covered later): map.increment. Examples in situ: \"https://github.com/iovisor/bcc/search?q=BPF_HISTOGRAM+path%3Aexamples&type=Code search /examples , \"https://github.com/iovisor/bcc/search?q=BPF_HISTOGRAM+path%3Atools&type=Code search /tools ", "Return": null, "Input Prameters": ["{Type:  ,Var: key_type}", "{Type:  ,Var: name}", "{Type:  ,Var: size}"], "capabilities": []}, "BPF_STACK_TRACE": {"Project": "bcc", "FunctionName": "BPF_STACK_TRACE", "Return Type": null, "Description": "BPF_STACK_TRACE(name, max_entries) Creates stack trace map named name, with a maximum entry count provided. These maps are used to store stack traces. For example: CBPF_STACK_TRACE(stack_traces, 1024); This creates stack trace map named stack_traces, with a maximum number of stack trace entries of 1024. This is a wrapper macro for BPF_TABLE(\"stacktrace\", ...). Methods (covered later): map.get_stackid. Examples in situ: \"https://github.com/iovisor/bcc/search?q=BPF_STACK_TRACE+path%3Aexamples&type=Code search /examples , \"https://github.com/iovisor/bcc/search?q=BPF_STACK_TRACE+path%3Atools&type=Code search /tools ", "Return": null, "Input Prameters": ["{Type:  ,Var: name}", "{Type:  ,Var: max_entries}"], "capabilities": []}, "BPF_PERF_ARRAY": {"Project": "bcc", "FunctionName": "BPF_PERF_ARRAY", "Return Type": null, "Description": "BPF_PERF_ARRAY(name, max_entries) Creates perf array named name, with a maximum entry count provided, which must be equal to the number of system cpus. These maps are used to fetch hardware performance counters. For example: Ctext=\"\"\"BPF_PERF_ARRAY(cpu_cycles, NUM_CPUS);\"\"\"b = bcc.BPF(text=text, cflags=[\"-DNUM_CPUS=%d\" % multiprocessing.cpu_count])b[\"cpu_cycles\"].open_perf_event(b[\"cpu_cycles\"].HW_CPU_CYCLES) This creates a perf array named cpu_cycles, with number of entries equal to the number of cpus/cores. The array is configured so that later calling map.perf_read will return a hardware-calculated counter of the number of cycles elapsed from some point in the past. Only one type of hardware counter may be configured per table at a time. Methods (covered later): map.perf_read. Examples in situ: \"https://github.com/iovisor/bcc/search?q=BPF_PERF_ARRAY+path%3Atests&type=Code search /tests ", "Return": null, "Input Prameters": ["{Type:  ,Var: name}", "{Type:  ,Var: max_entries}"], "capabilities": []}, "BPF_PERCPU_HASH": {"Project": "bcc", "FunctionName": "BPF_PERCPU_HASH", "Return Type": null, "Description": "BPF_PERCPU_HASH(name [, key_type [, leaf_type [, size]]]) Creates NUM_CPU int-indexed hash maps (associative arrays) named name, with optional parameters. Each CPU will have a separate copy of this array. The copies are not kept synchronized in any way. Note that due to limits defined in the kernel (in linux/mm/percpu.c), the leaf_type cannot have a size of more than 32KB.In other words, BPF_PERCPU_HASH elements cannot be larger than 32KB in size. Defaults: BPF_PERCPU_HASH(name, key_type=u64, leaf_type=u64, size=10240) For example: CBPF_PERCPU_HASH(start, struct request *); This creates NUM_CPU hashes named start where the key is a struct request *, and the value defaults to u64. This is a wrapper macro for BPF_TABLE(\"percpu_hash\", ...). Methods (covered later): map.lookup, map.lookup_or_try_init, map.delete, map.update, map.insert, map.increment. Examples in situ: \"https://github.com/iovisor/bcc/search?q=BPF_PERCPU_HASH+path%3Aexamples&type=Code search /examples , \"https://github.com/iovisor/bcc/search?q=BPF_PERCPU_HASH+path%3Atools&type=Code search /tools ", "Return": null, "Input Prameters": ["{Type:  ,Var: key_type}", "{Type:  ,Var: leaf_type}", "{Type:  ,Var: name}", "{Type:  ,Var: size}"], "capabilities": []}, "BPF_PERCPU_ARRAY": {"Project": "bcc", "FunctionName": "BPF_PERCPU_ARRAY", "Return Type": null, "Description": "BPF_PERCPU_ARRAY(name [, leaf_type [, size]]) Creates NUM_CPU int-indexed arrays which are optimized for fastest lookup and update, named name, with optional parameters. Each CPU will have a separate copy of this array. The copies are not kept synchronized in any way. Note that due to limits defined in the kernel (in linux/mm/percpu.c), the leaf_type cannot have a size of more than 32KB.In other words, BPF_PERCPU_ARRAY elements cannot be larger than 32KB in size. Defaults: BPF_PERCPU_ARRAY(name, leaf_type=u64, size=10240) For example: CBPF_PERCPU_ARRAY(counts, u64, 32); This creates NUM_CPU arrays named counts where with 32 buckets and 64-bit integer values. This is a wrapper macro for BPF_TABLE(\"percpu_array\", ...). Methods (covered later): map.lookup, map.update, map.increment. Note that all array elements are pre-allocated with zero values and can not be deleted. Examples in situ: \"https://github.com/iovisor/bcc/search?q=BPF_PERCPU_ARRAY+path%3Aexamples&type=Code search /examples , \"https://github.com/iovisor/bcc/search?q=BPF_PERCPU_ARRAY+path%3Atools&type=Code search /tools ", "Return": null, "Input Prameters": ["{Type:  ,Var: leaf_type}", "{Type:  ,Var: name}", "{Type:  ,Var: size}"], "capabilities": []}, "BPF_LPM_TRIE": {"Project": "bcc", "FunctionName": "BPF_LPM_TRIE", "Return Type": null, "Description": "BPF_LPM_TRIE(name [, key_type [, leaf_type [, size]]]) Creates a longest prefix match trie map named name, with optional parameters. Defaults: BPF_LPM_TRIE(name, key_type=u64, leaf_type=u64, size=10240) For example: cBPF_LPM_TRIE(trie, struct key_v6); This creates an LPM trie map named trie where the key is a struct key_v6, and the value defaults to u64. This is a wrapper macro to BPF_F_TABLE(\"lpm_trie\", ..., BPF_F_NO_PREALLOC). Methods (covered later): map.lookup, map.lookup_or_try_init, map.delete, map.update, map.insert, map.increment. Examples in situ: \"https://github.com/iovisor/bcc/search?q=BPF_LPM_TRIE+path%3Aexamples&type=Code search /examples , \"https://github.com/iovisor/bcc/search?q=BPF_LPM_TRIE+path%3Atools&type=Code search /tools ", "Return": null, "Input Prameters": ["{Type:  ,Var: key_type}", "{Type:  ,Var: leaf_type}", "{Type:  ,Var: name}", "{Type:  ,Var: size}"], "capabilities": []}, "BPF_PROG_ARRAY": {"Project": "bcc", "FunctionName": "BPF_PROG_ARRAY", "Return Type": null, "Description": "BPF_PROG_ARRAY(name, size) This creates a program array named name with size entries. Each entry of the array is either a file descriptor to a bpf program or NULL. The array acts as a jump table so that bpf programs can \"tail-call\" other bpf programs. This is a wrapper macro for BPF_TABLE(\"prog\", ...). Methods (covered later): map.call. Examples in situ: \"https://github.com/iovisor/bcc/search?q=BPF_PROG_ARRAY+path%3Aexamples&type=Code search /examples , \"https://github.com/iovisor/bcc/search?q=BPF_PROG_ARRAY+path%3Atests&type=Code search /tests , \"https://github.com/iovisor/bcc/blob/master/examples/networking/tunnel_monitor/monitor.py#L24-L26 assign fd ", "Return": null, "Input Prameters": ["{Type:  ,Var: name}", "{Type:  ,Var: size}"], "capabilities": []}, "BPF_DEVMAP": {"Project": "bcc", "FunctionName": "BPF_DEVMAP", "Return Type": null, "Description": "BPF_DEVMAP(name, size) This creates a device map named name with size entries. Each entry of the map is an ifindex to a network interface. This map is only used in XDP. For example:CBPF_DEVMAP(devmap, 10); Methods (covered later): map.redirect_map. Examples in situ: \"https://github.com/iovisor/bcc/search?q=BPF_DEVMAP+path%3Aexamples&type=Code search /examples ,", "Return": null, "Input Prameters": ["{Type:  ,Var: name}", "{Type:  ,Var: size}"], "capabilities": []}, "BPF_CPUMAP": {"Project": "bcc", "FunctionName": "BPF_CPUMAP", "Return Type": null, "Description": "BPF_CPUMAP(name, size) This creates a cpu map named name with size entries. The index of the map represents the CPU id and each entry is the size of the ring buffer allocated for the CPU. This map is only used in XDP. For example:CBPF_CPUMAP(cpumap, 16); Methods (covered later): map.redirect_map. Examples in situ: \"https://github.com/iovisor/bcc/search?q=BPF_CPUMAP+path%3Aexamples&type=Code search /examples ,", "Return": null, "Input Prameters": ["{Type:  ,Var: name}", "{Type:  ,Var: size}"], "capabilities": []}, "BPF_XSKMAP": {"Project": "bcc", "FunctionName": "BPF_XSKMAP", "Return Type": null, "Description": "BPF_XSKMAP(name, size [, \"/sys/fs/bpf/xyz\"]) This creates a xsk map named name with size entries and pin it to the bpffs as a FILE. Each entry represents one NIC's queue id. This map is only used in XDP to redirect packet to an AF_XDP socket. If the AF_XDP socket is binded to a queue which is different than the current packet's queue id, the packet will be dropped. For kernel v5.3 and latter, lookup method is available and can be used to check whether and AF_XDP socket is available for the current packet's queue id. More details at  \"https://www.kernel.org/doc/html/latest/networking/af_xdp.html AF_XDP . For example:CBPF_XSKMAP(xsks_map, 8); Methods (covered later): map.redirect_map. map.lookup Examples in situ: \"https://github.com/iovisor/bcc/search?q=BPF_XSKMAP+path%3Aexamples&type=Code search /examples ,", "Return": null, "Input Prameters": ["{Type:  ,Var: name}", "{Type:  ,Var: size}"], "capabilities": []}, "BPF_ARRAY_OF_MAPS": {"Project": "bcc", "FunctionName": "BPF_ARRAY_OF_MAPS", "Return Type": null, "Description": "BPF_ARRAY_OF_MAPS(name, inner_map_name, size) This creates an array map with a map-in-map type (BPF_MAP_TYPE_HASH_OF_MAPS) map named name with size entries. The inner map meta data is provided by map inner_map_name and can be most of array or hash maps except BPF_MAP_TYPE_PROG_ARRAY, BPF_MAP_TYPE_CGROUP_STORAGE and BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE. For example:CBPF_TABLE(\"hash\", int, int, ex1, 1024);BPF_TABLE(\"hash\", int, int, ex2, 1024);BPF_ARRAY_OF_MAPS(maps_array, \"ex1\", 10);", "Return": null, "Input Prameters": ["{Type:  ,Var: name}", "{Type:  ,Var: inner_map_name}", "{Type:  ,Var: size}"], "capabilities": []}, "BPF_HASH_OF_MAPS": {"Project": "bcc", "FunctionName": "BPF_HASH_OF_MAPS", "Return Type": null, "Description": "BPF_HASH_OF_MAPS(name, key_type, inner_map_name, size) This creates a hash map with a map-in-map type (BPF_MAP_TYPE_HASH_OF_MAPS) map named name with size entries. The inner map meta data is provided by map inner_map_name and can be most of array or hash maps except BPF_MAP_TYPE_PROG_ARRAY, BPF_MAP_TYPE_CGROUP_STORAGE and BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE. For example:CBPF_ARRAY(ex1, int, 1024);BPF_ARRAY(ex2, int, 1024);BPF_HASH_OF_MAPS(maps_hash, struct custom_key, \"ex1\", 10);", "Return": null, "Input Prameters": ["{Type:  ,Var: name}", "{Type:  ,Var: key}", "{Type:  ,Var: inner_map_name}", "{Type:  ,Var: size}"], "capabilities": []}, "BPF_STACK": {"Project": "bcc", "FunctionName": "BPF_STACK", "Return Type": null, "Description": "BPF_STACK(name, leaf_type, max_entries[, flags]) Creates a stack named name with value type leaf_type and max entries max_entries.Stack and Queue maps are only available from Linux 4.20+. For example: CBPF_STACK(stack, struct event, 10240); This creates a stack named stack where the value type is struct event, that holds up to 10240 entries. Methods (covered later): map.push, map.pop, map.peek. Examples in situ: \"https://github.com/iovisor/bcc/search?q=BPF_STACK+path%3Atests&type=Code search /tests ,", "Return": null, "Input Prameters": ["{Type:  ,Var: name}", "{Type:  ,Var: leaf_type}", "{Type:  ,Var: max_entries}", "{Type:  ,Var: flags}"], "capabilities": []}, "BPF_QUEUE": {"Project": "bcc", "FunctionName": "BPF_QUEUE", "Return Type": null, "Description": "BPF_QUEUE(name, leaf_type, max_entries[, flags]) Creates a queue named name with value type leaf_type and max entries max_entries.Stack and Queue maps are only available from Linux 4.20+. For example: CBPF_QUEUE(queue, struct event, 10240); This creates a queue named queue where the value type is struct event, that holds up to 10240 entries. Methods (covered later): map.push, map.pop, map.peek. Examples in situ: \"https://github.com/iovisor/bcc/search?q=BPF_QUEUE+path%3Atests&type=Code search /tests ,", "Return": null, "Input Prameters": ["{Type:  ,Var: name}", "{Type:  ,Var: leaf_type}", "{Type:  ,Var: max_entries}", "{Type:  ,Var: flags}"], "capabilities": []}, "BPF_SOCKHASH": {"Project": "bcc", "FunctionName": "BPF_SOCKHASH", "Return Type": null, "Description": "BPF_SOCKHASH(name[, key_type [, max_entries) Creates a hash named name, with optional parameters. sockhash is only available from Linux 4.18+. Default: BPF_SOCKHASH(name, key_type=u32, max_entries=10240) For example: Cstruct sock_key {  u32 remote_ip4;  u32 local_ip4;  u32 remote_port;  u32 local_port;};BPF_HASH(skh, struct sock_key, 65535); This creates a hash named skh where the key is a struct sock_key. A sockhash is a BPF map type that holds references to sock structs. Then with a new sk/msg redirect bpf helper BPF programs can use the map to redirect skbs/msgs between sockets (map.sk_redirect_hash/map.msg_redirect_hash). The difference between BPF_SOCKHASH and BPF_SOCKMAP is that BPF_SOCKMAP is implemented based on an array, and enforces keys to be four bytes. While BPF_SOCKHASH is implemented based on hash table, and the type of key can be specified freely. Methods (covered later): map.sock_hash_update, map.msg_redirect_hash, map.sk_redirect_hash.  \"https://github.com/iovisor/bcc/search?q=BPF_SOCKHASH+path%3Atests&type=Code search /tests ", "Return": null, "Input Prameters": ["{Type:  ,Var: name}", "{Type:  ,Var: key_type}", "{Type:  ,Var: max_entries}"], "capabilities": []}, "map.lookup": {"Project": "bcc", "FunctionName": "map.lookup", "Return Type": "*val", "Description": "*val map.lookup(&key) Lookup the key in the map, and return a pointer to its value if it exists, else NULL. We pass the key in as an address to a pointer. Examples in situ: \"https://github.com/iovisor/bcc/search?q=lookup+path%3Aexamples&type=Code search /examples , \"https://github.com/iovisor/bcc/search?q=lookup+path%3Atools&type=Code search /tools ", "Return": "Lookup the key in the map, and return a pointer to its value if it exists, else NULL.", "Input Prameters": ["{Type:  ,Var: key}"], "capabilities": []}, "map.lookup_or_try_init": {"Project": "bcc", "FunctionName": "map.lookup_or_try_init", "Return Type": "*val", "Description": "*val map.lookup_or_try_init(&key, &zero) Lookup the key in the map, and return a pointer to its value if it exists, else initialize the key's value to the second argument. This is often used to initialize values to zero. If the key cannot be inserted (e.g. the map is full) then NULL is returned. Examples in situ: \"https://github.com/iovisor/bcc/search?q=lookup_or_try_init+path%3Aexamples&type=Code search /examples , \"https://github.com/iovisor/bcc/search?q=lookup_or_try_init+path%3Atools&type=Code search /tools  Note: The old map.lookup_or_init may cause return from the function, so lookup_or_try_init is recommended as itdoes not have this side effect.", "Return": " Lookup the key in the map, and return a pointer to its value if it exists, else initialize the key's value to the second argument. ", "Input Prameters": ["{Type:  ,Var: key}", "{Type:  ,Var: zero}"], "capabilities": []}, "map.delete": {"Project": "bcc", "FunctionName": "map.delete", "Return Type": null, "Description": "map.delete(&key) Delete the key from the hash. Examples in situ: \"https://github.com/iovisor/bcc/search?q=delete+path%3Aexamples&type=Code search /examples , \"https://github.com/iovisor/bcc/search?q=delete+path%3Atools&type=Code search /tools ", "Return": null, "Input Prameters": ["{Type:  ,Var: key}"], "capabilities": []}, "map.update": {"Project": "bcc", "FunctionName": "map.update", "Return Type": null, "Description": "map.update(&key, &val) Associate the value in the second argument to the key, overwriting any previous value. Examples in situ: \"https://github.com/iovisor/bcc/search?q=update+path%3Aexamples&type=Code search /examples , \"https://github.com/iovisor/bcc/search?q=update+path%3Atools&type=Code search /tools ", "Return": null, "Input Prameters": ["{Type:  ,Var: key}", "{Type:  ,Var: val}"], "capabilities": []}, "map.insert": {"Project": "bcc", "FunctionName": "map.insert", "Return Type": null, "Description": "map.insert(&key, &val) Associate the value in the second argument to the key, only if there was no previous value. Examples in situ: \"https://github.com/iovisor/bcc/search?q=insert+path%3Aexamples&type=Code search /examples , \"https://github.com/iovisor/bcc/search?q=insert+path%3Atools&type=Code search /tools ", "Return": null, "Input Prameters": ["{Type:  ,Var: key}", "{Type:  ,Var: val}"], "capabilities": []}, "map.increment": {"Project": "bcc", "FunctionName": "map.increment", "Return Type": null, "Description": "map.increment(key[, increment_amount]) Increments the key's value by increment_amount, which defaults to 1. Used for histograms. map.increment are not atomic. In the concurrency case. If you want more accurate results, use map.atomic_increment instead of map.increment. The overhead of map.increment and map.atomic_increment is similar. Note. When using map.atomic_increment to operate on a BPF map of type BPF_MAP_TYPE_HASH, map.atomic_increment does not guarantee the atomicity of the operation when the specified key does not exist. Examples in situ: \"https://github.com/iovisor/bcc/search?q=increment+path%3Aexamples&type=Code search /examples , \"https://github.com/iovisor/bcc/search?q=increment+path%3Atools&type=Code search /tools ", "Return": null, "Input Prameters": ["{Type:  ,Var: key}", "{Type:  ,Var: increment_amount}"], "capabilities": []}, "map.get_stackid": {"Project": "bcc", "FunctionName": "map.get_stackid", "Return Type": "int", "Description": "int map.get_stackid(void *ctx, u64 flags) This walks the stack found via the struct pt_regs in ctx, saves it in the stack trace map, and returns a unique ID for the stack trace. Examples in situ: \"https://github.com/iovisor/bcc/search?q=get_stackid+path%3Aexamples&type=Code search /examples , \"https://github.com/iovisor/bcc/search?q=get_stackid+path%3Atools&type=Code search /tools ", "Return": "returns a unique ID for the stack trace", "Input Prameters": ["{Type:  void*,Var: ctx}", "{Type:  u64,Var: flags}"], "capabilities": []}, "map.perf_read": {"Project": "bcc", "FunctionName": "map.perf_read", "Return Type": "u64", "Description": "u64 map.perf_read(u32 cpu) This returns the hardware performance counter as configured in  \"#5-bpf_perf_array 5. BPF_PERF_ARRAY  Examples in situ: \"https://github.com/iovisor/bcc/search?q=perf_read+path%3Atests&type=Code search /tests ", "Return": "returns the hardware performance counter as configured in bpf_perf_array", "Input Prameters": ["{Type:  u32,Var: cpu}"], "capabilities": []}, "map.call": {"Project": "bcc", "FunctionName": "map.call", "Return Type": "void", "Description": "void map.call(void *ctx, int index) This invokes bpf_tail_call to tail-call the bpf program which the index entry in  \"#10-bpf_prog_array BPF_PROG_ARRAY  points to. A tail-call is different from the normal call. It reuses the current stack frame after jumping to another bpf program and never goes back. If the index entry is empty, it won't jump anywhere and the program execution continues as normal. For example: ```CBPF_PROG_ARRAY(prog_array, 10); int tail_call(void *ctx) {    bpf_trace_printk(\"Tail-call\\n\");    return 0;} int do_tail_call(void *ctx) {    bpf_trace_printk(\"Original program\\n\");    prog_array.call(ctx, 2);    return 0;}``` Pythonb = BPF(src_file=\"example.c\")tail_fn = b.load_func(\"tail_call\", BPF.KPROBE)prog_array = b.get_table(\"prog_array\")prog_array[c_int(2)] = c_int(tail_fn.fd)b.attach_kprobe(event=\"some_kprobe_event\", fn_name=\"do_tail_call\") This assigns tail_call to prog_array[2]. In the end of do_tail_call, prog_array.call(ctx, 2) tail-calls tail_call and executes it.  NOTE:  To prevent infinite loop, the maximum number of tail-calls is 32 ( \"https://github.com/torvalds/linux/search?l=C&q=MAX_TAIL_CALL_CNT+path%3Ainclude%2Flinux&type=Code MAX_TAIL_CALL_CNT ). Examples in situ: \"https://github.com/iovisor/bcc/search?l=C&q=call+path%3Aexamples&type=Code search /examples , \"https://github.com/iovisor/bcc/search?l=C&q=call+path%3Atests&type=Code search /tests ", "Return": null, "Input Prameters": ["{Type:  void*, Var: ctx}", "{Type:  int, Var: index}"], "capabilities": []}, "map.redirect_map": {"Project": "bcc", "FunctionName": "map.redirect_map", "Return Type": "int", "Description": "int map.redirect_map(int index, int flags) This redirects the incoming packets based on the index entry. If the map is  \"#11-bpf_devmap BPF_DEVMAP , the packet will be sent to the transmit queue of the network interface that the entry points to. If the map is  \"#12-bpf_cpumap BPF_CPUMAP , the packet will be sent to the ring buffer of the index CPU and be processed by the CPU later. If the map is  \"#13-bpf_xskmap BPF_XSKMAP , the packet will be sent to the AF_XDP socket attached to the queue. If the packet is redirected successfully, the function will return XDP_REDIRECT. Otherwise, it will return XDP_ABORTED to discard the packet. For example:```CBPF_DEVMAP(devmap, 1); int redirect_example(struct xdp_md ctx) {    return devmap.redirect_map(0, 0);}int xdp_dummy(struct xdp_md ctx) {    return XDP_PASS;}``` ```Pythonip = pyroute2.IPRouteidx = ip.link_lookup(ifname=\"eth1\")[0] b = bcc.BPF(src_file=\"example.c\") devmap = b.get_table(\"devmap\")devmap[c_uint32(0)] = c_int(idx) in_fn = b.load_func(\"redirect_example\", BPF.XDP)out_fn = b.load_func(\"xdp_dummy\", BPF.XDP)b.attach_xdp(\"eth0\", in_fn, 0)b.attach_xdp(\"eth1\", out_fn, 0)``` Examples in situ: \"https://github.com/iovisor/bcc/search?l=C&q=redirect_map+path%3Aexamples&type=Code search /examples ,", "Return": "If the packet is redirected successfully, the function will return XDP_REDIRECT. Otherwise, it will return XDP_ABORTED to discard the packet", "Input Prameters": ["{Type:  int, Var: index}", "{Type:  int, Var: flags}"], "capabilities": []}, "map.push": {"Project": "bcc", "FunctionName": "map.push", "Return Type": "int", "Description": "int map.push(&val, int flags) Push an element onto a Stack or Queue table.Passing BPF_EXIST as a flag causes the Queue or Stack to discard the oldest element if it is full.Returns 0 on success, negative error on failure. Examples in situ: \"https://github.com/iovisor/bcc/search?q=push+path%3Atests&type=Code search /tests ,", "Return": "0 on success, negative error on failure", "Input Prameters": ["{Type:  , Var: val}", "{Type:  int, Var: flags}"], "capabilities": []}, "map.pop": {"Project": "bcc", "FunctionName": "map.pop", "Return Type": "int", "Description": "int map.pop(&val) Pop an element from a Stack or Queue table. *val is populated with the result.Unlike peeking, popping removes the element.Returns 0 on success, negative error on failure. Examples in situ: \"https://github.com/iovisor/bcc/search?q=pop+path%3Atests&type=Code search /tests ,", "Return": "0 on success, negative error on failure", "Input Prameters": ["{Type:  , Var: val}"], "capabilities": []}, "map.peek": {"Project": "bcc", "FunctionName": "map.peek", "Return Type": "int", "Description": "int map.peek(&val) Peek an element at the head of a Stack or Queue table. *val is populated with the result.Unlike popping, peeking does not remove the element.Returns 0 on success, negative error on failure. Examples in situ: \"https://github.com/iovisor/bcc/search?q=peek+path%3Atests&type=Code search /tests ,", "Return": "0 on success, negative error on failure", "Input Prameters": ["{Type:  , Var: val}"], "capabilities": []}, "map.sock_hash_update": {"Project": "bcc", "FunctionName": "map.sock_hash_update", "Return Type": "int", "Description": "int map.sock_hash_update(struct bpf_sock_ops *skops, &key, int flags) Add an entry to, or update a sockhash map referencing sockets. The skops is used as a new value for the entry associated to key. flags is one of: BPF_NOEXIST: The entry for key must not exist in the map.BPF_EXIST: The entry for key must already exist in the map.BPF_ANY: No condition on the existence of the entry for key. If the map has eBPF programs (parser and verdict), those will be inherited by the socket being added. If the socket is already attached to eBPF programs, this results in an error. Return 0 on success, or a negative error in case of failure. Examples in situ: \"https://github.com/iovisor/bcc/search?q=sock_hash_update+path%3Atests&type=Code search /tests ,", "Return": "0 on success, or a negative error in case of failure.", "Input Prameters": ["{Type: struct bpf_sock_ops *, Var: skops}", "{Type: , Var: key}", "{Type: int, Var: flags}"], "capabilities": []}, "map.msg_redirect_hash": {"Project": "bcc", "FunctionName": "map.msg_redirect_hash", "Return Type": "int", "Description": "int map.msg_redirect_hash(struct sk_msg_buff *msg, void *key, u64 flags) This helper is used in programs implementing policies at the socket level. If the message msg is allowed to pass (i.e. if the verdict eBPF program returns SK_PASS), redirect it to the socket referenced by map (of type BPF_MAP_TYPE_SOCKHASH) using hash key. Both ingress and egress interfaces can be used for redirection. The BPF_F_INGRESS value in flags is used to make the distinction (ingress path is selected if the flag is present, egress path otherwise). This is the only flag supported for now. Return SK_PASS on success, or SK_DROP on error. Examples in situ: \"https://github.com/iovisor/bcc/search?q=msg_redirect_hash+path%3Atests&type=Code search /tests ,", "Return": "SK_PASS on success, or SK_DROP on error", "Input Prameters": ["{Type: struct sk_msg_buff *, Var: msg}", "{Type: void* , Var: key}", "{Type: u64, Var: flags}"], "capabilities": []}}]
