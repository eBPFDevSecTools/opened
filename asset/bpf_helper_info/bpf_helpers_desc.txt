Name,Description,is_map_read,is_map_write
*bpf_map_lookup_elemXXPerform a lookup in map for an entry associated to key.
 
 
bpf_map_update_elemXXAdd or update the value of the entry associated to key in map with value. flags is one of:BPF_NOEXISTThe entry for key must not exist in the map.BPF_EXISTThe entry for key must already exist in the map.BPF_ANYNo condition on the existence of the entry for key.Flag value BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY  (all elements always  ex‐ist), the helper would return an error.
 
 
bpf_map_delete_elemXXDelete entry with key from map.
 
 
bpf_probe_readXXFor tracing programs, safely attempt to read size bytes from address src and store the data in dst.
 
 
bpf_ktime_get_nsXXRaturn the time elapsed since system boot, in nanoseconds.
 
 
bpf_trace_printkXXThis  helper  is  a  "printk()-like"  facility for debugging. It prints a message defined by format fmt (of size fmt_size) to file/sys/kernel/debug/tracing/trace from DebugFS, if available. It can take up to three additional u64 arguments (as an eBPF  helpers,the total number of arguments is limited to five).Each  time  the  helper  is  called, it appends a line to the trace.  Lines are discarded while /sys/kernel/debug/tracing/trace isopen, use /sys/kernel/debug/tracing/trace_pipe to avoid this.  The format of the trace is customizable, and the exact  output  onewill  get  depends  on  the options set in /sys/kernel/debug/tracing/trace_options (see also the README file under the same direc‐tory). However, it usually defaults to something like:telnet-470   [001] .N.. 419421.045894: 0x00000001: <formatted msg>In the above:• telnet is the name of the current task.• 470 is the PID of the current task.• 001 is the CPU number on which the task is running.• In .N.., each character refers to a set of options (whether irqs are enabled, scheduling options, whether  hard/softirqs  arerunning, level of preempt_disabled respectively). N means that TIF_NEED_RESCHED and PREEMPT_NEED_RESCHED are set.• 419421.045894 is a timestamp.• 0x00000001 is a fake value used by BPF for the instruction pointer register.• <formatted msg> is the message formatted with fmt.The  conversion  specifiers  supported  by fmt are similar, but more limited than for printk(). They are %d, %i, %u, %x, %ld, %li,%lu, %lx, %lld, %lli, %llu, %llx, %p, %s. No modifier (size of field, padding with zeroes, etc.) is available, and the helper willreturn -EINVAL (but print nothing) if it encounters an unknown specifier.Also,  note that bpf_trace_printk() is slow, and should only be used for debugging purposes. For this reason, a notice bloc (span‐ning several lines) is printed to kernel logs and states that the helper should not be used "for production use"  the  first  timethis  helper is used (or more precisely, when trace_printk() buffers are allocated). For passing values to user space, perf eventsshould be preferred.
 
 
bpf_get_prandom_u32XXGet a pseudo-random number.From a security point of view, this helper uses its own pseudo-random internal state, and cannot be used  to  infer  the  seed  ofother  random functions in the kernel. However, it is essential to note that the generator used by the helper is not cryptographi‐cally secure.
 
 
bpf_get_smp_processor_idXXGet the SMP (symmetric multiprocessing) processor id. Note that all programs run with preemption disabled, which  means  that  theSMP processor id is stable during all the execution of the program.
 
 
bpf_skb_store_bytesXXStore  len  bytes  from address from into the packet associated to skb, at offset. flags are a combination of BPF_F_RECOMPUTE_CSUM(automatically recompute the checksum  for  the  packet  after  storing  the  bytes)  and  BPF_F_INVALIDATE_HASH  (set  skb->hash,skb->swhash and skb->l4hash to 0).A  call to this helper is susceptible to change the underlying packet buffer. Therefore, at load time, all checks on pointers pre‐viously done by the verifier are invalidated and must be performed again, if the helper is used in combination with direct  packetaccess.
 
 
bpf_l3_csum_replaceXXRecompute the layer 3 (e.g. IP) checksum for the packet associated to skb. Computation is incremental, so the helper must know theformer value of the header field that was modified (from), the new value of this field (to), and the number of bytes (2 or 4)  forthis  field, stored in size.  Alternatively, it is possible to store the difference between the previous and the new values of theheader field in to, by setting from and size to 0. For both methods, offset indicates the location of the IP checksum  within  thepacket.This  helper  works  in combination with bpf_csum_diff(), which does not update the checksum in-place, but offers more flexibilityand can handle sizes larger than 2 or 4 for the checksum to update.A call to this helper is susceptible to change the underlying packet buffer. Therefore, at load time, all checks on pointers  pre‐viously  done by the verifier are invalidated and must be performed again, if the helper is used in combination with direct packetaccess.
 
 
bpf_l4_csum_replaceXXRecompute the layer 4 (e.g. TCP, UDP or ICMP) checksum for the packet associated to skb. Computation is incremental, so the helpermust know the former value of the header field that was modified (from), the new value of this field (to), and the number of bytes(2 or 4) for this field, stored on the lowest four bits of flags. Alternatively, it is possible to store  the  difference  betweenthe  previous and the new values of the header field in to, by setting from and the four lowest bits of flags to 0. For both meth‐ods, offset indicates the location of the IP checksum within the packet. In addition to the size of the field, flags can be  added(bitwise  OR)  actual  flags.  With BPF_F_MARK_MANGLED_0, a null checksum is left untouched (unless BPF_F_MARK_ENFORCE is added aswell), and for updates resulting in a null checksum the value is set to CSUM_MANGLED_0 instead.  Flag  BPF_F_PSEUDO_HDR  indicatesthe checksum is to be computed against a pseudo-header.This  helper  works  in combination with bpf_csum_diff(), which does not update the checksum in-place, but offers more flexibilityand can handle sizes larger than 2 or 4 for the checksum to update.A call to this helper is susceptible to change the underlying packet buffer. Therefore, at load time, all checks on pointers  pre‐viously  done by the verifier are invalidated and must be performed again, if the helper is used in combination with direct packetaccess.
 
 
bpf_tail_callXXThis special helper is used to trigger a "tail call", or in other words, to jump into another eBPF program. The same  stack  frameis  used (but values on stack and in registers for the caller are not accessible to the callee). This mechanism allows for programchaining, either for raising the maximum number of available eBPF instructions,  or  to  execute  given  programs  in  conditionalblocks. For security reasons, there is an upper limit to the number of successive tail calls that can be performed.Upon  call  of this helper, the program attempts to jump into a program referenced at index index in prog_array_map, a special mapof type BPF_MAP_TYPE_PROG_ARRAY, and passes ctx, a pointer to the context.If the call succeeds, the kernel immediately runs the first instruction of the new program. This is not a function  call,  and  itnever  returns to the previous program. If the call fails, then the helper has no effect, and the caller continues to run its sub‐sequent instructions. A call can fail if the destination program for the jump does not exist (i.e. index is superior to the numberof  entries  in prog_array_map), or if the maximum number of tail calls has been reached for this chain of programs. This limit isdefined in the kernel by the macro MAX_TAIL_CALL_CNT (not accessible to user space), which is currently set to 32.
 
 
bpf_clone_redirectXXClone and redirect the packet associated to skb to another net device of index ifindex. Both ingress and egress interfaces can  beused  for  redirection.  The BPF_F_INGRESS value in flags is used to make the distinction (ingress path is selected if the flag ispresent, egress path otherwise).  This is the only flag supported for now.In comparison with bpf_redirect() helper, bpf_clone_redirect() has the associated cost of duplicating the packet buffer, but  thiscan  be  executed  out of the eBPF program. Conversely, bpf_redirect() is more efficient, but it is handled through an action codewhere the redirection happens only after the eBPF program has returned.A call to this helper is susceptible to change the underlying packet buffer. Therefore, at load time, all checks on pointers  pre‐viously  done by the verifier are invalidated and must be performed again, if the helper is used in combination with direct packetaccess.
 
 
bpf_get_current_pid_tgidXXRaturn A 64-bit integer containing the current tgid and pid, and created as such: current_task->tgid << 32 | current_task->pid.		    Return A 64-bit integer containing the current tgid and pid, and created as such: current_task->tgid << 32 | current_task->pid.u64 bpf_get_current_uid_gid(void)		Description
Raturn A 64-bit integer containing the current GID and UID, and created as such: current_gid << 32 | current_uid.Return A 64-bit integer containing the current GID and UID, and created as such: current_gid << 32 | current_uid.


bpf_get_current_commXXCopy the comm attribute of the current task into buf of size_of_buf. The comm attribute contains the name of the  executable  (ex‐cluding  the path) for the current task. The size_of_buf must be strictly positive. On success, the helper makes sure that the bufis NUL-terminated. On failure, it is filled with zeroes.
 
 
bpf_get_cgroup_classidXXRetrieve the classid for the current task, i.e. for the net_cls cgroup to which skb belongs.This helper can be used on TC egress path, but not on ingress.The net_cls cgroup provides an interface to tag network packets based on a user-provided identifier for all  traffic  coming  fromthe  tasks  belonging  to  the related cgroup. See also the related kernel documentation, available from the Linux sources in fileDocumentation/admin-guide/cgroup-v1/net_cls.rst.The Linux kernel has two versions for cgroups: there are cgroups v1 and cgroups v2. Both are available to users,  who  can  use  amixture  of  them,  but  note  that  the net_cls cgroup is for cgroup v1 only. This makes it incompatible with BPF programs run oncgroups, which is a cgroup-v2-only feature (a socket can only hold data for one version of cgroups at a time).This helper is only available is the kernel was compiled with the CONFIG_CGROUP_NET_CLASSID configuration option set to "y" or  to"m".
 
 
bpf_skb_vlan_pushXXPush  a  vlan_tci (VLAN tag control information) of protocol vlan_proto to the packet associated to skb, then update the checksum.Note that if vlan_proto is different from ETH_P_8021Q and ETH_P_8021AD, it is considered to be ETH_P_8021Q.A call to this helper is susceptible to change the underlying packet buffer. Therefore, at load time, all checks on pointers  pre‐viously  done by the verifier are invalidated and must be performed again, if the helper is used in combination with direct packetaccess.
 
 
bpf_skb_vlan_popXXPop a VLAN header from the packet associated to skb.A call to this helper is susceptible to change the underlying packet buffer. Therefore, at load time, all checks on pointers  pre‐viously  done by the verifier are invalidated and must be performed again, if the helper is used in combination with direct packetaccess.
 
 
bpf_skb_get_tunnel_keyXXGet tunnel metadata. This helper takes a pointer key to an empty struct bpf_tunnel_key of size, that will be  filled  with  tunnelmetadata  for  the packet associated to skb.  The flags can be set to BPF_F_TUNINFO_IPV6, which indicates that the tunnel is basedon IPv6 protocol instead of IPv4.The struct bpf_tunnel_key is an object that generalizes the principal parameters used by various tunneling protocols into a singlestruct. This way, it can be used to easily make a decision based on the contents of the encapsulation header, "summarized" in thisstruct. In particular, it holds the IP address of the remote end (IPv4 or IPv6, depending on  the  case)  in  key->remote_ipv4  orkey->remote_ipv6.  Also,  this struct exposes the key->tunnel_id, which is generally mapped to a VNI (Virtual Network Identifier),making it programmable together with the bpf_skb_set_tunnel_key() helper.Let's imagine that the following code is part of a program attached to the TC ingress interface, on one end of a GRE  tunnel,  andis supposed to filter out all messages coming from remote ends with IPv4 address other than 10.0.0.1:int ret;struct bpf_tunnel_key key = {};ret = bpf_skb_get_tunnel_key(skb, &key, sizeof(key), 0);if (ret < 0)return TC_ACT_SHOT;     // drop packetif (key.remote_ipv4 != 0x0a000001)return TC_ACT_SHOT;     // drop packetreturn TC_ACT_OK;               // accept packetThis  interface can also be used with all encapsulation devices that can operate in "collect metadata" mode: instead of having onenetwork device per specific configuration, the "collect metadata" mode only requires a single device where the  configuration  canbe extracted from this helper.This can be used together with various tunnels such as VXLan, Geneve, GRE or IP in IP (IPIP).
 
 
bpf_skb_set_tunnel_keyXXPopulate  tunnel  metadata for packet associated to skb. The tunnel metadata is set to the contents of key, of size. The flags canbe set to a combination of the following values:BPF_F_TUNINFO_IPV6Indicate that the tunnel is based on IPv6 protocol instead of IPv4.BPF_F_ZERO_CSUM_TXFor IPv4 packets, add a flag to tunnel metadata indicating that checksum computation should be skipped and checksum set  tozeroes.BPF_F_DONT_FRAGMENTAdd a flag to tunnel metadata indicating that the packet should not be fragmented.BPF_F_SEQ_NUMBERAdd a flag to tunnel metadata indicating that a sequence number should be added to tunnel header before sending the packet.This flag was added for GRE encapsulation, but might be used with other protocols as well in the future.Here is a typical usage on the transmit path:struct bpf_tunnel_key key;populate key ...bpf_skb_set_tunnel_key(skb, &key, sizeof(key), 0);bpf_clone_redirect(skb, vxlan_dev_ifindex, 0);See also the description of the bpf_skb_get_tunnel_key() helper for additional information.
 
 
bpf_perf_event_readXXRead the value of a perf event counter. This helper relies on a map of type BPF_MAP_TYPE_PERF_EVENT_ARRAY. The nature of the  perfevent  counter  is  selected when map is updated with perf event file descriptors. The map is an array whose size is the number ofavailable CPUs, and each cell contains a value relative to one CPU. The value to retrieve is indicated by flags, that contains theindex  of  the CPU to look up, masked with BPF_F_INDEX_MASK. Alternatively, flags can be set to BPF_F_CURRENT_CPU to indicate thatthe value for the current CPU should be retrieved.Note that before Linux 4.13, only hardware perf event can be retrieved.Also, be aware that the newer helper bpf_perf_event_read_value() is recommended over bpf_perf_event_read() in general. The  latterhas  some ABI quirks where error and counter value are used as a return code (which is wrong to do since ranges may overlap). Thisissue is fixed with bpf_perf_event_read_value(), which at the same time provides more features over the bpf_perf_event_read()  in‐terface. Please refer to the description of bpf_perf_event_read_value() for details.
 
 
bpf_redirectXXRedirect  the packet to another net device of index ifindex.  This helper is somewhat similar to bpf_clone_redirect(), except thatthe packet is not cloned, which provides increased performance.Except for XDP, both ingress and egress interfaces can be used for redirection. The BPF_F_INGRESS value in flags is used  to  makethe distinction (ingress path is selected if the flag is present, egress path otherwise). Currently, XDP only supports redirectionto the egress interface, and accepts no flag at all.The same effect can be attained with the more generic bpf_redirect_map(), which requires specific maps to be used but offers  bet‐ter performance.
 
 
bpf_get_route_realmXXRetrieve the realm or the route, that is to say the tclassid field of the destination for the skb. The indentifier retrieved is  auser-provided tag, similar to the one used with the net_cls cgroup (see description for bpf_get_cgroup_classid() helper), but herethis tag is held by a route (a destination entry), not by a task.Retrieving this identifier works with the clsact TC egress hook (see also tc-bpf(8)), or alternatively  on  conventional  classfulegress qdiscs, but not on TC ingress path. In case of clsact TC egress hook, this has the advantage that, internally, the destina‐tion entry has not been dropped yet in the transmit path. Therefore, the destination entry does not need to be  artificially  heldvia netif_keep_dst() for a classful qdisc until the skb is freed.This helper is available only if the kernel was compiled with CONFIG_IP_ROUTE_CLASSID configuration option.
 
 
bpf_perf_event_outputXXWrite raw data blob into a special BPF perf event held by map of type BPF_MAP_TYPE_PERF_EVENT_ARRAY. This perf event must have thefollowing attributes: PERF_SAMPLE_RAW as sample_type, PERF_TYPE_SOFTWARE as type, and PERF_COUNT_SW_BPF_OUTPUT as config.The flags are used to indicate the index in map for which the value must be put,  masked  with  BPF_F_INDEX_MASK.   Alternatively,flags can be set to BPF_F_CURRENT_CPU to indicate that the index of the current CPU core should be used.The value to write, of size, is passed through eBPF stack and pointed by data.The context of the program ctx needs also be passed to the helper.On  user  space, a program willing to read the values needs to call perf_event_open() on the perf event (either for one or for allCPUs) and to store the file descriptor into the map. This must be done before the eBPF program can send data into it.  An  exampleis  available  in  file  samples/bpf/trace_output_user.c  in the Linux kernel source tree (the eBPF program counterpart is in sam‐ples/bpf/trace_output_kern.c).bpf_perf_event_output() achieves better performance than bpf_trace_printk() for sharing data with user space, and is  much  bettersuitable for streaming data from eBPF programs.Note that this helper is not restricted to tracing use cases and can be used with programs attached to TC or XDP as well, where itallows for passing data to user space listeners. Data can be:• Only custom structs,• Only the packet payload, or• A combination of both.
 
 
bpf_skb_load_bytesXXThis helper was provided as an easy way to load data from a packet. It can be used to load len bytes from offset from  the  packetassociated to skb, into the buffer pointed by to.Since  Linux  4.7, usage of this helper has mostly been replaced by "direct packet access", enabling packet data to be manipulatedwith skb->data and skb->data_end pointing respectively to the first byte of packet data and to the byte after  the  last  byte  ofpacket data. However, it remains useful if one wishes to read large quantities of data at once from a packet into the eBPF stack.
 
 
bpf_get_stackidXXWalk a user or a kernel stack and return its id. To achieve this, the helper needs ctx, which is a pointer to the context on whichthe tracing program is executed, and a pointer to a map of type BPF_MAP_TYPE_STACK_TRACE.The last argument, flags, holds the number of stack frames to skip (from 0 to 255), masked with  BPF_F_SKIP_FIELD_MASK.  The  nextbits can be used to set a combination of the following flags:BPF_F_USER_STACKCollect a user space stack instead of a kernel stack.BPF_F_FAST_STACK_CMPCompare stacks by hash only.BPF_F_REUSE_STACKIDIf two different stacks hash into the same stackid, discard the old one.The  stack  id retrieved is a 32 bit long integer handle which can be further combined with other data (including other stack ids)and used as a key into maps. This can be useful for generating a variety of graphs (such as flame graphs or off-cpu graphs).For walking a stack, this helper is an improvement over bpf_probe_read(), which can be used with unrolled loops but is  not  effi‐cient  and consumes a lot of eBPF instructions.  Instead, bpf_get_stackid() can collect up to PERF_MAX_STACK_DEPTH both kernel anduser frames. Note that this limit can be controlled with the sysctl program, and that it should be manually increased in order  toprofile long user stacks (such as stacks for Java programs). To do so, use:# sysctl kernel.perf_event_max_stack=<new value>
 
 
bpf_csum_diffXXCompute  a  checksum  difference, from the raw buffer pointed by from, of length from_size (that must be a multiple of 4), towardsthe raw buffer pointed by to, of size to_size (same remark). An optional seed can be added to the value (this can be cascaded, theseed may come from a previous call to the helper).This is flexible enough to be used in several ways:• With from_size == 0, to_size > 0 and seed set to checksum, it can be used when pushing new data.• With from_size > 0, to_size == 0 and seed set to checksum, it can be used when removing data from a packet.• With from_size > 0, to_size > 0 and seed set to 0, it can be used to compute a diff. Note that from_size and to_size do not needto be equal.This helper can be used in combination with bpf_l3_csum_replace() and bpf_l4_csum_replace(), to which one can feed in the  differ‐ence computed with bpf_csum_diff().
 
 
bpf_skb_get_tunnel_optXXRetrieve tunnel options metadata for the packet associated to skb, and store the raw tunnel option data to the buffer opt of size.This  helper  can be used with encapsulation devices that can operate in "collect metadata" mode (please refer to the related notein the description of bpf_skb_get_tunnel_key() for more details). A particular example where this can be used  is  in  combinationwith  the  Geneve  encapsulation protocol, where it allows for pushing (with bpf_skb_get_tunnel_opt() helper) and retrieving arbi‐trary TLVs (Type-Length-Value headers) from the eBPF program. This allows for full customization of these headers.
 
 
bpf_skb_set_tunnel_optXXSet tunnel options metadata for the packet associated to skb to the option data contained in the raw buffer opt of size.See also the description of the bpf_skb_get_tunnel_opt() helper for additional information.
 
 
bpf_skb_change_protoXXChange the protocol of the skb to proto. Currently supported are transition from IPv4 to IPv6, and from IPv6 to IPv4.  The  helpertakes  care  of  the groundwork for the transition, including resizing the socket buffer. The eBPF program is expected to fill thenew headers, if any, via skb_store_bytes() and to recompute the checksums with  bpf_l3_csum_replace()  and  bpf_l4_csum_replace().The main case for this helper is to perform NAT64 operations out of an eBPF program.Internally,  the GSO type is marked as dodgy so that headers are checked and segments are recalculated by the GSO/GRO engine.  Thesize for GSO target is adapted as well.All values for flags are reserved for future usage, and must be left at zero.A call to this helper is susceptible to change the underlying packet buffer. Therefore, at load time, all checks on pointers  pre‐viously  done by the verifier are invalidated and must be performed again, if the helper is used in combination with direct packetaccess.
 
 
bpf_skb_change_typeXXChange the packet type for the packet associated to skb. This comes down to setting skb->pkt_type to type, except the eBPF programdoes not have a write access to skb->pkt_type beside this helper. Using a helper here allows for graceful handling of errors.The  major use case is to change incoming skb*s to **PACKET_HOST* in a programmatic way instead of having to recirculate via redi‐rect(..., BPF_F_INGRESS), for example.Note that type only allows certain values. At this time, they are:PACKET_HOSTPacket is for us.PACKET_BROADCASTSend packet to all.PACKET_MULTICASTSend packet to group.PACKET_OTHERHOSTSend packet to someone else.
 
 
bpf_skb_under_cgroupXXCheck whether skb is a descendant of the cgroup2 held by map of type BPF_MAP_TYPE_CGROUP_ARRAY, at index.
 
 
bpf_get_hash_recalcXXRetrieve the hash of the packet, skb->hash. If it is not set, in particular if the hash was cleared  due  to  mangling,  recomputethis hash. Later accesses to the hash can be done directly with skb->hash.Calling bpf_set_hash_invalid(), changing a packet prototype with bpf_skb_change_proto(), or calling bpf_skb_store_bytes() with theBPF_F_INVALIDATE_HASH are actions susceptible to clear  the  hash  and  to  trigger  a  new  computation  for  the  next  call  tobpf_get_hash_recalc().
 
 
bpf_get_current_taskXXRaturn A pointer to the current task struct.Return A pointer to the current task struct.int bpf_probe_write_user(void *dst, const void *src, u32 len)              Description
Attempt in a safe way to write len bytes from the buffer src to dst in memory. It only works for threads that are in user context,and dst must be a valid user space address.This helper should not be used to implement any kind of security mechanism because of TOC-TOU attacks, but rather  to  debug,  di‐vert, and manipulate execution of semi-cooperative processes.Keep  in  mind  that this feature is meant for experiments, and it has a risk of crashing the system and running programs.  There‐fore, when an eBPF program using this helper is attached, a warning including PID and process name is printed to kernel logs.
 
 
bpf_current_task_under_cgroupXXCheck whether the probe is being run is the context of a given subset of the cgroup2 hierarchy. The cgroup2 to test is held by mapof type BPF_MAP_TYPE_CGROUP_ARRAY, at index.
 
 
bpf_skb_change_tailXXResize  (trim  or  grow) the packet associated to skb to the new len. The flags are reserved for future usage, and must be left atzero.The basic idea is that the helper performs the needed work to change the size of the packet, then the eBPF  program  rewrites  therest  via  helpers like bpf_skb_store_bytes(), bpf_l3_csum_replace(), bpf_l3_csum_replace() and others. This helper is a slow pathutility intended for replies with control messages. And because it is targeted for slow path, the helper itself can afford  to  beslow: it implicitly linearizes, unclones and drops offloads from the skb.A  call to this helper is susceptible to change the underlying packet buffer. Therefore, at load time, all checks on pointers pre‐viously done by the verifier are invalidated and must be performed again, if the helper is used in combination with direct  packetaccess.
 
 
bpf_skb_pull_dataXXPull  in  non-linear data in case the skb is non-linear and not all of len are part of the linear section. Make len bytes from skbreadable and writable. If a zero value is passed for len, then the whole length of the skb is pulled.This helper is only needed for reading and writing with direct packet access.For direct packet access, testing that offsets to access are within packet boundaries (test on skb->data_end)  is  susceptible  tofail if offsets are invalid, or if the requested data is in non-linear parts of the skb. On failure the program can just bail out,or in the case of a non-linear buffer, use a helper to make the data available. The bpf_skb_load_bytes() helper is a  first  solu‐tion  to access the data. Another one consists in using bpf_skb_pull_data to pull in once the non-linear parts, then retesting andeventually access the data.At the same time, this also makes sure the skb is uncloned, which is a necessary condition for direct write. As this needs  to  bean  invariant  for the write part only, the verifier detects writes and adds a prologue that is calling bpf_skb_pull_data() to ef‐fectively unclone the skb from the very beginning in case it is indeed cloned.A call to this helper is susceptible to change the underlying packet buffer. Therefore, at load time, all checks on pointers  pre‐viously  done by the verifier are invalidated and must be performed again, if the helper is used in combination with direct packetaccess.
 
 
bpf_csum_updateXXAdd the checksum csum into skb->csum in case the driver has supplied a checksum for the entire packet into that field.  Return  anerror  otherwise. This helper is intended to be used in combination with bpf_csum_diff(), in particular when the checksum needs tobe updated after data has been written into the packet through direct packet access.
 
 
bpf_set_hash_invalidXXInvalidate the current skb->hash. It can be used after mangling on headers through direct packet access, in order to indicate thatthe  hash  is  outdated  and  to  trigger  a  recalculation  the  next  time  the  kernel  tries  to  access this hash or when thebpf_get_hash_recalc() helper is called.


bpf_get_numa_node_id(void)XXRaturn the id of the current NUMA node. The primary use case for this helper is the selection of sockets for the local NUMA  node,when  the  program  is  attached to sockets using the SO_ATTACH_REUSEPORT_EBPF option (see also socket(7)), but the helper is also available to other eBPF program types, similarly to bpf_get_smp_processor_id().
 
 
bpf_set_hash_invalidXXavailable to other eBPF program types, similarly to bpf_get_smp_processor_id().
 
 
bpf_skb_change_headXXGrows headroom of packet associated to skb and adjusts the offset of the MAC header accordingly, adding len bytes of space. It au‐tomatically extends and reallocates memory as required.This helper can be used on a layer 3 skb to push a MAC header for redirection into a layer 2 device.All values for flags are reserved for future usage, and must be left at zero.A  call to this helper is susceptible to change the underlying packet buffer. Therefore, at load time, all checks on pointers pre‐viously done by the verifier are invalidated and must be performed again, if the helper is used in combination with direct  packetaccess.
 
 
bpf_xdp_adjust_headXXAdjust  (move) xdp_md->data by delta bytes. Note that it is possible to use a negative value for delta. This helper can be used toprepare the packet for pushing or popping headers.A call to this helper is susceptible to change the underlying packet buffer. Therefore, at load time, all checks on pointers  pre‐viously  done by the verifier are invalidated and must be performed again, if the helper is used in combination with direct packetaccess.
 
 
bpf_probe_read_strXXCopy a NUL terminated string from an unsafe address unsafe_ptr to dst. The size should include the terminating NUL byte.  In  casethe string length is smaller than size, the target is not padded with further NUL bytes. If the string length is larger than size,just size-1 bytes are copied and the last byte is set to NUL.On success, the length of the copied string is returned. This makes this helper useful in tracing programs  for  reading  strings,and more importantly to get its length at runtime. See the following snippet:SEC("kprobe/sys_open")void bpf_sys_open(struct pt_regs *ctx){char buf[PATHLEN]; // PATHLEN is defined to 256int res = bpf_probe_read_str(buf, sizeof(buf),ctx->di);// Consume buf, for example push it to// userspace via bpf_perf_event_output(); we// can use res (the string length) as event// size, after checking its boundaries.}In comparison, using bpf_probe_read() helper here instead to read the string would require to estimate the length at compile time,and would often result in copying more memory than necessary.Another useful use case is when  parsing  individual  process  arguments  or  individual  environment  variables  navigating  cur‐rent->mm->arg_start  and current->mm->env_start: using this helper and the return value, one can quickly iterate at the right off‐set of the memory area.
 
 
bpf_get_socket_cookieXXIf the struct sk_buff pointed by skb has a known socket, retrieve the cookie (generated by the kernel)  of  this  socket.   If  nocookie  has been set yet, generate a new cookie. Once generated, the socket cookie remains stable for the life of the socket. Thishelper can be useful for monitoring per socket networking traffic statistics as it provides a global socket identifier that can beassumed unique.
 
 
bpf_get_socket_cookieXXEquivalent to bpf_get_socket_cookie() helper that accepts skb, but gets socket from struct bpf_sock_addr context.
 
 
bpf_get_socket_cookieXXEquivalent to bpf_get_socket_cookie() helper that accepts skb, but gets socket from struct bpf_sock_ops context.
 
 
bpf_get_socket_uidXXRaturn The  owner UID of the socket associated to skb. If the socket is NULL, or if it is not a full socket (i.e. if it is a time-wait ora request socket instead), overflowuid value is returned (note that overflowuid might  also  be  the  actual  UID  value  for  thesocket).
 
 
bpf_set_hashXXSet the full hash for skb (set the field skb->hash) to value hash.
 
 
bpf_setsockoptXXEmulate  a call to setsockopt() on the socket associated to bpf_socket, which must be a full socket. The level at which the optionresides and the name optname of the option must be specified, see setsockopt(2) for more information.  The option value of  lengthoptlen is pointed by optval.This helper actually implements a subset of setsockopt().  It supports the following levels:• SOL_SOCKET, which supports the following optnames: SO_RCVBUF, SO_SNDBUF, SO_MAX_PACING_RATE, SO_PRIORITY, SO_RCVLOWAT, SO_MARK.• IPPROTO_TCP, which supports the following optnames: TCP_CONGESTION, TCP_BPF_IW, TCP_BPF_SNDCWND_CLAMP.• IPPROTO_IP, which supports optname IP_TOS.• IPPROTO_IPV6, which supports optname IPV6_TCLASS.
 
 
bpf_skb_adjust_roomXXGrow or shrink the room for data in the packet associated to skb by len_diff, and according to the selected mode.There are two supported modes at this time:• BPF_ADJ_ROOM_MAC: Adjust room at the mac layer (room space is added or removed below the layer 2 header).• BPF_ADJ_ROOM_NET: Adjust room at the network layer (room space is added or removed below the layer 3 header).The following flags are supported at this time:• BPF_F_ADJ_ROOM_FIXED_GSO: Do not adjust gso_size.  Adjusting mss in this way is not allowed for datagrams.• BPF_F_ADJ_ROOM_ENCAP_L3_IPV4,  BPF_F_ADJ_ROOM_ENCAP_L3_IPV6:  Any  new space is reserved to hold a tunnel header.  Configure skboffsets and other fields accordingly.• BPF_F_ADJ_ROOM_ENCAP_L4_GRE, BPF_F_ADJ_ROOM_ENCAP_L4_UDP: Use with ENCAP_L3 flags to further specify the tunnel type.• BPF_F_ADJ_ROOM_ENCAP_L2(len): Use with ENCAP_L3/L4 flags to further specify the tunnel type; len is the length of the inner  MACheader.A  call to this helper is susceptible to change the underlying packet buffer. Therefore, at load time, all checks on pointers pre‐viously done by the verifier are invalidated and must be performed again, if the helper is used in combination with direct  packetaccess.
 
 
bpf_redirect_mapXXRedirect  the packet to the endpoint referenced by map at index key. Depending on its type, this map can contain references to netdevices (for forwarding packets through other ports), or to CPUs (for redirecting XDP frames to another CPU; but this is only  im‐plemented for native XDP (with driver support) as of this writing).The  lower  two  bits of flags are used as the return code if the map lookup fails. This is so that the return value can be one ofthe XDP program return codes up to XDP_TX, as chosen by the caller. Any higher bits in the flags argument must be unset.When used to redirect packets to net devices, this helper provides a high performance increase over bpf_redirect().  This  is  dueto  various  implementation  details  of the underlying mechanisms, one of which is the fact that bpf_redirect_map() tries to sendpacket as a "bulk" to the device.
 
 
bpf_sk_redirect_mapXXRedirect the packet to the socket referenced by map (of type BPF_MAP_TYPE_SOCKMAP) at index key. Both ingress  and  egress  inter‐faces  can  be used for redirection. The BPF_F_INGRESS value in flags is used to make the distinction (ingress path is selected ifthe flag is present, egress path otherwise). This is the only flag supported for now.
 
 
bpf_sock_map_updateXXAdd an entry to, or update a map referencing sockets. The skops is used as a new value for the entry associated to key.  flags  isone of:BPF_NOEXISTThe entry for key must not exist in the map.BPF_EXISTThe entry for key must already exist in the map.BPF_ANYNo condition on the existence of the entry for key.If the map has eBPF programs (parser and verdict), those will be inherited by the socket being added. If the socket is already at‐tached to eBPF programs, this results in an error.
 
 
bpf_xdp_adjust_metaXXAdjust the address pointed by xdp_md->data_meta by delta (which can be positive or negative). Note that  this  operation  modifiesthe address stored in xdp_md->data, so the latter must be loaded only after the helper has been called.The  use  of  xdp_md->data_meta is optional and programs are not required to use it. The rationale is that when the packet is pro‐cessed with XDP (e.g. as DoS filter), it is possible to push further meta data along with it before passing to the stack,  and  togive  the  guarantee  that  an  ingress  eBPF  program attached as a TC classifier on the same device can pick this up for furtherpost-processing. Since TC works with socket buffers, it remains possible to set from XDP the mark or priority pointers,  or  otherpointers  for  the  socket  buffer.  Having this scratch space generic and programmable allows for more flexibility as the user isfree to store whatever meta data they need.A call to this helper is susceptible to change the underlying packet buffer. Therefore, at load time, all checks on pointers  pre‐viously  done by the verifier are invalidated and must be performed again, if the helper is used in combination with direct packetaccess.
 
 
bpf_perf_event_read_valueXXRead the value of a perf event counter, and  store  it  into  buf  of  size  buf_size.  This  helper  relies  on  a  map  of  typeBPF_MAP_TYPE_PERF_EVENT_ARRAY.  The nature of the perf event counter is selected when map is updated with perf event file descrip‐tors. The map is an array whose size is the number of available CPUs, and each cell contains a value  relative  to  one  CPU.  Thevalue  to  retrieve  is  indicated by flags, that contains the index of the CPU to look up, masked with BPF_F_INDEX_MASK. Alterna‐tively, flags can be set to BPF_F_CURRENT_CPU to indicate that the value for the current CPU should be retrieved.This helper behaves in a way close to bpf_perf_event_read() helper, save that instead of just returning  the  value  observed,  itfills  the  buf  structure.  This  allows  for  additional  data to be retrieved: in particular, the enabled and running times (inbuf->enabled  and  buf->running,  respectively)  are  copied.  In  general,  bpf_perf_event_read_value()   is   recommended   overbpf_perf_event_read(), which has some ABI issues and provides fewer functionalities.These  values  are  interesting, because hardware PMU (Performance Monitoring Unit) counters are limited resources. When there aremore PMU based perf events opened than available counters, kernel will multiplex these events so each event gets certain  percent‐age  (but not all) of the PMU time. In case that multiplexing happens, the number of samples or counter value will not reflect thecase compared to when no multiplexing occurs. This makes comparison between different  runs  difficult.   Typically,  the  countervalue should be normalized before comparing to other experiments. The usual normalization is done as follows.normalized_counter = counter * t_enabled / t_runningWhere  t_enabled  is  the time enabled for event and t_running is the time running for event since last normalization. The enabledand running times are accumulated since the perf event open. To achieve scaling factor between two invocations of an eBPF program,users can can use CPU id as the key (which is typical for perf array usage model) to remember the previous value and do the calcu‐lation inside the eBPF program.
 
 
bpf_perf_prog_read_valueXXFor en eBPF program attached to a perf event, retrieve the value of the event counter associated to ctx and store it in the struc‐ture  pointed  by  buf and of size buf_size. Enabled and running times are also stored in the structure (see description of helperbpf_perf_event_read_value() for more details).
 
 
bpf_getsockoptXXEmulate a call to getsockopt() on the socket associated to bpf_socket, which must be a full socket. The level at which the  optionresides  and  the  name  optname  of the option must be specified, see getsockopt(2) for more information.  The retrieved value isstored in the structure pointed by opval and of length optlen.This helper actually implements a subset of getsockopt().  It supports the following levels:• IPPROTO_TCP, which supports optname TCP_CONGESTION.• IPPROTO_IP, which supports optname IP_TOS.• IPPROTO_IPV6, which supports optname IPV6_TCLASS.
 
 
bpf_override_returnXXUsed for error injection, this helper uses kprobes to override the return value of the probed function, and to set it to rc.   Thefirst argument is the context regs on which the kprobe works.This helper works by setting setting the PC (program counter) to an override function which is run in place of the original probedfunction. This means the probed function is not run at all. The replacement function just returns with the required value.This helper has security implications, and thus is subject to restrictions. It is only available if the kernel was  compiled  withthe CONFIG_BPF_KPROBE_OVERRIDE configuration option, and in this case it only works on functions tagged with ALLOW_ERROR_INJECTIONin the kernel code.Also, the helper is only available for the architectures having the CONFIG_FUNCTION_ERROR_INJECTION option. As  of  this  writing,x86 architecture is the only one to support this feature.
 
 
bpf_sock_ops_cb_flags_setXXAttempt to set the value of the bpf_sock_ops_cb_flags field for the full TCP socket associated to bpf_sock_ops to argval.The  primary use of this field is to determine if there should be calls to eBPF programs of type BPF_PROG_TYPE_SOCK_OPS at variouspoints in the TCP code. A program of the same type can change its value, per connection and as necessary, when the  connection  isestablished.  This  field is directly accessible for reading, but this helper must be used for updates in order to return an errorif an eBPF program tries to set a callback that is not supported in the current kernel.argval is a flag array which can combine these flags:• BPF_SOCK_OPS_RTO_CB_FLAG (retransmission time out)• BPF_SOCK_OPS_RETRANS_CB_FLAG (retransmission)• BPF_SOCK_OPS_STATE_CB_FLAG (TCP state change)• BPF_SOCK_OPS_RTT_CB_FLAG (every RTT)Therefore, this function can be used to clear a callback flag by setting the appropriate bit to zero.  e.g.  to  disable  the  RTOcallback:bpf_sock_ops_cb_flags_set(bpf_sock,bpf_sock->bpf_sock_ops_cb_flags & ~BPF_SOCK_OPS_RTO_CB_FLAG)Here are some examples of where one could call such eBPF program:• When RTO fires.• When a packet is retransmitted.• When the connection terminates.• When a packet is sent.• When a packet is received.
 
 
bpf_msg_redirect_mapXXThis helper is used in programs implementing policies at the socket level. If the message msg is allowed to pass (i.e. if the ver‐dict  eBPF program returns SK_PASS), redirect it to the socket referenced by map (of type BPF_MAP_TYPE_SOCKMAP) at index key. Bothingress and egress interfaces can be used for redirection. The BPF_F_INGRESS value in  flags  is  used  to  make  the  distinction(ingress path is selected if the flag is present, egress path otherwise). This is the only flag supported for now.
 
 
bpf_msg_apply_bytesXXFor socket policies, apply the verdict of the eBPF program to the next bytes (number of bytes) of message msg.For example, this helper can be used in the following cases:• A  single  sendmsg()  or sendfile() system call contains multiple logical messages that the eBPF program is supposed to read andfor which it should apply a verdict.• An eBPF program only cares to read the first bytes of a msg. If the message has a large payload, then setting up and calling theeBPF program repeatedly for all bytes, even though the verdict is already known, would create unnecessary overhead.When  called  from within an eBPF program, the helper sets a counter internal to the BPF infrastructure, that is used to apply thelast verdict to the next bytes. If bytes is smaller than the current data being processed from a sendmsg()  or  sendfile()  systemcall,  the first bytes will be sent and the eBPF program will be re-run with the pointer for start of data pointing to byte numberbytes + 1. If bytes is larger than the current data being processed, then the eBPF verdict will be applied to  multiple  sendmsg()or sendfile() calls until bytes are consumed.Note  that  if a socket closes with the internal counter holding a non-zero value, this is not a problem because data is not beingbuffered for bytes and is sent as it is received.
 
 
bpf_msg_cork_bytesXXFor socket policies, prevent the execution of the verdict eBPF program for message msg until bytes (byte number) have been accumu‐lated.This  can  be  used  when  one  needs a specific number of bytes before a verdict can be assigned, even if the data spans multiplesendmsg() or sendfile() calls. The extreme case would be a user calling sendmsg() repeatedly with 1-byte  long  message  segments.Obviously,  this  is  bad for performance, but it is still valid. If the eBPF program needs bytes bytes to validate a header, thishelper can be used to prevent the eBPF program to be called again until bytes have been accumulated.
 
 
bpf_msg_pull_dataXXFor socket policies, pull in non-linear data from user space for msg and set pointers msg->data and msg->data_end to start and endbytes offsets into msg, respectively.If  a  program of type BPF_PROG_TYPE_SK_MSG is run on a msg it can only parse data that the (data, data_end) pointers have alreadyconsumed. For sendmsg() hooks this is likely the first scatterlist element. But for calls relying on the  sendpage  handler  (e.g.sendfile())  this will be the range (0, 0) because the data is shared with user space and by default the objective is to avoid al‐lowing user space to modify data while (or after) eBPF verdict is being decided. This helper can be used to pull in  data  and  toset  the start and end pointer to given values. Data will be copied if necessary (i.e. if data was not linear and if start and endpointers do not point to the same chunk).A call to this helper is susceptible to change the underlying packet buffer. Therefore, at load time, all checks on pointers  pre‐viously  done by the verifier are invalidated and must be performed again, if the helper is used in combination with direct packetaccess.All values for flags are reserved for future usage, and must be left at zero.
 
 
bpf_bindXXBind the socket associated to ctx to the address pointed by addr, of length addr_len. This allows for making  outgoing  connectionfrom  the  desired IP address, which can be useful for example when all processes inside a cgroup should use one single IP addresson a host that has multiple IP configured.This helper works for IPv4 and IPv6, TCP and UDP sockets. The domain (addr->sa_family) must be AF_INET (or AF_INET6). Looking  fora  free  port to bind to can be expensive, therefore binding to port is not permitted by the helper: addr->sin_port (or sin6_port,respectively) must be set to zero.
 
 
bpf_xdp_adjust_tailXXAdjust (move) xdp_md->data_end by delta bytes. It is only possible to shrink the packet as of this writing, therefore  delta  mustbe a negative integer.A  call to this helper is susceptible to change the underlying packet buffer. Therefore, at load time, all checks on pointers pre‐viously done by the verifier are invalidated and must be performed again, if the helper is used in combination with direct  packetaccess.
 
 
bpf_skb_get_xfrm_stateXXRetrieve the XFRM state (IP transform framework, see also ip-xfrm(8)) at index in XFRM "security path" for skb.The retrieved value is stored in the struct bpf_xfrm_state pointed by xfrm_state and of length size.All values for flags are reserved for future usage, and must be left at zero.This helper is available only if the kernel was compiled with CONFIG_XFRM configuration option.
 
 
bpf_get_stackXXRaturn  a user or a kernel stack in bpf program provided buffer.  To achieve this, the helper needs ctx, which is a pointer to the context on which the tracing program is executed.  To store the stacktrace, the bpf program provides buf with a nonnegative size.The last argument, flags, holds the number of stack frames to skip (from 0 to 255), masked with  BPF_F_SKIP_FIELD_MASK.  The  next bits can be used to set the following flags: BPF_F_USER_STACK
Collect a user space stack instead of a kernel stack.BPF_F_USER_BUILD_ID Collect buildid+offset instead of ips for user stack, only valid if BPF_F_USER_STACK is also specified.bpf_get_stack()  can collect up to PERF_MAX_STACK_DEPTH both kernel and user frames, subject to sufficient large buffer size. Note that this limit can be controlled with the sysctl program, and that it should be manually increased in order to profile long  user stacks (such as stacks for Java programs). To do so, use:# sysctl kernel.perf_event_max_stack=<new value>
 
 
bpf_skb_load_bytes_relativeXXThis helper is similar to bpf_skb_load_bytes() in that it provides an easy way to load len bytes from offset from the packet asso‐ciated to skb, into the buffer pointed by to. The difference to bpf_skb_load_bytes() is that a fifth argument start_header  existsin order to select a base offset to start from. start_header can be one of:BPF_HDR_START_MACBase offset to load data from is skb's mac header.BPF_HDR_START_NETBase offset to load data from is skb's network header.In  general, "direct packet access" is the preferred method to access packet data, however, this helper is in particular useful insocket filters where skb->data does not always point to the start of the mac header and where "direct packet access" is not avail‐able.
 
 
bpf_fib_lookupXXDo  FIB  lookup  in kernel tables using parameters in params.  If lookup is successful and result shows packet is to be forwarded,the neighbor tables are searched for the nexthop.  If successful (ie., FIB lookup shows forwarding and nexthop is  resolved),  thenexthop  address  is returned in ipv4_dst or ipv6_dst based on family, smac is set to mac address of egress device, dmac is set tonexthop mac address, rt_metric is set to metric from route (IPv4/IPv6 only), and ifindex is set to the device index of the nexthopfrom the FIB lookup.plen argument is the size of the passed in struct.  flags argument can be a combination of one or more of the following values:BPF_FIB_LOOKUP_DIRECTDo a direct table lookup vs full lookup using FIB rules.BPF_FIB_LOOKUP_OUTPUTPerform lookup from an egress perspective (default is ingress).ctx is either struct xdp_md for XDP programs or struct sk_buff tc cls_act programs.
 
 
bpf_sock_hash_updateXXAdd  an entry to, or update a sockhash map referencing sockets.  The skops is used as a new value for the entry associated to key.flags is one of:BPF_NOEXISTThe entry for key must not exist in the map.BPF_EXISTThe entry for key must already exist in the map.BPF_ANYNo condition on the existence of the entry for key.If the map has eBPF programs (parser and verdict), those will be inherited by the socket being added. If the socket is already at‐tached to eBPF programs, this results in an error.
 
 
bpf_msg_redirect_hashXXThis helper is used in programs implementing policies at the socket level. If the message msg is allowed to pass (i.e. if the ver‐dict eBPF program returns SK_PASS), redirect it to the socket referenced by map (of type BPF_MAP_TYPE_SOCKHASH)  using  hash  key.Both  ingress  and egress interfaces can be used for redirection. The BPF_F_INGRESS value in flags is used to make the distinction(ingress path is selected if the flag is present, egress path otherwise). This is the only flag supported for now.
 
 
bpf_sk_redirect_hashXXThis helper is used in programs implementing policies at the skb socket level. If the sk_buff skb is allowed to pass (i.e.  if theverdeict  eBPF  program  returns  SK_PASS), redirect it to the socket referenced by map (of type BPF_MAP_TYPE_SOCKHASH) using hashkey. Both ingress and egress interfaces can be used for redirection. The BPF_F_INGRESS value in flags is used to make the distinc‐tion (ingress path is selected if the flag is present, egress otherwise). This is the only flag supported for now.
 
 
bpf_lwt_push_encapXXEncapsulate  the  packet associated to skb within a Layer 3 protocol header. This header is provided in the buffer at address hdr,with len its size in bytes. type indicates the protocol of the header and can be one of:BPF_LWT_ENCAP_SEG6IPv6 encapsulation with Segment Routing Header (struct ipv6_sr_hdr). hdr only contains the SRH, the IPv6 header is computedby the kernel.BPF_LWT_ENCAP_SEG6_INLINEOnly works if skb contains an IPv6 packet. Insert a Segment Routing Header (struct ipv6_sr_hdr) inside the IPv6 header.BPF_LWT_ENCAP_IPIP encapsulation (GRE/GUE/IPIP/etc). The outer header must be IPv4 or IPv6, followed by zero or more additional headers, upto LWT_BPF_MAX_HEADROOM total bytes in all prepended headers. Please note that if skb_is_gso(skb) is true, no more than twoheaders can be prepended, and the inner header, if present, should be either GRE or UDP/GUE.BPF_LWT_ENCAP_SEG6*  types  can be called by BPF programs of type BPF_PROG_TYPE_LWT_IN; BPF_LWT_ENCAP_IP type can be called by bpfprograms of types BPF_PROG_TYPE_LWT_IN and BPF_PROG_TYPE_LWT_XMIT.A call to this helper is susceptible to change the underlying packet buffer. Therefore, at load time, all checks on pointers  pre‐viously  done by the verifier are invalidated and must be performed again, if the helper is used in combination with direct packetaccess.
 
 
bpf_lwt_seg6_store_bytesXXStore len bytes from address from into the packet associated to skb, at offset. Only the flags, tag and TLVs inside the  outermostIPv6 Segment Routing Header can be modified through this helper.A  call to this helper is susceptible to change the underlying packet buffer. Therefore, at load time, all checks on pointers pre‐viously done by the verifier are invalidated and must be performed again, if the helper is used in combination with direct  packetaccess.
 
 
bpf_lwt_seg6_adjust_srhXXAdjust the size allocated to TLVs in the outermost IPv6 Segment Routing Header contained in the packet associated to skb, at posi‐tion offset by delta bytes. Only offsets after the segments are accepted. delta can be as  well  positive  (growing)  as  negative(shrinking).A  call to this helper is susceptible to change the underlying packet buffer. Therefore, at load time, all checks on pointers pre‐viously done by the verifier are invalidated and must be performed again, if the helper is used in combination with direct  packetaccess.
 
 
bpf_lwt_seg6_actionXXApply  an  IPv6  Segment Routing action of type action to the packet associated to skb. Each action takes a parameter contained ataddress param, and of length param_len bytes.  action can be one of:SEG6_LOCAL_ACTION_END_XEnd.X action: Endpoint with Layer-3 cross-connect.  Type of param: struct in6_addr.SEG6_LOCAL_ACTION_END_TEnd.T action: Endpoint with specific IPv6 table lookup.  Type of param: int.SEG6_LOCAL_ACTION_END_B6End.B6 action: Endpoint bound to an SRv6 policy.  Type of param: struct ipv6_sr_hdr.SEG6_LOCAL_ACTION_END_B6_ENCAPEnd.B6.Encap action: Endpoint bound to an SRv6 encapsulation policy.  Type of param: struct ipv6_sr_hdr.A call to this helper is susceptible to change the underlying packet buffer. Therefore, at load time, all checks on pointers  pre‐viously  done by the verifier are invalidated and must be performed again, if the helper is used in combination with direct packetaccess.
 
 
bpf_rc_repeatXXThis helper is used in programs implementing IR decoding, to report a successfully decoded repeat key  message.  This  delays  thegeneration of a key up event for previously generated key down event.Some IR protocols like NEC have a special IR message for repeating last button, for when a button is held down.The ctx should point to the lirc sample as passed into the program.This helper is only available is the kernel was compiled with the CONFIG_BPF_LIRC_MODE2 configuration option set to "y".
 
 
bpf_rc_keydownXXThis  helper  is used in programs implementing IR decoding, to report a successfully decoded key press with scancode, toggle valuein the given protocol. The scancode will be translated to a keycode using the rc keymap, and reported as an input key down  event.After  a  period  a  key up event is generated. This period can be extended by calling either bpf_rc_keydown() again with the samevalues, or calling bpf_rc_repeat().Some protocols include a toggle bit, in case the button was released and pressed again between consecutive scancodes.The ctx should point to the lirc sample as passed into the program.The protocol is the decoded protocol number (see enum rc_proto for some predefined values).This helper is only available is the kernel was compiled with the CONFIG_BPF_LIRC_MODE2 configuration option set to "y".
 
 
bpf_skb_cgroup_idXXReturn the cgroup v2 id of the socket associated with the skb.  This is roughly similar to the bpf_get_cgroup_classid() helper for cgroup  v1 by providing a tag resp. identifier that can be matched on or used for map lookups e.g. to implement policy. The cgroup v2 id of a given path in the hierarchy is exposed in user space through the f_handle API in order to get to the same 64-bit id.This helper can be used on TC egress path, but not on ingress, and is available only if the kernel  was  compiled  with  the  CON‐FIG_SOCK_CGROUP_DATA configuration option.
 
 
*bpf_get_local_storageXXGet  the pointer to the local storage area.  The type and the size of the local storage is defined by the map argument.  The flagsmeaning is specific for each map type, and has to be 0 for cgroup local storage.Depending on the BPF program type, a local storage area can be shared between multiple instances of the BPF program,  running  si‐multaneously.A  user  should care about the synchronization by himself.  For example, by using the BPF_STX_XADD instruction to alter the shareddata.
 
 
bpf_sk_select_reuseportXXSelect a SO_REUSEPORT socket from a BPF_MAP_TYPE_REUSEPORT_ARRAY map.  It checks the selected socket is matching the incoming  re‐quest in the socket buffer.
 
 
bpf_skb_ancestor_cgroup_idXXReturn  id  of  cgroup  v2 that is ancestor of cgroup associated with the skb at the ancestor_level.  The root cgroup is at ancestor_level zero and each step down the hierarchy increments the level. If ancestor_level == level of cgroup  associated  with  skb,then return value will be same as that of bpf_skb_cgroup_id().The helper is useful to implement policies based on cgroups that are upper in hierarchy than immediate cgroup associated with skb.The format of returned id and helper limitations are same as in bpf_skb_cgroup_id().
 
 
*bpf_sk_lookup_tcpXXLook  for  TCP  socket  matching  tuple,  optionally  in a child network namespace netns. The return value must be checked, and ifnon-NULL, released via bpf_sk_release().The ctx should point to the context of the program, such as the skb or socket (depending on the hook in use). This is used to  de‐termine the base network namespace for the lookup.tuple_size must be one of:sizeof(tuple->ipv4)Look for an IPv4 socket.sizeof(tuple->ipv6)Look for an IPv6 socket.If  the  netns is a negative signed 32-bit integer, then the socket lookup table in the netns associated with the ctx will will beused. For the TC hooks, this is the netns of the device in the skb. For socket hooks, this is the netns of the socket.   If  netnsis any other signed 32-bit value greater than or equal to zero then it specifies the ID of the netns relative to the netns associ‐ated with the ctx. netns values beyond the range of 32-bit integers are reserved for future use.All values for flags are reserved for future usage, and must be left at zero.This helper is available only if the kernel was compiled with CONFIG_NET configuration option.
 
 
*bpf_sk_lookup_udpXXLook  for  UDP  socket  matching  tuple,  optionally  in a child network namespace netns. The return value must be checked, and ifnon-NULL, released via bpf_sk_release().The ctx should point to the context of the program, such as the skb or socket (depending on the hook in use). This is used to  de‐termine the base network namespace for the lookup.tuple_size must be one of:sizeof(tuple->ipv4)Look for an IPv4 socket.sizeof(tuple->ipv6)Look for an IPv6 socket.If  the  netns is a negative signed 32-bit integer, then the socket lookup table in the netns associated with the ctx will will beused. For the TC hooks, this is the netns of the device in the skb. For socket hooks, this is the netns of the socket.   If  netnsis any other signed 32-bit value greater than or equal to zero then it specifies the ID of the netns relative to the netns associ‐ated with the ctx. netns values beyond the range of 32-bit integers are reserved for future use.All values for flags are reserved for future usage, and must be left at zero.This helper is available only if the kernel was compiled with CONFIG_NET configuration option.
 
 
bpf_sk_releaseXXRelease the reference held by sock. sock must be a non-NULL pointer that was returned from bpf_sk_lookup_xxx().
 
 
bpf_map_push_elemXXPush an element value in map. flags is one of:BPF_EXISTIf the queue/stack is full, the oldest element is removed to make room for this.
 
 
bpf_map_pop_elemXXPop an element from map.
 
 
bpf_map_peek_elemXXGet an element from map without removing it.
 
 
bpf_msg_push_dataXXFor socket policies, insert len bytes into msg at offset start.If  a program of type BPF_PROG_TYPE_SK_MSG is run on a msg it may want to insert metadata or options into the msg.  This can laterbe read and used by any of the lower layer BPF hooks.This helper may fail if under memory pressure (a malloc fails) in these cases BPF programs will get an appropriate error  and  BPFprograms will need to handle them.
 
 
bpf_msg_pop_dataXXWill  remove pop bytes from a msg starting at byte start.  This may result in ENOMEM errors under certain situations if an alloca‐tion and copy are required due to a full ring buffer.  However, the helper will try to avoid doing  the  allocation  if  possible.Other  errors  can  occur  if input parameters are invalid either due to start byte not being valid part of msg payload and/or popvalue being to large.
 
 
bpf_rc_pointer_relXXThis helper is used in programs implementing IR decoding, to report a successfully decoded pointer movement.The ctx should point to the lirc sample as passed into the program.This helper is only available is the kernel was compiled with the CONFIG_BPF_LIRC_MODE2 configuration option set to "y".
 
 
bpf_spin_lockXXAcquire a spinlock represented by the pointer lock, which is stored as part of a value of a map. Taking the lock allows to  safelyupdate the rest of the fields in that value. The spinlock can (and must) later be released with a call to bpf_spin_unlock(lock).Spinlocks in BPF programs come with a number of restrictions and constraints:• bpf_spin_lock  objects  are  only  allowed inside maps of types BPF_MAP_TYPE_HASH and BPF_MAP_TYPE_ARRAY (this list could be ex‐tended in the future).• BTF description of the map is mandatory.• The BPF program can take ONE lock at a time, since taking two or more could cause dead locks.• Only one struct bpf_spin_lock is allowed per map element.• When the lock is taken, calls (either BPF to BPF or helpers) are not allowed.• The BPF_LD_ABS and BPF_LD_IND instructions are not allowed inside a spinlock-ed region.• The BPF program MUST call bpf_spin_unlock() to release the lock, on all execution paths, before it returns.• The BPF program can access struct bpf_spin_lock only via the bpf_spin_lock() and bpf_spin_unlock() helpers. Loading  or  storingdata into the struct bpf_spin_lock lock; field of a map is not allowed.• To  use the bpf_spin_lock() helper, the BTF description of the map value must be a struct and have struct bpf_spin_lock anyname;field at the top level.  Nested lock inside another struct is not allowed.• The struct bpf_spin_lock lock field in a map value must be aligned on a multiple of 4 bytes in that value.• Syscall with command BPF_MAP_LOOKUP_ELEM does not copy the bpf_spin_lock field to user space.• Syscall with command BPF_MAP_UPDATE_ELEM, or update from a BPF program, do not update the bpf_spin_lock field.• bpf_spin_lock cannot be on the stack or inside a networking packet (it can only be inside of a map values).• bpf_spin_lock is available to root only.• Tracing programs and socket filter programs cannot use bpf_spin_lock() due to  insufficient  preemption  checks  (but  this  maychange in the future).• bpf_spin_lock is not allowed in inner maps of map-in-map.
 
 
bpf_spin_unlockXXRelease the lock previously locked by a call to bpf_spin_lock(lock).
 
 
*bpf_sk_fullsockXXThis helper gets a struct bpf_sock pointer such that all the fields in this bpf_sock can be accessed.
 
 
*bpf_tcp_sockXXThis helper gets a struct bpf_tcp_sock pointer from a struct bpf_sock pointer.
 
 
bpf_skb_ecn_set_ceXXSet  ECN (Explicit Congestion Notification) field of IP header to CE (Congestion Encountered) if current value is ECT (ECN CapableTransport). Otherwise, do nothing. Works with IPv6 and IPv4.
 
 
*bpf_get_listener_sockXXRaturn a struct bpf_sock pointer in TCP_LISTEN state.  bpf_sk_release() is unnecessary and not allowed.
 
 
*bpf_skc_lookup_tcpXXLook for TCP socket matching tuple, optionally in a child network namespace netns. The  return  value  must  be  checked,  and  ifnon-NULL, released via bpf_sk_release().This  function is identical to bpf_sk_lookup_tcp(), except that it also returns timewait or request sockets. Use bpf_sk_fullsock()or bpf_tcp_sock() to access the full structure.This helper is available only if the kernel was compiled with CONFIG_NET configuration option.
 
 
bpf_tcp_check_syncookieXXCheck whether iph and th contain a valid SYN cookie ACK for the listening socket in sk.iph points to the start of the IPv4 or IPv6 header, while iph_len contains sizeof(struct iphdr) or sizeof(struct ip6hdr).th points to the start of the TCP header, while th_len contains sizeof(struct tcphdr).
 
 
bpf_sysctl_get_nameXXGet name of sysctl in /proc/sys/ and copy it into provided by program buffer buf of size buf_len.The buffer is always NUL terminated, unless it's zero-sized.If  flags  is  zero,  full  name (e.g. "net/ipv4/tcp_mem") is copied. Use BPF_F_SYSCTL_BASE_NAME flag to copy base name only (e.g."tcp_mem").
 
 
bpf_sysctl_get_current_valueXXGet current value of sysctl as it is presented in /proc/sys (incl. newline, etc), and copy it as a string into provided by programbuffer buf of size buf_len.The whole value is copied, no matter what file position user space issued e.g. sys_read at.The buffer is always NUL terminated, unless it's zero-sized.
 
 
bpf_sysctl_get_new_valueXXGet  new  value  being  written by user space to sysctl (before the actual write happens) and copy it as a string into provided byprogram buffer buf of size buf_len.User space may write new value at file position > 0.The buffer is always NUL terminated, unless it's zero-sized.
 
 
bpf_sysctl_set_new_valueXXOverride new value being written by user space to sysctl with value provided by program in buffer buf of size buf_len.buf should contain a string in same form as provided by user space on sysctl write.User space may write new value at file position > 0. To override the whole sysctl value file position should be set to zero.
 
 
bpf_strtolXXConvert the initial part of the string from buffer buf of size buf_len to a long integer according to the given base and save  theresult in res.The string may begin with an arbitrary amount of white space (as determined by isspace(3)) followed by a single optional '-' sign.Five least significant bits of flags encode base, other bits are currently unused.Base must be either 8, 10, 16 or 0 to detect it automatically similar to user space strtol(3).
 
 
bpf_strtoulXXConvert the initial part of the string from buffer buf of size buf_len to an unsigned long integer according to the given base andsave the result in res.The string may begin with an arbitrary amount of white space (as determined by isspace(3)).Five least significant bits of flags encode base, other bits are currently unused.Base must be either 8, 10, 16 or 0 to detect it automatically similar to user space strtoul(3).
 
 
*bpf_sk_storage_getXXGet a bpf-local-storage from a sk.Logically, it could be thought of getting the value from a map with sk as the key.  From this perspective,  the usage is not  muchdifferent  from  bpf_map_lookup_elem(map,  &sk)  except  this  helper enforces the key must be a full socket and the map must be aBPF_MAP_TYPE_SK_STORAGE also.Underneath, the value is stored locally at sk instead of the map.  The map is used as the bpf-local-storage  "type".  The  bpf-lo‐cal-storage "type" (i.e. the map) is searched against all bpf-local-storages residing at sk.An  optional flags (BPF_SK_STORAGE_GET_F_CREATE) can be used such that a new bpf-local-storage will be created if one does not ex‐ist.  value can be used together with BPF_SK_STORAGE_GET_F_CREATE to specify the initial value of a bpf-local-storage.   If  valueis NULL, the new bpf-local-storage will be zero initialized.
 
 
bpf_sk_storage_deleteXXDelete a bpf-local-storage from a sk.
 
 
bpf_send_signalXXSend signal sig to the current task.
 
 
bpf_tcp_gen_syncookieXXTry to issue a SYN cookie for the packet with corresponding IP/TCP headers, iph and th, on the listening socket in sk.iph points to the start of the IPv4 or IPv6 header, while iph_len contains sizeof(struct iphdr) or sizeof(struct ip6hdr).th points to the start of the TCP header, while th_len contains the length of the TCP header.
 
 
