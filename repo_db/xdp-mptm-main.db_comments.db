{"_default": {"1": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "libbpf", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}, {"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_PASS", "Return": 2, "Description": "The XDP_PASS return code means that the packet is allowed to be passed up to the kernel\u2019s networking stack. Meaning, the current CPU that was processing this packet now allocates a skb, populates it, and passes it onwards into the GRO engine. This would be equivalent to the default packet handling behavior without XDP.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 52, "endLine": 99, "File": "/home/palani/github/opened_extraction/examples/xdp-mptm-main/src/kernel/mptm.c", "funcName": "mptm_encap", "developer_inline_comments": [{"start_line": 1, "end_line": 7, "text": "/* SPDX-License-Identifier: GPL-2.0 \n *  \n * Authors:\n * Dushyant Behl <dushyantbehl@in.ibm.com>\n * Sayandeep Sen <sayandes@in.ibm.com>\n * Palanivel Kodeswaran <palani.kodeswaran@in.ibm.com>\n */"}, {"start_line": 23, "end_line": 23, "text": "/* Defines xdp_stats_map */"}, {"start_line": 27, "end_line": 30, "text": "/* Inspired from Katran.\n * ETH_P_IP and ETH_P_IPV6 in Big Endian format.\n * So we don't have to do htons on each packet\n */"}, {"start_line": 53, "end_line": 53, "text": "//default action"}, {"start_line": 55, "end_line": 55, "text": "/* header pointers */"}, {"start_line": 59, "end_line": 59, "text": "/* map values and tunnel informations */"}, {"start_line": 93, "end_line": 93, "text": "// keep redirect flags zero for now"}], "updateMaps": [], "readMaps": ["  mptm_tnl_info_map"], "input": ["struct xdp_md *ctx"], "output": "int", "helper": ["bpf_map_lookup_elem", "bpf_redirect", "bpf_redirect_map", "XDP_PASS"], "compatibleHookpoints": ["xdp"], "source": ["int mptm_encap (struct xdp_md *ctx)\n", "{\n", "    int action = XDP_PASS;\n", "    struct ethhdr *eth;\n", "    struct iphdr *ip;\n", "    struct tunnel_info *tn;\n", "    tunnel_map_key_t key;\n", "    __u8 tun_type;\n", "    void *data = (void *) ((long) ctx->data);\n", "    void *data_end = (void *) ((long) ctx->data_end);\n", "    if (parse_pkt_headers (data, data_end, &eth, &ip, NULL) != 0) {\n", "        goto out;\n", "    }\n", "    key.s_addr = ip->saddr;\n", "    key.d_addr = ip->daddr;\n", "    tn = bpf_map_lookup_elem (& mptm_tnl_info_map, & key);\n", "    if (tn == NULL) {\n", "        mptm_print (\"[ERR] map entry missing for key-{saddr:%x,daddr:%x}\\n\", key.s_addr, key.d_addr);\n", "        goto out;\n", "    }\n", "    tun_type = tn->tunnel_type;\n", "    if (tun_type == VLAN) {\n", "        action = encap_vlan (ctx, eth, tn);\n", "    }\n", "    else if (tun_type == GENEVE) {\n", "        action = encap_geneve (ctx, eth, tn);\n", "    }\n", "    else {\n", "        bpf_debug (\"[ERR] tunnel type is unknown\");\n", "        goto out;\n", "    }\n", "    if (likely (tn->redirect)) {\n", "        __u64 flags = 0;\n", "        action = bpf_redirect_map (& mptm_tnl_redirect_devmap, tn -> veth_iface, flags);\n", "    }\n", "out :\n", "    return xdp_stats_record_action (ctx, action);\n", "}\n"], "called_function_list": ["encap_geneve", "encap_vlan", "parse_pkt_headers"], "call_depth": 4, "humanFuncDescription": [[{"description": "This function performs the encapsulation of specific tunnel on an outgoing packet. It parse the packet eth and ip header using the parse_pkt_headers helper function. It then performs a map lookup into mptm_tnl_info_map with key which is a struct containing the ip source and dst addr of the packet. The map lookup returns a tunnel_info object *tn, which is used further to encapsulate differnet tunnel based on the rule programmed in the tunnel_info object retrieved from the map. This function will then call appropriate helper function encap_<tunnel> to encapsulate appropriate tunnel on the packet and finally redirects the packet to an outbound interface which is pre programmed in a devmap with the key taken as tn->veth_iface object and flags as none. It will return XDP_REDIRECT on successful encapsulation or XDP_PASS/XDP_ABORTED based on the return value of helper functions used.", "author": "Dushyant Behl", "authorEmail": "dushyantbehl@in.ibm.com", "date": "2023-02-20"}, {}]], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "2": {"capabilities": [{"capability": "update_pkt", "update_pkt": [{"Project": "libbpf", "Return Type": "int", "Description": "Adjust (move) xdp_md->data by <[ delta ]>(IP: 1) bytes. Note that it is possible to use a negative value for delta. This helper can be used to prepare the packet for pushing or popping headers. A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_xdp_adjust_head", "Input Params": ["{Type: struct xdp_buff ,Var: *xdp_md}", "{Type:  int ,Var: delta}"], "compatible_hookpoints": ["xdp"], "capabilities": ["update_pkt"]}]}, {"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_PASS", "Return": 2, "Description": "The XDP_PASS return code means that the packet is allowed to be passed up to the kernel\u2019s networking stack. Meaning, the current CPU that was processing this packet now allocates a skb, populates it, and passes it onwards into the GRO engine. This would be equivalent to the default packet handling behavior without XDP.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_go_to_next_module"]}]}, {"capability": "map_read", "map_read": [{"Project": "libbpf", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}, {"capability": "pkt_stop_processing_drop_packet", "pkt_stop_processing_drop_packet": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_DROP", "Return": 1, "Description": "will drop the packet right at the driver level without wasting any further resources. This is in particular useful for BPF programs implementing DDoS mitigation mechanisms or firewalling in general.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_stop_processing_drop_packet"]}]}], "helperCallParams": {}, "startLine": 102, "endLine": 167, "File": "/home/palani/github/opened_extraction/examples/xdp-mptm-main/src/kernel/mptm.c", "funcName": "mptm_decap", "developer_inline_comments": [{"start_line": 103, "end_line": 103, "text": "//default action"}, {"start_line": 105, "end_line": 105, "text": "/* header pointers */"}, {"start_line": 116, "end_line": 116, "text": "// GENEVE packet"}, {"start_line": 117, "end_line": 117, "text": "// Check inner packet if there is a rule corresponding to"}, {"start_line": 118, "end_line": 118, "text": "// inner source which will be source for us as we received the packet"}, {"start_line": 129, "end_line": 129, "text": "/* recalculate the data pointers */"}, {"start_line": 133, "end_line": 133, "text": "/* header pointers */"}, {"start_line": 140, "end_line": 140, "text": "/* map values and tunnel informations */"}, {"start_line": 144, "end_line": 144, "text": "// keep redirect flags zero for now"}, {"start_line": 146, "end_line": 146, "text": "/* Packet is coming from outside so source and dest must be inversed */"}], "updateMaps": [], "readMaps": ["  mptm_tnl_info_map"], "input": ["struct xdp_md *ctx"], "output": "int", "helper": ["bpf_redirect", "bpf_xdp_adjust_head", "bpf_redirect_map", "XDP_PASS", "bpf_map_lookup_elem", "XDP_DROP"], "compatibleHookpoints": ["xdp"], "source": ["int mptm_decap (struct xdp_md *ctx)\n", "{\n", "    int action = XDP_PASS;\n", "    struct ethhdr *eth;\n", "    struct iphdr *ip;\n", "    struct udphdr *udp;\n", "    void *data = (void *) ((long) ctx->data);\n", "    void *data_end = (void *) ((long) ctx->data_end);\n", "    if (parse_pkt_headers (data, data_end, &eth, &ip, &udp) != 0)\n", "        goto out;\n", "    if (udp->dest == BE_GENEVE_DSTPORT) {\n", "        int outer_hdr_size = sizeof (struct genevehdr) + sizeof (struct udphdr) + sizeof (struct iphdr) + sizeof (struct ethhdr);\n", "        long ret = bpf_xdp_adjust_head (ctx, outer_hdr_size);\n", "        if (ret != 0l) {\n", "            mptm_print (\"[Agent:] DROP (BUG): Failure adjusting packet header!\\n\");\n", "            return XDP_DROP;\n", "        }\n", "        data = (void *) (long) ctx->data;\n", "        data_end = (void *) (long) ctx->data_end;\n", "        struct ethhdr *inner_eth;\n", "        struct iphdr *inner_ip;\n", "        if (parse_pkt_headers (data, data_end, &inner_eth, &inner_ip, NULL) != 0)\n", "            goto out;\n", "        tunnel_map_key_t key;\n", "        struct tunnel_info *tn;\n", "        __u8 tun_type;\n", "        __u64 flags = 0;\n", "        key.s_addr = inner_ip->daddr;\n", "        key.d_addr = inner_ip->saddr;\n", "        tn = bpf_map_lookup_elem (& mptm_tnl_info_map, & key);\n", "        if (tn == NULL) {\n", "            mptm_print (\"[ERR] map entry missing for key {saddr:%x,daddr:%x}\\n\", key.s_addr, key.d_addr);\n", "            goto out;\n", "        }\n", "        tun_type = tn->tunnel_type;\n", "        if (unlikely (tun_type != GENEVE)) {\n", "            mptm_print (\"Packet is changed but did not belong to us!\");\n", "            return XDP_DROP;\n", "        }\n", "        action = bpf_redirect_map (& mptm_tnl_redirect_devmap, tn -> eth0_iface, flags);\n", "    }\n", "out :\n", "    return xdp_stats_record_action (ctx, action);\n", "}\n"], "called_function_list": ["parse_pkt_headers"], "call_depth": 1, "humanFuncDescription": [[{"description": "This function performs the decapsulation of specific tunnel on an incoming packet. It parse the packet eth, ip and udp header using the parse_pkt_headers helper function. If the packet is a UDP packet and if the UDP dest port is 0xc117 the geneve tunnel destination port, then it will remove the geneve header from the packet,by reducing its data size by sizeof(struct genevehdr+ struct udphdr + struct iphdr + struct ethhdr) by calling bpf_xdp_adjust_head. After that it recalculates the packet headers using parse_pkt_headers and does a sanity check on if Geneve tunnel is what was intended for this packet. Finally the packet is redirected to appropriate interface using mptm_tnl_redirect_devmap", "author": "Dushyant Behl", "authorEmail": "dushyantbehl@in.ibm.com", "date": "2023-02-20"}, {}]], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "3": {"capabilities": [], "helperCallParams": {}, "startLine": 24, "endLine": 29, "File": "/home/palani/github/opened_extraction/examples/xdp-mptm-main/src/kernel/mptm_extras.c", "funcName": "mptm_redirect", "developer_inline_comments": [{"start_line": 1, "end_line": 7, "text": "/* SPDX-License-Identifier: GPL-2.0\n *  \n * Authors:\n * Dushyant Behl <dushyantbehl@in.ibm.com>\n * Sayandeep Sen <sayandes@in.ibm.com>\n * Palanivel Kodeswaran <palani.kodeswaran@in.ibm.com>\n */"}], "updateMaps": [], "readMaps": [], "input": ["struct xdp_md *ctx"], "output": "int", "helper": ["bpf_redirect", "bpf_redirect_map"], "compatibleHookpoints": ["xdp"], "source": ["int mptm_redirect (struct xdp_md *ctx)\n", "{\n", "    __u64 flags = 0;\n", "    __u32 key = ctx->ingress_ifindex;\n", "    return bpf_redirect_map (&mptm_extras_redirect_devmap, key, flags);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [[{"description": "This function takes in a packet represented by struct xdp_md context and redirects it to another interface via a BPF_REDIRECT_DEVMAP with key which is the packet's ingress interface and flags as zero.", "author": "Dushyant Behl", "authorEmail": "dushyantbehl@in.ibm.com", "date": "2023-02-20"}, {}]], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "4": {"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_PASS", "Return": 2, "Description": "The XDP_PASS return code means that the packet is allowed to be passed up to the kernel\u2019s networking stack. Meaning, the current CPU that was processing this packet now allocates a skb, populates it, and passes it onwards into the GRO engine. This would be equivalent to the default packet handling behavior without XDP.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 32, "endLine": 34, "File": "/home/palani/github/opened_extraction/examples/xdp-mptm-main/src/kernel/mptm_extras.c", "funcName": "mptm_pass", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct xdp_md *ctx"], "output": "int", "helper": ["XDP_PASS"], "compatibleHookpoints": ["xdp"], "source": ["int mptm_pass (struct xdp_md *ctx)\n", "{\n", "    return XDP_PASS;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [[{"description": "This function just returns XDP_PASS for any packet that is passed to it as struct xdp_mp context", "author": "Dushyant Behl", "authorEmail": "dushyantbehl@in.ibm.com", "date": "2023-02-20"}, {}]], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "5": {"capabilities": [], "helperCallParams": {}, "startLine": 41, "endLine": 97, "File": "/home/palani/github/opened_extraction/examples/xdp-mptm-main/src/kernel/lib/pkt-parse.h", "funcName": "parse_pkt_headers", "developer_inline_comments": [{"start_line": 1, "end_line": 7, "text": "/* SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-2-clause)\n *\n * Authors:\n * Dushyant Behl <dushyantbehl@in.ibm.com>\n * Sayandeep Sen <sayandes@in.ibm.com>\n * Palanivel Kodeswaran <palani.kodeswaran@in.ibm.com>\n*/"}, {"start_line": 28, "end_line": 31, "text": "/* Inspired from Katran.\n * ETH_P_IP and ETH_P_IPV6 in Big Endian format.\n * So we don't have to do htons on each packet\n */"}, {"start_line": 38, "end_line": 40, "text": "/* Parse eth, ip and udp headers of a packet.\n * If any header is passed as NULL then stop processing and return.\n */"}, {"start_line": 60, "end_line": 60, "text": "// We don't support ipv6 for now."}, {"start_line": 63, "end_line": 63, "text": "/* set the header */"}, {"start_line": 74, "end_line": 74, "text": "/* set the header */"}, {"start_line": 81, "end_line": 81, "text": "/* Check the protocol. If TCP we return else for udp we process further */"}, {"start_line": 85, "end_line": 85, "text": "/* Parse udp header */"}, {"start_line": 90, "end_line": 90, "text": "/* set the header */"}], "updateMaps": [], "readMaps": [], "input": ["void *data", " void *data_end", " struct ethhdr **ethhdr", " struct iphdr **iphdr", " struct udphdr **udphdr"], "output": "static__ALWAYS_INLINE__int", "helper": [], "compatibleHookpoints": ["cgroup_sock_addr", "sk_skb", "kprobe", "lwt_out", "cgroup_device", "perf_event", "xdp", "sk_reuseport", "cgroup_sock", "tracepoint", "cgroup_sysctl", "cgroup_skb", "sched_cls", "lwt_in", "socket_filter", "lwt_xmit", "raw_tracepoint_writable", "sk_msg", "flow_dissector", "lwt_seg6local", "sched_act", "sock_ops", "raw_tracepoint"], "source": ["static __ALWAYS_INLINE__ int parse_pkt_headers (void *data, void *data_end, struct ethhdr **ethhdr, struct iphdr **iphdr, struct udphdr **udphdr)\n", "{\n", "    struct hdr_cursor nh;\n", "    int nh_type;\n", "    nh.pos = data;\n", "    if (ethhdr == NULL)\n", "        return 0;\n", "    struct ethhdr *eth;\n", "    nh_type = parse_ethhdr (& nh, data_end, & eth);\n", "    if (nh_type == -1)\n", "        goto out_fail;\n", "    if (eth->h_proto == BE_ETH_P_ARP)\n", "        goto out_fail;\n", "    if (eth->h_proto != BE_ETH_P_IP)\n", "        goto out_fail;\n", "    *ethhdr = eth;\n", "    if (iphdr == NULL)\n", "        return 0;\n", "    struct iphdr *ip;\n", "    nh_type = parse_iphdr (& nh, data_end, & ip);\n", "    if (nh_type == -1)\n", "        goto out_fail;\n", "    *iphdr = ip;\n", "    if (udphdr == NULL)\n", "        return 0;\n", "    struct udphdr *udp;\n", "    if (nh_type == IPPROTO_TCP)\n", "        goto out_fail;\n", "    nh_type = parse_udphdr (& nh, data_end, & udp);\n", "    if (nh_type == -1)\n", "        goto out_fail;\n", "    *udphdr = udp;\n", "    return 0;\n", "out_fail :\n", "    return 1;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [[{"description": "This function takes in 5 arguments, 1 and 2 correspond to the start and end pointer of a packet data. The next three arguments are pointer to pointers to return values of eth header, ip header and udp header back to the caller. It calls internal libaray functions parse_ethhdr to parse eth header, parse_iphdr function to parse ip header, parse_udphdr to parse udp header, it ignore TCP packets because TCP packets don't represent any tunnel as all tunnels are implemented via udp stream. It sets the appropriate value of the pointer arguments to eth, ip and udp header to return to the caller. For success the function returns 0 and failure it returns -1", "author": "Dushyant Behl", "authorEmail": "dushyantbehl@in.ibm.com", "date": "2023-02-20"}, {}]], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "6": {"capabilities": [], "helperCallParams": {}, "startLine": 38, "endLine": 46, "File": "/home/palani/github/opened_extraction/examples/xdp-mptm-main/src/kernel/lib/pkt-encap.h", "funcName": "set_dst_mac", "developer_inline_comments": [{"start_line": 1, "end_line": 7, "text": "/* SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-2-clause)\n *  \n * Authors:\n * Dushyant Behl <dushyantbehl@in.ibm.com>\n * Sayandeep Sen <sayandes@in.ibm.com>\n * Palanivel Kodeswaran <palani.kodeswaran@in.ibm.com>\n */"}, {"start_line": 14, "end_line": 17, "text": "/*\n * The functions are marked as __always_inline, and\n * fully defined in this header file to be included in the BPF program.\n */"}], "updateMaps": [], "readMaps": [], "input": ["void *data", " unsigned char *dst_mac"], "output": "static__ALWAYS_INLINE__void", "helper": [], "compatibleHookpoints": ["cgroup_sock_addr", "sk_skb", "kprobe", "lwt_out", "cgroup_device", "perf_event", "xdp", "sk_reuseport", "cgroup_sock", "tracepoint", "cgroup_sysctl", "cgroup_skb", "sched_cls", "lwt_in", "socket_filter", "lwt_xmit", "raw_tracepoint_writable", "sk_msg", "flow_dissector", "lwt_seg6local", "sched_act", "sock_ops", "raw_tracepoint"], "source": ["static __ALWAYS_INLINE__ void set_dst_mac (void *data, unsigned char *dst_mac)\n", "{\n", "    unsigned short *p = data;\n", "    unsigned short *dst = (unsigned short *) dst_mac;\n", "    p[0] = dst[0];\n", "    p[1] = dst[1];\n", "    p[2] = dst[2];\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [[{"description": "This function takes in two arguments 1) void *data 2) unsigned char *dst_mac and will set the mac represented by dst_mac array 0,1,2 to the pointer pointed by data at array offset 0,1,2", "author": "Dushyant Behl", "authorEmail": "dushyantbehl@in.ibm.com", "date": "2023-02-20"}, {}]], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "7": {"capabilities": [], "helperCallParams": {}, "startLine": 48, "endLine": 56, "File": "/home/palani/github/opened_extraction/examples/xdp-mptm-main/src/kernel/lib/pkt-encap.h", "funcName": "set_src_mac", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["void *data", " unsigned char *src_mac"], "output": "static__ALWAYS_INLINE__void", "helper": [], "compatibleHookpoints": ["cgroup_sock_addr", "sk_skb", "kprobe", "lwt_out", "cgroup_device", "perf_event", "xdp", "sk_reuseport", "cgroup_sock", "tracepoint", "cgroup_sysctl", "cgroup_skb", "sched_cls", "lwt_in", "socket_filter", "lwt_xmit", "raw_tracepoint_writable", "sk_msg", "flow_dissector", "lwt_seg6local", "sched_act", "sock_ops", "raw_tracepoint"], "source": ["static __ALWAYS_INLINE__ void set_src_mac (void *data, unsigned char *src_mac)\n", "{\n", "    unsigned short *p = data;\n", "    unsigned short *src = (unsigned short *) src_mac;\n", "    p[3] = src[0];\n", "    p[4] = src[1];\n", "    p[5] = src[2];\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [[{"description": "This function takes in two arguments 1) void *data 2) unsigned char *src_mac and will set the mac represented by src_mac array 0,1,2 to the pointer pointed by data at array offset [3,4,5]", "author": "Dushyant Behl", "authorEmail": "dushyantbehl@in.ibm.com", "date": "2023-02-20"}, {}]], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "8": {"capabilities": [], "helperCallParams": {}, "startLine": 58, "endLine": 67, "File": "/home/palani/github/opened_extraction/examples/xdp-mptm-main/src/kernel/lib/pkt-encap.h", "funcName": "csum_fold_helper", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["__u64 csum"], "output": "static__ALWAYS_INLINE____u16", "helper": [], "compatibleHookpoints": ["cgroup_sock_addr", "sk_skb", "kprobe", "lwt_out", "cgroup_device", "perf_event", "xdp", "sk_reuseport", "cgroup_sock", "tracepoint", "cgroup_sysctl", "cgroup_skb", "sched_cls", "lwt_in", "socket_filter", "lwt_xmit", "raw_tracepoint_writable", "sk_msg", "flow_dissector", "lwt_seg6local", "sched_act", "sock_ops", "raw_tracepoint"], "source": ["static __ALWAYS_INLINE__ __u16 csum_fold_helper (__u64 csum)\n", "{\n", "    int i;\n", "\n", "#pragma unroll\n", "    for (i = 0; i < 4; i++) {\n", "        if (csum >> 16)\n", "            csum = (csum & 0xffff) + (csum >> 16);\n", "    }\n", "    return ~csum;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [[{"description": "This function takes in a __u64 csum helps in recomputing ipv4 checksum, return folded checksum as __u16", "author": "Dushyant Behl", "authorEmail": "dushyantbehl@in.ibm.com", "date": "2023-02-20"}, {}]], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "9": {"capabilities": [], "helperCallParams": {}, "startLine": 69, "endLine": 77, "File": "/home/palani/github/opened_extraction/examples/xdp-mptm-main/src/kernel/lib/pkt-encap.h", "funcName": "ipv4_csum_inline", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["void *iph", " __u64 *csum"], "output": "static__ALWAYS_INLINE__void", "helper": [], "compatibleHookpoints": ["cgroup_sock_addr", "sk_skb", "kprobe", "lwt_out", "cgroup_device", "perf_event", "xdp", "sk_reuseport", "cgroup_sock", "tracepoint", "cgroup_sysctl", "cgroup_skb", "sched_cls", "lwt_in", "socket_filter", "lwt_xmit", "raw_tracepoint_writable", "sk_msg", "flow_dissector", "lwt_seg6local", "sched_act", "sock_ops", "raw_tracepoint"], "source": ["static __ALWAYS_INLINE__ void ipv4_csum_inline (void *iph, __u64 *csum)\n", "{\n", "    __u16 *next_iph_u16 = (__u16 *) iph;\n", "\n", "#pragma clang loop unroll(full)\n", "    for (int i = 0; i < sizeof (struct iphdr) >> 1; i++) {\n", "        *csum += *next_iph_u16++;\n", "    }\n", "    *csum = csum_fold_helper (*csum);\n", "}\n"], "called_function_list": ["csum_fold_helper"], "call_depth": 1, "humanFuncDescription": [[{"description": "This function takes in an ip header void *iph and a checksum __u64 *csum, recomputes ipv4 checksum and stores the result back in *csum argument, does not return anything.", "author": "Dushyant Behl", "authorEmail": "dushyantbehl@in.ibm.com", "date": "2023-02-20"}, {}]], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "10": {"capabilities": [{"capability": "pkt_stop_processing_drop_packet", "pkt_stop_processing_drop_packet": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_DROP", "Return": 1, "Description": "will drop the packet right at the driver level without wasting any further resources. This is in particular useful for BPF programs implementing DDoS mitigation mechanisms or firewalling in general.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_stop_processing_drop_packet"]}, {"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_ABORTED", "Return": 0, "Description": "which serves denoting an exception like state from the program and has the same behavior as XDP_DROP only that XDP_ABORTED passes the trace_xdp_exception tracepoint which can be additionally monitored to detect misbehavior.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_stop_processing_drop_packet"]}]}, {"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_PASS", "Return": 2, "Description": "The XDP_PASS return code means that the packet is allowed to be passed up to the kernel\u2019s networking stack. Meaning, the current CPU that was processing this packet now allocates a skb, populates it, and passes it onwards into the GRO engine. This would be equivalent to the default packet handling behavior without XDP.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_go_to_next_module"]}]}, {"capability": "update_pkt", "update_pkt": [{"Project": "libbpf", "Return Type": "int", "Description": "Adjust (move) xdp_md->data by <[ delta ]>(IP: 1) bytes. Note that it is possible to use a negative value for delta. This helper can be used to prepare the packet for pushing or popping headers. A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_xdp_adjust_head", "Input Params": ["{Type: struct xdp_buff ,Var: *xdp_md}", "{Type:  int ,Var: delta}"], "compatible_hookpoints": ["xdp"], "capabilities": ["update_pkt"]}]}], "helperCallParams": {}, "startLine": 82, "endLine": 192, "File": "/home/palani/github/opened_extraction/examples/xdp-mptm-main/src/kernel/lib/pkt-encap.h", "funcName": "__encap_geneve", "developer_inline_comments": [{"start_line": 79, "end_line": 81, "text": "/* Pushes a new GENEVE header after the Ethernet header.\n *  Returns 0 on success, -1 on failure.\n */"}, {"start_line": 101, "end_line": 101, "text": "//TODO: Read from arp map table"}, {"start_line": 139, "end_line": 139, "text": "//TODO: Attach options"}, {"start_line": 140, "end_line": 140, "text": "//pkt->rts_opt = (void *)&pkt->geneve->options[0];"}, {"start_line": 142, "end_line": 142, "text": "// Populate the outer header fields "}, {"start_line": 166, "end_line": 166, "text": "//TODO: Put right checksum."}, {"start_line": 167, "end_line": 167, "text": "//For now make check 0"}, {"start_line": 169, "end_line": 169, "text": "// TODO: a hash value based on inner IP packet"}, {"start_line": 175, "end_line": 175, "text": "//TODO: Need to support geneve options"}, {"start_line": 176, "end_line": 176, "text": "//geneve->opt_len = gnv_opt_size / 4;"}, {"start_line": 185, "end_line": 185, "text": "//TODO: make vni paramater"}, {"start_line": 186, "end_line": 186, "text": "//trn_tunnel_id_to_vni(tn->vlid, pkt->geneve->vni);"}], "updateMaps": [], "readMaps": [], "input": ["struct xdp_md *ctx", " struct ethhdr *eth", " geneve_tunnel_info *tn"], "output": "static__ALWAYS_INLINE__int", "helper": ["XDP_DROP", "XDP_ABORTED", "XDP_PASS", "bpf_xdp_adjust_head"], "compatibleHookpoints": ["xdp"], "source": ["static __ALWAYS_INLINE__ int __encap_geneve (struct xdp_md *ctx, struct ethhdr *eth, geneve_tunnel_info *tn)\n", "{\n", "    int gnv_hdr_size = sizeof (struct genevehdr);\n", "    int udp_hdr_size = sizeof (struct udphdr);\n", "    int ip_hdr_size = sizeof (struct iphdr);\n", "    int eth_hdr_size = sizeof (struct ethhdr);\n", "    void *data = (void *) (long) ctx->data;\n", "    void *data_end = (void *) (long) ctx->data_end;\n", "    int old_size = (int) (data_end - data);\n", "    struct ethhdr *eth_inner_hdr = (struct ethhdr *) data;\n", "    if (eth_inner_hdr + 1 > data_end) {\n", "        mptm_print (\"[Agent: ] ABORTED: Bad ETH header offset \\n\");\n", "        return XDP_ABORTED;\n", "    }\n", "    set_dst_mac (data, tn->inner_dest_mac);\n", "    int outer_hdr_size = gnv_hdr_size + udp_hdr_size + ip_hdr_size + eth_hdr_size;\n", "    long ret = bpf_xdp_adjust_head (ctx, (0 - outer_hdr_size));\n", "    if (ret != 0l) {\n", "        mptm_print (\"[Agent:] DROP (BUG): Failure adjusting packet header!\\n\");\n", "        return XDP_DROP;\n", "    }\n", "    data = (void *) (long) ctx->data;\n", "    data_end = (void *) (long) ctx->data_end;\n", "    struct ethhdr *ethcpy;\n", "    ethcpy = data;\n", "    if (ethcpy + 1 > data_end) {\n", "        mptm_print (\"[Agent: ] ABORTED: Bad ETH header offset \\n\");\n", "        return XDP_ABORTED;\n", "    }\n", "    struct iphdr *ip = (struct iphdr *) (ethcpy + 1);\n", "    if (ip + 1 > data_end) {\n", "        mptm_print (\"ABORTED: Bad ip header offset ip: %x data_end:%x \\n\", ip + 1, data_end);\n", "        return XDP_ABORTED;\n", "    }\n", "    struct udphdr *udp = (struct udphdr *) (ip + 1);\n", "    if (udp + 1 > data_end) {\n", "        mptm_print (\"ABORTED: Bad udp header offset \\n\");\n", "        return XDP_ABORTED;\n", "    }\n", "    struct genevehdr *geneve = (struct genevehdr *) (udp + 1);\n", "    if (geneve + 1 > data_end) {\n", "        mptm_print (\"ABORTED: Bad GENEVE header offset \\n\");\n", "        return XDP_ABORTED;\n", "    }\n", "    ethcpy->h_proto = BE_ETH_P_IP;\n", "    set_dst_mac (data, tn->dest_mac);\n", "    set_src_mac (data, tn->source_mac);\n", "    int outer_ip_payload = gnv_hdr_size + udp_hdr_size + ip_hdr_size + old_size;\n", "    int outer_udp_payload = gnv_hdr_size + udp_hdr_size + old_size;\n", "    ip->version = 4;\n", "    ip->ihl = ip_hdr_size >> 2;\n", "    ip->frag_off = 0;\n", "    ip->protocol = IPPROTO_UDP;\n", "    ip->check = 0;\n", "    ip->tos = 0;\n", "    ip->tot_len = bpf_htons (outer_ip_payload);\n", "    ip->daddr = tn->dest_addr;\n", "    ip->saddr = tn->source_addr;\n", "    ip->ttl = DEFAULT_TTL;\n", "    __u64 c_sum = 0;\n", "    ipv4_csum_inline (ip, &c_sum);\n", "    ip->check = c_sum;\n", "    udp->check = 0;\n", "    udp->source = tn->source_port;\n", "    udp->dest = BE_GENEVE_DSTPORT;\n", "    udp->len = bpf_htons (outer_udp_payload);\n", "    __builtin_memset (geneve, 0, gnv_hdr_size);\n", "    geneve->opt_len = 0 / 4;\n", "    geneve->ver = 0;\n", "    geneve->rsvd1 = 0;\n", "    geneve->rsvd2 = 0;\n", "    geneve->oam = 0;\n", "    geneve->critical = 0;\n", "    geneve->proto_type = bpf_htons (ETH_P_TEB);\n", "    geneve->vni[0] = (__u8) (tn->vlan_id >> 16);\n", "    geneve->vni[1] = (__u8) (tn->vlan_id >> 8);\n", "    geneve->vni[2] = (__u8) tn->vlan_id;\n", "    return XDP_PASS;\n", "}\n"], "called_function_list": ["set_dst_mac", "set_src_mac", "ipv4_csum_inline"], "call_depth": 2, "humanFuncDescription": [[{"description": "This function takes in 3 arguments, 1) packet represented by struct xdp_mp *ctx, 2) struct ethhdr *eth, 3) geneve_tunnel_info *tn. It performs a geneve header encapsulation on top of the existing packet the details of geneve header are taken from tn argument. Specifically it expands the packet header by first calling the function bpf_xdp_adjust_head with extra size outer_hdr_size equal to geneve header + udp header + ip header + eth header and then it recalculates the new outer headers of expanded packet and populates the header information by taking relevant information from geneve_tunnel_info *tn object and programs the headers according to geneve protocol. Return XDP_PASS on success or XDP_ABORTED on failure", "author": "Dushyant Behl", "authorEmail": "dushyantbehl@in.ibm.com", "date": "2023-02-20"}, {}]], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "11": {"capabilities": [], "helperCallParams": {}, "startLine": 194, "endLine": 200, "File": "/home/palani/github/opened_extraction/examples/xdp-mptm-main/src/kernel/lib/pkt-encap.h", "funcName": "encap_geneve", "developer_inline_comments": [{"start_line": 197, "end_line": 197, "text": "// typecast the union to geneve"}], "updateMaps": [], "readMaps": [], "input": ["struct xdp_md *ctx", " struct ethhdr *eth", " mptm_tunnel_info *tn"], "output": "static__ALWAYS_INLINE__int", "helper": [], "compatibleHookpoints": ["cgroup_sock_addr", "sk_skb", "kprobe", "lwt_out", "cgroup_device", "perf_event", "xdp", "sk_reuseport", "cgroup_sock", "tracepoint", "cgroup_sysctl", "cgroup_skb", "sched_cls", "lwt_in", "socket_filter", "lwt_xmit", "raw_tracepoint_writable", "sk_msg", "flow_dissector", "lwt_seg6local", "sched_act", "sock_ops", "raw_tracepoint"], "source": ["static __ALWAYS_INLINE__ int encap_geneve (struct xdp_md *ctx, struct ethhdr *eth, mptm_tunnel_info *tn)\n", "{\n", "    struct geneve_info *geneve = (geneve_tunnel_info *) (&tn->tnl_info.geneve);\n", "    return __encap_geneve (ctx, eth, geneve);\n", "}\n"], "called_function_list": ["__encap_geneve"], "call_depth": 3, "humanFuncDescription": [[{"description": "This function takes in a packet represented by struct xdp_mp *ctx along side its eth header struct ethhdr *eth and mptm_tunnel_info *tn, it computes the geneve tunnel information to be pushed on the packet via mptm_tunnel_info and encapsulates the packet in a geneve tunnel by calling a helper funciton __encap_geneve. Returns XDP_PASS on success or XDP_ABORTED on failure.", "author": "Dushyant Behl", "authorEmail": "dushyantbehl@in.ibm.com", "date": "2023-02-20"}, {}]], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "12": {"capabilities": [{"capability": "pkt_stop_processing_drop_packet", "pkt_stop_processing_drop_packet": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_ABORTED", "Return": 0, "Description": "which serves denoting an exception like state from the program and has the same behavior as XDP_DROP only that XDP_ABORTED passes the trace_xdp_exception tracepoint which can be additionally monitored to detect misbehavior.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_stop_processing_drop_packet"]}]}, {"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_PASS", "Return": 2, "Description": "The XDP_PASS return code means that the packet is allowed to be passed up to the kernel\u2019s networking stack. Meaning, the current CPU that was processing this packet now allocates a skb, populates it, and passes it onwards into the GRO engine. This would be equivalent to the default packet handling behavior without XDP.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 203, "endLine": 214, "File": "/home/palani/github/opened_extraction/examples/xdp-mptm-main/src/kernel/lib/pkt-encap.h", "funcName": "encap_vlan", "developer_inline_comments": [{"start_line": 202, "end_line": 202, "text": "/* Use bpf.h function bpf_skb_vlan_push to remove dependency on xdp tutorials */"}, {"start_line": 206, "end_line": 206, "text": "// typecast the union to vlan"}], "updateMaps": [], "readMaps": [], "input": ["struct xdp_md *ctx", " struct ethhdr *eth", " mptm_tunnel_info *tn"], "output": "static__ALWAYS_INLINE__int", "helper": ["XDP_ABORTED", "XDP_PASS"], "compatibleHookpoints": ["xdp"], "source": ["static __ALWAYS_INLINE__ int encap_vlan (struct xdp_md *ctx, struct ethhdr *eth, mptm_tunnel_info *tn)\n", "{\n", "    struct vlan_info *vlan = (vlan_tunnel_info *) (&tn->tnl_info.vlan);\n", "    if (vlan_tag_push (ctx, eth, vlan->vlan_id) != 0) {\n", "        mptm_print (\"[ERR] vlan tag push failed %d\\n\", vlan->vlan_id);\n", "        return XDP_ABORTED;\n", "    }\n", "    return XDP_PASS;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [[{"description": "This function takes in a packet represented by struct xdp_mp *ctx along side its eth header struct ethhdr *eth and mptm_tunnel_info *tn, it computes the vlan tunnel to be pushed on the packet via mptm_tunnel_info and encapsulates the packet in a vlan by pusing a vlan tag on the packet eth hdr by calling a helper funciton vlan_tag_push. Returns XDP_PASS on success or XDP_ABORTED on failure.", "author": "Dushyant Behl", "authorEmail": "dushyantbehl@in.ibm.com", "date": "2023-02-20"}, {}]], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}}}