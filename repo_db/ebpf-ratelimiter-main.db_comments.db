{"_default": {"1": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "libbpf", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}, {"capability": "pkt_stop_processing_drop_packet", "pkt_stop_processing_drop_packet": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_DROP", "Return": 1, "Description": "will drop the packet right at the driver level without wasting any further resources. This is in particular useful for BPF programs implementing DDoS mitigation mechanisms or firewalling in general.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_stop_processing_drop_packet"]}]}, {"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_PASS", "Return": 2, "Description": "The XDP_PASS return code means that the packet is allowed to be passed up to the kernel\u2019s networking stack. Meaning, the current CPU that was processing this packet now allocates a skb, populates it, and passes it onwards into the GRO engine. This would be equivalent to the default packet handling behavior without XDP.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_go_to_next_module"]}]}, {"capability": "map_update", "map_update": [{"Project": "libbpf", "Return Type": "int", "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_map_update_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}", "{Type:  const void ,Var: *value}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_update"]}]}, {"capability": "read_sys_info", "read_sys_info": [{"Project": "bcc", "FunctionName": "bpf_ktime_get_ns", "Return Type": "u64", "Description": "u64 bpf_ktime_get_ns(void) Return: u64 number of nanoseconds. Starts at system boot time but stops during suspend. Examples in situ: \"https://github.com/iovisor/bcc/search?q=bpf_ktime_get_ns+path%3Aexamples&type=Code search /examples , \"https://github.com/iovisor/bcc/search?q=bpf_ktime_get_ns+path%3Atools&type=Code search /tools ", "Return": "u64 number of nanoseconds", "Input Prameters": [], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "raw_tracepoint_writable"], "capabilities": ["read_sys_info"]}]}], "helperCallParams": {}, "startLine": 100, "endLine": 276, "File": "/home/palani/github/opened_extraction/examples/ebpf-ratelimiter-main/ratelimiting_kern.c", "funcName": "_xdp_ratelimit", "developer_inline_comments": [{"start_line": 1, "end_line": 1, "text": "// Copyright Contributors to the L3AF Project."}, {"start_line": 2, "end_line": 2, "text": "// SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause)"}, {"start_line": 4, "end_line": 4, "text": "/* Ratelimit incoming TCP connections using XDP */"}, {"start_line": 19, "end_line": 19, "text": "/* TCP flags */"}, {"start_line": 44, "end_line": 44, "text": "/* Stores the ratelimit value(per second) */"}, {"start_line": 45, "end_line": 45, "text": "//Move map defintions to newer format "}, {"start_line": 55, "end_line": 56, "text": "/* Maintains the timestamp of a window and the total number of\n * connections received in that window(window = 1 sec interval) */"}, {"start_line": 65, "end_line": 66, "text": "/* Maintains the total number of connections received(TCP-SYNs)\n * Used only for metrics visibility */"}, {"start_line": 76, "end_line": 77, "text": "/* Maintains the total number of connections dropped as the ratelimit is hit\n * Used only for metrics visibility */"}, {"start_line": 86, "end_line": 86, "text": "/* Maintains the ports to be ratelimited */"}, {"start_line": 97, "end_line": 99, "text": "/* TODO Use atomics or spin locks where naive increments are used depending\n * on the accuracy tests and then do a tradeoff.\n * With 10k connections/sec tests, the error rate is < 3%. */"}, {"start_line": 107, "end_line": 107, "text": "/* Check if it is a valid ethernet packet */"}, {"start_line": 111, "end_line": 111, "text": "/* Ignore other than ethernet packets */"}, {"start_line": 117, "end_line": 117, "text": "/* Ignore other than IP packets */"}, {"start_line": 122, "end_line": 122, "text": "/* Ignore other than TCP packets */"}, {"start_line": 126, "end_line": 126, "text": "/* Check if its valid tcp packet */"}, {"start_line": 134, "end_line": 134, "text": "/* Ignore other than TCP-SYN packets */"}, {"start_line": 136, "end_line": 136, "text": "//bpf_printk(\"Ignoring %d \\n\",6);"}, {"start_line": 141, "end_line": 141, "text": "/* Ignore TCP-SYN-ACK packets */"}, {"start_line": 151, "end_line": 151, "text": "//bpf_printk(\"Check: rate  %d\\n\",rkey);"}, {"start_line": 156, "end_line": 156, "text": "//bpf_printk(\"Set: rate %d\\n\",*rate);"}, {"start_line": 159, "end_line": 159, "text": "//*rate = 5; //IRL Hard coding"}, {"start_line": 162, "end_line": 162, "text": "/* Current time in monotonic clock */"}, {"start_line": 165, "end_line": 165, "text": "/* Used for second to nanoseconds conversions and vice-versa */"}, {"start_line": 168, "end_line": 171, "text": "/* Used for converting decimals points to percentages as decimal points\n     * are not recommended in the kernel.\n     * Ex: 0.3 would be converted as 30 with this multiplication factor to\n     * perform the calculations needed. */"}, {"start_line": 174, "end_line": 177, "text": "/* Round off the current time to form the current window key.\n     * Ex: ts of the incoming connections from the time 16625000000000 till\n     * 166259999999 is rounded off to 166250000000000 to track the incoming\n     * connections received in that one second interval. */"}, {"start_line": 182, "end_line": 182, "text": "/* Previous window is one second before the current window */"}, {"start_line": 185, "end_line": 185, "text": "/* Number of incoming connections in the previous window(second) */"}, {"start_line": 188, "end_line": 188, "text": "/* Number of incoming connections in the current window(second) */"}, {"start_line": 191, "end_line": 191, "text": "/* Total number of incoming connections so far */"}, {"start_line": 194, "end_line": 194, "text": "/* Total number of dropped connections so far */"}, {"start_line": 197, "end_line": 198, "text": "/* Just make the verifier happy, it would never be the case in real as\n     * these two counters are initialised in the user space. */"}, {"start_line": 203, "end_line": 206, "text": "/*\n    bpf_printk(\"cw_key %u\\n\",cw_key);\n    bpf_printk(\"pw_key %u\\n\",pw_key);\n*/"}, {"start_line": 207, "end_line": 207, "text": "/* Increment the total number of incoming connections counter */"}, {"start_line": 213, "end_line": 214, "text": "/* This is the first connection in the current window,\n         * initialize the current window counter. */"}, {"start_line": 218, "end_line": 218, "text": "/* Just make the verifier happy */"}, {"start_line": 224, "end_line": 226, "text": "/* This is the fresh start of system or there have been no\n         * connections in the last second, so make the decision purely based\n         * on the incoming connections in the current window. */"}, {"start_line": 229, "end_line": 230, "text": "/* Connection count in the current window already exceeded the\n             * rate limit so drop this connection. */"}, {"start_line": 235, "end_line": 235, "text": "/* Allow otherwise */"}, {"start_line": 241, "end_line": 244, "text": "/* Calculate the number of connections accepted in last 1 sec from tnow *\n     * considering the connections accepted in previous window and          *\n     * current window based on what % of the sliding window(tnow - 1) falls *\n     * in previous window and what % of it is in the current window         */"}, {"start_line": 254, "end_line": 254, "text": "//uint64_t temp = (*rate) * MULTIPLIER;"}, {"start_line": 255, "end_line": 255, "text": "//uint64_t temp = 5;"}, {"start_line": 257, "end_line": 257, "text": "//bpf_printk(\"temp: %d\\n\",temp);"}, {"start_line": 259, "end_line": 259, "text": "//int c = (total_count > temp);"}, {"start_line": 260, "end_line": 260, "text": "//bpf_printk(\"c: %d\\n\",c);"}, {"start_line": 262, "end_line": 262, "text": "//if (c )"}, {"start_line": 264, "end_line": 264, "text": "//if (total_count > ((*rate) * MULTIPLIER))"}, {"start_line": 266, "end_line": 267, "text": "/* Connection count from tnow to (tnow-1) exceeded the rate limit,\n         * so drop this connection. */"}, {"start_line": 272, "end_line": 272, "text": "/* Allow otherwise */"}], "updateMaps": [" rl_window_map"], "readMaps": [" rl_recv_count_map", " rl_window_map", " rl_drop_count_map", " rl_config_map", "  rl_window_map"], "input": ["struct xdp_md *ctx"], "output": "static__always_inlineint", "helper": ["bpf_map_lookup_elem", "XDP_DROP", "XDP_PASS", "bpf_map_update_elem", "bpf_ktime_get_ns"], "compatibleHookpoints": ["xdp"], "source": ["static __always_inline int _xdp_ratelimit (struct xdp_md *ctx)\n", "{\n", "    void *data_end = (void *) (long) ctx->data_end;\n", "    void *data = (void *) (long) ctx->data;\n", "    struct ethhdr *eth = data;\n", "    if (data + sizeof (*eth) > data_end)\n", "        return XDP_DROP;\n", "    uint16_t eth_type = eth->h_proto;\n", "    if (ntohs (eth_type) != ETH_P_IP) {\n", "        return XDP_PASS;\n", "    }\n", "    struct iphdr *iph = data + sizeof (struct ethhdr);\n", "    if (iph + 1 > data_end)\n", "        return XDP_PASS;\n", "    if (iph->protocol != IPPROTO_TCP)\n", "        return XDP_PASS;\n", "    struct tcphdr *tcph = (struct tcphdr *) (iph + 1);\n", "    if (tcph + 1 > data_end)\n", "        return XDP_PASS;\n", "    bpf_printk (\"NEW: TCP Syn : %d\\n\", tcph->syn & TCP_FLAGS);\n", "    if (!(tcph->syn & TCP_FLAGS)) {\n", "        return XDP_PASS;\n", "    }\n", "    if (tcph->ack & TCP_FLAGS)\n", "        return XDP_PASS;\n", "    uint16_t dstport = bpf_ntohs (tcph -> dest);\n", "    uint64_t rkey = 0;\n", "    uint64_t *rate = bpf_map_lookup_elem (&rl_config_map, &rkey);\n", "    if (!rate) {\n", "        bpf_printk (\"Return: rate %d\\n\", rkey);\n", "        return XDP_PASS;\n", "    }\n", "    else {\n", "    }\n", "    bpf_printk (\"Allowed connections rate: %d\\n\", *rate);\n", "    uint64_t tnow = bpf_ktime_get_ns ();\n", "    uint64_t NANO = 1000000000;\n", "    uint64_t MULTIPLIER = 100;\n", "    uint64_t cw_key = (tnow / NANO) * NANO;\n", "    uint64_t pw_key = cw_key - NANO;\n", "    uint64_t *pw_count = bpf_map_lookup_elem (&rl_window_map, &pw_key);\n", "    uint32_t *cw_count = bpf_map_lookup_elem (&rl_window_map, &cw_key);\n", "    uint64_t *in_count = bpf_map_lookup_elem (&rl_recv_count_map, &rkey);\n", "    uint64_t *drop_count = bpf_map_lookup_elem (&rl_drop_count_map, &rkey);\n", "    if (!in_count || !drop_count) {\n", "        bpf_printk (\"count null %d\\n\", rate);\n", "        return XDP_PASS;\n", "    }\n", "    (*in_count)++;\n", "    if (!cw_count) {\n", "        uint64_t init_count = 0;\n", "        bpf_map_update_elem (&rl_window_map, &cw_key, &init_count, BPF_NOEXIST);\n", "        cw_count = bpf_map_lookup_elem (& rl_window_map, & cw_key);\n", "        if (!cw_count)\n", "            return XDP_PASS;\n", "    }\n", "    if (!pw_count) {\n", "        if (*cw_count >= *rate) {\n", "            (*drop_count)++;\n", "            bpf_printk (\"DROPPING CONNECTION: CT  %d\\n\", *cw_count);\n", "            return XDP_DROP;\n", "        }\n", "        (*cw_count)++;\n", "        bpf_printk (\"ALLOWING CONNECTION: CT %d\\n\", *cw_count);\n", "        return XDP_PASS;\n", "    }\n", "    uint64_t pw_weight = MULTIPLIER - (uint64_t) (((tnow - cw_key) * MULTIPLIER) / NANO);\n", "    uint64_t total_count = (uint64_t) ((pw_weight *(* pw_count)) +(*cw_count) * MULTIPLIER);\n", "    bpf_printk (\"tot_ct : %d\\n\", total_count);\n", "    bpf_printk (\"cw1_ct : %d\\n\", *cw_count);\n", "    if (total_count > (*rate)) {\n", "        (*drop_count)++;\n", "        bpf_printk (\"DROPPING CONNECTION: CT  %d\\n\", *cw_count);\n", "        return XDP_DROP;\n", "    }\n", "    (*cw_count)++;\n", "    bpf_printk (\"ALLOWING CONNECTION: CT  %d\\n\", *cw_count);\n", "    return XDP_PASS;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [[{"description": "This function implements a TCP connection rate limiter. Takes in input a packet in struct xdp_mp * ctx form. It first checks if input is a valid ethernet packet. It ignores other than ethernet packets, other than ip packets, other than tcp packets. If the packet is a valid tcp packet, it check if the packet is a TCP syn packet as it performs connection rate limiting it ignores packets other than tcp syn packets and even tcp syn ack packets. If the packet is a TCP SYN hence connection establishment packet, the code reads a map rl_config_map with key set to number 0 and receives the allowed rate of connections configured from the userspace if the map read fails, the function returns XDP_PASS else it continues execution. Next it checks which time window the packet corresponds to, a window is essentially a 1 second sliding window calculated by calling bpf_ktime_get_ns and getting the current time. Current time is used to calculate current window cw_key and previous window(current - 1 s) is used to calculate previous window pw_key. The function then performs a bunch of map reads, 1) rl_window_map twice with keys cw_key and pw_key which gives the cw_count and pw_count essentially current window packet count and previous window packet count. 2) rl_recv_count_map with key set to number 0 which tracks number of incommming connections 3) rl_drop_count_map with key set to number 0 which tracks number of dropped connections. If this is the first packet in this window then the function updates the map rl_window_map with key cw_key and value 0 and sets the cw_count to 0. If this is a new connection and no previous connection were present then the rate limiter allows connection if cw_count < rate and returns XDP_PASS else it drops the connection and returns XDP_DROP. If there had been previous connections then it calculates the number of connections accepted in last 1 sec from current time, if the total connections are higher than allowed rate, it drops the connection and returns XDP_DROP else it allows the connection and returns XDP_PASS. The function also updates the current window count and drop count before returning.", "author": "Dushyant Behl", "authorEmail": "dushyantbehl@in.ibm.com", "date": "2023-02-20"}, {}]], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "2": {"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}, {"capability": "map_read", "map_read": [{"Project": "libbpf", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}, {"capability": "map_update", "map_update": [{"Project": "libbpf", "Return Type": "int", "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_map_update_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}", "{Type:  const void ,Var: *value}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_update"]}]}, {"capability": "pkt_stop_processing_drop_packet", "pkt_stop_processing_drop_packet": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_SHOT", "Return": 2, "Description": "instructs the kernel to drop the packet, meaning, upper layers of the networking stack will never see the skb on ingress and similarly the packet will never be submitted for transmission on egress. TC_ACT_SHOT and TC_ACT_STOLEN are both similar in nature with few differences: TC_ACT_SHOT will indicate to the kernel that the skb was released through kfree_skb() and return NET_XMIT_DROP to the callers for immediate feedback, whereas TC_ACT_STOLEN will release the skb through consume_skb() and pretend to upper layers that the transmission was successful through NET_XMIT_SUCCESS. The perf\u2019s drop monitor which records traces of kfree_skb() will therefore also not see any drop indications from TC_ACT_STOLEN since its semantics are such that the skb has been \u201cconsumed\u201d or queued but certainly not \"dropped\".", "compatible_hookpoints": ["sched_cls", "sched_act"], "capabilities": ["pkt_stop_processing_drop_packet"]}]}, {"capability": "read_sys_info", "read_sys_info": [{"Project": "bcc", "FunctionName": "bpf_ktime_get_ns", "Return Type": "u64", "Description": "u64 bpf_ktime_get_ns(void) Return: u64 number of nanoseconds. Starts at system boot time but stops during suspend. Examples in situ: \"https://github.com/iovisor/bcc/search?q=bpf_ktime_get_ns+path%3Aexamples&type=Code search /examples , \"https://github.com/iovisor/bcc/search?q=bpf_ktime_get_ns+path%3Atools&type=Code search /tools ", "Return": "u64 number of nanoseconds", "Input Prameters": [], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "raw_tracepoint_writable"], "capabilities": ["read_sys_info"]}]}], "helperCallParams": {}, "startLine": 64, "endLine": 128, "File": "/home/palani/github/opened_extraction/examples/ebpf-ratelimiter-main/transformed/ratelimiting_kern-TC.c", "funcName": "_xdp_ratelimit", "developer_inline_comments": [], "updateMaps": [" rl_window_map"], "readMaps": [" rl_recv_count_map", " rl_window_map", " rl_drop_count_map", " rl_config_map", " rl_ports_map", "  rl_window_map"], "input": ["struct  __sk_buff *ctx"], "output": "static__always_inlineint", "helper": ["TC_ACT_OK", "bpf_map_lookup_elem", "bpf_map_update_elem", "TC_ACT_SHOT", "bpf_ktime_get_ns"], "compatibleHookpoints": ["sched_act", "sched_cls"], "source": ["static __always_inline int _xdp_ratelimit (struct  __sk_buff *ctx)\n", "{\n", "    void *data_end = (void *) (long) ctx->data_end;\n", "    void *data = (void *) (long) ctx->data;\n", "    struct ethhdr *eth = data;\n", "    if (data + sizeof (*eth) > data_end)\n", "        return TC_ACT_SHOT;\n", "    uint16_t eth_type = ctx->protocol;\n", "    if (ntohs (eth_type) != ETH_P_IP) {\n", "        return TC_ACT_OK;\n", "    }\n", "    struct iphdr *iph = data + sizeof (struct ethhdr);\n", "    if (iph + 1 > data_end)\n", "        return TC_ACT_OK;\n", "    if (iph->protocol != IPPROTO_TCP)\n", "        return TC_ACT_OK;\n", "    struct tcphdr *tcph = (struct tcphdr *) (iph + 1);\n", "    if (tcph + 1 > data_end)\n", "        return TC_ACT_OK;\n", "    if (!(tcph->syn & TCP_FLAGS))\n", "        return TC_ACT_OK;\n", "    if (tcph->ack & TCP_FLAGS)\n", "        return TC_ACT_OK;\n", "    uint16_t dstport = bpf_ntohs (tcph -> dest);\n", "    if (!bpf_map_lookup_elem (&rl_ports_map, &dstport))\n", "        return TC_ACT_OK;\n", "    uint64_t rkey = 0;\n", "    uint64_t *rate = bpf_map_lookup_elem (&rl_config_map, &rkey);\n", "    if (!rate)\n", "        return TC_ACT_OK;\n", "    uint64_t tnow = bpf_ktime_get_ns ();\n", "    uint64_t NANO = 1000000000;\n", "    uint64_t MULTIPLIER = 100;\n", "    uint64_t cw_key = tnow / NANO * NANO;\n", "    uint64_t pw_key = cw_key - NANO;\n", "    uint64_t *pw_count = bpf_map_lookup_elem (&rl_window_map, &pw_key);\n", "    uint32_t *cw_count = bpf_map_lookup_elem (&rl_window_map, &cw_key);\n", "    uint64_t *in_count = bpf_map_lookup_elem (&rl_recv_count_map, &rkey);\n", "    uint64_t *drop_count = bpf_map_lookup_elem (&rl_drop_count_map, &rkey);\n", "    if (!in_count || !drop_count)\n", "        return TC_ACT_OK;\n", "    (*in_count)++;\n", "    if (!cw_count) {\n", "        uint64_t init_count = 0;\n", "        bpf_map_update_elem (&rl_window_map, &cw_key, &init_count, BPF_NOEXIST);\n", "        cw_count = bpf_map_lookup_elem (& rl_window_map, & cw_key);\n", "        if (!cw_count)\n", "            return TC_ACT_OK;\n", "    }\n", "    if (!pw_count) {\n", "        if (*cw_count >= *rate) {\n", "            (*drop_count)++;\n", "            return TC_ACT_SHOT;\n", "        }\n", "        (*cw_count)++;\n", "        return TC_ACT_OK;\n", "    }\n", "    uint64_t pw_weight = MULTIPLIER - (uint64_t) (((tnow - cw_key) * MULTIPLIER) / NANO);\n", "    uint64_t total_count = (uint64_t) ((pw_weight *(* pw_count)) +(*cw_count) * MULTIPLIER);\n", "    if (total_count > ((*rate) * MULTIPLIER)) {\n", "        (*drop_count)++;\n", "        return TC_ACT_SHOT;\n", "    }\n", "    (*cw_count)++;\n", "    return TC_ACT_OK;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [[{"description": "This function implements a TCP connection rate limiter. Takes in input a packet in struct xdp_mp * ctx form. It first checks if input is a valid ethernet packet. It ignores other than ethernet packets, other than ip packets, other than tcp packets. If the packet is a valid tcp packet, it check if the packet is a TCP syn packet as it performs connection rate limiting it ignores packets other than tcp syn packets and even tcp syn ack packets. If the packet is a TCP SYN hence connection establishment packet, the code reads a map rl_config_map with key set to number 0 and receives the allowed rate of connections configured from the userspace if the map read fails, the function returns TC_ACT_OK else it continues execution. Next it checks which time window the packet corresponds to, a window is essentially a 1 second sliding window calculated by calling bpf_ktime_get_ns and getting the current time. Current time is used to calculate current window cw_key and previous window(current - 1 s) is used to calculate previous window pw_key. The function then performs a bunch of map reads, 1) rl_window_map twice with keys cw_key and pw_key which gives the cw_count and pw_count essentially current window packet count and previous window packet count. 2) rl_recv_count_map with key set to number 0 which tracks number of incommming connections 3) rl_drop_count_map with key set to number 0 which tracks number of dropped connections. If this is the first packet in this window then the function updates the map rl_window_map with key cw_key and value 0 and sets the cw_count to 0. If this is a new connection and no previous connection were present then the rate limiter allows connection if cw_count < rate and returns TC_ACT_OK else it drops the connection and returns TC_ACT_SHOT. If there had been previous connections then it calculates the number of connections accepted in last 1 sec from current time, if the total connections are higher than allowed rate, it drops the connection and returns TC_ACT_SHOT else it allows the connection and returns TC_ACT_OK. The function also updates the current window count and drop count before returning.", "author": "Dushyant Behl", "authorEmail": "dushyantbehl@in.ibm.com", "date": "2023-02-20"}, {}]], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "3": {"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_PASS", "Return": 2, "Description": "The XDP_PASS return code means that the packet is allowed to be passed up to the kernel\u2019s networking stack. Meaning, the current CPU that was processing this packet now allocates a skb, populates it, and passes it onwards into the GRO engine. This would be equivalent to the default packet handling behavior without XDP.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_go_to_next_module"]}]}, {"capability": "pkt_stop_processing_drop_packet", "pkt_stop_processing_drop_packet": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_DROP", "Return": 1, "Description": "will drop the packet right at the driver level without wasting any further resources. This is in particular useful for BPF programs implementing DDoS mitigation mechanisms or firewalling in general.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_stop_processing_drop_packet"]}]}], "helperCallParams": {}, "startLine": 279, "endLine": 289, "File": "/home/palani/github/opened_extraction/examples/ebpf-ratelimiter-main/ratelimiting_kern.c", "funcName": "_xdp_ratelimiting", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct xdp_md *ctx"], "output": "int", "helper": ["XDP_PASS", "XDP_DROP"], "compatibleHookpoints": ["xdp"], "source": ["int _xdp_ratelimiting (struct xdp_md *ctx)\n", "{\n", "    bpf_printk (\"entered xdp_rate_limiter\\n\");\n", "    int rc = _xdp_ratelimit (ctx);\n", "    if (rc == XDP_DROP) {\n", "        return XDP_DROP;\n", "    }\n", "    return XDP_PASS;\n", "}\n"], "called_function_list": ["_xdp_ratelimit"], "call_depth": 1, "humanFuncDescription": [[{"description": "This is a wrapper function which calls the base function _xdp_ratelimit with the same arument passed to it and returns its value", "author": "Dushyant Behl", "authorEmail": "dushyantbehl@in.ibm.com", "date": "2023-02-20"}, {}]], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "4": {"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}, {"capability": "pkt_stop_processing_drop_packet", "pkt_stop_processing_drop_packet": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_SHOT", "Return": 2, "Description": "instructs the kernel to drop the packet, meaning, upper layers of the networking stack will never see the skb on ingress and similarly the packet will never be submitted for transmission on egress. TC_ACT_SHOT and TC_ACT_STOLEN are both similar in nature with few differences: TC_ACT_SHOT will indicate to the kernel that the skb was released through kfree_skb() and return NET_XMIT_DROP to the callers for immediate feedback, whereas TC_ACT_STOLEN will release the skb through consume_skb() and pretend to upper layers that the transmission was successful through NET_XMIT_SUCCESS. The perf\u2019s drop monitor which records traces of kfree_skb() will therefore also not see any drop indications from TC_ACT_STOLEN since its semantics are such that the skb has been \u201cconsumed\u201d or queued but certainly not \"dropped\".", "compatible_hookpoints": ["sched_cls", "sched_act"], "capabilities": ["pkt_stop_processing_drop_packet"]}]}], "helperCallParams": {}, "startLine": 131, "endLine": 138, "File": "/home/palani/github/opened_extraction/examples/ebpf-ratelimiter-main/transformed/ratelimiting_kern-TC.c", "funcName": "_xdp_ratelimiting", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __sk_buff *ctx"], "output": "int", "helper": ["TC_ACT_OK", "TC_ACT_SHOT", "bpf_tail_call"], "compatibleHookpoints": ["sched_act", "sched_cls"], "source": ["int _xdp_ratelimiting (struct  __sk_buff *ctx)\n", "{\n", "    int rc = _xdp_ratelimit (ctx);\n", "    if (rc == TC_ACT_SHOT) {\n", "        return TC_ACT_SHOT;\n", "    }\n", "    bpf_tail_call (ctx, &xdp_rl_ingress_next_prog, 0);\n", "    return TC_ACT_OK;\n", "}\n"], "called_function_list": ["_xdp_ratelimit"], "call_depth": 1, "humanFuncDescription": [[{"description": "This is a wrapper function which calls the base function _xdp_ratelimit with the same arument passed to it and returns its value", "author": "Dushyant Behl", "authorEmail": "dushyantbehl@in.ibm.com", "date": "2023-02-20"}, {}]], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "5": {"capabilities": [], "helperCallParams": {}, "startLine": 38, "endLine": 44, "File": "/home/palani/github/opened_extraction/examples/ebpf-ratelimiter-main/ratelimiting_user.c", "funcName": "strsep", "developer_inline_comments": [{"start_line": 1, "end_line": 1, "text": "// Copyright Contributors to the L3AF Project."}, {"start_line": 2, "end_line": 2, "text": "// SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause)"}, {"start_line": 4, "end_line": 4, "text": "/* Ratelimit incoming TCP connections with sliding window approach */"}, {"start_line": 24, "end_line": 24, "text": "//#include <bpf/bpf_helpers.h>"}, {"start_line": 27, "end_line": 27, "text": "//#include \"bpf_load.h\""}, {"start_line": 29, "end_line": 29, "text": "//#include \"bpf_util.h\""}], "updateMaps": [], "readMaps": [], "input": ["char **stringp", " const char *delim"], "output": "char", "helper": [], "compatibleHookpoints": ["cgroup_device", "cgroup_sock", "lwt_xmit", "flow_dissector", "lwt_seg6local", "sk_skb", "sched_cls", "raw_tracepoint", "sk_msg", "tracepoint", "lwt_out", "cgroup_sock_addr", "raw_tracepoint_writable", "perf_event", "xdp", "kprobe", "sk_reuseport", "sock_ops", "cgroup_sysctl", "sched_act", "cgroup_skb", "lwt_in", "socket_filter"], "source": ["char *strsep (char **stringp, const char *delim)\n", "{\n", "    static char *next_token = NULL;\n", "    char *input = *stringp;\n", "    *stringp = strtok_s (input, delim, &next_token);\n", "    return input;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [[{"description": "", "author": "", "authorEmail": "", "date": ""}, {}]], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "6": {"capabilities": [], "helperCallParams": {}, "startLine": 47, "endLine": 58, "File": "/home/palani/github/opened_extraction/examples/ebpf-ratelimiter-main/ratelimiting_user.c", "funcName": "gettimeofday", "developer_inline_comments": [{"start_line": 54, "end_line": 54, "text": "// Convert to usec."}], "updateMaps": [], "readMaps": [], "input": ["struct timeval *tv", " struct timezone *tz"], "output": "int", "helper": [], "compatibleHookpoints": ["cgroup_device", "cgroup_sock", "lwt_xmit", "flow_dissector", "lwt_seg6local", "sk_skb", "sched_cls", "raw_tracepoint", "sk_msg", "tracepoint", "lwt_out", "cgroup_sock_addr", "raw_tracepoint_writable", "perf_event", "xdp", "kprobe", "sk_reuseport", "sock_ops", "cgroup_sysctl", "sched_act", "cgroup_skb", "lwt_in", "socket_filter"], "source": ["int gettimeofday (struct timeval *tv, struct timezone *tz)\n", "{\n", "    FILETIME ft;\n", "    ULARGE_INTEGER ui;\n", "    GetSystemTimeAsFileTime (&ft);\n", "    ui.LowPart = ft.dwLowDateTime;\n", "    ui.HighPart = ft.dwHighDateTime;\n", "    ui.QuadPart /= 10;\n", "    tv->tv_sec = (long) (ui.QuadPart / 1000000);\n", "    tv->tv_usec = ui.QuadPart % 1000000;\n", "    return 0;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [[{"description": "", "author": "", "authorEmail": "", "date": ""}, {}]], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "7": {"capabilities": [], "helperCallParams": {}, "startLine": 85, "endLine": 104, "File": "/home/palani/github/opened_extraction/examples/ebpf-ratelimiter-main/ratelimiting_user.c", "funcName": "usage", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["char *argv []"], "output": "staticvoid", "helper": [], "compatibleHookpoints": ["cgroup_device", "cgroup_sock", "lwt_xmit", "flow_dissector", "lwt_seg6local", "sk_skb", "sched_cls", "raw_tracepoint", "sk_msg", "tracepoint", "lwt_out", "cgroup_sock_addr", "raw_tracepoint_writable", "perf_event", "xdp", "kprobe", "sk_reuseport", "sock_ops", "cgroup_sysctl", "sched_act", "cgroup_skb", "lwt_in", "socket_filter"], "source": ["static void usage (char *argv [])\n", "{\n", "    int i;\n", "    printf (\"\\nDOCUMENTATION:\\n%s\\n\", __doc__);\n", "    printf (\"\\n\");\n", "    printf (\" Usage: %s (options-see-below)\\n\", argv[0]);\n", "    printf (\" Listing options:\\n\");\n", "    for (i = 0; long_options[i].name != 0; i++) {\n", "        printf (\" --%-12s\", long_options[i].name);\n", "        if (long_options[i].flag != NULL)\n", "            printf (\" flag (internal value:%d)\", *long_options[i].flag);\n", "        else\n", "            printf (\" short-option: -%c\", long_options[i].val);\n", "        printf (\"\\n\");\n", "    }\n", "    printf (\"\\n\");\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [[{"description": "", "author": "", "authorEmail": "", "date": ""}, {}]], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "8": {"capabilities": [], "helperCallParams": {}, "startLine": 107, "endLine": 118, "File": "/home/palani/github/opened_extraction/examples/ebpf-ratelimiter-main/ratelimiting_user.c", "funcName": "log_timestamp", "developer_inline_comments": [{"start_line": 106, "end_line": 106, "text": "/* Set log timestamps */"}], "updateMaps": [], "readMaps": [], "input": ["char *log_ts"], "output": "void", "helper": [], "compatibleHookpoints": ["cgroup_device", "cgroup_sock", "lwt_xmit", "flow_dissector", "lwt_seg6local", "sk_skb", "sched_cls", "raw_tracepoint", "sk_msg", "tracepoint", "lwt_out", "cgroup_sock_addr", "raw_tracepoint_writable", "perf_event", "xdp", "kprobe", "sk_reuseport", "sock_ops", "cgroup_sysctl", "sched_act", "cgroup_skb", "lwt_in", "socket_filter"], "source": ["void log_timestamp (char *log_ts)\n", "{\n", "    struct timeval tv;\n", "    time_t nowtime;\n", "    struct tm *nowtm;\n", "    char tmbuf [TIMESTAMP_LEN];\n", "    gettimeofday (&tv, NULL);\n", "    nowtime = tv.tv_sec;\n", "    nowtm = localtime (& nowtime);\n", "    strftime (tmbuf, DATE_LEN, \"%Y-%m-%d %H:%M:%S\", nowtm);\n", "    snprintf (log_ts, DATE_LEN + TIMESTAMP_LEN, \"%s.%06ld\", tmbuf, tv.tv_usec);\n", "}\n"], "called_function_list": ["gettimeofday"], "call_depth": 1, "humanFuncDescription": [[{"description": "", "author": "", "authorEmail": "", "date": ""}, {}]], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "9": {"capabilities": [], "helperCallParams": {}, "startLine": 120, "endLine": 129, "File": "/home/palani/github/opened_extraction/examples/ebpf-ratelimiter-main/ratelimiting_user.c", "funcName": "get_length", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const char *str"], "output": "staticint", "helper": [], "compatibleHookpoints": ["cgroup_device", "cgroup_sock", "lwt_xmit", "flow_dissector", "lwt_seg6local", "sk_skb", "sched_cls", "raw_tracepoint", "sk_msg", "tracepoint", "lwt_out", "cgroup_sock_addr", "raw_tracepoint_writable", "perf_event", "xdp", "kprobe", "sk_reuseport", "sock_ops", "cgroup_sysctl", "sched_act", "cgroup_skb", "lwt_in", "socket_filter"], "source": ["static int get_length (const char *str)\n", "{\n", "    int len = 0;\n", "    if (*str == '\\0')\n", "        return 0;\n", "    while (str[len] != '\\0')\n", "        len++;\n", "    return len;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [[{"description": "", "author": "", "authorEmail": "", "date": ""}, {}]], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "10": {"capabilities": [], "helperCallParams": {}, "startLine": 132, "endLine": 145, "File": "/home/palani/github/opened_extraction/examples/ebpf-ratelimiter-main/ratelimiting_user.c", "funcName": "set_logfile", "developer_inline_comments": [{"start_line": 131, "end_line": 131, "text": "/* Set the logging output to the default log file configured */"}], "updateMaps": [], "readMaps": [], "input": ["void"], "output": "staticFILE", "helper": [], "compatibleHookpoints": ["cgroup_device", "cgroup_sock", "lwt_xmit", "flow_dissector", "lwt_seg6local", "sk_skb", "sched_cls", "raw_tracepoint", "sk_msg", "tracepoint", "lwt_out", "cgroup_sock_addr", "raw_tracepoint_writable", "perf_event", "xdp", "kprobe", "sk_reuseport", "sock_ops", "cgroup_sysctl", "sched_act", "cgroup_skb", "lwt_in", "socket_filter"], "source": ["static FILE *set_logfile (void)\n", "{\n", "    if (info != NULL) {\n", "        return info;\n", "    }\n", "    info = fopen (DEFAULT_LOGFILE, \"a\");\n", "    if (info == NULL) {\n", "        fprintf (stderr, \"could not open log file \");\n", "        return NULL;\n", "    }\n", "    fprintf (stderr, \"writing errors/warnings/info/debug output to %s \\n\", DEFAULT_LOGFILE);\n", "    return info;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [[{"description": "", "author": "", "authorEmail": "", "date": ""}, {}]], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "11": {"capabilities": [{"capability": "map_update", "map_update": [{"Project": "libbpf", "Return Type": "int", "Description": "Delete entry with <[ key ]>(IP: 1) from map. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_map_delete_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_update"]}]}], "helperCallParams": {}, "startLine": 148, "endLine": 167, "File": "/home/palani/github/opened_extraction/examples/ebpf-ratelimiter-main/ratelimiting_user.c", "funcName": "xdp_unlink_bpf_chain", "developer_inline_comments": [{"start_line": 147, "end_line": 147, "text": "// This method to unlink the program"}], "updateMaps": [" map_fd"], "readMaps": [], "input": ["const char *map_filename"], "output": "staticint", "helper": ["bpf_map_delete_elem"], "compatibleHookpoints": ["cgroup_device", "cgroup_sock", "lwt_xmit", "flow_dissector", "lwt_seg6local", "sk_skb", "sched_cls", "raw_tracepoint", "sk_msg", "tracepoint", "lwt_out", "cgroup_sock_addr", "raw_tracepoint_writable", "perf_event", "xdp", "kprobe", "sk_reuseport", "sock_ops", "cgroup_sysctl", "sched_act", "cgroup_skb", "lwt_in", "socket_filter"], "source": ["static int xdp_unlink_bpf_chain (const char *map_filename)\n", "{\n", "    int ret = 0;\n", "    int key = 0;\n", "    int map_fd = bpf_obj_get (map_filename);\n", "    if (map_fd > 0) {\n", "        ret = bpf_map_delete_elem (map_fd, & key);\n", "        if (ret != 0) {\n", "            log_err (\"Failed to remove XDP program from the chain\");\n", "        }\n", "    }\n", "    else {\n", "        log_err (\"Failed to fetch previous XDP program in the chain\");\n", "    }\n", "    if (remove (xdp_rl_ingress_next_prog) < 0) {\n", "        log_warn (\"Failed to remove link to next XDP program in the chain\");\n", "    }\n", "    return ret;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [[{"description": "", "author": "", "authorEmail": "", "date": ""}, {}]], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "12": {"capabilities": [], "helperCallParams": {}, "startLine": 171, "endLine": 182, "File": "/home/palani/github/opened_extraction/examples/ebpf-ratelimiter-main/ratelimiting_user.c", "funcName": "signal_handler", "developer_inline_comments": [{"start_line": 170, "end_line": 170, "text": "/* Unlink xdp kernel program on receiving KILL/INT signals */"}], "updateMaps": [], "readMaps": [], "input": ["int signal"], "output": "staticvoid", "helper": [], "compatibleHookpoints": ["cgroup_device", "cgroup_sock", "lwt_xmit", "flow_dissector", "lwt_seg6local", "sk_skb", "sched_cls", "raw_tracepoint", "sk_msg", "tracepoint", "lwt_out", "cgroup_sock_addr", "raw_tracepoint_writable", "perf_event", "xdp", "kprobe", "sk_reuseport", "sock_ops", "cgroup_sysctl", "sched_act", "cgroup_skb", "lwt_in", "socket_filter"], "source": ["static void signal_handler (int signal)\n", "{\n", "    log_info (\"Received signal %d\", signal);\n", "    int i = 0;\n", "    xdp_unlink_bpf_chain (prev_prog_map);\n", "    for (i = 0; i < MAP_COUNT; i++) {\n", "        close (map_fd[i]);\n", "    }\n", "    if (info != NULL)\n", "        fclose (info);\n", "    exit (EXIT_SUCCESS);\n", "}\n"], "called_function_list": ["xdp_unlink_bpf_chain"], "call_depth": 1, "humanFuncDescription": [[{"description": "", "author": "", "authorEmail": "", "date": ""}, {}]], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "13": {"capabilities": [], "helperCallParams": {}, "startLine": 185, "endLine": 199, "File": "/home/palani/github/opened_extraction/examples/ebpf-ratelimiter-main/ratelimiting_user.c", "funcName": "time_get_ns", "developer_inline_comments": [{"start_line": 184, "end_line": 184, "text": "/* Get monotonic clock time in ns */"}], "updateMaps": [], "readMaps": [], "input": ["void"], "output": "static__u64", "helper": [], "compatibleHookpoints": ["cgroup_device", "cgroup_sock", "lwt_xmit", "flow_dissector", "lwt_seg6local", "sk_skb", "sched_cls", "raw_tracepoint", "sk_msg", "tracepoint", "lwt_out", "cgroup_sock_addr", "raw_tracepoint_writable", "perf_event", "xdp", "kprobe", "sk_reuseport", "sock_ops", "cgroup_sysctl", "sched_act", "cgroup_skb", "lwt_in", "socket_filter"], "source": ["static __u64 time_get_ns (void)\n", "{\n", "\n", "#ifdef __linux__\n", "    struct timespec ts;\n", "    clock_gettime (CLOCK_MONOTONIC, &ts);\n", "    return ts.tv_sec * 1000000000ull + ts.tv_nsec;\n", "\n", "#endif\n", "\n", "#ifdef WIN32\n", "    LARGE_INTEGER frequency, counter;\n", "    QueryPerformanceFrequency (&frequency);\n", "    QueryPerformanceCounter (&counter);\n", "    return (1000000000 * counter.QuadPart) / frequency.QuadPart;\n", "\n", "#endif\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [[{"description": "", "author": "", "authorEmail": "", "date": ""}, {}]], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "14": {"capabilities": [], "helperCallParams": {}, "startLine": 203, "endLine": 226, "File": "/home/palani/github/opened_extraction/examples/ebpf-ratelimiter-main/ratelimiting_user.c", "funcName": "delete_stale_entries", "developer_inline_comments": [{"start_line": 201, "end_line": 202, "text": "/* Delete stale map entries(LRU) based on the timestamp at which\n * a map element is created. */"}], "updateMaps": [" map_fd[1]"], "readMaps": [], "input": ["void"], "output": "staticvoid", "helper": [], "compatibleHookpoints": ["cgroup_device", "cgroup_sock", "lwt_xmit", "flow_dissector", "lwt_seg6local", "sk_skb", "sched_cls", "raw_tracepoint", "sk_msg", "tracepoint", "lwt_out", "cgroup_sock_addr", "raw_tracepoint_writable", "perf_event", "xdp", "kprobe", "sk_reuseport", "sock_ops", "cgroup_sysctl", "sched_act", "cgroup_skb", "lwt_in", "socket_filter"], "source": ["static void delete_stale_entries (void)\n", "{\n", "    log_debug (\"Deleting stale map entries periodically\");\n", "    if (map_fd[1] < 0) {\n", "        log_info (\"Window map fd not found\");\n", "        exit (EXIT_FAILURE);\n", "    }\n", "    __u64 first_key = 0, next_key = 0;\n", "    __u64 curr_time = time_get_ns ();\n", "    log_debug (\"Current time is %llu\", curr_time);\n", "    while (!bpf_map_get_next_key (map_fd[1], &first_key, &next_key)) {\n", "        if (next_key < (curr_time - buffer_time)) {\n", "            log_debug (\"Deleting stale map entry %llu\", next_key);\n", "            if (bpf_map_delete_elem (map_fd[1], &next_key) != 0) {\n", "                log_info (\"Map element not found\");\n", "            }\n", "        }\n", "        first_key = next_key;\n", "    }\n", "}\n"], "called_function_list": ["time_get_ns"], "call_depth": 1, "humanFuncDescription": [[{"description": "", "author": "", "authorEmail": "", "date": ""}, {}]], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "15": {"capabilities": [], "helperCallParams": {}, "startLine": 228, "endLine": 242, "File": "/home/palani/github/opened_extraction/examples/ebpf-ratelimiter-main/ratelimiting_user.c", "funcName": "trim_space", "developer_inline_comments": [{"start_line": 230, "end_line": 230, "text": "/* skip leading whitespace */"}, {"start_line": 234, "end_line": 234, "text": "/* remove trailing whitespace */"}, {"start_line": 239, "end_line": 239, "text": "/* write null character */"}], "updateMaps": [], "readMaps": [], "input": ["char *str"], "output": "staticchar", "helper": [], "compatibleHookpoints": ["cgroup_device", "cgroup_sock", "lwt_xmit", "flow_dissector", "lwt_seg6local", "sk_skb", "sched_cls", "raw_tracepoint", "sk_msg", "tracepoint", "lwt_out", "cgroup_sock_addr", "raw_tracepoint_writable", "perf_event", "xdp", "kprobe", "sk_reuseport", "sock_ops", "cgroup_sysctl", "sched_act", "cgroup_skb", "lwt_in", "socket_filter"], "source": ["static char *trim_space (char *str)\n", "{\n", "    char *end;\n", "    while (isspace (*str)) {\n", "        str = str + 1;\n", "    }\n", "    end = str + get_length (str) - 1;\n", "    while (end > str && isspace (*end)) {\n", "        end = end - 1;\n", "    }\n", "    *(end + 1) = '\\0';\n", "    return str;\n", "}\n"], "called_function_list": ["get_length"], "call_depth": 1, "humanFuncDescription": [[{"description": "", "author": "", "authorEmail": "", "date": ""}, {}]], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "16": {"capabilities": [], "helperCallParams": {}, "startLine": 244, "endLine": 255, "File": "/home/palani/github/opened_extraction/examples/ebpf-ratelimiter-main/ratelimiting_user.c", "funcName": "strtoi", "developer_inline_comments": [{"start_line": 249, "end_line": 249, "text": "//out of range, extra chars at end"}], "updateMaps": [], "readMaps": [], "input": ["const char *str"], "output": "staticint", "helper": ["strtol"], "compatibleHookpoints": ["cgroup_sysctl"], "source": ["static int strtoi (const char *str)\n", "{\n", "    char *endptr;\n", "    errno = 0;\n", "    long long_var = strtol (str, & endptr, 10);\n", "    if (errno == ERANGE || *endptr != '\\0' || str == endptr) {\n", "        fprintf (stderr, \"out of range\");\n", "    }\n", "    return (int) long_var;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [[{"description": "", "author": "", "authorEmail": "", "date": ""}, {}]], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "17": {"capabilities": [{"capability": "map_update", "map_update": [{"Project": "libbpf", "Return Type": "int", "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_map_update_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}", "{Type:  const void ,Var: *value}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_update"]}]}], "helperCallParams": {}, "startLine": 257, "endLine": 270, "File": "/home/palani/github/opened_extraction/examples/ebpf-ratelimiter-main/ratelimiting_user.c", "funcName": "update_ports", "developer_inline_comments": [], "updateMaps": [" map_fd[4]"], "readMaps": [], "input": ["char *ports"], "output": "staticvoid", "helper": ["bpf_map_update_elem"], "compatibleHookpoints": ["cgroup_device", "cgroup_sock", "lwt_xmit", "flow_dissector", "lwt_seg6local", "sk_skb", "sched_cls", "raw_tracepoint", "sk_msg", "tracepoint", "lwt_out", "cgroup_sock_addr", "raw_tracepoint_writable", "perf_event", "xdp", "kprobe", "sk_reuseport", "sock_ops", "cgroup_sysctl", "sched_act", "cgroup_skb", "lwt_in", "socket_filter"], "source": ["static void update_ports (char *ports)\n", "{\n", "    char *ptr, *tmp;\n", "    uint16_t port = 0;\n", "    uint8_t pval = 1;\n", "    tmp = strdup (ports);\n", "    while ((ptr = strsep (&tmp, delim)) != NULL) {\n", "        ptr = trim_space (ptr);\n", "        port = (uint16_t) (strtoi (ptr));\n", "        bpf_map_update_elem (map_fd[4], &port, &pval, 0);\n", "    }\n", "    free (tmp);\n", "}\n"], "called_function_list": ["strsep", "trim_space", "strtoi"], "call_depth": 2, "humanFuncDescription": [[{"description": "", "author": "", "authorEmail": "", "date": ""}, {}]], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "18": {"capabilities": [{"capability": "map_update", "map_update": [{"Project": "libbpf", "Return Type": "int", "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_map_update_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}", "{Type:  const void ,Var: *value}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_update"]}]}], "helperCallParams": {}, "startLine": 272, "endLine": 423, "File": "/home/palani/github/opened_extraction/examples/ebpf-ratelimiter-main/ratelimiting_user.c", "funcName": "main", "developer_inline_comments": [{"start_line": 287, "end_line": 287, "text": "/* Parse commands line args */"}, {"start_line": 317, "end_line": 317, "text": "/* Not honoured as of now */"}, {"start_line": 345, "end_line": 345, "text": "/* Get the previous program's map fd in the chain */"}, {"start_line": 351, "end_line": 352, "text": "/* Update current prog fd in the last prog map fd,\n     * so it can chain the current one */"}, {"start_line": 357, "end_line": 357, "text": "/* closing map fd to avoid stale map */"}, {"start_line": 369, "end_line": 373, "text": "/* Map FDs are sequenced same as they are defined in the bpf program ie.,\n     * map_fd[0] = rl_config_map, map_fd[1] = rl_window_map\n     * map_fd[2] = rl_recv_count_map, map_fd[3] = rl_drop_count_map\n     * map_fd[4] = rl_ports_map\n     * map_fd[5] = xdp_rl_ingress_next_prog*/"}, {"start_line": 408, "end_line": 408, "text": "/* Handle signals and exit clean */"}, {"start_line": 418, "end_line": 419, "text": "/* Keep deleting the stale map entries periodically *\n         * TODO Check if LRU maps can be used.              */"}], "updateMaps": [" map_fd [2]", " prev_prog_map_fd", " map_fd [0]", " map_fd [3]"], "readMaps": [], "input": ["int argc", " char **argv"], "output": "int", "helper": ["bpf_map_update_elem"], "compatibleHookpoints": ["cgroup_device", "cgroup_sock", "lwt_xmit", "flow_dissector", "lwt_seg6local", "sk_skb", "sched_cls", "raw_tracepoint", "sk_msg", "tracepoint", "lwt_out", "cgroup_sock_addr", "raw_tracepoint_writable", "perf_event", "xdp", "kprobe", "sk_reuseport", "sock_ops", "cgroup_sysctl", "sched_act", "cgroup_skb", "lwt_in", "socket_filter"], "source": ["int main (int argc, char **argv)\n", "{\n", "    int longindex = 0, rate = 0, opt;\n", "    int ret = EXIT_SUCCESS;\n", "    char bpf_obj_file [256];\n", "    char ports [2048];\n", "    verbosity = LOG_INFO;\n", "\n", "#ifdef __linux__\n", "    struct rlimit r = {RLIM_INFINITY, RLIM_INFINITY}\n", "    ;\n", "\n", "#endif\n", "    int len = 0;\n", "    snprintf (bpf_obj_file, sizeof (bpf_obj_file), \"%s_kern.o\", argv[0]);\n", "    memset (&ports, 0, 2048);\n", "    while ((opt = getopt_long (argc, argv, \"h\", long_options, &longindex)) != -1) {\n", "        switch (opt) {\n", "        case 'r' :\n", "            rate = strtoi (optarg);\n", "            break;\n", "        case 'i' :\n", "            ifindex = if_nametoindex (optarg);\n", "            break;\n", "        case 'v' :\n", "            if (optarg) {\n", "                verbosity = strtoi (optarg);\n", "            }\n", "            break;\n", "        case 'm' :\n", "            if (optarg) {\n", "                len = get_length (optarg);\n", "                strncpy (prev_prog_map, optarg, len);\n", "                prev_prog_map[len] = '\\0';\n", "            }\n", "            break;\n", "        case 'p' :\n", "            if (optarg) {\n", "                len = get_length (optarg);\n", "                strncpy (ports, optarg, len);\n", "                ports[len] = '\\0';\n", "            }\n", "            break;\n", "        case 'd' :\n", "            break;\n", "        case 'h' :\n", "        default :\n", "            usage (argv);\n", "            return EXIT_FAILURE;\n", "        }\n", "    }\n", "\n", "#ifdef __linux__\n", "    if (setrlimit (RLIMIT_MEMLOCK, &r)) {\n", "        perror (\"setrlimit(RLIMIT_MEMLOCK)\");\n", "        exit (EXIT_FAILURE);\n", "    }\n", "\n", "#endif\n", "    set_logfile ();\n", "    __u64 ckey = 0, rkey = 0, dkey = 0, pkey = 0;\n", "    __u64 recv_count = 0, drop_count = 0;\n", "    if (load_bpf_file (bpf_obj_file)) {\n", "        log_err (\"Failed to load bpf program\");\n", "        return 1;\n", "    }\n", "    if (!prog_fd[0]) {\n", "        log_err (\"Failed to get bpf program fd\")\n", "        return 1;\n", "    }\n", "    int prev_prog_map_fd = bpf_obj_get (prev_prog_map);\n", "    if (prev_prog_map_fd < 0) {\n", "        log_err (\"Failed to fetch previous xdp function in the chain\");\n", "        exit (EXIT_FAILURE);\n", "    }\n", "    if (bpf_map_update_elem (prev_prog_map_fd, &pkey, &(prog_fd[0]), 0)) {\n", "        log_err (\"Failed to update prog fd in the chain\");\n", "        exit (EXIT_FAILURE);\n", "    }\n", "    close (prev_prog_map_fd);\n", "    int next_prog_map_fd = bpf_obj_get (xdp_rl_ingress_next_prog);\n", "    if (next_prog_map_fd < 0) {\n", "        log_info (\"Failed to fetch next prog map fd, creating one\");\n", "        if (bpf_obj_pin (map_fd[5], xdp_rl_ingress_next_prog)) {\n", "            log_info (\"Failed to pin next prog fd map\");\n", "            exit (EXIT_FAILURE);\n", "        }\n", "    }\n", "    if (!map_fd[0]) {\n", "        log_err (\"Failed to fetch config map\");\n", "        return -1;\n", "    }\n", "    ret = bpf_map_update_elem (map_fd [0], & ckey, & rate, 0);\n", "    if (ret) {\n", "        perror (\"Failed to update config map\");\n", "        return 1;\n", "    }\n", "    if (!map_fd[2]) {\n", "        log_err (\"Failed to fetch receive count map\");\n", "        return -1;\n", "    }\n", "    ret = bpf_map_update_elem (map_fd [2], & rkey, & recv_count, 0);\n", "    if (ret) {\n", "        perror (\"Failed to update receive count map\");\n", "        return 1;\n", "    }\n", "    if (!map_fd[3]) {\n", "        log_err (\"Failed to fetch drop count map\");\n", "        return -1;\n", "    }\n", "    ret = bpf_map_update_elem (map_fd [3], & dkey, & drop_count, 0);\n", "    if (ret) {\n", "        perror (\"Failed to update drop count map\");\n", "        return 1;\n", "    }\n", "    if (get_length (ports)) {\n", "        log_info (\"Configured port list is %s\\n\", ports);\n", "        update_ports (ports);\n", "    }\n", "    signal (SIGINT, signal_handler);\n", "    signal (SIGTERM, signal_handler);\n", "\n", "#ifdef __linux__\n", "    signal (SIGHUP, signal_handler);\n", "\n", "#endif\n", "    while (1) {\n", "        sleep (60);\n", "        delete_stale_entries ();\n", "        fflush (info);\n", "    }\n", "}\n"], "called_function_list": ["update_ports", "set_logfile", "delete_stale_entries", "strtoi", "get_length", "usage"], "call_depth": 3, "humanFuncDescription": [[{"description": "", "author": "", "authorEmail": "", "date": ""}, {}]], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "19": {"capabilities": [{"capability": "map_update", "map_update": [{"Project": "libbpf", "Return Type": "int", "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_map_update_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}", "{Type:  const void ,Var: *value}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_update"]}]}, {"capability": "pkt_stop_processing_drop_packet", "pkt_stop_processing_drop_packet": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_DROP", "Return": 1, "Description": "will drop the packet right at the driver level without wasting any further resources. This is in particular useful for BPF programs implementing DDoS mitigation mechanisms or firewalling in general.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_stop_processing_drop_packet"]}]}, {"capability": "map_read", "map_read": [{"Project": "libbpf", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}, {"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_PASS", "Return": 2, "Description": "The XDP_PASS return code means that the packet is allowed to be passed up to the kernel\u2019s networking stack. Meaning, the current CPU that was processing this packet now allocates a skb, populates it, and passes it onwards into the GRO engine. This would be equivalent to the default packet handling behavior without XDP.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_go_to_next_module"]}]}, {"capability": "read_sys_info", "read_sys_info": [{"Project": "bcc", "FunctionName": "bpf_ktime_get_ns", "Return Type": "u64", "Description": "u64 bpf_ktime_get_ns(void) Return: u64 number of nanoseconds. Starts at system boot time but stops during suspend. Examples in situ: \"https://github.com/iovisor/bcc/search?q=bpf_ktime_get_ns+path%3Aexamples&type=Code search /examples , \"https://github.com/iovisor/bcc/search?q=bpf_ktime_get_ns+path%3Atools&type=Code search /tools ", "Return": "u64 number of nanoseconds", "Input Prameters": [], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "raw_tracepoint_writable"], "capabilities": ["read_sys_info"]}]}], "helperCallParams": {}, "startLine": 100, "endLine": 276, "File": "/home/palani/github/opened_extraction/examples/ebpf-ratelimiter-main/ratelimiting_kern.c", "funcName": "_xdp_ratelimit", "developer_inline_comments": [{"start_line": 1, "end_line": 1, "text": "// Copyright Contributors to the L3AF Project."}, {"start_line": 2, "end_line": 2, "text": "// SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause)"}, {"start_line": 4, "end_line": 4, "text": "/* Ratelimit incoming TCP connections using XDP */"}, {"start_line": 19, "end_line": 19, "text": "/* TCP flags */"}, {"start_line": 44, "end_line": 44, "text": "/* Stores the ratelimit value(per second) */"}, {"start_line": 45, "end_line": 45, "text": "//Move map defintions to newer format "}, {"start_line": 55, "end_line": 56, "text": "/* Maintains the timestamp of a window and the total number of\n * connections received in that window(window = 1 sec interval) */"}, {"start_line": 65, "end_line": 66, "text": "/* Maintains the total number of connections received(TCP-SYNs)\n * Used only for metrics visibility */"}, {"start_line": 76, "end_line": 77, "text": "/* Maintains the total number of connections dropped as the ratelimit is hit\n * Used only for metrics visibility */"}, {"start_line": 86, "end_line": 86, "text": "/* Maintains the ports to be ratelimited */"}, {"start_line": 97, "end_line": 99, "text": "/* TODO Use atomics or spin locks where naive increments are used depending\n * on the accuracy tests and then do a tradeoff.\n * With 10k connections/sec tests, the error rate is < 3%. */"}, {"start_line": 107, "end_line": 107, "text": "/* Check if it is a valid ethernet packet */"}, {"start_line": 111, "end_line": 111, "text": "/* Ignore other than ethernet packets */"}, {"start_line": 117, "end_line": 117, "text": "/* Ignore other than IP packets */"}, {"start_line": 122, "end_line": 122, "text": "/* Ignore other than TCP packets */"}, {"start_line": 126, "end_line": 126, "text": "/* Check if its valid tcp packet */"}, {"start_line": 134, "end_line": 134, "text": "/* Ignore other than TCP-SYN packets */"}, {"start_line": 136, "end_line": 136, "text": "//bpf_printk(\"Ignoring %d \\n\",6);"}, {"start_line": 141, "end_line": 141, "text": "/* Ignore TCP-SYN-ACK packets */"}, {"start_line": 151, "end_line": 151, "text": "//bpf_printk(\"Check: rate  %d\\n\",rkey);"}, {"start_line": 156, "end_line": 156, "text": "//bpf_printk(\"Set: rate %d\\n\",*rate);"}, {"start_line": 159, "end_line": 159, "text": "//*rate = 5; //IRL Hard coding"}, {"start_line": 162, "end_line": 162, "text": "/* Current time in monotonic clock */"}, {"start_line": 165, "end_line": 165, "text": "/* Used for second to nanoseconds conversions and vice-versa */"}, {"start_line": 168, "end_line": 171, "text": "/* Used for converting decimals points to percentages as decimal points\n     * are not recommended in the kernel.\n     * Ex: 0.3 would be converted as 30 with this multiplication factor to\n     * perform the calculations needed. */"}, {"start_line": 174, "end_line": 177, "text": "/* Round off the current time to form the current window key.\n     * Ex: ts of the incoming connections from the time 16625000000000 till\n     * 166259999999 is rounded off to 166250000000000 to track the incoming\n     * connections received in that one second interval. */"}, {"start_line": 182, "end_line": 182, "text": "/* Previous window is one second before the current window */"}, {"start_line": 185, "end_line": 185, "text": "/* Number of incoming connections in the previous window(second) */"}, {"start_line": 188, "end_line": 188, "text": "/* Number of incoming connections in the current window(second) */"}, {"start_line": 191, "end_line": 191, "text": "/* Total number of incoming connections so far */"}, {"start_line": 194, "end_line": 194, "text": "/* Total number of dropped connections so far */"}, {"start_line": 197, "end_line": 198, "text": "/* Just make the verifier happy, it would never be the case in real as\n     * these two counters are initialised in the user space. */"}, {"start_line": 203, "end_line": 206, "text": "/*\n    bpf_printk(\"cw_key %u\\n\",cw_key);\n    bpf_printk(\"pw_key %u\\n\",pw_key);\n*/"}, {"start_line": 207, "end_line": 207, "text": "/* Increment the total number of incoming connections counter */"}, {"start_line": 213, "end_line": 214, "text": "/* This is the first connection in the current window,\n         * initialize the current window counter. */"}, {"start_line": 218, "end_line": 218, "text": "/* Just make the verifier happy */"}, {"start_line": 224, "end_line": 226, "text": "/* This is the fresh start of system or there have been no\n         * connections in the last second, so make the decision purely based\n         * on the incoming connections in the current window. */"}, {"start_line": 229, "end_line": 230, "text": "/* Connection count in the current window already exceeded the\n             * rate limit so drop this connection. */"}, {"start_line": 235, "end_line": 235, "text": "/* Allow otherwise */"}, {"start_line": 241, "end_line": 244, "text": "/* Calculate the number of connections accepted in last 1 sec from tnow *\n     * considering the connections accepted in previous window and          *\n     * current window based on what % of the sliding window(tnow - 1) falls *\n     * in previous window and what % of it is in the current window         */"}, {"start_line": 254, "end_line": 254, "text": "//uint64_t temp = (*rate) * MULTIPLIER;"}, {"start_line": 255, "end_line": 255, "text": "//uint64_t temp = 5;"}, {"start_line": 257, "end_line": 257, "text": "//bpf_printk(\"temp: %d\\n\",temp);"}, {"start_line": 259, "end_line": 259, "text": "//int c = (total_count > temp);"}, {"start_line": 260, "end_line": 260, "text": "//bpf_printk(\"c: %d\\n\",c);"}, {"start_line": 262, "end_line": 262, "text": "//if (c )"}, {"start_line": 264, "end_line": 264, "text": "//if (total_count > ((*rate) * MULTIPLIER))"}, {"start_line": 266, "end_line": 267, "text": "/* Connection count from tnow to (tnow-1) exceeded the rate limit,\n         * so drop this connection. */"}, {"start_line": 272, "end_line": 272, "text": "/* Allow otherwise */"}], "updateMaps": [" rl_window_map"], "readMaps": [" rl_recv_count_map", " rl_drop_count_map", " rl_window_map", "  rl_window_map", " rl_config_map"], "input": ["struct xdp_md *ctx"], "output": "static__always_inlineint", "helper": ["bpf_map_update_elem", "XDP_DROP", "bpf_map_lookup_elem", "XDP_PASS", "bpf_ktime_get_ns"], "compatibleHookpoints": ["xdp"], "source": ["static __always_inline int _xdp_ratelimit (struct xdp_md *ctx)\n", "{\n", "    void *data_end = (void *) (long) ctx->data_end;\n", "    void *data = (void *) (long) ctx->data;\n", "    struct ethhdr *eth = data;\n", "    if (data + sizeof (*eth) > data_end)\n", "        return XDP_DROP;\n", "    uint16_t eth_type = eth->h_proto;\n", "    if (ntohs (eth_type) != ETH_P_IP) {\n", "        return XDP_PASS;\n", "    }\n", "    struct iphdr *iph = data + sizeof (struct ethhdr);\n", "    if (iph + 1 > data_end)\n", "        return XDP_PASS;\n", "    if (iph->protocol != IPPROTO_TCP)\n", "        return XDP_PASS;\n", "    struct tcphdr *tcph = (struct tcphdr *) (iph + 1);\n", "    if (tcph + 1 > data_end)\n", "        return XDP_PASS;\n", "    bpf_printk (\"NEW: TCP Syn : %d\\n\", tcph->syn & TCP_FLAGS);\n", "    if (!(tcph->syn & TCP_FLAGS)) {\n", "        return XDP_PASS;\n", "    }\n", "    if (tcph->ack & TCP_FLAGS)\n", "        return XDP_PASS;\n", "    uint16_t dstport = bpf_ntohs (tcph -> dest);\n", "    uint64_t rkey = 0;\n", "    uint64_t *rate = bpf_map_lookup_elem (&rl_config_map, &rkey);\n", "    if (!rate) {\n", "        bpf_printk (\"Return: rate %d\\n\", rkey);\n", "        return XDP_PASS;\n", "    }\n", "    else {\n", "    }\n", "    bpf_printk (\"Allowed connections rate: %d\\n\", *rate);\n", "    uint64_t tnow = bpf_ktime_get_ns ();\n", "    uint64_t NANO = 1000000000;\n", "    uint64_t MULTIPLIER = 100;\n", "    uint64_t cw_key = (tnow / NANO) * NANO;\n", "    uint64_t pw_key = cw_key - NANO;\n", "    uint64_t *pw_count = bpf_map_lookup_elem (&rl_window_map, &pw_key);\n", "    uint32_t *cw_count = bpf_map_lookup_elem (&rl_window_map, &cw_key);\n", "    uint64_t *in_count = bpf_map_lookup_elem (&rl_recv_count_map, &rkey);\n", "    uint64_t *drop_count = bpf_map_lookup_elem (&rl_drop_count_map, &rkey);\n", "    if (!in_count || !drop_count) {\n", "        bpf_printk (\"count null %d\\n\", rate);\n", "        return XDP_PASS;\n", "    }\n", "    (*in_count)++;\n", "    if (!cw_count) {\n", "        uint64_t init_count = 0;\n", "        bpf_map_update_elem (&rl_window_map, &cw_key, &init_count, BPF_NOEXIST);\n", "        cw_count = bpf_map_lookup_elem (& rl_window_map, & cw_key);\n", "        if (!cw_count)\n", "            return XDP_PASS;\n", "    }\n", "    if (!pw_count) {\n", "        if (*cw_count >= *rate) {\n", "            (*drop_count)++;\n", "            bpf_printk (\"DROPPING CONNECTION: CT  %d\\n\", *cw_count);\n", "            return XDP_DROP;\n", "        }\n", "        (*cw_count)++;\n", "        bpf_printk (\"ALLOWING CONNECTION: CT %d\\n\", *cw_count);\n", "        return XDP_PASS;\n", "    }\n", "    uint64_t pw_weight = MULTIPLIER - (uint64_t) (((tnow - cw_key) * MULTIPLIER) / NANO);\n", "    uint64_t total_count = (uint64_t) ((pw_weight *(* pw_count)) +(*cw_count) * MULTIPLIER);\n", "    bpf_printk (\"tot_ct : %d\\n\", total_count);\n", "    bpf_printk (\"cw1_ct : %d\\n\", *cw_count);\n", "    if (total_count > (*rate)) {\n", "        (*drop_count)++;\n", "        bpf_printk (\"DROPPING CONNECTION: CT  %d\\n\", *cw_count);\n", "        return XDP_DROP;\n", "    }\n", "    (*cw_count)++;\n", "    bpf_printk (\"ALLOWING CONNECTION: CT  %d\\n\", *cw_count);\n", "    return XDP_PASS;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [[{"description": "This function implements a TCP connection rate limiter. Takes in input a packet in struct xdp_mp * ctx form. It first checks if input is a valid ethernet packet. It ignores other than ethernet packets, other than ip packets, other than tcp packets. If the packet is a valid tcp packet, it check if the packet is a TCP syn packet as it performs connection rate limiting it ignores packets other than tcp syn packets and even tcp syn ack packets. If the packet is a TCP SYN hence connection establishment packet, the code reads a map rl_config_map with key set to number 0 and receives the allowed rate of connections configured from the userspace if the map read fails, the function returns XDP_PASS else it continues execution. Next it checks which time window the packet corresponds to, a window is essentially a 1 second sliding window calculated by calling bpf_ktime_get_ns and getting the current time. Current time is used to calculate current window cw_key and previous window(current - 1 s) is used to calculate previous window pw_key. The function then performs a bunch of map reads, 1) rl_window_map twice with keys cw_key and pw_key which gives the cw_count and pw_count essentially current window packet count and previous window packet count. 2) rl_recv_count_map with key set to number 0 which tracks number of incommming connections 3) rl_drop_count_map with key set to number 0 which tracks number of dropped connections. If this is the first packet in this window then the function updates the map rl_window_map with key cw_key and value 0 and sets the cw_count to 0. If this is a new connection and no previous connection were present then the rate limiter allows connection if cw_count < rate and returns XDP_PASS else it drops the connection and returns XDP_DROP. If there had been previous connections then it calculates the number of connections accepted in last 1 sec from current time, if the total connections are higher than allowed rate, it drops the connection and returns XDP_DROP else it allows the connection and returns XDP_PASS. The function also updates the current window count and drop count before returning.", "author": "Dushyant Behl", "authorEmail": "dushyantbehl@in.ibm.com", "date": "2023-02-20"}, {}]], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "20": {"capabilities": [{"capability": "map_update", "map_update": [{"Project": "libbpf", "Return Type": "int", "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_map_update_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}", "{Type:  const void ,Var: *value}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_update"]}]}, {"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}, {"capability": "map_read", "map_read": [{"Project": "libbpf", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}, {"capability": "pkt_stop_processing_drop_packet", "pkt_stop_processing_drop_packet": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_SHOT", "Return": 2, "Description": "instructs the kernel to drop the packet, meaning, upper layers of the networking stack will never see the skb on ingress and similarly the packet will never be submitted for transmission on egress. TC_ACT_SHOT and TC_ACT_STOLEN are both similar in nature with few differences: TC_ACT_SHOT will indicate to the kernel that the skb was released through kfree_skb() and return NET_XMIT_DROP to the callers for immediate feedback, whereas TC_ACT_STOLEN will release the skb through consume_skb() and pretend to upper layers that the transmission was successful through NET_XMIT_SUCCESS. The perf\u2019s drop monitor which records traces of kfree_skb() will therefore also not see any drop indications from TC_ACT_STOLEN since its semantics are such that the skb has been \u201cconsumed\u201d or queued but certainly not \"dropped\".", "compatible_hookpoints": ["sched_cls", "sched_act"], "capabilities": ["pkt_stop_processing_drop_packet"]}]}, {"capability": "read_sys_info", "read_sys_info": [{"Project": "bcc", "FunctionName": "bpf_ktime_get_ns", "Return Type": "u64", "Description": "u64 bpf_ktime_get_ns(void) Return: u64 number of nanoseconds. Starts at system boot time but stops during suspend. Examples in situ: \"https://github.com/iovisor/bcc/search?q=bpf_ktime_get_ns+path%3Aexamples&type=Code search /examples , \"https://github.com/iovisor/bcc/search?q=bpf_ktime_get_ns+path%3Atools&type=Code search /tools ", "Return": "u64 number of nanoseconds", "Input Prameters": [], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "raw_tracepoint_writable"], "capabilities": ["read_sys_info"]}]}], "helperCallParams": {}, "startLine": 64, "endLine": 128, "File": "/home/palani/github/opened_extraction/examples/ebpf-ratelimiter-main/transformed/ratelimiting_kern-TC.c", "funcName": "_xdp_ratelimit", "developer_inline_comments": [], "updateMaps": [" rl_window_map"], "readMaps": [" rl_recv_count_map", " rl_drop_count_map", " rl_ports_map", " rl_window_map", "  rl_window_map", " rl_config_map"], "input": ["struct  __sk_buff *ctx"], "output": "static__always_inlineint", "helper": ["bpf_map_update_elem", "TC_ACT_OK", "bpf_map_lookup_elem", "TC_ACT_SHOT", "bpf_ktime_get_ns"], "compatibleHookpoints": ["sched_cls", "sched_act"], "source": ["static __always_inline int _xdp_ratelimit (struct  __sk_buff *ctx)\n", "{\n", "    void *data_end = (void *) (long) ctx->data_end;\n", "    void *data = (void *) (long) ctx->data;\n", "    struct ethhdr *eth = data;\n", "    if (data + sizeof (*eth) > data_end)\n", "        return TC_ACT_SHOT;\n", "    uint16_t eth_type = ctx->protocol;\n", "    if (ntohs (eth_type) != ETH_P_IP) {\n", "        return TC_ACT_OK;\n", "    }\n", "    struct iphdr *iph = data + sizeof (struct ethhdr);\n", "    if (iph + 1 > data_end)\n", "        return TC_ACT_OK;\n", "    if (iph->protocol != IPPROTO_TCP)\n", "        return TC_ACT_OK;\n", "    struct tcphdr *tcph = (struct tcphdr *) (iph + 1);\n", "    if (tcph + 1 > data_end)\n", "        return TC_ACT_OK;\n", "    if (!(tcph->syn & TCP_FLAGS))\n", "        return TC_ACT_OK;\n", "    if (tcph->ack & TCP_FLAGS)\n", "        return TC_ACT_OK;\n", "    uint16_t dstport = bpf_ntohs (tcph -> dest);\n", "    if (!bpf_map_lookup_elem (&rl_ports_map, &dstport))\n", "        return TC_ACT_OK;\n", "    uint64_t rkey = 0;\n", "    uint64_t *rate = bpf_map_lookup_elem (&rl_config_map, &rkey);\n", "    if (!rate)\n", "        return TC_ACT_OK;\n", "    uint64_t tnow = bpf_ktime_get_ns ();\n", "    uint64_t NANO = 1000000000;\n", "    uint64_t MULTIPLIER = 100;\n", "    uint64_t cw_key = tnow / NANO * NANO;\n", "    uint64_t pw_key = cw_key - NANO;\n", "    uint64_t *pw_count = bpf_map_lookup_elem (&rl_window_map, &pw_key);\n", "    uint32_t *cw_count = bpf_map_lookup_elem (&rl_window_map, &cw_key);\n", "    uint64_t *in_count = bpf_map_lookup_elem (&rl_recv_count_map, &rkey);\n", "    uint64_t *drop_count = bpf_map_lookup_elem (&rl_drop_count_map, &rkey);\n", "    if (!in_count || !drop_count)\n", "        return TC_ACT_OK;\n", "    (*in_count)++;\n", "    if (!cw_count) {\n", "        uint64_t init_count = 0;\n", "        bpf_map_update_elem (&rl_window_map, &cw_key, &init_count, BPF_NOEXIST);\n", "        cw_count = bpf_map_lookup_elem (& rl_window_map, & cw_key);\n", "        if (!cw_count)\n", "            return TC_ACT_OK;\n", "    }\n", "    if (!pw_count) {\n", "        if (*cw_count >= *rate) {\n", "            (*drop_count)++;\n", "            return TC_ACT_SHOT;\n", "        }\n", "        (*cw_count)++;\n", "        return TC_ACT_OK;\n", "    }\n", "    uint64_t pw_weight = MULTIPLIER - (uint64_t) (((tnow - cw_key) * MULTIPLIER) / NANO);\n", "    uint64_t total_count = (uint64_t) ((pw_weight *(* pw_count)) +(*cw_count) * MULTIPLIER);\n", "    if (total_count > ((*rate) * MULTIPLIER)) {\n", "        (*drop_count)++;\n", "        return TC_ACT_SHOT;\n", "    }\n", "    (*cw_count)++;\n", "    return TC_ACT_OK;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [[{"description": "This function implements a TCP connection rate limiter. Takes in input a packet in struct xdp_mp * ctx form. It first checks if input is a valid ethernet packet. It ignores other than ethernet packets, other than ip packets, other than tcp packets. If the packet is a valid tcp packet, it check if the packet is a TCP syn packet as it performs connection rate limiting it ignores packets other than tcp syn packets and even tcp syn ack packets. If the packet is a TCP SYN hence connection establishment packet, the code reads a map rl_config_map with key set to number 0 and receives the allowed rate of connections configured from the userspace if the map read fails, the function returns TC_ACT_OK else it continues execution. Next it checks which time window the packet corresponds to, a window is essentially a 1 second sliding window calculated by calling bpf_ktime_get_ns and getting the current time. Current time is used to calculate current window cw_key and previous window(current - 1 s) is used to calculate previous window pw_key. The function then performs a bunch of map reads, 1) rl_window_map twice with keys cw_key and pw_key which gives the cw_count and pw_count essentially current window packet count and previous window packet count. 2) rl_recv_count_map with key set to number 0 which tracks number of incommming connections 3) rl_drop_count_map with key set to number 0 which tracks number of dropped connections. If this is the first packet in this window then the function updates the map rl_window_map with key cw_key and value 0 and sets the cw_count to 0. If this is a new connection and no previous connection were present then the rate limiter allows connection if cw_count < rate and returns TC_ACT_OK else it drops the connection and returns TC_ACT_SHOT. If there had been previous connections then it calculates the number of connections accepted in last 1 sec from current time, if the total connections are higher than allowed rate, it drops the connection and returns TC_ACT_SHOT else it allows the connection and returns TC_ACT_OK. The function also updates the current window count and drop count before returning.", "author": "Dushyant Behl", "authorEmail": "dushyantbehl@in.ibm.com", "date": "2023-02-20"}, {}]], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "21": {"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_PASS", "Return": 2, "Description": "The XDP_PASS return code means that the packet is allowed to be passed up to the kernel\u2019s networking stack. Meaning, the current CPU that was processing this packet now allocates a skb, populates it, and passes it onwards into the GRO engine. This would be equivalent to the default packet handling behavior without XDP.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_go_to_next_module"]}]}, {"capability": "pkt_stop_processing_drop_packet", "pkt_stop_processing_drop_packet": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_DROP", "Return": 1, "Description": "will drop the packet right at the driver level without wasting any further resources. This is in particular useful for BPF programs implementing DDoS mitigation mechanisms or firewalling in general.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_stop_processing_drop_packet"]}]}], "helperCallParams": {}, "startLine": 279, "endLine": 289, "File": "/home/palani/github/opened_extraction/examples/ebpf-ratelimiter-main/ratelimiting_kern.c", "funcName": "_xdp_ratelimiting", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct xdp_md *ctx"], "output": "int", "helper": ["XDP_PASS", "XDP_DROP"], "compatibleHookpoints": ["xdp"], "source": ["int _xdp_ratelimiting (struct xdp_md *ctx)\n", "{\n", "    bpf_printk (\"entered xdp_rate_limiter\\n\");\n", "    int rc = _xdp_ratelimit (ctx);\n", "    if (rc == XDP_DROP) {\n", "        return XDP_DROP;\n", "    }\n", "    return XDP_PASS;\n", "}\n"], "called_function_list": ["_xdp_ratelimit"], "call_depth": 1, "humanFuncDescription": [[{"description": "This is a wrapper function which calls the base function _xdp_ratelimit with the same arument passed to it and returns its value", "author": "Dushyant Behl", "authorEmail": "dushyantbehl@in.ibm.com", "date": "2023-02-20"}, {}]], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "22": {"capabilities": [{"capability": "pkt_stop_processing_drop_packet", "pkt_stop_processing_drop_packet": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_SHOT", "Return": 2, "Description": "instructs the kernel to drop the packet, meaning, upper layers of the networking stack will never see the skb on ingress and similarly the packet will never be submitted for transmission on egress. TC_ACT_SHOT and TC_ACT_STOLEN are both similar in nature with few differences: TC_ACT_SHOT will indicate to the kernel that the skb was released through kfree_skb() and return NET_XMIT_DROP to the callers for immediate feedback, whereas TC_ACT_STOLEN will release the skb through consume_skb() and pretend to upper layers that the transmission was successful through NET_XMIT_SUCCESS. The perf\u2019s drop monitor which records traces of kfree_skb() will therefore also not see any drop indications from TC_ACT_STOLEN since its semantics are such that the skb has been \u201cconsumed\u201d or queued but certainly not \"dropped\".", "compatible_hookpoints": ["sched_cls", "sched_act"], "capabilities": ["pkt_stop_processing_drop_packet"]}]}, {"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 131, "endLine": 138, "File": "/home/palani/github/opened_extraction/examples/ebpf-ratelimiter-main/transformed/ratelimiting_kern-TC.c", "funcName": "_xdp_ratelimiting", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __sk_buff *ctx"], "output": "int", "helper": ["TC_ACT_SHOT", "TC_ACT_OK", "bpf_tail_call"], "compatibleHookpoints": ["sched_cls", "sched_act"], "source": ["int _xdp_ratelimiting (struct  __sk_buff *ctx)\n", "{\n", "    int rc = _xdp_ratelimit (ctx);\n", "    if (rc == TC_ACT_SHOT) {\n", "        return TC_ACT_SHOT;\n", "    }\n", "    bpf_tail_call (ctx, &xdp_rl_ingress_next_prog, 0);\n", "    return TC_ACT_OK;\n", "}\n"], "called_function_list": ["_xdp_ratelimit"], "call_depth": 1, "humanFuncDescription": [[{"description": "This is a wrapper function which calls the base function _xdp_ratelimit with the same arument passed to it and returns its value", "author": "Dushyant Behl", "authorEmail": "dushyantbehl@in.ibm.com", "date": "2023-02-20"}, {}]], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "23": {"capabilities": [], "helperCallParams": {}, "startLine": 38, "endLine": 44, "File": "/home/palani/github/opened_extraction/examples/ebpf-ratelimiter-main/ratelimiting_user.c", "funcName": "strsep", "developer_inline_comments": [{"start_line": 1, "end_line": 1, "text": "// Copyright Contributors to the L3AF Project."}, {"start_line": 2, "end_line": 2, "text": "// SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause)"}, {"start_line": 4, "end_line": 4, "text": "/* Ratelimit incoming TCP connections with sliding window approach */"}, {"start_line": 24, "end_line": 24, "text": "//#include <bpf/bpf_helpers.h>"}, {"start_line": 27, "end_line": 27, "text": "//#include \"bpf_load.h\""}, {"start_line": 29, "end_line": 29, "text": "//#include \"bpf_util.h\""}], "updateMaps": [], "readMaps": [], "input": ["char **stringp", " const char *delim"], "output": "char", "helper": [], "compatibleHookpoints": ["lwt_seg6local", "lwt_out", "kprobe", "sock_ops", "sk_skb", "sk_msg", "sched_cls", "raw_tracepoint_writable", "cgroup_sock", "tracepoint", "sched_act", "cgroup_skb", "lwt_xmit", "flow_dissector", "cgroup_device", "raw_tracepoint", "xdp", "socket_filter", "cgroup_sock_addr", "lwt_in", "sk_reuseport", "cgroup_sysctl", "perf_event"], "source": ["char *strsep (char **stringp, const char *delim)\n", "{\n", "    static char *next_token = NULL;\n", "    char *input = *stringp;\n", "    *stringp = strtok_s (input, delim, &next_token);\n", "    return input;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [[{"description": "", "author": "", "authorEmail": "", "date": ""}, {}]], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "24": {"capabilities": [], "helperCallParams": {}, "startLine": 47, "endLine": 58, "File": "/home/palani/github/opened_extraction/examples/ebpf-ratelimiter-main/ratelimiting_user.c", "funcName": "gettimeofday", "developer_inline_comments": [{"start_line": 54, "end_line": 54, "text": "// Convert to usec."}], "updateMaps": [], "readMaps": [], "input": ["struct timeval *tv", " struct timezone *tz"], "output": "int", "helper": [], "compatibleHookpoints": ["lwt_seg6local", "lwt_out", "kprobe", "sock_ops", "sk_skb", "sk_msg", "sched_cls", "raw_tracepoint_writable", "cgroup_sock", "tracepoint", "sched_act", "cgroup_skb", "lwt_xmit", "flow_dissector", "cgroup_device", "raw_tracepoint", "xdp", "socket_filter", "cgroup_sock_addr", "lwt_in", "sk_reuseport", "cgroup_sysctl", "perf_event"], "source": ["int gettimeofday (struct timeval *tv, struct timezone *tz)\n", "{\n", "    FILETIME ft;\n", "    ULARGE_INTEGER ui;\n", "    GetSystemTimeAsFileTime (&ft);\n", "    ui.LowPart = ft.dwLowDateTime;\n", "    ui.HighPart = ft.dwHighDateTime;\n", "    ui.QuadPart /= 10;\n", "    tv->tv_sec = (long) (ui.QuadPart / 1000000);\n", "    tv->tv_usec = ui.QuadPart % 1000000;\n", "    return 0;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [[{"description": "", "author": "", "authorEmail": "", "date": ""}, {}]], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "25": {"capabilities": [], "helperCallParams": {}, "startLine": 85, "endLine": 104, "File": "/home/palani/github/opened_extraction/examples/ebpf-ratelimiter-main/ratelimiting_user.c", "funcName": "usage", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["char *argv []"], "output": "staticvoid", "helper": [], "compatibleHookpoints": ["lwt_seg6local", "lwt_out", "kprobe", "sock_ops", "sk_skb", "sk_msg", "sched_cls", "raw_tracepoint_writable", "cgroup_sock", "tracepoint", "sched_act", "cgroup_skb", "lwt_xmit", "flow_dissector", "cgroup_device", "raw_tracepoint", "xdp", "socket_filter", "cgroup_sock_addr", "lwt_in", "sk_reuseport", "cgroup_sysctl", "perf_event"], "source": ["static void usage (char *argv [])\n", "{\n", "    int i;\n", "    printf (\"\\nDOCUMENTATION:\\n%s\\n\", __doc__);\n", "    printf (\"\\n\");\n", "    printf (\" Usage: %s (options-see-below)\\n\", argv[0]);\n", "    printf (\" Listing options:\\n\");\n", "    for (i = 0; long_options[i].name != 0; i++) {\n", "        printf (\" --%-12s\", long_options[i].name);\n", "        if (long_options[i].flag != NULL)\n", "            printf (\" flag (internal value:%d)\", *long_options[i].flag);\n", "        else\n", "            printf (\" short-option: -%c\", long_options[i].val);\n", "        printf (\"\\n\");\n", "    }\n", "    printf (\"\\n\");\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [[{"description": "", "author": "", "authorEmail": "", "date": ""}, {}]], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "26": {"capabilities": [], "helperCallParams": {}, "startLine": 107, "endLine": 118, "File": "/home/palani/github/opened_extraction/examples/ebpf-ratelimiter-main/ratelimiting_user.c", "funcName": "log_timestamp", "developer_inline_comments": [{"start_line": 106, "end_line": 106, "text": "/* Set log timestamps */"}], "updateMaps": [], "readMaps": [], "input": ["char *log_ts"], "output": "void", "helper": [], "compatibleHookpoints": ["lwt_seg6local", "lwt_out", "kprobe", "sock_ops", "sk_skb", "sk_msg", "sched_cls", "raw_tracepoint_writable", "cgroup_sock", "tracepoint", "sched_act", "cgroup_skb", "lwt_xmit", "flow_dissector", "cgroup_device", "raw_tracepoint", "xdp", "socket_filter", "cgroup_sock_addr", "lwt_in", "sk_reuseport", "cgroup_sysctl", "perf_event"], "source": ["void log_timestamp (char *log_ts)\n", "{\n", "    struct timeval tv;\n", "    time_t nowtime;\n", "    struct tm *nowtm;\n", "    char tmbuf [TIMESTAMP_LEN];\n", "    gettimeofday (&tv, NULL);\n", "    nowtime = tv.tv_sec;\n", "    nowtm = localtime (& nowtime);\n", "    strftime (tmbuf, DATE_LEN, \"%Y-%m-%d %H:%M:%S\", nowtm);\n", "    snprintf (log_ts, DATE_LEN + TIMESTAMP_LEN, \"%s.%06ld\", tmbuf, tv.tv_usec);\n", "}\n"], "called_function_list": ["gettimeofday"], "call_depth": 1, "humanFuncDescription": [[{"description": "", "author": "", "authorEmail": "", "date": ""}, {}]], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "27": {"capabilities": [], "helperCallParams": {}, "startLine": 120, "endLine": 129, "File": "/home/palani/github/opened_extraction/examples/ebpf-ratelimiter-main/ratelimiting_user.c", "funcName": "get_length", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const char *str"], "output": "staticint", "helper": [], "compatibleHookpoints": ["lwt_seg6local", "lwt_out", "kprobe", "sock_ops", "sk_skb", "sk_msg", "sched_cls", "raw_tracepoint_writable", "cgroup_sock", "tracepoint", "sched_act", "cgroup_skb", "lwt_xmit", "flow_dissector", "cgroup_device", "raw_tracepoint", "xdp", "socket_filter", "cgroup_sock_addr", "lwt_in", "sk_reuseport", "cgroup_sysctl", "perf_event"], "source": ["static int get_length (const char *str)\n", "{\n", "    int len = 0;\n", "    if (*str == '\\0')\n", "        return 0;\n", "    while (str[len] != '\\0')\n", "        len++;\n", "    return len;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [[{"description": "", "author": "", "authorEmail": "", "date": ""}, {}]], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "28": {"capabilities": [], "helperCallParams": {}, "startLine": 132, "endLine": 145, "File": "/home/palani/github/opened_extraction/examples/ebpf-ratelimiter-main/ratelimiting_user.c", "funcName": "set_logfile", "developer_inline_comments": [{"start_line": 131, "end_line": 131, "text": "/* Set the logging output to the default log file configured */"}], "updateMaps": [], "readMaps": [], "input": ["void"], "output": "staticFILE", "helper": [], "compatibleHookpoints": ["lwt_seg6local", "lwt_out", "kprobe", "sock_ops", "sk_skb", "sk_msg", "sched_cls", "raw_tracepoint_writable", "cgroup_sock", "tracepoint", "sched_act", "cgroup_skb", "lwt_xmit", "flow_dissector", "cgroup_device", "raw_tracepoint", "xdp", "socket_filter", "cgroup_sock_addr", "lwt_in", "sk_reuseport", "cgroup_sysctl", "perf_event"], "source": ["static FILE *set_logfile (void)\n", "{\n", "    if (info != NULL) {\n", "        return info;\n", "    }\n", "    info = fopen (DEFAULT_LOGFILE, \"a\");\n", "    if (info == NULL) {\n", "        fprintf (stderr, \"could not open log file \");\n", "        return NULL;\n", "    }\n", "    fprintf (stderr, \"writing errors/warnings/info/debug output to %s \\n\", DEFAULT_LOGFILE);\n", "    return info;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [[{"description": "", "author": "", "authorEmail": "", "date": ""}, {}]], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "29": {"capabilities": [{"capability": "map_update", "map_update": [{"Project": "libbpf", "Return Type": "int", "Description": "Delete entry with <[ key ]>(IP: 1) from map. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_map_delete_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_update"]}]}], "helperCallParams": {}, "startLine": 148, "endLine": 167, "File": "/home/palani/github/opened_extraction/examples/ebpf-ratelimiter-main/ratelimiting_user.c", "funcName": "xdp_unlink_bpf_chain", "developer_inline_comments": [{"start_line": 147, "end_line": 147, "text": "// This method to unlink the program"}], "updateMaps": [" map_fd"], "readMaps": [], "input": ["const char *map_filename"], "output": "staticint", "helper": ["bpf_map_delete_elem"], "compatibleHookpoints": ["lwt_seg6local", "lwt_out", "kprobe", "sock_ops", "sk_skb", "sk_msg", "sched_cls", "raw_tracepoint_writable", "cgroup_sock", "tracepoint", "sched_act", "cgroup_skb", "lwt_xmit", "flow_dissector", "cgroup_device", "raw_tracepoint", "xdp", "socket_filter", "cgroup_sock_addr", "lwt_in", "sk_reuseport", "cgroup_sysctl", "perf_event"], "source": ["static int xdp_unlink_bpf_chain (const char *map_filename)\n", "{\n", "    int ret = 0;\n", "    int key = 0;\n", "    int map_fd = bpf_obj_get (map_filename);\n", "    if (map_fd > 0) {\n", "        ret = bpf_map_delete_elem (map_fd, & key);\n", "        if (ret != 0) {\n", "            log_err (\"Failed to remove XDP program from the chain\");\n", "        }\n", "    }\n", "    else {\n", "        log_err (\"Failed to fetch previous XDP program in the chain\");\n", "    }\n", "    if (remove (xdp_rl_ingress_next_prog) < 0) {\n", "        log_warn (\"Failed to remove link to next XDP program in the chain\");\n", "    }\n", "    return ret;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [[{"description": "", "author": "", "authorEmail": "", "date": ""}, {}]], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "30": {"capabilities": [], "helperCallParams": {}, "startLine": 171, "endLine": 182, "File": "/home/palani/github/opened_extraction/examples/ebpf-ratelimiter-main/ratelimiting_user.c", "funcName": "signal_handler", "developer_inline_comments": [{"start_line": 170, "end_line": 170, "text": "/* Unlink xdp kernel program on receiving KILL/INT signals */"}], "updateMaps": [], "readMaps": [], "input": ["int signal"], "output": "staticvoid", "helper": [], "compatibleHookpoints": ["lwt_seg6local", "lwt_out", "kprobe", "sock_ops", "sk_skb", "sk_msg", "sched_cls", "raw_tracepoint_writable", "cgroup_sock", "tracepoint", "sched_act", "cgroup_skb", "lwt_xmit", "flow_dissector", "cgroup_device", "raw_tracepoint", "xdp", "socket_filter", "cgroup_sock_addr", "lwt_in", "sk_reuseport", "cgroup_sysctl", "perf_event"], "source": ["static void signal_handler (int signal)\n", "{\n", "    log_info (\"Received signal %d\", signal);\n", "    int i = 0;\n", "    xdp_unlink_bpf_chain (prev_prog_map);\n", "    for (i = 0; i < MAP_COUNT; i++) {\n", "        close (map_fd[i]);\n", "    }\n", "    if (info != NULL)\n", "        fclose (info);\n", "    exit (EXIT_SUCCESS);\n", "}\n"], "called_function_list": ["xdp_unlink_bpf_chain"], "call_depth": 1, "humanFuncDescription": [[{"description": "", "author": "", "authorEmail": "", "date": ""}, {}]], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "31": {"capabilities": [], "helperCallParams": {}, "startLine": 185, "endLine": 199, "File": "/home/palani/github/opened_extraction/examples/ebpf-ratelimiter-main/ratelimiting_user.c", "funcName": "time_get_ns", "developer_inline_comments": [{"start_line": 184, "end_line": 184, "text": "/* Get monotonic clock time in ns */"}], "updateMaps": [], "readMaps": [], "input": ["void"], "output": "static__u64", "helper": [], "compatibleHookpoints": ["lwt_seg6local", "lwt_out", "kprobe", "sock_ops", "sk_skb", "sk_msg", "sched_cls", "raw_tracepoint_writable", "cgroup_sock", "tracepoint", "sched_act", "cgroup_skb", "lwt_xmit", "flow_dissector", "cgroup_device", "raw_tracepoint", "xdp", "socket_filter", "cgroup_sock_addr", "lwt_in", "sk_reuseport", "cgroup_sysctl", "perf_event"], "source": ["static __u64 time_get_ns (void)\n", "{\n", "\n", "#ifdef __linux__\n", "    struct timespec ts;\n", "    clock_gettime (CLOCK_MONOTONIC, &ts);\n", "    return ts.tv_sec * 1000000000ull + ts.tv_nsec;\n", "\n", "#endif\n", "\n", "#ifdef WIN32\n", "    LARGE_INTEGER frequency, counter;\n", "    QueryPerformanceFrequency (&frequency);\n", "    QueryPerformanceCounter (&counter);\n", "    return (1000000000 * counter.QuadPart) / frequency.QuadPart;\n", "\n", "#endif\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [[{"description": "", "author": "", "authorEmail": "", "date": ""}, {}]], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "32": {"capabilities": [], "helperCallParams": {}, "startLine": 203, "endLine": 226, "File": "/home/palani/github/opened_extraction/examples/ebpf-ratelimiter-main/ratelimiting_user.c", "funcName": "delete_stale_entries", "developer_inline_comments": [{"start_line": 201, "end_line": 202, "text": "/* Delete stale map entries(LRU) based on the timestamp at which\n * a map element is created. */"}], "updateMaps": [" map_fd[1]"], "readMaps": [], "input": ["void"], "output": "staticvoid", "helper": [], "compatibleHookpoints": ["lwt_seg6local", "lwt_out", "kprobe", "sock_ops", "sk_skb", "sk_msg", "sched_cls", "raw_tracepoint_writable", "cgroup_sock", "tracepoint", "sched_act", "cgroup_skb", "lwt_xmit", "flow_dissector", "cgroup_device", "raw_tracepoint", "xdp", "socket_filter", "cgroup_sock_addr", "lwt_in", "sk_reuseport", "cgroup_sysctl", "perf_event"], "source": ["static void delete_stale_entries (void)\n", "{\n", "    log_debug (\"Deleting stale map entries periodically\");\n", "    if (map_fd[1] < 0) {\n", "        log_info (\"Window map fd not found\");\n", "        exit (EXIT_FAILURE);\n", "    }\n", "    __u64 first_key = 0, next_key = 0;\n", "    __u64 curr_time = time_get_ns ();\n", "    log_debug (\"Current time is %llu\", curr_time);\n", "    while (!bpf_map_get_next_key (map_fd[1], &first_key, &next_key)) {\n", "        if (next_key < (curr_time - buffer_time)) {\n", "            log_debug (\"Deleting stale map entry %llu\", next_key);\n", "            if (bpf_map_delete_elem (map_fd[1], &next_key) != 0) {\n", "                log_info (\"Map element not found\");\n", "            }\n", "        }\n", "        first_key = next_key;\n", "    }\n", "}\n"], "called_function_list": ["time_get_ns"], "call_depth": 1, "humanFuncDescription": [[{"description": "", "author": "", "authorEmail": "", "date": ""}, {}]], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "33": {"capabilities": [], "helperCallParams": {}, "startLine": 228, "endLine": 242, "File": "/home/palani/github/opened_extraction/examples/ebpf-ratelimiter-main/ratelimiting_user.c", "funcName": "trim_space", "developer_inline_comments": [{"start_line": 230, "end_line": 230, "text": "/* skip leading whitespace */"}, {"start_line": 234, "end_line": 234, "text": "/* remove trailing whitespace */"}, {"start_line": 239, "end_line": 239, "text": "/* write null character */"}], "updateMaps": [], "readMaps": [], "input": ["char *str"], "output": "staticchar", "helper": [], "compatibleHookpoints": ["lwt_seg6local", "lwt_out", "kprobe", "sock_ops", "sk_skb", "sk_msg", "sched_cls", "raw_tracepoint_writable", "cgroup_sock", "tracepoint", "sched_act", "cgroup_skb", "lwt_xmit", "flow_dissector", "cgroup_device", "raw_tracepoint", "xdp", "socket_filter", "cgroup_sock_addr", "lwt_in", "sk_reuseport", "cgroup_sysctl", "perf_event"], "source": ["static char *trim_space (char *str)\n", "{\n", "    char *end;\n", "    while (isspace (*str)) {\n", "        str = str + 1;\n", "    }\n", "    end = str + get_length (str) - 1;\n", "    while (end > str && isspace (*end)) {\n", "        end = end - 1;\n", "    }\n", "    *(end + 1) = '\\0';\n", "    return str;\n", "}\n"], "called_function_list": ["get_length"], "call_depth": 1, "humanFuncDescription": [[{"description": "", "author": "", "authorEmail": "", "date": ""}, {}]], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "34": {"capabilities": [], "helperCallParams": {}, "startLine": 244, "endLine": 255, "File": "/home/palani/github/opened_extraction/examples/ebpf-ratelimiter-main/ratelimiting_user.c", "funcName": "strtoi", "developer_inline_comments": [{"start_line": 249, "end_line": 249, "text": "//out of range, extra chars at end"}], "updateMaps": [], "readMaps": [], "input": ["const char *str"], "output": "staticint", "helper": ["strtol"], "compatibleHookpoints": ["cgroup_sysctl"], "source": ["static int strtoi (const char *str)\n", "{\n", "    char *endptr;\n", "    errno = 0;\n", "    long long_var = strtol (str, & endptr, 10);\n", "    if (errno == ERANGE || *endptr != '\\0' || str == endptr) {\n", "        fprintf (stderr, \"out of range\");\n", "    }\n", "    return (int) long_var;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [[{"description": "", "author": "", "authorEmail": "", "date": ""}, {}]], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "35": {"capabilities": [{"capability": "map_update", "map_update": [{"Project": "libbpf", "Return Type": "int", "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_map_update_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}", "{Type:  const void ,Var: *value}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_update"]}]}], "helperCallParams": {}, "startLine": 257, "endLine": 270, "File": "/home/palani/github/opened_extraction/examples/ebpf-ratelimiter-main/ratelimiting_user.c", "funcName": "update_ports", "developer_inline_comments": [], "updateMaps": [" map_fd[4]"], "readMaps": [], "input": ["char *ports"], "output": "staticvoid", "helper": ["bpf_map_update_elem"], "compatibleHookpoints": ["lwt_seg6local", "lwt_out", "kprobe", "sock_ops", "sk_skb", "sk_msg", "sched_cls", "raw_tracepoint_writable", "cgroup_sock", "tracepoint", "sched_act", "cgroup_skb", "lwt_xmit", "flow_dissector", "cgroup_device", "raw_tracepoint", "xdp", "socket_filter", "cgroup_sock_addr", "lwt_in", "sk_reuseport", "cgroup_sysctl", "perf_event"], "source": ["static void update_ports (char *ports)\n", "{\n", "    char *ptr, *tmp;\n", "    uint16_t port = 0;\n", "    uint8_t pval = 1;\n", "    tmp = strdup (ports);\n", "    while ((ptr = strsep (&tmp, delim)) != NULL) {\n", "        ptr = trim_space (ptr);\n", "        port = (uint16_t) (strtoi (ptr));\n", "        bpf_map_update_elem (map_fd[4], &port, &pval, 0);\n", "    }\n", "    free (tmp);\n", "}\n"], "called_function_list": ["trim_space", "strtoi", "strsep"], "call_depth": 2, "humanFuncDescription": [[{"description": "", "author": "", "authorEmail": "", "date": ""}, {}]], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "36": {"capabilities": [{"capability": "map_update", "map_update": [{"Project": "libbpf", "Return Type": "int", "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_map_update_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}", "{Type:  const void ,Var: *value}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_update"]}]}], "helperCallParams": {}, "startLine": 272, "endLine": 423, "File": "/home/palani/github/opened_extraction/examples/ebpf-ratelimiter-main/ratelimiting_user.c", "funcName": "main", "developer_inline_comments": [{"start_line": 287, "end_line": 287, "text": "/* Parse commands line args */"}, {"start_line": 317, "end_line": 317, "text": "/* Not honoured as of now */"}, {"start_line": 345, "end_line": 345, "text": "/* Get the previous program's map fd in the chain */"}, {"start_line": 351, "end_line": 352, "text": "/* Update current prog fd in the last prog map fd,\n     * so it can chain the current one */"}, {"start_line": 357, "end_line": 357, "text": "/* closing map fd to avoid stale map */"}, {"start_line": 369, "end_line": 373, "text": "/* Map FDs are sequenced same as they are defined in the bpf program ie.,\n     * map_fd[0] = rl_config_map, map_fd[1] = rl_window_map\n     * map_fd[2] = rl_recv_count_map, map_fd[3] = rl_drop_count_map\n     * map_fd[4] = rl_ports_map\n     * map_fd[5] = xdp_rl_ingress_next_prog*/"}, {"start_line": 408, "end_line": 408, "text": "/* Handle signals and exit clean */"}, {"start_line": 418, "end_line": 419, "text": "/* Keep deleting the stale map entries periodically *\n         * TODO Check if LRU maps can be used.              */"}], "updateMaps": [" map_fd [3]", " map_fd [0]", " prev_prog_map_fd", " map_fd [2]"], "readMaps": [], "input": ["int argc", " char **argv"], "output": "int", "helper": ["bpf_map_update_elem"], "compatibleHookpoints": ["lwt_seg6local", "lwt_out", "kprobe", "sock_ops", "sk_skb", "sk_msg", "sched_cls", "raw_tracepoint_writable", "cgroup_sock", "tracepoint", "sched_act", "cgroup_skb", "lwt_xmit", "flow_dissector", "cgroup_device", "raw_tracepoint", "xdp", "socket_filter", "cgroup_sock_addr", "lwt_in", "sk_reuseport", "cgroup_sysctl", "perf_event"], "source": ["int main (int argc, char **argv)\n", "{\n", "    int longindex = 0, rate = 0, opt;\n", "    int ret = EXIT_SUCCESS;\n", "    char bpf_obj_file [256];\n", "    char ports [2048];\n", "    verbosity = LOG_INFO;\n", "\n", "#ifdef __linux__\n", "    struct rlimit r = {RLIM_INFINITY, RLIM_INFINITY}\n", "    ;\n", "\n", "#endif\n", "    int len = 0;\n", "    snprintf (bpf_obj_file, sizeof (bpf_obj_file), \"%s_kern.o\", argv[0]);\n", "    memset (&ports, 0, 2048);\n", "    while ((opt = getopt_long (argc, argv, \"h\", long_options, &longindex)) != -1) {\n", "        switch (opt) {\n", "        case 'r' :\n", "            rate = strtoi (optarg);\n", "            break;\n", "        case 'i' :\n", "            ifindex = if_nametoindex (optarg);\n", "            break;\n", "        case 'v' :\n", "            if (optarg) {\n", "                verbosity = strtoi (optarg);\n", "            }\n", "            break;\n", "        case 'm' :\n", "            if (optarg) {\n", "                len = get_length (optarg);\n", "                strncpy (prev_prog_map, optarg, len);\n", "                prev_prog_map[len] = '\\0';\n", "            }\n", "            break;\n", "        case 'p' :\n", "            if (optarg) {\n", "                len = get_length (optarg);\n", "                strncpy (ports, optarg, len);\n", "                ports[len] = '\\0';\n", "            }\n", "            break;\n", "        case 'd' :\n", "            break;\n", "        case 'h' :\n", "        default :\n", "            usage (argv);\n", "            return EXIT_FAILURE;\n", "        }\n", "    }\n", "\n", "#ifdef __linux__\n", "    if (setrlimit (RLIMIT_MEMLOCK, &r)) {\n", "        perror (\"setrlimit(RLIMIT_MEMLOCK)\");\n", "        exit (EXIT_FAILURE);\n", "    }\n", "\n", "#endif\n", "    set_logfile ();\n", "    __u64 ckey = 0, rkey = 0, dkey = 0, pkey = 0;\n", "    __u64 recv_count = 0, drop_count = 0;\n", "    if (load_bpf_file (bpf_obj_file)) {\n", "        log_err (\"Failed to load bpf program\");\n", "        return 1;\n", "    }\n", "    if (!prog_fd[0]) {\n", "        log_err (\"Failed to get bpf program fd\")\n", "        return 1;\n", "    }\n", "    int prev_prog_map_fd = bpf_obj_get (prev_prog_map);\n", "    if (prev_prog_map_fd < 0) {\n", "        log_err (\"Failed to fetch previous xdp function in the chain\");\n", "        exit (EXIT_FAILURE);\n", "    }\n", "    if (bpf_map_update_elem (prev_prog_map_fd, &pkey, &(prog_fd[0]), 0)) {\n", "        log_err (\"Failed to update prog fd in the chain\");\n", "        exit (EXIT_FAILURE);\n", "    }\n", "    close (prev_prog_map_fd);\n", "    int next_prog_map_fd = bpf_obj_get (xdp_rl_ingress_next_prog);\n", "    if (next_prog_map_fd < 0) {\n", "        log_info (\"Failed to fetch next prog map fd, creating one\");\n", "        if (bpf_obj_pin (map_fd[5], xdp_rl_ingress_next_prog)) {\n", "            log_info (\"Failed to pin next prog fd map\");\n", "            exit (EXIT_FAILURE);\n", "        }\n", "    }\n", "    if (!map_fd[0]) {\n", "        log_err (\"Failed to fetch config map\");\n", "        return -1;\n", "    }\n", "    ret = bpf_map_update_elem (map_fd [0], & ckey, & rate, 0);\n", "    if (ret) {\n", "        perror (\"Failed to update config map\");\n", "        return 1;\n", "    }\n", "    if (!map_fd[2]) {\n", "        log_err (\"Failed to fetch receive count map\");\n", "        return -1;\n", "    }\n", "    ret = bpf_map_update_elem (map_fd [2], & rkey, & recv_count, 0);\n", "    if (ret) {\n", "        perror (\"Failed to update receive count map\");\n", "        return 1;\n", "    }\n", "    if (!map_fd[3]) {\n", "        log_err (\"Failed to fetch drop count map\");\n", "        return -1;\n", "    }\n", "    ret = bpf_map_update_elem (map_fd [3], & dkey, & drop_count, 0);\n", "    if (ret) {\n", "        perror (\"Failed to update drop count map\");\n", "        return 1;\n", "    }\n", "    if (get_length (ports)) {\n", "        log_info (\"Configured port list is %s\\n\", ports);\n", "        update_ports (ports);\n", "    }\n", "    signal (SIGINT, signal_handler);\n", "    signal (SIGTERM, signal_handler);\n", "\n", "#ifdef __linux__\n", "    signal (SIGHUP, signal_handler);\n", "\n", "#endif\n", "    while (1) {\n", "        sleep (60);\n", "        delete_stale_entries ();\n", "        fflush (info);\n", "    }\n", "}\n"], "called_function_list": ["set_logfile", "strtoi", "update_ports", "get_length", "delete_stale_entries", "usage"], "call_depth": 3, "humanFuncDescription": [[{"description": "", "author": "", "authorEmail": "", "date": ""}, {}]], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}}}