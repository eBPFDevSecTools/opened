{"_default": {"1": {"capabilities": [], "helperCallParams": {}, "startLine": 2, "endLine": 6, "File": "/home/palani/github/opened_extraction/examples/bcc/trace_fields.c", "funcName": "hello", "developer_inline_comments": [{"start_line": 1, "end_line": 1, "text": "//int hello (void *ctx)"}], "updateMaps": [], "readMaps": [], "input": ["NA"], "output": "int", "helper": ["bpf_trace_printk"], "compatibleHookpoints": ["cgroup_sysctl", "perf_event", "cgroup_device", "lwt_out", "kprobe", "sk_reuseport", "raw_tracepoint", "lwt_xmit", "sock_ops", "flow_dissector", "xdp", "sched_cls", "sk_msg", "sk_skb", "tracepoint", "socket_filter", "cgroup_sock_addr", "raw_tracepoint_writable", "lwt_seg6local", "cgroup_sock", "cgroup_skb", "lwt_in", "sched_act"], "source": ["int hello ()\n", "{\n", "    bpf_trace_printk (\"Hello, World!\\\\n\");\n", "    return 0;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{}, {"description": "This prints out a trace line every time the clone system call is called.\n                      This will instrument the kernel sys_clone() function, which will then run the BPF defined hello() function each time it is called.", "author": "Utkalika Satapathy", "authorEmail": "utkalika.satapathy01@gmail.com", "date": "02.02.2023"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "2": {"capabilities": [], "helperCallParams": {}, "startLine": 1, "endLine": 4, "File": "/home/palani/github/opened_extraction/examples/bcc/hello_fields.c", "funcName": "hello", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["void *ctx"], "output": "int", "helper": ["bpf_trace_printk"], "compatibleHookpoints": ["cgroup_sysctl", "perf_event", "cgroup_device", "lwt_out", "kprobe", "sk_reuseport", "raw_tracepoint", "lwt_xmit", "sock_ops", "flow_dissector", "xdp", "sched_cls", "sk_msg", "sk_skb", "tracepoint", "socket_filter", "cgroup_sock_addr", "raw_tracepoint_writable", "lwt_seg6local", "cgroup_sock", "cgroup_skb", "lwt_in", "sched_act"], "source": ["int hello (void *ctx)\n", "{\n", "    bpf_trace_printk (\"Hello, World!\\\\n\");\n", "    return 0;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{}, {"description": "hello() function takes as input a void pointer ctx. It uses \n                      the bpf_trace_printk helper to print the message which is passed \n                      as argument. bpf_trace_printk is a printk()-like facility that \n                      prints message defined in it. Function returns 0 on completion.", "author": "Neha Chowdhary", "authorEmail": "nehaniket79@gmail.com", "date": "01.02.2023"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "3": {"capabilities": [{"capability": "read_sys_info", "read_sys_info": [{"Project": "bcc", "FunctionName": "bpf_ktime_get_ns", "Return Type": "u64", "Description": "u64 bpf_ktime_get_ns(void) Return: u64 number of nanoseconds. Starts at system boot time but stops during suspend. Examples in situ: \"https://github.com/iovisor/bcc/search?q=bpf_ktime_get_ns+path%3Aexamples&type=Code search /examples , \"https://github.com/iovisor/bcc/search?q=bpf_ktime_get_ns+path%3Atools&type=Code search /tools ", "Return": "u64 number of nanoseconds", "Input Prameters": [], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "raw_tracepoint_writable"], "capabilities": ["read_sys_info"]}]}], "helperCallParams": {}, "startLine": 8, "endLine": 29, "File": "/home/palani/github/opened_extraction/examples/bcc/biolatpcts.c", "funcName": "RAW_TRACEPOINT_PROBE", "developer_inline_comments": [{"start_line": 10, "end_line": 10, "text": "// TP_PROTO(struct request *rq, blk_status_t error, unsigned int nr_bytes)"}], "updateMaps": [], "readMaps": [], "input": ["block_rq_complete"], "output": "NA", "helper": ["bpf_ktime_get_ns"], "compatibleHookpoints": ["perf_event", "lwt_out", "kprobe", "sk_reuseport", "raw_tracepoint", "lwt_xmit", "sock_ops", "flow_dissector", "xdp", "sched_cls", "sk_msg", "sk_skb", "tracepoint", "socket_filter", "cgroup_sock_addr", "raw_tracepoint_writable", "lwt_seg6local", "cgroup_sock", "cgroup_skb", "lwt_in", "sched_act"], "source": ["RAW_TRACEPOINT_PROBE (block_rq_complete)\n", "{\n", "    struct request *rq = (void *) ctx->args[0];\n", "    unsigned int cmd_flags;\n", "    u64 dur;\n", "    size_t base, slot;\n", "    if (!rq->io_start_time_ns)\n", "        return 0;\n", "    dur = bpf_ktime_get_ns () - rq->io_start_time_ns;\n", "    slot = min_t (size_t, div_u64 (dur, 100 * NSEC_PER_MSEC), 99);\n", "    lat_100ms.increment (slot);\n", "    if (slot)\n", "        return 0;\n", "    slot = min_t (size_t, div_u64 (dur, NSEC_PER_MSEC), 99);\n", "    lat_1ms.increment (slot);\n", "    if (slot)\n", "        return 0;\n", "    slot = min_t (size_t, div_u64 (dur, 10 * NSEC_PER_USEC), 99);\n", "    lat_10us.increment (slot);\n", "    return 0;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{}, {"description": "biolatpcts_RAW_TRACEPOINT_PROBE function takes as input a block_req_complete\n                      and calculates the duration of the i/o time 'dur' by subtracting kernel time \n                      with start time. It uses helper bpf_ktime_get_ns() to get the kernel time. It \n                      then divides it into three slots:\n                      dur>100ms, 100ms>dur>1ms and 10microsec<dur<1ms and increments the count of each \n                      slot if the duration falls in the slot. biolatpcts_RAW_TRACEPOINT_PROBE returns 0\n                      when the slots are valid or the io start time for request is 0.", "author": "Neha Chowdhary", "authorEmail": "nehaniket79@gmail.com", "date": "01.02.2023"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "4": {"capabilities": [], "helperCallParams": {}, "startLine": 3, "endLine": 11, "File": "/home/palani/github/opened_extraction/examples/bcc/kvm_hypercall.c", "funcName": "TRACEPOINT_PROBE", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["kvm", " kvm_exit"], "output": "NA", "helper": ["bpf_trace_printk"], "compatibleHookpoints": ["cgroup_sysctl", "perf_event", "cgroup_device", "lwt_out", "kprobe", "sk_reuseport", "raw_tracepoint", "lwt_xmit", "sock_ops", "flow_dissector", "xdp", "sched_cls", "sk_msg", "sk_skb", "tracepoint", "socket_filter", "cgroup_sock_addr", "raw_tracepoint_writable", "lwt_seg6local", "cgroup_sock", "cgroup_skb", "lwt_in", "sched_act"], "source": ["TRACEPOINT_PROBE (kvm, kvm_exit)\n", "{\n", "    u8 e = EXIT_REASON;\n", "    u8 one = 1;\n", "    if (args->exit_reason == EXIT_REASON) {\n", "        bpf_trace_printk (\"KVM_EXIT exit_reason : %d\\\\n\", args->exit_reason);\n", "        start.update (&e, &one);\n", "    }\n", "    return 0;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{}, {"description": "kvm_hypercall_TRACEPOINT_PROBE function is triggered in case of kvm exit\n                      event. It takes as input two parameters 'kvm' and 'kvm_exit. Function stores\n                      checks if the reason for exit is 'EXIT_REASON'. If yes, it prints the reason \n                      and stores 1 in start map. Basically keeping a note wether the next exit reason \n                      of type 'EXIT_REASON' was triggered by same event reason. Functions returns 0 on\n                      success.", "author": "Neha Chowdhary", "authorEmail": "nehaniket79@gmail.com", "date": "01.02.2023"}, {"description": "kvm_hypercal_TRACEPOINT_PROBE() checks kvm entry events. It checks \n                      if the reason for exit is EXIT_REASON and if it is, then it prints \n                      out the vcpu id of that event. It also resets start to 0. Function\n                      returns 0 on success.", "author": "Neha Chowdhary", "authorEmail": "", "date": ""}, {"description": "kvm_hypercall_TRACEPOINT_PROBE() checks whether a kvm hypercall\n                      occurs or not and whether the reason for it's exit is \n                      EXTI_REASON. If yes then we print args->nr related to the\n                      hypercall. Function returns 0 on success.", "author": "Neha Chowdhary", "authorEmail": "", "date": ""}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "5": {"capabilities": [], "helperCallParams": {}, "startLine": 12, "endLine": 21, "File": "/home/palani/github/opened_extraction/examples/bcc/kvm_hypercall.c", "funcName": "TRACEPOINT_PROBE", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["kvm", " kvm_entry"], "output": "NA", "helper": ["bpf_trace_printk"], "compatibleHookpoints": ["cgroup_sysctl", "perf_event", "cgroup_device", "lwt_out", "kprobe", "sk_reuseport", "raw_tracepoint", "lwt_xmit", "sock_ops", "flow_dissector", "xdp", "sched_cls", "sk_msg", "sk_skb", "tracepoint", "socket_filter", "cgroup_sock_addr", "raw_tracepoint_writable", "lwt_seg6local", "cgroup_sock", "cgroup_skb", "lwt_in", "sched_act"], "source": ["TRACEPOINT_PROBE (kvm, kvm_entry)\n", "{\n", "    u8 e = EXIT_REASON;\n", "    u8 zero = 0;\n", "    u8 *s = start.lookup (&e);\n", "    if (s != NULL && *s == 1) {\n", "        bpf_trace_printk (\"KVM_ENTRY vcpu_id : %u\\\\n\", args->vcpu_id);\n", "        start.update (&e, &zero);\n", "    }\n", "    return 0;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{}, {"description": "kvm_hypercall_TRACEPOINT_PROBE function is triggered in case of kvm exit\n                      event. It takes as input two parameters 'kvm' and 'kvm_exit. Function stores\n                      checks if the reason for exit is 'EXIT_REASON'. If yes, it prints the reason \n                      and stores 1 in start map. Basically keeping a note wether the next exit reason \n                      of type 'EXIT_REASON' was triggered by same event reason. Functions returns 0 on\n                      success.", "author": "Neha Chowdhary", "authorEmail": "nehaniket79@gmail.com", "date": "01.02.2023"}, {"description": "kvm_hypercal_TRACEPOINT_PROBE() checks kvm entry events. It checks \n                      if the reason for exit is EXIT_REASON and if it is, then it prints \n                      out the vcpu id of that event. It also resets start to 0. Function\n                      returns 0 on success.", "author": "Neha Chowdhary", "authorEmail": "", "date": ""}, {"description": "kvm_hypercall_TRACEPOINT_PROBE() checks whether a kvm hypercall\n                      occurs or not and whether the reason for it's exit is \n                      EXTI_REASON. If yes then we print args->nr related to the\n                      hypercall. Function returns 0 on success.", "author": "Neha Chowdhary", "authorEmail": "", "date": ""}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "6": {"capabilities": [], "helperCallParams": {}, "startLine": 22, "endLine": 30, "File": "/home/palani/github/opened_extraction/examples/bcc/kvm_hypercall.c", "funcName": "TRACEPOINT_PROBE", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["kvm", " kvm_hypercall"], "output": "NA", "helper": ["bpf_trace_printk"], "compatibleHookpoints": ["cgroup_sysctl", "perf_event", "cgroup_device", "lwt_out", "kprobe", "sk_reuseport", "raw_tracepoint", "lwt_xmit", "sock_ops", "flow_dissector", "xdp", "sched_cls", "sk_msg", "sk_skb", "tracepoint", "socket_filter", "cgroup_sock_addr", "raw_tracepoint_writable", "lwt_seg6local", "cgroup_sock", "cgroup_skb", "lwt_in", "sched_act"], "source": ["TRACEPOINT_PROBE (kvm, kvm_hypercall)\n", "{\n", "    u8 e = EXIT_REASON;\n", "    u8 zero = 0;\n", "    u8 *s = start.lookup (&e);\n", "    if (s != NULL && *s == 1) {\n", "        bpf_trace_printk (\"HYPERCALL nr : %d\\\\n\", args->nr);\n", "    }\n", "    return 0;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{}, {"description": "kvm_hypercall_TRACEPOINT_PROBE function is triggered in case of kvm exit\n                      event. It takes as input two parameters 'kvm' and 'kvm_exit. Function stores\n                      checks if the reason for exit is 'EXIT_REASON'. If yes, it prints the reason \n                      and stores 1 in start map. Basically keeping a note wether the next exit reason \n                      of type 'EXIT_REASON' was triggered by same event reason. Functions returns 0 on\n                      success.", "author": "Neha Chowdhary", "authorEmail": "nehaniket79@gmail.com", "date": "01.02.2023"}, {"description": "kvm_hypercal_TRACEPOINT_PROBE() checks kvm entry events. It checks \n                      if the reason for exit is EXIT_REASON and if it is, then it prints \n                      out the vcpu id of that event. It also resets start to 0. Function\n                      returns 0 on success.", "author": "Neha Chowdhary", "authorEmail": "", "date": ""}, {"description": "kvm_hypercall_TRACEPOINT_PROBE() checks whether a kvm hypercall\n                      occurs or not and whether the reason for it's exit is \n                      EXTI_REASON. If yes then we print args->nr related to the\n                      hypercall. Function returns 0 on success.", "author": "Neha Chowdhary", "authorEmail": "", "date": ""}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "7": {"capabilities": [], "helperCallParams": {}, "startLine": 1, "endLine": 5, "File": "/home/palani/github/opened_extraction/examples/bcc/urandomread.c", "funcName": "TRACEPOINT_PROBE", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["random", " urandom_read"], "output": "NA", "helper": ["bpf_trace_printk"], "compatibleHookpoints": ["cgroup_sysctl", "perf_event", "cgroup_device", "lwt_out", "kprobe", "sk_reuseport", "raw_tracepoint", "lwt_xmit", "sock_ops", "flow_dissector", "xdp", "sched_cls", "sk_msg", "sk_skb", "tracepoint", "socket_filter", "cgroup_sock_addr", "raw_tracepoint_writable", "lwt_seg6local", "cgroup_sock", "cgroup_skb", "lwt_in", "sched_act"], "source": ["TRACEPOINT_PROBE (random, urandom_read)\n", "{\n", "    bpf_trace_printk (\"%d\\\\n\", args->got_bits);\n", "    return 0;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{}, {"description": "TRACEPOINT_PROBE(random, urandom_read) is a macro that instruments the tracepoint defined by random:urandom_read and prints the tracepoint argument got_bits.", "author": "Utkalika Satapathy", "authorEmail": "utkalika.satapathy01@gmail.com", "date": "02.02.2023"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}}}