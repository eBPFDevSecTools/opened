{"_default": {"1": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "libbpf", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"bpf_map_lookup_elem": [{"opVar": "    tn ", "inpVar": [" &mptm_tnl_info_map", " &key"]}], "redirect": [{"opVar": "NA", "inpVar": ["        if likelytn-> "]}], "bpf_redirect": [{"opVar": "         action ", "inpVar": [" _map&mptm_tnl_redirect_devmap", " tn->veth_iface", " flags"]}]}, "startLine": 52, "endLine": 99, "File": "/home/sayandes/opened_extraction/examples/xdp-mptm-main/src/kernel/mptm.c", "funcName": "mptm_encap", "updateMaps": [], "readMaps": ["  mptm_tnl_info_map"], "input": ["struct xdp_md *ctx"], "output": "int", "helper": ["bpf_map_lookup_elem", "bpf_redirect", "redirect"], "compatibleHookpoints": ["lwt_xmit", "sched_cls", "xdp", "sched_act"], "humanFuncDescription": [{"description": "This function performs the encapsulation of specific tunnel on an outgoing packet. It parse the packet eth and ip header using the parse_pkt_headers helper function. It then performs a map lookup into mptm_tnl_info_map with key which is a struct containing the ip source and dst addr of the packet. The map lookup returns a tunnel_info object *tn, which is used further to encapsulate differnet tunnel based on the rule programmed in the tunnel_info object retrieved from the map. This function will then call appropriate helper function encap_<tunnel> to encapsulate appropriate tunnel on the packet and finally redirects the packet to an outbound interface which is pre programmed in a devmap with the key taken as tn->veth_iface object and flags as none. It will return XDP_REDIRECT on successful encapsulation or XDP_PASS/XDP_ABORTED based on the return value of helper functions used.", "author": "Dushyant Behl", "authorEmail": "dushyantbehl@in.ibm.com", "date": "2023-02-20"}, {}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "2": {"capabilities": [{"capability": "update_pkt", "update_pkt": [{"Project": "libbpf", "Return Type": "int", "Description": "Adjust (move) xdp_md->data by <[ delta ]>(IP: 1) bytes. Note that it is possible to use a negative value for delta. This helper can be used to prepare the packet for pushing or popping headers. A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_xdp_adjust_head", "Input Params": ["{Type: struct xdp_buff ,Var: *xdp_md}", "{Type:  int ,Var: delta}"]}]}, {"capability": "map_read", "map_read": [{"Project": "libbpf", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"bpf_xdp_adjust_head": [{"opVar": "        long ret ", "inpVar": [" ctx", " outer_hdr_size"]}], "bpf_map_lookup_elem": [{"opVar": "        tn ", "inpVar": [" &mptm_tnl_info_map", " &key"]}], "bpf_redirect": [{"opVar": "                action ", "inpVar": [" _map&mptm_tnl_redirect_devmap", " tn->eth0_iface", " flags"]}]}, "startLine": 102, "endLine": 167, "File": "/home/sayandes/opened_extraction/examples/xdp-mptm-main/src/kernel/mptm.c", "funcName": "mptm_decap", "updateMaps": [], "readMaps": ["  mptm_tnl_info_map"], "input": ["struct xdp_md *ctx"], "output": "int", "helper": ["bpf_map_lookup_elem", "bpf_xdp_adjust_head", "bpf_redirect"], "compatibleHookpoints": ["xdp"], "humanFuncDescription": [{"description": "This function performs the decapsulation of specific tunnel on an incoming packet. It parse the packet eth, ip and udp header using the parse_pkt_headers helper function. If the packet is a UDP packet and if the UDP dest port is 0xc117 the geneve tunnel destination port, then it will remove the geneve header from the packet,by reducing its data size by sizeof(struct genevehdr+ struct udphdr + struct iphdr + struct ethhdr) by calling bpf_xdp_adjust_head. After that it recalculates the packet headers using parse_pkt_headers and does a sanity check on if Geneve tunnel is what was intended for this packet. Finally the packet is redirected to appropriate interface using mptm_tnl_redirect_devmap", "author": "Dushyant Behl", "authorEmail": "dushyantbehl@in.ibm.com", "date": "2023-02-20"}, {}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "3": {"capabilities": [], "helperCallParams": {}, "startLine": 41, "endLine": 97, "File": "/home/sayandes/opened_extraction/examples/xdp-mptm-main/src/kernel/lib/pkt-parse.h", "funcName": "parse_pkt_headers", "updateMaps": [], "readMaps": [], "input": ["void *data", " void *data_end", " struct ethhdr **ethhdr", " struct iphdr **iphdr", " struct udphdr **udphdr"], "output": "static__ALWAYS_INLINE__int", "helper": [], "compatibleHookpoints": ["sk_reuseport", "lwt_seg6local", "cgroup_sysctl", "sock_ops", "lwt_out", "raw_tracepoint_writable", "kprobe", "cgroup_skb", "sched_cls", "sched_act", "flow_dissector", "raw_tracepoint", "cgroup_device", "perf_event", "cgroup_sock_addr", "sk_skb", "sk_msg", "cgroup_sock", "tracepoint", "lwt_xmit", "socket_filter", "lwt_in", "xdp"], "humanFuncDescription": [{"description": "This function takes in 5 arguments, 1 and 2 correspond to the start and end pointer of a packet data. The next three arguments are pointer to pointers to return values of eth header, ip header and udp header back to the caller. It calls internal libaray functions parse_ethhdr to parse eth header, parse_iphdr function to parse ip header, parse_udphdr to parse udp header, it ignore TCP packets because TCP packets don't represent any tunnel as all tunnels are implemented via udp stream. It sets the appropriate value of the pointer arguments to eth, ip and udp header to return to the caller. For success the function returns 0 and failure it returns -1", "author": "Dushyant Behl", "authorEmail": "dushyantbehl@in.ibm.com", "date": "2023-02-20"}, {}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "4": {"capabilities": [], "helperCallParams": {"bpf_redirect": [{"opVar": "NA", "inpVar": ["    return _map&mptm_extras_redirect_devmap", " key", " flags"]}]}, "startLine": 24, "endLine": 29, "File": "/home/sayandes/opened_extraction/examples/xdp-mptm-main/src/kernel/mptm_extras.c", "funcName": "mptm_redirect", "updateMaps": [], "readMaps": [], "input": ["struct xdp_md *ctx"], "output": "int", "helper": ["bpf_redirect", "redirect"], "compatibleHookpoints": ["lwt_xmit", "sched_cls", "xdp", "sched_act"], "humanFuncDescription": [{"description": "This function takes in a packet represented by struct xdp_md context and redirects it to another interface via a BPF_REDIRECT_DEVMAP with key which is the packet's ingress interface and flags as zero.", "author": "Dushyant Behl", "authorEmail": "dushyantbehl@in.ibm.com", "date": "2023-02-20"}, {}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "5": {"capabilities": [], "helperCallParams": {}, "startLine": 32, "endLine": 34, "File": "/home/sayandes/opened_extraction/examples/xdp-mptm-main/src/kernel/mptm_extras.c", "funcName": "mptm_pass", "updateMaps": [], "readMaps": [], "input": ["struct xdp_md *ctx"], "output": "int", "helper": [], "compatibleHookpoints": ["sk_reuseport", "lwt_seg6local", "cgroup_sysctl", "sock_ops", "lwt_out", "raw_tracepoint_writable", "kprobe", "cgroup_skb", "sched_cls", "sched_act", "flow_dissector", "raw_tracepoint", "cgroup_device", "perf_event", "cgroup_sock_addr", "sk_skb", "sk_msg", "cgroup_sock", "tracepoint", "lwt_xmit", "socket_filter", "lwt_in", "xdp"], "humanFuncDescription": [{"description": "This function just returns XDP_PASS for any packet that is passed to it as struct xdp_mp context", "author": "Dushyant Behl", "authorEmail": "dushyantbehl@in.ibm.com", "date": "2023-02-20"}, {}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "6": {"capabilities": [], "helperCallParams": {}, "startLine": 38, "endLine": 46, "File": "/home/sayandes/opened_extraction/examples/xdp-mptm-main/src/kernel/lib/pkt-encap.h", "funcName": "set_dst_mac", "updateMaps": [], "readMaps": [], "input": ["void *data", " unsigned char *dst_mac"], "output": "static__ALWAYS_INLINE__void", "helper": [], "compatibleHookpoints": ["sk_reuseport", "lwt_seg6local", "cgroup_sysctl", "sock_ops", "lwt_out", "raw_tracepoint_writable", "kprobe", "cgroup_skb", "sched_cls", "sched_act", "flow_dissector", "raw_tracepoint", "cgroup_device", "perf_event", "cgroup_sock_addr", "sk_skb", "sk_msg", "cgroup_sock", "tracepoint", "lwt_xmit", "socket_filter", "lwt_in", "xdp"], "humanFuncDescription": [{"description": "This function takes in two arguments 1) void *data 2) unsigned char *dst_mac and will set the mac represented by dst_mac array 0,1,2 to the pointer pointed by data at array offset 0,1,2", "author": "Dushyant Behl", "authorEmail": "dushyantbehl@in.ibm.com", "date": "2023-02-20"}, {}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "7": {"capabilities": [], "helperCallParams": {}, "startLine": 48, "endLine": 56, "File": "/home/sayandes/opened_extraction/examples/xdp-mptm-main/src/kernel/lib/pkt-encap.h", "funcName": "set_src_mac", "updateMaps": [], "readMaps": [], "input": ["void *data", " unsigned char *src_mac"], "output": "static__ALWAYS_INLINE__void", "helper": [], "compatibleHookpoints": ["sk_reuseport", "lwt_seg6local", "cgroup_sysctl", "sock_ops", "lwt_out", "raw_tracepoint_writable", "kprobe", "cgroup_skb", "sched_cls", "sched_act", "flow_dissector", "raw_tracepoint", "cgroup_device", "perf_event", "cgroup_sock_addr", "sk_skb", "sk_msg", "cgroup_sock", "tracepoint", "lwt_xmit", "socket_filter", "lwt_in", "xdp"], "humanFuncDescription": [{"description": "This function takes in two arguments 1) void *data 2) unsigned char *src_mac and will set the mac represented by src_mac array 0,1,2 to the pointer pointed by data at array offset [3,4,5]", "author": "Dushyant Behl", "authorEmail": "dushyantbehl@in.ibm.com", "date": "2023-02-20"}, {}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "8": {"capabilities": [], "helperCallParams": {}, "startLine": 58, "endLine": 67, "File": "/home/sayandes/opened_extraction/examples/xdp-mptm-main/src/kernel/lib/pkt-encap.h", "funcName": "csum_fold_helper", "updateMaps": [], "readMaps": [], "input": ["__u64 csum"], "output": "static__ALWAYS_INLINE____u16", "helper": [], "compatibleHookpoints": ["sk_reuseport", "lwt_seg6local", "cgroup_sysctl", "sock_ops", "lwt_out", "raw_tracepoint_writable", "kprobe", "cgroup_skb", "sched_cls", "sched_act", "flow_dissector", "raw_tracepoint", "cgroup_device", "perf_event", "cgroup_sock_addr", "sk_skb", "sk_msg", "cgroup_sock", "tracepoint", "lwt_xmit", "socket_filter", "lwt_in", "xdp"], "humanFuncDescription": [{"description": "This function takes in a __u64 csum helps in recomputing ipv4 checksum, return folded checksum as __u16", "author": "Dushyant Behl", "authorEmail": "dushyantbehl@in.ibm.com", "date": "2023-02-20"}, {}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "9": {"capabilities": [], "helperCallParams": {}, "startLine": 69, "endLine": 77, "File": "/home/sayandes/opened_extraction/examples/xdp-mptm-main/src/kernel/lib/pkt-encap.h", "funcName": "ipv4_csum_inline", "updateMaps": [], "readMaps": [], "input": ["void *iph", " __u64 *csum"], "output": "static__ALWAYS_INLINE__void", "helper": [], "compatibleHookpoints": ["sk_reuseport", "lwt_seg6local", "cgroup_sysctl", "sock_ops", "lwt_out", "raw_tracepoint_writable", "kprobe", "cgroup_skb", "sched_cls", "sched_act", "flow_dissector", "raw_tracepoint", "cgroup_device", "perf_event", "cgroup_sock_addr", "sk_skb", "sk_msg", "cgroup_sock", "tracepoint", "lwt_xmit", "socket_filter", "lwt_in", "xdp"], "humanFuncDescription": [{"description": "This function takes in an ip header void *iph and a checksum __u64 *csum, recomputes ipv4 checksum and stores the result back in *csum argument, does not return anything.", "author": "Dushyant Behl", "authorEmail": "dushyantbehl@in.ibm.com", "date": "2023-02-20"}, {}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "10": {"capabilities": [{"capability": "update_pkt", "update_pkt": [{"Project": "libbpf", "Return Type": "int", "Description": "Adjust (move) xdp_md->data by <[ delta ]>(IP: 1) bytes. Note that it is possible to use a negative value for delta. This helper can be used to prepare the packet for pushing or popping headers. A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_xdp_adjust_head", "Input Params": ["{Type: struct xdp_buff ,Var: *xdp_md}", "{Type:  int ,Var: delta}"]}]}], "helperCallParams": {"bpf_xdp_adjust_head": [{"opVar": "    long ret ", "inpVar": [" ctx", " 0-outer_hdr_size"]}]}, "startLine": 82, "endLine": 192, "File": "/home/sayandes/opened_extraction/examples/xdp-mptm-main/src/kernel/lib/pkt-encap.h", "funcName": "__encap_geneve", "updateMaps": [], "readMaps": [], "input": ["struct xdp_md *ctx", " struct ethhdr *eth", " geneve_tunnel_info *tn"], "output": "static__ALWAYS_INLINE__int", "helper": ["bpf_xdp_adjust_head"], "compatibleHookpoints": ["xdp"], "humanFuncDescription": [{"description": "This function takes in 3 arguments, 1) packet represented by struct xdp_mp *ctx, 2) struct ethhdr *eth, 3) geneve_tunnel_info *tn. It performs a geneve header encapsulation on top of the existing packet the details of geneve header are taken from tn argument. Specifically it expands the packet header by first calling the function bpf_xdp_adjust_head with extra size outer_hdr_size equal to geneve header + udp header + ip header + eth header and then it recalculates the new outer headers of expanded packet and populates the header information by taking relevant information from geneve_tunnel_info *tn object and programs the headers according to geneve protocol. Return XDP_PASS on success or XDP_ABORTED on failure", "author": "Dushyant Behl", "authorEmail": "dushyantbehl@in.ibm.com", "date": "2023-02-20"}, {}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "11": {"capabilities": [], "helperCallParams": {}, "startLine": 194, "endLine": 200, "File": "/home/sayandes/opened_extraction/examples/xdp-mptm-main/src/kernel/lib/pkt-encap.h", "funcName": "encap_geneve", "updateMaps": [], "readMaps": [], "input": ["struct xdp_md *ctx", " struct ethhdr *eth", " mptm_tunnel_info *tn"], "output": "static__ALWAYS_INLINE__int", "helper": [], "compatibleHookpoints": ["sk_reuseport", "lwt_seg6local", "cgroup_sysctl", "sock_ops", "lwt_out", "raw_tracepoint_writable", "kprobe", "cgroup_skb", "sched_cls", "sched_act", "flow_dissector", "raw_tracepoint", "cgroup_device", "perf_event", "cgroup_sock_addr", "sk_skb", "sk_msg", "cgroup_sock", "tracepoint", "lwt_xmit", "socket_filter", "lwt_in", "xdp"], "humanFuncDescription": [{"description": "This function takes in a packet represented by struct xdp_mp *ctx along side its eth header struct ethhdr *eth and mptm_tunnel_info *tn, it computes the geneve tunnel information to be pushed on the packet via mptm_tunnel_info and encapsulates the packet in a geneve tunnel by calling a helper funciton __encap_geneve. Returns XDP_PASS on success or XDP_ABORTED on failure.", "author": "Dushyant Behl", "authorEmail": "dushyantbehl@in.ibm.com", "date": "2023-02-20"}, {}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "12": {"capabilities": [], "helperCallParams": {}, "startLine": 203, "endLine": 214, "File": "/home/sayandes/opened_extraction/examples/xdp-mptm-main/src/kernel/lib/pkt-encap.h", "funcName": "encap_vlan", "updateMaps": [], "readMaps": [], "input": ["struct xdp_md *ctx", " struct ethhdr *eth", " mptm_tunnel_info *tn"], "output": "static__ALWAYS_INLINE__int", "helper": [], "compatibleHookpoints": ["sk_reuseport", "lwt_seg6local", "cgroup_sysctl", "sock_ops", "lwt_out", "raw_tracepoint_writable", "kprobe", "cgroup_skb", "sched_cls", "sched_act", "flow_dissector", "raw_tracepoint", "cgroup_device", "perf_event", "cgroup_sock_addr", "sk_skb", "sk_msg", "cgroup_sock", "tracepoint", "lwt_xmit", "socket_filter", "lwt_in", "xdp"], "humanFuncDescription": [{"description": "This function takes in a packet represented by struct xdp_mp *ctx along side its eth header struct ethhdr *eth and mptm_tunnel_info *tn, it computes the vlan tunnel to be pushed on the packet via mptm_tunnel_info and encapsulates the packet in a vlan by pusing a vlan tag on the packet eth hdr by calling a helper funciton vlan_tag_push. Returns XDP_PASS on success or XDP_ABORTED on failure.", "author": "Dushyant Behl", "authorEmail": "dushyantbehl@in.ibm.com", "date": "2023-02-20"}, {}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}}}
