<?xml version="1.0"?>
<doc>
<source file="/home/sayandes/opened_extraction/examples/katran/healthchecking_helpers.h" funcheader="static inline bool set_hc_key (const struct  __sk_buff *skb, struct hc_key *hckey, bool is_ipv6)" startline="37" endline="77">
static inline bool set_hc_key (const struct  __sk_buff *skb, struct hc_key *hckey, bool is_ipv6)
{
    void *iphdr = (void *) (long) skb->data + sizeof (struct ethhdr);
    void *transport_hdr;
    if (is_ipv6) {
        struct ipv6hdr *ip6h = iphdr;
        if (ip6h + 1 > (void *) (long) skb->data_end) {
            return false;
        }
        transport_hdr = iphdr + sizeof (struct ipv6hdr);
        memcpy (hckey->addrv6, ip6h->daddr.s6_addr32, 16);
        hckey->proto = ip6h->nexthdr;
    }
    else {
        struct iphdr *iph = iphdr;
        if (iph + 1 > (void *) (long) skb->data_end) {
            return false;
        }
        transport_hdr = iphdr + sizeof (struct iphdr);
        hckey->addr = iph->daddr;
        hckey->proto = iph->protocol;
    }
    if (hckey->proto == IPPROTO_TCP) {
        struct tcphdr *tcp = transport_hdr;
        if (tcp + 1 > (void *) (long) skb->data_end) {
            return false;
        }
        hckey->port = tcp->dest;
    }
    else if (hckey->proto == IPPROTO_UDP) {
        struct udphdr *udp = transport_hdr;
        if (udp + 1 > (void *) (long) skb->data_end) {
            return false;
        }
        hckey->port = udp->dest;
    }
    else {
        return false;
    }
    return true;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/katran/healthchecking_helpers.h" funcheader="static inline bool hc_encap_ipip (struct  __sk_buff *skb, struct hc_real_definition *real, struct ethhdr *ethh, bool is_ipv6)" startline="79" endline="139">
static inline bool hc_encap_ipip (struct  __sk_buff *skb, struct hc_real_definition *real, struct ethhdr *ethh, bool is_ipv6)
{
    struct hc_real_definition *src;
    __u64 flags = 0;
    __u16 pkt_len;
    int adjust_len;
    __u32 key;
    pkt_len = skb->len - sizeof (struct ethhdr);
    if (real->flags == V6DADDR) {
        __u8 proto = IPPROTO_IPV6;
        key = V6_SRC_INDEX;
        src = bpf_map_lookup_elem (& hc_pckt_srcs_map, & key);
        if (!src) {
            return false;
        }
        flags |= BPF_F_ADJ_ROOM_FIXED_GSO | BPF_F_ADJ_ROOM_ENCAP_L3_IPV6;
        adjust_len = sizeof (struct ipv6hdr);
        if (bpf_skb_adjust_room (skb, adjust_len, BPF_ADJ_ROOM_MAC, flags)) {
            return false;
        }
        if ((skb->data + sizeof (struct ethhdr) + sizeof (struct ipv6hdr)) > skb->data_end) {
            return false;
        }
        ethh = (void *) (long) skb->data;
        ethh->h_proto = BE_ETH_P_IPV6;
        struct ipv6hdr *ip6h = (void *) (long) skb->data + sizeof (struct ethhdr);
        if (!is_ipv6) {
            proto = IPPROTO_IPIP;
        }
        create_v6_hdr (ip6h, DEFAULT_TOS, src->v6daddr, real->v6daddr, pkt_len, proto);
    }
    else {
        key = V4_SRC_INDEX;
        src = bpf_map_lookup_elem (& hc_pckt_srcs_map, & key);
        if (!src) {
            return false;
        }
        flags |= BPF_F_ADJ_ROOM_FIXED_GSO | BPF_F_ADJ_ROOM_ENCAP_L3_IPV4;
        adjust_len = sizeof (struct iphdr);
        if (bpf_skb_adjust_room (skb, adjust_len, BPF_ADJ_ROOM_MAC, flags)) {
            return false;
        }
        if ((skb->data + sizeof (struct ethhdr) + sizeof (struct iphdr)) > skb->data_end) {
            return false;
        }
        struct iphdr *iph = (void *) (long) skb->data + sizeof (struct ethhdr);
        create_v4_hdr (iph, DEFAULT_TOS, src->daddr, real->daddr, pkt_len, IPPROTO_IPIP);
    }
    return true;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/katran/healthchecking_helpers.h" funcheader="static inline __u16 gue_sport (__u32 seed)" startline="141" endline="143">
static inline __u16 gue_sport (__u32 seed)
{
    return (__u16) ((seed ^ (seed >> 16)) & 0xFFFF);
}
</source>
<source file="/home/sayandes/opened_extraction/examples/katran/healthchecking_helpers.h" funcheader="static inline bool hc_encap_gue (struct  __sk_buff *skb, struct hc_real_definition *real, struct ethhdr *ethh, bool is_ipv6)" startline="145" endline="213">
static inline bool hc_encap_gue (struct  __sk_buff *skb, struct hc_real_definition *real, struct ethhdr *ethh, bool is_ipv6)
{
    struct hc_real_definition *src;
    __u64 flags = 0;
    __u16 pkt_len;
    __u16 sport;
    int adjust_len;
    __u32 key;
    pkt_len = skb->len - sizeof (struct ethhdr);
    if (real->flags == V6DADDR) {
        sport = gue_sport (real -> v6daddr [0] | real -> v6daddr [3]);
        __u8 proto = IPPROTO_IPV6;
        key = V6_SRC_INDEX;
        src = bpf_map_lookup_elem (& hc_pckt_srcs_map, & key);
        if (!src) {
            return false;
        }
        flags |= BPF_F_ADJ_ROOM_FIXED_GSO | BPF_F_ADJ_ROOM_ENCAP_L3_IPV6 | BPF_F_ADJ_ROOM_ENCAP_L4_UDP;
        adjust_len = sizeof (struct ipv6hdr) + sizeof (struct udphdr);
        if (bpf_skb_adjust_room (skb, adjust_len, BPF_ADJ_ROOM_MAC, flags)) {
            return false;
        }
        if ((skb->data + sizeof (struct ethhdr) + sizeof (struct ipv6hdr) + sizeof (struct udphdr)) > skb->data_end) {
            return false;
        }
        ethh = (void *) (long) skb->data;
        ethh->h_proto = BE_ETH_P_IPV6;
        struct ipv6hdr *ip6h = (void *) (long) skb->data + sizeof (struct ethhdr);
        struct udphdr *udph = (void *) ip6h + sizeof (struct ipv6hdr);
        pkt_len += sizeof (struct udphdr);
        create_udp_hdr (udph, sport, GUE_DPORT, pkt_len, GUE_CSUM);
        create_v6_hdr (ip6h, DEFAULT_TOS, src->v6daddr, real->v6daddr, pkt_len, IPPROTO_UDP);
    }
    else {
        sport = gue_sport (real -> daddr);
        key = V4_SRC_INDEX;
        src = bpf_map_lookup_elem (& hc_pckt_srcs_map, & key);
        if (!src) {
            return false;
        }
        flags |= BPF_F_ADJ_ROOM_FIXED_GSO | BPF_F_ADJ_ROOM_ENCAP_L3_IPV4 | BPF_F_ADJ_ROOM_ENCAP_L4_UDP;
        adjust_len = sizeof (struct iphdr) + sizeof (struct udphdr);
        if (bpf_skb_adjust_room (skb, adjust_len, BPF_ADJ_ROOM_MAC, flags)) {
            return false;
        }
        if ((skb->data + sizeof (struct ethhdr) + sizeof (struct iphdr) + sizeof (struct udphdr)) > skb->data_end) {
            return false;
        }
        struct iphdr *iph = (void *) (long) skb->data + sizeof (struct ethhdr);
        struct udphdr *udph = (void *) iph + sizeof (struct iphdr);
        pkt_len += sizeof (struct udphdr);
        create_udp_hdr (udph, sport, GUE_DPORT, pkt_len, GUE_CSUM);
        create_v4_hdr (iph, DEFAULT_TOS, src->daddr, real->daddr, pkt_len, IPPROTO_UDP);
    }
    return true;
}
</source>
</doc>
