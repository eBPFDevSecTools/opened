{"is_under_flood": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/balancer_kern.c", "startLine": "25", "endLine": "50", "capability": {"capability": [{"map_read": [{"Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": "Map value associated to key, or NULL if no entry was found.", "Return Type": "void", "Function Name": "*bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}, {"read_sys_info": [{"Description": "Return the time elapsed since system boot , in nanoseconds. ", "Return": "Current ktime.", "Return Type": "u64", "Function Name": "bpf_ktime_get_ns", "Input Params": ["{Type: voi ,Var: void}"]}]}], "helperCallParams": {"bpf_map_lookup_elem": ["{\n \"opVar\": \"  struct lb_stats* conn_rate_stats \",\n \"inpVar\": [\n  \"      &stats\",\n  \" &conn_rate_key\"\n ]\n}"], "bpf_ktime_get_ns": ["{\n \"opVar\": \"    *cur_time \",\n \"inpVar\": [\n  \" \"\n ]\n}"]}}}], "get_packet_dst": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/balancer_kern.c", "startLine": "53", "endLine": "131", "capability": {"capability": [{"map_read": [{"Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": "Map value associated to key, or NULL if no entry was found.", "Return Type": "void", "Function Name": "*bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}, {"map_update": [{"Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of:BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ", "Return": "0 on success, or a negative error in case of failure.", "Return Type": "int", "Function Name": "bpf_map_update_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}", "{Type:  const void ,Var: *value}", "{Type:  u64 ,Var: flags}"]}]}], "helperCallParams": {"bpf_map_lookup_elem": ["{\n \"opVar\": \"      lpm_val \",\n \"inpVar\": [\n  \" &lpm_src_v6\",\n  \" &lpm_key_v6\"\n ]\n}", "{\n \"opVar\": \"      lpm_val \",\n \"inpVar\": [\n  \" &lpm_src_v4\",\n  \" &lpm_key_v4\"\n ]\n}", "{\n \"opVar\": \"    struct lb_stats* data_stats \",\n \"inpVar\": [\n  \" &stats\",\n  \" &stats_key\"\n ]\n}", "{\n \"opVar\": \"    real_pos \",\n \"inpVar\": [\n  \" &ch_rings\",\n  \" &key\"\n ]\n}", "{\n \"opVar\": \"  *real \",\n \"inpVar\": [\n  \" &reals\",\n  \" &key\"\n ]\n}"], "bpf_map_update_elem": ["{\n \"opVar\": \"NA\",\n \"inpVar\": [\n  \"    lru_map\",\n  \" &pckt->flow\",\n  \" &new_dst_lru\",\n  \" BPF_ANY\"\n ]\n}"]}}}], "connection_table_lookup": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/balancer_kern.c", "startLine": "133", "endLine": "156", "capability": {"capability": [{"map_read": [{"Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": "Map value associated to key, or NULL if no entry was found.", "Return Type": "void", "Function Name": "*bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}, {"read_sys_info": [{"Description": "Return the time elapsed since system boot , in nanoseconds. ", "Return": "Current ktime.", "Return Type": "u64", "Function Name": "bpf_ktime_get_ns", "Input Params": ["{Type: voi ,Var: void}"]}]}], "helperCallParams": {"bpf_map_lookup_elem": ["{\n \"opVar\": \"  dst_lru \",\n \"inpVar\": [\n  \" lru_map\",\n  \" &pckt->flow\"\n ]\n}", "{\n \"opVar\": \"  *real \",\n \"inpVar\": [\n  \" &reals\",\n  \" &key\"\n ]\n}"], "bpf_ktime_get_ns": ["{\n \"opVar\": \"    cur_time \",\n \"inpVar\": [\n  \" \"\n ]\n}"]}}}], "process_l3_headers": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/balancer_kern.c", "startLine": "158", "endLine": "230", "capability": {"capability": [{"pkt_stop_processing_drop_packet": [{"Return Type": "int", "Input Params": [], "Function Name": "XDP_DROP", "Return": 1, "Description": "will drop the packet right at the driver level without wasting any further resources. This is in particular useful for BPF programs implementing DDoS mitigation mechanisms or firewalling in general."}]}], "helperCallParams": {}}}, {"fileName": "/home/sayandes/opened_extraction/examples/katran/decap_kern.c", "startLine": "34", "endLine": "83", "capability": {"capability": [{"pkt_stop_processing_drop_packet": [{"Return Type": "int", "Input Params": [], "Function Name": "XDP_DROP", "Return": 1, "Description": "will drop the packet right at the driver level without wasting any further resources. This is in particular useful for BPF programs implementing DDoS mitigation mechanisms or firewalling in general."}]}], "helperCallParams": {}}}], "check_decap_dst": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/balancer_kern.c", "startLine": "233", "endLine": "255", "capability": {"capability": [{"map_read": [{"Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": "Map value associated to key, or NULL if no entry was found.", "Return Type": "void", "Function Name": "*bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}, {"pkt_stop_processing_drop_packet": [{"Return Type": "int", "Input Params": [], "Function Name": "XDP_DROP", "Return": 1, "Description": "will drop the packet right at the driver level without wasting any further resources. This is in particular useful for BPF programs implementing DDoS mitigation mechanisms or firewalling in general."}]}], "helperCallParams": {"bpf_map_lookup_elem": ["{\n \"opVar\": \"    __u32* decap_dst_flags \",\n \"inpVar\": [\n  \" &decap_dst\",\n  \" &dst_addr\"\n ]\n}", "{\n \"opVar\": \"    data_stats \",\n \"inpVar\": [\n  \" &stats\",\n  \" &stats_key\"\n ]\n}"]}}}], "reals_have_same_addr": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/balancer_kern.c", "startLine": "261", "endLine": "277", "capability": {"capability": [], "helperCallParams": {}}}], "perform_global_lru_lookup": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/balancer_kern.c", "startLine": "279", "endLine": "335", "capability": {"capability": [{"map_read": [{"Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": "Map value associated to key, or NULL if no entry was found.", "Return Type": "void", "Function Name": "*bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}, {"pkt_stop_processing_drop_packet": [{"Return Type": "int", "Input Params": [], "Function Name": "XDP_DROP", "Return": 1, "Description": "will drop the packet right at the driver level without wasting any further resources. This is in particular useful for BPF programs implementing DDoS mitigation mechanisms or firewalling in general."}]}], "helperCallParams": {"bpf_map_lookup_elem": ["{\n \"opVar\": \"    void* g_lru_map \",\n \"inpVar\": [\n  \" &global_lru_maps\",\n  \" &cpu_num\"\n ]\n}", "{\n \"opVar\": \"  struct lb_stats* global_lru_stats \",\n \"inpVar\": [\n  \"      &stats\",\n  \" &global_lru_stats_key\"\n ]\n}", "{\n \"opVar\": \"      struct lb_stats* global_lru_mismatch_stats \",\n \"inpVar\": [\n  \"          &stats\",\n  \" &global_lru_mismatch_stats_key\"\n ]\n}"]}}}], "process_encaped_ipip_pckt": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/balancer_kern.c", "startLine": "340", "endLine": "387", "capability": {"capability": [{"pkt_stop_processing_drop_packet": [{"Return Type": "int", "Input Params": [], "Function Name": "XDP_DROP", "Return": 1, "Description": "will drop the packet right at the driver level without wasting any further resources. This is in particular useful for BPF programs implementing DDoS mitigation mechanisms or firewalling in general."}]}, {"pkt_go_to_next_module": [{"Return Type": "int", "Input Params": [], "Function Name": "XDP_PASS", "Return": 2, "Description": "The XDP_PASS return code means that the packet is allowed to be passed up to the kernel\u2019s networking stack. Meaning, the current CPU that was processing this packet now allocates a skb, populates it, and passes it onwards into the GRO engine. This would be equivalent to the default packet handling behavior without XDP."}]}], "helperCallParams": {}}}, {"fileName": "/home/sayandes/opened_extraction/examples/katran/decap_kern.c", "startLine": "85", "endLine": "120", "capability": {"capability": [{"pkt_stop_processing_drop_packet": [{"Return Type": "int", "Input Params": [], "Function Name": "XDP_DROP", "Return": 1, "Description": "will drop the packet right at the driver level without wasting any further resources. This is in particular useful for BPF programs implementing DDoS mitigation mechanisms or firewalling in general."}]}], "helperCallParams": {}}}], "process_encaped_gue_pckt": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/balancer_kern.c", "startLine": "391", "endLine": "441", "capability": {"capability": [{"pkt_stop_processing_drop_packet": [{"Return Type": "int", "Input Params": [], "Function Name": "XDP_DROP", "Return": 1, "Description": "will drop the packet right at the driver level without wasting any further resources. This is in particular useful for BPF programs implementing DDoS mitigation mechanisms or firewalling in general."}]}, {"pkt_go_to_next_module": [{"Return Type": "int", "Input Params": [], "Function Name": "XDP_PASS", "Return": 2, "Description": "The XDP_PASS return code means that the packet is allowed to be passed up to the kernel\u2019s networking stack. Meaning, the current CPU that was processing this packet now allocates a skb, populates it, and passes it onwards into the GRO engine. This would be equivalent to the default packet handling behavior without XDP."}]}], "helperCallParams": {}}}, {"fileName": "/home/sayandes/opened_extraction/examples/katran/decap_kern.c", "startLine": "123", "endLine": "161", "capability": {"capability": [{"pkt_stop_processing_drop_packet": [{"Return Type": "int", "Input Params": [], "Function Name": "XDP_DROP", "Return": 1, "Description": "will drop the packet right at the driver level without wasting any further resources. This is in particular useful for BPF programs implementing DDoS mitigation mechanisms or firewalling in general."}]}], "helperCallParams": {}}}], "increment_quic_cid_version_stats": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/balancer_kern.c", "startLine": "444", "endLine": "457", "capability": {"capability": [{"map_read": [{"Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": "Map value associated to key, or NULL if no entry was found.", "Return Type": "void", "Function Name": "*bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"bpf_map_lookup_elem": ["{\n \"opVar\": \"  struct lb_stats* quic_version \",\n \"inpVar\": [\n  \"      &stats\",\n  \" &quic_version_stats_key\"\n ]\n}"]}}}], "increment_quic_cid_drop_no_real": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/balancer_kern.c", "startLine": "459", "endLine": "468", "capability": {"capability": [{"map_read": [{"Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": "Map value associated to key, or NULL if no entry was found.", "Return Type": "void", "Function Name": "*bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"bpf_map_lookup_elem": ["{\n \"opVar\": \"  struct lb_stats* quic_drop \",\n \"inpVar\": [\n  \"      &stats\",\n  \" &quic_drop_stats_key\"\n ]\n}"]}}}], "increment_quic_cid_drop_real_0": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/balancer_kern.c", "startLine": "470", "endLine": "478", "capability": {"capability": [{"map_read": [{"Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": "Map value associated to key, or NULL if no entry was found.", "Return Type": "void", "Function Name": "*bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"bpf_map_lookup_elem": ["{\n \"opVar\": \"  struct lb_stats* quic_drop \",\n \"inpVar\": [\n  \"      &stats\",\n  \" &quic_drop_stats_key\"\n ]\n}"]}}}], "process_packet": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/balancer_kern.c", "startLine": "480", "endLine": "791", "capability": {"capability": [{"map_read": [{"Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": "Map value associated to key, or NULL if no entry was found.", "Return Type": "void", "Function Name": "*bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}, {"read_sys_info": [{"Description": "Get the SMP (symmetric multiprocessing) processor id. Note that all programs run with preemption disabled , which means that the SMP processor id is stable during all the execution of the program. ", "Return": "The SMP id of the processor running the program.", "Return Type": "u32", "Function Name": "bpf_get_smp_processor_id", "Input Params": ["{Type: voi ,Var: void}"]}]}, {"pkt_stop_processing_drop_packet": [{"Return Type": "int", "Input Params": [], "Function Name": "XDP_DROP", "Return": 1, "Description": "will drop the packet right at the driver level without wasting any further resources. This is in particular useful for BPF programs implementing DDoS mitigation mechanisms or firewalling in general."}]}, {"pkt_go_to_next_module": [{"Return Type": "int", "Input Params": [], "Function Name": "XDP_PASS", "Return": 2, "Description": "The XDP_PASS return code means that the packet is allowed to be passed up to the kernel\u2019s networking stack. Meaning, the current CPU that was processing this packet now allocates a skb, populates it, and passes it onwards into the GRO engine. This would be equivalent to the default packet handling behavior without XDP."}]}, {"pkt_alter_or_redo_processing_or_interface": [{"Return Type": "int", "Input Params": [], "Function Name": "XDP_TX", "Return": 3, "Description": "an efficient option to transmit the network packet out of the same NIC it just arrived on again. This is typically useful when few nodes are implementing, for example, firewalling with subsequent load balancing in a cluster and thus act as a hairpinned load balancer pushing the incoming packets back into the switch after rewriting them in XDP BPF."}]}], "helperCallParams": {"bpf_map_lookup_elem": ["{\n \"opVar\": \"  vip_info \",\n \"inpVar\": [\n  \" &vip_map\",\n  \" &vip\"\n ]\n}", "{\n \"opVar\": \"    vip_info \",\n \"inpVar\": [\n  \" &vip_map\",\n  \" &vip\"\n ]\n}", "{\n \"opVar\": \"    data_stats \",\n \"inpVar\": [\n  \" &stats\",\n  \" &stats_key\"\n ]\n}", "{\n \"opVar\": \"  data_stats \",\n \"inpVar\": [\n  \" &stats\",\n  \" &stats_key\"\n ]\n}", "{\n \"opVar\": \"    struct lb_stats* quic_stats \",\n \"inpVar\": [\n  \" &stats\",\n  \" &quic_stats_key\"\n ]\n}", "{\n \"opVar\": \"      __u32* real_pos \",\n \"inpVar\": [\n  \" &server_id_map\",\n  \" &key\"\n ]\n}", "{\n \"opVar\": \"          dst \",\n \"inpVar\": [\n  \" &reals\",\n  \" &key\"\n ]\n}", "{\n \"opVar\": \"    void* lru_map \",\n \"inpVar\": [\n  \" &lru_mapping\",\n  \" &cpu_num\"\n ]\n}", "{\n \"opVar\": \"      struct lb_stats* lru_stats \",\n \"inpVar\": [\n  \" &stats\",\n  \" &lru_stats_key\"\n ]\n}", "{\n \"opVar\": \"      struct lb_stats* routing_stats \",\n \"inpVar\": [\n  \"          &stats\",\n  \" &routing_stats_key\"\n ]\n}", "{\n \"opVar\": \"        struct lb_stats* lru_stats \",\n \"inpVar\": [\n  \"            &stats\",\n  \" &lru_stats_key\"\n ]\n}", "{\n \"opVar\": \"        cval \",\n \"inpVar\": [\n  \" &ctl_array\",\n  \" &mac_addr_pos\"\n ]\n}", "{\n \"opVar\": \"  data_stats \",\n \"inpVar\": [\n  \" &stats\",\n  \" &vip_num\"\n ]\n}", "{\n \"opVar\": \"    data_stats \",\n \"inpVar\": [\n  \" &reals_stats\",\n  \" &pckt.real_index\"\n ]\n}"], "bpf_get_smp_processor_id": ["{\n \"opVar\": \"        __u32 cpu_num \",\n \"inpVar\": [\n  \" \"\n ]\n}"]}}}, {"fileName": "/home/sayandes/opened_extraction/examples/katran/decap_kern.c", "startLine": "164", "endLine": "221", "capability": {"capability": [{"map_read": [{"Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": "Map value associated to key, or NULL if no entry was found.", "Return Type": "void", "Function Name": "*bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}, {"pkt_go_to_next_module": [{"Return Type": "int", "Input Params": [], "Function Name": "XDP_PASS", "Return": 2, "Description": "The XDP_PASS return code means that the packet is allowed to be passed up to the kernel\u2019s networking stack. Meaning, the current CPU that was processing this packet now allocates a skb, populates it, and passes it onwards into the GRO engine. This would be equivalent to the default packet handling behavior without XDP."}]}], "helperCallParams": {"bpf_map_lookup_elem": ["{\n \"opVar\": \"  data_stats \",\n \"inpVar\": [\n  \" &decap_counters\",\n  \" &key\"\n ]\n}"]}}}], "balancer_ingress": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/balancer_kern.c", "startLine": "794", "endLine": "817", "capability": {"capability": [{"pkt_stop_processing_drop_packet": [{"Return Type": "int", "Input Params": [], "Function Name": "XDP_DROP", "Return": 1, "Description": "will drop the packet right at the driver level without wasting any further resources. This is in particular useful for BPF programs implementing DDoS mitigation mechanisms or firewalling in general."}]}, {"pkt_go_to_next_module": [{"Return Type": "int", "Input Params": [], "Function Name": "XDP_PASS", "Return": 2, "Description": "The XDP_PASS return code means that the packet is allowed to be passed up to the kernel\u2019s networking stack. Meaning, the current CPU that was processing this packet now allocates a skb, populates it, and passes it onwards into the GRO engine. This would be equivalent to the default packet handling behavior without XDP."}]}], "helperCallParams": {}}}], "get_packet_hash": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/balancer_kern.c", "startLine": "818", "endLine": "827", "capability": {"capability": [], "helperCallParams": {}}}], "xdpdecap": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/decap_kern.c", "startLine": "224", "endLine": "247", "capability": {"capability": [{"pkt_stop_processing_drop_packet": [{"Return Type": "int", "Input Params": [], "Function Name": "XDP_DROP", "Return": 1, "Description": "will drop the packet right at the driver level without wasting any further resources. This is in particular useful for BPF programs implementing DDoS mitigation mechanisms or firewalling in general."}]}, {"pkt_go_to_next_module": [{"Return Type": "int", "Input Params": [], "Function Name": "XDP_PASS", "Return": 2, "Description": "The XDP_PASS return code means that the packet is allowed to be passed up to the kernel\u2019s networking stack. Meaning, the current CPU that was processing this packet now allocates a skb, populates it, and passes it onwards into the GRO engine. This would be equivalent to the default packet handling behavior without XDP."}]}], "helperCallParams": {}}}], "xdp_prog_simple": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/x.c", "startLine": "9", "endLine": "13", "capability": {"capability": [], "helperCallParams": {}}}], "xdp_root": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/xdp_root.c", "startLine": "30", "endLine": "37", "capability": {"capability": [{"pkt_go_to_next_module": [{"Return Type": "int", "Input Params": [], "Function Name": "XDP_PASS", "Return": 2, "Description": "The XDP_PASS return code means that the packet is allowed to be passed up to the kernel\u2019s networking stack. Meaning, the current CPU that was processing this packet now allocates a skb, populates it, and passes it onwards into the GRO engine. This would be equivalent to the default packet handling behavior without XDP."}]}], "helperCallParams": {"bpf_tail_call": ["{\n \"opVar\": \"NA\",\n \"inpVar\": [\n  \"    ctx\",\n  \" &root_array\",\n  \" i\"\n ]\n}"]}}}], "xdp_val": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/xdp_root.c", "startLine": "40", "endLine": "47", "capability": {"capability": [{"pkt_go_to_next_module": [{"Return Type": "int", "Input Params": [], "Function Name": "XDP_PASS", "Return": 2, "Description": "The XDP_PASS return code means that the packet is allowed to be passed up to the kernel\u2019s networking stack. Meaning, the current CPU that was processing this packet now allocates a skb, populates it, and passes it onwards into the GRO engine. This would be equivalent to the default packet handling behavior without XDP."}]}], "helperCallParams": {"bpf_tail_call": ["{\n \"opVar\": \"NA\",\n \"inpVar\": [\n  \"    ctx\",\n  \" &root_array\",\n  \" i\"\n ]\n}"]}}}], "healthcheck_encap": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/healthchecking_kern.c", "startLine": "34", "endLine": "139", "capability": {"capability": [{"map_read": [{"Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": "Map value associated to key, or NULL if no entry was found.", "Return Type": "void", "Function Name": "*bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}, {"pkt_stop_processing_drop_packet": [{"Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_SHOT", "Return": 2, "Description": "instructs the kernel to drop the packet, meaning, upper layers of the networking stack will never see the skb on ingress and similarly the packet will never be submitted for transmission on egress. TC_ACT_SHOT and TC_ACT_STOLEN are both similar in nature with few differences: TC_ACT_SHOT will indicate to the kernel that the skb was released through kfree_skb() and return NET_XMIT_DROP to the callers for immediate feedback, whereas TC_ACT_STOLEN will release the skb through consume_skb() and pretend to upper layers that the transmission was successful through NET_XMIT_SUCCESS. The perf\u2019s drop monitor which records traces of kfree_skb() will therefore also not see any drop indications from TC_ACT_STOLEN since its semantics are such that the skb has been \u201cconsumed\u201d or queued but certainly not \"dropped\"."}]}, {"pkt_go_to_next_module": [{"Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_UNSPEC", "Return": -1, "Description": "unspecified action and is used in three cases, i) when an offloaded tc BPF program is attached and the tc ingress hook is run where the cls_bpf representation for the offloaded program will return TC_ACT_UNSPEC, ii) in order to continue with the next tc BPF program in cls_bpf for the multi-program case. The latter also works in combination with offloaded tc BPF programs from point i) where the TC_ACT_UNSPEC from there continues with a next tc BPF program solely running in non-offloaded case. Last but not least, iii) TC_ACT_UNSPEC is also used for the single program case to simply tell the kernel to continue with the skb without additional side-effects. TC_ACT_UNSPEC is very similar to the TC_ACT_OK action code in the sense that both pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. The only difference to TC_ACT_OK is that TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context."}]}], "helperCallParams": {"bpf_map_lookup_elem": ["{\n \"opVar\": \"  prog_stats \",\n \"inpVar\": [\n  \" &hc_stats_map\",\n  \" &stats_key\"\n ]\n}", "{\n \"opVar\": \"    struct hc_real_definition* real \",\n \"inpVar\": [\n  \" &hc_reals_map\",\n  \" &somark\"\n ]\n}", "{\n \"opVar\": \"  #endif  __u32* intf_ifindex \",\n \"inpVar\": [\n  \" &hc_ctrl_map\",\n  \" &key\"\n ]\n}", "{\n \"opVar\": \"  esrc \",\n \"inpVar\": [\n  \" &hc_pckt_macs\",\n  \" &key\"\n ]\n}", "{\n \"opVar\": \"  edst \",\n \"inpVar\": [\n  \" &hc_pckt_macs\",\n  \" &key\"\n ]\n}", "{\n \"opVar\": \"    __u32* hc_key_cntr_index \",\n \"inpVar\": [\n  \" &hc_key_map\",\n  \" &hckey\"\n ]\n}", "{\n \"opVar\": \"      __u32* packets_processed_for_hc_key \",\n \"inpVar\": [\n  \"          &per_hckey_stats\",\n  \" hc_key_cntr_index\"\n ]\n}"], "bpf_redirect": ["{\n \"opVar\": \"NA\",\n \"inpVar\": [\n  \"              return *intf_ifindex\",\n  \" REDIRECT_EGRESS\"\n ]\n}"]}}}, {"fileName": "/home/sayandes/opened_extraction/examples/katran/healthchecking_ipip.c", "startLine": "89", "endLine": "157", "capability": {"capability": [{"update_pkt": [{"Description": "Populate tunnel metadata for packet associated to skb. The tunnel metadata is set to the contents of <[ key ]>(IP: 1) , of size. The <[ flags ]>(IP: 3) can be set to a combination of the following values:BPF_F_TUNINFO_IPV6Indicate that the tunnel is based on IPv6 protocol instead of IPv4. BPF_F_ZERO_CSUM_TXFor IPv4 packets , add a flag to tunnel metadata indicating that checksum computation should be skipped and checksum set to zeroes. BPF_F_DONT_FRAGMENTAdd a flag to tunnel metadata indicating that the packet should not be fragmented. BPF_F_SEQ_NUMBERAdd a flag to tunnel metadata indicating that a sequence number should be added to tunnel header before sending the packet. This flag was added for GRE encapsulation , but might be used with other protocols as well in the future. Here is a typical usage on the transmit path:struct bpf_tunnel_key key; populate <[ key ]>(IP: 1) . . . bpf_skb_set_tunnel_key(skb , &key , sizeof(key) , 0);bpf_clone_redirect(skb , vxlan_dev_ifindex , 0);See also the description of the bpf_skb_get_tunnel_key() helper for additional information. ", "Return": "0 on success, or a negative error in case of failure.", "Return Type": "int", "Function Name": "bpf_skb_set_tunnel_key", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  struct bpf_tunnel_key ,Var: *key}", "{Type:  u32 ,Var: size}", "{Type:  u64 ,Var: flags}"]}]}, {"map_read": [{"Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": "Map value associated to key, or NULL if no entry was found.", "Return Type": "void", "Function Name": "*bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}, {"pkt_stop_processing_drop_packet": [{"Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_SHOT", "Return": 2, "Description": "instructs the kernel to drop the packet, meaning, upper layers of the networking stack will never see the skb on ingress and similarly the packet will never be submitted for transmission on egress. TC_ACT_SHOT and TC_ACT_STOLEN are both similar in nature with few differences: TC_ACT_SHOT will indicate to the kernel that the skb was released through kfree_skb() and return NET_XMIT_DROP to the callers for immediate feedback, whereas TC_ACT_STOLEN will release the skb through consume_skb() and pretend to upper layers that the transmission was successful through NET_XMIT_SUCCESS. The perf\u2019s drop monitor which records traces of kfree_skb() will therefore also not see any drop indications from TC_ACT_STOLEN since its semantics are such that the skb has been \u201cconsumed\u201d or queued but certainly not \"dropped\"."}]}, {"pkt_go_to_next_module": [{"Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_UNSPEC", "Return": -1, "Description": "unspecified action and is used in three cases, i) when an offloaded tc BPF program is attached and the tc ingress hook is run where the cls_bpf representation for the offloaded program will return TC_ACT_UNSPEC, ii) in order to continue with the next tc BPF program in cls_bpf for the multi-program case. The latter also works in combination with offloaded tc BPF programs from point i) where the TC_ACT_UNSPEC from there continues with a next tc BPF program solely running in non-offloaded case. Last but not least, iii) TC_ACT_UNSPEC is also used for the single program case to simply tell the kernel to continue with the skb without additional side-effects. TC_ACT_UNSPEC is very similar to the TC_ACT_OK action code in the sense that both pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. The only difference to TC_ACT_OK is that TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context."}]}], "helperCallParams": {"bpf_map_lookup_elem": ["{\n \"opVar\": \"  prog_stats \",\n \"inpVar\": [\n  \" &hc_stats_map\",\n  \" &stats_key\"\n ]\n}", "{\n \"opVar\": \"    struct hc_real_definition* real \",\n \"inpVar\": [\n  \" &hc_reals_map\",\n  \" &somark\"\n ]\n}", "{\n \"opVar\": \"    __u32* v4_intf_ifindex \",\n \"inpVar\": [\n  \" &hc_ctrl_map\",\n  \" &v4_intf_pos\"\n ]\n}", "{\n \"opVar\": \"    __u32* v6_intf_ifindex \",\n \"inpVar\": [\n  \" &hc_ctrl_map\",\n  \" &v6_intf_pos\"\n ]\n}"], "bpf_skb_set_tunnel_key": ["{\n \"opVar\": \"NA\",\n \"inpVar\": [\n  \"  skb\",\n  \" &tkey\",\n  \" sizeoftkey\",\n  \" tun_flag\"\n ]\n}"], "bpf_redirect": ["{\n \"opVar\": \"NA\",\n \"inpVar\": [\n  \"  return ifindex\",\n  \" REDIRECT_EGRESS\"\n ]\n}"]}}}], "pktcntr": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/xdp_pktcntr.c", "startLine": "46", "endLine": "62", "capability": {"capability": [{"map_read": [{"Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": "Map value associated to key, or NULL if no entry was found.", "Return Type": "void", "Function Name": "*bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}, {"pkt_go_to_next_module": [{"Return Type": "int", "Input Params": [], "Function Name": "XDP_PASS", "Return": 2, "Description": "The XDP_PASS return code means that the packet is allowed to be passed up to the kernel\u2019s networking stack. Meaning, the current CPU that was processing this packet now allocates a skb, populates it, and passes it onwards into the GRO engine. This would be equivalent to the default packet handling behavior without XDP."}]}], "helperCallParams": {"bpf_map_lookup_elem": ["{\n \"opVar\": \"  __u32* flag \",\n \"inpVar\": [\n  \" &ctl_array\",\n  \" &ctl_flag_pos\"\n ]\n}", "{\n \"opVar\": \"  __u64* cntr_val \",\n \"inpVar\": [\n  \" &cntrs_array\",\n  \" &cntr_pos\"\n ]\n}"]}}}], "encap_v6": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/pckt_encap.h", "startLine": "41", "endLine": "91", "capability": {"capability": [{"update_pkt": [{"Description": "Adjust (move) xdp_md->data by <[ delta ]>(IP: 1) bytes. Note that it is possible to use a negative value for delta. This helper can be used to prepare the packet for pushing or popping headers. A call to this helper is susceptible to change the underlaying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": "0 on success, or a negative error in case of failure.", "Return Type": "int", "Function Name": "bpf_xdp_adjust_head", "Input Params": ["{Type: struct xdp_buff ,Var: *xdp_md}", "{Type:  int ,Var: delta}"]}]}], "helperCallParams": {"bpf_xdp_adjust_head": ["{\n \"opVar\": \"NA\",\n \"inpVar\": [\n  \"    if xdp\",\n  \" 0 - intsizeofstruct ipv6hdr \"\n ]\n}"]}}}], "encap_v4": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/pckt_encap.h", "startLine": "93", "endLine": "133", "capability": {"capability": [{"update_pkt": [{"Description": "Adjust (move) xdp_md->data by <[ delta ]>(IP: 1) bytes. Note that it is possible to use a negative value for delta. This helper can be used to prepare the packet for pushing or popping headers. A call to this helper is susceptible to change the underlaying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": "0 on success, or a negative error in case of failure.", "Return Type": "int", "Function Name": "bpf_xdp_adjust_head", "Input Params": ["{Type: struct xdp_buff ,Var: *xdp_md}", "{Type:  int ,Var: delta}"]}]}], "helperCallParams": {"bpf_xdp_adjust_head": ["{\n \"opVar\": \"NA\",\n \"inpVar\": [\n  \"    if xdp\",\n  \" 0 - intsizeofstruct iphdr \"\n ]\n}"]}}}], "decap_v6": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/pckt_encap.h", "startLine": "137", "endLine": "156", "capability": {"capability": [{"update_pkt": [{"Description": "Adjust (move) xdp_md->data by <[ delta ]>(IP: 1) bytes. Note that it is possible to use a negative value for delta. This helper can be used to prepare the packet for pushing or popping headers. A call to this helper is susceptible to change the underlaying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": "0 on success, or a negative error in case of failure.", "Return Type": "int", "Function Name": "bpf_xdp_adjust_head", "Input Params": ["{Type: struct xdp_buff ,Var: *xdp_md}", "{Type:  int ,Var: delta}"]}]}], "helperCallParams": {"bpf_xdp_adjust_head": ["{\n \"opVar\": \"NA\",\n \"inpVar\": [\n  \"    if xdp\",\n  \" intsizeofstruct ipv6hdr \"\n ]\n}"]}}}], "decap_v4": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/pckt_encap.h", "startLine": "158", "endLine": "173", "capability": {"capability": [{"update_pkt": [{"Description": "Adjust (move) xdp_md->data by <[ delta ]>(IP: 1) bytes. Note that it is possible to use a negative value for delta. This helper can be used to prepare the packet for pushing or popping headers. A call to this helper is susceptible to change the underlaying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": "0 on success, or a negative error in case of failure.", "Return Type": "int", "Function Name": "bpf_xdp_adjust_head", "Input Params": ["{Type: struct xdp_buff ,Var: *xdp_md}", "{Type:  int ,Var: delta}"]}]}], "helperCallParams": {"bpf_xdp_adjust_head": ["{\n \"opVar\": \"NA\",\n \"inpVar\": [\n  \"  if xdp\",\n  \" intsizeofstruct iphdr \"\n ]\n}"]}}}], "gue_csum": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/pckt_encap.h", "startLine": "177", "endLine": "249", "capability": {"capability": [], "helperCallParams": {}}}], "gue_encap_v4": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/pckt_encap.h", "startLine": "251", "endLine": "307", "capability": {"capability": [{"update_pkt": [{"Description": "Adjust (move) xdp_md->data by <[ delta ]>(IP: 1) bytes. Note that it is possible to use a negative value for delta. This helper can be used to prepare the packet for pushing or popping headers. A call to this helper is susceptible to change the underlaying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": "0 on success, or a negative error in case of failure.", "Return Type": "int", "Function Name": "bpf_xdp_adjust_head", "Input Params": ["{Type: struct xdp_buff ,Var: *xdp_md}", "{Type:  int ,Var: delta}"]}]}, {"map_read": [{"Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": "Map value associated to key, or NULL if no entry was found.", "Return Type": "void", "Function Name": "*bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"bpf_map_lookup_elem": ["{\n \"opVar\": \"  src \",\n \"inpVar\": [\n  \" &pckt_srcs\",\n  \" &ipv4_src\"\n ]\n}"], "bpf_xdp_adjust_head": ["{\n \"opVar\": \"NA\",\n \"inpVar\": [\n  \"  if           xdp\",\n  \" 0 - intsizeofstruct iphdr + intsizeofstruct udphdr \"\n ]\n}"]}}}], "gue_encap_v6": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/pckt_encap.h", "startLine": "309", "endLine": "367", "capability": {"capability": [{"update_pkt": [{"Description": "Adjust (move) xdp_md->data by <[ delta ]>(IP: 1) bytes. Note that it is possible to use a negative value for delta. This helper can be used to prepare the packet for pushing or popping headers. A call to this helper is susceptible to change the underlaying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": "0 on success, or a negative error in case of failure.", "Return Type": "int", "Function Name": "bpf_xdp_adjust_head", "Input Params": ["{Type: struct xdp_buff ,Var: *xdp_md}", "{Type:  int ,Var: delta}"]}]}, {"map_read": [{"Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": "Map value associated to key, or NULL if no entry was found.", "Return Type": "void", "Function Name": "*bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"bpf_map_lookup_elem": ["{\n \"opVar\": \"  src \",\n \"inpVar\": [\n  \" &pckt_srcs\",\n  \" &key\"\n ]\n}"], "bpf_xdp_adjust_head": ["{\n \"opVar\": \"NA\",\n \"inpVar\": [\n  \"    if           xdp\",\n  \"          0 - intsizeofstruct ipv6hdr + intsizeofstruct udphdr \"\n ]\n}"]}}}], "gue_decap_v4": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/pckt_encap.h", "startLine": "372", "endLine": "389", "capability": {"capability": [{"update_pkt": [{"Description": "Adjust (move) xdp_md->data by <[ delta ]>(IP: 1) bytes. Note that it is possible to use a negative value for delta. This helper can be used to prepare the packet for pushing or popping headers. A call to this helper is susceptible to change the underlaying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": "0 on success, or a negative error in case of failure.", "Return Type": "int", "Function Name": "bpf_xdp_adjust_head", "Input Params": ["{Type: struct xdp_buff ,Var: *xdp_md}", "{Type:  int ,Var: delta}"]}]}], "helperCallParams": {"bpf_xdp_adjust_head": ["{\n \"opVar\": \"NA\",\n \"inpVar\": [\n  \"  if           xdp\",\n  \" intsizeofstruct iphdr + sizeofstruct udphdr \"\n ]\n}"]}}}], "gue_decap_v6": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/pckt_encap.h", "startLine": "391", "endLine": "412", "capability": {"capability": [{"update_pkt": [{"Description": "Adjust (move) xdp_md->data by <[ delta ]>(IP: 1) bytes. Note that it is possible to use a negative value for delta. This helper can be used to prepare the packet for pushing or popping headers. A call to this helper is susceptible to change the underlaying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": "0 on success, or a negative error in case of failure.", "Return Type": "int", "Function Name": "bpf_xdp_adjust_head", "Input Params": ["{Type: struct xdp_buff ,Var: *xdp_md}", "{Type:  int ,Var: delta}"]}]}], "helperCallParams": {"bpf_xdp_adjust_head": ["{\n \"opVar\": \"NA\",\n \"inpVar\": [\n  \"    if           xdp\",\n  \" intsizeofstruct ipv6hdr + sizeofstruct udphdr \"\n ]\n}"]}}}], "set_hc_key": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/healthchecking_helpers.h", "startLine": "37", "endLine": "77", "capability": {"capability": [], "helperCallParams": {}}}], "hc_encap_ipip": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/healthchecking_helpers.h", "startLine": "79", "endLine": "139", "capability": {"capability": [{"update_pkt": [{"Description": "Grow or shrink the room for data in the packet associated to <[ skb ]>(IP: 0) by <[ len_diff ]>(IP: 1) , and according to the selected mode. There is a single supported <[ mode ]>(IP: 2) at this time:BPF_ADJ_ROOM_NET: Adjust room at the network layer (room space is added or removed below the layer 3 header). All values for <[ flags ]>(IP: 3) are reserved for future usage , and must be left at zero. A call to this helper is susceptible to change the underlaying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": "0 on success, or a negative error in case of failure.", "Return Type": "int", "Function Name": "bpf_skb_adjust_room", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  u32 ,Var: len_diff}", "{Type:  u32 ,Var: mode}", "{Type:  u64 ,Var: flags}"]}]}, {"map_read": [{"Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": "Map value associated to key, or NULL if no entry was found.", "Return Type": "void", "Function Name": "*bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"bpf_map_lookup_elem": ["{\n \"opVar\": \"    src \",\n \"inpVar\": [\n  \" &hc_pckt_srcs_map\",\n  \" &key\"\n ]\n}", "{\n \"opVar\": \"    src \",\n \"inpVar\": [\n  \" &hc_pckt_srcs_map\",\n  \" &key\"\n ]\n}"], "bpf_skb_adjust_room": ["{\n \"opVar\": \"NA\",\n \"inpVar\": [\n  \"        if skb\",\n  \" adjust_len\",\n  \" BPF_ADJ_ROOM_MAC\",\n  \" flags \"\n ]\n}", "{\n \"opVar\": \"NA\",\n \"inpVar\": [\n  \"        if skb\",\n  \" adjust_len\",\n  \" BPF_ADJ_ROOM_MAC\",\n  \" flags \"\n ]\n}"]}}}], "gue_sport": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/healthchecking_helpers.h", "startLine": "141", "endLine": "143", "capability": {"capability": [], "helperCallParams": {}}}], "hc_encap_gue": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/healthchecking_helpers.h", "startLine": "145", "endLine": "213", "capability": {"capability": [{"update_pkt": [{"Description": "Grow or shrink the room for data in the packet associated to <[ skb ]>(IP: 0) by <[ len_diff ]>(IP: 1) , and according to the selected mode. There is a single supported <[ mode ]>(IP: 2) at this time:BPF_ADJ_ROOM_NET: Adjust room at the network layer (room space is added or removed below the layer 3 header). All values for <[ flags ]>(IP: 3) are reserved for future usage , and must be left at zero. A call to this helper is susceptible to change the underlaying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": "0 on success, or a negative error in case of failure.", "Return Type": "int", "Function Name": "bpf_skb_adjust_room", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  u32 ,Var: len_diff}", "{Type:  u32 ,Var: mode}", "{Type:  u64 ,Var: flags}"]}]}, {"map_read": [{"Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": "Map value associated to key, or NULL if no entry was found.", "Return Type": "void", "Function Name": "*bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"bpf_map_lookup_elem": ["{\n \"opVar\": \"    src \",\n \"inpVar\": [\n  \" &hc_pckt_srcs_map\",\n  \" &key\"\n ]\n}", "{\n \"opVar\": \"    src \",\n \"inpVar\": [\n  \" &hc_pckt_srcs_map\",\n  \" &key\"\n ]\n}"], "bpf_skb_adjust_room": ["{\n \"opVar\": \"NA\",\n \"inpVar\": [\n  \"        if skb\",\n  \" adjust_len\",\n  \" BPF_ADJ_ROOM_MAC\",\n  \" flags \"\n ]\n}", "{\n \"opVar\": \"NA\",\n \"inpVar\": [\n  \"        if skb\",\n  \" adjust_len\",\n  \" BPF_ADJ_ROOM_MAC\",\n  \" flags \"\n ]\n}"]}}}], "create_v4_hdr": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/encap_helpers.h", "startLine": "31", "endLine": "55", "capability": {"capability": [], "helperCallParams": {}}}], "create_v6_hdr": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/encap_helpers.h", "startLine": "57", "endLine": "77", "capability": {"capability": [], "helperCallParams": {}}}], "create_udp_hdr": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/encap_helpers.h", "startLine": "79", "endLine": "89", "capability": {"capability": [], "helperCallParams": {}}}], "rol32": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/jhash.h", "startLine": "7", "endLine": "9", "capability": {"capability": [], "helperCallParams": {}}}], "jhash": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/jhash.h", "startLine": "55", "endLine": "100", "capability": {"capability": [], "helperCallParams": {}}}], "__jhash_nwords": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/jhash.h", "startLine": "102", "endLine": "108", "capability": {"capability": [], "helperCallParams": {}}}], "jhash_2words": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/jhash.h", "startLine": "110", "endLine": "112", "capability": {"capability": [], "helperCallParams": {}}}], "jhash_1word": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/jhash.h", "startLine": "114", "endLine": "116", "capability": {"capability": [], "helperCallParams": {}}}], "submit_event": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/balancer_helpers.h", "startLine": "46", "endLine": "70", "capability": {"capability": [{"map_read": [{"Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": "Map value associated to key, or NULL if no entry was found.", "Return Type": "void", "Function Name": "*bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"bpf_map_lookup_elem": ["{\n \"opVar\": \"  gk \",\n \"inpVar\": [\n  \" &ctl_array\",\n  \" &introspection_gk_pos\"\n ]\n}"], "bpf_perf_event_output": ["{\n \"opVar\": \"NA\",\n \"inpVar\": [\n  \"    ctx\",\n  \" map\",\n  \" flags\",\n  \" &md\",\n  \" sizeofstruct event_metadata\"\n ]\n}"]}}}], "recirculate": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/balancer_helpers.h", "startLine": "74", "endLine": "80", "capability": {"capability": [{"pkt_go_to_next_module": [{"Return Type": "int", "Input Params": [], "Function Name": "XDP_PASS", "Return": 2, "Description": "The XDP_PASS return code means that the packet is allowed to be passed up to the kernel\u2019s networking stack. Meaning, the current CPU that was processing this packet now allocates a skb, populates it, and passes it onwards into the GRO engine. This would be equivalent to the default packet handling behavior without XDP."}]}], "helperCallParams": {"bpf_tail_call": ["{\n \"opVar\": \"NA\",\n \"inpVar\": [\n  \"  ctx\",\n  \" &subprograms\",\n  \" i\"\n ]\n}"]}}}], "decrement_ttl": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/balancer_helpers.h", "startLine": "83", "endLine": "111", "capability": {"capability": [{"pkt_stop_processing_drop_packet": [{"Return Type": "int", "Input Params": [], "Function Name": "XDP_DROP", "Return": 1, "Description": "will drop the packet right at the driver level without wasting any further resources. This is in particular useful for BPF programs implementing DDoS mitigation mechanisms or firewalling in general."}]}], "helperCallParams": {}}}], "calc_offset": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/pckt_parsing.h", "startLine": "58", "endLine": "74", "capability": {"capability": [], "helperCallParams": {}}}], "parse_udp": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/pckt_parsing.h", "startLine": "76", "endLine": "100", "capability": {"capability": [], "helperCallParams": {}}}], "parse_tcp": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/pckt_parsing.h", "startLine": "102", "endLine": "130", "capability": {"capability": [], "helperCallParams": {}}}], "parse_hdr_opt": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/pckt_parsing.h", "startLine": "144", "endLine": "197", "capability": {"capability": [], "helperCallParams": {}}}], "tcp_hdr_opt_lookup": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/pckt_parsing.h", "startLine": "199", "endLine": "273", "capability": {"capability": [{"map_read": [{"Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": "Map value associated to key, or NULL if no entry was found.", "Return Type": "void", "Function Name": "*bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}, {"map_update": [{"Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of:BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ", "Return": "0 on success, or a negative error in case of failure.", "Return Type": "int", "Function Name": "bpf_map_update_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}", "{Type:  const void ,Var: *value}", "{Type:  u64 ,Var: flags}"]}]}], "helperCallParams": {"bpf_map_lookup_elem": ["{\n \"opVar\": \"  __u32* real_pos \",\n \"inpVar\": [\n  \" &server_id_map\",\n  \" &key\"\n ]\n}", "{\n \"opVar\": \"  *real \",\n \"inpVar\": [\n  \" &reals\",\n  \" &key\"\n ]\n}", "{\n \"opVar\": \"    struct real_pos_lru* dst_lru \",\n \"inpVar\": [\n  \" lru_map\",\n  \" &pckt->flow\"\n ]\n}"], "bpf_map_update_elem": ["{\n \"opVar\": \"NA\",\n \"inpVar\": [\n  \"    lru_map\",\n  \" &pckt->flow\",\n  \" &new_dst_lru\",\n  \" BPF_ANY\"\n ]\n}"]}}}], "parse_quic": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/pckt_parsing.h", "startLine": "276", "endLine": "335", "capability": {"capability": [], "helperCallParams": {}}}], "get_next_ports": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/flow_debug_helpers.h", "startLine": "29", "endLine": "53", "capability": {"capability": [], "helperCallParams": {}}}], "gue_record_route": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/flow_debug_helpers.h", "startLine": "55", "endLine": "128", "capability": {"capability": [{"read_sys_info": [{"Description": "Get the SMP (symmetric multiprocessing) processor id. Note that all programs run with preemption disabled , which means that the SMP processor id is stable during all the execution of the program. ", "Return": "The SMP id of the processor running the program.", "Return Type": "u32", "Function Name": "bpf_get_smp_processor_id", "Input Params": ["{Type: voi ,Var: void}"]}]}], "helperCallParams": {"bpf_get_smp_processor_id": ["{\n \"opVar\": \"  __u32 cpu_num \",\n \"inpVar\": [\n  \" \"\n ]\n}"]}}}], "csum_fold_helper": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/csum_helpers.h", "startLine": "30", "endLine": "39", "capability": {"capability": [], "helperCallParams": {}}}], "min_helper": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/csum_helpers.h", "startLine": "41", "endLine": "43", "capability": {"capability": [], "helperCallParams": {}}}], "ipv4_csum": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/csum_helpers.h", "startLine": "45", "endLine": "49", "capability": {"capability": [{"read_skb": [{"Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways:With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with bpf_l3_csum_replace() and bpf_l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with bpf_csum_diff(). ", "Return": "The checksum result, or a negative error code in case of failure.", "Return Type": "s64", "Function Name": "bpf_csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"]}]}], "helperCallParams": {"bpf_csum_diff": ["{\n \"opVar\": \"  *csum \",\n \"inpVar\": [\n  \" 0\",\n  \" 0\",\n  \" data_start\",\n  \" data_size\",\n  \" *csum\"\n ]\n}"]}}}], "ipv4_csum_inline": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/csum_helpers.h", "startLine": "51", "endLine": "60", "capability": {"capability": [], "helperCallParams": {}}}], "ipv4_l4_csum": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/csum_helpers.h", "startLine": "62", "endLine": "73", "capability": {"capability": [{"read_skb": [{"Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways:With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with bpf_l3_csum_replace() and bpf_l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with bpf_csum_diff(). ", "Return": "The checksum result, or a negative error code in case of failure.", "Return Type": "s64", "Function Name": "bpf_csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"]}]}], "helperCallParams": {"bpf_csum_diff": ["{\n \"opVar\": \"  *csum \",\n \"inpVar\": [\n  \" 0\",\n  \" 0\",\n  \" &iph->saddr\",\n  \" sizeof__be32\",\n  \" *csum\"\n ]\n}", "{\n \"opVar\": \"  *csum \",\n \"inpVar\": [\n  \" 0\",\n  \" 0\",\n  \" &iph->daddr\",\n  \" sizeof__be32\",\n  \" *csum\"\n ]\n}", "{\n \"opVar\": \"  *csum \",\n \"inpVar\": [\n  \" 0\",\n  \" 0\",\n  \" &tmp\",\n  \" sizeof__u32\",\n  \" *csum\"\n ]\n}", "{\n \"opVar\": \"  *csum \",\n \"inpVar\": [\n  \" 0\",\n  \" 0\",\n  \" &tmp\",\n  \" sizeof__u32\",\n  \" *csum\"\n ]\n}", "{\n \"opVar\": \"  *csum \",\n \"inpVar\": [\n  \" 0\",\n  \" 0\",\n  \" data_start\",\n  \" data_size\",\n  \" *csum\"\n ]\n}"]}}}], "ipv6_csum": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/csum_helpers.h", "startLine": "75", "endLine": "88", "capability": {"capability": [{"read_skb": [{"Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways:With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with bpf_l3_csum_replace() and bpf_l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with bpf_csum_diff(). ", "Return": "The checksum result, or a negative error code in case of failure.", "Return Type": "s64", "Function Name": "bpf_csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"]}]}], "helperCallParams": {"bpf_csum_diff": ["{\n \"opVar\": \"  *csum \",\n \"inpVar\": [\n  \" 0\",\n  \" 0\",\n  \" &ip6h->saddr\",\n  \" sizeofstruct in6_addr\",\n  \" *csum\"\n ]\n}", "{\n \"opVar\": \"  *csum \",\n \"inpVar\": [\n  \" 0\",\n  \" 0\",\n  \" &ip6h->daddr\",\n  \" sizeofstruct in6_addr\",\n  \" *csum\"\n ]\n}", "{\n \"opVar\": \"  *csum \",\n \"inpVar\": [\n  \" 0\",\n  \" 0\",\n  \" &tmp\",\n  \" sizeof__u32\",\n  \" *csum\"\n ]\n}", "{\n \"opVar\": \"  *csum \",\n \"inpVar\": [\n  \" 0\",\n  \" 0\",\n  \" &tmp\",\n  \" sizeof__u32\",\n  \" *csum\"\n ]\n}", "{\n \"opVar\": \"    *csum \",\n \"inpVar\": [\n  \" 0\",\n  \" 0\",\n  \" data_start\",\n  \" data_size\",\n  \" *csum\"\n ]\n}"]}}}], "add_pseudo_ipv6_header": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/csum_helpers.h", "startLine": "95", "endLine": "127", "capability": {"capability": [{"read_skb": [{"Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways:With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with bpf_l3_csum_replace() and bpf_l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with bpf_csum_diff(). ", "Return": "The checksum result, or a negative error code in case of failure.", "Return Type": "s64", "Function Name": "bpf_csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"]}]}], "helperCallParams": {"bpf_csum_diff": ["{\n \"opVar\": \"  ret \",\n \"inpVar\": [\n  \" 0\",\n  \" 0\",\n  \" &ip6h->saddr\",\n  \" sizeofstruct in6_addr\",\n  \" *csum\"\n ]\n}", "{\n \"opVar\": \"  ret \",\n \"inpVar\": [\n  \" 0\",\n  \" 0\",\n  \" &ip6h->daddr\",\n  \" sizeofstruct in6_addr\",\n  \" *csum\"\n ]\n}", "{\n \"opVar\": \"  ret \",\n \"inpVar\": [\n  \" 0\",\n  \" 0\",\n  \" &tmp\",\n  \" sizeof__u32\",\n  \" *csum\"\n ]\n}", "{\n \"opVar\": \"  ret \",\n \"inpVar\": [\n  \" 0\",\n  \" 0\",\n  \" &tmp\",\n  \" sizeof__u32\",\n  \" *csum\"\n ]\n}"]}}}], "rem_pseudo_ipv6_header": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/csum_helpers.h", "startLine": "129", "endLine": "158", "capability": {"capability": [{"read_skb": [{"Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways:With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with bpf_l3_csum_replace() and bpf_l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with bpf_csum_diff(). ", "Return": "The checksum result, or a negative error code in case of failure.", "Return Type": "s64", "Function Name": "bpf_csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"]}]}], "helperCallParams": {"bpf_csum_diff": ["{\n \"opVar\": \"  ret \",\n \"inpVar\": [\n  \" &ip6h->saddr\",\n  \" sizeofstruct in6_addr\",\n  \" 0\",\n  \" 0\",\n  \" *csum\"\n ]\n}", "{\n \"opVar\": \"  ret \",\n \"inpVar\": [\n  \" &ip6h->daddr\",\n  \" sizeofstruct in6_addr\",\n  \" 0\",\n  \" 0\",\n  \" *csum\"\n ]\n}", "{\n \"opVar\": \"  ret \",\n \"inpVar\": [\n  \" &tmp\",\n  \" sizeof__u32\",\n  \" 0\",\n  \" 0\",\n  \" *csum\"\n ]\n}", "{\n \"opVar\": \"  ret \",\n \"inpVar\": [\n  \" &tmp\",\n  \" sizeof__u32\",\n  \" 0\",\n  \" 0\",\n  \" *csum\"\n ]\n}"]}}}], "add_pseudo_ipv4_header": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/csum_helpers.h", "startLine": "160", "endLine": "189", "capability": {"capability": [{"read_skb": [{"Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways:With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with bpf_l3_csum_replace() and bpf_l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with bpf_csum_diff(). ", "Return": "The checksum result, or a negative error code in case of failure.", "Return Type": "s64", "Function Name": "bpf_csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"]}]}], "helperCallParams": {"bpf_csum_diff": ["{\n \"opVar\": \"  ret \",\n \"inpVar\": [\n  \" 0\",\n  \" 0\",\n  \" &iph->saddr\",\n  \" sizeof__be32\",\n  \" *csum\"\n ]\n}", "{\n \"opVar\": \"  ret \",\n \"inpVar\": [\n  \" 0\",\n  \" 0\",\n  \" &iph->daddr\",\n  \" sizeof__be32\",\n  \" *csum\"\n ]\n}", "{\n \"opVar\": \"  ret \",\n \"inpVar\": [\n  \" 0\",\n  \" 0\",\n  \" &tmp\",\n  \" sizeof__u32\",\n  \" *csum\"\n ]\n}", "{\n \"opVar\": \"  ret \",\n \"inpVar\": [\n  \" 0\",\n  \" 0\",\n  \" &tmp\",\n  \" sizeof__u32\",\n  \" *csum\"\n ]\n}"]}}}], "rem_pseudo_ipv4_header": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/csum_helpers.h", "startLine": "191", "endLine": "220", "capability": {"capability": [{"read_skb": [{"Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways:With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with bpf_l3_csum_replace() and bpf_l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with bpf_csum_diff(). ", "Return": "The checksum result, or a negative error code in case of failure.", "Return Type": "s64", "Function Name": "bpf_csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"]}]}], "helperCallParams": {"bpf_csum_diff": ["{\n \"opVar\": \"  ret \",\n \"inpVar\": [\n  \" &iph->saddr\",\n  \" sizeof__be32\",\n  \" 0\",\n  \" 0\",\n  \" *csum\"\n ]\n}", "{\n \"opVar\": \"  ret \",\n \"inpVar\": [\n  \" &iph->daddr\",\n  \" sizeof__be32\",\n  \" 0\",\n  \" 0\",\n  \" *csum\"\n ]\n}", "{\n \"opVar\": \"  ret \",\n \"inpVar\": [\n  \" &tmp\",\n  \" sizeof__u32\",\n  \" 0\",\n  \" 0\",\n  \" *csum\"\n ]\n}", "{\n \"opVar\": \"  ret \",\n \"inpVar\": [\n  \" &tmp\",\n  \" sizeof__u32\",\n  \" 0\",\n  \" 0\",\n  \" *csum\"\n ]\n}"]}}}], "gue_csum_v6": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/csum_helpers.h", "startLine": "234", "endLine": "268", "capability": {"capability": [{"read_skb": [{"Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways:With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with bpf_l3_csum_replace() and bpf_l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with bpf_csum_diff(). ", "Return": "The checksum result, or a negative error code in case of failure.", "Return Type": "s64", "Function Name": "bpf_csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"]}]}], "helperCallParams": {"bpf_csum_diff": ["{\n \"opVar\": \"  ret \",\n \"inpVar\": [\n  \" 0\",\n  \" 0\",\n  \" &orig_csum\",\n  \" sizeof__u32\",\n  \" seed\"\n ]\n}", "{\n \"opVar\": \"    ret \",\n \"inpVar\": [\n  \" 0\",\n  \" 0\",\n  \" inner_ip6h\",\n  \" sizeofstruct ipv6hdr\",\n  \" *csum_in_hdr\"\n ]\n}", "{\n \"opVar\": \"  ret \",\n \"inpVar\": [\n  \" 0\",\n  \" 0\",\n  \" udph\",\n  \" sizeofstruct udphdr\",\n  \" *csum_in_hdr\"\n ]\n}"]}}}], "gue_csum_v4": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/csum_helpers.h", "startLine": "270", "endLine": "302", "capability": {"capability": [{"read_skb": [{"Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways:With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with bpf_l3_csum_replace() and bpf_l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with bpf_csum_diff(). ", "Return": "The checksum result, or a negative error code in case of failure.", "Return Type": "s64", "Function Name": "bpf_csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"]}]}], "helperCallParams": {"bpf_csum_diff": ["{\n \"opVar\": \"  ret \",\n \"inpVar\": [\n  \" 0\",\n  \" 0\",\n  \" &orig_csum\",\n  \" sizeof__u32\",\n  \" seed\"\n ]\n}", "{\n \"opVar\": \"    ret \",\n \"inpVar\": [\n  \" 0\",\n  \" 0\",\n  \" inner_iph\",\n  \" sizeofstruct iphdr\",\n  \" *csum_in_hdr\"\n ]\n}", "{\n \"opVar\": \"  ret \",\n \"inpVar\": [\n  \" 0\",\n  \" 0\",\n  \" udph\",\n  \" sizeofstruct udphdr\",\n  \" *csum_in_hdr\"\n ]\n}"]}}}], "gue_csum_v4_in_v6": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/csum_helpers.h", "startLine": "304", "endLine": "336", "capability": {"capability": [{"read_skb": [{"Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways:With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with bpf_l3_csum_replace() and bpf_l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with bpf_csum_diff(). ", "Return": "The checksum result, or a negative error code in case of failure.", "Return Type": "s64", "Function Name": "bpf_csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"]}]}], "helperCallParams": {"bpf_csum_diff": ["{\n \"opVar\": \"  ret \",\n \"inpVar\": [\n  \" 0\",\n  \" 0\",\n  \" &orig_csum\",\n  \" sizeof__u32\",\n  \" seed\"\n ]\n}", "{\n \"opVar\": \"    ret \",\n \"inpVar\": [\n  \" 0\",\n  \" 0\",\n  \" inner_iph\",\n  \" sizeofstruct iphdr\",\n  \" *csum_in_hdr\"\n ]\n}", "{\n \"opVar\": \"  ret \",\n \"inpVar\": [\n  \" 0\",\n  \" 0\",\n  \" udph\",\n  \" sizeofstruct udphdr\",\n  \" *csum_in_hdr\"\n ]\n}"]}}}], "swap_mac_and_send": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/handle_icmp.h", "startLine": "38", "endLine": "48", "capability": {"capability": [{"pkt_alter_or_redo_processing_or_interface": [{"Return Type": "int", "Input Params": [], "Function Name": "XDP_TX", "Return": 3, "Description": "an efficient option to transmit the network packet out of the same NIC it just arrived on again. This is typically useful when few nodes are implementing, for example, firewalling with subsequent load balancing in a cluster and thus act as a hairpinned load balancer pushing the incoming packets back into the switch after rewriting them in XDP BPF."}]}], "helperCallParams": {}}}], "swap_mac": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/handle_icmp.h", "startLine": "50", "endLine": "58", "capability": {"capability": [], "helperCallParams": {}}}], "send_icmp_reply": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/handle_icmp.h", "startLine": "60", "endLine": "90", "capability": {"capability": [{"pkt_stop_processing_drop_packet": [{"Return Type": "int", "Input Params": [], "Function Name": "XDP_DROP", "Return": 1, "Description": "will drop the packet right at the driver level without wasting any further resources. This is in particular useful for BPF programs implementing DDoS mitigation mechanisms or firewalling in general."}]}], "helperCallParams": {}}}], "send_icmp6_reply": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/handle_icmp.h", "startLine": "92", "endLine": "117", "capability": {"capability": [{"pkt_stop_processing_drop_packet": [{"Return Type": "int", "Input Params": [], "Function Name": "XDP_DROP", "Return": 1, "Description": "will drop the packet right at the driver level without wasting any further resources. This is in particular useful for BPF programs implementing DDoS mitigation mechanisms or firewalling in general."}]}], "helperCallParams": {}}}], "send_icmp4_too_big": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/handle_icmp.h", "startLine": "119", "endLine": "162", "capability": {"capability": [{"update_pkt": [{"Description": "Adjust (move) xdp_md->data by <[ delta ]>(IP: 1) bytes. Note that it is possible to use a negative value for delta. This helper can be used to prepare the packet for pushing or popping headers. A call to this helper is susceptible to change the underlaying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": "0 on success, or a negative error in case of failure.", "Return Type": "int", "Function Name": "bpf_xdp_adjust_head", "Input Params": ["{Type: struct xdp_buff ,Var: *xdp_md}", "{Type:  int ,Var: delta}"]}]}, {"pkt_stop_processing_drop_packet": [{"Return Type": "int", "Input Params": [], "Function Name": "XDP_DROP", "Return": 1, "Description": "will drop the packet right at the driver level without wasting any further resources. This is in particular useful for BPF programs implementing DDoS mitigation mechanisms or firewalling in general."}]}, {"pkt_alter_or_redo_processing_or_interface": [{"Return Type": "int", "Input Params": [], "Function Name": "XDP_TX", "Return": 3, "Description": "an efficient option to transmit the network packet out of the same NIC it just arrived on again. This is typically useful when few nodes are implementing, for example, firewalling with subsequent load balancing in a cluster and thus act as a hairpinned load balancer pushing the incoming packets back into the switch after rewriting them in XDP BPF."}]}], "helperCallParams": {"bpf_xdp_adjust_head": ["{\n \"opVar\": \"NA\",\n \"inpVar\": [\n  \"  if xdp\",\n  \" 0 - headroom \"\n ]\n}"]}}}], "send_icmp6_too_big": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/handle_icmp.h", "startLine": "164", "endLine": "203", "capability": {"capability": [{"update_pkt": [{"Description": "Adjust (move) xdp_md->data by <[ delta ]>(IP: 1) bytes. Note that it is possible to use a negative value for delta. This helper can be used to prepare the packet for pushing or popping headers. A call to this helper is susceptible to change the underlaying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": "0 on success, or a negative error in case of failure.", "Return Type": "int", "Function Name": "bpf_xdp_adjust_head", "Input Params": ["{Type: struct xdp_buff ,Var: *xdp_md}", "{Type:  int ,Var: delta}"]}]}, {"pkt_stop_processing_drop_packet": [{"Return Type": "int", "Input Params": [], "Function Name": "XDP_DROP", "Return": 1, "Description": "will drop the packet right at the driver level without wasting any further resources. This is in particular useful for BPF programs implementing DDoS mitigation mechanisms or firewalling in general."}]}, {"pkt_alter_or_redo_processing_or_interface": [{"Return Type": "int", "Input Params": [], "Function Name": "XDP_TX", "Return": 3, "Description": "an efficient option to transmit the network packet out of the same NIC it just arrived on again. This is typically useful when few nodes are implementing, for example, firewalling with subsequent load balancing in a cluster and thus act as a hairpinned load balancer pushing the incoming packets back into the switch after rewriting them in XDP BPF."}]}], "helperCallParams": {"bpf_xdp_adjust_head": ["{\n \"opVar\": \"NA\",\n \"inpVar\": [\n  \"  if xdp\",\n  \" 0 - headroom \"\n ]\n}"]}}}], "send_icmp_too_big": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/handle_icmp.h", "startLine": "205", "endLine": "221", "capability": {"capability": [{"update_pkt": [{"Description": "Adjust (move) xdp_md->data_end by <[ delta ]>(IP: 1) bytes. It is only possible to shrink the packet as of this writing , therefore <[ delta ]>(IP: 1) must be a negative integer. A call to this helper is susceptible to change the underlaying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": "0 on success, or a negative error in case of failure.", "Return Type": "int", "Function Name": "bpf_xdp_adjust_tail", "Input Params": ["{Type: struct xdp_buff ,Var: *xdp_md}", "{Type:  int ,Var: delta}"]}]}, {"pkt_stop_processing_drop_packet": [{"Return Type": "int", "Input Params": [], "Function Name": "XDP_DROP", "Return": 1, "Description": "will drop the packet right at the driver level without wasting any further resources. This is in particular useful for BPF programs implementing DDoS mitigation mechanisms or firewalling in general."}]}], "helperCallParams": {"bpf_xdp_adjust_tail": ["{\n \"opVar\": \"NA\",\n \"inpVar\": [\n  \"    if xdp\",\n  \" 0 - offset \"\n ]\n}"]}}}], "parse_icmpv6": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/handle_icmp.h", "startLine": "223", "endLine": "253", "capability": {"capability": [{"pkt_stop_processing_drop_packet": [{"Return Type": "int", "Input Params": [], "Function Name": "XDP_DROP", "Return": 1, "Description": "will drop the packet right at the driver level without wasting any further resources. This is in particular useful for BPF programs implementing DDoS mitigation mechanisms or firewalling in general."}]}, {"pkt_go_to_next_module": [{"Return Type": "int", "Input Params": [], "Function Name": "XDP_PASS", "Return": 2, "Description": "The XDP_PASS return code means that the packet is allowed to be passed up to the kernel\u2019s networking stack. Meaning, the current CPU that was processing this packet now allocates a skb, populates it, and passes it onwards into the GRO engine. This would be equivalent to the default packet handling behavior without XDP."}]}], "helperCallParams": {}}}], "parse_icmp": [{"fileName": "/home/sayandes/opened_extraction/examples/katran/handle_icmp.h", "startLine": "255", "endLine": "285", "capability": {"capability": [{"pkt_stop_processing_drop_packet": [{"Return Type": "int", "Input Params": [], "Function Name": "XDP_DROP", "Return": 1, "Description": "will drop the packet right at the driver level without wasting any further resources. This is in particular useful for BPF programs implementing DDoS mitigation mechanisms or firewalling in general."}]}, {"pkt_go_to_next_module": [{"Return Type": "int", "Input Params": [], "Function Name": "XDP_PASS", "Return": 2, "Description": "The XDP_PASS return code means that the packet is allowed to be passed up to the kernel\u2019s networking stack. Meaning, the current CPU that was processing this packet now allocates a skb, populates it, and passes it onwards into the GRO engine. This would be equivalent to the default packet handling behavior without XDP."}]}], "helperCallParams": {}}}]}