{"is_under_flood": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "libbpf", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}, {"capability": "read_sys_info", "read_sys_info": [{"Project": "bcc", "FunctionName": "bpf_ktime_get_ns", "Return Type": "u64", "Description": "u64 bpf_ktime_get_ns(void) Return: u64 number of nanoseconds. Starts at system boot time but stops during suspend. Examples in situ: \"https://github.com/iovisor/bcc/search?q=bpf_ktime_get_ns+path%3Aexamples&type=Code search /examples , \"https://github.com/iovisor/bcc/search?q=bpf_ktime_get_ns+path%3Atools&type=Code search /tools ", "Return": "u64 number of nanoseconds", "Input Prameters": [], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "raw_tracepoint_writable"], "capabilities": ["read_sys_info"]}]}], "helperCallParams": {}, "startLine": 25, "endLine": 50, "File": "/home/sayandes/opened_extraction/examples/katran/balancer_kern.c", "funcName": "is_under_flood", "developer_inline_comments": [{"start_line": 1, "end_line": 4, "text": "/*\n * Copyright 2004-present Facebook. All Rights Reserved.\n * This is main balancer's application code\n */"}, {"start_line": 34, "end_line": 34, "text": "// we are going to check that new connections rate is less than predefined"}, {"start_line": 35, "end_line": 35, "text": "// value; conn_rate_stats.v1 contains number of new connections for the last"}, {"start_line": 36, "end_line": 36, "text": "// second, v2 - when last time quanta started."}, {"start_line": 38, "end_line": 38, "text": "// new time quanta; reseting counters"}, {"start_line": 44, "end_line": 44, "text": "// we are exceding max connections rate. bypasing lru update and"}, {"start_line": 45, "end_line": 45, "text": "// source routing lookup"}], "updateMaps": [], "readMaps": [" stats"], "input": ["__u64 *cur_time"], "output": "staticinlinebool", "helper": ["bpf_map_lookup_elem", "bpf_ktime_get_ns"], "compatibleHookpoints": ["cgroup_skb", "sk_skb", "kprobe", "socket_filter", "tracepoint", "xdp", "raw_tracepoint_writable", "flow_dissector", "lwt_seg6local", "sched_cls", "lwt_out", "sched_act", "cgroup_sock_addr", "sk_reuseport", "lwt_xmit", "sock_ops", "perf_event", "raw_tracepoint", "sk_msg", "lwt_in", "cgroup_sock"], "source": ["static inline bool is_under_flood (__u64 *cur_time)\n", "{\n", "    __u32 conn_rate_key = MAX_VIPS + NEW_CONN_RATE_CNTR;\n", "    struct lb_stats *conn_rate_stats = bpf_map_lookup_elem (&stats, &conn_rate_key);\n", "    if (!conn_rate_stats) {\n", "        return true;\n", "    }\n", "    *cur_time = bpf_ktime_get_ns ();\n", "    if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {\n", "        conn_rate_stats->v1 = 1;\n", "        conn_rate_stats->v2 = *cur_time;\n", "    }\n", "    else {\n", "        conn_rate_stats->v1 += 1;\n", "        if (conn_rate_stats->v1 > MAX_CONN_RATE) {\n", "            return true;\n", "        }\n", "    }\n", "    return false;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{"description": " Check how many connection have been made within the last one second(or other predefined value), function will return true if it's exceding the max connection rate and false otherwise. ", "author": "Nengneng Yu", "authorEmail": "ynn1999@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "get_packet_dst": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "libbpf", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}, {"capability": "map_update", "map_update": [{"Project": "libbpf", "Return Type": "int", "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_map_update_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}", "{Type:  const void ,Var: *value}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_update"]}]}], "helperCallParams": {}, "startLine": 53, "endLine": 131, "File": "/home/sayandes/opened_extraction/examples/katran/balancer_kern.c", "funcName": "get_packet_dst", "developer_inline_comments": [{"start_line": 8, "end_line": 8, "text": "// to update lru w/ new connection"}, {"start_line": 52, "end_line": 52, "text": "// service which only use dst port for hash calculation"}, {"start_line": 53, "end_line": 53, "text": "// e.g. if packets has same dst port -> they will go to the same real."}, {"start_line": 54, "end_line": 54, "text": "// usually VoIP related services."}], "updateMaps": [" lru_map"], "readMaps": ["  lpm_src_v6", "  ch_rings", " stats", " reals", "  lpm_src_v4"], "input": ["struct real_definition **real", " struct packet_description *pckt", " struct vip_meta *vip_info", " bool is_ipv6", " void *lru_map"], "output": "staticinlinebool", "helper": ["bpf_map_lookup_elem", "bpf_map_update_elem"], "compatibleHookpoints": ["cgroup_skb", "sk_skb", "kprobe", "cgroup_device", "tracepoint", "socket_filter", "xdp", "raw_tracepoint_writable", "flow_dissector", "lwt_seg6local", "sched_cls", "lwt_out", "sched_act", "cgroup_sysctl", "cgroup_sock_addr", "sk_reuseport", "lwt_xmit", "sock_ops", "perf_event", "raw_tracepoint", "sk_msg", "lwt_in", "cgroup_sock"], "source": ["static inline bool get_packet_dst (struct real_definition **real, struct packet_description *pckt, struct vip_meta *vip_info, bool is_ipv6, void *lru_map)\n", "{\n", "    struct real_pos_lru new_dst_lru = {}\n", "    ;\n", "    bool under_flood = false;\n", "    bool src_found = false;\n", "    __u32 *real_pos;\n", "    __u64 cur_time = 0;\n", "    __u32 hash;\n", "    __u32 key;\n", "    under_flood = is_under_flood (& cur_time);\n", "\n", "#ifdef LPM_SRC_LOOKUP\n", "    if ((vip_info->flags & F_SRC_ROUTING) && !under_flood) {\n", "        __u32 *lpm_val;\n", "        if (is_ipv6) {\n", "            struct v6_lpm_key lpm_key_v6 = {}\n", "            ;\n", "            lpm_key_v6.prefixlen = 128;\n", "            memcpy (lpm_key_v6.addr, pckt->flow.srcv6, 16);\n", "            lpm_val = bpf_map_lookup_elem (& lpm_src_v6, & lpm_key_v6);\n", "        }\n", "        else {\n", "            struct v4_lpm_key lpm_key_v4 = {}\n", "            ;\n", "            lpm_key_v4.addr = pckt->flow.src;\n", "            lpm_key_v4.prefixlen = 32;\n", "            lpm_val = bpf_map_lookup_elem (& lpm_src_v4, & lpm_key_v4);\n", "        }\n", "        if (lpm_val) {\n", "            src_found = true;\n", "            key = *lpm_val;\n", "        }\n", "        __u32 stats_key = MAX_VIPS + LPM_SRC_CNTRS;\n", "        struct lb_stats *data_stats = bpf_map_lookup_elem (&stats, &stats_key);\n", "        if (data_stats) {\n", "            if (src_found) {\n", "                data_stats->v2 += 1;\n", "            }\n", "            else {\n", "                data_stats->v1 += 1;\n", "            }\n", "        }\n", "    }\n", "\n", "#endif\n", "    if (!src_found) {\n", "        bool hash_16bytes = is_ipv6;\n", "        if (vip_info->flags & F_HASH_DPORT_ONLY) {\n", "            pckt->flow.port16[0] = pckt->flow.port16[1];\n", "            memset (pckt->flow.srcv6, 0, 16);\n", "        }\n", "        hash = get_packet_hash (pckt, hash_16bytes) % RING_SIZE;\n", "        key = RING_SIZE * (vip_info->vip_num) + hash;\n", "        real_pos = bpf_map_lookup_elem (& ch_rings, & key);\n", "        if (!real_pos) {\n", "            return false;\n", "        }\n", "        key = *real_pos;\n", "    }\n", "    pckt->real_index = key;\n", "    *real = bpf_map_lookup_elem (&reals, &key);\n", "    if (!(*real)) {\n", "        return false;\n", "    }\n", "    if (lru_map && !(vip_info->flags & F_LRU_BYPASS) && !under_flood) {\n", "        if (pckt->flow.proto == IPPROTO_UDP) {\n", "            new_dst_lru.atime = cur_time;\n", "        }\n", "        new_dst_lru.pos = key;\n", "        bpf_map_update_elem (lru_map, &pckt->flow, &new_dst_lru, BPF_ANY);\n", "    }\n", "    return true;\n", "}\n"], "called_function_list": ["is_under_flood", "get_packet_hash"], "call_depth": 3, "humanFuncDescription": [{"description": " This function checks the source routing for new connections. ", "author": "Nengneng Yu", "authorEmail": "ynn1999@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "connection_table_lookup": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "libbpf", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}, {"capability": "read_sys_info", "read_sys_info": [{"Project": "bcc", "FunctionName": "bpf_ktime_get_ns", "Return Type": "u64", "Description": "u64 bpf_ktime_get_ns(void) Return: u64 number of nanoseconds. Starts at system boot time but stops during suspend. Examples in situ: \"https://github.com/iovisor/bcc/search?q=bpf_ktime_get_ns+path%3Aexamples&type=Code search /examples , \"https://github.com/iovisor/bcc/search?q=bpf_ktime_get_ns+path%3Atools&type=Code search /tools ", "Return": "u64 number of nanoseconds", "Input Prameters": [], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "raw_tracepoint_writable"], "capabilities": ["read_sys_info"]}]}], "helperCallParams": {}, "startLine": 133, "endLine": 156, "File": "/home/sayandes/opened_extraction/examples/katran/balancer_kern.c", "funcName": "connection_table_lookup", "developer_inline_comments": [], "updateMaps": [], "readMaps": [" lru_map", " reals"], "input": ["struct real_definition **real", " struct packet_description *pckt", " void *lru_map", " bool isGlobalLru"], "output": "staticinlinevoid", "helper": ["bpf_map_lookup_elem", "bpf_ktime_get_ns"], "compatibleHookpoints": ["cgroup_skb", "sk_skb", "kprobe", "socket_filter", "tracepoint", "xdp", "raw_tracepoint_writable", "flow_dissector", "lwt_seg6local", "sched_cls", "lwt_out", "sched_act", "cgroup_sock_addr", "sk_reuseport", "lwt_xmit", "sock_ops", "perf_event", "raw_tracepoint", "sk_msg", "lwt_in", "cgroup_sock"], "source": ["static inline void connection_table_lookup (struct real_definition **real, struct packet_description *pckt, void *lru_map, bool isGlobalLru)\n", "{\n", "    struct real_pos_lru *dst_lru;\n", "    __u64 cur_time;\n", "    __u32 key;\n", "    dst_lru = bpf_map_lookup_elem (lru_map, & pckt -> flow);\n", "    if (!dst_lru) {\n", "        return;\n", "    }\n", "    if (!isGlobalLru && pckt->flow.proto == IPPROTO_UDP) {\n", "        cur_time = bpf_ktime_get_ns ();\n", "        if (cur_time - dst_lru->atime > LRU_UDP_TIMEOUT) {\n", "            return;\n", "        }\n", "        dst_lru->atime = cur_time;\n", "    }\n", "    key = dst_lru->pos;\n", "    pckt->real_index = key;\n", "    *real = bpf_map_lookup_elem (&reals, &key);\n", "    return;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{"description": " First check if the packet flow exists in lru_map and whether this connection is legal regarding its connection time(only check this if it is UDP protocol). Then we update the input real using the info from reals ", "author": "Nengneng Yu", "authorEmail": "ynn1999@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "process_l3_headers": [{"capabilities": [{"capability": "pkt_stop_processing_drop_packet", "pkt_stop_processing_drop_packet": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_DROP", "Return": 1, "Description": "will drop the packet right at the driver level without wasting any further resources. This is in particular useful for BPF programs implementing DDoS mitigation mechanisms or firewalling in general.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_stop_processing_drop_packet"]}]}], "helperCallParams": {}, "startLine": 158, "endLine": 230, "File": "/home/sayandes/opened_extraction/examples/katran/balancer_kern.c", "funcName": "process_l3_headers", "developer_inline_comments": [{"start_line": 23, "end_line": 23, "text": "// copy tos from the packet"}, {"start_line": 30, "end_line": 30, "text": "// we drop fragmented packets"}, {"start_line": 46, "end_line": 46, "text": "// ihl contains len of ipv4 header in 32bit words"}, {"start_line": 48, "end_line": 48, "text": "// if len of ipv4 hdr is not equal to 20bytes that means that header"}, {"start_line": 49, "end_line": 49, "text": "// contains ip options, and we dont support em"}, {"start_line": 59, "end_line": 59, "text": "// we drop fragmented packets."}], "updateMaps": [], "readMaps": [], "input": ["struct packet_description *pckt", " __u8 *protocol", " __u64 off", " __u16 *pkt_bytes", " void *data", " void *data_end", " bool is_ipv6"], "output": "staticinlineint", "helper": ["XDP_DROP"], "compatibleHookpoints": ["xdp"], "source": ["static inline int process_l3_headers (struct packet_description *pckt, __u8 *protocol, __u64 off, __u16 *pkt_bytes, void *data, void *data_end, bool is_ipv6)\n", "{\n", "    __u64 iph_len;\n", "    int action;\n", "    struct iphdr *iph;\n", "    struct ipv6hdr *ip6h;\n", "    if (is_ipv6) {\n", "        ip6h = data + off;\n", "        if (ip6h + 1 > data_end) {\n", "            return XDP_DROP;\n", "        }\n", "        iph_len = sizeof (struct ipv6hdr);\n", "        *protocol = ip6h->nexthdr;\n", "        pckt->flow.proto = *protocol;\n", "        pckt->tos = (ip6h->priority << 4) & 0xF0;\n", "        pckt->tos = pckt->tos | ((ip6h->flow_lbl[0] >> 4) & 0x0F);\n", "        *pkt_bytes = bpf_ntohs (ip6h->payload_len);\n", "        off += iph_len;\n", "        if (*protocol == IPPROTO_FRAGMENT) {\n", "            return XDP_DROP;\n", "        }\n", "        else if (*protocol == IPPROTO_ICMPV6) {\n", "            action = parse_icmpv6 (data, data_end, off, pckt);\n", "            if (action >= 0) {\n", "                return action;\n", "            }\n", "        }\n", "        else {\n", "            memcpy (pckt->flow.srcv6, ip6h->saddr.s6_addr32, 16);\n", "            memcpy (pckt->flow.dstv6, ip6h->daddr.s6_addr32, 16);\n", "        }\n", "    }\n", "    else {\n", "        iph = data + off;\n", "        if (iph + 1 > data_end) {\n", "            return XDP_DROP;\n", "        }\n", "        if (iph->ihl != 5) {\n", "            return XDP_DROP;\n", "        }\n", "        pckt->tos = iph->tos;\n", "        *protocol = iph->protocol;\n", "        pckt->flow.proto = *protocol;\n", "        *pkt_bytes = bpf_ntohs (iph->tot_len);\n", "        off += IPV4_HDR_LEN_NO_OPT;\n", "        if (iph->frag_off & PCKT_FRAGMENTED) {\n", "            return XDP_DROP;\n", "        }\n", "        if (*protocol == IPPROTO_ICMP) {\n", "            action = parse_icmp (data, data_end, off, pckt);\n", "            if (action >= 0) {\n", "                return action;\n", "            }\n", "        }\n", "        else {\n", "            pckt->flow.src = iph->saddr;\n", "            pckt->flow.dst = iph->daddr;\n", "        }\n", "    }\n", "    return FURTHER_PROCESSING;\n", "}\n"], "called_function_list": ["parse_icmpv6", "parse_icmp"], "call_depth": 3, "humanFuncDescription": [{"description": " Function processes the packet based on protocol and stores information in packet_description structure  ", "author": "Nengneng Yu", "authorEmail": "ynn1999@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [{"capability": "pkt_stop_processing_drop_packet", "pkt_stop_processing_drop_packet": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_DROP", "Return": 1, "Description": "will drop the packet right at the driver level without wasting any further resources. This is in particular useful for BPF programs implementing DDoS mitigation mechanisms or firewalling in general.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_stop_processing_drop_packet"]}]}], "helperCallParams": {}, "startLine": 34, "endLine": 83, "File": "/home/sayandes/opened_extraction/examples/katran/decap_kern.c", "funcName": "process_l3_headers", "developer_inline_comments": [{"start_line": 1, "end_line": 15, "text": "/* Copyright (C) 2019-present, Facebook, Inc.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; version 2 of the License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */"}, {"start_line": 57, "end_line": 57, "text": "// we drop fragmented packets"}, {"start_line": 65, "end_line": 65, "text": "// ihl contains len of ipv4 header in 32bit words"}, {"start_line": 67, "end_line": 67, "text": "// if len of ipv4 hdr is not equal to 20bytes that means that header"}, {"start_line": 68, "end_line": 68, "text": "// contains ip options, and we dont support em"}, {"start_line": 78, "end_line": 78, "text": "// we drop fragmented packets."}], "updateMaps": [], "readMaps": [], "input": ["struct packet_description *pckt", " __u8 *protocol", " __u64 off", " __u16 *pkt_bytes", " void *data", " void *data_end", " bool is_ipv6"], "output": "staticinlineint", "helper": ["XDP_DROP"], "compatibleHookpoints": ["xdp"], "source": ["static inline int process_l3_headers (struct packet_description *pckt, __u8 *protocol, __u64 off, __u16 *pkt_bytes, void *data, void *data_end, bool is_ipv6)\n", "{\n", "    __u64 iph_len;\n", "    struct iphdr *iph;\n", "    struct ipv6hdr *ip6h;\n", "    if (is_ipv6) {\n", "        ip6h = data + off;\n", "        if (ip6h + 1 > data_end) {\n", "            return XDP_DROP;\n", "        }\n", "        iph_len = sizeof (struct ipv6hdr);\n", "        *protocol = ip6h->nexthdr;\n", "        pckt->flow.proto = *protocol;\n", "        *pkt_bytes = bpf_ntohs (ip6h->payload_len);\n", "        off += iph_len;\n", "        if (*protocol == IPPROTO_FRAGMENT) {\n", "            return XDP_DROP;\n", "        }\n", "    }\n", "    else {\n", "        iph = data + off;\n", "        if (iph + 1 > data_end) {\n", "            return XDP_DROP;\n", "        }\n", "        if (iph->ihl != 5) {\n", "            return XDP_DROP;\n", "        }\n", "        *protocol = iph->protocol;\n", "        pckt->flow.proto = *protocol;\n", "        *pkt_bytes = bpf_ntohs (iph->tot_len);\n", "        off += IPV4_HDR_LEN_NO_OPT;\n", "        if (iph->frag_off & PCKT_FRAGMENTED) {\n", "            return XDP_DROP;\n", "        }\n", "    }\n", "    return FURTHER_PROCESSING;\n", "}\n"], "called_function_list": ["parse_icmpv6", "parse_icmp"], "call_depth": 3, "humanFuncDescription": [{"description": " Process layer 3 headers. Drop the packet if it is 1)bogus packet, len less than minimum ethernet frame size, 2)fragmented, 3)ipv4 header not equals to 20 bytes,                   which means it contains ip options, and we do not support them.                   Otherwise, perform decapsulation of the packet header. ", "author": "Qintian Huang", "authorEmail": "qthuang@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "check_decap_dst": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "libbpf", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}, {"capability": "pkt_stop_processing_drop_packet", "pkt_stop_processing_drop_packet": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_DROP", "Return": 1, "Description": "will drop the packet right at the driver level without wasting any further resources. This is in particular useful for BPF programs implementing DDoS mitigation mechanisms or firewalling in general.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_stop_processing_drop_packet"]}]}], "helperCallParams": {}, "startLine": 233, "endLine": 255, "File": "/home/sayandes/opened_extraction/examples/katran/balancer_kern.c", "funcName": "check_decap_dst", "developer_inline_comments": [], "updateMaps": [], "readMaps": [" decap_dst", "  stats"], "input": ["struct packet_description *pckt", " bool is_ipv6", " bool *pass"], "output": "staticinlineint", "helper": ["bpf_map_lookup_elem", "XDP_DROP"], "compatibleHookpoints": ["xdp"], "source": ["static inline int check_decap_dst (struct packet_description *pckt, bool is_ipv6, bool *pass)\n", "{\n", "    struct address dst_addr = {}\n", "    ;\n", "    struct lb_stats *data_stats;\n", "    if (is_ipv6) {\n", "        memcpy (dst_addr.addrv6, pckt->flow.dstv6, 16);\n", "    }\n", "    else {\n", "        dst_addr.addr = pckt->flow.dst;\n", "    }\n", "    __u32 *decap_dst_flags = bpf_map_lookup_elem (&decap_dst, &dst_addr);\n", "    if (decap_dst_flags) {\n", "        *pass = false;\n", "        __u32 stats_key = MAX_VIPS + REMOTE_ENCAP_CNTRS;\n", "        data_stats = bpf_map_lookup_elem (& stats, & stats_key);\n", "        if (!data_stats) {\n", "            return XDP_DROP;\n", "        }\n", "        data_stats->v1 += 1;\n", "    }\n", "    return FURTHER_PROCESSING;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{"description": " Given input \"pckt\", check if its flow's dst is legal. if it does, increase the coresponding stats's amount ", "author": "Nengneng Yu", "authorEmail": "ynn1999@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "reals_have_same_addr": [{"capabilities": [], "helperCallParams": {}, "startLine": 261, "endLine": 277, "File": "/home/sayandes/opened_extraction/examples/katran/balancer_kern.c", "funcName": "reals_have_same_addr", "developer_inline_comments": [{"start_line": 1, "end_line": 1, "text": "// of INLINE_DECAP_GENERIC"}], "updateMaps": [], "readMaps": [], "input": ["struct real_definition *a", " struct real_definition *b"], "output": "staticinlinebool", "helper": [], "compatibleHookpoints": ["kprobe", "cgroup_skb", "sk_skb", "cgroup_device", "tracepoint", "socket_filter", "xdp", "raw_tracepoint_writable", "flow_dissector", "lwt_seg6local", "sched_cls", "lwt_out", "sched_act", "cgroup_sysctl", "cgroup_sock_addr", "sk_reuseport", "lwt_xmit", "sock_ops", "perf_event", "raw_tracepoint", "sk_msg", "lwt_in", "cgroup_sock"], "source": ["static inline bool reals_have_same_addr (struct real_definition *a, struct real_definition *b)\n", "{\n", "    if (a->flags != b->flags) {\n", "        return false;\n", "    }\n", "    if (a->flags & F_IPV6) {\n", "        for (int i = 0; i < 4; i++) {\n", "            if (a->dstv6[i] != b->dstv6[i]) {\n", "                return false;\n", "            }\n", "            return true;\n", "        }\n", "    }\n", "    else {\n", "        return a->dst == b->dst;\n", "    }\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{"description": " Function checks the input 2 backend servers have the same dst addresses ", "author": "Nengneng Yu", "authorEmail": "ynn1999@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "perform_global_lru_lookup": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "libbpf", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}, {"capability": "pkt_stop_processing_drop_packet", "pkt_stop_processing_drop_packet": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_DROP", "Return": 1, "Description": "will drop the packet right at the driver level without wasting any further resources. This is in particular useful for BPF programs implementing DDoS mitigation mechanisms or firewalling in general.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_stop_processing_drop_packet"]}]}], "helperCallParams": {}, "startLine": 279, "endLine": 335, "File": "/home/sayandes/opened_extraction/examples/katran/balancer_kern.c", "funcName": "perform_global_lru_lookup", "developer_inline_comments": [{"start_line": 7, "end_line": 7, "text": "// lookup in the global cache"}, {"start_line": 18, "end_line": 18, "text": "// We were not able to retrieve the global lru for this cpu."}, {"start_line": 19, "end_line": 19, "text": "// This counter should never be anything except 0 in prod."}, {"start_line": 20, "end_line": 20, "text": "// We are going to use it for monitoring."}, {"start_line": 21, "end_line": 21, "text": "// global lru map doesn't exist for this cpu"}, {"start_line": 25, "end_line": 25, "text": "/*isGlobalLru=*/"}, {"start_line": 27, "end_line": 27, "text": "// we routed a flow using global lru"}, {"start_line": 29, "end_line": 29, "text": "// Find the real that we route the packet to if we use consistent hashing"}, {"start_line": 36, "end_line": 36, "text": "/*lru_map=*/"}, {"start_line": 44, "end_line": 44, "text": "// We route to the same real as that indicated by the consistent"}, {"start_line": 45, "end_line": 45, "text": "// hash"}, {"start_line": 48, "end_line": 48, "text": "// We route to a real different from that indicated by the"}, {"start_line": 49, "end_line": 49, "text": "// consistent hash"}], "updateMaps": [], "readMaps": [" global_lru_maps", " stats"], "input": ["struct real_definition **dst", " struct packet_description *pckt", " __u32 cpu_num", " struct vip_meta *vip_info", " bool is_ipv6"], "output": "staticinlineint", "helper": ["bpf_map_lookup_elem", "XDP_DROP"], "compatibleHookpoints": ["xdp"], "source": ["static inline int perform_global_lru_lookup (struct real_definition **dst, struct packet_description *pckt, __u32 cpu_num, struct vip_meta *vip_info, bool is_ipv6)\n", "{\n", "    void *g_lru_map = bpf_map_lookup_elem (&global_lru_maps, &cpu_num);\n", "    __u32 global_lru_stats_key = MAX_VIPS + GLOBAL_LRU_CNTR;\n", "    struct lb_stats *global_lru_stats = bpf_map_lookup_elem (&stats, &global_lru_stats_key);\n", "    if (!global_lru_stats) {\n", "        return XDP_DROP;\n", "    }\n", "    if (!g_lru_map) {\n", "        global_lru_stats->v1 += 1;\n", "        g_lru_map = &fallback_glru;\n", "    }\n", "    connection_table_lookup (dst, pckt, g_lru_map, true);\n", "    if (*dst) {\n", "        global_lru_stats->v2 += 1;\n", "        struct real_definition *dst_consistent_hash = NULL;\n", "        if (get_packet_dst (&dst_consistent_hash, pckt, vip_info, is_ipv6, NULL)) {\n", "            __u32 global_lru_mismatch_stats_key = MAX_VIPS + GLOBAL_LRU_MISMATCH_CNTR;\n", "            struct lb_stats *global_lru_mismatch_stats = bpf_map_lookup_elem (&stats, &global_lru_mismatch_stats_key);\n", "            if (dst_consistent_hash && global_lru_mismatch_stats) {\n", "                if (reals_have_same_addr (dst_consistent_hash, *dst)) {\n", "                    global_lru_mismatch_stats->v1++;\n", "                }\n", "                else {\n", "                    global_lru_mismatch_stats->v2++;\n", "                }\n", "            }\n", "        }\n", "    }\n", "    return FURTHER_PROCESSING;\n", "}\n"], "called_function_list": ["reals_have_same_addr", "get_packet_dst", "connection_table_lookup"], "call_depth": 4, "humanFuncDescription": [{"description": " (can't understand) find the lru_map from global cache based on gicen cpu_num, ", "author": "Nengneng Yu", "authorEmail": "ynn1999@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "process_encaped_ipip_pckt": [{"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_PASS", "Return": 2, "Description": "The XDP_PASS return code means that the packet is allowed to be passed up to the kernel\u2019s networking stack. Meaning, the current CPU that was processing this packet now allocates a skb, populates it, and passes it onwards into the GRO engine. This would be equivalent to the default packet handling behavior without XDP.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_go_to_next_module"]}]}, {"capability": "pkt_stop_processing_drop_packet", "pkt_stop_processing_drop_packet": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_DROP", "Return": 1, "Description": "will drop the packet right at the driver level without wasting any further resources. This is in particular useful for BPF programs implementing DDoS mitigation mechanisms or firewalling in general.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_stop_processing_drop_packet"]}]}], "helperCallParams": {}, "startLine": 340, "endLine": 387, "File": "/home/sayandes/opened_extraction/examples/katran/balancer_kern.c", "funcName": "process_encaped_ipip_pckt", "developer_inline_comments": [{"start_line": 1, "end_line": 1, "text": "// GLOBAL_LRU_LOOKUP"}, {"start_line": 47, "end_line": 47, "text": "// pass packet to kernel after decapsulation"}], "updateMaps": [], "readMaps": [], "input": ["void **data", " void **data_end", " struct xdp_md *xdp", " bool *is_ipv6", " __u8 *protocol", " bool pass"], "output": "staticinlineint", "helper": ["XDP_PASS", "XDP_DROP"], "compatibleHookpoints": ["xdp"], "source": ["static inline int process_encaped_ipip_pckt (void **data, void **data_end, struct xdp_md *xdp, bool *is_ipv6, __u8 *protocol, bool pass)\n", "{\n", "    int action;\n", "    if (*protocol == IPPROTO_IPIP) {\n", "        if (*is_ipv6) {\n", "            int offset = sizeof (struct ipv6hdr) + sizeof (struct ethhdr);\n", "            if ((*data + offset) > *data_end) {\n", "                return XDP_DROP;\n", "            }\n", "            action = decrement_ttl (* data, * data_end, offset, false);\n", "            if (!decap_v6 (xdp, data, data_end, true)) {\n", "                return XDP_DROP;\n", "            }\n", "            *is_ipv6 = false;\n", "        }\n", "        else {\n", "            int offset = sizeof (struct iphdr) + sizeof (struct ethhdr);\n", "            if ((*data + offset) > *data_end) {\n", "                return XDP_DROP;\n", "            }\n", "            action = decrement_ttl (* data, * data_end, offset, false);\n", "            if (!decap_v4 (xdp, data, data_end)) {\n", "                return XDP_DROP;\n", "            }\n", "        }\n", "    }\n", "    else if (*protocol == IPPROTO_IPV6) {\n", "        int offset = sizeof (struct ipv6hdr) + sizeof (struct ethhdr);\n", "        if ((*data + offset) > *data_end) {\n", "            return XDP_DROP;\n", "        }\n", "        action = decrement_ttl (* data, * data_end, offset, true);\n", "        if (!decap_v6 (xdp, data, data_end, false)) {\n", "            return XDP_DROP;\n", "        }\n", "    }\n", "    if (action >= 0) {\n", "        return action;\n", "    }\n", "    if (pass) {\n", "        return XDP_PASS;\n", "    }\n", "    return recirculate (xdp);\n", "}\n"], "called_function_list": ["decap_v6", "recirculate", "decap_v4", "decrement_ttl"], "call_depth": 1, "humanFuncDescription": [{"description": " Used for IPIP packets, Based on the encapsulate packet protocol type,  call the appropriate decapsulation function and decrement ttl ", "author": "Nengneng Yu", "authorEmail": "ynn1999@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [{"capability": "pkt_stop_processing_drop_packet", "pkt_stop_processing_drop_packet": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_DROP", "Return": 1, "Description": "will drop the packet right at the driver level without wasting any further resources. This is in particular useful for BPF programs implementing DDoS mitigation mechanisms or firewalling in general.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_stop_processing_drop_packet"]}]}], "helperCallParams": {}, "startLine": 85, "endLine": 120, "File": "/home/sayandes/opened_extraction/examples/katran/decap_kern.c", "funcName": "process_encaped_ipip_pckt", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["void **data", " void **data_end", " struct xdp_md *xdp", " bool *is_ipv6", " struct packet_description *pckt", " __u8 *protocol", " __u64 off", " __u16 *pkt_bytes"], "output": "staticinlineint", "helper": ["XDP_DROP"], "compatibleHookpoints": ["xdp"], "source": ["static inline int process_encaped_ipip_pckt (void **data, void **data_end, struct xdp_md *xdp, bool *is_ipv6, struct packet_description *pckt, __u8 *protocol, __u64 off, __u16 *pkt_bytes)\n", "{\n", "    if (*protocol == IPPROTO_IPIP) {\n", "        if (*is_ipv6) {\n", "            if ((*data + sizeof (struct ipv6hdr) + sizeof (struct ethhdr)) > *data_end) {\n", "                return XDP_DROP;\n", "            }\n", "            if (!decap_v6 (xdp, data, data_end, true)) {\n", "                return XDP_DROP;\n", "            }\n", "        }\n", "        else {\n", "            if ((*data + sizeof (struct iphdr) + sizeof (struct ethhdr)) > *data_end) {\n", "                return XDP_DROP;\n", "            }\n", "            if (!decap_v4 (xdp, data, data_end)) {\n", "                return XDP_DROP;\n", "            }\n", "        }\n", "    }\n", "    else if (*protocol == IPPROTO_IPV6) {\n", "        if ((*data + sizeof (struct ipv6hdr) + sizeof (struct ethhdr)) > *data_end) {\n", "            return XDP_DROP;\n", "        }\n", "        if (!decap_v6 (xdp, data, data_end, false)) {\n", "            return XDP_DROP;\n", "        }\n", "    }\n", "    return FURTHER_PROCESSING;\n", "}\n"], "called_function_list": ["decap_v6", "recirculate", "decap_v4", "decrement_ttl"], "call_depth": 1, "humanFuncDescription": [{"description": " Process ip-in-ip encaped packet, drop the packet if 1) bogus packet, len less than minimum ethernet frame size, 2) not decaped successfully.                   Otherwise, perform decapsulation of the outer packet header. ", "author": "Qintian Huang", "authorEmail": "qthuang@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "process_encaped_gue_pckt": [{"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_PASS", "Return": 2, "Description": "The XDP_PASS return code means that the packet is allowed to be passed up to the kernel\u2019s networking stack. Meaning, the current CPU that was processing this packet now allocates a skb, populates it, and passes it onwards into the GRO engine. This would be equivalent to the default packet handling behavior without XDP.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_go_to_next_module"]}]}, {"capability": "pkt_stop_processing_drop_packet", "pkt_stop_processing_drop_packet": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_DROP", "Return": 1, "Description": "will drop the packet right at the driver level without wasting any further resources. This is in particular useful for BPF programs implementing DDoS mitigation mechanisms or firewalling in general.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_stop_processing_drop_packet"]}]}], "helperCallParams": {}, "startLine": 391, "endLine": 441, "File": "/home/sayandes/opened_extraction/examples/katran/balancer_kern.c", "funcName": "process_encaped_gue_pckt", "developer_inline_comments": [{"start_line": 16, "end_line": 16, "text": "// 1 byte for gue v1 marker to figure out what is internal protocol"}, {"start_line": 23, "end_line": 23, "text": "// inner packet is ipv6 as well"}, {"start_line": 29, "end_line": 29, "text": "// inner packet is ipv4"}], "updateMaps": [], "readMaps": [], "input": ["void **data", " void **data_end", " struct xdp_md *xdp", " bool is_ipv6", " bool pass"], "output": "staticinlineint", "helper": ["XDP_PASS", "XDP_DROP"], "compatibleHookpoints": ["xdp"], "source": ["static inline int process_encaped_gue_pckt (void **data, void **data_end, struct xdp_md *xdp, bool is_ipv6, bool pass)\n", "{\n", "    int offset = 0;\n", "    int action;\n", "    if (is_ipv6) {\n", "        __u8 v6 = 0;\n", "        offset = sizeof (struct ipv6hdr) + sizeof (struct ethhdr) + sizeof (struct udphdr);\n", "        if ((*data + offset + 1) > *data_end) {\n", "            return XDP_DROP;\n", "        }\n", "        v6 = ((__u8 *) (*data))[offset];\n", "        v6 &= GUEV1_IPV6MASK;\n", "        if (v6) {\n", "            action = decrement_ttl (* data, * data_end, offset, true);\n", "            if (!gue_decap_v6 (xdp, data, data_end, false)) {\n", "                return XDP_DROP;\n", "            }\n", "        }\n", "        else {\n", "            action = decrement_ttl (* data, * data_end, offset, false);\n", "            if (!gue_decap_v6 (xdp, data, data_end, true)) {\n", "                return XDP_DROP;\n", "            }\n", "        }\n", "    }\n", "    else {\n", "        offset = sizeof (struct iphdr) + sizeof (struct ethhdr) + sizeof (struct udphdr);\n", "        if ((*data + offset) > *data_end) {\n", "            return XDP_DROP;\n", "        }\n", "        action = decrement_ttl (* data, * data_end, offset, false);\n", "        if (!gue_decap_v4 (xdp, data, data_end)) {\n", "            return XDP_DROP;\n", "        }\n", "    }\n", "    if (action >= 0) {\n", "        return action;\n", "    }\n", "    if (pass) {\n", "        return XDP_PASS;\n", "    }\n", "    return recirculate (xdp);\n", "}\n"], "called_function_list": ["gue_decap_v6", "recirculate", "gue_decap_v4", "decrement_ttl"], "call_depth": 1, "humanFuncDescription": [{"description": " Used for GUE packets,Based on the encapsulate packet protocol type,  call the appropriate decapsulation function and decrement ttl ", "author": "Nengneng Yu", "authorEmail": "ynn1999@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [{"capability": "pkt_stop_processing_drop_packet", "pkt_stop_processing_drop_packet": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_DROP", "Return": 1, "Description": "will drop the packet right at the driver level without wasting any further resources. This is in particular useful for BPF programs implementing DDoS mitigation mechanisms or firewalling in general.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_stop_processing_drop_packet"]}]}], "helperCallParams": {}, "startLine": 123, "endLine": 161, "File": "/home/sayandes/opened_extraction/examples/katran/decap_kern.c", "funcName": "process_encaped_gue_pckt", "developer_inline_comments": [{"start_line": 12, "end_line": 12, "text": "// 1 byte for gue v1 marker to figure out what is internal protocol"}, {"start_line": 19, "end_line": 19, "text": "// inner packet is ipv6 as well"}, {"start_line": 24, "end_line": 24, "text": "// inner packet is ipv4"}], "updateMaps": [], "readMaps": [], "input": ["void **data", " void **data_end", " struct xdp_md *xdp", " bool is_ipv6"], "output": "staticinlineint", "helper": ["XDP_DROP"], "compatibleHookpoints": ["xdp"], "source": ["static inline int process_encaped_gue_pckt (void **data, void **data_end, struct xdp_md *xdp, bool is_ipv6)\n", "{\n", "    int offset = 0;\n", "    if (is_ipv6) {\n", "        __u8 v6 = 0;\n", "        offset = sizeof (struct ipv6hdr) + sizeof (struct ethhdr) + sizeof (struct udphdr);\n", "        if ((*data + offset + 1) > *data_end) {\n", "            return XDP_DROP;\n", "        }\n", "        v6 = ((__u8 *) (*data))[offset];\n", "        v6 &= GUEV1_IPV6MASK;\n", "        if (v6) {\n", "            if (!gue_decap_v6 (xdp, data, data_end, false)) {\n", "                return XDP_DROP;\n", "            }\n", "        }\n", "        else {\n", "            if (!gue_decap_v6 (xdp, data, data_end, true)) {\n", "                return XDP_DROP;\n", "            }\n", "        }\n", "    }\n", "    else {\n", "        offset = sizeof (struct iphdr) + sizeof (struct ethhdr) + sizeof (struct udphdr);\n", "        if ((*data + offset) > *data_end) {\n", "            return XDP_DROP;\n", "        }\n", "        if (!gue_decap_v4 (xdp, data, data_end)) {\n", "            return XDP_DROP;\n", "        }\n", "    }\n", "    return FURTHER_PROCESSING;\n", "}\n"], "called_function_list": ["gue_decap_v6", "recirculate", "gue_decap_v4", "decrement_ttl"], "call_depth": 1, "humanFuncDescription": [{"description": " Decapsulate the outer header of the packet based on whether the inner-outer combo is ipv6 or ipv4.                   Drop the packet if: 1) bogus packet, len less than minimum ethernet frame size, 2) not decaped succesfully.                   When ipv6, check the situation that the inner packet is ipv6 and ipv4                   When ipv4, check the situation that the inner packet is ipv4 ", "author": "Qintian Huang", "authorEmail": "qthuang@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "increment_quic_cid_version_stats": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "libbpf", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 444, "endLine": 457, "File": "/home/sayandes/opened_extraction/examples/katran/balancer_kern.c", "funcName": "increment_quic_cid_version_stats", "developer_inline_comments": [], "updateMaps": [], "readMaps": [" stats"], "input": ["int host_id"], "output": "staticinlinevoid", "helper": ["bpf_map_lookup_elem"], "compatibleHookpoints": ["kprobe", "cgroup_skb", "sk_skb", "cgroup_device", "tracepoint", "socket_filter", "xdp", "raw_tracepoint_writable", "flow_dissector", "lwt_seg6local", "sched_cls", "lwt_out", "sched_act", "cgroup_sysctl", "cgroup_sock_addr", "sk_reuseport", "lwt_xmit", "sock_ops", "perf_event", "raw_tracepoint", "sk_msg", "lwt_in", "cgroup_sock"], "source": ["static inline void increment_quic_cid_version_stats (int host_id)\n", "{\n", "    __u32 quic_version_stats_key = MAX_VIPS + QUIC_CID_VERSION_STATS;\n", "    struct lb_stats *quic_version = bpf_map_lookup_elem (&stats, &quic_version_stats_key);\n", "    if (!quic_version) {\n", "        return;\n", "    }\n", "    if (host_id > QUIC_CONNID_VERSION_V1_MAX_VAL) {\n", "        quic_version->v2 += 1;\n", "    }\n", "    else {\n", "        quic_version->v1 += 1;\n", "    }\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{"description": " Function updates quic protocol stats ", "author": "Nengneng Yu", "authorEmail": "ynn1999@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "increment_quic_cid_drop_no_real": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "libbpf", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 459, "endLine": 468, "File": "/home/sayandes/opened_extraction/examples/katran/balancer_kern.c", "funcName": "increment_quic_cid_drop_no_real", "developer_inline_comments": [], "updateMaps": [], "readMaps": [" stats"], "input": ["NA"], "output": "staticinlinevoid", "helper": ["bpf_map_lookup_elem"], "compatibleHookpoints": ["kprobe", "cgroup_skb", "sk_skb", "cgroup_device", "tracepoint", "socket_filter", "xdp", "raw_tracepoint_writable", "flow_dissector", "lwt_seg6local", "sched_cls", "lwt_out", "sched_act", "cgroup_sysctl", "cgroup_sock_addr", "sk_reuseport", "lwt_xmit", "sock_ops", "perf_event", "raw_tracepoint", "sk_msg", "lwt_in", "cgroup_sock"], "source": ["static inline void increment_quic_cid_drop_no_real ()\n", "{\n", "    __u32 quic_drop_stats_key = MAX_VIPS + QUIC_CID_DROP_STATS;\n", "    struct lb_stats *quic_drop = bpf_map_lookup_elem (&stats, &quic_drop_stats_key);\n", "    if (!quic_drop) {\n", "        return;\n", "    }\n", "    quic_drop->v1 += 1;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{"description": " lookup stats by QUIC_CID_DROP_STATS, increment stats v1 by 1 ", "author": "Nengneng Yu", "authorEmail": "ynn1999@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "increment_quic_cid_drop_real_0": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "libbpf", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 470, "endLine": 478, "File": "/home/sayandes/opened_extraction/examples/katran/balancer_kern.c", "funcName": "increment_quic_cid_drop_real_0", "developer_inline_comments": [], "updateMaps": [], "readMaps": [" stats"], "input": ["NA"], "output": "staticinlinevoid", "helper": ["bpf_map_lookup_elem"], "compatibleHookpoints": ["kprobe", "cgroup_skb", "sk_skb", "cgroup_device", "tracepoint", "socket_filter", "xdp", "raw_tracepoint_writable", "flow_dissector", "lwt_seg6local", "sched_cls", "lwt_out", "sched_act", "cgroup_sysctl", "cgroup_sock_addr", "sk_reuseport", "lwt_xmit", "sock_ops", "perf_event", "raw_tracepoint", "sk_msg", "lwt_in", "cgroup_sock"], "source": ["static inline void increment_quic_cid_drop_real_0 ()\n", "{\n", "    __u32 quic_drop_stats_key = MAX_VIPS + QUIC_CID_DROP_STATS;\n", "    struct lb_stats *quic_drop = bpf_map_lookup_elem (&stats, &quic_drop_stats_key);\n", "    if (!quic_drop) {\n", "        return;\n", "    }\n", "    quic_drop->v2 += 1;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{"description": " lookup stats by QUIC_CID_DROP_STATS, update Corresponding stats's v2 ", "author": "Nengneng Yu", "authorEmail": "ynn1999@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "process_packet": [{"capabilities": [{"capability": "pkt_stop_processing_drop_packet", "pkt_stop_processing_drop_packet": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_DROP", "Return": 1, "Description": "will drop the packet right at the driver level without wasting any further resources. This is in particular useful for BPF programs implementing DDoS mitigation mechanisms or firewalling in general.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_stop_processing_drop_packet"]}]}, {"capability": "map_read", "map_read": [{"Project": "libbpf", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}, {"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_PASS", "Return": 2, "Description": "The XDP_PASS return code means that the packet is allowed to be passed up to the kernel\u2019s networking stack. Meaning, the current CPU that was processing this packet now allocates a skb, populates it, and passes it onwards into the GRO engine. This would be equivalent to the default packet handling behavior without XDP.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_go_to_next_module"]}]}, {"capability": "read_sys_info", "read_sys_info": [{"Project": "libbpf", "Return Type": "u32", "Description": "Get the SMP (symmetric multiprocessing) processor id. Note that all programs run with preemption disabled , which means that the SMP processor id is stable during all the execution of the program. ", "Return": " The SMP id of the processor running the program.", "Function Name": "bpf_get_smp_processor_id", "Input Params": ["{Type: voi ,Var: void}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "raw_tracepoint_writable"], "capabilities": ["read_sys_info"]}]}, {"capability": "pkt_alter_or_redo_processing_or_interface", "pkt_alter_or_redo_processing_or_interface": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_TX", "Return": 3, "Description": "an efficient option to transmit the network packet out of the same NIC it just arrived on again. This is typically useful when few nodes are implementing, for example, firewalling with subsequent load balancing in a cluster and thus act as a hairpinned load balancer pushing the incoming packets back into the switch after rewriting them in XDP BPF.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_alter_or_redo_processing_or_interface"]}]}], "helperCallParams": {}, "startLine": 480, "endLine": 791, "File": "/home/sayandes/opened_extraction/examples/katran/balancer_kern.c", "funcName": "process_packet", "developer_inline_comments": [{"start_line": 26, "end_line": 50, "text": "/* This is to workaround a verifier issue for 5.2.\n   * The reason is that 5.2 verifier does not handle register\n   * copy states properly while 5.6 handles properly.\n   *\n   * For the following source code:\n   *   if (protocol == IPPROTO_IPIP || protocol == IPPROTO_IPV6) {\n   *     ...\n   *   }\n   * llvm12 may generate the following simplified code sequence\n   *   100  r5 = *(u8 *)(r9 +51)  // r5 is the protocol\n   *   120  r4 = r5\n   *   121  if r4 s> 0x10 goto target1\n   *   122  *(u64 *)(r10 -184) = r5\n   *   123  if r4 == 0x4 goto target2\n   *   ...\n   *   target2:\n   *   150  r1 = *(u64 *)(r10 -184)\n   *   151  if (r1 != 4) { __unreachable__}\n   *\n   * For the path 123->150->151, 5.6 correctly noticed\n   * at insn 150: r4, r5, *(u64 *)(r10 -184) all have value 4.\n   * while 5.2 has *(u64 *)(r10 -184) holding \"r5\" which could be\n   * any value 0-255. In 5.2, \"__unreachable\" code is verified\n   * and it caused verifier failure.\n   */"}, {"start_line": 68, "end_line": 68, "text": "// INLINE_DECAP_IPIP"}, {"start_line": 87, "end_line": 87, "text": "// of INLINE_DECAP_GUE"}, {"start_line": 89, "end_line": 89, "text": "// send to tcp/ip stack"}, {"start_line": 110, "end_line": 110, "text": "// VIP, which doesnt care about dst port (all packets to this VIP w/ diff"}, {"start_line": 111, "end_line": 111, "text": "// dst port but from the same src port/ip must go to the same real"}, {"start_line": 141, "end_line": 141, "text": "// total packets"}, {"start_line": 144, "end_line": 144, "text": "// Lookup dst based on id in packet"}, {"start_line": 161, "end_line": 161, "text": "// increment counter for the CH based routing"}, {"start_line": 174, "end_line": 174, "text": "// increment counter for the CH based routing"}, {"start_line": 182, "end_line": 182, "text": "// save the original sport before making real selection, possibly changing its"}, {"start_line": 183, "end_line": 183, "text": "// value."}, {"start_line": 188, "end_line": 188, "text": "// service, where diff src port, but same ip must go to the same real,"}, {"start_line": 189, "end_line": 189, "text": "// e.g. gfs"}, {"start_line": 201, "end_line": 201, "text": "// We were not able to retrieve per cpu/core lru and falling back to"}, {"start_line": 202, "end_line": 202, "text": "// default one. This counter should never be anything except 0 in prod."}, {"start_line": 203, "end_line": 203, "text": "// We are going to use it for monitoring."}, {"start_line": 207, "end_line": 207, "text": "// First try to lookup dst in the tcp_hdr_opt (if enabled)"}, {"start_line": 227, "end_line": 227, "text": "// TCP_SERVER_ID_ROUTING"}, {"start_line": 229, "end_line": 229, "text": "// Next, try to lookup dst in the lru_cache"}, {"start_line": 232, "end_line": 232, "text": "/*isGlobalLru=*/"}, {"start_line": 243, "end_line": 243, "text": "// GLOBAL_LRU_LOOKUP"}, {"start_line": 245, "end_line": 245, "text": "// if dst is not found, route via consistent-hashing of the flow."}, {"start_line": 255, "end_line": 255, "text": "// miss because of new tcp session"}, {"start_line": 258, "end_line": 258, "text": "// miss of non-syn tcp packet. could be either because of LRU trashing"}, {"start_line": 259, "end_line": 259, "text": "// or because another katran is restarting and all the sessions"}, {"start_line": 260, "end_line": 260, "text": "// have been reshuffled"}, {"start_line": 268, "end_line": 268, "text": "// lru misses (either new connection or lru is full and starts to trash)"}, {"start_line": 287, "end_line": 287, "text": "// per real statistics"}, {"start_line": 299, "end_line": 299, "text": "// restore the original sport value to use it as a seed for the GUE sport"}], "updateMaps": [], "readMaps": ["  reals", "  ctl_array", "  reals_stats", "  stats", " lru_mapping", " stats", " server_id_map", "  vip_map"], "input": ["struct xdp_md *xdp", " __u64 off", " bool is_ipv6"], "output": "staticinlineint", "helper": ["XDP_DROP", "bpf_map_lookup_elem", "XDP_PASS", "bpf_get_smp_processor_id", "XDP_TX"], "compatibleHookpoints": ["xdp"], "source": ["static inline int process_packet (struct xdp_md *xdp, __u64 off, bool is_ipv6)\n", "{\n", "    void *data = (void *) (long) xdp->data;\n", "    void *data_end = (void *) (long) xdp->data_end;\n", "    struct ctl_value *cval;\n", "    struct real_definition *dst = NULL;\n", "    struct packet_description pckt = {}\n", "    ;\n", "    struct vip_definition vip = {}\n", "    ;\n", "    struct vip_meta *vip_info;\n", "    struct lb_stats *data_stats;\n", "    __u64 iph_len;\n", "    __u8 protocol;\n", "    __u16 original_sport;\n", "    int action;\n", "    __u32 vip_num;\n", "    __u32 mac_addr_pos = 0;\n", "    __u16 pkt_bytes;\n", "    action = process_l3_headers (& pckt, & protocol, off, & pkt_bytes, data, data_end, is_ipv6);\n", "    if (action >= 0) {\n", "        return action;\n", "    }\n", "    protocol = pckt.flow.proto;\n", "\n", "#ifdef INLINE_DECAP_IPIP\n", "    if (protocol == IPPROTO_IPIP) {\n", "        bool pass = true;\n", "        action = check_decap_dst (& pckt, is_ipv6, & pass);\n", "        if (action >= 0) {\n", "            return action;\n", "        }\n", "        return process_encaped_ipip_pckt (&data, &data_end, xdp, &is_ipv6, &protocol, pass);\n", "    }\n", "    else if (protocol == IPPROTO_IPV6) {\n", "        bool pass = true;\n", "        action = check_decap_dst (& pckt, is_ipv6, & pass);\n", "        if (action >= 0) {\n", "            return action;\n", "        }\n", "        return process_encaped_ipip_pckt (&data, &data_end, xdp, &is_ipv6, &protocol, pass);\n", "    }\n", "\n", "#endif // INLINE_DECAP_IPIP\n", "    if (protocol == IPPROTO_TCP) {\n", "        if (!parse_tcp (data, data_end, is_ipv6, &pckt)) {\n", "            return XDP_DROP;\n", "        }\n", "    }\n", "    else if (protocol == IPPROTO_UDP) {\n", "        if (!parse_udp (data, data_end, is_ipv6, &pckt)) {\n", "            return XDP_DROP;\n", "        }\n", "\n", "#ifdef INLINE_DECAP_GUE\n", "        if (pckt.flow.port16[1] == bpf_htons (GUE_DPORT)) {\n", "            bool pass = true;\n", "            action = check_decap_dst (& pckt, is_ipv6, & pass);\n", "            if (action >= 0) {\n", "                return action;\n", "            }\n", "            return process_encaped_gue_pckt (&data, &data_end, xdp, is_ipv6, pass);\n", "        }\n", "\n", "#endif // of INLINE_DECAP_GUE\n", "    }\n", "    else {\n", "        return XDP_PASS;\n", "    }\n", "    if (is_ipv6) {\n", "        memcpy (vip.vipv6, pckt.flow.dstv6, 16);\n", "    }\n", "    else {\n", "        vip.vip = pckt.flow.dst;\n", "    }\n", "    vip.port = pckt.flow.port16[1];\n", "    vip.proto = pckt.flow.proto;\n", "    vip_info = bpf_map_lookup_elem (& vip_map, & vip);\n", "    if (!vip_info) {\n", "        vip.port = 0;\n", "        vip_info = bpf_map_lookup_elem (& vip_map, & vip);\n", "        if (!vip_info) {\n", "            return XDP_PASS;\n", "        }\n", "        if (!(vip_info->flags & F_HASH_DPORT_ONLY)) {\n", "            pckt.flow.port16[1] = 0;\n", "        }\n", "    }\n", "    if (data_end - data > MAX_PCKT_SIZE) {\n", "        REPORT_PACKET_TOOBIG (xdp, data, data_end - data, false);\n", "\n", "#ifdef ICMP_TOOBIG_GENERATION\n", "        __u32 stats_key = MAX_VIPS + ICMP_TOOBIG_CNTRS;\n", "        data_stats = bpf_map_lookup_elem (& stats, & stats_key);\n", "        if (!data_stats) {\n", "            return XDP_DROP;\n", "        }\n", "        if (is_ipv6) {\n", "            data_stats->v2 += 1;\n", "        }\n", "        else {\n", "            data_stats->v1 += 1;\n", "        }\n", "        return send_icmp_too_big (xdp, is_ipv6, data_end - data);\n", "\n", "#else\n", "        return XDP_DROP;\n", "\n", "#endif\n", "    }\n", "    __u32 stats_key = MAX_VIPS + LRU_CNTRS;\n", "    data_stats = bpf_map_lookup_elem (& stats, & stats_key);\n", "    if (!data_stats) {\n", "        return XDP_DROP;\n", "    }\n", "    data_stats->v1 += 1;\n", "    if ((vip_info->flags & F_QUIC_VIP)) {\n", "        __u32 quic_stats_key = MAX_VIPS + QUIC_ROUTE_STATS;\n", "        struct lb_stats *quic_stats = bpf_map_lookup_elem (&stats, &quic_stats_key);\n", "        if (!quic_stats) {\n", "            return XDP_DROP;\n", "        }\n", "        int real_index;\n", "        real_index = parse_quic (data, data_end, is_ipv6, & pckt);\n", "        if (real_index > 0) {\n", "            increment_quic_cid_version_stats (real_index);\n", "            __u32 key = real_index;\n", "            __u32 *real_pos = bpf_map_lookup_elem (&server_id_map, &key);\n", "            if (real_pos) {\n", "                key = *real_pos;\n", "                if (key == 0) {\n", "                    increment_quic_cid_drop_real_0 ();\n", "                    quic_stats->v1 += 1;\n", "                }\n", "                else {\n", "                    pckt.real_index = key;\n", "                    dst = bpf_map_lookup_elem (& reals, & key);\n", "                    if (!dst) {\n", "                        increment_quic_cid_drop_no_real ();\n", "                        REPORT_QUIC_PACKET_DROP_NO_REAL (xdp, data, data_end - data, false);\n", "                        return XDP_DROP;\n", "                    }\n", "                    quic_stats->v2 += 1;\n", "                }\n", "            }\n", "            else {\n", "                quic_stats->v1 += 1;\n", "            }\n", "        }\n", "        else {\n", "            quic_stats->v1 += 1;\n", "        }\n", "    }\n", "    original_sport = pckt.flow.port16[0];\n", "    if (!dst) {\n", "        if ((vip_info->flags & F_HASH_NO_SRC_PORT)) {\n", "            pckt.flow.port16[0] = 0;\n", "        }\n", "        __u32 cpu_num = bpf_get_smp_processor_id ();\n", "        void *lru_map = bpf_map_lookup_elem (&lru_mapping, &cpu_num);\n", "        if (!lru_map) {\n", "            lru_map = &fallback_cache;\n", "            __u32 lru_stats_key = MAX_VIPS + FALLBACK_LRU_CNTR;\n", "            struct lb_stats *lru_stats = bpf_map_lookup_elem (&stats, &lru_stats_key);\n", "            if (!lru_stats) {\n", "                return XDP_DROP;\n", "            }\n", "            lru_stats->v1 += 1;\n", "        }\n", "\n", "#ifdef TCP_SERVER_ID_ROUTING\n", "        if (pckt.flow.proto == IPPROTO_TCP && !(pckt.flags & F_SYN_SET)) {\n", "            __u32 routing_stats_key = MAX_VIPS + TCP_SERVER_ID_ROUTE_STATS;\n", "            struct lb_stats *routing_stats = bpf_map_lookup_elem (&stats, &routing_stats_key);\n", "            if (!routing_stats) {\n", "                return XDP_DROP;\n", "            }\n", "            if (tcp_hdr_opt_lookup (xdp, is_ipv6, &dst, &pckt, vip_info->flags & F_LRU_BYPASS, lru_map) == FURTHER_PROCESSING) {\n", "                routing_stats->v1 += 1;\n", "            }\n", "            else {\n", "                routing_stats->v2 += 1;\n", "            }\n", "        }\n", "\n", "#endif // TCP_SERVER_ID_ROUTING\n", "        if (!dst && !(pckt.flags & F_SYN_SET) && !(vip_info->flags & F_LRU_BYPASS)) {\n", "            connection_table_lookup (&dst, &pckt, lru_map, false);\n", "        }\n", "\n", "#ifdef GLOBAL_LRU_LOOKUP\n", "        if (!dst && !(pckt.flags & F_SYN_SET) && vip_info->flags & F_GLOBAL_LRU) {\n", "            int global_lru_lookup_result = perform_global_lru_lookup (& dst, & pckt, cpu_num, vip_info, is_ipv6);\n", "            if (global_lru_lookup_result >= 0) {\n", "                return global_lru_lookup_result;\n", "            }\n", "        }\n", "\n", "#endif // GLOBAL_LRU_LOOKUP\n", "        if (!dst) {\n", "            if (pckt.flow.proto == IPPROTO_TCP) {\n", "                __u32 lru_stats_key = MAX_VIPS + LRU_MISS_CNTR;\n", "                struct lb_stats *lru_stats = bpf_map_lookup_elem (&stats, &lru_stats_key);\n", "                if (!lru_stats) {\n", "                    return XDP_DROP;\n", "                }\n", "                if (pckt.flags & F_SYN_SET) {\n", "                    lru_stats->v1 += 1;\n", "                }\n", "                else {\n", "                    REPORT_TCP_NONSYN_LRUMISS (xdp, data, data_end - data, false);\n", "                    lru_stats->v2 += 1;\n", "                }\n", "            }\n", "            if (!get_packet_dst (&dst, &pckt, vip_info, is_ipv6, lru_map)) {\n", "                return XDP_DROP;\n", "            }\n", "            data_stats->v2 += 1;\n", "        }\n", "    }\n", "    cval = bpf_map_lookup_elem (& ctl_array, & mac_addr_pos);\n", "    if (!cval) {\n", "        return XDP_DROP;\n", "    }\n", "    vip_num = vip_info->vip_num;\n", "    data_stats = bpf_map_lookup_elem (& stats, & vip_num);\n", "    if (!data_stats) {\n", "        return XDP_DROP;\n", "    }\n", "    data_stats->v1 += 1;\n", "    data_stats->v2 += pkt_bytes;\n", "    data_stats = bpf_map_lookup_elem (& reals_stats, & pckt.real_index);\n", "    if (!data_stats) {\n", "        return XDP_DROP;\n", "    }\n", "    data_stats->v1 += 1;\n", "    data_stats->v2 += pkt_bytes;\n", "\n", "#ifdef LOCAL_DELIVERY_OPTIMIZATION\n", "    if ((vip_info->flags & F_LOCAL_VIP) && (dst->flags & F_LOCAL_REAL)) {\n", "        return XDP_PASS;\n", "    }\n", "\n", "#endif\n", "    pckt.flow.port16[0] = original_sport;\n", "    if (dst->flags & F_IPV6) {\n", "        if (!PCKT_ENCAP_V6(xdp, cval, is_ipv6, &pckt, dst, pkt_bytes)) {\n", "            return XDP_DROP;\n", "        }\n", "    }\n", "    else {\n", "        if (!PCKT_ENCAP_V4(xdp, cval, &pckt, dst, pkt_bytes)) {\n", "            return XDP_DROP;\n", "        }\n", "    }\n", "    return XDP_TX;\n", "}\n"], "called_function_list": ["process_encaped_gue_pckt", "connection_table_lookup", "process_encaped_ipip_pckt", "increment_quic_cid_drop_real_0", "check_decap_dst", "process_l3_headers", "parse_udp", "increment_quic_cid_drop_no_real", "perform_global_lru_lookup", "get_packet_dst", "send_icmp_too_big", "increment_quic_cid_version_stats", "parse_tcp", "parse_quic", "tcp_hdr_opt_lookup"], "call_depth": 2, "humanFuncDescription": [{"description": " This function process the packet based on the protocol and updates corresponding stats. ", "author": "Nengneng Yu", "authorEmail": "ynn1999@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "libbpf", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}, {"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_PASS", "Return": 2, "Description": "The XDP_PASS return code means that the packet is allowed to be passed up to the kernel\u2019s networking stack. Meaning, the current CPU that was processing this packet now allocates a skb, populates it, and passes it onwards into the GRO engine. This would be equivalent to the default packet handling behavior without XDP.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 164, "endLine": 221, "File": "/home/sayandes/opened_extraction/examples/katran/decap_kern.c", "funcName": "process_packet", "developer_inline_comments": [{"start_line": 57, "end_line": 57, "text": "// INLINE_DECAP_GUE"}], "updateMaps": [], "readMaps": ["  decap_counters"], "input": ["void *data", " __u64 off", " void *data_end", " bool is_ipv6", " struct xdp_md *xdp"], "output": "staticinlineint", "helper": ["bpf_map_lookup_elem", "XDP_PASS"], "compatibleHookpoints": ["xdp"], "source": ["static inline int process_packet (void *data, __u64 off, void *data_end, bool is_ipv6, struct xdp_md *xdp)\n", "{\n", "    struct packet_description pckt = {}\n", "    ;\n", "    struct decap_stats *data_stats;\n", "    __u32 key = 0;\n", "    __u8 protocol;\n", "    int action;\n", "    __u16 pkt_bytes;\n", "    action = process_l3_headers (& pckt, & protocol, off, & pkt_bytes, data, data_end, is_ipv6);\n", "    if (action >= 0) {\n", "        return action;\n", "    }\n", "    protocol = pckt.flow.proto;\n", "    data_stats = bpf_map_lookup_elem (& decap_counters, & key);\n", "    if (!data_stats) {\n", "        return XDP_PASS;\n", "    }\n", "    data_stats->total += 1;\n", "    if (protocol == IPPROTO_IPIP || protocol == IPPROTO_IPV6) {\n", "        if (is_ipv6) {\n", "            data_stats->decap_v6 += 1;\n", "        }\n", "        else {\n", "            data_stats->decap_v4 += 1;\n", "        }\n", "        action = process_encaped_ipip_pckt (& data, & data_end, xdp, & is_ipv6, & pckt, & protocol, off, & pkt_bytes);\n", "        if (action >= 0) {\n", "            return action;\n", "        }\n", "    }\n", "\n", "#ifdef INLINE_DECAP_GUE\n", "    else if (protocol == IPPROTO_UDP) {\n", "        if (!parse_udp (data, data_end, is_ipv6, &pckt)) {\n", "            return XDP_PASS;\n", "        }\n", "        if (pckt.flow.port16[1] == bpf_htons (GUE_DPORT)) {\n", "            if (is_ipv6) {\n", "                data_stats->decap_v6 += 1;\n", "            }\n", "            else {\n", "                data_stats->decap_v4 += 1;\n", "            }\n", "            action = process_encaped_gue_pckt (& data, & data_end, xdp, is_ipv6);\n", "            if (action >= 0) {\n", "                return action;\n", "            }\n", "        }\n", "    }\n", "\n", "#endif // INLINE_DECAP_GUE\n", "    return XDP_PASS;\n", "}\n"], "called_function_list": ["process_encaped_gue_pckt", "connection_table_lookup", "process_encaped_ipip_pckt", "increment_quic_cid_drop_real_0", "check_decap_dst", "process_l3_headers", "parse_udp", "increment_quic_cid_drop_no_real", "perform_global_lru_lookup", "get_packet_dst", "send_icmp_too_big", "increment_quic_cid_version_stats", "parse_tcp", "parse_quic", "tcp_hdr_opt_lookup"], "call_depth": 2, "humanFuncDescription": [{"description": " This is a function which assembles the previous 3 functions process_l3_headers, process_encaped_ipip_pckt                   and process_encaped_gue_pckt. It process the packet regardless the type of the packet. ", "author": "Qintian Huang", "authorEmail": "qthuang@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "balancer_ingress": [{"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_PASS", "Return": 2, "Description": "The XDP_PASS return code means that the packet is allowed to be passed up to the kernel\u2019s networking stack. Meaning, the current CPU that was processing this packet now allocates a skb, populates it, and passes it onwards into the GRO engine. This would be equivalent to the default packet handling behavior without XDP.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_go_to_next_module"]}]}, {"capability": "pkt_stop_processing_drop_packet", "pkt_stop_processing_drop_packet": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_DROP", "Return": 1, "Description": "will drop the packet right at the driver level without wasting any further resources. This is in particular useful for BPF programs implementing DDoS mitigation mechanisms or firewalling in general.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_stop_processing_drop_packet"]}]}], "helperCallParams": {}, "startLine": 794, "endLine": 817, "File": "/home/sayandes/opened_extraction/examples/katran/balancer_kern.c", "funcName": "balancer_ingress", "developer_inline_comments": [{"start_line": 11, "end_line": 11, "text": "// bogus packet, len less than minimum ethernet frame size"}, {"start_line": 22, "end_line": 22, "text": "// pass to tcp/ip stack"}], "updateMaps": [], "readMaps": [], "input": ["struct xdp_md *ctx"], "output": "int", "helper": ["XDP_PASS", "XDP_DROP"], "compatibleHookpoints": ["xdp"], "source": ["int balancer_ingress (struct xdp_md *ctx)\n", "{\n", "    void *data = (void *) (long) ctx->data;\n", "    void *data_end = (void *) (long) ctx->data_end;\n", "    struct ethhdr *eth = data;\n", "    __u32 eth_proto;\n", "    __u32 nh_off;\n", "    nh_off = sizeof (struct ethhdr);\n", "    if (data + nh_off > data_end) {\n", "        return XDP_DROP;\n", "    }\n", "    eth_proto = eth->h_proto;\n", "    if (eth_proto == BE_ETH_P_IP) {\n", "        return process_packet (ctx, nh_off, false);\n", "    }\n", "    else if (eth_proto == BE_ETH_P_IPV6) {\n", "        return process_packet (ctx, nh_off, true);\n", "    }\n", "    else {\n", "        return XDP_PASS;\n", "    }\n", "}\n"], "called_function_list": ["process_packet"], "call_depth": 3, "humanFuncDescription": [{"description": " process the input ctx packet ", "author": "Nengneng Yu", "authorEmail": "ynn1999@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "get_packet_hash": [{"capabilities": [], "helperCallParams": {}, "startLine": 818, "endLine": 827, "File": "/home/sayandes/opened_extraction/examples/katran/balancer_kern.c", "funcName": "get_packet_hash", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct packet_description *pckt", " bool hash_16bytes"], "output": "staticinline__u32", "helper": [], "compatibleHookpoints": ["kprobe", "cgroup_skb", "sk_skb", "cgroup_device", "tracepoint", "socket_filter", "xdp", "raw_tracepoint_writable", "flow_dissector", "lwt_seg6local", "sched_cls", "lwt_out", "sched_act", "cgroup_sysctl", "cgroup_sock_addr", "sk_reuseport", "lwt_xmit", "sock_ops", "perf_event", "raw_tracepoint", "sk_msg", "lwt_in", "cgroup_sock"], "source": ["static inline __u32 get_packet_hash (struct packet_description *pckt, bool hash_16bytes)\n", "{\n", "    if (hash_16bytes) {\n", "        return jhash_2words (jhash (pckt->flow.srcv6, 16, INIT_JHASH_SEED_V6), pckt->flow.ports, INIT_JHASH_SEED);\n", "    }\n", "    else {\n", "        return jhash_2words (pckt->flow.src, pckt->flow.ports, INIT_JHASH_SEED);\n", "    }\n", "}\n"], "called_function_list": ["jhash", "jhash_2words"], "call_depth": 2, "humanFuncDescription": [{"description": " return the hash value of input packet ", "author": "Nengneng Yu", "authorEmail": "ynn1999@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "xdpdecap": [{"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_PASS", "Return": 2, "Description": "The XDP_PASS return code means that the packet is allowed to be passed up to the kernel\u2019s networking stack. Meaning, the current CPU that was processing this packet now allocates a skb, populates it, and passes it onwards into the GRO engine. This would be equivalent to the default packet handling behavior without XDP.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_go_to_next_module"]}]}, {"capability": "pkt_stop_processing_drop_packet", "pkt_stop_processing_drop_packet": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_DROP", "Return": 1, "Description": "will drop the packet right at the driver level without wasting any further resources. This is in particular useful for BPF programs implementing DDoS mitigation mechanisms or firewalling in general.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_stop_processing_drop_packet"]}]}], "helperCallParams": {}, "startLine": 224, "endLine": 247, "File": "/home/sayandes/opened_extraction/examples/katran/decap_kern.c", "funcName": "xdpdecap", "developer_inline_comments": [{"start_line": 11, "end_line": 11, "text": "// bogus packet, len less than minimum ethernet frame size"}, {"start_line": 22, "end_line": 22, "text": "// pass to tcp/ip stack"}], "updateMaps": [], "readMaps": [], "input": ["struct xdp_md *ctx"], "output": "int", "helper": ["XDP_PASS", "XDP_DROP"], "compatibleHookpoints": ["xdp"], "source": ["int xdpdecap (struct xdp_md *ctx)\n", "{\n", "    void *data = (void *) (long) ctx->data;\n", "    void *data_end = (void *) (long) ctx->data_end;\n", "    struct ethhdr *eth = data;\n", "    __u32 eth_proto;\n", "    __u32 nh_off;\n", "    nh_off = sizeof (struct ethhdr);\n", "    if (data + nh_off > data_end) {\n", "        return XDP_DROP;\n", "    }\n", "    eth_proto = eth->h_proto;\n", "    if (eth_proto == BE_ETH_P_IP) {\n", "        return process_packet (data, nh_off, data_end, false, ctx);\n", "    }\n", "    else if (eth_proto == BE_ETH_P_IPV6) {\n", "        return process_packet (data, nh_off, data_end, true, ctx);\n", "    }\n", "    else {\n", "        return XDP_PASS;\n", "    }\n", "}\n"], "called_function_list": ["process_packet"], "call_depth": 3, "humanFuncDescription": [{"description": " This is wrapper function which decapsulates the packet packet header for all types. After processing the packet, pass it to tcp/ip stack. ", "author": "Qintian Huang", "authorEmail": "qthuang@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "xdp_prog_simple": [{"capabilities": [], "helperCallParams": {}, "startLine": 9, "endLine": 13, "File": "/home/sayandes/opened_extraction/examples/katran/x.c", "funcName": "xdp_prog_simple", "developer_inline_comments": [{"start_line": 1, "end_line": 1, "text": "/* SPDX-License-Identifier: GPL-2.0 */"}, {"start_line": 5, "end_line": 5, "text": "//#include <linux/bpf.h>"}, {"start_line": 6, "end_line": 6, "text": "//#include <bpf/bpf_helpers.h>"}, {"start_line": 12, "end_line": 12, "text": "//return XDP_PASS;"}], "updateMaps": [], "readMaps": [], "input": ["struct xdp_md *ctx"], "output": "int", "helper": [], "compatibleHookpoints": ["kprobe", "cgroup_skb", "sk_skb", "cgroup_device", "tracepoint", "socket_filter", "xdp", "raw_tracepoint_writable", "flow_dissector", "lwt_seg6local", "sched_cls", "lwt_out", "sched_act", "cgroup_sysctl", "cgroup_sock_addr", "sk_reuseport", "lwt_xmit", "sock_ops", "perf_event", "raw_tracepoint", "sk_msg", "lwt_in", "cgroup_sock"], "source": ["int xdp_prog_simple (struct xdp_md *ctx)\n", "{\n", "    return xdpdecap (ctx);\n", "}\n"], "called_function_list": ["xdpdecap"], "call_depth": 4, "humanFuncDescription": [{"description": " Same as decap_kern, it decaps the packet and pass it to the tcp/ip stack. ", "author": "Qintian Huang", "authorEmail": "qthuang@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "xdp_root": [{"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_PASS", "Return": 2, "Description": "The XDP_PASS return code means that the packet is allowed to be passed up to the kernel\u2019s networking stack. Meaning, the current CPU that was processing this packet now allocates a skb, populates it, and passes it onwards into the GRO engine. This would be equivalent to the default packet handling behavior without XDP.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 30, "endLine": 37, "File": "/home/sayandes/opened_extraction/examples/katran/xdp_root.c", "funcName": "xdp_root", "developer_inline_comments": [{"start_line": 1, "end_line": 15, "text": "/* Copyright (C) 2018-present, Facebook, Inc.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; version 2 of the License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */"}], "updateMaps": [], "readMaps": [], "input": ["struct xdp_md *ctx"], "output": "\\xdp\\)", "helper": ["XDP_PASS", "bpf_tail_call"], "compatibleHookpoints": ["xdp"], "source": ["int SEC (\"xdp\") xdp_root (struct xdp_md *ctx)\n", "{\n", "    __u32 *fd;\n", "\n", "#pragma clang loop unroll(full)\n", "    for (__u32 i = 0; i < ROOT_ARRAY_SIZE; i++) {\n", "        bpf_tail_call (ctx, &root_array, i);\n", "    }\n", "    return XDP_PASS;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{"description": " Input (struct xdp_md* ctx) is user accessible metadata for XDP packet hook                   The program will jump into another eBPF program.                   For each index in root_array, the program attempts to jump into a program referenced at index i                   and passes ctx, a pointer to the context.                   This programs chains and executes the input program, and finally pass the packet. ", "author": "Qintian Huang", "authorEmail": "qthuang@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "xdp_val": [{"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_PASS", "Return": 2, "Description": "The XDP_PASS return code means that the packet is allowed to be passed up to the kernel\u2019s networking stack. Meaning, the current CPU that was processing this packet now allocates a skb, populates it, and passes it onwards into the GRO engine. This would be equivalent to the default packet handling behavior without XDP.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 40, "endLine": 47, "File": "/home/sayandes/opened_extraction/examples/katran/xdp_root.c", "funcName": "xdp_val", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct xdp_md *ctx"], "output": "\\xdp\\)", "helper": ["XDP_PASS", "bpf_tail_call"], "compatibleHookpoints": ["xdp"], "source": ["int SEC (\"xdp\") xdp_val (struct xdp_md *ctx)\n", "{\n", "    __u32 *fd;\n", "\n", "#pragma clang loop unroll(full)\n", "    for (__u32 i = 0; i < ROOT_ARRAY_SIZE; i++) {\n", "        bpf_tail_call (ctx, &root_array, i);\n", "    }\n", "    return XDP_PASS;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{"description": " Input (struct xdp_md* ctx) is user accessible metadata for XDP packet hook                   The program will jump into another eBPF program.                   For each index in root_array, the program attempts to jump into a program referenced at index i                   and passes ctx, a pointer to the context.                   This programs chains and executes the input program, and finally pass the packet. ", "author": "Qintian Huang", "authorEmail": "qthuang@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "healthcheck_encap": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "libbpf", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}, {"capability": "pkt_stop_processing_drop_packet", "pkt_stop_processing_drop_packet": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_SHOT", "Return": 2, "Description": "instructs the kernel to drop the packet, meaning, upper layers of the networking stack will never see the skb on ingress and similarly the packet will never be submitted for transmission on egress. TC_ACT_SHOT and TC_ACT_STOLEN are both similar in nature with few differences: TC_ACT_SHOT will indicate to the kernel that the skb was released through kfree_skb() and return NET_XMIT_DROP to the callers for immediate feedback, whereas TC_ACT_STOLEN will release the skb through consume_skb() and pretend to upper layers that the transmission was successful through NET_XMIT_SUCCESS. The perf\u2019s drop monitor which records traces of kfree_skb() will therefore also not see any drop indications from TC_ACT_STOLEN since its semantics are such that the skb has been \u201cconsumed\u201d or queued but certainly not \"dropped\".", "compatible_hookpoints": ["sched_cls", "sched_act"], "capabilities": ["pkt_stop_processing_drop_packet"]}]}, {"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_UNSPEC", "Return": -1, "Description": "unspecified action and is used in three cases, i) when an offloaded tc BPF program is attached and the tc ingress hook is run where the cls_bpf representation for the offloaded program will return TC_ACT_UNSPEC, ii) in order to continue with the next tc BPF program in cls_bpf for the multi-program case. The latter also works in combination with offloaded tc BPF programs from point i) where the TC_ACT_UNSPEC from there continues with a next tc BPF program solely running in non-offloaded case. Last but not least, iii) TC_ACT_UNSPEC is also used for the single program case to simply tell the kernel to continue with the skb without additional side-effects. TC_ACT_UNSPEC is very similar to the TC_ACT_OK action code in the sense that both pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. The only difference to TC_ACT_OK is that TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 34, "endLine": 139, "File": "/home/sayandes/opened_extraction/examples/katran/healthchecking_kern.c", "funcName": "healthcheck_encap", "developer_inline_comments": [{"start_line": 1, "end_line": 15, "text": "/* Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; version 2 of the License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */"}, {"start_line": 59, "end_line": 59, "text": "// some strange (w/ fwmark; but not a healthcheck) local packet"}, {"start_line": 66, "end_line": 66, "text": "// do not allow packets bigger than the specified size"}, {"start_line": 75, "end_line": 75, "text": "// we dont have ifindex for main interface"}, {"start_line": 76, "end_line": 76, "text": "// not much we can do without it. Drop packet so that hc will fail"}, {"start_line": 108, "end_line": 108, "text": "// to prevent recursion, if encapsulated packet would run through this filter"}], "updateMaps": [], "readMaps": ["  hc_stats_map", " per_hckey_stats", " hc_ctrl_map", "  hc_pckt_macs", " hc_reals_map", " hc_key_map"], "input": ["struct  __sk_buff *skb"], "output": "int", "helper": ["bpf_map_lookup_elem", "TC_ACT_SHOT", "bpf_redirect", "TC_ACT_UNSPEC"], "compatibleHookpoints": ["sched_act", "sched_cls"], "source": ["int healthcheck_encap (struct  __sk_buff *skb)\n", "{\n", "    __u32 stats_key = GENERIC_STATS_INDEX;\n", "    __u32 key = HC_MAIN_INTF_POSITION;\n", "    __u32 somark = skb->mark;\n", "    __u32 ifindex = 0;\n", "    __u64 flags = 0;\n", "    bool is_ipv6 = false;\n", "    int adjust_len = 0;\n", "    int ret = 0;\n", "    struct hc_stats *prog_stats;\n", "    struct ethhdr *ethh;\n", "    struct hc_mac *esrc, *edst;\n", "    struct hc_real_definition *src;\n", "    prog_stats = bpf_map_lookup_elem (& hc_stats_map, & stats_key);\n", "    if (!prog_stats) {\n", "        return TC_ACT_UNSPEC;\n", "    }\n", "    if (somark == 0) {\n", "        prog_stats->pckts_skipped += 1;\n", "        return TC_ACT_UNSPEC;\n", "    }\n", "    struct hc_real_definition *real = bpf_map_lookup_elem (&hc_reals_map, &somark);\n", "    if (!real) {\n", "        prog_stats->pckts_skipped += 1;\n", "        return TC_ACT_UNSPEC;\n", "    }\n", "\n", "#if HC_MAX_PACKET_SIZE > 0\n", "    if (skb->len > HC_MAX_PACKET_SIZE) {\n", "        prog_stats->pckts_dropped += 1;\n", "        prog_stats->pckts_too_big += 1;\n", "        return TC_ACT_SHOT;\n", "    }\n", "\n", "#endif\n", "    __u32 *intf_ifindex = bpf_map_lookup_elem (&hc_ctrl_map, &key);\n", "    if (!intf_ifindex) {\n", "        prog_stats->pckts_dropped += 1;\n", "        return TC_ACT_SHOT;\n", "    }\n", "    key = HC_SRC_MAC_POS;\n", "    esrc = bpf_map_lookup_elem (& hc_pckt_macs, & key);\n", "    if (!esrc) {\n", "        prog_stats->pckts_dropped += 1;\n", "        return TC_ACT_SHOT;\n", "    }\n", "    key = HC_DST_MAC_POS;\n", "    edst = bpf_map_lookup_elem (& hc_pckt_macs, & key);\n", "    if (!edst) {\n", "        prog_stats->pckts_dropped += 1;\n", "        return TC_ACT_SHOT;\n", "    }\n", "    if ((skb->data + sizeof (struct ethhdr)) > skb->data_end) {\n", "        prog_stats->pckts_dropped += 1;\n", "        return TC_ACT_SHOT;\n", "    }\n", "    ethh = (void *) (long) skb->data;\n", "    if (ethh->h_proto == BE_ETH_P_IPV6) {\n", "        is_ipv6 = true;\n", "    }\n", "    struct hc_key hckey = {}\n", "    ;\n", "    bool hc_key_parseable = set_hc_key (skb, & hckey, is_ipv6);\n", "    skb->mark = 0;\n", "    if (!HC_ENCAP(skb, real, ethh, is_ipv6)) {\n", "        prog_stats->pckts_dropped += 1;\n", "        return TC_ACT_SHOT;\n", "    }\n", "    if (skb->data + sizeof (struct ethhdr) > skb->data_end) {\n", "        prog_stats->pckts_dropped += 1;\n", "        return TC_ACT_SHOT;\n", "    }\n", "    ethh = (void *) (long) skb->data;\n", "    memcpy (ethh->h_source, esrc->mac, 6);\n", "    memcpy (ethh->h_dest, edst->mac, 6);\n", "    prog_stats->pckts_processed += 1;\n", "    if (hc_key_parseable) {\n", "        __u32 *hc_key_cntr_index = bpf_map_lookup_elem (&hc_key_map, &hckey);\n", "        if (hc_key_cntr_index) {\n", "            __u32 *packets_processed_for_hc_key = bpf_map_lookup_elem (&per_hckey_stats, hc_key_cntr_index);\n", "            if (packets_processed_for_hc_key) {\n", "                *packets_processed_for_hc_key += 1;\n", "            }\n", "        }\n", "    }\n", "    return bpf_redirect (*intf_ifindex, REDIRECT_EGRESS);\n", "}\n"], "called_function_list": ["set_hc_key"], "call_depth": 1, "humanFuncDescription": [{"description": " Input is user accessible mirror of in-kernel sk_buff                   This function performs healthcheck for encapsulation                   Use default action configured from tc (TC_ACT_UNSPEC), which is skip the packet, if                    1) program stats is NULL/stats_key is not found in hc_stats_map,                    2)mark of the sk_buff is 0,                    3)somark is not found in hc_reals_map                   The program returns error/healthcheck fails (TC_ACT_SHOT) if 1)packet is bigger than the specified size,                   2)do not have ifindex for main interface,                   3)do not find HC_SRC_MAC_POS or HC_DST_MAC_POS,                   4)the result for HC_ENCAP (healthcheck encap) is faulse.                   Otherwise, the packet passes the healthcheck, and will be redirected to another net device of index intf_ifindex. ", "author": "Qintian Huang", "authorEmail": "qthuang@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_UNSPEC", "Return": -1, "Description": "unspecified action and is used in three cases, i) when an offloaded tc BPF program is attached and the tc ingress hook is run where the cls_bpf representation for the offloaded program will return TC_ACT_UNSPEC, ii) in order to continue with the next tc BPF program in cls_bpf for the multi-program case. The latter also works in combination with offloaded tc BPF programs from point i) where the TC_ACT_UNSPEC from there continues with a next tc BPF program solely running in non-offloaded case. Last but not least, iii) TC_ACT_UNSPEC is also used for the single program case to simply tell the kernel to continue with the skb without additional side-effects. TC_ACT_UNSPEC is very similar to the TC_ACT_OK action code in the sense that both pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. The only difference to TC_ACT_OK is that TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}, {"capability": "map_read", "map_read": [{"Project": "libbpf", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}, {"capability": "pkt_stop_processing_drop_packet", "pkt_stop_processing_drop_packet": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_SHOT", "Return": 2, "Description": "instructs the kernel to drop the packet, meaning, upper layers of the networking stack will never see the skb on ingress and similarly the packet will never be submitted for transmission on egress. TC_ACT_SHOT and TC_ACT_STOLEN are both similar in nature with few differences: TC_ACT_SHOT will indicate to the kernel that the skb was released through kfree_skb() and return NET_XMIT_DROP to the callers for immediate feedback, whereas TC_ACT_STOLEN will release the skb through consume_skb() and pretend to upper layers that the transmission was successful through NET_XMIT_SUCCESS. The perf\u2019s drop monitor which records traces of kfree_skb() will therefore also not see any drop indications from TC_ACT_STOLEN since its semantics are such that the skb has been \u201cconsumed\u201d or queued but certainly not \"dropped\".", "compatible_hookpoints": ["sched_cls", "sched_act"], "capabilities": ["pkt_stop_processing_drop_packet"]}]}, {"capability": "update_pkt", "update_pkt": [{"Project": "libbpf", "Return Type": "int", "Description": "Populate tunnel metadata for packet associated to skb. The tunnel metadata is set to the contents of <[ key ]>(IP: 1) , of size. The <[ flags ]>(IP: 3) can be set to a combination of the following values: BPF_F_TUNINFO_IPV6 Indicate that the tunnel is based on IPv6 protocol instead of IPv4. BPF_F_ZERO_CSUM_TX For IPv4 packets , add a flag to tunnel metadata indicating that checksum computation should be skipped and checksum set to zeroes. BPF_F_DONT_FRAGMENT Add a flag to tunnel metadata indicating that the packet should not be fragmented. BPF_F_SEQ_NUMBER Add a flag to tunnel metadata indicating that a sequence number should be added to tunnel header before sending the packet. This flag was added for GRE encapsulation , but might be used with other protocols as well in the future. Here is a typical usage on the transmit path: struct bpf_tunnel_key key; populate <[ key ]>(IP: 1) . . . bpf_skb_set_tunnel_key(skb , &key , sizeof(key) , 0); bpf_clone_redirect(skb , vxlan_dev_ifindex , 0); See also the description of the bpf_skb_get_tunnel_key() helper for additional information. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_skb_set_tunnel_key", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  struct bpf_tunnel_key ,Var: *key}", "{Type:  u32 ,Var: size}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["sched_cls", "sched_act", "lwt_xmit"], "capabilities": ["update_pkt"]}]}], "helperCallParams": {}, "startLine": 89, "endLine": 157, "File": "/home/sayandes/opened_extraction/examples/katran/healthchecking_ipip.c", "funcName": "healthcheck_encap", "developer_inline_comments": [{"start_line": 1, "end_line": 15, "text": "/* Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n * *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; version 2 of the License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */"}, {"start_line": 34, "end_line": 34, "text": "// Specify max packet size to avoid packets exceed mss (after encapsulation)"}, {"start_line": 39, "end_line": 39, "text": "// position in stats map where we are storing generic counters."}, {"start_line": 42, "end_line": 42, "text": "// size of stats map."}, {"start_line": 57, "end_line": 57, "text": "// struct to record packet level for counters for relevant events"}, {"start_line": 79, "end_line": 79, "text": "// map which contains counters for monitoring"}, {"start_line": 113, "end_line": 113, "text": "// some strange (w/ fwmark; but not a healthcheck) local packet"}, {"start_line": 119, "end_line": 119, "text": "// do not allow packets bigger than the specified size"}, {"start_line": 127, "end_line": 127, "text": "// we dont have ifindex for ipip v4 interface"}, {"start_line": 128, "end_line": 128, "text": "// not much we can do without it. Drop packet so that hc will fail"}, {"start_line": 141, "end_line": 141, "text": "// to prevent recursion, when encaped packet would run through this filter"}, {"start_line": 145, "end_line": 145, "text": "// the dst is v6."}, {"start_line": 150, "end_line": 150, "text": "// the dst is v4"}], "updateMaps": [], "readMaps": [" hc_reals_map", "  hc_stats_map", " hc_ctrl_map"], "input": ["struct  __sk_buff *skb"], "output": "int", "helper": ["bpf_redirect", "TC_ACT_UNSPEC", "bpf_map_lookup_elem", "TC_ACT_SHOT", "bpf_skb_set_tunnel_key"], "compatibleHookpoints": ["sched_act", "sched_cls"], "source": ["int healthcheck_encap (struct  __sk_buff *skb)\n", "{\n", "    int ret = 0;\n", "    int tun_flag = 0;\n", "    __u32 ifindex;\n", "    __u32 somark = skb->mark;\n", "    __u32 v4_intf_pos = 1;\n", "    __u32 v6_intf_pos = 2;\n", "    struct bpf_tunnel_key tkey = {}\n", "    ;\n", "    __u32 stats_key = GENERIC_STATS_INDEX;\n", "    struct hc_stats *prog_stats;\n", "    prog_stats = bpf_map_lookup_elem (& hc_stats_map, & stats_key);\n", "    if (!prog_stats) {\n", "        return TC_ACT_UNSPEC;\n", "    }\n", "    if (skb->mark == 0) {\n", "        prog_stats->pckts_skipped += 1;\n", "        return TC_ACT_UNSPEC;\n", "    }\n", "    struct hc_real_definition *real = bpf_map_lookup_elem (&hc_reals_map, &somark);\n", "    if (!real) {\n", "        prog_stats->pckts_skipped += 1;\n", "        return TC_ACT_UNSPEC;\n", "    }\n", "    if (skb->len > MAX_PACKET_SIZE) {\n", "        prog_stats->pckts_dropped += 1;\n", "        prog_stats->pckts_too_big += 1;\n", "        return TC_ACT_SHOT;\n", "    }\n", "    __u32 *v4_intf_ifindex = bpf_map_lookup_elem (&hc_ctrl_map, &v4_intf_pos);\n", "    if (!v4_intf_ifindex) {\n", "        prog_stats->pckts_dropped += 1;\n", "        return TC_ACT_SHOT;\n", "    }\n", "    __u32 *v6_intf_ifindex = bpf_map_lookup_elem (&hc_ctrl_map, &v6_intf_pos);\n", "    if (!v6_intf_ifindex) {\n", "        prog_stats->pckts_dropped += 1;\n", "        return TC_ACT_SHOT;\n", "    }\n", "    tkey.tunnel_ttl = DEFAULT_TTL;\n", "    skb->mark = 0;\n", "    if (real->flags == V6DADDR) {\n", "        tun_flag = BPF_F_TUNINFO_IPV6;\n", "        memcpy (tkey.remote_ipv6, real->v6daddr, 16);\n", "        ifindex = *v6_intf_ifindex;\n", "    }\n", "    else {\n", "        tkey.remote_ipv4 = real->daddr;\n", "        ifindex = *v4_intf_ifindex;\n", "    }\n", "    prog_stats->pckts_processed += 1;\n", "    bpf_skb_set_tunnel_key (skb, &tkey, sizeof (tkey), tun_flag);\n", "    return bpf_redirect (ifindex, REDIRECT_EGRESS);\n", "}\n"], "called_function_list": ["set_hc_key"], "call_depth": 1, "humanFuncDescription": [{"description": " Performs healthcheck for ip-in-ip encapsulated packets.                   Use default action configured from tc (TC_ACT_UNSPEC), which is skip the packet, if                    1) program stats is NULL/stats_key is not found in hc_stats_map,                    2)mark of the sk_buff is 0,                    3)somark is not found in hc_reals_map                   The program returns error/healthcheck fails (TC_ACT_SHOT) if                    1)packet is bigger than the specified size,                   2)do not have ipip v4 or v6 ifindex for main interface.                   Otherwise, Populate tunnel metadata for packet associated to skb, the tunnel metadata is set to the contents of tkey.                   The packet passes the healthcheck, and will be redirected to another net device of index intf_ifindex. ", "author": "Qintian Huang", "authorEmail": "qthuang@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "pktcntr": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "libbpf", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}, {"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_PASS", "Return": 2, "Description": "The XDP_PASS return code means that the packet is allowed to be passed up to the kernel\u2019s networking stack. Meaning, the current CPU that was processing this packet now allocates a skb, populates it, and passes it onwards into the GRO engine. This would be equivalent to the default packet handling behavior without XDP.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 46, "endLine": 62, "File": "/home/sayandes/opened_extraction/examples/katran/xdp_pktcntr.c", "funcName": "pktcntr", "developer_inline_comments": [{"start_line": 1, "end_line": 15, "text": "/* Copyright (C) 2018-present, Facebook, Inc.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; version 2 of the License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */"}], "updateMaps": [], "readMaps": [" ctl_array", " cntrs_array"], "input": ["struct xdp_md *ctx"], "output": "int", "helper": ["bpf_map_lookup_elem", "XDP_PASS"], "compatibleHookpoints": ["xdp"], "source": ["int pktcntr (struct xdp_md *ctx)\n", "{\n", "    void *data_end = (void *) (long) ctx->data_end;\n", "    void *data = (void *) (long) ctx->data;\n", "    __u32 ctl_flag_pos = 0;\n", "    __u32 cntr_pos = 0;\n", "    __u32 *flag = bpf_map_lookup_elem (&ctl_array, &ctl_flag_pos);\n", "    if (!flag || (*flag == 0)) {\n", "        return XDP_PASS;\n", "    }\n", "    __u64 *cntr_val = bpf_map_lookup_elem (&cntrs_array, &cntr_pos);\n", "    if (cntr_val) {\n", "        *cntr_val += 1;\n", "    }\n", "    return XDP_PASS;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "encap_v6": [{"capabilities": [], "helperCallParams": {}, "startLine": 41, "endLine": 91, "File": "/home/sayandes/opened_extraction/examples/katran/pckt_encap.h", "funcName": "encap_v6", "developer_inline_comments": [{"start_line": 1, "end_line": 15, "text": "/* Copyright (C) 2018-present, Facebook, Inc.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; version 2 of the License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */"}, {"start_line": 20, "end_line": 24, "text": "/*\n * This file contains routines which are responsible for encapsulation of the\n * packets, which will be sent out from load balancer. right now we are\n * using IPIP as our encap of choice\n */"}, {"start_line": 57, "end_line": 57, "text": "// ip(6)ip6 encap"}], "updateMaps": [], "readMaps": [], "input": ["struct xdp_md *xdp", " struct ctl_value *cval", " bool is_ipv6", " struct packet_description *pckt", " struct real_definition *dst", " __u32 pkt_bytes"], "output": "staticinlinebool", "helper": [], "compatibleHookpoints": ["kprobe", "cgroup_skb", "sk_skb", "cgroup_device", "tracepoint", "socket_filter", "xdp", "raw_tracepoint_writable", "flow_dissector", "lwt_seg6local", "sched_cls", "lwt_out", "sched_act", "cgroup_sysctl", "cgroup_sock_addr", "sk_reuseport", "lwt_xmit", "sock_ops", "perf_event", "raw_tracepoint", "sk_msg", "lwt_in", "cgroup_sock"], "source": ["static inline bool encap_v6 (struct xdp_md *xdp, struct ctl_value *cval, bool is_ipv6, struct packet_description *pckt, struct real_definition *dst, __u32 pkt_bytes)\n", "{\n", "    void *data;\n", "    void *data_end;\n", "    struct ipv6hdr *ip6h;\n", "    struct ethhdr *new_eth;\n", "    struct ethhdr *old_eth;\n", "    __u16 payload_len;\n", "    __u32 ip_suffix;\n", "    __u32 saddr [4];\n", "    __u8 proto;\n", "    if (bpf_xdp_adjust_head (xdp, 0 - (int) sizeof (struct ipv6hdr))) {\n", "        return false;\n", "    }\n", "    data = (void *) (long) xdp->data;\n", "    data_end = (void *) (long) xdp->data_end;\n", "    new_eth = data;\n", "    ip6h = data + sizeof (struct ethhdr);\n", "    old_eth = data + sizeof (struct ipv6hdr);\n", "    if (new_eth + 1 > data_end || old_eth + 1 > data_end || ip6h + 1 > data_end) {\n", "        return false;\n", "    }\n", "    memcpy (new_eth->h_dest, cval->mac, 6);\n", "    memcpy (new_eth->h_source, old_eth->h_dest, 6);\n", "    new_eth->h_proto = BE_ETH_P_IPV6;\n", "    if (is_ipv6) {\n", "        proto = IPPROTO_IPV6;\n", "        ip_suffix = pckt->flow.srcv6[3] ^ pckt->flow.port16[0];\n", "        payload_len = pkt_bytes + sizeof (struct ipv6hdr);\n", "    }\n", "    else {\n", "        proto = IPPROTO_IPIP;\n", "        ip_suffix = pckt->flow.src ^ pckt->flow.port16[0];\n", "        payload_len = pkt_bytes;\n", "    }\n", "    saddr[0] = IPIP_V6_PREFIX1;\n", "    saddr[1] = IPIP_V6_PREFIX2;\n", "    saddr[2] = IPIP_V6_PREFIX3;\n", "    saddr[3] = ip_suffix;\n", "    create_v6_hdr (ip6h, pckt->tos, saddr, dst->dstv6, payload_len, proto);\n", "    return true;\n", "}\n"], "called_function_list": ["create_v6_hdr"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "encap_v4": [{"capabilities": [], "helperCallParams": {}, "startLine": 93, "endLine": 133, "File": "/home/sayandes/opened_extraction/examples/katran/pckt_encap.h", "funcName": "encap_v4", "developer_inline_comments": [{"start_line": 15, "end_line": 15, "text": "//  __u64 csum = 0;"}, {"start_line": 16, "end_line": 16, "text": "// ipip encap"}], "updateMaps": [], "readMaps": [], "input": ["struct xdp_md *xdp", " struct ctl_value *cval", " struct packet_description *pckt", " struct real_definition *dst", " __u32 pkt_bytes"], "output": "staticinlinebool", "helper": [], "compatibleHookpoints": ["kprobe", "cgroup_skb", "sk_skb", "cgroup_device", "tracepoint", "socket_filter", "xdp", "raw_tracepoint_writable", "flow_dissector", "lwt_seg6local", "sched_cls", "lwt_out", "sched_act", "cgroup_sysctl", "cgroup_sock_addr", "sk_reuseport", "lwt_xmit", "sock_ops", "perf_event", "raw_tracepoint", "sk_msg", "lwt_in", "cgroup_sock"], "source": ["static inline bool encap_v4 (struct xdp_md *xdp, struct ctl_value *cval, struct packet_description *pckt, struct real_definition *dst, __u32 pkt_bytes)\n", "{\n", "    void *data;\n", "    void *data_end;\n", "    struct iphdr *iph;\n", "    struct ethhdr *new_eth;\n", "    struct ethhdr *old_eth;\n", "    __u32 ip_suffix = bpf_htons (pckt -> flow.port16 [0]);\n", "    ip_suffix <<= 16;\n", "    ip_suffix ^= pckt->flow.src;\n", "    if (bpf_xdp_adjust_head (xdp, 0 - (int) sizeof (struct iphdr))) {\n", "        return false;\n", "    }\n", "    data = (void *) (long) xdp->data;\n", "    data_end = (void *) (long) xdp->data_end;\n", "    new_eth = data;\n", "    iph = data + sizeof (struct ethhdr);\n", "    old_eth = data + sizeof (struct iphdr);\n", "    if (new_eth + 1 > data_end || old_eth + 1 > data_end || iph + 1 > data_end) {\n", "        return false;\n", "    }\n", "    memcpy (new_eth->h_dest, cval->mac, 6);\n", "    memcpy (new_eth->h_source, old_eth->h_dest, 6);\n", "    new_eth->h_proto = BE_ETH_P_IP;\n", "    create_v4_hdr (iph, pckt->tos, ((0xFFFF0000 & ip_suffix) | IPIP_V4_PREFIX), dst->dst, pkt_bytes, IPPROTO_IPIP);\n", "    return true;\n", "}\n"], "called_function_list": ["create_v4_hdr"], "call_depth": 3, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "decap_v6": [{"capabilities": [], "helperCallParams": {}, "startLine": 137, "endLine": 156, "File": "/home/sayandes/opened_extraction/examples/katran/pckt_encap.h", "funcName": "decap_v6", "developer_inline_comments": [{"start_line": 1, "end_line": 1, "text": "// before calling decap helper apropriate checks for data_end - data must be"}, {"start_line": 2, "end_line": 2, "text": "// done. otherwise verifier wont like it"}], "updateMaps": [], "readMaps": [], "input": ["struct xdp_md *xdp", " void **data", " void **data_end", " bool inner_v4"], "output": "staticinlinebool", "helper": [], "compatibleHookpoints": ["kprobe", "cgroup_skb", "sk_skb", "cgroup_device", "tracepoint", "socket_filter", "xdp", "raw_tracepoint_writable", "flow_dissector", "lwt_seg6local", "sched_cls", "lwt_out", "sched_act", "cgroup_sysctl", "cgroup_sock_addr", "sk_reuseport", "lwt_xmit", "sock_ops", "perf_event", "raw_tracepoint", "sk_msg", "lwt_in", "cgroup_sock"], "source": ["static inline bool decap_v6 (struct xdp_md *xdp, void **data, void **data_end, bool inner_v4)\n", "{\n", "    struct ethhdr *new_eth;\n", "    struct ethhdr *old_eth;\n", "    old_eth = *data;\n", "    new_eth = *data + sizeof (struct ipv6hdr);\n", "    memcpy (new_eth->h_source, old_eth->h_source, 6);\n", "    memcpy (new_eth->h_dest, old_eth->h_dest, 6);\n", "    if (inner_v4) {\n", "        new_eth->h_proto = BE_ETH_P_IP;\n", "    }\n", "    else {\n", "        new_eth->h_proto = BE_ETH_P_IPV6;\n", "    }\n", "    if (bpf_xdp_adjust_head (xdp, (int) sizeof (struct ipv6hdr))) {\n", "        return false;\n", "    }\n", "    *data = (void *) (long) xdp->data;\n", "    *data_end = (void *) (long) xdp->data_end;\n", "    return true;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "decap_v4": [{"capabilities": [], "helperCallParams": {}, "startLine": 158, "endLine": 173, "File": "/home/sayandes/opened_extraction/examples/katran/pckt_encap.h", "funcName": "decap_v4", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct xdp_md *xdp", " void **data", " void **data_end"], "output": "staticinlinebool", "helper": [], "compatibleHookpoints": ["kprobe", "cgroup_skb", "sk_skb", "cgroup_device", "tracepoint", "socket_filter", "xdp", "raw_tracepoint_writable", "flow_dissector", "lwt_seg6local", "sched_cls", "lwt_out", "sched_act", "cgroup_sysctl", "cgroup_sock_addr", "sk_reuseport", "lwt_xmit", "sock_ops", "perf_event", "raw_tracepoint", "sk_msg", "lwt_in", "cgroup_sock"], "source": ["static inline bool decap_v4 (struct xdp_md *xdp, void **data, void **data_end)\n", "{\n", "    struct ethhdr *new_eth;\n", "    struct ethhdr *old_eth;\n", "    old_eth = *data;\n", "    new_eth = *data + sizeof (struct iphdr);\n", "    memcpy (new_eth->h_source, old_eth->h_source, 6);\n", "    memcpy (new_eth->h_dest, old_eth->h_dest, 6);\n", "    new_eth->h_proto = BE_ETH_P_IP;\n", "    if (bpf_xdp_adjust_head (xdp, (int) sizeof (struct iphdr))) {\n", "        return false;\n", "    }\n", "    *data = (void *) (long) xdp->data;\n", "    *data_end = (void *) (long) xdp->data_end;\n", "    return true;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "gue_csum": [{"capabilities": [], "helperCallParams": {}, "startLine": 177, "endLine": 249, "File": "/home/sayandes/opened_extraction/examples/katran/pckt_encap.h", "funcName": "gue_csum", "developer_inline_comments": [{"start_line": 10, "end_line": 10, "text": "// offsets for different header types"}, {"start_line": 44, "end_line": 44, "text": "// encapsulation for ipv6 in ipv4 is not supported"}], "updateMaps": [], "readMaps": [], "input": ["void *data", " void *data_end", " bool outer_v6", " bool inner_v6", " struct packet_description *pckt", " __u64 *csum"], "output": "staticinlinebool", "helper": [], "compatibleHookpoints": ["kprobe", "cgroup_skb", "sk_skb", "cgroup_device", "tracepoint", "socket_filter", "xdp", "raw_tracepoint_writable", "flow_dissector", "lwt_seg6local", "sched_cls", "lwt_out", "sched_act", "cgroup_sysctl", "cgroup_sock_addr", "sk_reuseport", "lwt_xmit", "sock_ops", "perf_event", "raw_tracepoint", "sk_msg", "lwt_in", "cgroup_sock"], "source": ["static inline bool gue_csum (void *data, void *data_end, bool outer_v6, bool inner_v6, struct packet_description *pckt, __u64 *csum)\n", "{\n", "    __u16 outer_ip_off;\n", "    __u16 udp_hdr_off;\n", "    __u16 inner_ip_off;\n", "    __u16 inner_transport_off;\n", "    struct udphdr *udph;\n", "    outer_ip_off = sizeof (struct ethhdr);\n", "    udp_hdr_off = outer_v6 ? outer_ip_off + sizeof (struct ipv6hdr) : outer_ip_off + sizeof (struct iphdr);\n", "    inner_ip_off = udp_hdr_off + sizeof (struct udphdr);\n", "    inner_transport_off = inner_v6 ? inner_ip_off + sizeof (struct ipv6hdr) : inner_ip_off + sizeof (struct iphdr);\n", "    if (data + inner_transport_off > data_end) {\n", "        return false;\n", "    }\n", "    if (pckt->flow.proto == IPPROTO_UDP) {\n", "        struct udphdr *inner_udp = data + inner_transport_off;\n", "        if (inner_udp + 1 > data_end) {\n", "            return false;\n", "        }\n", "        *csum = inner_udp->check;\n", "    }\n", "    else if (pckt->flow.proto == IPPROTO_TCP) {\n", "        struct tcphdr *inner_tcp = data + inner_transport_off;\n", "        if (inner_tcp + 1 > data_end) {\n", "            return false;\n", "        }\n", "        *csum = inner_tcp->check;\n", "    }\n", "    else {\n", "        return false;\n", "    }\n", "    if (inner_v6) {\n", "        struct ipv6hdr *outer_ip6h = data + outer_ip_off;\n", "        udph = (void *) data + udp_hdr_off;\n", "        struct ipv6hdr *inner_ip6h = data + inner_ip_off;\n", "        if (outer_ip6h + 1 > data_end || udph + 1 > data_end || inner_ip6h + 1 > data_end) {\n", "            return false;\n", "        }\n", "        return gue_csum_v6 (outer_ip6h, udph, inner_ip6h, csum);\n", "    }\n", "    else {\n", "        if (outer_v6) {\n", "            struct ipv6hdr *outer_ip6h = data + outer_ip_off;\n", "            udph = data + udp_hdr_off;\n", "            struct iphdr *inner_iph = data + inner_ip_off;\n", "            if (outer_ip6h + 1 > data_end || udph + 1 > data_end || inner_iph + 1 > data_end) {\n", "                return false;\n", "            }\n", "            return gue_csum_v4_in_v6 (outer_ip6h, udph, inner_iph, csum);\n", "        }\n", "        else {\n", "            struct iphdr *outer_iph = data + outer_ip_off;\n", "            udph = data + udp_hdr_off;\n", "            struct iphdr *inner_iph = data + inner_ip_off;\n", "            if (outer_iph + 1 > data_end || udph + 1 > data_end || inner_iph + 1 > data_end) {\n", "                return false;\n", "            }\n", "            return gue_csum_v4 (outer_iph, udph, inner_iph, csum);\n", "        }\n", "    }\n", "    return true;\n", "}\n"], "called_function_list": ["gue_csum_v4", "gue_csum_v6", "gue_csum_v4_in_v6"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "gue_encap_v4": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "libbpf", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 251, "endLine": 307, "File": "/home/sayandes/opened_extraction/examples/katran/pckt_encap.h", "funcName": "gue_encap_v4", "developer_inline_comments": [], "updateMaps": [], "readMaps": ["  pckt_srcs"], "input": ["struct xdp_md *xdp", " struct ctl_value *cval", " struct packet_description *pckt", " struct real_definition *dst", " __u32 pkt_bytes"], "output": "staticinlinebool", "helper": ["bpf_map_lookup_elem"], "compatibleHookpoints": ["kprobe", "cgroup_skb", "sk_skb", "cgroup_device", "tracepoint", "socket_filter", "xdp", "raw_tracepoint_writable", "flow_dissector", "lwt_seg6local", "sched_cls", "lwt_out", "sched_act", "cgroup_sysctl", "cgroup_sock_addr", "sk_reuseport", "lwt_xmit", "sock_ops", "perf_event", "raw_tracepoint", "sk_msg", "lwt_in", "cgroup_sock"], "source": ["static inline bool gue_encap_v4 (struct xdp_md *xdp, struct ctl_value *cval, struct packet_description *pckt, struct real_definition *dst, __u32 pkt_bytes)\n", "{\n", "    void *data;\n", "    void *data_end;\n", "    struct iphdr *iph;\n", "    struct udphdr *udph;\n", "    struct ethhdr *new_eth;\n", "    struct ethhdr *old_eth;\n", "    struct real_definition *src;\n", "    __u16 sport = bpf_htons (pckt -> flow.port16 [0]);\n", "    __u32 ipv4_src = V4_SRC_INDEX;\n", "    src = bpf_map_lookup_elem (& pckt_srcs, & ipv4_src);\n", "    if (!src) {\n", "        return false;\n", "    }\n", "    ipv4_src = src->dst;\n", "    sport ^= ((pckt->flow.src >> 16) & 0xFFFF);\n", "    if (bpf_xdp_adjust_head (xdp, 0 - ((int) sizeof (struct iphdr) + (int) sizeof (struct udphdr)))) {\n", "        return false;\n", "    }\n", "    data = (void *) (long) xdp->data;\n", "    data_end = (void *) (long) xdp->data_end;\n", "    new_eth = data;\n", "    iph = data + sizeof (struct ethhdr);\n", "    udph = (void *) iph + sizeof (struct iphdr);\n", "    old_eth = data + sizeof (struct iphdr) + sizeof (struct udphdr);\n", "    if (new_eth + 1 > data_end || old_eth + 1 > data_end || iph + 1 > data_end || udph + 1 > data_end) {\n", "        return false;\n", "    }\n", "    memcpy (new_eth->h_dest, cval->mac, sizeof (new_eth->h_dest));\n", "    memcpy (new_eth->h_source, old_eth->h_dest, sizeof (new_eth->h_source));\n", "    new_eth->h_proto = BE_ETH_P_IP;\n", "    create_udp_hdr (udph, sport, GUE_DPORT, pkt_bytes + sizeof (struct udphdr), 0);\n", "    create_v4_hdr (iph, pckt->tos, ipv4_src, dst->dst, pkt_bytes + sizeof (struct udphdr), IPPROTO_UDP);\n", "    __u64 csum = 0;\n", "    if (gue_csum (data, data_end, false, false, pckt, &csum)) {\n", "        udph->check = csum & 0xFFFF;\n", "    }\n", "    return true;\n", "}\n"], "called_function_list": ["create_udp_hdr", "gue_csum", "create_v4_hdr"], "call_depth": 3, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "gue_encap_v6": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "libbpf", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 309, "endLine": 367, "File": "/home/sayandes/opened_extraction/examples/katran/pckt_encap.h", "funcName": "gue_encap_v6", "developer_inline_comments": [], "updateMaps": [], "readMaps": ["  pckt_srcs"], "input": ["struct xdp_md *xdp", " struct ctl_value *cval", " bool is_ipv6", " struct packet_description *pckt", " struct real_definition *dst", " __u32 pkt_bytes"], "output": "staticinlinebool", "helper": ["bpf_map_lookup_elem"], "compatibleHookpoints": ["kprobe", "cgroup_skb", "sk_skb", "cgroup_device", "tracepoint", "socket_filter", "xdp", "raw_tracepoint_writable", "flow_dissector", "lwt_seg6local", "sched_cls", "lwt_out", "sched_act", "cgroup_sysctl", "cgroup_sock_addr", "sk_reuseport", "lwt_xmit", "sock_ops", "perf_event", "raw_tracepoint", "sk_msg", "lwt_in", "cgroup_sock"], "source": ["static inline bool gue_encap_v6 (struct xdp_md *xdp, struct ctl_value *cval, bool is_ipv6, struct packet_description *pckt, struct real_definition *dst, __u32 pkt_bytes)\n", "{\n", "    void *data;\n", "    void *data_end;\n", "    struct ipv6hdr *ip6h;\n", "    struct ethhdr *new_eth;\n", "    struct ethhdr *old_eth;\n", "    struct udphdr *udph;\n", "    __u32 key = V6_SRC_INDEX;\n", "    __u16 payload_len;\n", "    __u16 sport;\n", "    struct real_definition *src;\n", "    src = bpf_map_lookup_elem (& pckt_srcs, & key);\n", "    if (!src) {\n", "        return false;\n", "    }\n", "    if (bpf_xdp_adjust_head (xdp, 0 - ((int) sizeof (struct ipv6hdr) + (int) sizeof (struct udphdr)))) {\n", "        return false;\n", "    }\n", "    data = (void *) (long) xdp->data;\n", "    data_end = (void *) (long) xdp->data_end;\n", "    new_eth = data;\n", "    ip6h = data + sizeof (struct ethhdr);\n", "    udph = (void *) ip6h + sizeof (struct ipv6hdr);\n", "    old_eth = data + sizeof (struct ipv6hdr) + sizeof (struct udphdr);\n", "    if (new_eth + 1 > data_end || old_eth + 1 > data_end || ip6h + 1 > data_end || udph + 1 > data_end) {\n", "        return false;\n", "    }\n", "    memcpy (new_eth->h_dest, cval->mac, 6);\n", "    memcpy (new_eth->h_source, old_eth->h_dest, 6);\n", "    new_eth->h_proto = BE_ETH_P_IPV6;\n", "    if (is_ipv6) {\n", "        sport = (pckt->flow.srcv6[3] & 0xFFFF) ^ pckt->flow.port16[0];\n", "        pkt_bytes += (sizeof (struct ipv6hdr) + sizeof (struct udphdr));\n", "    }\n", "    else {\n", "        sport = ((pckt->flow.src >> 16) & 0xFFFF) ^ pckt->flow.port16[0];\n", "        pkt_bytes += sizeof (struct udphdr);\n", "    }\n", "    create_udp_hdr (udph, sport, GUE_DPORT, pkt_bytes, 0);\n", "    create_v6_hdr (ip6h, pckt->tos, src->dstv6, dst->dstv6, pkt_bytes, IPPROTO_UDP);\n", "    __u64 csum = 0;\n", "    if (gue_csum (data, data_end, true, is_ipv6, pckt, &csum)) {\n", "        udph->check = csum & 0xFFFF;\n", "    }\n", "    return true;\n", "}\n"], "called_function_list": ["create_v6_hdr", "create_udp_hdr", "gue_csum"], "call_depth": 3, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "gue_decap_v4": [{"capabilities": [], "helperCallParams": {}, "startLine": 372, "endLine": 389, "File": "/home/sayandes/opened_extraction/examples/katran/pckt_encap.h", "funcName": "gue_decap_v4", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct xdp_md *xdp", " void **data", " void **data_end"], "output": "staticinlinebool", "helper": [], "compatibleHookpoints": ["kprobe", "cgroup_skb", "sk_skb", "cgroup_device", "tracepoint", "socket_filter", "xdp", "raw_tracepoint_writable", "flow_dissector", "lwt_seg6local", "sched_cls", "lwt_out", "sched_act", "cgroup_sysctl", "cgroup_sock_addr", "sk_reuseport", "lwt_xmit", "sock_ops", "perf_event", "raw_tracepoint", "sk_msg", "lwt_in", "cgroup_sock"], "source": ["static inline bool gue_decap_v4 (struct xdp_md *xdp, void **data, void **data_end)\n", "{\n", "    struct ethhdr *new_eth;\n", "    struct ethhdr *old_eth;\n", "    old_eth = *data;\n", "    new_eth = *data + sizeof (struct iphdr) + sizeof (struct udphdr);\n", "    RECORD_GUE_ROUTE (old_eth, new_eth, *data_end, true, true);\n", "    memcpy (new_eth->h_source, old_eth->h_source, 6);\n", "    memcpy (new_eth->h_dest, old_eth->h_dest, 6);\n", "    new_eth->h_proto = BE_ETH_P_IP;\n", "    if (bpf_xdp_adjust_head (xdp, (int) (sizeof (struct iphdr) + sizeof (struct udphdr)))) {\n", "        return false;\n", "    }\n", "    *data = (void *) (long) xdp->data;\n", "    *data_end = (void *) (long) xdp->data_end;\n", "    return true;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "gue_decap_v6": [{"capabilities": [], "helperCallParams": {}, "startLine": 391, "endLine": 412, "File": "/home/sayandes/opened_extraction/examples/katran/pckt_encap.h", "funcName": "gue_decap_v6", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct xdp_md *xdp", " void **data", " void **data_end", " bool inner_v4"], "output": "staticinlinebool", "helper": [], "compatibleHookpoints": ["kprobe", "cgroup_skb", "sk_skb", "cgroup_device", "tracepoint", "socket_filter", "xdp", "raw_tracepoint_writable", "flow_dissector", "lwt_seg6local", "sched_cls", "lwt_out", "sched_act", "cgroup_sysctl", "cgroup_sock_addr", "sk_reuseport", "lwt_xmit", "sock_ops", "perf_event", "raw_tracepoint", "sk_msg", "lwt_in", "cgroup_sock"], "source": ["static inline bool gue_decap_v6 (struct xdp_md *xdp, void **data, void **data_end, bool inner_v4)\n", "{\n", "    struct ethhdr *new_eth;\n", "    struct ethhdr *old_eth;\n", "    old_eth = *data;\n", "    new_eth = *data + sizeof (struct ipv6hdr) + sizeof (struct udphdr);\n", "    RECORD_GUE_ROUTE (old_eth, new_eth, *data_end, false, inner_v4);\n", "    memcpy (new_eth->h_source, old_eth->h_source, 6);\n", "    memcpy (new_eth->h_dest, old_eth->h_dest, 6);\n", "    if (inner_v4) {\n", "        new_eth->h_proto = BE_ETH_P_IP;\n", "    }\n", "    else {\n", "        new_eth->h_proto = BE_ETH_P_IPV6;\n", "    }\n", "    if (bpf_xdp_adjust_head (xdp, (int) (sizeof (struct ipv6hdr) + sizeof (struct udphdr)))) {\n", "        return false;\n", "    }\n", "    *data = (void *) (long) xdp->data;\n", "    *data_end = (void *) (long) xdp->data_end;\n", "    return true;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "set_hc_key": [{"capabilities": [], "helperCallParams": {}, "startLine": 37, "endLine": 77, "File": "/home/sayandes/opened_extraction/examples/katran/healthchecking_helpers.h", "funcName": "set_hc_key", "developer_inline_comments": [{"start_line": 1, "end_line": 15, "text": "/* Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; version 2 of the License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */"}], "updateMaps": [], "readMaps": [], "input": ["const struct  __sk_buff *skb", " struct hc_key *hckey", " bool is_ipv6"], "output": "staticinlinebool", "helper": [], "compatibleHookpoints": ["kprobe", "cgroup_skb", "sk_skb", "cgroup_device", "tracepoint", "socket_filter", "xdp", "raw_tracepoint_writable", "flow_dissector", "lwt_seg6local", "sched_cls", "lwt_out", "sched_act", "cgroup_sysctl", "cgroup_sock_addr", "sk_reuseport", "lwt_xmit", "sock_ops", "perf_event", "raw_tracepoint", "sk_msg", "lwt_in", "cgroup_sock"], "source": ["static inline bool set_hc_key (const struct  __sk_buff *skb, struct hc_key *hckey, bool is_ipv6)\n", "{\n", "    void *iphdr = (void *) (long) skb->data + sizeof (struct ethhdr);\n", "    void *transport_hdr;\n", "    if (is_ipv6) {\n", "        struct ipv6hdr *ip6h = iphdr;\n", "        if (ip6h + 1 > (void *) (long) skb->data_end) {\n", "            return false;\n", "        }\n", "        transport_hdr = iphdr + sizeof (struct ipv6hdr);\n", "        memcpy (hckey->addrv6, ip6h->daddr.s6_addr32, 16);\n", "        hckey->proto = ip6h->nexthdr;\n", "    }\n", "    else {\n", "        struct iphdr *iph = iphdr;\n", "        if (iph + 1 > (void *) (long) skb->data_end) {\n", "            return false;\n", "        }\n", "        transport_hdr = iphdr + sizeof (struct iphdr);\n", "        hckey->addr = iph->daddr;\n", "        hckey->proto = iph->protocol;\n", "    }\n", "    if (hckey->proto == IPPROTO_TCP) {\n", "        struct tcphdr *tcp = transport_hdr;\n", "        if (tcp + 1 > (void *) (long) skb->data_end) {\n", "            return false;\n", "        }\n", "        hckey->port = tcp->dest;\n", "    }\n", "    else if (hckey->proto == IPPROTO_UDP) {\n", "        struct udphdr *udp = transport_hdr;\n", "        if (udp + 1 > (void *) (long) skb->data_end) {\n", "            return false;\n", "        }\n", "        hckey->port = udp->dest;\n", "    }\n", "    else {\n", "        return false;\n", "    }\n", "    return true;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "hc_encap_ipip": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "libbpf", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 79, "endLine": 139, "File": "/home/sayandes/opened_extraction/examples/katran/healthchecking_helpers.h", "funcName": "hc_encap_ipip", "developer_inline_comments": [{"start_line": 23, "end_line": 23, "text": "// new header would be inserted after MAC but before old L3 header"}, {"start_line": 48, "end_line": 48, "text": "// new header would be inserted after MAC but before old L3 header"}], "updateMaps": [], "readMaps": ["  hc_pckt_srcs_map"], "input": ["struct  __sk_buff *skb", " struct hc_real_definition *real", " struct ethhdr *ethh", " bool is_ipv6"], "output": "staticinlinebool", "helper": ["bpf_map_lookup_elem"], "compatibleHookpoints": ["kprobe", "cgroup_skb", "sk_skb", "cgroup_device", "tracepoint", "socket_filter", "xdp", "raw_tracepoint_writable", "flow_dissector", "lwt_seg6local", "sched_cls", "lwt_out", "sched_act", "cgroup_sysctl", "cgroup_sock_addr", "sk_reuseport", "lwt_xmit", "sock_ops", "perf_event", "raw_tracepoint", "sk_msg", "lwt_in", "cgroup_sock"], "source": ["static inline bool hc_encap_ipip (struct  __sk_buff *skb, struct hc_real_definition *real, struct ethhdr *ethh, bool is_ipv6)\n", "{\n", "    struct hc_real_definition *src;\n", "    __u64 flags = 0;\n", "    __u16 pkt_len;\n", "    int adjust_len;\n", "    __u32 key;\n", "    pkt_len = skb->len - sizeof (struct ethhdr);\n", "    if (real->flags == V6DADDR) {\n", "        __u8 proto = IPPROTO_IPV6;\n", "        key = V6_SRC_INDEX;\n", "        src = bpf_map_lookup_elem (& hc_pckt_srcs_map, & key);\n", "        if (!src) {\n", "            return false;\n", "        }\n", "        flags |= BPF_F_ADJ_ROOM_FIXED_GSO | BPF_F_ADJ_ROOM_ENCAP_L3_IPV6;\n", "        adjust_len = sizeof (struct ipv6hdr);\n", "        if (bpf_skb_adjust_room (skb, adjust_len, BPF_ADJ_ROOM_MAC, flags)) {\n", "            return false;\n", "        }\n", "        if ((skb->data + sizeof (struct ethhdr) + sizeof (struct ipv6hdr)) > skb->data_end) {\n", "            return false;\n", "        }\n", "        ethh = (void *) (long) skb->data;\n", "        ethh->h_proto = BE_ETH_P_IPV6;\n", "        struct ipv6hdr *ip6h = (void *) (long) skb->data + sizeof (struct ethhdr);\n", "        if (!is_ipv6) {\n", "            proto = IPPROTO_IPIP;\n", "        }\n", "        create_v6_hdr (ip6h, DEFAULT_TOS, src->v6daddr, real->v6daddr, pkt_len, proto);\n", "    }\n", "    else {\n", "        key = V4_SRC_INDEX;\n", "        src = bpf_map_lookup_elem (& hc_pckt_srcs_map, & key);\n", "        if (!src) {\n", "            return false;\n", "        }\n", "        flags |= BPF_F_ADJ_ROOM_FIXED_GSO | BPF_F_ADJ_ROOM_ENCAP_L3_IPV4;\n", "        adjust_len = sizeof (struct iphdr);\n", "        if (bpf_skb_adjust_room (skb, adjust_len, BPF_ADJ_ROOM_MAC, flags)) {\n", "            return false;\n", "        }\n", "        if ((skb->data + sizeof (struct ethhdr) + sizeof (struct iphdr)) > skb->data_end) {\n", "            return false;\n", "        }\n", "        struct iphdr *iph = (void *) (long) skb->data + sizeof (struct ethhdr);\n", "        create_v4_hdr (iph, DEFAULT_TOS, src->daddr, real->daddr, pkt_len, IPPROTO_IPIP);\n", "    }\n", "    return true;\n", "}\n"], "called_function_list": ["create_v4_hdr", "create_v6_hdr"], "call_depth": 3, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "gue_sport": [{"capabilities": [], "helperCallParams": {}, "startLine": 141, "endLine": 143, "File": "/home/sayandes/opened_extraction/examples/katran/healthchecking_helpers.h", "funcName": "gue_sport", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["__u32 seed"], "output": "staticinline__u16", "helper": [], "compatibleHookpoints": ["kprobe", "cgroup_skb", "sk_skb", "cgroup_device", "tracepoint", "socket_filter", "xdp", "raw_tracepoint_writable", "flow_dissector", "lwt_seg6local", "sched_cls", "lwt_out", "sched_act", "cgroup_sysctl", "cgroup_sock_addr", "sk_reuseport", "lwt_xmit", "sock_ops", "perf_event", "raw_tracepoint", "sk_msg", "lwt_in", "cgroup_sock"], "source": ["static inline __u16 gue_sport (__u32 seed)\n", "{\n", "    return (__u16) ((seed ^ (seed >> 16)) & 0xFFFF);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "hc_encap_gue": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "libbpf", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 145, "endLine": 213, "File": "/home/sayandes/opened_extraction/examples/katran/healthchecking_helpers.h", "funcName": "hc_encap_gue", "developer_inline_comments": [{"start_line": 26, "end_line": 26, "text": "// new headers would be inserted after MAC but before old L3 header"}, {"start_line": 53, "end_line": 53, "text": "// new headers would be inserted after MAC but before old L3 header"}], "updateMaps": [], "readMaps": ["  hc_pckt_srcs_map"], "input": ["struct  __sk_buff *skb", " struct hc_real_definition *real", " struct ethhdr *ethh", " bool is_ipv6"], "output": "staticinlinebool", "helper": ["bpf_map_lookup_elem"], "compatibleHookpoints": ["kprobe", "cgroup_skb", "sk_skb", "cgroup_device", "tracepoint", "socket_filter", "xdp", "raw_tracepoint_writable", "flow_dissector", "lwt_seg6local", "sched_cls", "lwt_out", "sched_act", "cgroup_sysctl", "cgroup_sock_addr", "sk_reuseport", "lwt_xmit", "sock_ops", "perf_event", "raw_tracepoint", "sk_msg", "lwt_in", "cgroup_sock"], "source": ["static inline bool hc_encap_gue (struct  __sk_buff *skb, struct hc_real_definition *real, struct ethhdr *ethh, bool is_ipv6)\n", "{\n", "    struct hc_real_definition *src;\n", "    __u64 flags = 0;\n", "    __u16 pkt_len;\n", "    __u16 sport;\n", "    int adjust_len;\n", "    __u32 key;\n", "    pkt_len = skb->len - sizeof (struct ethhdr);\n", "    if (real->flags == V6DADDR) {\n", "        sport = gue_sport (real -> v6daddr [0] | real -> v6daddr [3]);\n", "        __u8 proto = IPPROTO_IPV6;\n", "        key = V6_SRC_INDEX;\n", "        src = bpf_map_lookup_elem (& hc_pckt_srcs_map, & key);\n", "        if (!src) {\n", "            return false;\n", "        }\n", "        flags |= BPF_F_ADJ_ROOM_FIXED_GSO | BPF_F_ADJ_ROOM_ENCAP_L3_IPV6 | BPF_F_ADJ_ROOM_ENCAP_L4_UDP;\n", "        adjust_len = sizeof (struct ipv6hdr) + sizeof (struct udphdr);\n", "        if (bpf_skb_adjust_room (skb, adjust_len, BPF_ADJ_ROOM_MAC, flags)) {\n", "            return false;\n", "        }\n", "        if ((skb->data + sizeof (struct ethhdr) + sizeof (struct ipv6hdr) + sizeof (struct udphdr)) > skb->data_end) {\n", "            return false;\n", "        }\n", "        ethh = (void *) (long) skb->data;\n", "        ethh->h_proto = BE_ETH_P_IPV6;\n", "        struct ipv6hdr *ip6h = (void *) (long) skb->data + sizeof (struct ethhdr);\n", "        struct udphdr *udph = (void *) ip6h + sizeof (struct ipv6hdr);\n", "        pkt_len += sizeof (struct udphdr);\n", "        create_udp_hdr (udph, sport, GUE_DPORT, pkt_len, GUE_CSUM);\n", "        create_v6_hdr (ip6h, DEFAULT_TOS, src->v6daddr, real->v6daddr, pkt_len, IPPROTO_UDP);\n", "    }\n", "    else {\n", "        sport = gue_sport (real -> daddr);\n", "        key = V4_SRC_INDEX;\n", "        src = bpf_map_lookup_elem (& hc_pckt_srcs_map, & key);\n", "        if (!src) {\n", "            return false;\n", "        }\n", "        flags |= BPF_F_ADJ_ROOM_FIXED_GSO | BPF_F_ADJ_ROOM_ENCAP_L3_IPV4 | BPF_F_ADJ_ROOM_ENCAP_L4_UDP;\n", "        adjust_len = sizeof (struct iphdr) + sizeof (struct udphdr);\n", "        if (bpf_skb_adjust_room (skb, adjust_len, BPF_ADJ_ROOM_MAC, flags)) {\n", "            return false;\n", "        }\n", "        if ((skb->data + sizeof (struct ethhdr) + sizeof (struct iphdr) + sizeof (struct udphdr)) > skb->data_end) {\n", "            return false;\n", "        }\n", "        struct iphdr *iph = (void *) (long) skb->data + sizeof (struct ethhdr);\n", "        struct udphdr *udph = (void *) iph + sizeof (struct iphdr);\n", "        pkt_len += sizeof (struct udphdr);\n", "        create_udp_hdr (udph, sport, GUE_DPORT, pkt_len, GUE_CSUM);\n", "        create_v4_hdr (iph, DEFAULT_TOS, src->daddr, real->daddr, pkt_len, IPPROTO_UDP);\n", "    }\n", "    return true;\n", "}\n"], "called_function_list": ["create_v4_hdr", "gue_sport", "create_udp_hdr", "create_v6_hdr"], "call_depth": 3, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "create_v4_hdr": [{"capabilities": [], "helperCallParams": {}, "startLine": 31, "endLine": 55, "File": "/home/sayandes/opened_extraction/examples/katran/encap_helpers.h", "funcName": "create_v4_hdr", "developer_inline_comments": [{"start_line": 1, "end_line": 15, "text": "/* Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved,\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; version 2 of the License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */"}], "updateMaps": [], "readMaps": [], "input": ["struct iphdr *iph", " __u8 tos", " __u32 saddr", " __u32 daddr", " __u16 pkt_bytes", " __u8 proto"], "output": "staticinlinevoid", "helper": [], "compatibleHookpoints": ["kprobe", "cgroup_skb", "sk_skb", "cgroup_device", "tracepoint", "socket_filter", "xdp", "raw_tracepoint_writable", "flow_dissector", "lwt_seg6local", "sched_cls", "lwt_out", "sched_act", "cgroup_sysctl", "cgroup_sock_addr", "sk_reuseport", "lwt_xmit", "sock_ops", "perf_event", "raw_tracepoint", "sk_msg", "lwt_in", "cgroup_sock"], "source": ["static inline void create_v4_hdr (struct iphdr *iph, __u8 tos, __u32 saddr, __u32 daddr, __u16 pkt_bytes, __u8 proto)\n", "{\n", "    __u64 csum = 0;\n", "    iph->version = 4;\n", "    iph->ihl = 5;\n", "    iph->frag_off = 0;\n", "    iph->protocol = proto;\n", "    iph->check = 0;\n", "\n", "#ifdef COPY_INNER_PACKET_TOS\n", "    iph->tos = tos;\n", "\n", "#else\n", "    iph->tos = DEFAULT_TOS;\n", "\n", "#endif\n", "    iph->tot_len = bpf_htons (pkt_bytes + sizeof (struct iphdr));\n", "    iph->daddr = daddr;\n", "    iph->saddr = saddr;\n", "    iph->ttl = DEFAULT_TTL;\n", "    ipv4_csum_inline (iph, &csum);\n", "    iph->check = csum;\n", "}\n"], "called_function_list": ["ipv4_csum_inline"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "create_v6_hdr": [{"capabilities": [], "helperCallParams": {}, "startLine": 57, "endLine": 77, "File": "/home/sayandes/opened_extraction/examples/katran/encap_helpers.h", "funcName": "create_v6_hdr", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct ipv6hdr *ip6h", " __u8 tc", " __u32 *saddr", " __u32 *daddr", " __u16 payload_len", " __u8 proto"], "output": "staticinlinevoid", "helper": [], "compatibleHookpoints": ["kprobe", "cgroup_skb", "sk_skb", "cgroup_device", "tracepoint", "socket_filter", "xdp", "raw_tracepoint_writable", "flow_dissector", "lwt_seg6local", "sched_cls", "lwt_out", "sched_act", "cgroup_sysctl", "cgroup_sock_addr", "sk_reuseport", "lwt_xmit", "sock_ops", "perf_event", "raw_tracepoint", "sk_msg", "lwt_in", "cgroup_sock"], "source": ["static inline void create_v6_hdr (struct ipv6hdr *ip6h, __u8 tc, __u32 *saddr, __u32 *daddr, __u16 payload_len, __u8 proto)\n", "{\n", "    ip6h->version = 6;\n", "    memset (ip6h->flow_lbl, 0, sizeof (ip6h->flow_lbl));\n", "\n", "#ifdef COPY_INNER_PACKET_TOS\n", "    ip6h->priority = (tc & 0xF0) >> 4;\n", "    ip6h->flow_lbl[0] = (tc & 0x0F) << 4;\n", "\n", "#else\n", "    ip6h->priority = DEFAULT_TOS;\n", "\n", "#endif\n", "    ip6h->nexthdr = proto;\n", "    ip6h->payload_len = bpf_htons (payload_len);\n", "    ip6h->hop_limit = DEFAULT_TTL;\n", "    memcpy (ip6h->saddr.s6_addr32, saddr, 16);\n", "    memcpy (ip6h->daddr.s6_addr32, daddr, 16);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "create_udp_hdr": [{"capabilities": [], "helperCallParams": {}, "startLine": 79, "endLine": 89, "File": "/home/sayandes/opened_extraction/examples/katran/encap_helpers.h", "funcName": "create_udp_hdr", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct udphdr *udph", " __u16 sport", " __u16 dport", " __u16 len", " __u16 csum"], "output": "staticinlinevoid", "helper": [], "compatibleHookpoints": ["kprobe", "cgroup_skb", "sk_skb", "cgroup_device", "tracepoint", "socket_filter", "xdp", "raw_tracepoint_writable", "flow_dissector", "lwt_seg6local", "sched_cls", "lwt_out", "sched_act", "cgroup_sysctl", "cgroup_sock_addr", "sk_reuseport", "lwt_xmit", "sock_ops", "perf_event", "raw_tracepoint", "sk_msg", "lwt_in", "cgroup_sock"], "source": ["static inline void create_udp_hdr (struct udphdr *udph, __u16 sport, __u16 dport, __u16 len, __u16 csum)\n", "{\n", "    udph->source = sport;\n", "    udph->dest = bpf_htons (dport);\n", "    udph->len = bpf_htons (len);\n", "    udph->check = csum;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "rol32": [{"capabilities": [], "helperCallParams": {}, "startLine": 7, "endLine": 9, "File": "/home/sayandes/opened_extraction/examples/katran/jhash.h", "funcName": "rol32", "developer_inline_comments": [{"start_line": 3, "end_line": 5, "text": "/* copy paste of jhash from kernel sources to make sure llvm\n * can compile it into valid sequence of bpf instructions\n */"}], "updateMaps": [], "readMaps": [], "input": ["__u32 word", " unsigned int shift"], "output": "staticinline__u32", "helper": [], "compatibleHookpoints": ["kprobe", "cgroup_skb", "sk_skb", "cgroup_device", "tracepoint", "socket_filter", "xdp", "raw_tracepoint_writable", "flow_dissector", "lwt_seg6local", "sched_cls", "lwt_out", "sched_act", "cgroup_sysctl", "cgroup_sock_addr", "sk_reuseport", "lwt_xmit", "sock_ops", "perf_event", "raw_tracepoint", "sk_msg", "lwt_in", "cgroup_sock"], "source": ["static inline __u32 rol32 (__u32 word, unsigned int shift)\n", "{\n", "    return (word << shift) | (word >> ((-shift) & 31));\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "jhash": [{"capabilities": [], "helperCallParams": {}, "startLine": 55, "endLine": 100, "File": "/home/sayandes/opened_extraction/examples/katran/jhash.h", "funcName": "jhash", "developer_inline_comments": [{"start_line": 85, "end_line": 85, "text": "/* Nothing left to add */"}], "updateMaps": [], "readMaps": [], "input": ["const void *key", " u32 length", " u32 initval"], "output": "staticinlineu32", "helper": [], "compatibleHookpoints": ["kprobe", "cgroup_skb", "sk_skb", "cgroup_device", "tracepoint", "socket_filter", "xdp", "raw_tracepoint_writable", "flow_dissector", "lwt_seg6local", "sched_cls", "lwt_out", "sched_act", "cgroup_sysctl", "cgroup_sock_addr", "sk_reuseport", "lwt_xmit", "sock_ops", "perf_event", "raw_tracepoint", "sk_msg", "lwt_in", "cgroup_sock"], "source": ["static inline u32 jhash (const void *key, u32 length, u32 initval)\n", "{\n", "    u32 a, b, c;\n", "    const unsigned char *k = key;\n", "    a = b = c = JHASH_INITVAL + length + initval;\n", "    while (length > 12) {\n", "        a += *(u32*) (k);\n", "        b += *(u32*) (k + 4);\n", "        c += *(u32*) (k + 8);\n", "        __jhash_mix (a, b, c);\n", "        length -= 12;\n", "        k += 12;\n", "    }\n", "    switch (length) {\n", "    case 12 :\n", "        c += (u32) k[11] << 24;\n", "    case 11 :\n", "        c += (u32) k[10] << 16;\n", "    case 10 :\n", "        c += (u32) k[9] << 8;\n", "    case 9 :\n", "        c += k[8];\n", "    case 8 :\n", "        b += (u32) k[7] << 24;\n", "    case 7 :\n", "        b += (u32) k[6] << 16;\n", "    case 6 :\n", "        b += (u32) k[5] << 8;\n", "    case 5 :\n", "        b += k[4];\n", "    case 4 :\n", "        a += (u32) k[3] << 24;\n", "    case 3 :\n", "        a += (u32) k[2] << 16;\n", "    case 2 :\n", "        a += (u32) k[1] << 8;\n", "    case 1 :\n", "        a += k[0];\n", "        __jhash_final (a, b, c);\n", "    case 0 :\n", "        break;\n", "    }\n", "    return c;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__jhash_nwords": [{"capabilities": [], "helperCallParams": {}, "startLine": 102, "endLine": 108, "File": "/home/sayandes/opened_extraction/examples/katran/jhash.h", "funcName": "__jhash_nwords", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["u32 a", " u32 b", " u32 c", " u32 initval"], "output": "staticinlineu32", "helper": [], "compatibleHookpoints": ["kprobe", "cgroup_skb", "sk_skb", "cgroup_device", "tracepoint", "socket_filter", "xdp", "raw_tracepoint_writable", "flow_dissector", "lwt_seg6local", "sched_cls", "lwt_out", "sched_act", "cgroup_sysctl", "cgroup_sock_addr", "sk_reuseport", "lwt_xmit", "sock_ops", "perf_event", "raw_tracepoint", "sk_msg", "lwt_in", "cgroup_sock"], "source": ["static inline u32 __jhash_nwords (u32 a, u32 b, u32 c, u32 initval)\n", "{\n", "    a += initval;\n", "    b += initval;\n", "    c += initval;\n", "    __jhash_final (a, b, c);\n", "    return c;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "jhash_2words": [{"capabilities": [], "helperCallParams": {}, "startLine": 110, "endLine": 112, "File": "/home/sayandes/opened_extraction/examples/katran/jhash.h", "funcName": "jhash_2words", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["u32 a", " u32 b", " u32 initval"], "output": "staticinlineu32", "helper": [], "compatibleHookpoints": ["kprobe", "cgroup_skb", "sk_skb", "cgroup_device", "tracepoint", "socket_filter", "xdp", "raw_tracepoint_writable", "flow_dissector", "lwt_seg6local", "sched_cls", "lwt_out", "sched_act", "cgroup_sysctl", "cgroup_sock_addr", "sk_reuseport", "lwt_xmit", "sock_ops", "perf_event", "raw_tracepoint", "sk_msg", "lwt_in", "cgroup_sock"], "source": ["static inline u32 jhash_2words (u32 a, u32 b, u32 initval)\n", "{\n", "    return __jhash_nwords (a, b, 0, initval + JHASH_INITVAL + (2 << 2));\n", "}\n"], "called_function_list": ["__jhash_nwords"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "jhash_1word": [{"capabilities": [], "helperCallParams": {}, "startLine": 114, "endLine": 116, "File": "/home/sayandes/opened_extraction/examples/katran/jhash.h", "funcName": "jhash_1word", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["u32 a", " u32 initval"], "output": "staticinlineu32", "helper": [], "compatibleHookpoints": ["kprobe", "cgroup_skb", "sk_skb", "cgroup_device", "tracepoint", "socket_filter", "xdp", "raw_tracepoint_writable", "flow_dissector", "lwt_seg6local", "sched_cls", "lwt_out", "sched_act", "cgroup_sysctl", "cgroup_sock_addr", "sk_reuseport", "lwt_xmit", "sock_ops", "perf_event", "raw_tracepoint", "sk_msg", "lwt_in", "cgroup_sock"], "source": ["static inline u32 jhash_1word (u32 a, u32 initval)\n", "{\n", "    return __jhash_nwords (a, 0, 0, initval + JHASH_INITVAL + (1 << 2));\n", "}\n"], "called_function_list": ["__jhash_nwords"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "submit_event": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "libbpf", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 46, "endLine": 70, "File": "/home/sayandes/opened_extraction/examples/katran/balancer_helpers.h", "funcName": "submit_event", "developer_inline_comments": [{"start_line": 1, "end_line": 15, "text": "/* Copyright (C) 2018-present, Facebook, Inc.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; version 2 of the License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */"}, {"start_line": 19, "end_line": 21, "text": "/*\n * This file contains common used routines. such as csum helpers etc\n */"}, {"start_line": 43, "end_line": 45, "text": "/**\n * helper to print blob of data into perf pipe\n */"}], "updateMaps": [], "readMaps": ["  ctl_array"], "input": ["struct xdp_md *ctx", " void *map", " __u32 event_id", " void *data", " __u32 size", " bool metadata_only"], "output": "staticinlinevoid", "helper": ["bpf_map_lookup_elem", "bpf_perf_event_output"], "compatibleHookpoints": ["sock_ops", "lwt_out", "sched_act", "raw_tracepoint_writable", "perf_event", "raw_tracepoint", "lwt_in", "kprobe", "cgroup_skb", "sk_skb", "sched_cls", "tracepoint", "lwt_seg6local", "xdp", "socket_filter", "lwt_xmit"], "source": ["static inline void submit_event (struct xdp_md *ctx, void *map, __u32 event_id, void *data, __u32 size, bool metadata_only)\n", "{\n", "    struct ctl_value *gk;\n", "    __u32 introspection_gk_pos = 5;\n", "    gk = bpf_map_lookup_elem (& ctl_array, & introspection_gk_pos);\n", "    if (!gk || gk->value == 0) {\n", "        return;\n", "    }\n", "    struct event_metadata md = {}\n", "    ;\n", "    __u64 flags = BPF_F_CURRENT_CPU;\n", "    md.event = event_id;\n", "    md.pkt_size = size;\n", "    if (metadata_only) {\n", "        md.data_len = 0;\n", "    }\n", "    else {\n", "        md.data_len = min_helper (size, MAX_EVENT_SIZE);\n", "        flags |= (__u64) md.data_len << 32;\n", "    }\n", "    bpf_perf_event_output (ctx, map, flags, &md, sizeof (struct event_metadata));\n", "}\n"], "called_function_list": ["min_helper"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "recirculate": [{"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_PASS", "Return": 2, "Description": "The XDP_PASS return code means that the packet is allowed to be passed up to the kernel\u2019s networking stack. Meaning, the current CPU that was processing this packet now allocates a skb, populates it, and passes it onwards into the GRO engine. This would be equivalent to the default packet handling behavior without XDP.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 74, "endLine": 80, "File": "/home/sayandes/opened_extraction/examples/katran/balancer_helpers.h", "funcName": "recirculate", "developer_inline_comments": [{"start_line": 7, "end_line": 7, "text": "// we should never hit this"}], "updateMaps": [], "readMaps": [], "input": ["struct xdp_md *ctx"], "output": "staticinlineint", "helper": ["XDP_PASS", "bpf_tail_call"], "compatibleHookpoints": ["xdp"], "source": ["static inline int recirculate (struct xdp_md *ctx)\n", "{\n", "    int i = RECIRCULATION_INDEX;\n", "    bpf_tail_call (ctx, &subprograms, i);\n", "    return XDP_PASS;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "decrement_ttl": [{"capabilities": [{"capability": "pkt_stop_processing_drop_packet", "pkt_stop_processing_drop_packet": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_DROP", "Return": 1, "Description": "will drop the packet right at the driver level without wasting any further resources. This is in particular useful for BPF programs implementing DDoS mitigation mechanisms or firewalling in general.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_stop_processing_drop_packet"]}]}], "helperCallParams": {}, "startLine": 83, "endLine": 111, "File": "/home/sayandes/opened_extraction/examples/katran/balancer_helpers.h", "funcName": "decrement_ttl", "developer_inline_comments": [{"start_line": 13, "end_line": 13, "text": "// ttl 0"}, {"start_line": 23, "end_line": 23, "text": "// ttl 0"}], "updateMaps": [], "readMaps": [], "input": ["void *data", " void *data_end", " int offset", " bool is_ipv6"], "output": "staticinlineint", "helper": ["XDP_DROP"], "compatibleHookpoints": ["xdp"], "source": ["static inline int decrement_ttl (void *data, void *data_end, int offset, bool is_ipv6)\n", "{\n", "    struct iphdr *iph;\n", "    struct ipv6hdr *ip6h;\n", "    if (is_ipv6) {\n", "        if ((data + offset + sizeof (struct ipv6hdr)) > data_end) {\n", "            return XDP_DROP;\n", "        }\n", "        ip6h = (struct ipv6hdr *) (data + offset);\n", "        if (!--ip6h->hop_limit) {\n", "            return XDP_DROP;\n", "        }\n", "    }\n", "    else {\n", "        if ((data + offset + sizeof (struct iphdr)) > data_end) {\n", "            return XDP_DROP;\n", "        }\n", "        iph = (struct iphdr *) (data + offset);\n", "        __u32 csum;\n", "        if (!--iph->ttl) {\n", "            return XDP_DROP;\n", "        }\n", "        csum = iph->check + 0x0001;\n", "        iph->check = (csum & 0xffff) + (csum >> 16);\n", "    }\n", "    return FURTHER_PROCESSING;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "calc_offset": [{"capabilities": [], "helperCallParams": {}, "startLine": 58, "endLine": 74, "File": "/home/sayandes/opened_extraction/examples/katran/pckt_parsing.h", "funcName": "calc_offset", "developer_inline_comments": [{"start_line": 1, "end_line": 15, "text": "/* Copyright (C) 2018-present, Facebook, Inc.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; version 2 of the License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */"}, {"start_line": 20, "end_line": 23, "text": "/*\n * This file contains generic packet parsing routines (e.g. tcp/udp headers\n * parsing etc)\n */"}, {"start_line": 44, "end_line": 44, "text": "// Pre draft-22: Dest Conn Id Len(4 bits) | Source Conn Id Len(4 bits)"}, {"start_line": 45, "end_line": 45, "text": "// Post draft-22: Dest Conn Id Len (8 bits)"}, {"start_line": 47, "end_line": 47, "text": "// conn-id len can be of either 0 bytes in length or between 4 and 18 bytes"}, {"start_line": 48, "end_line": 48, "text": "// For routing, katran requires minimum of 'QUIC_MIN_CONNID_LEN',"}, {"start_line": 49, "end_line": 49, "text": "// and doesn't read beyond that"}], "updateMaps": [], "readMaps": [], "input": ["bool is_ipv6", " bool is_icmp"], "output": "staticinline__u64", "helper": [], "compatibleHookpoints": ["kprobe", "cgroup_skb", "sk_skb", "cgroup_device", "tracepoint", "socket_filter", "xdp", "raw_tracepoint_writable", "flow_dissector", "lwt_seg6local", "sched_cls", "lwt_out", "sched_act", "cgroup_sysctl", "cgroup_sock_addr", "sk_reuseport", "lwt_xmit", "sock_ops", "perf_event", "raw_tracepoint", "sk_msg", "lwt_in", "cgroup_sock"], "source": ["static inline __u64 calc_offset (bool is_ipv6, bool is_icmp)\n", "{\n", "    __u64 off = sizeof (struct ethhdr);\n", "    if (is_ipv6) {\n", "        off += sizeof (struct ipv6hdr);\n", "        if (is_icmp) {\n", "            off += (sizeof (struct icmp6hdr) + sizeof (struct ipv6hdr));\n", "        }\n", "    }\n", "    else {\n", "        off += sizeof (struct iphdr);\n", "        if (is_icmp) {\n", "            off += (sizeof (struct icmphdr) + sizeof (struct iphdr));\n", "        }\n", "    }\n", "    return off;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "parse_udp": [{"capabilities": [], "helperCallParams": {}, "startLine": 76, "endLine": 100, "File": "/home/sayandes/opened_extraction/examples/katran/pckt_parsing.h", "funcName": "parse_udp", "developer_inline_comments": [{"start_line": 19, "end_line": 19, "text": "// packet_description was created from icmp \"packet too big\". hence"}, {"start_line": 20, "end_line": 20, "text": "// we need to invert src/dst ports"}], "updateMaps": [], "readMaps": [], "input": ["void *data", " void *data_end", " bool is_ipv6", " struct packet_description *pckt"], "output": "staticinlinebool", "helper": [], "compatibleHookpoints": ["kprobe", "cgroup_skb", "sk_skb", "cgroup_device", "tracepoint", "socket_filter", "xdp", "raw_tracepoint_writable", "flow_dissector", "lwt_seg6local", "sched_cls", "lwt_out", "sched_act", "cgroup_sysctl", "cgroup_sock_addr", "sk_reuseport", "lwt_xmit", "sock_ops", "perf_event", "raw_tracepoint", "sk_msg", "lwt_in", "cgroup_sock"], "source": ["static inline bool parse_udp (void *data, void *data_end, bool is_ipv6, struct packet_description *pckt)\n", "{\n", "    bool is_icmp = !((pckt->flags & F_ICMP) == 0);\n", "    __u64 off = calc_offset (is_ipv6, is_icmp);\n", "    struct udphdr *udp;\n", "    udp = data + off;\n", "    if (udp + 1 > data_end) {\n", "        return false;\n", "    }\n", "    if (!is_icmp) {\n", "        pckt->flow.port16[0] = udp->source;\n", "        pckt->flow.port16[1] = udp->dest;\n", "    }\n", "    else {\n", "        pckt->flow.port16[0] = udp->dest;\n", "        pckt->flow.port16[1] = udp->source;\n", "    }\n", "    return true;\n", "}\n"], "called_function_list": ["calc_offset"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "parse_tcp": [{"capabilities": [], "helperCallParams": {}, "startLine": 102, "endLine": 130, "File": "/home/sayandes/opened_extraction/examples/katran/pckt_parsing.h", "funcName": "parse_tcp", "developer_inline_comments": [{"start_line": 23, "end_line": 23, "text": "// packet_description was created from icmp \"packet too big\". hence"}, {"start_line": 24, "end_line": 24, "text": "// we need to invert src/dst ports"}], "updateMaps": [], "readMaps": [], "input": ["void *data", " void *data_end", " bool is_ipv6", " struct packet_description *pckt"], "output": "staticinlinebool", "helper": [], "compatibleHookpoints": ["kprobe", "cgroup_skb", "sk_skb", "cgroup_device", "tracepoint", "socket_filter", "xdp", "raw_tracepoint_writable", "flow_dissector", "lwt_seg6local", "sched_cls", "lwt_out", "sched_act", "cgroup_sysctl", "cgroup_sock_addr", "sk_reuseport", "lwt_xmit", "sock_ops", "perf_event", "raw_tracepoint", "sk_msg", "lwt_in", "cgroup_sock"], "source": ["static inline bool parse_tcp (void *data, void *data_end, bool is_ipv6, struct packet_description *pckt)\n", "{\n", "    bool is_icmp = !((pckt->flags & F_ICMP) == 0);\n", "    __u64 off = calc_offset (is_ipv6, is_icmp);\n", "    struct tcphdr *tcp;\n", "    tcp = data + off;\n", "    if (tcp + 1 > data_end) {\n", "        return false;\n", "    }\n", "    if (tcp->syn) {\n", "        pckt->flags |= F_SYN_SET;\n", "    }\n", "    if (!is_icmp) {\n", "        pckt->flow.port16[0] = tcp->source;\n", "        pckt->flow.port16[1] = tcp->dest;\n", "    }\n", "    else {\n", "        pckt->flow.port16[0] = tcp->dest;\n", "        pckt->flow.port16[1] = tcp->source;\n", "    }\n", "    return true;\n", "}\n"], "called_function_list": ["calc_offset"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "parse_hdr_opt": [{"capabilities": [], "helperCallParams": {}, "startLine": 144, "endLine": 197, "File": "/home/sayandes/opened_extraction/examples/katran/pckt_parsing.h", "funcName": "parse_hdr_opt", "developer_inline_comments": [{"start_line": 19, "end_line": 19, "text": "// Need this check to satisify the verifier"}], "updateMaps": [], "readMaps": [], "input": ["const struct xdp_md *xdp", " struct hdr_opt_state *state"], "output": "int", "helper": [], "compatibleHookpoints": ["kprobe", "cgroup_skb", "sk_skb", "cgroup_device", "tracepoint", "socket_filter", "xdp", "raw_tracepoint_writable", "flow_dissector", "lwt_seg6local", "sched_cls", "lwt_out", "sched_act", "cgroup_sysctl", "cgroup_sock_addr", "sk_reuseport", "lwt_xmit", "sock_ops", "perf_event", "raw_tracepoint", "sk_msg", "lwt_in", "cgroup_sock"], "source": ["int parse_hdr_opt (const struct xdp_md *xdp, struct hdr_opt_state *state)\n", "{\n", "    const void *data = (void *) (long) xdp->data;\n", "    const void *data_end = (void *) (long) xdp->data_end;\n", "    __u8 *tcp_opt, kind, hdr_len;\n", "    if (!state) {\n", "        return -1;\n", "    }\n", "    tcp_opt = (__u8 *) (data + state->byte_offset);\n", "    if (tcp_opt + 1 > data_end) {\n", "        return -1;\n", "    }\n", "    kind = tcp_opt[0];\n", "    if (kind == TCP_OPT_EOL) {\n", "        return -1;\n", "    }\n", "    if (kind == TCP_OPT_NOP) {\n", "        state->hdr_bytes_remaining--;\n", "        state->byte_offset++;\n", "        return 0;\n", "    }\n", "    if (state->hdr_bytes_remaining < 2 || tcp_opt + sizeof (__u8) + sizeof (__u8) > data_end) {\n", "        return -1;\n", "    }\n", "    hdr_len = tcp_opt[1];\n", "    if (hdr_len > state->hdr_bytes_remaining) {\n", "        return -1;\n", "    }\n", "    if (kind == TCP_HDR_OPT_KIND_TPR) {\n", "        if (hdr_len != TCP_HDR_OPT_LEN_TPR) {\n", "            return -1;\n", "        }\n", "        if (tcp_opt + TCP_HDR_OPT_LEN_TPR > data_end) {\n", "            return -1;\n", "        }\n", "        state->server_id = *(__u32*) &tcp_opt[2];\n", "        return 1;\n", "    }\n", "    state->hdr_bytes_remaining -= hdr_len;\n", "    state->byte_offset += hdr_len;\n", "    return 0;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "tcp_hdr_opt_lookup": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "libbpf", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}, {"capability": "map_update", "map_update": [{"Project": "libbpf", "Return Type": "int", "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_map_update_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}", "{Type:  const void ,Var: *value}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_update"]}]}], "helperCallParams": {}, "startLine": 199, "endLine": 273, "File": "/home/sayandes/opened_extraction/examples/katran/pckt_parsing.h", "funcName": "tcp_hdr_opt_lookup", "developer_inline_comments": [{"start_line": 17, "end_line": 17, "text": "/* is_icmp */"}, {"start_line": 31, "end_line": 31, "text": "// For linux kernel version < 5.3, there isn't support in the bpf verifier"}, {"start_line": 32, "end_line": 32, "text": "// for validating bounded loops, so we need to unroll the loop"}, {"start_line": 53, "end_line": 53, "text": "// Since server_id_map is a bpf_map_array all its members are 0-initialized"}, {"start_line": 54, "end_line": 54, "text": "// This can lead to a false match for non-existing key to real at index 0."}, {"start_line": 55, "end_line": 55, "text": "// So, just skip key of value 0 to avoid misrouting of packets."}, {"start_line": 63, "end_line": 63, "text": "// update this routing decision in the lru_map as well"}], "updateMaps": [" lru_map"], "readMaps": [" lru_map", " server_id_map", " reals"], "input": ["const struct xdp_md *xdp", " bool is_ipv6", " struct real_definition **real", " struct packet_description *pckt", " bool bypass_lru", " void *lru_map"], "output": "staticinlineint", "helper": ["bpf_map_lookup_elem", "bpf_map_update_elem"], "compatibleHookpoints": ["cgroup_skb", "sk_skb", "kprobe", "cgroup_device", "tracepoint", "socket_filter", "xdp", "raw_tracepoint_writable", "flow_dissector", "lwt_seg6local", "sched_cls", "lwt_out", "sched_act", "cgroup_sysctl", "cgroup_sock_addr", "sk_reuseport", "lwt_xmit", "sock_ops", "perf_event", "raw_tracepoint", "sk_msg", "lwt_in", "cgroup_sock"], "source": ["static inline int tcp_hdr_opt_lookup (const struct xdp_md *xdp, bool is_ipv6, struct real_definition **real, struct packet_description *pckt, bool bypass_lru, void *lru_map)\n", "{\n", "    const void *data = (void *) (long) xdp->data;\n", "    const void *data_end = (void *) (long) xdp->data_end;\n", "    struct real_pos_lru *dst_lru;\n", "    struct tcphdr *tcp_hdr;\n", "    __u8 tcp_hdr_opt_len = 0;\n", "    __u64 tcp_offset = 0;\n", "    struct hdr_opt_state opt_state = {}\n", "    ;\n", "    int err = 0;\n", "    tcp_offset = calc_offset (is_ipv6, false);\n", "    tcp_hdr = (struct tcphdr *) (data + tcp_offset);\n", "    if (tcp_hdr + 1 > data_end) {\n", "        return FURTHER_PROCESSING;\n", "    }\n", "    tcp_hdr_opt_len = (tcp_hdr->doff * 4) - sizeof (struct tcphdr);\n", "    if (tcp_hdr_opt_len < TCP_HDR_OPT_LEN_TPR) {\n", "        return FURTHER_PROCESSING;\n", "    }\n", "    opt_state.hdr_bytes_remaining = tcp_hdr_opt_len;\n", "    opt_state.byte_offset = sizeof (struct tcphdr) + tcp_offset;\n", "\n", "#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 3, 0) || \\\n", "    !defined TCP_HDR_OPT_SKIP_UNROLL_LOOP\n", "\n", "#pragma clang loop unroll(full)\n", "\n", "#endif\n", "    for (int i = 0; i < TCP_HDR_OPT_MAX_OPT_CHECKS; i++) {\n", "        err = parse_hdr_opt (xdp, & opt_state);\n", "        if (err || !opt_state.hdr_bytes_remaining) {\n", "            break;\n", "        }\n", "    }\n", "    if (!opt_state.server_id) {\n", "        return FURTHER_PROCESSING;\n", "    }\n", "    __u32 key = opt_state.server_id;\n", "    __u32 *real_pos = bpf_map_lookup_elem (&server_id_map, &key);\n", "    if (!real_pos) {\n", "        return FURTHER_PROCESSING;\n", "    }\n", "    key = *real_pos;\n", "    if (key == 0) {\n", "        return FURTHER_PROCESSING;\n", "    }\n", "    pckt->real_index = key;\n", "    *real = bpf_map_lookup_elem (&reals, &key);\n", "    if (!(*real)) {\n", "        return FURTHER_PROCESSING;\n", "    }\n", "    if (!bypass_lru) {\n", "        struct real_pos_lru *dst_lru = bpf_map_lookup_elem (lru_map, &pckt->flow);\n", "        if (dst_lru) {\n", "            dst_lru->pos = key;\n", "            return 0;\n", "        }\n", "        struct real_pos_lru new_dst_lru = {}\n", "        ;\n", "        new_dst_lru.pos = key;\n", "        bpf_map_update_elem (lru_map, &pckt->flow, &new_dst_lru, BPF_ANY);\n", "    }\n", "    return 0;\n", "}\n"], "called_function_list": ["parse_hdr_opt", "calc_offset"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "parse_quic": [{"capabilities": [], "helperCallParams": {}, "startLine": 276, "endLine": 335, "File": "/home/sayandes/opened_extraction/examples/katran/pckt_parsing.h", "funcName": "parse_quic", "developer_inline_comments": [{"start_line": 9, "end_line": 9, "text": "// offset points to the beginning of transport header (udp) of quic's packet"}, {"start_line": 10, "end_line": 10, "text": "/*                                      |QUIC PKT TYPE|           */"}, {"start_line": 18, "end_line": 18, "text": "// the position of conn id varies depending on whether the packet has a"}, {"start_line": 19, "end_line": 19, "text": "// long-header or short-header."}, {"start_line": 20, "end_line": 20, "text": "// Once we compute the offset of conn id, just read fixed length,"}, {"start_line": 21, "end_line": 21, "text": "// even if the connid len can be of 0 or 4-18 bytes, since katran is only"}, {"start_line": 22, "end_line": 22, "text": "// concerned about the first 16 bits in Dest Conn Id"}, {"start_line": 24, "end_line": 24, "text": "// packet with long header"}, {"start_line": 29, "end_line": 29, "text": "// for client initial and 0rtt packet - fall back to use c. hash, since"}, {"start_line": 30, "end_line": 30, "text": "// the connection-id is not the server-chosen one."}, {"start_line": 35, "end_line": 35, "text": "// Post draft version 22, this byte is the conn id length of dest conn id"}, {"start_line": 41, "end_line": 41, "text": "// short header: just read the connId"}, {"start_line": 50, "end_line": 50, "text": "// connId schema: if first two bits contain the right version info"}, {"start_line": 53, "end_line": 53, "text": "// extract last 16 bits from the first 18 bits:"}, {"start_line": 54, "end_line": 54, "text": "//            last 6 bits         +    8 bits        +   first 2 bits"}], "updateMaps": [], "readMaps": [], "input": ["void *data", " void *data_end", " bool is_ipv6", " struct packet_description *pckt"], "output": "staticinlineint", "helper": [], "compatibleHookpoints": ["kprobe", "cgroup_skb", "sk_skb", "cgroup_device", "tracepoint", "socket_filter", "xdp", "raw_tracepoint_writable", "flow_dissector", "lwt_seg6local", "sched_cls", "lwt_out", "sched_act", "cgroup_sysctl", "cgroup_sock_addr", "sk_reuseport", "lwt_xmit", "sock_ops", "perf_event", "raw_tracepoint", "sk_msg", "lwt_in", "cgroup_sock"], "source": ["static inline int parse_quic (void *data, void *data_end, bool is_ipv6, struct packet_description *pckt)\n", "{\n", "    bool is_icmp = (pckt->flags & F_ICMP);\n", "    __u64 off = calc_offset (is_ipv6, is_icmp);\n", "    if ((data + off + sizeof (struct udphdr) + sizeof (__u8)) > data_end) {\n", "        return FURTHER_PROCESSING;\n", "    }\n", "    __u8 *quic_data = data + off + sizeof (struct udphdr);\n", "    __u8 *pkt_type = quic_data;\n", "    __u8 *connId = NULL;\n", "    if ((*pkt_type & QUIC_LONG_HEADER) == QUIC_LONG_HEADER) {\n", "        if (quic_data + sizeof (struct quic_long_header) > data_end) {\n", "            return FURTHER_PROCESSING;\n", "        }\n", "        if ((*pkt_type & QUIC_PACKET_TYPE_MASK) < QUIC_HANDSHAKE) {\n", "            return FURTHER_PROCESSING;\n", "        }\n", "        struct quic_long_header *long_header = (struct quic_long_header *) quic_data;\n", "        if (long_header->conn_id_lens < QUIC_MIN_CONNID_LEN) {\n", "            return FURTHER_PROCESSING;\n", "        }\n", "        connId = long_header->dst_connection_id;\n", "    }\n", "    else {\n", "        if (quic_data + sizeof (struct quic_short_header) > data_end) {\n", "            return FURTHER_PROCESSING;\n", "        }\n", "        connId = ((struct quic_short_header *) quic_data)->connection_id;\n", "    }\n", "    if (!connId) {\n", "        return FURTHER_PROCESSING;\n", "    }\n", "    __u8 connIdVersion = (connId[0] >> 6);\n", "    if (connIdVersion == QUIC_CONNID_VERSION_V1) {\n", "        return ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);\n", "    }\n", "    else if (connIdVersion == QUIC_CONNID_VERSION_V2) {\n", "        __u32 cid = (connId[1] << 16) | (connId[2] << 8) | (connId[3]);\n", "        return cid;\n", "    }\n", "    return FURTHER_PROCESSING;\n", "}\n"], "called_function_list": ["calc_offset"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "get_next_ports": [{"capabilities": [], "helperCallParams": {}, "startLine": 29, "endLine": 53, "File": "/home/sayandes/opened_extraction/examples/katran/flow_debug_helpers.h", "funcName": "get_next_ports", "developer_inline_comments": [{"start_line": 1, "end_line": 15, "text": "/* Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; version 2 of the License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */"}], "updateMaps": [], "readMaps": [], "input": ["void *transport_hdr", " __u8 proto", " void *data_end"], "output": "staticinline__u32", "helper": [], "compatibleHookpoints": ["kprobe", "cgroup_skb", "sk_skb", "cgroup_device", "tracepoint", "socket_filter", "xdp", "raw_tracepoint_writable", "flow_dissector", "lwt_seg6local", "sched_cls", "lwt_out", "sched_act", "cgroup_sysctl", "cgroup_sock_addr", "sk_reuseport", "lwt_xmit", "sock_ops", "perf_event", "raw_tracepoint", "sk_msg", "lwt_in", "cgroup_sock"], "source": ["static inline __u32 get_next_ports (void *transport_hdr, __u8 proto, void *data_end)\n", "{\n", "    __u32 ports = 0;\n", "    struct udphdr *udph = 0;\n", "    struct tcphdr *tcph = 0;\n", "    switch (proto) {\n", "    case IPPROTO_UDP :\n", "        udph = transport_hdr;\n", "        if ((void *) udph + sizeof (struct udphdr) <= data_end) {\n", "            ports = (bpf_ntohs (udph->dest) << 16) | bpf_ntohs (udph->source);\n", "        }\n", "        break;\n", "    case IPPROTO_TCP :\n", "        tcph = transport_hdr;\n", "        if ((void *) tcph + sizeof (struct tcphdr) <= data_end) {\n", "            ports = (bpf_ntohs (tcph->dest) << 16) | bpf_ntohs (tcph->source);\n", "        }\n", "        break;\n", "    default :\n", "        break;\n", "    }\n", "    return ports;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "gue_record_route": [{"capabilities": [{"capability": "read_sys_info", "read_sys_info": [{"Project": "libbpf", "Return Type": "u32", "Description": "Get the SMP (symmetric multiprocessing) processor id. Note that all programs run with preemption disabled , which means that the SMP processor id is stable during all the execution of the program. ", "Return": " The SMP id of the processor running the program.", "Function Name": "bpf_get_smp_processor_id", "Input Params": ["{Type: voi ,Var: void}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "raw_tracepoint_writable"], "capabilities": ["read_sys_info"]}]}], "helperCallParams": {}, "startLine": 55, "endLine": 128, "File": "/home/sayandes/opened_extraction/examples/katran/flow_debug_helpers.h", "funcName": "gue_record_route", "developer_inline_comments": [{"start_line": 15, "end_line": 20, "text": "/*XXX\nvoid* flow_debug_map = bpf_map_lookup_elem(&flow_debug_maps, &cpu_num);\n  if (!flow_debug_map) {\n    return;\n  }\n  */"}, {"start_line": 70, "end_line": 72, "text": "/* XXX\n  bpf_map_update_elem(flow_debug_map, &flow, &debug_info, BPF_ANY);\n  */"}], "updateMaps": [], "readMaps": [], "input": ["struct ethhdr *outer_eth", " struct ethhdr *inner_eth", " void *data_end", " bool outer_v4", " bool inner_v4"], "output": "staticinlinevoid", "helper": ["bpf_get_smp_processor_id"], "compatibleHookpoints": ["kprobe", "cgroup_skb", "sk_skb", "tracepoint", "socket_filter", "xdp", "raw_tracepoint_writable", "flow_dissector", "lwt_seg6local", "sched_cls", "lwt_out", "sched_act", "cgroup_sock_addr", "sk_reuseport", "lwt_xmit", "sock_ops", "perf_event", "raw_tracepoint", "sk_msg", "lwt_in", "cgroup_sock"], "source": ["static inline void gue_record_route (struct ethhdr *outer_eth, struct ethhdr *inner_eth, void *data_end, bool outer_v4, bool inner_v4)\n", "{\n", "    struct flow_key flow = {0}\n", "    ;\n", "    struct flow_debug_info debug_info = {0}\n", "    ;\n", "    struct ipv6hdr *ip6h = 0;\n", "    struct iphdr *ip4h = 0;\n", "    void *transport_header = 0;\n", "    __u32 cpu_num = bpf_get_smp_processor_id ();\n", "    if (outer_v4) {\n", "        if ((void *) outer_eth + sizeof (struct ethhdr) + sizeof (struct iphdr) > data_end) {\n", "            return;\n", "        }\n", "        ip4h = (void *) outer_eth + sizeof (struct ethhdr);\n", "        debug_info.l4_hop = ip4h->saddr;\n", "        debug_info.this_hop = ip4h->daddr;\n", "    }\n", "    else {\n", "        if ((void *) outer_eth + sizeof (struct ethhdr) + sizeof (struct ipv6hdr) > data_end) {\n", "            return;\n", "        }\n", "        ip6h = (void *) outer_eth + sizeof (struct ethhdr);\n", "        __builtin_memcpy (debug_info.l4_hopv6, ip6h->saddr.s6_addr32, sizeof (debug_info.l4_hopv6));\n", "        __builtin_memcpy (debug_info.this_hopv6, ip6h->daddr.s6_addr32, sizeof (debug_info.this_hopv6));\n", "    }\n", "    if (inner_v4) {\n", "        if ((void *) inner_eth + sizeof (struct ethhdr) + sizeof (struct iphdr) > data_end) {\n", "            return;\n", "        }\n", "        ip4h = (void *) inner_eth + sizeof (struct ethhdr);\n", "        transport_header = (void *) inner_eth + sizeof (struct ethhdr) + sizeof (struct iphdr);\n", "        flow.src = ip4h->saddr;\n", "        flow.dst = ip4h->daddr;\n", "        flow.proto = ip4h->protocol;\n", "        flow.ports = get_next_ports (transport_header, ip4h->protocol, data_end);\n", "    }\n", "    else {\n", "        if ((void *) inner_eth + sizeof (struct ethhdr) + sizeof (struct ipv6hdr) > data_end) {\n", "            return;\n", "        }\n", "        ip6h = (void *) inner_eth + sizeof (struct ethhdr);\n", "        transport_header = (void *) inner_eth + sizeof (struct ethhdr) + sizeof (struct ipv6hdr);\n", "        __builtin_memcpy (flow.srcv6, ip6h->saddr.s6_addr32, sizeof (flow.srcv6));\n", "        __builtin_memcpy (flow.dstv6, ip6h->daddr.s6_addr32, sizeof (flow.dstv6));\n", "        flow.proto = ip6h->nexthdr;\n", "        flow.ports = get_next_ports (transport_header, ip6h->nexthdr, data_end);\n", "    }\n", "    return;\n", "}\n"], "called_function_list": ["get_next_ports"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "csum_fold_helper": [{"capabilities": [], "helperCallParams": {}, "startLine": 30, "endLine": 39, "File": "/home/sayandes/opened_extraction/examples/katran/csum_helpers.h", "funcName": "csum_fold_helper", "developer_inline_comments": [{"start_line": 1, "end_line": 15, "text": "/* Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; version 2 of the License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */"}], "updateMaps": [], "readMaps": [], "input": ["__u64 csum"], "output": "staticinline__u16", "helper": [], "compatibleHookpoints": ["kprobe", "cgroup_skb", "sk_skb", "cgroup_device", "tracepoint", "socket_filter", "xdp", "raw_tracepoint_writable", "flow_dissector", "lwt_seg6local", "sched_cls", "lwt_out", "sched_act", "cgroup_sysctl", "cgroup_sock_addr", "sk_reuseport", "lwt_xmit", "sock_ops", "perf_event", "raw_tracepoint", "sk_msg", "lwt_in", "cgroup_sock"], "source": ["static inline __u16 csum_fold_helper (__u64 csum)\n", "{\n", "    int i;\n", "\n", "#pragma unroll\n", "    for (i = 0; i < 4; i++) {\n", "        if (csum >> 16)\n", "            csum = (csum & 0xffff) + (csum >> 16);\n", "    }\n", "    return ~csum;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "min_helper": [{"capabilities": [], "helperCallParams": {}, "startLine": 41, "endLine": 43, "File": "/home/sayandes/opened_extraction/examples/katran/csum_helpers.h", "funcName": "min_helper", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["int a", " int b"], "output": "staticint", "helper": [], "compatibleHookpoints": ["kprobe", "cgroup_skb", "sk_skb", "cgroup_device", "tracepoint", "socket_filter", "xdp", "raw_tracepoint_writable", "flow_dissector", "lwt_seg6local", "sched_cls", "lwt_out", "sched_act", "cgroup_sysctl", "cgroup_sock_addr", "sk_reuseport", "lwt_xmit", "sock_ops", "perf_event", "raw_tracepoint", "sk_msg", "lwt_in", "cgroup_sock"], "source": ["static int min_helper (int a, int b)\n", "{\n", "    return a < b ? a : b;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ipv4_csum": [{"capabilities": [{"capability": "read_skb", "read_skb": [{"Project": "libbpf", "Return Type": "s64", "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with bpf_l3_csum_replace() and bpf_l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with bpf_csum_diff(). ", "Return": " The checksum result, or a negative error code in case of failure.", "Function Name": "bpf_csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp", "lwt_in", "lwt_out", "lwt_xmit", "lwt_seg6local"], "capabilities": ["read_skb"]}]}], "helperCallParams": {}, "startLine": 45, "endLine": 49, "File": "/home/sayandes/opened_extraction/examples/katran/csum_helpers.h", "funcName": "ipv4_csum", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["void *data_start", " int data_size", " __u64 *csum"], "output": "staticinlinevoid", "helper": ["bpf_csum_diff"], "compatibleHookpoints": ["lwt_out", "sched_act", "lwt_seg6local", "lwt_in", "sched_cls", "xdp", "lwt_xmit"], "source": ["static inline void ipv4_csum (void *data_start, int data_size, __u64 *csum)\n", "{\n", "    *csum = bpf_csum_diff (0, 0, data_start, data_size, *csum);\n", "    *csum = csum_fold_helper (*csum);\n", "}\n"], "called_function_list": ["csum_fold_helper"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ipv4_csum_inline": [{"capabilities": [], "helperCallParams": {}, "startLine": 51, "endLine": 60, "File": "/home/sayandes/opened_extraction/examples/katran/csum_helpers.h", "funcName": "ipv4_csum_inline", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["void *iph", " __u64 *csum"], "output": "staticinlinevoid", "helper": [], "compatibleHookpoints": ["kprobe", "cgroup_skb", "sk_skb", "cgroup_device", "tracepoint", "socket_filter", "xdp", "raw_tracepoint_writable", "flow_dissector", "lwt_seg6local", "sched_cls", "lwt_out", "sched_act", "cgroup_sysctl", "cgroup_sock_addr", "sk_reuseport", "lwt_xmit", "sock_ops", "perf_event", "raw_tracepoint", "sk_msg", "lwt_in", "cgroup_sock"], "source": ["static inline void ipv4_csum_inline (void *iph, __u64 *csum)\n", "{\n", "    __u16 *next_iph_u16 = (__u16 *) iph;\n", "\n", "#pragma clang loop unroll(full)\n", "    for (int i = 0; i < sizeof (struct iphdr) >> 1; i++) {\n", "        *csum += *next_iph_u16++;\n", "    }\n", "    *csum = csum_fold_helper (*csum);\n", "}\n"], "called_function_list": ["csum_fold_helper"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ipv4_l4_csum": [{"capabilities": [{"capability": "read_skb", "read_skb": [{"Project": "libbpf", "Return Type": "s64", "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with bpf_l3_csum_replace() and bpf_l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with bpf_csum_diff(). ", "Return": " The checksum result, or a negative error code in case of failure.", "Function Name": "bpf_csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp", "lwt_in", "lwt_out", "lwt_xmit", "lwt_seg6local"], "capabilities": ["read_skb"]}]}], "helperCallParams": {}, "startLine": 62, "endLine": 73, "File": "/home/sayandes/opened_extraction/examples/katran/csum_helpers.h", "funcName": "ipv4_l4_csum", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["void *data_start", " int data_size", " __u64 *csum", " struct iphdr *iph"], "output": "staticinlinevoid", "helper": ["bpf_csum_diff"], "compatibleHookpoints": ["lwt_out", "sched_act", "lwt_seg6local", "lwt_in", "sched_cls", "xdp", "lwt_xmit"], "source": ["static inline void ipv4_l4_csum (void *data_start, int data_size, __u64 *csum, struct iphdr *iph)\n", "{\n", "    __u32 tmp = 0;\n", "    *csum = bpf_csum_diff (0, 0, &iph->saddr, sizeof (__be32), *csum);\n", "    *csum = bpf_csum_diff (0, 0, &iph->daddr, sizeof (__be32), *csum);\n", "    tmp = __builtin_bswap32 ((__u32) (iph -> protocol));\n", "    *csum = bpf_csum_diff (0, 0, &tmp, sizeof (__u32), *csum);\n", "    tmp = __builtin_bswap32 ((__u32) (data_size));\n", "    *csum = bpf_csum_diff (0, 0, &tmp, sizeof (__u32), *csum);\n", "    *csum = bpf_csum_diff (0, 0, data_start, data_size, *csum);\n", "    *csum = csum_fold_helper (*csum);\n", "}\n"], "called_function_list": ["csum_fold_helper"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ipv6_csum": [{"capabilities": [{"capability": "read_skb", "read_skb": [{"Project": "libbpf", "Return Type": "s64", "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with bpf_l3_csum_replace() and bpf_l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with bpf_csum_diff(). ", "Return": " The checksum result, or a negative error code in case of failure.", "Function Name": "bpf_csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp", "lwt_in", "lwt_out", "lwt_xmit", "lwt_seg6local"], "capabilities": ["read_skb"]}]}], "helperCallParams": {}, "startLine": 75, "endLine": 88, "File": "/home/sayandes/opened_extraction/examples/katran/csum_helpers.h", "funcName": "ipv6_csum", "developer_inline_comments": [{"start_line": 3, "end_line": 3, "text": "// ipv6 pseudo header"}, {"start_line": 11, "end_line": 11, "text": "// sum over payload"}], "updateMaps": [], "readMaps": [], "input": ["void *data_start", " int data_size", " __u64 *csum", " struct ipv6hdr *ip6h"], "output": "staticinlinevoid", "helper": ["bpf_csum_diff"], "compatibleHookpoints": ["lwt_out", "sched_act", "lwt_seg6local", "lwt_in", "sched_cls", "xdp", "lwt_xmit"], "source": ["static inline void ipv6_csum (void *data_start, int data_size, __u64 *csum, struct ipv6hdr *ip6h)\n", "{\n", "    __u32 tmp = 0;\n", "    *csum = bpf_csum_diff (0, 0, &ip6h->saddr, sizeof (struct in6_addr), *csum);\n", "    *csum = bpf_csum_diff (0, 0, &ip6h->daddr, sizeof (struct in6_addr), *csum);\n", "    tmp = __builtin_bswap32 ((__u32) (data_size));\n", "    *csum = bpf_csum_diff (0, 0, &tmp, sizeof (__u32), *csum);\n", "    tmp = __builtin_bswap32 ((__u32) (ip6h -> nexthdr));\n", "    *csum = bpf_csum_diff (0, 0, &tmp, sizeof (__u32), *csum);\n", "    *csum = bpf_csum_diff (0, 0, data_start, data_size, *csum);\n", "    *csum = csum_fold_helper (*csum);\n", "}\n"], "called_function_list": ["csum_fold_helper"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "add_pseudo_ipv6_header": [{"capabilities": [{"capability": "read_skb", "read_skb": [{"Project": "libbpf", "Return Type": "s64", "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with bpf_l3_csum_replace() and bpf_l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with bpf_csum_diff(). ", "Return": " The checksum result, or a negative error code in case of failure.", "Function Name": "bpf_csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp", "lwt_in", "lwt_out", "lwt_xmit", "lwt_seg6local"], "capabilities": ["read_skb"]}]}], "helperCallParams": {}, "startLine": 95, "endLine": 127, "File": "/home/sayandes/opened_extraction/examples/katran/csum_helpers.h", "funcName": "add_pseudo_ipv6_header", "developer_inline_comments": [{"start_line": 3, "end_line": 3, "text": "// Next four methods are helper methods to add or remove IP(6) pseudo header"}, {"start_line": 4, "end_line": 4, "text": "// unto the given csum value."}, {"start_line": 21, "end_line": 21, "text": "// convert 16-bit payload in network order to 32-bit in network order"}, {"start_line": 22, "end_line": 22, "text": "// e.g. payload len: 0x0102 to be written as 0x02010000 in network order"}, {"start_line": 24, "end_line": 24, "text": "/* back to network byte order */"}], "updateMaps": [], "readMaps": [], "input": ["struct ipv6hdr *ip6h", " __u64 *csum"], "output": "staticinline__s64", "helper": ["bpf_csum_diff"], "compatibleHookpoints": ["lwt_out", "sched_act", "lwt_seg6local", "lwt_in", "sched_cls", "xdp", "lwt_xmit"], "source": ["static inline __s64 add_pseudo_ipv6_header (struct ipv6hdr *ip6h, __u64 *csum)\n", "{\n", "    __s64 ret;\n", "    __u32 tmp = 0;\n", "    ret = bpf_csum_diff (0, 0, & ip6h -> saddr, sizeof (struct in6_addr), * csum);\n", "    if (ret < 0) {\n", "        return ret;\n", "    }\n", "    *csum = ret;\n", "    ret = bpf_csum_diff (0, 0, & ip6h -> daddr, sizeof (struct in6_addr), * csum);\n", "    if (ret < 0) {\n", "        return ret;\n", "    }\n", "    *csum = ret;\n", "    tmp = (__u32) bpf_ntohs (ip6h->payload_len);\n", "    tmp = bpf_htonl (tmp);\n", "    ret = bpf_csum_diff (0, 0, & tmp, sizeof (__u32), * csum);\n", "    if (ret < 0) {\n", "        return ret;\n", "    }\n", "    *csum = ret;\n", "    tmp = __builtin_bswap32 ((__u32) (ip6h -> nexthdr));\n", "    ret = bpf_csum_diff (0, 0, & tmp, sizeof (__u32), * csum);\n", "    if (ret < 0) {\n", "        return ret;\n", "    }\n", "    *csum = ret;\n", "    return 0;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "rem_pseudo_ipv6_header": [{"capabilities": [{"capability": "read_skb", "read_skb": [{"Project": "libbpf", "Return Type": "s64", "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with bpf_l3_csum_replace() and bpf_l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with bpf_csum_diff(). ", "Return": " The checksum result, or a negative error code in case of failure.", "Function Name": "bpf_csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp", "lwt_in", "lwt_out", "lwt_xmit", "lwt_seg6local"], "capabilities": ["read_skb"]}]}], "helperCallParams": {}, "startLine": 129, "endLine": 158, "File": "/home/sayandes/opened_extraction/examples/katran/csum_helpers.h", "funcName": "rem_pseudo_ipv6_header", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct ipv6hdr *ip6h", " __u64 *csum"], "output": "staticinline__s64", "helper": ["bpf_csum_diff"], "compatibleHookpoints": ["lwt_out", "sched_act", "lwt_seg6local", "lwt_in", "sched_cls", "xdp", "lwt_xmit"], "source": ["static inline __s64 rem_pseudo_ipv6_header (struct ipv6hdr *ip6h, __u64 *csum)\n", "{\n", "    __s64 ret;\n", "    __u32 tmp = 0;\n", "    ret = bpf_csum_diff (& ip6h -> saddr, sizeof (struct in6_addr), 0, 0, * csum);\n", "    if (ret < 0) {\n", "        return ret;\n", "    }\n", "    *csum = ret;\n", "    ret = bpf_csum_diff (& ip6h -> daddr, sizeof (struct in6_addr), 0, 0, * csum);\n", "    if (ret < 0) {\n", "        return ret;\n", "    }\n", "    *csum = ret;\n", "    tmp = (__u32) bpf_ntohs (ip6h->payload_len);\n", "    tmp = bpf_htonl (tmp);\n", "    ret = bpf_csum_diff (& tmp, sizeof (__u32), 0, 0, * csum);\n", "    if (ret < 0) {\n", "        return ret;\n", "    }\n", "    *csum = ret;\n", "    tmp = __builtin_bswap32 ((__u32) (ip6h -> nexthdr));\n", "    ret = bpf_csum_diff (& tmp, sizeof (__u32), 0, 0, * csum);\n", "    if (ret < 0) {\n", "        return ret;\n", "    }\n", "    *csum = ret;\n", "    return 0;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "add_pseudo_ipv4_header": [{"capabilities": [{"capability": "read_skb", "read_skb": [{"Project": "libbpf", "Return Type": "s64", "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with bpf_l3_csum_replace() and bpf_l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with bpf_csum_diff(). ", "Return": " The checksum result, or a negative error code in case of failure.", "Function Name": "bpf_csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp", "lwt_in", "lwt_out", "lwt_xmit", "lwt_seg6local"], "capabilities": ["read_skb"]}]}], "helperCallParams": {}, "startLine": 160, "endLine": 189, "File": "/home/sayandes/opened_extraction/examples/katran/csum_helpers.h", "funcName": "add_pseudo_ipv4_header", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct iphdr *iph", " __u64 *csum"], "output": "staticinline__s64", "helper": ["bpf_csum_diff"], "compatibleHookpoints": ["lwt_out", "sched_act", "lwt_seg6local", "lwt_in", "sched_cls", "xdp", "lwt_xmit"], "source": ["static inline __s64 add_pseudo_ipv4_header (struct iphdr *iph, __u64 *csum)\n", "{\n", "    __s64 ret;\n", "    __u32 tmp = 0;\n", "    ret = bpf_csum_diff (0, 0, & iph -> saddr, sizeof (__be32), * csum);\n", "    if (ret < 0) {\n", "        return ret;\n", "    }\n", "    *csum = ret;\n", "    ret = bpf_csum_diff (0, 0, & iph -> daddr, sizeof (__be32), * csum);\n", "    if (ret < 0) {\n", "        return ret;\n", "    }\n", "    *csum = ret;\n", "    tmp = (__u32) bpf_ntohs (iph->tot_len) - sizeof (struct iphdr);\n", "    tmp = bpf_htonl (tmp);\n", "    ret = bpf_csum_diff (0, 0, & tmp, sizeof (__u32), * csum);\n", "    if (ret < 0) {\n", "        return ret;\n", "    }\n", "    *csum = ret;\n", "    tmp = __builtin_bswap32 ((__u32) (iph -> protocol));\n", "    ret = bpf_csum_diff (0, 0, & tmp, sizeof (__u32), * csum);\n", "    if (ret < 0) {\n", "        return ret;\n", "    }\n", "    *csum = ret;\n", "    return 0;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "rem_pseudo_ipv4_header": [{"capabilities": [{"capability": "read_skb", "read_skb": [{"Project": "libbpf", "Return Type": "s64", "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with bpf_l3_csum_replace() and bpf_l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with bpf_csum_diff(). ", "Return": " The checksum result, or a negative error code in case of failure.", "Function Name": "bpf_csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp", "lwt_in", "lwt_out", "lwt_xmit", "lwt_seg6local"], "capabilities": ["read_skb"]}]}], "helperCallParams": {}, "startLine": 191, "endLine": 220, "File": "/home/sayandes/opened_extraction/examples/katran/csum_helpers.h", "funcName": "rem_pseudo_ipv4_header", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct iphdr *iph", " __u64 *csum"], "output": "staticinline__s64", "helper": ["bpf_csum_diff"], "compatibleHookpoints": ["lwt_out", "sched_act", "lwt_seg6local", "lwt_in", "sched_cls", "xdp", "lwt_xmit"], "source": ["static inline __s64 rem_pseudo_ipv4_header (struct iphdr *iph, __u64 *csum)\n", "{\n", "    __s64 ret;\n", "    __u32 tmp = 0;\n", "    ret = bpf_csum_diff (& iph -> saddr, sizeof (__be32), 0, 0, * csum);\n", "    if (ret < 0) {\n", "        return ret;\n", "    }\n", "    *csum = ret;\n", "    ret = bpf_csum_diff (& iph -> daddr, sizeof (__be32), 0, 0, * csum);\n", "    if (ret < 0) {\n", "        return ret;\n", "    }\n", "    *csum = ret;\n", "    tmp = (__u32) bpf_ntohs (iph->tot_len) - sizeof (struct iphdr);\n", "    tmp = bpf_htonl (tmp);\n", "    ret = bpf_csum_diff (& tmp, sizeof (__u32), 0, 0, * csum);\n", "    if (ret < 0) {\n", "        return ret;\n", "    }\n", "    *csum = ret;\n", "    tmp = __builtin_bswap32 ((__u32) (iph -> protocol));\n", "    ret = bpf_csum_diff (& tmp, sizeof (__u32), 0, 0, * csum);\n", "    if (ret < 0) {\n", "        return ret;\n", "    }\n", "    *csum = ret;\n", "    return 0;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "gue_csum_v6": [{"capabilities": [{"capability": "read_skb", "read_skb": [{"Project": "libbpf", "Return Type": "s64", "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with bpf_l3_csum_replace() and bpf_l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with bpf_csum_diff(). ", "Return": " The checksum result, or a negative error code in case of failure.", "Function Name": "bpf_csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp", "lwt_in", "lwt_out", "lwt_xmit", "lwt_seg6local"], "capabilities": ["read_skb"]}]}], "helperCallParams": {}, "startLine": 234, "endLine": 268, "File": "/home/sayandes/opened_extraction/examples/katran/csum_helpers.h", "funcName": "gue_csum_v6", "developer_inline_comments": [{"start_line": 1, "end_line": 12, "text": "/*\n * The following methods concern computation of checksum for GUE encapsulated\n * header for various combination of ip-headers.\n *\n * csum computation for the GUE header is implemented as the Eqn 3 in RFC-1624\n * https://tools.ietf.org/html/rfc1624#section-2\n * New checksum (HC') = ~(~HC + ~m + m')\n * where: HC  - old checksum in header\n *        HC' - new checksum in header\n *        m   - old value of a 16-bit field\n *        m'  - new value of a 16-bit field\n */"}, {"start_line": 20, "end_line": 20, "text": "// one's complement of csum from the original transport header"}, {"start_line": 22, "end_line": 22, "text": "// add the original csum value from the transport header"}], "updateMaps": [], "readMaps": [], "input": ["struct ipv6hdr *outer_ip6h", " struct udphdr *udph", " struct ipv6hdr *inner_ip6h", " __u64 *csum_in_hdr"], "output": "staticinlinebool", "helper": ["bpf_csum_diff"], "compatibleHookpoints": ["lwt_out", "sched_act", "lwt_seg6local", "lwt_in", "sched_cls", "xdp", "lwt_xmit"], "source": ["static inline bool gue_csum_v6 (struct ipv6hdr *outer_ip6h, struct udphdr *udph, struct ipv6hdr *inner_ip6h, __u64 *csum_in_hdr)\n", "{\n", "    __s64 ret;\n", "    __u32 tmp = 0;\n", "    __u32 seed = (~(*csum_in_hdr)) & 0xffff;\n", "    __u32 orig_csum = (__u32) *csum_in_hdr;\n", "    ret = bpf_csum_diff (0, 0, & orig_csum, sizeof (__u32), seed);\n", "    if (ret < 0) {\n", "        return false;\n", "    }\n", "    *csum_in_hdr = ret;\n", "    if (rem_pseudo_ipv6_header (inner_ip6h, csum_in_hdr) < 0) {\n", "        return false;\n", "    }\n", "    ret = bpf_csum_diff (0, 0, inner_ip6h, sizeof (struct ipv6hdr), * csum_in_hdr);\n", "    if (ret < 0) {\n", "        return false;\n", "    }\n", "    *csum_in_hdr = ret;\n", "    ret = bpf_csum_diff (0, 0, udph, sizeof (struct udphdr), * csum_in_hdr);\n", "    if (ret < 0) {\n", "        return false;\n", "    }\n", "    *csum_in_hdr = ret;\n", "    if (add_pseudo_ipv6_header (outer_ip6h, csum_in_hdr) < 0) {\n", "        return false;\n", "    }\n", "    *csum_in_hdr = csum_fold_helper (*csum_in_hdr);\n", "    return true;\n", "}\n"], "called_function_list": ["rem_pseudo_ipv6_header", "add_pseudo_ipv6_header", "csum_fold_helper"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "gue_csum_v4": [{"capabilities": [{"capability": "read_skb", "read_skb": [{"Project": "libbpf", "Return Type": "s64", "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with bpf_l3_csum_replace() and bpf_l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with bpf_csum_diff(). ", "Return": " The checksum result, or a negative error code in case of failure.", "Function Name": "bpf_csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp", "lwt_in", "lwt_out", "lwt_xmit", "lwt_seg6local"], "capabilities": ["read_skb"]}]}], "helperCallParams": {}, "startLine": 270, "endLine": 302, "File": "/home/sayandes/opened_extraction/examples/katran/csum_helpers.h", "funcName": "gue_csum_v4", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct iphdr *outer_iph", " struct udphdr *udph", " struct iphdr *inner_iph", " __u64 *csum_in_hdr"], "output": "staticinlinebool", "helper": ["bpf_csum_diff"], "compatibleHookpoints": ["lwt_out", "sched_act", "lwt_seg6local", "lwt_in", "sched_cls", "xdp", "lwt_xmit"], "source": ["static inline bool gue_csum_v4 (struct iphdr *outer_iph, struct udphdr *udph, struct iphdr *inner_iph, __u64 *csum_in_hdr)\n", "{\n", "    __s64 ret;\n", "    __u32 tmp = 0;\n", "    __u32 seed = (~(*csum_in_hdr)) & 0xffff;\n", "    __u32 orig_csum = (__u32) *csum_in_hdr;\n", "    ret = bpf_csum_diff (0, 0, & orig_csum, sizeof (__u32), seed);\n", "    if (ret < 0) {\n", "        return false;\n", "    }\n", "    *csum_in_hdr = ret;\n", "    if (rem_pseudo_ipv4_header (inner_iph, csum_in_hdr) < 0) {\n", "        return false;\n", "    }\n", "    ret = bpf_csum_diff (0, 0, inner_iph, sizeof (struct iphdr), * csum_in_hdr);\n", "    if (ret < 0) {\n", "        return false;\n", "    }\n", "    *csum_in_hdr = ret;\n", "    ret = bpf_csum_diff (0, 0, udph, sizeof (struct udphdr), * csum_in_hdr);\n", "    if (ret < 0) {\n", "        return false;\n", "    }\n", "    *csum_in_hdr = ret;\n", "    if (add_pseudo_ipv4_header (outer_iph, csum_in_hdr) < 0) {\n", "        return false;\n", "    }\n", "    *csum_in_hdr = csum_fold_helper (*csum_in_hdr);\n", "    return true;\n", "}\n"], "called_function_list": ["add_pseudo_ipv4_header", "rem_pseudo_ipv4_header", "csum_fold_helper"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "gue_csum_v4_in_v6": [{"capabilities": [{"capability": "read_skb", "read_skb": [{"Project": "libbpf", "Return Type": "s64", "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with bpf_l3_csum_replace() and bpf_l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with bpf_csum_diff(). ", "Return": " The checksum result, or a negative error code in case of failure.", "Function Name": "bpf_csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp", "lwt_in", "lwt_out", "lwt_xmit", "lwt_seg6local"], "capabilities": ["read_skb"]}]}], "helperCallParams": {}, "startLine": 304, "endLine": 336, "File": "/home/sayandes/opened_extraction/examples/katran/csum_helpers.h", "funcName": "gue_csum_v4_in_v6", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct ipv6hdr *outer_ip6h", " struct udphdr *udph", " struct iphdr *inner_iph", " __u64 *csum_in_hdr"], "output": "staticinlinebool", "helper": ["bpf_csum_diff"], "compatibleHookpoints": ["lwt_out", "sched_act", "lwt_seg6local", "lwt_in", "sched_cls", "xdp", "lwt_xmit"], "source": ["static inline bool gue_csum_v4_in_v6 (struct ipv6hdr *outer_ip6h, struct udphdr *udph, struct iphdr *inner_iph, __u64 *csum_in_hdr)\n", "{\n", "    __s64 ret;\n", "    __u32 tmp = 0;\n", "    __u32 seed = (~(*csum_in_hdr)) & 0xffff;\n", "    __u32 orig_csum = (__u32) *csum_in_hdr;\n", "    ret = bpf_csum_diff (0, 0, & orig_csum, sizeof (__u32), seed);\n", "    if (ret < 0) {\n", "        return false;\n", "    }\n", "    *csum_in_hdr = ret;\n", "    if (rem_pseudo_ipv4_header (inner_iph, csum_in_hdr) < 0) {\n", "        return false;\n", "    }\n", "    ret = bpf_csum_diff (0, 0, inner_iph, sizeof (struct iphdr), * csum_in_hdr);\n", "    if (ret < 0) {\n", "        return false;\n", "    }\n", "    *csum_in_hdr = ret;\n", "    ret = bpf_csum_diff (0, 0, udph, sizeof (struct udphdr), * csum_in_hdr);\n", "    if (ret < 0) {\n", "        return false;\n", "    }\n", "    *csum_in_hdr = ret;\n", "    if (add_pseudo_ipv6_header (outer_ip6h, csum_in_hdr) < 0) {\n", "        return false;\n", "    }\n", "    *csum_in_hdr = csum_fold_helper (*csum_in_hdr);\n", "    return true;\n", "}\n"], "called_function_list": ["rem_pseudo_ipv4_header", "add_pseudo_ipv6_header", "csum_fold_helper"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "swap_mac_and_send": [{"capabilities": [{"capability": "pkt_alter_or_redo_processing_or_interface", "pkt_alter_or_redo_processing_or_interface": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_TX", "Return": 3, "Description": "an efficient option to transmit the network packet out of the same NIC it just arrived on again. This is typically useful when few nodes are implementing, for example, firewalling with subsequent load balancing in a cluster and thus act as a hairpinned load balancer pushing the incoming packets back into the switch after rewriting them in XDP BPF.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_alter_or_redo_processing_or_interface"]}]}], "helperCallParams": {}, "startLine": 38, "endLine": 48, "File": "/home/sayandes/opened_extraction/examples/katran/handle_icmp.h", "funcName": "swap_mac_and_send", "developer_inline_comments": [{"start_line": 1, "end_line": 15, "text": "/* Copyright (C) 2018-present, Facebook, Inc.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; version 2 of the License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */"}, {"start_line": 20, "end_line": 23, "text": "/*\n * This file contains all routines which are responsible for parsing\n * and handling ICMP packets\n */"}], "updateMaps": [], "readMaps": [], "input": ["void *data", " void *data_end"], "output": "staticinlineint", "helper": ["XDP_TX"], "compatibleHookpoints": ["xdp"], "source": ["static inline int swap_mac_and_send (void *data, void *data_end)\n", "{\n", "    struct ethhdr *eth;\n", "    unsigned char tmp_mac [ETH_ALEN];\n", "    eth = data;\n", "    memcpy (tmp_mac, eth->h_source, ETH_ALEN);\n", "    memcpy (eth->h_source, eth->h_dest, ETH_ALEN);\n", "    memcpy (eth->h_dest, tmp_mac, ETH_ALEN);\n", "    return XDP_TX;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "swap_mac": [{"capabilities": [], "helperCallParams": {}, "startLine": 50, "endLine": 58, "File": "/home/sayandes/opened_extraction/examples/katran/handle_icmp.h", "funcName": "swap_mac", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["void *data", " struct ethhdr *orig_eth"], "output": "staticinlinevoid", "helper": [], "compatibleHookpoints": ["kprobe", "cgroup_skb", "sk_skb", "cgroup_device", "tracepoint", "socket_filter", "xdp", "raw_tracepoint_writable", "flow_dissector", "lwt_seg6local", "sched_cls", "lwt_out", "sched_act", "cgroup_sysctl", "cgroup_sock_addr", "sk_reuseport", "lwt_xmit", "sock_ops", "perf_event", "raw_tracepoint", "sk_msg", "lwt_in", "cgroup_sock"], "source": ["static inline void swap_mac (void *data, struct ethhdr *orig_eth)\n", "{\n", "    struct ethhdr *eth;\n", "    eth = data;\n", "    memcpy (eth->h_source, orig_eth->h_dest, ETH_ALEN);\n", "    memcpy (eth->h_dest, orig_eth->h_source, ETH_ALEN);\n", "    eth->h_proto = orig_eth->h_proto;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "send_icmp_reply": [{"capabilities": [{"capability": "pkt_stop_processing_drop_packet", "pkt_stop_processing_drop_packet": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_DROP", "Return": 1, "Description": "will drop the packet right at the driver level without wasting any further resources. This is in particular useful for BPF programs implementing DDoS mitigation mechanisms or firewalling in general.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_stop_processing_drop_packet"]}]}], "helperCallParams": {}, "startLine": 60, "endLine": 90, "File": "/home/sayandes/opened_extraction/examples/katran/handle_icmp.h", "funcName": "send_icmp_reply", "developer_inline_comments": [{"start_line": 19, "end_line": 19, "text": "// the only diff between icmp echo and reply hdrs is type;"}, {"start_line": 20, "end_line": 20, "text": "// in first case it's 8; in second it's 0; so instead of recalc"}, {"start_line": 21, "end_line": 21, "text": "// checksum from ground up we will just adjust it."}], "updateMaps": [], "readMaps": [], "input": ["void *data", " void *data_end"], "output": "staticinlineint", "helper": ["XDP_DROP"], "compatibleHookpoints": ["xdp"], "source": ["static inline int send_icmp_reply (void *data, void *data_end)\n", "{\n", "    struct iphdr *iph;\n", "    struct icmphdr *icmp_hdr;\n", "    __u32 tmp_addr = 0;\n", "    __u64 csum = 0;\n", "    __u64 off = 0;\n", "    if ((data + sizeof (struct ethhdr) + sizeof (struct iphdr) + sizeof (struct icmphdr)) > data_end) {\n", "        return XDP_DROP;\n", "    }\n", "    off += sizeof (struct ethhdr);\n", "    iph = data + off;\n", "    off += sizeof (struct iphdr);\n", "    icmp_hdr = data + off;\n", "    icmp_hdr->type = ICMP_ECHOREPLY;\n", "    icmp_hdr->checksum += 0x0008;\n", "    iph->ttl = DEFAULT_TTL;\n", "    tmp_addr = iph->daddr;\n", "    iph->daddr = iph->saddr;\n", "    iph->saddr = tmp_addr;\n", "    iph->check = 0;\n", "    ipv4_csum_inline (iph, &csum);\n", "    iph->check = csum;\n", "    return swap_mac_and_send (data, data_end);\n", "}\n"], "called_function_list": ["swap_mac_and_send", "ipv4_csum_inline"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "send_icmp6_reply": [{"capabilities": [{"capability": "pkt_stop_processing_drop_packet", "pkt_stop_processing_drop_packet": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_DROP", "Return": 1, "Description": "will drop the packet right at the driver level without wasting any further resources. This is in particular useful for BPF programs implementing DDoS mitigation mechanisms or firewalling in general.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_stop_processing_drop_packet"]}]}], "helperCallParams": {}, "startLine": 92, "endLine": 117, "File": "/home/sayandes/opened_extraction/examples/katran/handle_icmp.h", "funcName": "send_icmp6_reply", "developer_inline_comments": [{"start_line": 17, "end_line": 17, "text": "// the only diff between icmp echo and reply hdrs is type;"}, {"start_line": 18, "end_line": 18, "text": "// in first case it's 128; in second it's 129; so instead of recalc"}, {"start_line": 19, "end_line": 19, "text": "// checksum from ground up we will just adjust it."}], "updateMaps": [], "readMaps": [], "input": ["void *data", " void *data_end"], "output": "staticinlineint", "helper": ["XDP_DROP"], "compatibleHookpoints": ["xdp"], "source": ["static inline int send_icmp6_reply (void *data, void *data_end)\n", "{\n", "    struct ipv6hdr *ip6h;\n", "    struct icmp6hdr *icmp_hdr;\n", "    __be32 tmp_addr [4];\n", "    __u64 off = 0;\n", "    if ((data + sizeof (struct ethhdr) + sizeof (struct ipv6hdr) + sizeof (struct icmp6hdr)) > data_end) {\n", "        return XDP_DROP;\n", "    }\n", "    off += sizeof (struct ethhdr);\n", "    ip6h = data + off;\n", "    off += sizeof (struct ipv6hdr);\n", "    icmp_hdr = data + off;\n", "    icmp_hdr->icmp6_type = ICMPV6_ECHO_REPLY;\n", "    icmp_hdr->icmp6_cksum -= 0x0001;\n", "    ip6h->hop_limit = DEFAULT_TTL;\n", "    memcpy (tmp_addr, ip6h->saddr.s6_addr32, 16);\n", "    memcpy (ip6h->saddr.s6_addr32, ip6h->daddr.s6_addr32, 16);\n", "    memcpy (ip6h->daddr.s6_addr32, tmp_addr, 16);\n", "    return swap_mac_and_send (data, data_end);\n", "}\n"], "called_function_list": ["swap_mac_and_send"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "send_icmp4_too_big": [{"capabilities": [{"capability": "pkt_alter_or_redo_processing_or_interface", "pkt_alter_or_redo_processing_or_interface": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_TX", "Return": 3, "Description": "an efficient option to transmit the network packet out of the same NIC it just arrived on again. This is typically useful when few nodes are implementing, for example, firewalling with subsequent load balancing in a cluster and thus act as a hairpinned load balancer pushing the incoming packets back into the switch after rewriting them in XDP BPF.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_alter_or_redo_processing_or_interface"]}]}, {"capability": "pkt_stop_processing_drop_packet", "pkt_stop_processing_drop_packet": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_DROP", "Return": 1, "Description": "will drop the packet right at the driver level without wasting any further resources. This is in particular useful for BPF programs implementing DDoS mitigation mechanisms or firewalling in general.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_stop_processing_drop_packet"]}]}], "helperCallParams": {}, "startLine": 119, "endLine": 162, "File": "/home/sayandes/opened_extraction/examples/katran/handle_icmp.h", "funcName": "send_icmp4_too_big", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct xdp_md *xdp"], "output": "staticinlineint", "helper": ["XDP_TX", "XDP_DROP"], "compatibleHookpoints": ["xdp"], "source": ["static inline int send_icmp4_too_big (struct xdp_md *xdp)\n", "{\n", "    int headroom = (int) sizeof (struct iphdr) + (int) sizeof (struct icmphdr);\n", "    if (bpf_xdp_adjust_head (xdp, 0 - headroom)) {\n", "        return XDP_DROP;\n", "    }\n", "    void *data = (void *) (long) xdp->data;\n", "    void *data_end = (void *) (long) xdp->data_end;\n", "    if (data + (ICMP_TOOBIG_SIZE + headroom) > data_end) {\n", "        return XDP_DROP;\n", "    }\n", "    struct iphdr *iph, *orig_iph;\n", "    struct ethhdr *orig_eth;\n", "    struct icmphdr *icmp_hdr;\n", "    __u64 csum = 0;\n", "    __u64 off = 0;\n", "    orig_eth = data + headroom;\n", "    swap_mac (data, orig_eth);\n", "    off += sizeof (struct ethhdr);\n", "    iph = data + off;\n", "    off += sizeof (struct iphdr);\n", "    icmp_hdr = data + off;\n", "    off += sizeof (struct icmphdr);\n", "    orig_iph = data + off;\n", "    icmp_hdr->type = ICMP_DEST_UNREACH;\n", "    icmp_hdr->code = ICMP_FRAG_NEEDED;\n", "    icmp_hdr->un.frag.mtu = bpf_htons (MAX_PCKT_SIZE - sizeof (struct ethhdr));\n", "    icmp_hdr->checksum = 0;\n", "    ipv4_csum (icmp_hdr, ICMP_TOOBIG_PAYLOAD_SIZE, &csum);\n", "    icmp_hdr->checksum = csum;\n", "    iph->ttl = DEFAULT_TTL;\n", "    iph->daddr = orig_iph->saddr;\n", "    iph->saddr = orig_iph->daddr;\n", "    iph->version = 4;\n", "    iph->ihl = 5;\n", "    iph->protocol = IPPROTO_ICMP;\n", "    iph->tos = 0;\n", "    iph->tot_len = bpf_htons (ICMP_TOOBIG_SIZE + headroom - sizeof (struct ethhdr));\n", "    iph->check = 0;\n", "    csum = 0;\n", "    ipv4_csum (iph, sizeof (struct iphdr), &csum);\n", "    iph->check = csum;\n", "    return XDP_TX;\n", "}\n"], "called_function_list": ["swap_mac", "ipv4_csum"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "send_icmp6_too_big": [{"capabilities": [{"capability": "pkt_alter_or_redo_processing_or_interface", "pkt_alter_or_redo_processing_or_interface": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_TX", "Return": 3, "Description": "an efficient option to transmit the network packet out of the same NIC it just arrived on again. This is typically useful when few nodes are implementing, for example, firewalling with subsequent load balancing in a cluster and thus act as a hairpinned load balancer pushing the incoming packets back into the switch after rewriting them in XDP BPF.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_alter_or_redo_processing_or_interface"]}]}, {"capability": "pkt_stop_processing_drop_packet", "pkt_stop_processing_drop_packet": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_DROP", "Return": 1, "Description": "will drop the packet right at the driver level without wasting any further resources. This is in particular useful for BPF programs implementing DDoS mitigation mechanisms or firewalling in general.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_stop_processing_drop_packet"]}]}], "helperCallParams": {}, "startLine": 164, "endLine": 203, "File": "/home/sayandes/opened_extraction/examples/katran/handle_icmp.h", "funcName": "send_icmp6_too_big", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct xdp_md *xdp"], "output": "staticinlineint", "helper": ["XDP_TX", "XDP_DROP"], "compatibleHookpoints": ["xdp"], "source": ["static inline int send_icmp6_too_big (struct xdp_md *xdp)\n", "{\n", "    int headroom = (int) sizeof (struct ipv6hdr) + (int) sizeof (struct icmp6hdr);\n", "    if (bpf_xdp_adjust_head (xdp, 0 - headroom)) {\n", "        return XDP_DROP;\n", "    }\n", "    void *data = (void *) (long) xdp->data;\n", "    void *data_end = (void *) (long) xdp->data_end;\n", "    if (data + (ICMP6_TOOBIG_SIZE + headroom) > data_end) {\n", "        return XDP_DROP;\n", "    }\n", "    struct ipv6hdr *ip6h, *orig_ip6h;\n", "    struct ethhdr *orig_eth;\n", "    struct icmp6hdr *icmp6_hdr;\n", "    __u64 csum = 0;\n", "    __u64 off = 0;\n", "    orig_eth = data + headroom;\n", "    swap_mac (data, orig_eth);\n", "    off += sizeof (struct ethhdr);\n", "    ip6h = data + off;\n", "    off += sizeof (struct ipv6hdr);\n", "    icmp6_hdr = data + off;\n", "    off += sizeof (struct icmp6hdr);\n", "    orig_ip6h = data + off;\n", "    ip6h->version = 6;\n", "    ip6h->priority = 0;\n", "    ip6h->nexthdr = IPPROTO_ICMPV6;\n", "    ip6h->hop_limit = DEFAULT_TTL;\n", "    ip6h->payload_len = bpf_htons (ICMP6_TOOBIG_PAYLOAD_SIZE);\n", "    memset (ip6h->flow_lbl, 0, sizeof (ip6h->flow_lbl));\n", "    memcpy (ip6h->daddr.s6_addr32, orig_ip6h->saddr.s6_addr32, 16);\n", "    memcpy (ip6h->saddr.s6_addr32, orig_ip6h->daddr.s6_addr32, 16);\n", "    icmp6_hdr->icmp6_type = ICMPV6_PKT_TOOBIG;\n", "    icmp6_hdr->icmp6_code = 0;\n", "    icmp6_hdr->icmp6_mtu = bpf_htonl (MAX_PCKT_SIZE - sizeof (struct ethhdr));\n", "    icmp6_hdr->icmp6_cksum = 0;\n", "    ipv6_csum (icmp6_hdr, ICMP6_TOOBIG_PAYLOAD_SIZE, &csum, ip6h);\n", "    icmp6_hdr->icmp6_cksum = csum;\n", "    return XDP_TX;\n", "}\n"], "called_function_list": ["swap_mac", "ipv6_csum"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "send_icmp_too_big": [{"capabilities": [{"capability": "pkt_stop_processing_drop_packet", "pkt_stop_processing_drop_packet": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_DROP", "Return": 1, "Description": "will drop the packet right at the driver level without wasting any further resources. This is in particular useful for BPF programs implementing DDoS mitigation mechanisms or firewalling in general.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_stop_processing_drop_packet"]}]}], "helperCallParams": {}, "startLine": 205, "endLine": 221, "File": "/home/sayandes/opened_extraction/examples/katran/handle_icmp.h", "funcName": "send_icmp_too_big", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct xdp_md *xdp", " bool is_ipv6", " int pckt_size"], "output": "staticinlineint", "helper": ["XDP_DROP"], "compatibleHookpoints": ["xdp"], "source": ["static inline int send_icmp_too_big (struct xdp_md *xdp, bool is_ipv6, int pckt_size)\n", "{\n", "    int offset = pckt_size;\n", "    if (is_ipv6) {\n", "        offset -= ICMP6_TOOBIG_SIZE;\n", "    }\n", "    else {\n", "        offset -= ICMP_TOOBIG_SIZE;\n", "    }\n", "    if (bpf_xdp_adjust_tail (xdp, 0 - offset)) {\n", "        return XDP_DROP;\n", "    }\n", "    if (is_ipv6) {\n", "        return send_icmp6_too_big (xdp);\n", "    }\n", "    else {\n", "        return send_icmp4_too_big (xdp);\n", "    }\n", "}\n"], "called_function_list": ["send_icmp4_too_big", "send_icmp6_too_big"], "call_depth": 3, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "parse_icmpv6": [{"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_PASS", "Return": 2, "Description": "The XDP_PASS return code means that the packet is allowed to be passed up to the kernel\u2019s networking stack. Meaning, the current CPU that was processing this packet now allocates a skb, populates it, and passes it onwards into the GRO engine. This would be equivalent to the default packet handling behavior without XDP.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_go_to_next_module"]}]}, {"capability": "pkt_stop_processing_drop_packet", "pkt_stop_processing_drop_packet": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_DROP", "Return": 1, "Description": "will drop the packet right at the driver level without wasting any further resources. This is in particular useful for BPF programs implementing DDoS mitigation mechanisms or firewalling in general.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_stop_processing_drop_packet"]}]}], "helperCallParams": {}, "startLine": 223, "endLine": 253, "File": "/home/sayandes/opened_extraction/examples/katran/handle_icmp.h", "funcName": "parse_icmpv6", "developer_inline_comments": [{"start_line": 20, "end_line": 20, "text": "// data partition of icmp 'pkt too big' contains header (and as much data as"}, {"start_line": 21, "end_line": 21, "text": "// as possible) of the packet, which has trigered this icmp."}], "updateMaps": [], "readMaps": [], "input": ["void *data", " void *data_end", " __u64 off", " struct packet_description *pckt"], "output": "staticinlineint", "helper": ["XDP_PASS", "XDP_DROP"], "compatibleHookpoints": ["xdp"], "source": ["static inline int parse_icmpv6 (void *data, void *data_end, __u64 off, struct packet_description *pckt)\n", "{\n", "    struct icmp6hdr *icmp_hdr;\n", "    struct ipv6hdr *ip6h;\n", "    icmp_hdr = data + off;\n", "    if (icmp_hdr + 1 > data_end) {\n", "        return XDP_DROP;\n", "    }\n", "    if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {\n", "        return send_icmp6_reply (data, data_end);\n", "    }\n", "    if ((icmp_hdr->icmp6_type != ICMPV6_PKT_TOOBIG) && (icmp_hdr->icmp6_type != ICMPV6_DEST_UNREACH)) {\n", "        return XDP_PASS;\n", "    }\n", "    off += sizeof (struct icmp6hdr);\n", "    ip6h = data + off;\n", "    if (ip6h + 1 > data_end) {\n", "        return XDP_DROP;\n", "    }\n", "    pckt->flow.proto = ip6h->nexthdr;\n", "    pckt->flags |= F_ICMP;\n", "    memcpy (pckt->flow.srcv6, ip6h->daddr.s6_addr32, 16);\n", "    memcpy (pckt->flow.dstv6, ip6h->saddr.s6_addr32, 16);\n", "    return FURTHER_PROCESSING;\n", "}\n"], "called_function_list": ["send_icmp6_reply"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "parse_icmp": [{"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_PASS", "Return": 2, "Description": "The XDP_PASS return code means that the packet is allowed to be passed up to the kernel\u2019s networking stack. Meaning, the current CPU that was processing this packet now allocates a skb, populates it, and passes it onwards into the GRO engine. This would be equivalent to the default packet handling behavior without XDP.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_go_to_next_module"]}]}, {"capability": "pkt_stop_processing_drop_packet", "pkt_stop_processing_drop_packet": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_DROP", "Return": 1, "Description": "will drop the packet right at the driver level without wasting any further resources. This is in particular useful for BPF programs implementing DDoS mitigation mechanisms or firewalling in general.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_stop_processing_drop_packet"]}]}], "helperCallParams": {}, "startLine": 255, "endLine": 285, "File": "/home/sayandes/opened_extraction/examples/katran/handle_icmp.h", "funcName": "parse_icmp", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["void *data", " void *data_end", " __u64 off", " struct packet_description *pckt"], "output": "staticinlineint", "helper": ["XDP_PASS", "XDP_DROP"], "compatibleHookpoints": ["xdp"], "source": ["static inline int parse_icmp (void *data, void *data_end, __u64 off, struct packet_description *pckt)\n", "{\n", "    struct icmphdr *icmp_hdr;\n", "    struct iphdr *iph;\n", "    icmp_hdr = data + off;\n", "    if (icmp_hdr + 1 > data_end) {\n", "        return XDP_DROP;\n", "    }\n", "    if (icmp_hdr->type == ICMP_ECHO) {\n", "        return send_icmp_reply (data, data_end);\n", "    }\n", "    if (icmp_hdr->type != ICMP_DEST_UNREACH) {\n", "        return XDP_PASS;\n", "    }\n", "    off += sizeof (struct icmphdr);\n", "    iph = data + off;\n", "    if (iph + 1 > data_end) {\n", "        return XDP_DROP;\n", "    }\n", "    if (iph->ihl != 5) {\n", "        return XDP_DROP;\n", "    }\n", "    pckt->flow.proto = iph->protocol;\n", "    pckt->flags |= F_ICMP;\n", "    pckt->flow.src = iph->daddr;\n", "    pckt->flow.dst = iph->saddr;\n", "    return FURTHER_PROCESSING;\n", "}\n"], "called_function_list": ["send_icmp_reply"], "call_depth": 3, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}]}
