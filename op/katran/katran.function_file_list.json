{"is_under_flood": [{"fileName": "/root/examples/katran/balancer_kern.c", "startLine": "25", "endLine": "50", "capability": {"capability": [{"map_read": [{"Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": "Map value associated to key, or NULL if no entry was found.", "Return Type": "void", "Function Name": "*bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}, {"read_sys_info": [{"Description": "Return the time elapsed since system boot , in nanoseconds. ", "Return": "Current ktime.", "Return Type": "u64", "Function Name": "bpf_ktime_get_ns", "Input Params": ["{Type: voi ,Var: void}"]}]}], "helperCallParams": {"bpf_map_lookup_elem": [{"opVar": "  struct lb_stats* conn_rate_stats ", "inpVar": ["      &stats", " &conn_rate_key"]}], "bpf_ktime_get_ns": [{"opVar": "    *cur_time ", "inpVar": [" "]}]}}}], "get_packet_dst": [{"fileName": "/root/examples/katran/balancer_kern.c", "startLine": "53", "endLine": "131", "capability": {"capability": [{"map_read": [{"Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": "Map value associated to key, or NULL if no entry was found.", "Return Type": "void", "Function Name": "*bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}, {"map_update": [{"Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of:BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ", "Return": "0 on success, or a negative error in case of failure.", "Return Type": "int", "Function Name": "bpf_map_update_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}", "{Type:  const void ,Var: *value}", "{Type:  u64 ,Var: flags}"]}]}], "helperCallParams": {"bpf_map_lookup_elem": [{"opVar": "      lpm_val ", "inpVar": [" &lpm_src_v6", " &lpm_key_v6"]}, {"opVar": "      lpm_val ", "inpVar": [" &lpm_src_v4", " &lpm_key_v4"]}, {"opVar": "    struct lb_stats* data_stats ", "inpVar": [" &stats", " &stats_key"]}, {"opVar": "    real_pos ", "inpVar": [" &ch_rings", " &key"]}, {"opVar": "  *real ", "inpVar": [" &reals", " &key"]}], "bpf_map_update_elem": [{"opVar": "NA", "inpVar": ["    lru_map", " &pckt->flow", " &new_dst_lru", " BPF_ANY"]}]}}}], "connection_table_lookup": [{"fileName": "/root/examples/katran/balancer_kern.c", "startLine": "133", "endLine": "156", "capability": {"capability": [{"map_read": [{"Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": "Map value associated to key, or NULL if no entry was found.", "Return Type": "void", "Function Name": "*bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}, {"read_sys_info": [{"Description": "Return the time elapsed since system boot , in nanoseconds. ", "Return": "Current ktime.", "Return Type": "u64", "Function Name": "bpf_ktime_get_ns", "Input Params": ["{Type: voi ,Var: void}"]}]}], "helperCallParams": {"bpf_map_lookup_elem": [{"opVar": "  dst_lru ", "inpVar": [" lru_map", " &pckt->flow"]}, {"opVar": "  *real ", "inpVar": [" &reals", " &key"]}], "bpf_ktime_get_ns": [{"opVar": "    cur_time ", "inpVar": [" "]}]}}}], "process_l3_headers": [{"fileName": "/root/examples/katran/balancer_kern.c", "startLine": "158", "endLine": "230", "capability": {"capability": [], "helperCallParams": {}}}, {"fileName": "/root/examples/katran/decap_kern.c", "startLine": "34", "endLine": "83", "capability": {"capability": [], "helperCallParams": {}}}], "check_decap_dst": [{"fileName": "/root/examples/katran/balancer_kern.c", "startLine": "233", "endLine": "255", "capability": {"capability": [{"map_read": [{"Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": "Map value associated to key, or NULL if no entry was found.", "Return Type": "void", "Function Name": "*bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"bpf_map_lookup_elem": [{"opVar": "    __u32* decap_dst_flags ", "inpVar": [" &decap_dst", " &dst_addr"]}, {"opVar": "    data_stats ", "inpVar": [" &stats", " &stats_key"]}]}}}], "reals_have_same_addr": [{"fileName": "/root/examples/katran/balancer_kern.c", "startLine": "261", "endLine": "277", "capability": {"capability": [], "helperCallParams": {}}}], "perform_global_lru_lookup": [{"fileName": "/root/examples/katran/balancer_kern.c", "startLine": "279", "endLine": "335", "capability": {"capability": [{"map_read": [{"Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": "Map value associated to key, or NULL if no entry was found.", "Return Type": "void", "Function Name": "*bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"bpf_map_lookup_elem": [{"opVar": "    void* g_lru_map ", "inpVar": [" &global_lru_maps", " &cpu_num"]}, {"opVar": "  struct lb_stats* global_lru_stats ", "inpVar": ["      &stats", " &global_lru_stats_key"]}, {"opVar": "      struct lb_stats* global_lru_mismatch_stats ", "inpVar": ["          &stats", " &global_lru_mismatch_stats_key"]}]}}}], "process_encaped_ipip_pckt": [{"fileName": "/root/examples/katran/balancer_kern.c", "startLine": "340", "endLine": "387", "capability": {"capability": [], "helperCallParams": {}}}, {"fileName": "/root/examples/katran/decap_kern.c", "startLine": "85", "endLine": "120", "capability": {"capability": [], "helperCallParams": {}}}], "process_encaped_gue_pckt": [{"fileName": "/root/examples/katran/balancer_kern.c", "startLine": "391", "endLine": "441", "capability": {"capability": [], "helperCallParams": {}}}, {"fileName": "/root/examples/katran/decap_kern.c", "startLine": "123", "endLine": "161", "capability": {"capability": [], "helperCallParams": {}}}], "increment_quic_cid_version_stats": [{"fileName": "/root/examples/katran/balancer_kern.c", "startLine": "444", "endLine": "457", "capability": {"capability": [{"map_read": [{"Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": "Map value associated to key, or NULL if no entry was found.", "Return Type": "void", "Function Name": "*bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"bpf_map_lookup_elem": [{"opVar": "  struct lb_stats* quic_version ", "inpVar": ["      &stats", " &quic_version_stats_key"]}]}}}], "increment_quic_cid_drop_no_real": [{"fileName": "/root/examples/katran/balancer_kern.c", "startLine": "459", "endLine": "468", "capability": {"capability": [{"map_read": [{"Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": "Map value associated to key, or NULL if no entry was found.", "Return Type": "void", "Function Name": "*bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"bpf_map_lookup_elem": [{"opVar": "  struct lb_stats* quic_drop ", "inpVar": ["      &stats", " &quic_drop_stats_key"]}]}}}], "increment_quic_cid_drop_real_0": [{"fileName": "/root/examples/katran/balancer_kern.c", "startLine": "470", "endLine": "478", "capability": {"capability": [{"map_read": [{"Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": "Map value associated to key, or NULL if no entry was found.", "Return Type": "void", "Function Name": "*bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"bpf_map_lookup_elem": [{"opVar": "  struct lb_stats* quic_drop ", "inpVar": ["      &stats", " &quic_drop_stats_key"]}]}}}], "process_packet": [{"fileName": "/root/examples/katran/balancer_kern.c", "startLine": "480", "endLine": "791", "capability": {"capability": [{"map_read": [{"Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": "Map value associated to key, or NULL if no entry was found.", "Return Type": "void", "Function Name": "*bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}, {"read_sys_info": [{"Description": "Get the SMP (symmetric multiprocessing) processor id. Note that all programs run with preemption disabled , which means that the SMP processor id is stable during all the execution of the program. ", "Return": "The SMP id of the processor running the program.", "Return Type": "u32", "Function Name": "bpf_get_smp_processor_id", "Input Params": ["{Type: voi ,Var: void}"]}]}], "helperCallParams": {"bpf_map_lookup_elem": [{"opVar": "  vip_info ", "inpVar": [" &vip_map", " &vip"]}, {"opVar": "    vip_info ", "inpVar": [" &vip_map", " &vip"]}, {"opVar": "    data_stats ", "inpVar": [" &stats", " &stats_key"]}, {"opVar": "  data_stats ", "inpVar": [" &stats", " &stats_key"]}, {"opVar": "    struct lb_stats* quic_stats ", "inpVar": [" &stats", " &quic_stats_key"]}, {"opVar": "      __u32* real_pos ", "inpVar": [" &server_id_map", " &key"]}, {"opVar": "          dst ", "inpVar": [" &reals", " &key"]}, {"opVar": "    void* lru_map ", "inpVar": [" &lru_mapping", " &cpu_num"]}, {"opVar": "      struct lb_stats* lru_stats ", "inpVar": [" &stats", " &lru_stats_key"]}, {"opVar": "      struct lb_stats* routing_stats ", "inpVar": ["          &stats", " &routing_stats_key"]}, {"opVar": "        struct lb_stats* lru_stats ", "inpVar": ["            &stats", " &lru_stats_key"]}, {"opVar": "        cval ", "inpVar": [" &ctl_array", " &mac_addr_pos"]}, {"opVar": "  data_stats ", "inpVar": [" &stats", " &vip_num"]}, {"opVar": "    data_stats ", "inpVar": [" &reals_stats", " &pckt.real_index"]}], "bpf_get_smp_processor_id": [{"opVar": "        __u32 cpu_num ", "inpVar": [" "]}]}}}, {"fileName": "/root/examples/katran/decap_kern.c", "startLine": "164", "endLine": "221", "capability": {"capability": [{"map_read": [{"Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": "Map value associated to key, or NULL if no entry was found.", "Return Type": "void", "Function Name": "*bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"bpf_map_lookup_elem": [{"opVar": "  data_stats ", "inpVar": [" &decap_counters", " &key"]}]}}}], "balancer_ingress": [{"fileName": "/root/examples/katran/balancer_kern.c", "startLine": "794", "endLine": "817", "capability": {"capability": [], "helperCallParams": {}}}], "get_packet_hash": [{"fileName": "/root/examples/katran/balancer_kern.c", "startLine": "818", "endLine": "827", "capability": {"capability": [], "helperCallParams": {}}}], "healthcheck_encap": [{"fileName": "/root/examples/katran/healthchecking_kern.c", "startLine": "34", "endLine": "139", "capability": {"capability": [{"map_read": [{"Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": "Map value associated to key, or NULL if no entry was found.", "Return Type": "void", "Function Name": "*bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"bpf_map_lookup_elem": [{"opVar": "  prog_stats ", "inpVar": [" &hc_stats_map", " &stats_key"]}, {"opVar": "    struct hc_real_definition* real ", "inpVar": [" &hc_reals_map", " &somark"]}, {"opVar": "  #endif  __u32* intf_ifindex ", "inpVar": [" &hc_ctrl_map", " &key"]}, {"opVar": "  esrc ", "inpVar": [" &hc_pckt_macs", " &key"]}, {"opVar": "  edst ", "inpVar": [" &hc_pckt_macs", " &key"]}, {"opVar": "    __u32* hc_key_cntr_index ", "inpVar": [" &hc_key_map", " &hckey"]}, {"opVar": "      __u32* packets_processed_for_hc_key ", "inpVar": ["          &per_hckey_stats", " hc_key_cntr_index"]}], "bpf_redirect": [{"opVar": "NA", "inpVar": ["              return *intf_ifindex", " REDIRECT_EGRESS"]}]}}}, {"fileName": "/root/examples/katran/healthchecking_ipip.c", "startLine": "89", "endLine": "157", "capability": {"capability": [{"update_pkt": [{"Description": "Populate tunnel metadata for packet associated to skb. The tunnel metadata is set to the contents of <[ key ]>(IP: 1) , of size. The <[ flags ]>(IP: 3) can be set to a combination of the following values:BPF_F_TUNINFO_IPV6Indicate that the tunnel is based on IPv6 protocol instead of IPv4. BPF_F_ZERO_CSUM_TXFor IPv4 packets , add a flag to tunnel metadata indicating that checksum computation should be skipped and checksum set to zeroes. BPF_F_DONT_FRAGMENTAdd a flag to tunnel metadata indicating that the packet should not be fragmented. BPF_F_SEQ_NUMBERAdd a flag to tunnel metadata indicating that a sequence number should be added to tunnel header before sending the packet. This flag was added for GRE encapsulation , but might be used with other protocols as well in the future. Here is a typical usage on the transmit path:struct bpf_tunnel_key key; populate <[ key ]>(IP: 1) . . . bpf_skb_set_tunnel_key(skb , &key , sizeof(key) , 0);bpf_clone_redirect(skb , vxlan_dev_ifindex , 0);See also the description of the bpf_skb_get_tunnel_key() helper for additional information. ", "Return": "0 on success, or a negative error in case of failure.", "Return Type": "int", "Function Name": "bpf_skb_set_tunnel_key", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  struct bpf_tunnel_key ,Var: *key}", "{Type:  u32 ,Var: size}", "{Type:  u64 ,Var: flags}"]}]}, {"map_read": [{"Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": "Map value associated to key, or NULL if no entry was found.", "Return Type": "void", "Function Name": "*bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"bpf_map_lookup_elem": [{"opVar": "  prog_stats ", "inpVar": [" &hc_stats_map", " &stats_key"]}, {"opVar": "    struct hc_real_definition* real ", "inpVar": [" &hc_reals_map", " &somark"]}, {"opVar": "    __u32* v4_intf_ifindex ", "inpVar": [" &hc_ctrl_map", " &v4_intf_pos"]}, {"opVar": "    __u32* v6_intf_ifindex ", "inpVar": [" &hc_ctrl_map", " &v6_intf_pos"]}], "bpf_skb_set_tunnel_key": [{"opVar": "NA", "inpVar": ["  skb", " &tkey", " sizeoftkey", " tun_flag"]}], "bpf_redirect": [{"opVar": "NA", "inpVar": ["  return ifindex", " REDIRECT_EGRESS"]}]}}}], "xdp_root": [{"fileName": "/root/examples/katran/xdp_root.c", "startLine": "30", "endLine": "37", "capability": {"capability": [], "helperCallParams": {"bpf_tail_call": [{"opVar": "NA", "inpVar": ["    ctx", " &root_array", " i"]}]}}}], "xdp_val": [{"fileName": "/root/examples/katran/xdp_root.c", "startLine": "40", "endLine": "47", "capability": {"capability": [], "helperCallParams": {"bpf_tail_call": [{"opVar": "NA", "inpVar": ["    ctx", " &root_array", " i"]}]}}}], "xdpdecap": [{"fileName": "/root/examples/katran/decap_kern.c", "startLine": "224", "endLine": "247", "capability": {"capability": [], "helperCallParams": {}}}], "xdp_prog_simple": [{"fileName": "/root/examples/katran/x.c", "startLine": "9", "endLine": "13", "capability": {"capability": [], "helperCallParams": {}}}], "pktcntr": [{"fileName": "/root/examples/katran/xdp_pktcntr.c", "startLine": "46", "endLine": "62", "capability": {"capability": [{"map_read": [{"Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": "Map value associated to key, or NULL if no entry was found.", "Return Type": "void", "Function Name": "*bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"bpf_map_lookup_elem": [{"opVar": "  __u32* flag ", "inpVar": [" &ctl_array", " &ctl_flag_pos"]}, {"opVar": "  __u64* cntr_val ", "inpVar": [" &cntrs_array", " &cntr_pos"]}]}}}], "csum_fold_helper": [{"fileName": "/root/examples/katran/csum_helpers.h", "startLine": "30", "endLine": "39", "capability": {"capability": [], "helperCallParams": {}}}], "min_helper": [{"fileName": "/root/examples/katran/csum_helpers.h", "startLine": "41", "endLine": "43", "capability": {"capability": [], "helperCallParams": {}}}], "ipv4_csum": [{"fileName": "/root/examples/katran/csum_helpers.h", "startLine": "45", "endLine": "49", "capability": {"capability": [{"read_skb": [{"Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways:With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with bpf_l3_csum_replace() and bpf_l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with bpf_csum_diff(). ", "Return": "The checksum result, or a negative error code in case of failure.", "Return Type": "s64", "Function Name": "bpf_csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"]}]}], "helperCallParams": {"bpf_csum_diff": [{"opVar": "  *csum ", "inpVar": [" 0", " 0", " data_start", " data_size", " *csum"]}]}}}], "ipv4_csum_inline": [{"fileName": "/root/examples/katran/csum_helpers.h", "startLine": "51", "endLine": "60", "capability": {"capability": [], "helperCallParams": {}}}], "ipv4_l4_csum": [{"fileName": "/root/examples/katran/csum_helpers.h", "startLine": "62", "endLine": "73", "capability": {"capability": [{"read_skb": [{"Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways:With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with bpf_l3_csum_replace() and bpf_l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with bpf_csum_diff(). ", "Return": "The checksum result, or a negative error code in case of failure.", "Return Type": "s64", "Function Name": "bpf_csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"]}]}], "helperCallParams": {"bpf_csum_diff": [{"opVar": "  *csum ", "inpVar": [" 0", " 0", " &iph->saddr", " sizeof__be32", " *csum"]}, {"opVar": "  *csum ", "inpVar": [" 0", " 0", " &iph->daddr", " sizeof__be32", " *csum"]}, {"opVar": "  *csum ", "inpVar": [" 0", " 0", " &tmp", " sizeof__u32", " *csum"]}, {"opVar": "  *csum ", "inpVar": [" 0", " 0", " &tmp", " sizeof__u32", " *csum"]}, {"opVar": "  *csum ", "inpVar": [" 0", " 0", " data_start", " data_size", " *csum"]}]}}}], "ipv6_csum": [{"fileName": "/root/examples/katran/csum_helpers.h", "startLine": "75", "endLine": "88", "capability": {"capability": [{"read_skb": [{"Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways:With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with bpf_l3_csum_replace() and bpf_l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with bpf_csum_diff(). ", "Return": "The checksum result, or a negative error code in case of failure.", "Return Type": "s64", "Function Name": "bpf_csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"]}]}], "helperCallParams": {"bpf_csum_diff": [{"opVar": "  *csum ", "inpVar": [" 0", " 0", " &ip6h->saddr", " sizeofstruct in6_addr", " *csum"]}, {"opVar": "  *csum ", "inpVar": [" 0", " 0", " &ip6h->daddr", " sizeofstruct in6_addr", " *csum"]}, {"opVar": "  *csum ", "inpVar": [" 0", " 0", " &tmp", " sizeof__u32", " *csum"]}, {"opVar": "  *csum ", "inpVar": [" 0", " 0", " &tmp", " sizeof__u32", " *csum"]}, {"opVar": "    *csum ", "inpVar": [" 0", " 0", " data_start", " data_size", " *csum"]}]}}}], "add_pseudo_ipv6_header": [{"fileName": "/root/examples/katran/csum_helpers.h", "startLine": "95", "endLine": "127", "capability": {"capability": [{"read_skb": [{"Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways:With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with bpf_l3_csum_replace() and bpf_l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with bpf_csum_diff(). ", "Return": "The checksum result, or a negative error code in case of failure.", "Return Type": "s64", "Function Name": "bpf_csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"]}]}], "helperCallParams": {"bpf_csum_diff": [{"opVar": "  ret ", "inpVar": [" 0", " 0", " &ip6h->saddr", " sizeofstruct in6_addr", " *csum"]}, {"opVar": "  ret ", "inpVar": [" 0", " 0", " &ip6h->daddr", " sizeofstruct in6_addr", " *csum"]}, {"opVar": "  ret ", "inpVar": [" 0", " 0", " &tmp", " sizeof__u32", " *csum"]}, {"opVar": "  ret ", "inpVar": [" 0", " 0", " &tmp", " sizeof__u32", " *csum"]}]}}}], "rem_pseudo_ipv6_header": [{"fileName": "/root/examples/katran/csum_helpers.h", "startLine": "129", "endLine": "158", "capability": {"capability": [{"read_skb": [{"Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways:With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with bpf_l3_csum_replace() and bpf_l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with bpf_csum_diff(). ", "Return": "The checksum result, or a negative error code in case of failure.", "Return Type": "s64", "Function Name": "bpf_csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"]}]}], "helperCallParams": {"bpf_csum_diff": [{"opVar": "  ret ", "inpVar": [" &ip6h->saddr", " sizeofstruct in6_addr", " 0", " 0", " *csum"]}, {"opVar": "  ret ", "inpVar": [" &ip6h->daddr", " sizeofstruct in6_addr", " 0", " 0", " *csum"]}, {"opVar": "  ret ", "inpVar": [" &tmp", " sizeof__u32", " 0", " 0", " *csum"]}, {"opVar": "  ret ", "inpVar": [" &tmp", " sizeof__u32", " 0", " 0", " *csum"]}]}}}], "add_pseudo_ipv4_header": [{"fileName": "/root/examples/katran/csum_helpers.h", "startLine": "160", "endLine": "189", "capability": {"capability": [{"read_skb": [{"Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways:With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with bpf_l3_csum_replace() and bpf_l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with bpf_csum_diff(). ", "Return": "The checksum result, or a negative error code in case of failure.", "Return Type": "s64", "Function Name": "bpf_csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"]}]}], "helperCallParams": {"bpf_csum_diff": [{"opVar": "  ret ", "inpVar": [" 0", " 0", " &iph->saddr", " sizeof__be32", " *csum"]}, {"opVar": "  ret ", "inpVar": [" 0", " 0", " &iph->daddr", " sizeof__be32", " *csum"]}, {"opVar": "  ret ", "inpVar": [" 0", " 0", " &tmp", " sizeof__u32", " *csum"]}, {"opVar": "  ret ", "inpVar": [" 0", " 0", " &tmp", " sizeof__u32", " *csum"]}]}}}], "rem_pseudo_ipv4_header": [{"fileName": "/root/examples/katran/csum_helpers.h", "startLine": "191", "endLine": "220", "capability": {"capability": [{"read_skb": [{"Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways:With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with bpf_l3_csum_replace() and bpf_l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with bpf_csum_diff(). ", "Return": "The checksum result, or a negative error code in case of failure.", "Return Type": "s64", "Function Name": "bpf_csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"]}]}], "helperCallParams": {"bpf_csum_diff": [{"opVar": "  ret ", "inpVar": [" &iph->saddr", " sizeof__be32", " 0", " 0", " *csum"]}, {"opVar": "  ret ", "inpVar": [" &iph->daddr", " sizeof__be32", " 0", " 0", " *csum"]}, {"opVar": "  ret ", "inpVar": [" &tmp", " sizeof__u32", " 0", " 0", " *csum"]}, {"opVar": "  ret ", "inpVar": [" &tmp", " sizeof__u32", " 0", " 0", " *csum"]}]}}}], "gue_csum_v6": [{"fileName": "/root/examples/katran/csum_helpers.h", "startLine": "234", "endLine": "268", "capability": {"capability": [{"read_skb": [{"Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways:With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with bpf_l3_csum_replace() and bpf_l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with bpf_csum_diff(). ", "Return": "The checksum result, or a negative error code in case of failure.", "Return Type": "s64", "Function Name": "bpf_csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"]}]}], "helperCallParams": {"bpf_csum_diff": [{"opVar": "  ret ", "inpVar": [" 0", " 0", " &orig_csum", " sizeof__u32", " seed"]}, {"opVar": "    ret ", "inpVar": [" 0", " 0", " inner_ip6h", " sizeofstruct ipv6hdr", " *csum_in_hdr"]}, {"opVar": "  ret ", "inpVar": [" 0", " 0", " udph", " sizeofstruct udphdr", " *csum_in_hdr"]}]}}}], "gue_csum_v4": [{"fileName": "/root/examples/katran/csum_helpers.h", "startLine": "270", "endLine": "302", "capability": {"capability": [{"read_skb": [{"Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways:With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with bpf_l3_csum_replace() and bpf_l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with bpf_csum_diff(). ", "Return": "The checksum result, or a negative error code in case of failure.", "Return Type": "s64", "Function Name": "bpf_csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"]}]}], "helperCallParams": {"bpf_csum_diff": [{"opVar": "  ret ", "inpVar": [" 0", " 0", " &orig_csum", " sizeof__u32", " seed"]}, {"opVar": "    ret ", "inpVar": [" 0", " 0", " inner_iph", " sizeofstruct iphdr", " *csum_in_hdr"]}, {"opVar": "  ret ", "inpVar": [" 0", " 0", " udph", " sizeofstruct udphdr", " *csum_in_hdr"]}]}}}], "gue_csum_v4_in_v6": [{"fileName": "/root/examples/katran/csum_helpers.h", "startLine": "304", "endLine": "336", "capability": {"capability": [{"read_skb": [{"Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways:With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with bpf_l3_csum_replace() and bpf_l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with bpf_csum_diff(). ", "Return": "The checksum result, or a negative error code in case of failure.", "Return Type": "s64", "Function Name": "bpf_csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"]}]}], "helperCallParams": {"bpf_csum_diff": [{"opVar": "  ret ", "inpVar": [" 0", " 0", " &orig_csum", " sizeof__u32", " seed"]}, {"opVar": "    ret ", "inpVar": [" 0", " 0", " inner_iph", " sizeofstruct iphdr", " *csum_in_hdr"]}, {"opVar": "  ret ", "inpVar": [" 0", " 0", " udph", " sizeofstruct udphdr", " *csum_in_hdr"]}]}}}], "swap_mac_and_send": [{"fileName": "/root/examples/katran/handle_icmp.h", "startLine": "38", "endLine": "48", "capability": {"capability": [], "helperCallParams": {}}}], "swap_mac": [{"fileName": "/root/examples/katran/handle_icmp.h", "startLine": "50", "endLine": "58", "capability": {"capability": [], "helperCallParams": {}}}], "send_icmp_reply": [{"fileName": "/root/examples/katran/handle_icmp.h", "startLine": "60", "endLine": "90", "capability": {"capability": [], "helperCallParams": {}}}], "send_icmp6_reply": [{"fileName": "/root/examples/katran/handle_icmp.h", "startLine": "92", "endLine": "117", "capability": {"capability": [], "helperCallParams": {}}}], "send_icmp4_too_big": [{"fileName": "/root/examples/katran/handle_icmp.h", "startLine": "119", "endLine": "162", "capability": {"capability": [{"update_pkt": [{"Description": "Adjust (move) xdp_md->data by <[ delta ]>(IP: 1) bytes. Note that it is possible to use a negative value for delta. This helper can be used to prepare the packet for pushing or popping headers. A call to this helper is susceptible to change the underlaying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": "0 on success, or a negative error in case of failure.", "Return Type": "int", "Function Name": "bpf_xdp_adjust_head", "Input Params": ["{Type: struct xdp_buff ,Var: *xdp_md}", "{Type:  int ,Var: delta}"]}]}], "helperCallParams": {"bpf_xdp_adjust_head": [{"opVar": "NA", "inpVar": ["  if xdp", " 0 - headroom "]}]}}}], "send_icmp6_too_big": [{"fileName": "/root/examples/katran/handle_icmp.h", "startLine": "164", "endLine": "203", "capability": {"capability": [{"update_pkt": [{"Description": "Adjust (move) xdp_md->data by <[ delta ]>(IP: 1) bytes. Note that it is possible to use a negative value for delta. This helper can be used to prepare the packet for pushing or popping headers. A call to this helper is susceptible to change the underlaying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": "0 on success, or a negative error in case of failure.", "Return Type": "int", "Function Name": "bpf_xdp_adjust_head", "Input Params": ["{Type: struct xdp_buff ,Var: *xdp_md}", "{Type:  int ,Var: delta}"]}]}], "helperCallParams": {"bpf_xdp_adjust_head": [{"opVar": "NA", "inpVar": ["  if xdp", " 0 - headroom "]}]}}}], "send_icmp_too_big": [{"fileName": "/root/examples/katran/handle_icmp.h", "startLine": "205", "endLine": "221", "capability": {"capability": [{"update_pkt": [{"Description": "Adjust (move) xdp_md->data_end by <[ delta ]>(IP: 1) bytes. It is only possible to shrink the packet as of this writing , therefore <[ delta ]>(IP: 1) must be a negative integer. A call to this helper is susceptible to change the underlaying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": "0 on success, or a negative error in case of failure.", "Return Type": "int", "Function Name": "bpf_xdp_adjust_tail", "Input Params": ["{Type: struct xdp_buff ,Var: *xdp_md}", "{Type:  int ,Var: delta}"]}]}], "helperCallParams": {"bpf_xdp_adjust_tail": [{"opVar": "NA", "inpVar": ["    if xdp", " 0 - offset "]}]}}}], "parse_icmpv6": [{"fileName": "/root/examples/katran/handle_icmp.h", "startLine": "223", "endLine": "253", "capability": {"capability": [], "helperCallParams": {}}}], "parse_icmp": [{"fileName": "/root/examples/katran/handle_icmp.h", "startLine": "255", "endLine": "285", "capability": {"capability": [], "helperCallParams": {}}}], "create_v4_hdr": [{"fileName": "/root/examples/katran/encap_helpers.h", "startLine": "31", "endLine": "55", "capability": {"capability": [], "helperCallParams": {}}}], "create_v6_hdr": [{"fileName": "/root/examples/katran/encap_helpers.h", "startLine": "57", "endLine": "77", "capability": {"capability": [], "helperCallParams": {}}}], "create_udp_hdr": [{"fileName": "/root/examples/katran/encap_helpers.h", "startLine": "79", "endLine": "89", "capability": {"capability": [], "helperCallParams": {}}}], "calc_offset": [{"fileName": "/root/examples/katran/pckt_parsing.h", "startLine": "58", "endLine": "74", "capability": {"capability": [], "helperCallParams": {}}}], "parse_udp": [{"fileName": "/root/examples/katran/pckt_parsing.h", "startLine": "76", "endLine": "100", "capability": {"capability": [], "helperCallParams": {}}}], "parse_tcp": [{"fileName": "/root/examples/katran/pckt_parsing.h", "startLine": "102", "endLine": "130", "capability": {"capability": [], "helperCallParams": {}}}], "parse_hdr_opt": [{"fileName": "/root/examples/katran/pckt_parsing.h", "startLine": "144", "endLine": "197", "capability": {"capability": [], "helperCallParams": {}}}], "tcp_hdr_opt_lookup": [{"fileName": "/root/examples/katran/pckt_parsing.h", "startLine": "199", "endLine": "273", "capability": {"capability": [{"map_read": [{"Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": "Map value associated to key, or NULL if no entry was found.", "Return Type": "void", "Function Name": "*bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}, {"map_update": [{"Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of:BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ", "Return": "0 on success, or a negative error in case of failure.", "Return Type": "int", "Function Name": "bpf_map_update_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}", "{Type:  const void ,Var: *value}", "{Type:  u64 ,Var: flags}"]}]}], "helperCallParams": {"bpf_map_lookup_elem": [{"opVar": "  __u32* real_pos ", "inpVar": [" &server_id_map", " &key"]}, {"opVar": "  *real ", "inpVar": [" &reals", " &key"]}, {"opVar": "    struct real_pos_lru* dst_lru ", "inpVar": [" lru_map", " &pckt->flow"]}], "bpf_map_update_elem": [{"opVar": "NA", "inpVar": ["    lru_map", " &pckt->flow", " &new_dst_lru", " BPF_ANY"]}]}}}], "parse_quic": [{"fileName": "/root/examples/katran/pckt_parsing.h", "startLine": "276", "endLine": "335", "capability": {"capability": [], "helperCallParams": {}}}], "rol32": [{"fileName": "/root/examples/katran/jhash.h", "startLine": "7", "endLine": "9", "capability": {"capability": [], "helperCallParams": {}}}], "jhash": [{"fileName": "/root/examples/katran/jhash.h", "startLine": "55", "endLine": "100", "capability": {"capability": [], "helperCallParams": {}}}], "__jhash_nwords": [{"fileName": "/root/examples/katran/jhash.h", "startLine": "102", "endLine": "108", "capability": {"capability": [], "helperCallParams": {}}}], "jhash_2words": [{"fileName": "/root/examples/katran/jhash.h", "startLine": "110", "endLine": "112", "capability": {"capability": [], "helperCallParams": {}}}], "jhash_1word": [{"fileName": "/root/examples/katran/jhash.h", "startLine": "114", "endLine": "116", "capability": {"capability": [], "helperCallParams": {}}}], "set_hc_key": [{"fileName": "/root/examples/katran/healthchecking_helpers.h", "startLine": "37", "endLine": "77", "capability": {"capability": [], "helperCallParams": {}}}], "hc_encap_ipip": [{"fileName": "/root/examples/katran/healthchecking_helpers.h", "startLine": "79", "endLine": "139", "capability": {"capability": [{"update_pkt": [{"Description": "Grow or shrink the room for data in the packet associated to <[ skb ]>(IP: 0) by <[ len_diff ]>(IP: 1) , and according to the selected mode. There is a single supported <[ mode ]>(IP: 2) at this time:BPF_ADJ_ROOM_NET: Adjust room at the network layer (room space is added or removed below the layer 3 header). All values for <[ flags ]>(IP: 3) are reserved for future usage , and must be left at zero. A call to this helper is susceptible to change the underlaying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": "0 on success, or a negative error in case of failure.", "Return Type": "int", "Function Name": "bpf_skb_adjust_room", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  u32 ,Var: len_diff}", "{Type:  u32 ,Var: mode}", "{Type:  u64 ,Var: flags}"]}]}, {"map_read": [{"Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": "Map value associated to key, or NULL if no entry was found.", "Return Type": "void", "Function Name": "*bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"bpf_map_lookup_elem": [{"opVar": "    src ", "inpVar": [" &hc_pckt_srcs_map", " &key"]}, {"opVar": "    src ", "inpVar": [" &hc_pckt_srcs_map", " &key"]}], "bpf_skb_adjust_room": [{"opVar": "NA", "inpVar": ["        if skb", " adjust_len", " BPF_ADJ_ROOM_MAC", " flags "]}, {"opVar": "NA", "inpVar": ["        if skb", " adjust_len", " BPF_ADJ_ROOM_MAC", " flags "]}]}}}], "gue_sport": [{"fileName": "/root/examples/katran/healthchecking_helpers.h", "startLine": "141", "endLine": "143", "capability": {"capability": [], "helperCallParams": {}}}], "hc_encap_gue": [{"fileName": "/root/examples/katran/healthchecking_helpers.h", "startLine": "145", "endLine": "213", "capability": {"capability": [{"update_pkt": [{"Description": "Grow or shrink the room for data in the packet associated to <[ skb ]>(IP: 0) by <[ len_diff ]>(IP: 1) , and according to the selected mode. There is a single supported <[ mode ]>(IP: 2) at this time:BPF_ADJ_ROOM_NET: Adjust room at the network layer (room space is added or removed below the layer 3 header). All values for <[ flags ]>(IP: 3) are reserved for future usage , and must be left at zero. A call to this helper is susceptible to change the underlaying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": "0 on success, or a negative error in case of failure.", "Return Type": "int", "Function Name": "bpf_skb_adjust_room", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  u32 ,Var: len_diff}", "{Type:  u32 ,Var: mode}", "{Type:  u64 ,Var: flags}"]}]}, {"map_read": [{"Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": "Map value associated to key, or NULL if no entry was found.", "Return Type": "void", "Function Name": "*bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"bpf_map_lookup_elem": [{"opVar": "    src ", "inpVar": [" &hc_pckt_srcs_map", " &key"]}, {"opVar": "    src ", "inpVar": [" &hc_pckt_srcs_map", " &key"]}], "bpf_skb_adjust_room": [{"opVar": "NA", "inpVar": ["        if skb", " adjust_len", " BPF_ADJ_ROOM_MAC", " flags "]}, {"opVar": "NA", "inpVar": ["        if skb", " adjust_len", " BPF_ADJ_ROOM_MAC", " flags "]}]}}}], "encap_v6": [{"fileName": "/root/examples/katran/pckt_encap.h", "startLine": "41", "endLine": "91", "capability": {"capability": [{"update_pkt": [{"Description": "Adjust (move) xdp_md->data by <[ delta ]>(IP: 1) bytes. Note that it is possible to use a negative value for delta. This helper can be used to prepare the packet for pushing or popping headers. A call to this helper is susceptible to change the underlaying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": "0 on success, or a negative error in case of failure.", "Return Type": "int", "Function Name": "bpf_xdp_adjust_head", "Input Params": ["{Type: struct xdp_buff ,Var: *xdp_md}", "{Type:  int ,Var: delta}"]}]}], "helperCallParams": {"bpf_xdp_adjust_head": [{"opVar": "NA", "inpVar": ["    if xdp", " 0 - intsizeofstruct ipv6hdr "]}]}}}], "encap_v4": [{"fileName": "/root/examples/katran/pckt_encap.h", "startLine": "93", "endLine": "133", "capability": {"capability": [{"update_pkt": [{"Description": "Adjust (move) xdp_md->data by <[ delta ]>(IP: 1) bytes. Note that it is possible to use a negative value for delta. This helper can be used to prepare the packet for pushing or popping headers. A call to this helper is susceptible to change the underlaying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": "0 on success, or a negative error in case of failure.", "Return Type": "int", "Function Name": "bpf_xdp_adjust_head", "Input Params": ["{Type: struct xdp_buff ,Var: *xdp_md}", "{Type:  int ,Var: delta}"]}]}], "helperCallParams": {"bpf_xdp_adjust_head": [{"opVar": "NA", "inpVar": ["    if xdp", " 0 - intsizeofstruct iphdr "]}]}}}], "decap_v6": [{"fileName": "/root/examples/katran/pckt_encap.h", "startLine": "137", "endLine": "156", "capability": {"capability": [{"update_pkt": [{"Description": "Adjust (move) xdp_md->data by <[ delta ]>(IP: 1) bytes. Note that it is possible to use a negative value for delta. This helper can be used to prepare the packet for pushing or popping headers. A call to this helper is susceptible to change the underlaying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": "0 on success, or a negative error in case of failure.", "Return Type": "int", "Function Name": "bpf_xdp_adjust_head", "Input Params": ["{Type: struct xdp_buff ,Var: *xdp_md}", "{Type:  int ,Var: delta}"]}]}], "helperCallParams": {"bpf_xdp_adjust_head": [{"opVar": "NA", "inpVar": ["    if xdp", " intsizeofstruct ipv6hdr "]}]}}}], "decap_v4": [{"fileName": "/root/examples/katran/pckt_encap.h", "startLine": "158", "endLine": "173", "capability": {"capability": [{"update_pkt": [{"Description": "Adjust (move) xdp_md->data by <[ delta ]>(IP: 1) bytes. Note that it is possible to use a negative value for delta. This helper can be used to prepare the packet for pushing or popping headers. A call to this helper is susceptible to change the underlaying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": "0 on success, or a negative error in case of failure.", "Return Type": "int", "Function Name": "bpf_xdp_adjust_head", "Input Params": ["{Type: struct xdp_buff ,Var: *xdp_md}", "{Type:  int ,Var: delta}"]}]}], "helperCallParams": {"bpf_xdp_adjust_head": [{"opVar": "NA", "inpVar": ["  if xdp", " intsizeofstruct iphdr "]}]}}}], "gue_csum": [{"fileName": "/root/examples/katran/pckt_encap.h", "startLine": "177", "endLine": "249", "capability": {"capability": [], "helperCallParams": {}}}], "gue_encap_v4": [{"fileName": "/root/examples/katran/pckt_encap.h", "startLine": "251", "endLine": "307", "capability": {"capability": [{"update_pkt": [{"Description": "Adjust (move) xdp_md->data by <[ delta ]>(IP: 1) bytes. Note that it is possible to use a negative value for delta. This helper can be used to prepare the packet for pushing or popping headers. A call to this helper is susceptible to change the underlaying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": "0 on success, or a negative error in case of failure.", "Return Type": "int", "Function Name": "bpf_xdp_adjust_head", "Input Params": ["{Type: struct xdp_buff ,Var: *xdp_md}", "{Type:  int ,Var: delta}"]}]}, {"map_read": [{"Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": "Map value associated to key, or NULL if no entry was found.", "Return Type": "void", "Function Name": "*bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"bpf_map_lookup_elem": [{"opVar": "  src ", "inpVar": [" &pckt_srcs", " &ipv4_src"]}], "bpf_xdp_adjust_head": [{"opVar": "NA", "inpVar": ["  if           xdp", " 0 - intsizeofstruct iphdr + intsizeofstruct udphdr "]}]}}}], "gue_encap_v6": [{"fileName": "/root/examples/katran/pckt_encap.h", "startLine": "309", "endLine": "367", "capability": {"capability": [{"update_pkt": [{"Description": "Adjust (move) xdp_md->data by <[ delta ]>(IP: 1) bytes. Note that it is possible to use a negative value for delta. This helper can be used to prepare the packet for pushing or popping headers. A call to this helper is susceptible to change the underlaying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": "0 on success, or a negative error in case of failure.", "Return Type": "int", "Function Name": "bpf_xdp_adjust_head", "Input Params": ["{Type: struct xdp_buff ,Var: *xdp_md}", "{Type:  int ,Var: delta}"]}]}, {"map_read": [{"Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": "Map value associated to key, or NULL if no entry was found.", "Return Type": "void", "Function Name": "*bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"bpf_map_lookup_elem": [{"opVar": "  src ", "inpVar": [" &pckt_srcs", " &key"]}], "bpf_xdp_adjust_head": [{"opVar": "NA", "inpVar": ["    if           xdp", "          0 - intsizeofstruct ipv6hdr + intsizeofstruct udphdr "]}]}}}], "gue_decap_v4": [{"fileName": "/root/examples/katran/pckt_encap.h", "startLine": "372", "endLine": "389", "capability": {"capability": [{"update_pkt": [{"Description": "Adjust (move) xdp_md->data by <[ delta ]>(IP: 1) bytes. Note that it is possible to use a negative value for delta. This helper can be used to prepare the packet for pushing or popping headers. A call to this helper is susceptible to change the underlaying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": "0 on success, or a negative error in case of failure.", "Return Type": "int", "Function Name": "bpf_xdp_adjust_head", "Input Params": ["{Type: struct xdp_buff ,Var: *xdp_md}", "{Type:  int ,Var: delta}"]}]}], "helperCallParams": {"bpf_xdp_adjust_head": [{"opVar": "NA", "inpVar": ["  if           xdp", " intsizeofstruct iphdr + sizeofstruct udphdr "]}]}}}], "gue_decap_v6": [{"fileName": "/root/examples/katran/pckt_encap.h", "startLine": "391", "endLine": "412", "capability": {"capability": [{"update_pkt": [{"Description": "Adjust (move) xdp_md->data by <[ delta ]>(IP: 1) bytes. Note that it is possible to use a negative value for delta. This helper can be used to prepare the packet for pushing or popping headers. A call to this helper is susceptible to change the underlaying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": "0 on success, or a negative error in case of failure.", "Return Type": "int", "Function Name": "bpf_xdp_adjust_head", "Input Params": ["{Type: struct xdp_buff ,Var: *xdp_md}", "{Type:  int ,Var: delta}"]}]}], "helperCallParams": {"bpf_xdp_adjust_head": [{"opVar": "NA", "inpVar": ["    if           xdp", " intsizeofstruct ipv6hdr + sizeofstruct udphdr "]}]}}}], "submit_event": [{"fileName": "/root/examples/katran/balancer_helpers.h", "startLine": "46", "endLine": "70", "capability": {"capability": [{"map_read": [{"Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": "Map value associated to key, or NULL if no entry was found.", "Return Type": "void", "Function Name": "*bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"bpf_map_lookup_elem": [{"opVar": "  gk ", "inpVar": [" &ctl_array", " &introspection_gk_pos"]}], "bpf_perf_event_output": [{"opVar": "NA", "inpVar": ["    ctx", " map", " flags", " &md", " sizeofstruct event_metadata"]}]}}}], "recirculate": [{"fileName": "/root/examples/katran/balancer_helpers.h", "startLine": "74", "endLine": "80", "capability": {"capability": [], "helperCallParams": {"bpf_tail_call": [{"opVar": "NA", "inpVar": ["  ctx", " &subprograms", " i"]}]}}}], "decrement_ttl": [{"fileName": "/root/examples/katran/balancer_helpers.h", "startLine": "83", "endLine": "111", "capability": {"capability": [], "helperCallParams": {}}}], "get_next_ports": [{"fileName": "/root/examples/katran/flow_debug_helpers.h", "startLine": "29", "endLine": "53", "capability": {"capability": [], "helperCallParams": {}}}], "gue_record_route": [{"fileName": "/root/examples/katran/flow_debug_helpers.h", "startLine": "55", "endLine": "128", "capability": {"capability": [{"read_sys_info": [{"Description": "Get the SMP (symmetric multiprocessing) processor id. Note that all programs run with preemption disabled , which means that the SMP processor id is stable during all the execution of the program. ", "Return": "The SMP id of the processor running the program.", "Return Type": "u32", "Function Name": "bpf_get_smp_processor_id", "Input Params": ["{Type: voi ,Var: void}"]}]}], "helperCallParams": {"bpf_get_smp_processor_id": [{"opVar": "  __u32 cpu_num ", "inpVar": [" "]}]}}}]}