{"caller": [{"capabilities": [], "helperCallParams": {}, "startLine": 24, "endLine": 32, "File": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/tail_call_bad.c", "funcName": "caller", "developer_inline_comments": [{"start_line": 1, "end_line": 1, "text": "// Copyright (c) Prevail Verifier contributors."}, {"start_line": 2, "end_line": 2, "text": "// SPDX-License-Identifier: MIT"}, {"start_line": 27, "end_line": 27, "text": "// This should fail validation since the map is not a prog array."}, {"start_line": 30, "end_line": 30, "text": "// bpf_tail_call failed at runtime."}], "updateMaps": [], "readMaps": [], "input": ["struct xdp_md *ctx"], "output": "int", "helper": ["bpf_tail_call"], "compatibleHookpoints": ["flow_dissector", "sched_act", "lwt_in", "sk_skb", "sk_reuseport", "sched_cls", "tracepoint", "lwt_xmit", "cgroup_skb", "sock_ops", "kprobe", "cgroup_sock_addr", "lwt_seg6local", "cgroup_sock", "perf_event", "raw_tracepoint_writable", "lwt_out", "raw_tracepoint", "sk_msg", "socket_filter", "xdp"], "source": ["int caller (struct xdp_md *ctx)\n", "{\n", "    long error = bpf_tail_call (ctx, & map, 0);\n", "    return (int) error;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 24, "endLine": 31, "File": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/tail_call.c", "funcName": "caller", "developer_inline_comments": [{"start_line": 1, "end_line": 1, "text": "// Copyright (c) Prevail Verifier contributors."}, {"start_line": 2, "end_line": 2, "text": "// SPDX-License-Identifier: MIT"}, {"start_line": 29, "end_line": 29, "text": "// bpf_tail_call failed at runtime."}], "updateMaps": [], "readMaps": [], "input": ["struct xdp_md *ctx"], "output": "int", "helper": ["bpf_tail_call"], "compatibleHookpoints": ["flow_dissector", "sched_act", "lwt_in", "sk_skb", "sk_reuseport", "sched_cls", "tracepoint", "lwt_xmit", "cgroup_skb", "sock_ops", "kprobe", "cgroup_sock_addr", "lwt_seg6local", "cgroup_sock", "perf_event", "raw_tracepoint_writable", "lwt_out", "raw_tracepoint", "sk_msg", "socket_filter", "xdp"], "source": ["int caller (struct xdp_md *ctx)\n", "{\n", "    long error = bpf_tail_call (ctx, & map, 0);\n", "    return (int) error;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "callee": [{"capabilities": [], "helperCallParams": {}, "startLine": 34, "endLine": 38, "File": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/tail_call_bad.c", "funcName": "callee", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct xdp_md *ctx"], "output": "int", "helper": [], "compatibleHookpoints": ["flow_dissector", "sched_act", "cgroup_device", "lwt_in", "sk_skb", "sk_reuseport", "sched_cls", "tracepoint", "lwt_xmit", "cgroup_skb", "sock_ops", "kprobe", "cgroup_sock_addr", "lwt_seg6local", "cgroup_sysctl", "cgroup_sock", "perf_event", "raw_tracepoint_writable", "lwt_out", "raw_tracepoint", "sk_msg", "socket_filter", "xdp"], "source": ["int callee (struct xdp_md *ctx)\n", "{\n", "    return 42;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 33, "endLine": 37, "File": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/tail_call.c", "funcName": "callee", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct xdp_md *ctx"], "output": "int", "helper": [], "compatibleHookpoints": ["flow_dissector", "sched_act", "cgroup_device", "lwt_in", "sk_skb", "sk_reuseport", "sched_cls", "tracepoint", "lwt_xmit", "cgroup_skb", "sock_ops", "kprobe", "cgroup_sock_addr", "lwt_seg6local", "cgroup_sysctl", "cgroup_sock", "perf_event", "raw_tracepoint_writable", "lwt_out", "raw_tracepoint", "sk_msg", "socket_filter", "xdp"], "source": ["int callee (struct xdp_md *ctx)\n", "{\n", "    return 42;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "func": [{"capabilities": [], "helperCallParams": {}, "startLine": 29, "endLine": 36, "File": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/exposeptr2.c", "funcName": "func", "developer_inline_comments": [{"start_line": 1, "end_line": 1, "text": "// Copyright (c) Prevail Verifier contributors."}, {"start_line": 2, "end_line": 2, "text": "// SPDX-License-Identifier: MIT"}, {"start_line": 33, "end_line": 33, "text": "// The following should fail verification since it stores"}, {"start_line": 34, "end_line": 34, "text": "// a pointer in shared memory, thus exposing it to user-mode apps."}], "updateMaps": [" map"], "readMaps": [], "input": ["struct ctx *ctx"], "output": "int", "helper": [], "compatibleHookpoints": ["flow_dissector", "sched_act", "cgroup_device", "lwt_in", "sk_skb", "sk_reuseport", "sched_cls", "tracepoint", "lwt_xmit", "cgroup_skb", "sock_ops", "kprobe", "cgroup_sock_addr", "lwt_seg6local", "cgroup_sysctl", "cgroup_sock", "perf_event", "raw_tracepoint_writable", "lwt_out", "raw_tracepoint", "sk_msg", "socket_filter", "xdp"], "source": ["int func (struct ctx *ctx)\n", "{\n", "    uint32_t value = 0;\n", "    return ebpf_map_update_elem (&map, &ctx, &value, 0);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "libbpf", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 35, "endLine": 49, "File": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/map_in_map.c", "funcName": "func", "developer_inline_comments": [{"start_line": 25, "end_line": 25, "text": "// (uint32_t)&inner_map};"}], "updateMaps": [], "readMaps": [" array_of_maps", " nolocal_lru_map", "  inner_map"], "input": ["void *ctx"], "output": "int", "helper": ["bpf_map_lookup_elem"], "compatibleHookpoints": ["flow_dissector", "sched_act", "cgroup_device", "lwt_in", "sk_skb", "sk_reuseport", "sched_cls", "tracepoint", "lwt_xmit", "cgroup_skb", "sock_ops", "kprobe", "cgroup_sock_addr", "lwt_seg6local", "cgroup_sysctl", "cgroup_sock", "perf_event", "raw_tracepoint_writable", "lwt_out", "raw_tracepoint", "sk_msg", "socket_filter", "xdp"], "source": ["int func (void *ctx)\n", "{\n", "    uint32_t outer_key = 0;\n", "    void *nolocal_lru_map = bpf_map_lookup_elem (&array_of_maps, &outer_key);\n", "    if (nolocal_lru_map) {\n", "        uint32_t inner_key = 0;\n", "        void *ret = bpf_map_lookup_elem (nolocal_lru_map, &inner_key);\n", "        if (ret) {\n", "            return 0;\n", "        }\n", "        else {\n", "            ret = bpf_map_lookup_elem (& inner_map, & inner_key);\n", "            return 0;\n", "        }\n", "    }\n", "    return 0;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 29, "endLine": 38, "File": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/mapunderflow.c", "funcName": "func", "developer_inline_comments": [{"start_line": 1, "end_line": 1, "text": "// Copyright (c) Prevail Verifier contributors."}, {"start_line": 2, "end_line": 2, "text": "// SPDX-License-Identifier: MIT"}, {"start_line": 34, "end_line": 34, "text": "// The following should fail verification since it tries to"}, {"start_line": 35, "end_line": 35, "text": "// write before the start of the array, or past the end if -1"}, {"start_line": 36, "end_line": 36, "text": "// is interpreted as unsigned."}], "updateMaps": [" map"], "readMaps": [], "input": ["struct ctx *ctx"], "output": "int", "helper": [], "compatibleHookpoints": ["flow_dissector", "sched_act", "cgroup_device", "lwt_in", "sk_skb", "sk_reuseport", "sched_cls", "tracepoint", "lwt_xmit", "cgroup_skb", "sock_ops", "kprobe", "cgroup_sock_addr", "lwt_seg6local", "cgroup_sysctl", "cgroup_sock", "perf_event", "raw_tracepoint_writable", "lwt_out", "raw_tracepoint", "sk_msg", "socket_filter", "xdp"], "source": ["int func (struct ctx *ctx)\n", "{\n", "    int key = -1;\n", "    uint64_t value = 0;\n", "    return ebpf_map_update_elem (&map, &key, &value, 0);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [{"capability": "read_sys_info", "read_sys_info": [{"Project": "cilium", "Return Type": "u32", "Description": "Get a pseudo-random number. From a security point of view , this helper uses its own pseudo-random internal state , and cannot be used to infer the seed of other random functions in the kernel. However , it is essential to note that the generator used by the helper is not cryptographically secure. ", "Return": " A random 32-bit unsigned value.", "Function Name": "get_prandom_u32", "Input Params": ["{Type: voi ,Var: void}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "raw_tracepoint_writable"], "capabilities": ["read_sys_info"]}]}], "helperCallParams": {}, "startLine": 29, "endLine": 48, "File": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/twotypes.c", "funcName": "func", "developer_inline_comments": [{"start_line": 1, "end_line": 1, "text": "// Copyright (c) Prevail Verifier contributors."}, {"start_line": 2, "end_line": 2, "text": "// SPDX-License-Identifier: MIT"}], "updateMaps": [], "readMaps": [" map"], "input": ["struct ctx *ctx"], "output": "int", "helper": ["bpf_map_lookup_elem", "get_prandom_u32"], "compatibleHookpoints": ["flow_dissector", "sched_act", "lwt_in", "sk_skb", "sk_reuseport", "sched_cls", "tracepoint", "lwt_xmit", "cgroup_skb", "sock_ops", "kprobe", "cgroup_sock_addr", "lwt_seg6local", "cgroup_sock", "perf_event", "raw_tracepoint_writable", "lwt_out", "raw_tracepoint", "sk_msg", "socket_filter", "xdp"], "source": ["int func (struct ctx *ctx)\n", "{\n", "    uint32_t rand32 = get_prandom_u32 ();\n", "    uint8_t stack_buffer [256] = {0};\n", "    *(uint32_t*) stack_buffer = rand32;\n", "    int map_key = 0;\n", "    uint8_t *map_value = (uint8_t *) bpf_map_lookup_elem (&map, &map_key);\n", "    if (map_value == 0)\n", "        return 0;\n", "    uint8_t *ptr;\n", "    if (rand32 & 1) {\n", "        ptr = map_value;\n", "    }\n", "    else {\n", "        ptr = stack_buffer + 128;\n", "    }\n", "    return (*ptr == stack_buffer[0]) ? 1 : 0;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [{"capability": "map_update", "map_update": [{"Project": "libbpf", "Return Type": "int", "Description": "Add an entry to , or update a <[ map ]>(IP: 1) referencing sockets. The <[ skops ]>(IP: 0) is used as a new value for the entry associated to key. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 2) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 2) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. If the <[ map ]>(IP: 1) has eBPF programs (parser and verdict) , those will be inherited by the socket being added. If the socket is already attached to eBPF programs , this results in an error. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_sock_map_update", "Input Params": ["{Type: struct bpf_sock_ops ,Var: *skops}", "{Type:  struct bpf_map ,Var: *map}", "{Type:  void ,Var: *key}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["sock_ops"], "capabilities": ["map_update"]}]}], "helperCallParams": {}, "startLine": 29, "endLine": 37, "File": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/wronghelper.c", "funcName": "func", "developer_inline_comments": [{"start_line": 1, "end_line": 1, "text": "// Copyright (c) Prevail Verifier contributors."}, {"start_line": 2, "end_line": 2, "text": "// SPDX-License-Identifier: MIT"}, {"start_line": 33, "end_line": 33, "text": "// The following should fail because the ctx doesn't match, and in particular"}, {"start_line": 34, "end_line": 34, "text": "// the memory pointed to by ctx might be smaller than the memory read by the helper."}], "updateMaps": [" ctx"], "readMaps": [], "input": ["void *ctx"], "output": "int", "helper": ["bpf_sock_map_update"], "compatibleHookpoints": ["sock_ops"], "source": ["int func (void *ctx)\n", "{\n", "    uint32_t key = 1;\n", "    int result = bpf_sock_map_update (ctx, & map, & key, 0);\n", "    return result;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [{"capability": "read_sys_info", "read_sys_info": [{"Project": "cilium", "Return Type": "u32", "Description": "Get a pseudo-random number. From a security point of view , this helper uses its own pseudo-random internal state , and cannot be used to infer the seed of other random functions in the kernel. However , it is essential to note that the generator used by the helper is not cryptographically secure. ", "Return": " A random 32-bit unsigned value.", "Function Name": "get_prandom_u32", "Input Params": ["{Type: voi ,Var: void}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "raw_tracepoint_writable"], "capabilities": ["read_sys_info"]}]}], "helperCallParams": {}, "startLine": 8, "endLine": 19, "File": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/stackok.c", "funcName": "func", "developer_inline_comments": [{"start_line": 1, "end_line": 1, "text": "// Copyright (c) Prevail Verifier contributors."}, {"start_line": 2, "end_line": 2, "text": "// SPDX-License-Identifier: MIT"}, {"start_line": 10, "end_line": 10, "text": "// Initialize an array of 256 bytes (to all zeroes in this example)."}, {"start_line": 13, "end_line": 13, "text": "// Set index to a random value in the interval [0,255]."}, {"start_line": 17, "end_line": 17, "text": "// Return the array element at the specified index."}], "updateMaps": [], "readMaps": [], "input": ["void *ctx"], "output": "int", "helper": ["get_prandom_u32"], "compatibleHookpoints": ["flow_dissector", "sched_act", "lwt_in", "sk_skb", "sk_reuseport", "sched_cls", "tracepoint", "lwt_xmit", "cgroup_skb", "sock_ops", "kprobe", "cgroup_sock_addr", "lwt_seg6local", "cgroup_sock", "perf_event", "raw_tracepoint_writable", "lwt_out", "raw_tracepoint", "sk_msg", "socket_filter", "xdp"], "source": ["int func (void *ctx)\n", "{\n", "    char array [256] = \"\";\n", "    uint32_t rand32 = get_prandom_u32 ();\n", "    uint32_t index = *(unsignedchar*) &rand32;\n", "    return array[index];\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 8, "endLine": 15, "File": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/badhelpercall.c", "funcName": "func", "developer_inline_comments": [{"start_line": 1, "end_line": 1, "text": "// Copyright (c) Prevail Verifier contributors."}, {"start_line": 2, "end_line": 2, "text": "// SPDX-License-Identifier: MIT"}, {"start_line": 12, "end_line": 12, "text": "// The following should fail verification since it asks the helper"}, {"start_line": 13, "end_line": 13, "text": "// to write past the end of the stack."}], "updateMaps": [], "readMaps": [], "input": ["NA"], "output": "int", "helper": [], "compatibleHookpoints": ["flow_dissector", "sched_act", "cgroup_device", "lwt_in", "sk_skb", "sk_reuseport", "sched_cls", "tracepoint", "lwt_xmit", "cgroup_skb", "sock_ops", "kprobe", "cgroup_sock_addr", "lwt_seg6local", "cgroup_sysctl", "cgroup_sock", "perf_event", "raw_tracepoint_writable", "lwt_out", "raw_tracepoint", "sk_msg", "socket_filter", "xdp"], "source": ["int func ()\n", "{\n", "    char buffer [1];\n", "    return ebpf_get_current_comm (buffer, 20);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [{"capability": "map_update", "map_update": [{"Project": "libbpf", "Return Type": "int", "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_map_update_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}", "{Type:  const void ,Var: *value}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_update"]}]}], "helperCallParams": {}, "startLine": 31, "endLine": 38, "File": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/badrelo.c", "funcName": "func", "developer_inline_comments": [{"start_line": 1, "end_line": 1, "text": "// Copyright (c) Prevail Verifier contributors."}, {"start_line": 2, "end_line": 2, "text": "// SPDX-License-Identifier: MIT"}, {"start_line": 25, "end_line": 25, "text": "// This will be an unresolved symbol in the resulting .o file."}, {"start_line": 35, "end_line": 35, "text": "// And we can furthermore pass some bad parameters in here.  These"}, {"start_line": 36, "end_line": 36, "text": "// would be illegal to pass to bpf_map_update_elem if it were resolved."}], "updateMaps": [" map2"], "readMaps": [], "input": ["struct ctx *ctx"], "output": "int", "helper": ["bpf_map_update_elem"], "compatibleHookpoints": ["flow_dissector", "sched_act", "cgroup_device", "lwt_in", "sk_skb", "sk_reuseport", "sched_cls", "tracepoint", "lwt_xmit", "cgroup_skb", "sock_ops", "kprobe", "cgroup_sock_addr", "lwt_seg6local", "cgroup_sysctl", "cgroup_sock", "perf_event", "raw_tracepoint_writable", "lwt_out", "raw_tracepoint", "sk_msg", "socket_filter", "xdp"], "source": ["int func (struct ctx *ctx)\n", "{\n", "    struct bpf_map map2;\n", "    return bpf_map_update_elem (&map2, (const void *) 0, (const void *) 0, 0);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 29, "endLine": 36, "File": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/exposeptr.c", "funcName": "func", "developer_inline_comments": [{"start_line": 1, "end_line": 1, "text": "// Copyright (c) Prevail Verifier contributors."}, {"start_line": 2, "end_line": 2, "text": "// SPDX-License-Identifier: MIT"}, {"start_line": 33, "end_line": 33, "text": "// The following should fail verification since it stores"}, {"start_line": 34, "end_line": 34, "text": "// a pointer in shared memory, thus exposing it to user-mode apps."}], "updateMaps": [" map"], "readMaps": [], "input": ["struct ctx *ctx"], "output": "int", "helper": [], "compatibleHookpoints": ["flow_dissector", "sched_act", "cgroup_device", "lwt_in", "sk_skb", "sk_reuseport", "sched_cls", "tracepoint", "lwt_xmit", "cgroup_skb", "sock_ops", "kprobe", "cgroup_sock_addr", "lwt_seg6local", "cgroup_sysctl", "cgroup_sock", "perf_event", "raw_tracepoint_writable", "lwt_out", "raw_tracepoint", "sk_msg", "socket_filter", "xdp"], "source": ["int func (struct ctx *ctx)\n", "{\n", "    uint32_t key = 0;\n", "    return ebpf_map_update_elem (&map, &key, &ctx, 0);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "libbpf", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 26, "endLine": 39, "File": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/mapvalue-overrun.c", "funcName": "func", "developer_inline_comments": [{"start_line": 1, "end_line": 1, "text": "// Copyright (c) Prevail Verifier contributors."}, {"start_line": 2, "end_line": 2, "text": "// SPDX-License-Identifier: MIT"}, {"start_line": 35, "end_line": 35, "text": "// The map's value size can only hold a uint32_t."}, {"start_line": 36, "end_line": 36, "text": "// So verification should fail if we try to read past the space returned."}], "updateMaps": [], "readMaps": [" map"], "input": ["void *ctx"], "output": "int", "helper": ["bpf_map_lookup_elem"], "compatibleHookpoints": ["flow_dissector", "sched_act", "cgroup_device", "lwt_in", "sk_skb", "sk_reuseport", "sched_cls", "tracepoint", "lwt_xmit", "cgroup_skb", "sock_ops", "kprobe", "cgroup_sock_addr", "lwt_seg6local", "cgroup_sysctl", "cgroup_sock", "perf_event", "raw_tracepoint_writable", "lwt_out", "raw_tracepoint", "sk_msg", "socket_filter", "xdp"], "source": ["int func (void *ctx)\n", "{\n", "    uint32_t key = 1;\n", "    uint64_t *ptr = bpf_map_lookup_elem (&map, &key);\n", "    if (ptr == 0) {\n", "        return 0;\n", "    }\n", "    uint64_t i = *ptr;\n", "    return (uint32_t) i;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [{"capability": "read_sys_info", "read_sys_info": [{"Project": "cilium", "Return Type": "u32", "Description": "Get a pseudo-random number. From a security point of view , this helper uses its own pseudo-random internal state , and cannot be used to infer the seed of other random functions in the kernel. However , it is essential to note that the generator used by the helper is not cryptographically secure. ", "Return": " A random 32-bit unsigned value.", "Function Name": "get_prandom_u32", "Input Params": ["{Type: voi ,Var: void}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "raw_tracepoint_writable"], "capabilities": ["read_sys_info"]}]}], "helperCallParams": {}, "startLine": 36, "endLine": 48, "File": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/twomaps.c", "funcName": "func", "developer_inline_comments": [{"start_line": 1, "end_line": 1, "text": "// Copyright (c) Prevail Verifier contributors."}, {"start_line": 2, "end_line": 2, "text": "// SPDX-License-Identifier: MIT"}, {"start_line": 46, "end_line": 46, "text": "// The following is safe since both maps have the same value size."}], "updateMaps": [], "readMaps": [" map"], "input": ["struct ctx *ctx"], "output": "int", "helper": ["bpf_map_lookup_elem", "get_prandom_u32"], "compatibleHookpoints": ["flow_dissector", "sched_act", "lwt_in", "sk_skb", "sk_reuseport", "sched_cls", "tracepoint", "lwt_xmit", "cgroup_skb", "sock_ops", "kprobe", "cgroup_sock_addr", "lwt_seg6local", "cgroup_sock", "perf_event", "raw_tracepoint_writable", "lwt_out", "raw_tracepoint", "sk_msg", "socket_filter", "xdp"], "source": ["int func (struct ctx *ctx)\n", "{\n", "    uint32_t rand32 = get_prandom_u32 ();\n", "    struct ebpf_map *map = (rand32 & 1) ? &map1 : &map2;\n", "    int key = 10;\n", "    uint64_t *value = (uint64_t *) bpf_map_lookup_elem (map, &key);\n", "    if (value == 0)\n", "        return 0;\n", "    return (int) *value;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [{"capability": "read_sys_info", "read_sys_info": [{"Project": "cilium", "Return Type": "u32", "Description": "Get a pseudo-random number. From a security point of view , this helper uses its own pseudo-random internal state , and cannot be used to infer the seed of other random functions in the kernel. However , it is essential to note that the generator used by the helper is not cryptographically secure. ", "Return": " A random 32-bit unsigned value.", "Function Name": "get_prandom_u32", "Input Params": ["{Type: voi ,Var: void}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "raw_tracepoint_writable"], "capabilities": ["read_sys_info"]}]}], "helperCallParams": {}, "startLine": 10, "endLine": 46, "File": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/twostackvars.c", "funcName": "func", "developer_inline_comments": [{"start_line": 1, "end_line": 1, "text": "// Copyright (c) Prevail Verifier contributors."}, {"start_line": 2, "end_line": 2, "text": "// SPDX-License-Identifier: MIT"}, {"start_line": 17, "end_line": 17, "text": "// In this path we want ptr to point to one section"}, {"start_line": 18, "end_line": 18, "text": "// of stack space that is known to be a number, and have"}, {"start_line": 19, "end_line": 19, "text": "// the rest of the stack be unknown."}, {"start_line": 26, "end_line": 26, "text": "// Do something with the pointer to force it to be saved in a"}, {"start_line": 27, "end_line": 27, "text": "// register before joining the two paths."}, {"start_line": 30, "end_line": 30, "text": "// In this path we want ptr to point to a different section"}, {"start_line": 31, "end_line": 31, "text": "// of stack space that is known to be a number, and have"}, {"start_line": 32, "end_line": 32, "text": "// the rest of the stack be unknown."}, {"start_line": 40, "end_line": 40, "text": "// Here we want to dereference the pointer to get a number."}, {"start_line": 41, "end_line": 41, "text": "// In both paths above, ptr safely points to a number, even"}, {"start_line": 42, "end_line": 42, "text": "// though each part of stack_buffer is not necessarily a number"}, {"start_line": 43, "end_line": 43, "text": "// at this point."}], "updateMaps": [], "readMaps": [], "input": ["struct ctx *ctx"], "output": "int", "helper": ["get_prandom_u32"], "compatibleHookpoints": ["flow_dissector", "sched_act", "lwt_in", "sk_skb", "sk_reuseport", "sched_cls", "tracepoint", "lwt_xmit", "cgroup_skb", "sock_ops", "kprobe", "cgroup_sock_addr", "lwt_seg6local", "cgroup_sock", "perf_event", "raw_tracepoint_writable", "lwt_out", "raw_tracepoint", "sk_msg", "socket_filter", "xdp"], "source": ["int func (struct ctx *ctx)\n", "{\n", "    int stack_buffer [16];\n", "    int *ptr = (int *) 0;\n", "    uint32_t rand32 = get_prandom_u32 ();\n", "    if (rand32 & 1) {\n", "        for (int i = 0; i < 8; i++) {\n", "            stack_buffer[i] = get_prandom_u32 ();\n", "        }\n", "        int index = rand32 % 8;\n", "        ptr = &stack_buffer[index];\n", "        ptr[index ^ 1] = 0;\n", "    }\n", "    else {\n", "        int *stack_buffer2 = &stack_buffer[8];\n", "        for (int i = 0; i < 8; i++) {\n", "            stack_buffer2[i] = get_prandom_u32 ();\n", "        }\n", "        ptr = &stack_buffer2[rand32 % 8];\n", "    }\n", "    return *ptr;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [{"capability": "read_sys_info", "read_sys_info": [{"Project": "cilium", "Return Type": "u32", "Description": "Get a pseudo-random number. From a security point of view , this helper uses its own pseudo-random internal state , and cannot be used to infer the seed of other random functions in the kernel. However , it is essential to note that the generator used by the helper is not cryptographically secure. ", "Return": " A random 32-bit unsigned value.", "Function Name": "get_prandom_u32", "Input Params": ["{Type: voi ,Var: void}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "raw_tracepoint_writable"], "capabilities": ["read_sys_info"]}]}], "helperCallParams": {}, "startLine": 8, "endLine": 26, "File": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/byteswap.c", "funcName": "func", "developer_inline_comments": [{"start_line": 1, "end_line": 1, "text": "// Copyright (c) Prevail Verifier contributors."}, {"start_line": 2, "end_line": 2, "text": "// SPDX-License-Identifier: MIT"}], "updateMaps": [], "readMaps": [], "input": ["struct ctx *ctx"], "output": "int", "helper": ["get_prandom_u32"], "compatibleHookpoints": ["flow_dissector", "sched_act", "lwt_in", "sk_skb", "sk_reuseport", "sched_cls", "tracepoint", "lwt_xmit", "cgroup_skb", "sock_ops", "kprobe", "cgroup_sock_addr", "lwt_seg6local", "cgroup_sock", "perf_event", "raw_tracepoint_writable", "lwt_out", "raw_tracepoint", "sk_msg", "socket_filter", "xdp"], "source": ["int func (struct ctx *ctx)\n", "{\n", "    int rand32 = get_prandom_u32 ();\n", "    if (rand32 & 0x01) {\n", "        asm volatile (\"r0 = le64 r0\\nexit\"\n", "            );\n", "    }\n", "    else if (rand32 & 0x02) {\n", "        asm volatile (\"r0 = le32 r0\\nexit\"\n", "            );\n", "    }\n", "    else if (rand32 & 0x04) {\n", "        asm volatile (\"r0 = le16 r0\\nexit\"\n", "            );\n", "    }\n", "    else if (rand32 & 0x10) {\n", "        asm volatile (\"r0 = be64 r0\\nexit\"\n", "            );\n", "    }\n", "    else if (rand32 & 0x20) {\n", "        asm volatile (\"r0 = be32 r0\\nexit\"\n", "            );\n", "    }\n", "    else {\n", "        asm volatile (\"r0 = be16 r0\\nexit\"\n", "            );\n", "    }\n", "    return 0;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [{"capability": "map_update", "map_update": [{"Project": "libbpf", "Return Type": "int", "Description": "Add an entry to , or update a <[ map ]>(IP: 1) referencing sockets. The <[ skops ]>(IP: 0) is used as a new value for the entry associated to key. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 2) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 2) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. If the <[ map ]>(IP: 1) has eBPF programs (parser and verdict) , those will be inherited by the socket being added. If the socket is already attached to eBPF programs , this results in an error. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_sock_map_update", "Input Params": ["{Type: struct bpf_sock_ops ,Var: *skops}", "{Type:  struct bpf_map ,Var: *map}", "{Type:  void ,Var: *key}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["sock_ops"], "capabilities": ["map_update"]}]}], "helperCallParams": {}, "startLine": 29, "endLine": 38, "File": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/ctxoffset.c", "funcName": "func", "developer_inline_comments": [{"start_line": 1, "end_line": 1, "text": "// Copyright (c) Prevail Verifier contributors."}, {"start_line": 2, "end_line": 2, "text": "// SPDX-License-Identifier: MIT"}, {"start_line": 33, "end_line": 33, "text": "// The following should fail because the sock_ops ctx isn't the same pointer passed in"}, {"start_line": 34, "end_line": 34, "text": "// but is offset 8 bytes into it."}], "updateMaps": [" ctx"], "readMaps": [], "input": ["void *ctx"], "output": "int", "helper": ["bpf_sock_map_update"], "compatibleHookpoints": ["sock_ops"], "source": ["int func (void *ctx)\n", "{\n", "    uint32_t key = 1;\n", "    ctx = ((char *) ctx) + 8;\n", "    int result = bpf_sock_map_update (ctx, & map, & key, 0);\n", "    return result;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 29, "endLine": 37, "File": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/mapoverflow.c", "funcName": "func", "developer_inline_comments": [{"start_line": 1, "end_line": 1, "text": "// Copyright (c) Prevail Verifier contributors."}, {"start_line": 2, "end_line": 2, "text": "// SPDX-License-Identifier: MIT"}, {"start_line": 34, "end_line": 34, "text": "// The following should fail verification since it tries to"}, {"start_line": 35, "end_line": 35, "text": "// write past the size of the array."}], "updateMaps": [" map"], "readMaps": [], "input": ["struct ctx *ctx"], "output": "int", "helper": [], "compatibleHookpoints": ["flow_dissector", "sched_act", "cgroup_device", "lwt_in", "sk_skb", "sk_reuseport", "sched_cls", "tracepoint", "lwt_xmit", "cgroup_skb", "sock_ops", "kprobe", "cgroup_sock_addr", "lwt_seg6local", "cgroup_sysctl", "cgroup_sock", "perf_event", "raw_tracepoint_writable", "lwt_out", "raw_tracepoint", "sk_msg", "socket_filter", "xdp"], "source": ["int func (struct ctx *ctx)\n", "{\n", "    uint32_t key = 10;\n", "    uint64_t value = 0;\n", "    return ebpf_map_update_elem (&map, &key, &value, 0);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "read_write_packet_start": [{"capabilities": [], "helperCallParams": {}, "startLine": 18, "endLine": 27, "File": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/packet_overflow.c", "funcName": "read_write_packet_start", "developer_inline_comments": [{"start_line": 1, "end_line": 1, "text": "// Copyright (c) Prevail Verifier contributors."}, {"start_line": 2, "end_line": 2, "text": "// SPDX-License-Identifier: MIT"}], "updateMaps": [], "readMaps": [], "input": ["struct xdp_md *ctx"], "output": "int", "helper": [], "compatibleHookpoints": ["flow_dissector", "sched_act", "cgroup_device", "lwt_in", "sk_skb", "sk_reuseport", "sched_cls", "tracepoint", "lwt_xmit", "cgroup_skb", "sock_ops", "kprobe", "cgroup_sock_addr", "lwt_seg6local", "cgroup_sysctl", "cgroup_sock", "perf_event", "raw_tracepoint_writable", "lwt_out", "raw_tracepoint", "sk_msg", "socket_filter", "xdp"], "source": ["int read_write_packet_start (struct xdp_md *ctx)\n", "{\n", "    void *data_end = (void *) (long) ctx->data_end;\n", "    void *data = (void *) (long) ctx->data;\n", "    if (data > data_end)\n", "        return 1;\n", "    int value = *(int*) data;\n", "    *(int*) data = value + 1;\n", "    return 0;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 18, "endLine": 27, "File": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/packet_start_ok.c", "funcName": "read_write_packet_start", "developer_inline_comments": [{"start_line": 1, "end_line": 1, "text": "// Copyright (c) Prevail Verifier contributors."}, {"start_line": 2, "end_line": 2, "text": "// SPDX-License-Identifier: MIT"}], "updateMaps": [], "readMaps": [], "input": ["struct xdp_md *ctx"], "output": "int", "helper": [], "compatibleHookpoints": ["flow_dissector", "sched_act", "cgroup_device", "lwt_in", "sk_skb", "sk_reuseport", "sched_cls", "tracepoint", "lwt_xmit", "cgroup_skb", "sock_ops", "kprobe", "cgroup_sock_addr", "lwt_seg6local", "cgroup_sysctl", "cgroup_sock", "perf_event", "raw_tracepoint_writable", "lwt_out", "raw_tracepoint", "sk_msg", "socket_filter", "xdp"], "source": ["int read_write_packet_start (struct xdp_md *ctx)\n", "{\n", "    void *data_end = (void *) (long) ctx->data_end;\n", "    void *data = (void *) (long) ctx->data;\n", "    if (data + sizeof (int) > data_end)\n", "        return 1;\n", "    int value = *(int*) data;\n", "    *(int*) data = value + 1;\n", "    return 0;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "test_repro": [{"capabilities": [], "helperCallParams": {}, "startLine": 28, "endLine": 40, "File": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/badmapptr.c", "funcName": "test_repro", "developer_inline_comments": [{"start_line": 1, "end_line": 1, "text": "// Copyright (c) Prevail Verifier contributors."}, {"start_line": 2, "end_line": 2, "text": "// SPDX-License-Identifier: MIT"}, {"start_line": 22, "end_line": 22, "text": "// BPF_MAP_TYPE_HASH"}, {"start_line": 35, "end_line": 35, "text": "// Instead of passing in the correct map pointer, pass in a value past it."}, {"start_line": 36, "end_line": 36, "text": "// This should fail verification."}], "updateMaps": [], "readMaps": [" map + 1"], "input": ["void *ctx"], "output": "int", "helper": [], "compatibleHookpoints": ["flow_dissector", "sched_act", "cgroup_device", "lwt_in", "sk_skb", "sk_reuseport", "sched_cls", "tracepoint", "lwt_xmit", "cgroup_skb", "sock_ops", "kprobe", "cgroup_sock_addr", "lwt_seg6local", "cgroup_sysctl", "cgroup_sock", "perf_event", "raw_tracepoint_writable", "lwt_out", "raw_tracepoint", "sk_msg", "socket_filter", "xdp"], "source": ["int test_repro (void *ctx)\n", "{\n", "    uint32_t key = 1;\n", "    bpf_map_def_t *map = &test_map;\n", "    uint32_t *value = ebpf_map_lookup_elem (map + 1, &key);\n", "    return (value != 0);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 28, "endLine": 40, "File": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/nullmapref.c", "funcName": "test_repro", "developer_inline_comments": [{"start_line": 1, "end_line": 1, "text": "// Copyright (c) Prevail Verifier contributors."}, {"start_line": 2, "end_line": 2, "text": "// SPDX-License-Identifier: MIT"}, {"start_line": 22, "end_line": 22, "text": "// BPF_MAP_TYPE_HASH"}, {"start_line": 35, "end_line": 35, "text": "// ebpf_map_lookup_elem can return NULL if not found,"}, {"start_line": 36, "end_line": 36, "text": "// so this unchecked dereference should fail verification."}], "updateMaps": [], "readMaps": [" test_map"], "input": ["void *ctx"], "output": "int", "helper": [], "compatibleHookpoints": ["flow_dissector", "sched_act", "cgroup_device", "lwt_in", "sk_skb", "sk_reuseport", "sched_cls", "tracepoint", "lwt_xmit", "cgroup_skb", "sock_ops", "kprobe", "cgroup_sock_addr", "lwt_seg6local", "cgroup_sysctl", "cgroup_sock", "perf_event", "raw_tracepoint_writable", "lwt_out", "raw_tracepoint", "sk_msg", "socket_filter", "xdp"], "source": ["int test_repro (void *ctx)\n", "{\n", "    uint32_t key = 1;\n", "    uint32_t *value = ebpf_map_lookup_elem (&test_map, &key);\n", "    *value = 1;\n", "    return 0;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "reallocate_invalidates": [{"capabilities": [{"capability": "update_pkt", "update_pkt": [{"Project": "libbpf", "Return Type": "int", "Description": "Grows headroom of packet associated to <[ skb ]>(IP: 0) and adjusts the offset of the MAC header accordingly , adding <[ len ]>(IP: 1) bytes of space. It automatically extends and reallocates memory as required. This helper can be used on a layer 3 <[ skb ]>(IP: 0) to push a MAC header for redirection into a layer 2 device. All values for <[ flags ]>(IP: 2) are reserved for future usage , and must be left at zero. A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_skb_change_head", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  u32 ,Var: len}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["sched_cls", "sched_act", "lwt_xmit", "sk_skb"], "capabilities": ["update_pkt"]}]}], "helperCallParams": {}, "startLine": 17, "endLine": 34, "File": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/packet_reallocate.c", "funcName": "reallocate_invalidates", "developer_inline_comments": [{"start_line": 1, "end_line": 1, "text": "// Copyright (c) Prevail Verifier contributors."}, {"start_line": 2, "end_line": 2, "text": "// SPDX-License-Identifier: MIT"}], "updateMaps": [], "readMaps": [], "input": ["struct sk_buff *ctx"], "output": "int", "helper": ["bpf_skb_change_head"], "compatibleHookpoints": ["lwt_xmit", "sched_act", "sk_skb", "sched_cls"], "source": ["int reallocate_invalidates (struct sk_buff *ctx)\n", "{\n", "    void *data_end = (void *) (long) ctx->data_end;\n", "    void *data = (void *) (long) ctx->data;\n", "    if (data + sizeof (int) > data_end)\n", "        return 1;\n", "    int value = *(int*) data;\n", "    *(int*) data = value + 1;\n", "    bpf_skb_change_head (ctx, 4, 0);\n", "    value = *(int*) data;\n", "    *(int*) data = value + 1;\n", "    return 0;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "foo": [{"capabilities": [], "helperCallParams": {}, "startLine": 13, "endLine": 31, "File": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/loop.c", "funcName": "foo", "developer_inline_comments": [{"start_line": 1, "end_line": 1, "text": "// Copyright (c) Prevail Verifier contributors."}, {"start_line": 2, "end_line": 2, "text": "// SPDX-License-Identifier: MIT"}], "updateMaps": [], "readMaps": [], "input": ["struct test_md *ctx"], "output": "int", "helper": [], "compatibleHookpoints": ["flow_dissector", "sched_act", "cgroup_device", "lwt_in", "sk_skb", "sk_reuseport", "sched_cls", "tracepoint", "lwt_xmit", "cgroup_skb", "sock_ops", "kprobe", "cgroup_sock_addr", "lwt_seg6local", "cgroup_sysctl", "cgroup_sock", "perf_event", "raw_tracepoint_writable", "lwt_out", "raw_tracepoint", "sk_msg", "socket_filter", "xdp"], "source": ["int foo (struct test_md *ctx)\n", "{\n", "    int index;\n", "    int cumul = 0;\n", "    uint8_t array [ARRAY_LENGTH] = {0};\n", "    for (index = 0; index < sizeof (array); index++) {\n", "        if ((ctx->data_start + index) >= ctx->data_end)\n", "            break;\n", "        array[index] = 1;\n", "    }\n", "    for (index = 0; index < sizeof (array); index++) {\n", "        cumul += array[index];\n", "    }\n", "    return cumul;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "test": [{"capabilities": [], "helperCallParams": {}, "startLine": 24, "endLine": 32, "File": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/ringbuf_uninit.c", "funcName": "test", "developer_inline_comments": [{"start_line": 1, "end_line": 1, "text": "// Copyright (c) Prevail Verifier contributors."}, {"start_line": 2, "end_line": 2, "text": "// SPDX-License-Identifier: MIT"}, {"start_line": 28, "end_line": 28, "text": "// The following call should fail verification as test is not initialized."}], "updateMaps": [], "readMaps": [], "input": ["void *ctx"], "output": "int", "helper": [], "compatibleHookpoints": ["flow_dissector", "sched_act", "cgroup_device", "lwt_in", "sk_skb", "sk_reuseport", "sched_cls", "tracepoint", "lwt_xmit", "cgroup_skb", "sock_ops", "kprobe", "cgroup_sock_addr", "lwt_seg6local", "cgroup_sysctl", "cgroup_sock", "perf_event", "raw_tracepoint_writable", "lwt_out", "raw_tracepoint", "sk_msg", "socket_filter", "xdp"], "source": ["int test (void *ctx)\n", "{\n", "    uint64_t test;\n", "    bpf_ringbuf_output (&ring_buffer, &test, sizeof (test), 0);\n", "    return 0;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "test_packet_access": [{"capabilities": [{"capability": "read_sys_info", "read_sys_info": [{"Project": "cilium", "Return Type": "u32", "Description": "Get a pseudo-random number. From a security point of view , this helper uses its own pseudo-random internal state , and cannot be used to infer the seed of other random functions in the kernel. However , it is essential to note that the generator used by the helper is not cryptographically secure. ", "Return": " A random 32-bit unsigned value.", "Function Name": "get_prandom_u32", "Input Params": ["{Type: voi ,Var: void}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "raw_tracepoint_writable"], "capabilities": ["read_sys_info"]}]}], "helperCallParams": {}, "startLine": 18, "endLine": 58, "File": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/packet_access.c", "funcName": "test_packet_access", "developer_inline_comments": [{"start_line": 1, "end_line": 1, "text": "// Copyright (c) Prevail Verifier contributors."}, {"start_line": 2, "end_line": 2, "text": "// SPDX-License-Identifier: MIT"}, {"start_line": 26, "end_line": 26, "text": "// We now do two code paths that should have identical results."}, {"start_line": 32, "end_line": 44, "text": "/* The above code results in the following assembly:\n         *            r0 <<= 2\n         *            r0 &= 60\n         *            r1 = *(u32 *)(r6 + 0)\n         *            r1 += r0    // In the ELSE clause below, this becomes\n         *                        // \"r0 += r1\" then \"r1 = r0\".\n         *            r0 = 1\n         *            r2 = r1\n         *            r2 += 4\n         *            r3 = *(u32 *)(r6 + 4)\n         *            if r2 > r3 goto +13\n         *            r0 = *(u32 *)(r1 + 0)\n         */"}, {"start_line": 49, "end_line": 49, "text": "// In the IF clause above, these two instructions"}, {"start_line": 50, "end_line": 50, "text": "// are \"r1 += r0\"."}], "updateMaps": [], "readMaps": [], "input": ["struct xdp_md *ctx"], "output": "int", "helper": ["get_prandom_u32"], "compatibleHookpoints": ["flow_dissector", "sched_act", "lwt_in", "sk_skb", "sk_reuseport", "sched_cls", "tracepoint", "lwt_xmit", "cgroup_skb", "sock_ops", "kprobe", "cgroup_sock_addr", "lwt_seg6local", "cgroup_sock", "perf_event", "raw_tracepoint_writable", "lwt_out", "raw_tracepoint", "sk_msg", "socket_filter", "xdp"], "source": ["int test_packet_access (struct xdp_md *ctx)\n", "{\n", "    uint32_t rand32 = get_prandom_u32 ();\n", "    void *data_end = (void *) (long) ctx->data_end;\n", "    void *data = (void *) (long) ctx->data;\n", "    int offset = (rand32 & 0x0F) * 4;\n", "    int *ptr;\n", "    if (rand32 & 1) {\n", "        if (data + offset + sizeof (int) > data_end)\n", "            return 1;\n", "        ptr = offset + data;\n", "        return *(int*) ptr;\n", "    }\n", "    else {\n", "        asm volatile (\"r0 <<= 2\\n\"\n", "            \"r0 &= 60\\n\"\n", "            \"r1 = *(u32 *)(r6 + 0)\\n\"\n", "            \"r0 += r1\\n\"\n", "            \"r1 = r0\\n\"\n", "            \"r0 = 1\\n\"\n", "            \"r2 = r1\\n\"\n", "            \"r2 += 4\\n\"\n", "            \"r3 = *(u32 *)(r6 + 4)\\n\"\n", "            \"if r2 > r3 goto +1\\n\"\n", "            \"r0 = *(u32 *)(r1 + 0)\\n\"\n", "            );\n", "    }\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}]}