{"caller": [{"capabilities": [], "helperCallParams": {}, "startLine": 24, "endLine": 32, "File": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/tail_call_bad.c", "funcName": "caller", "updateMaps": [], "readMaps": [], "input": ["struct xdp_md *ctx"], "output": "int", "helper": ["bpf_tail_call"], "compatibleHookpoints": ["sk_msg", "lwt_seg6local", "raw_tracepoint", "lwt_xmit", "xdp", "perf_event", "kprobe", "lwt_in", "sk_skb", "sk_reuseport", "socket_filter", "sched_cls", "raw_tracepoint_writable", "cgroup_sock_addr", "cgroup_sock", "lwt_out", "tracepoint", "flow_dissector", "cgroup_skb", "sock_ops", "sched_act"], "source": ["int caller (struct xdp_md *ctx)\n", "{\n", "    long error = bpf_tail_call (ctx, & map, 0);\n", "    return (int) error;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 24, "endLine": 31, "File": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/tail_call.c", "funcName": "caller", "updateMaps": [], "readMaps": [], "input": ["struct xdp_md *ctx"], "output": "int", "helper": ["bpf_tail_call"], "compatibleHookpoints": ["sk_msg", "lwt_seg6local", "raw_tracepoint", "lwt_xmit", "xdp", "perf_event", "kprobe", "lwt_in", "sk_skb", "sk_reuseport", "socket_filter", "sched_cls", "raw_tracepoint_writable", "cgroup_sock_addr", "cgroup_sock", "lwt_out", "tracepoint", "flow_dissector", "cgroup_skb", "sock_ops", "sched_act"], "source": ["int caller (struct xdp_md *ctx)\n", "{\n", "    long error = bpf_tail_call (ctx, & map, 0);\n", "    return (int) error;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "callee": [{"capabilities": [], "helperCallParams": {}, "startLine": 34, "endLine": 38, "File": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/tail_call_bad.c", "funcName": "callee", "updateMaps": [], "readMaps": [], "input": ["struct xdp_md *ctx"], "output": "int", "helper": [], "compatibleHookpoints": ["sk_msg", "lwt_seg6local", "raw_tracepoint", "lwt_xmit", "xdp", "perf_event", "kprobe", "lwt_in", "cgroup_device", "sk_skb", "sk_reuseport", "socket_filter", "sched_cls", "cgroup_sysctl", "raw_tracepoint_writable", "cgroup_sock_addr", "cgroup_sock", "lwt_out", "tracepoint", "flow_dissector", "cgroup_skb", "sock_ops", "sched_act"], "source": ["int callee (struct xdp_md *ctx)\n", "{\n", "    return 42;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 33, "endLine": 37, "File": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/tail_call.c", "funcName": "callee", "updateMaps": [], "readMaps": [], "input": ["struct xdp_md *ctx"], "output": "int", "helper": [], "compatibleHookpoints": ["sk_msg", "lwt_seg6local", "raw_tracepoint", "lwt_xmit", "xdp", "perf_event", "kprobe", "lwt_in", "cgroup_device", "sk_skb", "sk_reuseport", "socket_filter", "sched_cls", "cgroup_sysctl", "raw_tracepoint_writable", "cgroup_sock_addr", "cgroup_sock", "lwt_out", "tracepoint", "flow_dissector", "cgroup_skb", "sock_ops", "sched_act"], "source": ["int callee (struct xdp_md *ctx)\n", "{\n", "    return 42;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "func": [{"capabilities": [], "helperCallParams": {}, "startLine": 29, "endLine": 36, "File": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/exposeptr2.c", "funcName": "func", "updateMaps": [" map"], "readMaps": [], "input": ["struct ctx *ctx"], "output": "int", "helper": [], "compatibleHookpoints": ["sk_msg", "lwt_seg6local", "raw_tracepoint", "lwt_xmit", "xdp", "perf_event", "kprobe", "lwt_in", "cgroup_device", "sk_skb", "sk_reuseport", "socket_filter", "sched_cls", "cgroup_sysctl", "raw_tracepoint_writable", "cgroup_sock_addr", "cgroup_sock", "lwt_out", "tracepoint", "flow_dissector", "cgroup_skb", "sock_ops", "sched_act"], "source": ["int func (struct ctx *ctx)\n", "{\n", "    uint32_t value = 0;\n", "    return ebpf_map_update_elem (&map, &ctx, &value, 0);\n", "}\n"], "called_function_list": ["ebpf_map_update_elem", "ebpf_get_current_comm"], "call_depth": -1, "humanFuncDescription": [{}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "libbpf", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 35, "endLine": 49, "File": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/map_in_map.c", "funcName": "func", "updateMaps": [], "readMaps": [" nolocal_lru_map", " array_of_maps", "  inner_map"], "input": ["void *ctx"], "output": "int", "helper": ["bpf_map_lookup_elem"], "compatibleHookpoints": ["sk_msg", "lwt_seg6local", "raw_tracepoint", "lwt_xmit", "xdp", "perf_event", "kprobe", "lwt_in", "cgroup_device", "sk_skb", "sk_reuseport", "socket_filter", "sched_cls", "cgroup_sysctl", "raw_tracepoint_writable", "cgroup_sock_addr", "cgroup_sock", "lwt_out", "tracepoint", "flow_dissector", "cgroup_skb", "sock_ops", "sched_act"], "source": ["int func (void *ctx)\n", "{\n", "    uint32_t outer_key = 0;\n", "    void *nolocal_lru_map = bpf_map_lookup_elem (&array_of_maps, &outer_key);\n", "    if (nolocal_lru_map) {\n", "        uint32_t inner_key = 0;\n", "        void *ret = bpf_map_lookup_elem (nolocal_lru_map, &inner_key);\n", "        if (ret) {\n", "            return 0;\n", "        }\n", "        else {\n", "            ret = bpf_map_lookup_elem (& inner_map, & inner_key);\n", "            return 0;\n", "        }\n", "    }\n", "    return 0;\n", "}\n"], "called_function_list": ["ebpf_map_update_elem", "ebpf_get_current_comm"], "call_depth": -1, "humanFuncDescription": [{}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 29, "endLine": 38, "File": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/mapunderflow.c", "funcName": "func", "updateMaps": [" map"], "readMaps": [], "input": ["struct ctx *ctx"], "output": "int", "helper": [], "compatibleHookpoints": ["sk_msg", "lwt_seg6local", "raw_tracepoint", "lwt_xmit", "xdp", "perf_event", "kprobe", "lwt_in", "cgroup_device", "sk_skb", "sk_reuseport", "socket_filter", "sched_cls", "cgroup_sysctl", "raw_tracepoint_writable", "cgroup_sock_addr", "cgroup_sock", "lwt_out", "tracepoint", "flow_dissector", "cgroup_skb", "sock_ops", "sched_act"], "source": ["int func (struct ctx *ctx)\n", "{\n", "    int key = -1;\n", "    uint64_t value = 0;\n", "    return ebpf_map_update_elem (&map, &key, &value, 0);\n", "}\n"], "called_function_list": ["ebpf_map_update_elem", "ebpf_get_current_comm"], "call_depth": -1, "humanFuncDescription": [{}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [{"capability": "read_sys_info", "read_sys_info": [{"Project": "cilium", "Return Type": "u32", "Description": "Get a pseudo-random number. From a security point of view , this helper uses its own pseudo-random internal state , and cannot be used to infer the seed of other random functions in the kernel. However , it is essential to note that the generator used by the helper is not cryptographically secure. ", "Return": " A random 32-bit unsigned value.", "Function Name": "get_prandom_u32", "Input Params": ["{Type: voi ,Var: void}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "raw_tracepoint_writable"], "capabilities": ["read_sys_info"]}]}], "helperCallParams": {}, "startLine": 29, "endLine": 48, "File": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/twotypes.c", "funcName": "func", "updateMaps": [], "readMaps": [" map"], "input": ["struct ctx *ctx"], "output": "int", "helper": ["get_prandom_u32", "bpf_map_lookup_elem"], "compatibleHookpoints": ["sk_msg", "lwt_seg6local", "raw_tracepoint", "lwt_xmit", "xdp", "perf_event", "kprobe", "lwt_in", "sk_skb", "sk_reuseport", "socket_filter", "sched_cls", "raw_tracepoint_writable", "cgroup_sock_addr", "cgroup_sock", "lwt_out", "tracepoint", "flow_dissector", "cgroup_skb", "sock_ops", "sched_act"], "source": ["int func (struct ctx *ctx)\n", "{\n", "    uint32_t rand32 = get_prandom_u32 ();\n", "    uint8_t stack_buffer [256] = {0};\n", "    *(uint32_t*) stack_buffer = rand32;\n", "    int map_key = 0;\n", "    uint8_t *map_value = (uint8_t *) bpf_map_lookup_elem (&map, &map_key);\n", "    if (map_value == 0)\n", "        return 0;\n", "    uint8_t *ptr;\n", "    if (rand32 & 1) {\n", "        ptr = map_value;\n", "    }\n", "    else {\n", "        ptr = stack_buffer + 128;\n", "    }\n", "    return (*ptr == stack_buffer[0]) ? 1 : 0;\n", "}\n"], "called_function_list": ["ebpf_map_update_elem", "ebpf_get_current_comm"], "call_depth": -1, "humanFuncDescription": [{}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [{"capability": "map_update", "map_update": [{"Project": "libbpf", "Return Type": "int", "Description": "Add an entry to , or update a <[ map ]>(IP: 1) referencing sockets. The <[ skops ]>(IP: 0) is used as a new value for the entry associated to key. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 2) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 2) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. If the <[ map ]>(IP: 1) has eBPF programs (parser and verdict) , those will be inherited by the socket being added. If the socket is already attached to eBPF programs , this results in an error. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_sock_map_update", "Input Params": ["{Type: struct bpf_sock_ops ,Var: *skops}", "{Type:  struct bpf_map ,Var: *map}", "{Type:  void ,Var: *key}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["sock_ops"], "capabilities": ["map_update"]}]}], "helperCallParams": {}, "startLine": 29, "endLine": 37, "File": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/wronghelper.c", "funcName": "func", "updateMaps": [" ctx"], "readMaps": [], "input": ["void *ctx"], "output": "int", "helper": ["bpf_sock_map_update"], "compatibleHookpoints": ["sock_ops"], "source": ["int func (void *ctx)\n", "{\n", "    uint32_t key = 1;\n", "    int result = bpf_sock_map_update (ctx, & map, & key, 0);\n", "    return result;\n", "}\n"], "called_function_list": ["ebpf_map_update_elem", "ebpf_get_current_comm"], "call_depth": -1, "humanFuncDescription": [{}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [{"capability": "read_sys_info", "read_sys_info": [{"Project": "cilium", "Return Type": "u32", "Description": "Get a pseudo-random number. From a security point of view , this helper uses its own pseudo-random internal state , and cannot be used to infer the seed of other random functions in the kernel. However , it is essential to note that the generator used by the helper is not cryptographically secure. ", "Return": " A random 32-bit unsigned value.", "Function Name": "get_prandom_u32", "Input Params": ["{Type: voi ,Var: void}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "raw_tracepoint_writable"], "capabilities": ["read_sys_info"]}]}], "helperCallParams": {}, "startLine": 8, "endLine": 19, "File": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/stackok.c", "funcName": "func", "updateMaps": [], "readMaps": [], "input": ["void *ctx"], "output": "int", "helper": ["get_prandom_u32"], "compatibleHookpoints": ["sk_msg", "lwt_seg6local", "raw_tracepoint", "lwt_xmit", "xdp", "perf_event", "kprobe", "lwt_in", "sk_skb", "sk_reuseport", "socket_filter", "sched_cls", "raw_tracepoint_writable", "cgroup_sock_addr", "cgroup_sock", "lwt_out", "tracepoint", "flow_dissector", "cgroup_skb", "sock_ops", "sched_act"], "source": ["int func (void *ctx)\n", "{\n", "    char array [256] = \"\";\n", "    uint32_t rand32 = get_prandom_u32 ();\n", "    uint32_t index = *(unsignedchar*) &rand32;\n", "    return array[index];\n", "}\n"], "called_function_list": ["ebpf_map_update_elem", "ebpf_get_current_comm"], "call_depth": -1, "humanFuncDescription": [{}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 8, "endLine": 15, "File": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/badhelpercall.c", "funcName": "func", "updateMaps": [], "readMaps": [], "input": ["NA"], "output": "int", "helper": [], "compatibleHookpoints": ["sk_msg", "lwt_seg6local", "raw_tracepoint", "lwt_xmit", "xdp", "perf_event", "kprobe", "lwt_in", "cgroup_device", "sk_skb", "sk_reuseport", "socket_filter", "sched_cls", "cgroup_sysctl", "raw_tracepoint_writable", "cgroup_sock_addr", "cgroup_sock", "lwt_out", "tracepoint", "flow_dissector", "cgroup_skb", "sock_ops", "sched_act"], "source": ["int func ()\n", "{\n", "    char buffer [1];\n", "    return ebpf_get_current_comm (buffer, 20);\n", "}\n"], "called_function_list": ["ebpf_map_update_elem", "ebpf_get_current_comm"], "call_depth": -1, "humanFuncDescription": [{}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [{"capability": "map_update", "map_update": [{"Project": "libbpf", "Return Type": "int", "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_map_update_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}", "{Type:  const void ,Var: *value}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_update"]}]}], "helperCallParams": {}, "startLine": 31, "endLine": 38, "File": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/badrelo.c", "funcName": "func", "updateMaps": [" map2"], "readMaps": [], "input": ["struct ctx *ctx"], "output": "int", "helper": ["bpf_map_update_elem"], "compatibleHookpoints": ["sk_msg", "lwt_seg6local", "raw_tracepoint", "lwt_xmit", "xdp", "perf_event", "kprobe", "lwt_in", "cgroup_device", "sk_skb", "sk_reuseport", "socket_filter", "sched_cls", "cgroup_sysctl", "raw_tracepoint_writable", "cgroup_sock_addr", "cgroup_sock", "lwt_out", "tracepoint", "flow_dissector", "cgroup_skb", "sock_ops", "sched_act"], "source": ["int func (struct ctx *ctx)\n", "{\n", "    struct bpf_map map2;\n", "    return bpf_map_update_elem (&map2, (const void *) 0, (const void *) 0, 0);\n", "}\n"], "called_function_list": ["ebpf_map_update_elem", "ebpf_get_current_comm"], "call_depth": -1, "humanFuncDescription": [{}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 29, "endLine": 36, "File": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/exposeptr.c", "funcName": "func", "updateMaps": [" map"], "readMaps": [], "input": ["struct ctx *ctx"], "output": "int", "helper": [], "compatibleHookpoints": ["sk_msg", "lwt_seg6local", "raw_tracepoint", "lwt_xmit", "xdp", "perf_event", "kprobe", "lwt_in", "cgroup_device", "sk_skb", "sk_reuseport", "socket_filter", "sched_cls", "cgroup_sysctl", "raw_tracepoint_writable", "cgroup_sock_addr", "cgroup_sock", "lwt_out", "tracepoint", "flow_dissector", "cgroup_skb", "sock_ops", "sched_act"], "source": ["int func (struct ctx *ctx)\n", "{\n", "    uint32_t key = 0;\n", "    return ebpf_map_update_elem (&map, &key, &ctx, 0);\n", "}\n"], "called_function_list": ["ebpf_map_update_elem", "ebpf_get_current_comm"], "call_depth": -1, "humanFuncDescription": [{}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "libbpf", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 26, "endLine": 39, "File": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/mapvalue-overrun.c", "funcName": "func", "updateMaps": [], "readMaps": [" map"], "input": ["void *ctx"], "output": "int", "helper": ["bpf_map_lookup_elem"], "compatibleHookpoints": ["sk_msg", "lwt_seg6local", "raw_tracepoint", "lwt_xmit", "xdp", "perf_event", "kprobe", "lwt_in", "cgroup_device", "sk_skb", "sk_reuseport", "socket_filter", "sched_cls", "cgroup_sysctl", "raw_tracepoint_writable", "cgroup_sock_addr", "cgroup_sock", "lwt_out", "tracepoint", "flow_dissector", "cgroup_skb", "sock_ops", "sched_act"], "source": ["int func (void *ctx)\n", "{\n", "    uint32_t key = 1;\n", "    uint64_t *ptr = bpf_map_lookup_elem (&map, &key);\n", "    if (ptr == 0) {\n", "        return 0;\n", "    }\n", "    uint64_t i = *ptr;\n", "    return (uint32_t) i;\n", "}\n"], "called_function_list": ["ebpf_map_update_elem", "ebpf_get_current_comm"], "call_depth": -1, "humanFuncDescription": [{}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [{"capability": "read_sys_info", "read_sys_info": [{"Project": "cilium", "Return Type": "u32", "Description": "Get a pseudo-random number. From a security point of view , this helper uses its own pseudo-random internal state , and cannot be used to infer the seed of other random functions in the kernel. However , it is essential to note that the generator used by the helper is not cryptographically secure. ", "Return": " A random 32-bit unsigned value.", "Function Name": "get_prandom_u32", "Input Params": ["{Type: voi ,Var: void}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "raw_tracepoint_writable"], "capabilities": ["read_sys_info"]}]}], "helperCallParams": {}, "startLine": 36, "endLine": 48, "File": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/twomaps.c", "funcName": "func", "updateMaps": [], "readMaps": [" map"], "input": ["struct ctx *ctx"], "output": "int", "helper": ["get_prandom_u32", "bpf_map_lookup_elem"], "compatibleHookpoints": ["sk_msg", "lwt_seg6local", "raw_tracepoint", "lwt_xmit", "xdp", "perf_event", "kprobe", "lwt_in", "sk_skb", "sk_reuseport", "socket_filter", "sched_cls", "raw_tracepoint_writable", "cgroup_sock_addr", "cgroup_sock", "lwt_out", "tracepoint", "flow_dissector", "cgroup_skb", "sock_ops", "sched_act"], "source": ["int func (struct ctx *ctx)\n", "{\n", "    uint32_t rand32 = get_prandom_u32 ();\n", "    struct ebpf_map *map = (rand32 & 1) ? &map1 : &map2;\n", "    int key = 10;\n", "    uint64_t *value = (uint64_t *) bpf_map_lookup_elem (map, &key);\n", "    if (value == 0)\n", "        return 0;\n", "    return (int) *value;\n", "}\n"], "called_function_list": ["ebpf_map_update_elem", "ebpf_get_current_comm"], "call_depth": -1, "humanFuncDescription": [{}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [{"capability": "read_sys_info", "read_sys_info": [{"Project": "cilium", "Return Type": "u32", "Description": "Get a pseudo-random number. From a security point of view , this helper uses its own pseudo-random internal state , and cannot be used to infer the seed of other random functions in the kernel. However , it is essential to note that the generator used by the helper is not cryptographically secure. ", "Return": " A random 32-bit unsigned value.", "Function Name": "get_prandom_u32", "Input Params": ["{Type: voi ,Var: void}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "raw_tracepoint_writable"], "capabilities": ["read_sys_info"]}]}], "helperCallParams": {}, "startLine": 10, "endLine": 46, "File": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/twostackvars.c", "funcName": "func", "updateMaps": [], "readMaps": [], "input": ["struct ctx *ctx"], "output": "int", "helper": ["get_prandom_u32"], "compatibleHookpoints": ["sk_msg", "lwt_seg6local", "raw_tracepoint", "lwt_xmit", "xdp", "perf_event", "kprobe", "lwt_in", "sk_skb", "sk_reuseport", "socket_filter", "sched_cls", "raw_tracepoint_writable", "cgroup_sock_addr", "cgroup_sock", "lwt_out", "tracepoint", "flow_dissector", "cgroup_skb", "sock_ops", "sched_act"], "source": ["int func (struct ctx *ctx)\n", "{\n", "    int stack_buffer [16];\n", "    int *ptr = (int *) 0;\n", "    uint32_t rand32 = get_prandom_u32 ();\n", "    if (rand32 & 1) {\n", "        for (int i = 0; i < 8; i++) {\n", "            stack_buffer[i] = get_prandom_u32 ();\n", "        }\n", "        int index = rand32 % 8;\n", "        ptr = &stack_buffer[index];\n", "        ptr[index ^ 1] = 0;\n", "    }\n", "    else {\n", "        int *stack_buffer2 = &stack_buffer[8];\n", "        for (int i = 0; i < 8; i++) {\n", "            stack_buffer2[i] = get_prandom_u32 ();\n", "        }\n", "        ptr = &stack_buffer2[rand32 % 8];\n", "    }\n", "    return *ptr;\n", "}\n"], "called_function_list": ["ebpf_map_update_elem", "ebpf_get_current_comm"], "call_depth": -1, "humanFuncDescription": [{}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [{"capability": "read_sys_info", "read_sys_info": [{"Project": "cilium", "Return Type": "u32", "Description": "Get a pseudo-random number. From a security point of view , this helper uses its own pseudo-random internal state , and cannot be used to infer the seed of other random functions in the kernel. However , it is essential to note that the generator used by the helper is not cryptographically secure. ", "Return": " A random 32-bit unsigned value.", "Function Name": "get_prandom_u32", "Input Params": ["{Type: voi ,Var: void}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "raw_tracepoint_writable"], "capabilities": ["read_sys_info"]}]}], "helperCallParams": {}, "startLine": 8, "endLine": 26, "File": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/byteswap.c", "funcName": "func", "updateMaps": [], "readMaps": [], "input": ["struct ctx *ctx"], "output": "int", "helper": ["get_prandom_u32"], "compatibleHookpoints": ["sk_msg", "lwt_seg6local", "raw_tracepoint", "lwt_xmit", "xdp", "perf_event", "kprobe", "lwt_in", "sk_skb", "sk_reuseport", "socket_filter", "sched_cls", "raw_tracepoint_writable", "cgroup_sock_addr", "cgroup_sock", "lwt_out", "tracepoint", "flow_dissector", "cgroup_skb", "sock_ops", "sched_act"], "source": ["int func (struct ctx *ctx)\n", "{\n", "    int rand32 = get_prandom_u32 ();\n", "    if (rand32 & 0x01) {\n", "        asm volatile (\"r0 = le64 r0\\nexit\"\n", "            );\n", "    }\n", "    else if (rand32 & 0x02) {\n", "        asm volatile (\"r0 = le32 r0\\nexit\"\n", "            );\n", "    }\n", "    else if (rand32 & 0x04) {\n", "        asm volatile (\"r0 = le16 r0\\nexit\"\n", "            );\n", "    }\n", "    else if (rand32 & 0x10) {\n", "        asm volatile (\"r0 = be64 r0\\nexit\"\n", "            );\n", "    }\n", "    else if (rand32 & 0x20) {\n", "        asm volatile (\"r0 = be32 r0\\nexit\"\n", "            );\n", "    }\n", "    else {\n", "        asm volatile (\"r0 = be16 r0\\nexit\"\n", "            );\n", "    }\n", "    return 0;\n", "}\n"], "called_function_list": ["ebpf_map_update_elem", "ebpf_get_current_comm"], "call_depth": -1, "humanFuncDescription": [{}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [{"capability": "map_update", "map_update": [{"Project": "libbpf", "Return Type": "int", "Description": "Add an entry to , or update a <[ map ]>(IP: 1) referencing sockets. The <[ skops ]>(IP: 0) is used as a new value for the entry associated to key. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 2) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 2) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. If the <[ map ]>(IP: 1) has eBPF programs (parser and verdict) , those will be inherited by the socket being added. If the socket is already attached to eBPF programs , this results in an error. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_sock_map_update", "Input Params": ["{Type: struct bpf_sock_ops ,Var: *skops}", "{Type:  struct bpf_map ,Var: *map}", "{Type:  void ,Var: *key}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["sock_ops"], "capabilities": ["map_update"]}]}], "helperCallParams": {}, "startLine": 29, "endLine": 38, "File": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/ctxoffset.c", "funcName": "func", "updateMaps": [" ctx"], "readMaps": [], "input": ["void *ctx"], "output": "int", "helper": ["bpf_sock_map_update"], "compatibleHookpoints": ["sock_ops"], "source": ["int func (void *ctx)\n", "{\n", "    uint32_t key = 1;\n", "    ctx = ((char *) ctx) + 8;\n", "    int result = bpf_sock_map_update (ctx, & map, & key, 0);\n", "    return result;\n", "}\n"], "called_function_list": ["ebpf_map_update_elem", "ebpf_get_current_comm"], "call_depth": -1, "humanFuncDescription": [{}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 29, "endLine": 37, "File": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/mapoverflow.c", "funcName": "func", "updateMaps": [" map"], "readMaps": [], "input": ["struct ctx *ctx"], "output": "int", "helper": [], "compatibleHookpoints": ["sk_msg", "lwt_seg6local", "raw_tracepoint", "lwt_xmit", "xdp", "perf_event", "kprobe", "lwt_in", "cgroup_device", "sk_skb", "sk_reuseport", "socket_filter", "sched_cls", "cgroup_sysctl", "raw_tracepoint_writable", "cgroup_sock_addr", "cgroup_sock", "lwt_out", "tracepoint", "flow_dissector", "cgroup_skb", "sock_ops", "sched_act"], "source": ["int func (struct ctx *ctx)\n", "{\n", "    uint32_t key = 10;\n", "    uint64_t value = 0;\n", "    return ebpf_map_update_elem (&map, &key, &value, 0);\n", "}\n"], "called_function_list": ["ebpf_map_update_elem", "ebpf_get_current_comm"], "call_depth": -1, "humanFuncDescription": [{}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "read_write_packet_start": [{"capabilities": [], "helperCallParams": {}, "startLine": 18, "endLine": 27, "File": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/packet_overflow.c", "funcName": "read_write_packet_start", "updateMaps": [], "readMaps": [], "input": ["struct xdp_md *ctx"], "output": "int", "helper": [], "compatibleHookpoints": ["sk_msg", "lwt_seg6local", "raw_tracepoint", "lwt_xmit", "xdp", "perf_event", "kprobe", "lwt_in", "cgroup_device", "sk_skb", "sk_reuseport", "socket_filter", "sched_cls", "cgroup_sysctl", "raw_tracepoint_writable", "cgroup_sock_addr", "cgroup_sock", "lwt_out", "tracepoint", "flow_dissector", "cgroup_skb", "sock_ops", "sched_act"], "source": ["int read_write_packet_start (struct xdp_md *ctx)\n", "{\n", "    void *data_end = (void *) (long) ctx->data_end;\n", "    void *data = (void *) (long) ctx->data;\n", "    if (data > data_end)\n", "        return 1;\n", "    int value = *(int*) data;\n", "    *(int*) data = value + 1;\n", "    return 0;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 18, "endLine": 27, "File": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/packet_start_ok.c", "funcName": "read_write_packet_start", "updateMaps": [], "readMaps": [], "input": ["struct xdp_md *ctx"], "output": "int", "helper": [], "compatibleHookpoints": ["sk_msg", "lwt_seg6local", "raw_tracepoint", "lwt_xmit", "xdp", "perf_event", "kprobe", "lwt_in", "cgroup_device", "sk_skb", "sk_reuseport", "socket_filter", "sched_cls", "cgroup_sysctl", "raw_tracepoint_writable", "cgroup_sock_addr", "cgroup_sock", "lwt_out", "tracepoint", "flow_dissector", "cgroup_skb", "sock_ops", "sched_act"], "source": ["int read_write_packet_start (struct xdp_md *ctx)\n", "{\n", "    void *data_end = (void *) (long) ctx->data_end;\n", "    void *data = (void *) (long) ctx->data;\n", "    if (data + sizeof (int) > data_end)\n", "        return 1;\n", "    int value = *(int*) data;\n", "    *(int*) data = value + 1;\n", "    return 0;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "test_repro": [{"capabilities": [], "helperCallParams": {}, "startLine": 28, "endLine": 40, "File": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/badmapptr.c", "funcName": "test_repro", "updateMaps": [], "readMaps": [" map + 1"], "input": ["void *ctx"], "output": "int", "helper": [], "compatibleHookpoints": ["sk_msg", "lwt_seg6local", "raw_tracepoint", "lwt_xmit", "xdp", "perf_event", "kprobe", "lwt_in", "cgroup_device", "sk_skb", "sk_reuseport", "socket_filter", "sched_cls", "cgroup_sysctl", "raw_tracepoint_writable", "cgroup_sock_addr", "cgroup_sock", "lwt_out", "tracepoint", "flow_dissector", "cgroup_skb", "sock_ops", "sched_act"], "source": ["int test_repro (void *ctx)\n", "{\n", "    uint32_t key = 1;\n", "    bpf_map_def_t *map = &test_map;\n", "    uint32_t *value = ebpf_map_lookup_elem (map + 1, &key);\n", "    return (value != 0);\n", "}\n"], "called_function_list": ["ebpf_map_lookup_elem"], "call_depth": -1, "humanFuncDescription": [{}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 28, "endLine": 40, "File": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/nullmapref.c", "funcName": "test_repro", "updateMaps": [], "readMaps": [" test_map"], "input": ["void *ctx"], "output": "int", "helper": [], "compatibleHookpoints": ["sk_msg", "lwt_seg6local", "raw_tracepoint", "lwt_xmit", "xdp", "perf_event", "kprobe", "lwt_in", "cgroup_device", "sk_skb", "sk_reuseport", "socket_filter", "sched_cls", "cgroup_sysctl", "raw_tracepoint_writable", "cgroup_sock_addr", "cgroup_sock", "lwt_out", "tracepoint", "flow_dissector", "cgroup_skb", "sock_ops", "sched_act"], "source": ["int test_repro (void *ctx)\n", "{\n", "    uint32_t key = 1;\n", "    uint32_t *value = ebpf_map_lookup_elem (&test_map, &key);\n", "    *value = 1;\n", "    return 0;\n", "}\n"], "called_function_list": ["ebpf_map_lookup_elem"], "call_depth": -1, "humanFuncDescription": [{}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "reallocate_invalidates": [{"capabilities": [{"capability": "update_pkt", "update_pkt": [{"Project": "libbpf", "Return Type": "int", "Description": "Grows headroom of packet associated to <[ skb ]>(IP: 0) and adjusts the offset of the MAC header accordingly , adding <[ len ]>(IP: 1) bytes of space. It automatically extends and reallocates memory as required. This helper can be used on a layer 3 <[ skb ]>(IP: 0) to push a MAC header for redirection into a layer 2 device. All values for <[ flags ]>(IP: 2) are reserved for future usage , and must be left at zero. A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_skb_change_head", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  u32 ,Var: len}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["sched_cls", "sched_act", "lwt_xmit", "sk_skb"], "capabilities": ["update_pkt"]}]}], "helperCallParams": {}, "startLine": 17, "endLine": 34, "File": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/packet_reallocate.c", "funcName": "reallocate_invalidates", "updateMaps": [], "readMaps": [], "input": ["struct sk_buff *ctx"], "output": "int", "helper": ["bpf_skb_change_head"], "compatibleHookpoints": ["sk_skb", "sched_cls", "sched_act", "lwt_xmit"], "source": ["int reallocate_invalidates (struct sk_buff *ctx)\n", "{\n", "    void *data_end = (void *) (long) ctx->data_end;\n", "    void *data = (void *) (long) ctx->data;\n", "    if (data + sizeof (int) > data_end)\n", "        return 1;\n", "    int value = *(int*) data;\n", "    *(int*) data = value + 1;\n", "    bpf_skb_change_head (ctx, 4, 0);\n", "    value = *(int*) data;\n", "    *(int*) data = value + 1;\n", "    return 0;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "foo": [{"capabilities": [], "helperCallParams": {}, "startLine": 13, "endLine": 31, "File": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/loop.c", "funcName": "foo", "updateMaps": [], "readMaps": [], "input": ["struct test_md *ctx"], "output": "int", "helper": [], "compatibleHookpoints": ["sk_msg", "lwt_seg6local", "raw_tracepoint", "lwt_xmit", "xdp", "perf_event", "kprobe", "lwt_in", "cgroup_device", "sk_skb", "sk_reuseport", "socket_filter", "sched_cls", "cgroup_sysctl", "raw_tracepoint_writable", "cgroup_sock_addr", "cgroup_sock", "lwt_out", "tracepoint", "flow_dissector", "cgroup_skb", "sock_ops", "sched_act"], "source": ["int foo (struct test_md *ctx)\n", "{\n", "    int index;\n", "    int cumul = 0;\n", "    uint8_t array [ARRAY_LENGTH] = {0};\n", "    for (index = 0; index < sizeof (array); index++) {\n", "        if ((ctx->data_start + index) >= ctx->data_end)\n", "            break;\n", "        array[index] = 1;\n", "    }\n", "    for (index = 0; index < sizeof (array); index++) {\n", "        cumul += array[index];\n", "    }\n", "    return cumul;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "test": [{"capabilities": [], "helperCallParams": {}, "startLine": 24, "endLine": 32, "File": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/ringbuf_uninit.c", "funcName": "test", "updateMaps": [], "readMaps": [], "input": ["void *ctx"], "output": "int", "helper": [], "compatibleHookpoints": ["sk_msg", "lwt_seg6local", "raw_tracepoint", "lwt_xmit", "xdp", "perf_event", "kprobe", "lwt_in", "cgroup_device", "sk_skb", "sk_reuseport", "socket_filter", "sched_cls", "cgroup_sysctl", "raw_tracepoint_writable", "cgroup_sock_addr", "cgroup_sock", "lwt_out", "tracepoint", "flow_dissector", "cgroup_skb", "sock_ops", "sched_act"], "source": ["int test (void *ctx)\n", "{\n", "    uint64_t test;\n", "    bpf_ringbuf_output (&ring_buffer, &test, sizeof (test), 0);\n", "    return 0;\n", "}\n"], "called_function_list": ["bpf_ringbuf_output"], "call_depth": -1, "humanFuncDescription": [{}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "test_packet_access": [{"capabilities": [{"capability": "read_sys_info", "read_sys_info": [{"Project": "cilium", "Return Type": "u32", "Description": "Get a pseudo-random number. From a security point of view , this helper uses its own pseudo-random internal state , and cannot be used to infer the seed of other random functions in the kernel. However , it is essential to note that the generator used by the helper is not cryptographically secure. ", "Return": " A random 32-bit unsigned value.", "Function Name": "get_prandom_u32", "Input Params": ["{Type: voi ,Var: void}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "raw_tracepoint_writable"], "capabilities": ["read_sys_info"]}]}], "helperCallParams": {}, "startLine": 18, "endLine": 58, "File": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/packet_access.c", "funcName": "test_packet_access", "updateMaps": [], "readMaps": [], "input": ["struct xdp_md *ctx"], "output": "int", "helper": ["get_prandom_u32"], "compatibleHookpoints": ["sk_msg", "lwt_seg6local", "raw_tracepoint", "lwt_xmit", "xdp", "perf_event", "kprobe", "lwt_in", "sk_skb", "sk_reuseport", "socket_filter", "sched_cls", "raw_tracepoint_writable", "cgroup_sock_addr", "cgroup_sock", "lwt_out", "tracepoint", "flow_dissector", "cgroup_skb", "sock_ops", "sched_act"], "source": ["int test_packet_access (struct xdp_md *ctx)\n", "{\n", "    uint32_t rand32 = get_prandom_u32 ();\n", "    void *data_end = (void *) (long) ctx->data_end;\n", "    void *data = (void *) (long) ctx->data;\n", "    int offset = (rand32 & 0x0F) * 4;\n", "    int *ptr;\n", "    if (rand32 & 1) {\n", "        if (data + offset + sizeof (int) > data_end)\n", "            return 1;\n", "        ptr = offset + data;\n", "        return *(int*) ptr;\n", "    }\n", "    else {\n", "        asm volatile (\"r0 <<= 2\\n\"\n", "            \"r0 &= 60\\n\"\n", "            \"r1 = *(u32 *)(r6 + 0)\\n\"\n", "            \"r0 += r1\\n\"\n", "            \"r1 = r0\\n\"\n", "            \"r0 = 1\\n\"\n", "            \"r2 = r1\\n\"\n", "            \"r2 += 4\\n\"\n", "            \"r3 = *(u32 *)(r6 + 4)\\n\"\n", "            \"if r2 > r3 goto +1\\n\"\n", "            \"r0 = *(u32 *)(r1 + 0)\\n\"\n", "            );\n", "    }\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}]}