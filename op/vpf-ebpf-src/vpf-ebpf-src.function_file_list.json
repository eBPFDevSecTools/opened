{"caller": [{"fileName": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/tail_call_bad.c", "startLine": "24", "endLine": "32", "capability": {"capability": [], "helperCallParams": {"bpf_tail_call": ["{\n \"opVar\": \"        long error \",\n \"inpVar\": [\n  \" ctx\",\n  \" &map\",\n  \" 0\"\n ]\n}"]}}}, {"fileName": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/tail_call.c", "startLine": "24", "endLine": "31", "capability": {"capability": [], "helperCallParams": {"bpf_tail_call": ["{\n \"opVar\": \"    long error \",\n \"inpVar\": [\n  \" ctx\",\n  \" &map\",\n  \" 0\"\n ]\n}"]}}}], "callee": [{"fileName": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/tail_call_bad.c", "startLine": "34", "endLine": "38", "capability": {"capability": [], "helperCallParams": {}}}, {"fileName": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/tail_call.c", "startLine": "33", "endLine": "37", "capability": {"capability": [], "helperCallParams": {}}}], "func": [{"fileName": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/exposeptr2.c", "startLine": "29", "endLine": "36", "capability": {"capability": [{"map_update": [{"Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of:BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ", "Return": "0 on success, or a negative error in case of failure.", "Return Type": "int", "Function Name": "bpf_map_update_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}", "{Type:  const void ,Var: *value}", "{Type:  u64 ,Var: flags}"]}]}], "helperCallParams": {"bpf_map_update_elem": ["{\n \"opVar\": \"NA\",\n \"inpVar\": [\n  \"            return e&map\",\n  \" &ctx\",\n  \" &value\",\n  \" 0\"\n ]\n}"]}}}, {"fileName": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/map_in_map.c", "startLine": "35", "endLine": "49", "capability": {"capability": [{"map_read": [{"Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": "Map value associated to key, or NULL if no entry was found.", "Return Type": "void", "Function Name": "*bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"bpf_map_lookup_elem": ["{\n \"opVar\": \"    void* nolocal_lru_map \",\n \"inpVar\": [\n  \" &array_of_maps\",\n  \" &outer_key\"\n ]\n}", "{\n \"opVar\": \"        void* ret \",\n \"inpVar\": [\n  \" nolocal_lru_map\",\n  \" &inner_key\"\n ]\n}", "{\n \"opVar\": \"            ret \",\n \"inpVar\": [\n  \" &inner_map\",\n  \" &inner_key\"\n ]\n}"]}}}, {"fileName": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/mapunderflow.c", "startLine": "29", "endLine": "38", "capability": {"capability": [{"map_update": [{"Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of:BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ", "Return": "0 on success, or a negative error in case of failure.", "Return Type": "int", "Function Name": "bpf_map_update_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}", "{Type:  const void ,Var: *value}", "{Type:  u64 ,Var: flags}"]}]}], "helperCallParams": {"bpf_map_update_elem": ["{\n \"opVar\": \"NA\",\n \"inpVar\": [\n  \"                return e&map\",\n  \" &key\",\n  \" &value\",\n  \" 0\"\n ]\n}"]}}}, {"fileName": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/twotypes.c", "startLine": "29", "endLine": "48", "capability": {"capability": [{"map_read": [{"Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": "Map value associated to key, or NULL if no entry was found.", "Return Type": "void", "Function Name": "*bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"bpf_map_lookup_elem": ["{\n \"opVar\": \"    uint8_t* map_value \",\n \"inpVar\": [\n  \" uint8_t*&map\",\n  \" &map_key\"\n ]\n}"]}}}, {"fileName": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/wronghelper.c", "startLine": "29", "endLine": "37", "capability": {"capability": [{"map_update": [{"Description": "Add an entry to , or update a <[ map ]>(IP: 1) referencing sockets. The <[ skops ]>(IP: 0) is used as a new value for the entry associated to key. <[ flags ]>(IP: 3) is one of:BPF_NOEXISTThe entry for <[ key ]>(IP: 2) must not exist in the map. BPF_EXISTThe entry for <[ key ]>(IP: 2) must already exist in the map. BPF_ANYNo condition on the existence of the entry for key. If the <[ map ]>(IP: 1) has eBPF programs (parser and verdict) , those will be inherited by the socket being added. If the socket is already attached to eBPF programs , this results in an error. ", "Return": "0 on success, or a negative error in case of failure.", "Return Type": "int", "Function Name": "bpf_sock_map_update", "Input Params": ["{Type: struct bpf_sock_ops ,Var: *skops}", "{Type:  struct bpf_map ,Var: *map}", "{Type:  void ,Var: *key}", "{Type:  u64 ,Var: flags}"]}]}], "helperCallParams": {"bpf_sock_map_update": ["{\n \"opVar\": \"            int result \",\n \"inpVar\": [\n  \" ctx\",\n  \" &map\",\n  \" &key\",\n  \" 0\"\n ]\n}"]}}}, {"fileName": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/stackok.c", "startLine": "8", "endLine": "19", "capability": {"capability": [], "helperCallParams": {}}}, {"fileName": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/badhelpercall.c", "startLine": "8", "endLine": "15", "capability": {"capability": [{"read_sys_info": [{"Description": "Copy the comm attribute of the current task into <[ buf ]>(IP: 0) of size_of_buf. The comm attribute contains the name of the executable (excluding the path) for the current task. The <[ size_of_buf ]>(IP: 1) must be strictly positive. On success , the helper makes sure that the <[ buf ]>(IP: 0) is NUL-terminated. On failure , it is filled with zeroes. ", "Return": "0 on success, or a negative error in case of failure.", "Return Type": "int", "Function Name": "bpf_get_current_comm", "Input Params": ["{Type: char ,Var: *buf}", "{Type:  u32 ,Var: size_of_buf}"]}]}], "helperCallParams": {"bpf_get_current_comm": ["{\n \"opVar\": \"NA\",\n \"inpVar\": [\n  \"            return ebuffer\",\n  \" 20\"\n ]\n}"]}}}, {"fileName": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/badrelo.c", "startLine": "31", "endLine": "38", "capability": {"capability": [{"map_update": [{"Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of:BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ", "Return": "0 on success, or a negative error in case of failure.", "Return Type": "int", "Function Name": "bpf_map_update_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}", "{Type:  const void ,Var: *value}", "{Type:  u64 ,Var: flags}"]}]}], "helperCallParams": {"bpf_map_update_elem": ["{\n \"opVar\": \"NA\",\n \"inpVar\": [\n  \"            return &map2\",\n  \" const void*0\",\n  \" const void*0\",\n  \" 0\"\n ]\n}"]}}}, {"fileName": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/exposeptr.c", "startLine": "29", "endLine": "36", "capability": {"capability": [{"map_update": [{"Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of:BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ", "Return": "0 on success, or a negative error in case of failure.", "Return Type": "int", "Function Name": "bpf_map_update_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}", "{Type:  const void ,Var: *value}", "{Type:  u64 ,Var: flags}"]}]}], "helperCallParams": {"bpf_map_update_elem": ["{\n \"opVar\": \"NA\",\n \"inpVar\": [\n  \"            return e&map\",\n  \" &key\",\n  \" &ctx\",\n  \" 0\"\n ]\n}"]}}}, {"fileName": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/mapvalue-overrun.c", "startLine": "26", "endLine": "39", "capability": {"capability": [{"map_read": [{"Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": "Map value associated to key, or NULL if no entry was found.", "Return Type": "void", "Function Name": "*bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"bpf_map_lookup_elem": ["{\n \"opVar\": \"    uint64_t* ptr \",\n \"inpVar\": [\n  \" &map\",\n  \" &key\"\n ]\n}"]}}}, {"fileName": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/twomaps.c", "startLine": "36", "endLine": "48", "capability": {"capability": [{"map_read": [{"Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": "Map value associated to key, or NULL if no entry was found.", "Return Type": "void", "Function Name": "*bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"bpf_map_lookup_elem": ["{\n \"opVar\": \"    uint64_t* value \",\n \"inpVar\": [\n  \" uint64_t*map\",\n  \" &key\"\n ]\n}"]}}}, {"fileName": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/twostackvars.c", "startLine": "10", "endLine": "46", "capability": {"capability": [], "helperCallParams": {}}}, {"fileName": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/byteswap.c", "startLine": "8", "endLine": "26", "capability": {"capability": [], "helperCallParams": {}}}, {"fileName": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/ctxoffset.c", "startLine": "29", "endLine": "38", "capability": {"capability": [{"map_update": [{"Description": "Add an entry to , or update a <[ map ]>(IP: 1) referencing sockets. The <[ skops ]>(IP: 0) is used as a new value for the entry associated to key. <[ flags ]>(IP: 3) is one of:BPF_NOEXISTThe entry for <[ key ]>(IP: 2) must not exist in the map. BPF_EXISTThe entry for <[ key ]>(IP: 2) must already exist in the map. BPF_ANYNo condition on the existence of the entry for key. If the <[ map ]>(IP: 1) has eBPF programs (parser and verdict) , those will be inherited by the socket being added. If the socket is already attached to eBPF programs , this results in an error. ", "Return": "0 on success, or a negative error in case of failure.", "Return Type": "int", "Function Name": "bpf_sock_map_update", "Input Params": ["{Type: struct bpf_sock_ops ,Var: *skops}", "{Type:  struct bpf_map ,Var: *map}", "{Type:  void ,Var: *key}", "{Type:  u64 ,Var: flags}"]}]}], "helperCallParams": {"bpf_sock_map_update": ["{\n \"opVar\": \"    int result \",\n \"inpVar\": [\n  \" ctx\",\n  \" &map\",\n  \" &key\",\n  \" 0\"\n ]\n}"]}}}, {"fileName": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/mapoverflow.c", "startLine": "29", "endLine": "37", "capability": {"capability": [{"map_update": [{"Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of:BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ", "Return": "0 on success, or a negative error in case of failure.", "Return Type": "int", "Function Name": "bpf_map_update_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}", "{Type:  const void ,Var: *value}", "{Type:  u64 ,Var: flags}"]}]}], "helperCallParams": {"bpf_map_update_elem": ["{\n \"opVar\": \"NA\",\n \"inpVar\": [\n  \"            return e&map\",\n  \" &key\",\n  \" &value\",\n  \" 0\"\n ]\n}"]}}}], "read_write_packet_start": [{"fileName": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/packet_overflow.c", "startLine": "18", "endLine": "27", "capability": {"capability": [], "helperCallParams": {}}}, {"fileName": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/packet_start_ok.c", "startLine": "18", "endLine": "27", "capability": {"capability": [], "helperCallParams": {}}}], "test_repro": [{"fileName": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/badmapptr.c", "startLine": "28", "endLine": "40", "capability": {"capability": [{"map_read": [{"Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": "Map value associated to key, or NULL if no entry was found.", "Return Type": "void", "Function Name": "*bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"bpf_map_lookup_elem": ["{\n \"opVar\": \"            uint32_t* value \",\n \"inpVar\": [\n  \" emap + 1\",\n  \" &key\"\n ]\n}"]}}}, {"fileName": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/nullmapref.c", "startLine": "28", "endLine": "40", "capability": {"capability": [{"map_read": [{"Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": "Map value associated to key, or NULL if no entry was found.", "Return Type": "void", "Function Name": "*bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"bpf_map_lookup_elem": ["{\n \"opVar\": \"    uint32_t* value \",\n \"inpVar\": [\n  \" e&test_map\",\n  \" &key\"\n ]\n}"]}}}], "reallocate_invalidates": [{"fileName": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/packet_reallocate.c", "startLine": "17", "endLine": "34", "capability": {"capability": [{"update_pkt": [{"Description": "Grows headroom of packet associated to <[ skb ]>(IP: 0) and adjusts the offset of the MAC header accordingly , adding <[ len ]>(IP: 1) bytes of space. It automatically extends and reallocates memory as required. This helper can be used on a layer 3 <[ skb ]>(IP: 0) to push a MAC header for redirection into a layer 2 device. All values for <[ flags ]>(IP: 2) are reserved for future usage , and must be left at zero. A call to this helper is susceptible to change the underlaying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": "0 on success, or a negative error in case of failure.", "Return Type": "int", "Function Name": "bpf_skb_change_head", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  u32 ,Var: len}", "{Type:  u64 ,Var: flags}"]}]}], "helperCallParams": {"bpf_skb_change_head": ["{\n \"opVar\": \"NA\",\n \"inpVar\": [\n  \"    ctx\",\n  \" 4\",\n  \" 0\"\n ]\n}"]}}}], "foo": [{"fileName": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/loop.c", "startLine": "13", "endLine": "31", "capability": {"capability": [], "helperCallParams": {}}}], "test": [{"fileName": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/ringbuf_uninit.c", "startLine": "24", "endLine": "32", "capability": {"capability": [], "helperCallParams": {}}}], "test_packet_access": [{"fileName": "/home/sayandes/opened_extraction/examples/vpf-ebpf-src/packet_access.c", "startLine": "18", "endLine": "58", "capability": {"capability": [], "helperCallParams": {}}}]}