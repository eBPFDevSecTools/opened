{"*lb4_lookup_service": [{"fileName": "/home/sayandes/opened_extraction/examples/kpng-master/backends/ebpf/bpf/cgroup_connect4.c", "startLine": "59", "endLine": "69", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}, {"Project": "libbpf", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}}}], "ctx_dst_port": [{"fileName": "/home/sayandes/opened_extraction/examples/kpng-master/backends/ebpf/bpf/cgroup_connect4.c", "startLine": "72", "endLine": "76", "capability": {"capabilities": [], "helperCallParams": {}}}], "sock_select_slot": [{"fileName": "/home/sayandes/opened_extraction/examples/kpng-master/backends/ebpf/bpf/cgroup_connect4.c", "startLine": "78", "endLine": "80", "capability": {"capabilities": [{"capability": "read_sys_info", "read_sys_info": [{"Project": "bcc", "FunctionName": "bpf_get_prandom_u32", "Return Type": "u32", "Description": "u32 bpf_get_prandom_u32 Returns a pseudo-random u32. Example in situ: \"https://github.com/iovisor/bcc/search?q=bpf_get_prandom_u32+path%3Aexamples&type=Code search /examples , \"https://github.com/iovisor/bcc/search?q=bpf_get_prandom_u32+path%3Atools&type=Code search /tools ", "Return": "Returns a pseudo-random u32", "Input Prameters": [], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "raw_tracepoint_writable"], "capabilities": ["read_sys_info"]}, {"Project": "cilium", "Return Type": "u32", "Description": "Get a pseudo-random number. From a security point of view , this helper uses its own pseudo-random internal state , and cannot be used to infer the seed of other random functions in the kernel. However , it is essential to note that the generator used by the helper is not cryptographically secure. ", "Return": " A random 32-bit unsigned value.", "Function Name": "get_prandom_u32", "Input Params": ["{Type: voi ,Var: void}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "raw_tracepoint_writable"], "capabilities": ["read_sys_info"]}]}], "helperCallParams": {}}}], "*__lb4_lookup_backend": [{"fileName": "/home/sayandes/opened_extraction/examples/kpng-master/backends/ebpf/bpf/cgroup_connect4.c", "startLine": "82", "endLine": "85", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}, {"Project": "libbpf", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}}}], "*__lb4_lookup_backend_slot": [{"fileName": "/home/sayandes/opened_extraction/examples/kpng-master/backends/ebpf/bpf/cgroup_connect4.c", "startLine": "87", "endLine": "90", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}, {"Project": "libbpf", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}}}], "sock4_skip_xlate_if_same_netns": [{"fileName": "/home/sayandes/opened_extraction/examples/kpng-master/backends/ebpf/bpf/cgroup_connect4.c", "startLine": "111", "endLine": "136", "capability": {"capabilities": [{"capability": "read_sys_info", "read_sys_info": [{"Project": "cilium", "Return Type": "struct sock*", "Description": "Look for UDP socket matching <[ tuple ]>(IP: 1) , optionally in a child network namespace netns. The return value must be checked , and if non-NULL , released via sk_release(). The <[ ctx ]>(IP: 0) should point to the context of the program , such as the skb or socket (depending on the hook in use). This is used to determine the base network namespace for the lookup. <[ tuple_size ]>(IP: 2) must be one of: sizeof(tuple->ipv4) Look for an IPv4 socket. sizeof(tuple->ipv6) Look for an IPv6 socket. If the <[ netns ]>(IP: 3) is a negative signed 32-bit integer , then the socket lookup table in the <[ netns ]>(IP: 3) associated with the <[ ctx ]>(IP: 0) will will be used. For the TC hooks , this is the <[ netns ]>(IP: 3) of the device in the skb. For socket hooks , this is the <[ netns ]>(IP: 3) of the socket. If <[ netns ]>(IP: 3) is any other signed 32-bit value greater than or equal to zero then it specifies the ID of the <[ netns ]>(IP: 3) relative to the <[ netns ]>(IP: 3) associated with the ctx. <[ netns ]>(IP: 3) values beyond the range of 32-bit integers are reserved for future use. All values for <[ flags ]>(IP: 4) are reserved for future usage , and must be left at zero. This helper is available only if the kernel was compiled with CONFIG_NET configuration option. ", "Return": " Pointer  to  struct  sock, or NULL in case of failure.  For sockets with                     reuseport option, the struct  sock result is  from  reuse->socks[]  using                     the hash of the tuple.", "Function Name": "sk_lookup_udp", "Input Params": ["{Type: void ,Var: *ctx}", "{Type:  struct sock_tuple ,Var: *tuple}", "{Type:  u32 ,Var: tuple_size}", "{Type:  u64 ,Var: netns}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp", "sk_skb", "cgroup_sock_addr"], "capabilities": ["read_sys_info"]}, {"Project": "cilium", "Return Type": "struct sock*", "Description": "Look for TCP socket matching <[ tuple ]>(IP: 1) , optionally in a child network namespace netns. The return value must be checked , and if non-NULL , released via sk_release(). The <[ ctx ]>(IP: 0) should point to the context of the program , such as the skb or socket (depending on the hook in use). This is used to determine the base network namespace for the lookup. <[ tuple_size ]>(IP: 2) must be one of: sizeof(tuple->ipv4) Look for an IPv4 socket. sizeof(tuple->ipv6) Look for an IPv6 socket. If the <[ netns ]>(IP: 3) is a negative signed 32-bit integer , then the socket lookup table in the <[ netns ]>(IP: 3) associated with the <[ ctx ]>(IP: 0) will will be used. For the TC hooks , this is the <[ netns ]>(IP: 3) of the device in the skb. For socket hooks , this is the <[ netns ]>(IP: 3) of the socket. If <[ netns ]>(IP: 3) is any other signed 32-bit value greater than or equal to zero then it specifies the ID of the <[ netns ]>(IP: 3) relative to the <[ netns ]>(IP: 3) associated with the ctx. <[ netns ]>(IP: 3) values beyond the range of 32-bit integers are reserved for future use. All values for <[ flags ]>(IP: 4) are reserved for future usage , and must be left at zero. This helper is available only if the kernel was compiled with CONFIG_NET configuration option. ", "Return": " Pointer to struct  sock, or NULL in case of failure.   For  sockets  with                     reuseport  option,  the  struct  sock result is from reuse->socks[] using                     the hash of the tuple.", "Function Name": "sk_lookup_tcp", "Input Params": ["{Type: void ,Var: *ctx}", "{Type:  struct sock_tuple ,Var: *tuple}", "{Type:  u32 ,Var: tuple_size}", "{Type:  u64 ,Var: netns}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp", "sk_skb", "cgroup_sock_addr"], "capabilities": ["read_sys_info"]}]}], "helperCallParams": {}}}], "ctx_set_port": [{"fileName": "/home/sayandes/opened_extraction/examples/kpng-master/backends/ebpf/bpf/cgroup_connect4.c", "startLine": "138", "endLine": "141", "capability": {"capabilities": [], "helperCallParams": {}}}], "__sock4_fwd": [{"fileName": "/home/sayandes/opened_extraction/examples/kpng-master/backends/ebpf/bpf/cgroup_connect4.c", "startLine": "143", "endLine": "191", "capability": {"capabilities": [], "helperCallParams": {}}}], "sock4_connect": [{"fileName": "/home/sayandes/opened_extraction/examples/kpng-master/backends/ebpf/bpf/cgroup_connect4.c", "startLine": "194", "endLine": "198", "capability": {"capabilities": [], "helperCallParams": {}}}]}