{"*lb4_lookup_service": [{"fileName": "/home/sayandes/opened_extraction/examples/kpng-master/backends/ebpf/bpf/cgroup_connect4.c", "startLine": "59", "endLine": "69", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "libbpf", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"bpf_map_lookup_elem": [{"opVar": "  svc ", "inpVar": [" &v4_svc_map", " key"]}]}}}], "ctx_dst_port": [{"fileName": "/home/sayandes/opened_extraction/examples/kpng-master/backends/ebpf/bpf/cgroup_connect4.c", "startLine": "72", "endLine": "76", "capability": {"capabilities": [], "helperCallParams": {}}}], "sock_select_slot": [{"fileName": "/home/sayandes/opened_extraction/examples/kpng-master/backends/ebpf/bpf/cgroup_connect4.c", "startLine": "78", "endLine": "80", "capability": {"capabilities": [{"capability": "read_sys_info", "read_sys_info": [{"Project": "libbpf", "Return Type": "u32", "Description": "Get a pseudo-random number. From a security point of view , this helper uses its own pseudo-random internal state , and cannot be used to infer the seed of other random functions in the kernel. However , it is essential to note that the generator used by the helper is not cryptographically secure. ", "Return": " A random 32-bit unsigned value.", "Function Name": "bpf_get_prandom_u32", "Input Params": ["{Type: voi ,Var: void}"]}]}], "helperCallParams": {"bpf_get_prandom_u32": [{"opVar": "  return ctx->protocol ", "inpVar": [""]}]}}}], "*__lb4_lookup_backend": [{"fileName": "/home/sayandes/opened_extraction/examples/kpng-master/backends/ebpf/bpf/cgroup_connect4.c", "startLine": "82", "endLine": "85", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "libbpf", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"bpf_map_lookup_elem": [{"opVar": "NA", "inpVar": ["  return &v4_backend_map", " &backend_id"]}]}}}], "*__lb4_lookup_backend_slot": [{"fileName": "/home/sayandes/opened_extraction/examples/kpng-master/backends/ebpf/bpf/cgroup_connect4.c", "startLine": "87", "endLine": "90", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "libbpf", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"bpf_map_lookup_elem": [{"opVar": "NA", "inpVar": ["  return &v4_svc_map", " key"]}]}}}], "sock4_skip_xlate_if_same_netns": [{"fileName": "/home/sayandes/opened_extraction/examples/kpng-master/backends/ebpf/bpf/cgroup_connect4.c", "startLine": "111", "endLine": "136", "capability": {"capabilities": [{"capability": "read_sys_info", "read_sys_info": [{"Project": "cilium", "Return Type": "struct sock*", "Description": "Look for UDP socket matching <[ tuple ]>(IP: 1) , optionally in a child network namespace netns. The return value must be checked , and if non-NULL , released via sk_release(). The <[ ctx ]>(IP: 0) should point to the context of the program , such as the skb or socket (depending on the hook in use). This is used to determine the base network namespace for the lookup. <[ tuple_size ]>(IP: 2) must be one of: sizeof(tuple->ipv4) Look for an IPv4 socket. sizeof(tuple->ipv6) Look for an IPv6 socket. If the <[ netns ]>(IP: 3) is a negative signed 32-bit integer , then the socket lookup table in the <[ netns ]>(IP: 3) associated with the <[ ctx ]>(IP: 0) will will be used. For the TC hooks , this is the <[ netns ]>(IP: 3) of the device in the skb. For socket hooks , this is the <[ netns ]>(IP: 3) of the socket. If <[ netns ]>(IP: 3) is any other signed 32-bit value greater than or equal to zero then it specifies the ID of the <[ netns ]>(IP: 3) relative to the <[ netns ]>(IP: 3) associated with the ctx. <[ netns ]>(IP: 3) values beyond the range of 32-bit integers are reserved for future use. All values for <[ flags ]>(IP: 4) are reserved for future usage , and must be left at zero. This helper is available only if the kernel was compiled with CONFIG_NET configuration option. ", "Return": " Pointer  to  struct  sock, or NULL in case of failure.  For sockets with                     reuseport option, the struct  sock result is  from  reuse->socks[]  using                     the hash of the tuple.", "Function Name": "sk_lookup_udp", "Input Params": ["{Type: void ,Var: *ctx}", "{Type:  struct sock_tuple ,Var: *tuple}", "{Type:  u32 ,Var: tuple_size}", "{Type:  u64 ,Var: netns}", "{Type:  u64 ,Var: flags}"]}, {"Project": "cilium", "Return Type": "struct sock*", "Description": "Look for TCP socket matching <[ tuple ]>(IP: 1) , optionally in a child network namespace netns. The return value must be checked , and if non-NULL , released via sk_release(). The <[ ctx ]>(IP: 0) should point to the context of the program , such as the skb or socket (depending on the hook in use). This is used to determine the base network namespace for the lookup. <[ tuple_size ]>(IP: 2) must be one of: sizeof(tuple->ipv4) Look for an IPv4 socket. sizeof(tuple->ipv6) Look for an IPv6 socket. If the <[ netns ]>(IP: 3) is a negative signed 32-bit integer , then the socket lookup table in the <[ netns ]>(IP: 3) associated with the <[ ctx ]>(IP: 0) will will be used. For the TC hooks , this is the <[ netns ]>(IP: 3) of the device in the skb. For socket hooks , this is the <[ netns ]>(IP: 3) of the socket. If <[ netns ]>(IP: 3) is any other signed 32-bit value greater than or equal to zero then it specifies the ID of the <[ netns ]>(IP: 3) relative to the <[ netns ]>(IP: 3) associated with the ctx. <[ netns ]>(IP: 3) values beyond the range of 32-bit integers are reserved for future use. All values for <[ flags ]>(IP: 4) are reserved for future usage , and must be left at zero. This helper is available only if the kernel was compiled with CONFIG_NET configuration option. ", "Return": " Pointer to struct  sock, or NULL in case of failure.   For  sockets  with                     reuseport  option,  the  struct  sock result is from reuse->socks[] using                     the hash of the tuple.", "Function Name": "sk_lookup_tcp", "Input Params": ["{Type: void ,Var: *ctx}", "{Type:  struct sock_tuple ,Var: *tuple}", "{Type:  u32 ,Var: tuple_size}", "{Type:  u64 ,Var: netns}", "{Type:  u64 ,Var: flags}"]}]}], "helperCallParams": {"sk_lookup_tcp": [{"opVar": "  case IPPROTO_TCP:    sk ", "inpVar": [" ctx", " &tuple", " sizeoftuple.ipv4", " BPF_F_CURRENT_NETNS", " 0"]}], "sk_lookup_udp": [{"opVar": "  case IPPROTO_UDP:    sk ", "inpVar": [" ctx", " &tuple", " sizeoftuple.ipv4", " BPF_F_CURRENT_NETNS", " 0"]}], "sk_release": [{"opVar": "NA", "inpVar": ["    sk"]}]}}}], "ctx_set_port": [{"fileName": "/home/sayandes/opened_extraction/examples/kpng-master/backends/ebpf/bpf/cgroup_connect4.c", "startLine": "138", "endLine": "141", "capability": {"capabilities": [], "helperCallParams": {}}}], "__sock4_fwd": [{"fileName": "/home/sayandes/opened_extraction/examples/kpng-master/backends/ebpf/bpf/cgroup_connect4.c", "startLine": "143", "endLine": "191", "capability": {"capabilities": [], "helperCallParams": {"bpf_trace_printk": [{"opVar": "NA", "inpVar": ["    debug_str", " sizeofdebug_str", "  key.address", " key.dport", " svc->backend_id"]}]}}}], "sock4_connect": [{"fileName": "/home/sayandes/opened_extraction/examples/kpng-master/backends/ebpf/bpf/cgroup_connect4.c", "startLine": "194", "endLine": "198", "capability": {"capabilities": [], "helperCallParams": {}}}]}