<?xml version="1.0"?>
<doc>
<source file="/home/sayandes/opened_extraction/examples/kpng-master/backends/ebpf/bpf/cgroup_connect4.c" funcheader="static __always_inline struct lb4_service *lb4_lookup_service (struct V4_key *key)" startline="59" endline="69">
static __always_inline struct lb4_service *lb4_lookup_service (struct V4_key *key)
{
    struct lb4_service *svc;
    svc = bpf_map_lookup_elem (& v4_svc_map, key);
    if (svc) {
        return svc;
    }
    return NULL;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/kpng-master/backends/ebpf/bpf/cgroup_connect4.c" funcheader="static __always_inline __be16 ctx_dst_port (const struct bpf_sock_addr *ctx)" startline="72" endline="76">
static __always_inline __be16 ctx_dst_port (const struct bpf_sock_addr *ctx)
{
    volatile __u32 dport = ctx->user_port;
    return (__be16) dport;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/kpng-master/backends/ebpf/bpf/cgroup_connect4.c" funcheader="static __always_inline __u64 sock_select_slot (struct bpf_sock_addr *ctx)" startline="78" endline="80">
static __always_inline __u64 sock_select_slot (struct bpf_sock_addr *ctx)
{
    return ctx->protocol == IPPROTO_TCP ? bpf_get_prandom_u32 () : 0;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/kpng-master/backends/ebpf/bpf/cgroup_connect4.c" funcheader="static __always_inline struct lb4_backend *__lb4_lookup_backend (__u32 backend_id)" startline="82" endline="85">
static __always_inline struct lb4_backend *__lb4_lookup_backend (__u32 backend_id)
{
    return bpf_map_lookup_elem (&v4_backend_map, &backend_id);
}
</source>
<source file="/home/sayandes/opened_extraction/examples/kpng-master/backends/ebpf/bpf/cgroup_connect4.c" funcheader="static __always_inline struct lb4_service *__lb4_lookup_backend_slot (struct V4_key *key)" startline="87" endline="90">
static __always_inline struct lb4_service *__lb4_lookup_backend_slot (struct V4_key *key)
{
    return bpf_map_lookup_elem (&v4_svc_map, key);
}
</source>
<source file="/home/sayandes/opened_extraction/examples/kpng-master/backends/ebpf/bpf/cgroup_connect4.c" funcheader="static __always_inline bool sock4_skip_xlate_if_same_netns (struct bpf_sock_addr *ctx, const struct lb4_backend *backend)" startline="111" endline="136">
static __always_inline bool sock4_skip_xlate_if_same_netns (struct bpf_sock_addr *ctx, const struct lb4_backend *backend)
{

#ifdef BPF_HAVE_SOCKET_LOOKUP
    struct bpf_sock_tuple tuple = {
        .ipv4.daddr = backend->address,
        .ipv4.dport = backend->port,}
    ;
    struct bpf_sock *sk = NULL;
    switch (ctx->protocol) {
    case IPPROTO_TCP :
        sk = sk_lookup_tcp (ctx, &tuple, sizeof (tuple.ipv4), BPF_F_CURRENT_NETNS, 0);
        break;
    case IPPROTO_UDP :
        sk = sk_lookup_udp (ctx, &tuple, sizeof (tuple.ipv4), BPF_F_CURRENT_NETNS, 0);
        break;
    }
    if (sk) {
        sk_release (sk);
        return true;
    }

#endif /* BPF_HAVE_SOCKET_LOOKUP */
    return false;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/kpng-master/backends/ebpf/bpf/cgroup_connect4.c" funcheader="static __always_inline void ctx_set_port (struct bpf_sock_addr *ctx, __be16 dport)" startline="138" endline="141">
static __always_inline void ctx_set_port (struct bpf_sock_addr *ctx, __be16 dport)
{
    ctx->user_port = (__u32) dport;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/kpng-master/backends/ebpf/bpf/cgroup_connect4.c" funcheader="static __always_inline int __sock4_fwd (struct bpf_sock_addr *ctx)" startline="143" endline="191">
static __always_inline int __sock4_fwd (struct bpf_sock_addr *ctx)
{
    struct V4_key key = {
        .address = ctx->user_ip4,
        .dport = ctx_dst_port (ctx),
        .backend_slot = 0,}
    ;
    struct lb4_service *svc;
    struct lb4_service *backend_slot;
    struct lb4_backend *backend = NULL;
    __u32 backend_id = 0;
    svc = lb4_lookup_service (& key);
    if (!svc) {
        return -ENXIO;
    }
    const char debug_str [] = "Entering the kpng ebpf backend, caught a\
  packet destined for my VIP, the address is: %x port is: %x and selected backend id is: %x\n";
    bpf_trace_printk (debug_str, sizeof (debug_str), key.address, key.dport, svc->backend_id);
    if (backend_id == 0) {
        key.backend_slot = (sock_select_slot (ctx) % svc->count) + 1;
        backend_slot = __lb4_lookup_backend_slot (& key);
        if (!backend_slot) {
            return -ENOENT;
        }
        backend_id = backend_slot->backend_id;
        backend = __lb4_lookup_backend (backend_id);
    }
    if (!backend) {
        return -ENOENT;
    }
    if (sock4_skip_xlate_if_same_netns (ctx, backend)) {
        return -ENXIO;
    }
    ctx->user_ip4 = backend->address;
    ctx_set_port (ctx, backend->port);
    return 0;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/kpng-master/backends/ebpf/bpf/cgroup_connect4.c" funcheader="int sock4_connect (struct bpf_sock_addr *ctx)" startline="194" endline="198">
int sock4_connect (struct bpf_sock_addr *ctx)
{
    __sock4_fwd (ctx);
    return SYS_PROCEED;
}
</source>
</doc>
