<?xml version="1.0"?>
<doc>
<source file="/home/sayandes/opened_extraction/examples/ebpf-ratelimiter-main/ratelimiting_user.c" funcheader="char *strsep (char **stringp, const char *delim)" startline="38" endline="44">
char *strsep (char **stringp, const char *delim)
{
    static char *next_token = NULL;
    char *input = *stringp;
    *stringp = strtok_s (input, delim, &next_token);
    return input;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/ebpf-ratelimiter-main/ratelimiting_user.c" funcheader="int gettimeofday (struct timeval *tv, struct timezone *tz)" startline="47" endline="58">
int gettimeofday (struct timeval *tv, struct timezone *tz)
{
    FILETIME ft;
    ULARGE_INTEGER ui;
    GetSystemTimeAsFileTime (&ft);
    ui.LowPart = ft.dwLowDateTime;
    ui.HighPart = ft.dwHighDateTime;
    ui.QuadPart /= 10;
    tv->tv_sec = (long) (ui.QuadPart / 1000000);
    tv->tv_usec = ui.QuadPart % 1000000;
    return 0;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/ebpf-ratelimiter-main/ratelimiting_user.c" funcheader="static void usage (char *argv [])" startline="85" endline="104">
static void usage (char *argv [])
{
    int i;
    printf ("\nDOCUMENTATION:\n%s\n", __doc__);
    printf ("\n");
    printf (" Usage: %s (options-see-below)\n", argv[0]);
    printf (" Listing options:\n");
    for (i = 0; long_options[i].name != 0; i++) {
        printf (" --%-12s", long_options[i].name);
        if (long_options[i].flag != NULL)
            printf (" flag (internal value:%d)", *long_options[i].flag);
        else
            printf (" short-option: -%c", long_options[i].val);
        printf ("\n");
    }
    printf ("\n");
}
</source>
<source file="/home/sayandes/opened_extraction/examples/ebpf-ratelimiter-main/ratelimiting_user.c" funcheader="void log_timestamp (char *log_ts)" startline="107" endline="118">
void log_timestamp (char *log_ts)
{
    struct timeval tv;
    time_t nowtime;
    struct tm *nowtm;
    char tmbuf [TIMESTAMP_LEN];
    gettimeofday (&tv, NULL);
    nowtime = tv.tv_sec;
    nowtm = localtime (& nowtime);
    strftime (tmbuf, DATE_LEN, "%Y-%m-%d %H:%M:%S", nowtm);
    snprintf (log_ts, DATE_LEN + TIMESTAMP_LEN, "%s.%06ld", tmbuf, tv.tv_usec);
}
</source>
<source file="/home/sayandes/opened_extraction/examples/ebpf-ratelimiter-main/ratelimiting_user.c" funcheader="static int get_length (const char *str)" startline="120" endline="129">
static int get_length (const char *str)
{
    int len = 0;
    if (*str == '\0')
        return 0;
    while (str[len] != '\0')
        len++;
    return len;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/ebpf-ratelimiter-main/ratelimiting_user.c" funcheader="static FILE *set_logfile (void)" startline="132" endline="145">
static FILE *set_logfile (void)
{
    if (info != NULL) {
        return info;
    }
    info = fopen (DEFAULT_LOGFILE, "a");
    if (info == NULL) {
        fprintf (stderr, "could not open log file ");
        return NULL;
    }
    fprintf (stderr, "writing errors/warnings/info/debug output to %s \n", DEFAULT_LOGFILE);
    return info;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/ebpf-ratelimiter-main/ratelimiting_user.c" funcheader="static int xdp_unlink_bpf_chain (const char *map_filename)" startline="148" endline="167">
static int xdp_unlink_bpf_chain (const char *map_filename)
{
    int ret = 0;
    int key = 0;
    int map_fd = bpf_obj_get (map_filename);
    if (map_fd > 0) {
        ret = bpf_map_delete_elem (map_fd, & key);
        if (ret != 0) {
            log_err ("Failed to remove XDP program from the chain");
        }
    }
    else {
        log_err ("Failed to fetch previous XDP program in the chain");
    }
    if (remove (xdp_rl_ingress_next_prog) < 0) {
        log_warn ("Failed to remove link to next XDP program in the chain");
    }
    return ret;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/ebpf-ratelimiter-main/ratelimiting_user.c" funcheader="static void signal_handler (int signal)" startline="171" endline="182">
static void signal_handler (int signal)
{
    log_info ("Received signal %d", signal);
    int i = 0;
    xdp_unlink_bpf_chain (prev_prog_map);
    for (i = 0; i < MAP_COUNT; i++) {
        close (map_fd[i]);
    }
    if (info != NULL)
        fclose (info);
    exit (EXIT_SUCCESS);
}
</source>
<source file="/home/sayandes/opened_extraction/examples/ebpf-ratelimiter-main/ratelimiting_user.c" funcheader="static __u64 time_get_ns (void)" startline="185" endline="199">
static __u64 time_get_ns (void)
{

#ifdef __linux__
    struct timespec ts;
    clock_gettime (CLOCK_MONOTONIC, &ts);
    return ts.tv_sec * 1000000000ull + ts.tv_nsec;

#endif

#ifdef WIN32
    LARGE_INTEGER frequency, counter;
    QueryPerformanceFrequency (&frequency);
    QueryPerformanceCounter (&counter);
    return (1000000000 * counter.QuadPart) / frequency.QuadPart;

#endif
}
</source>
<source file="/home/sayandes/opened_extraction/examples/ebpf-ratelimiter-main/ratelimiting_user.c" funcheader="static void delete_stale_entries (void)" startline="203" endline="226">
static void delete_stale_entries (void)
{
    log_debug ("Deleting stale map entries periodically");
    if (map_fd[1] < 0) {
        log_info ("Window map fd not found");
        exit (EXIT_FAILURE);
    }
    __u64 first_key = 0, next_key = 0;
    __u64 curr_time = time_get_ns ();
    log_debug ("Current time is %llu", curr_time);
    while (!bpf_map_get_next_key (map_fd[1], &first_key, &next_key)) {
        if (next_key < (curr_time - buffer_time)) {
            log_debug ("Deleting stale map entry %llu", next_key);
            if (bpf_map_delete_elem (map_fd[1], &next_key) != 0) {
                log_info ("Map element not found");
            }
        }
        first_key = next_key;
    }
}
</source>
<source file="/home/sayandes/opened_extraction/examples/ebpf-ratelimiter-main/ratelimiting_user.c" funcheader="static char *trim_space (char *str)" startline="228" endline="242">
static char *trim_space (char *str)
{
    char *end;
    while (isspace (*str)) {
        str = str + 1;
    }
    end = str + get_length (str) - 1;
    while (end > str && isspace (*end)) {
        end = end - 1;
    }
    *(end + 1) = '\0';
    return str;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/ebpf-ratelimiter-main/ratelimiting_user.c" funcheader="static int strtoi (const char *str)" startline="244" endline="255">
static int strtoi (const char *str)
{
    char *endptr;
    errno = 0;
    long long_var = strtol (str, & endptr, 10);
    if (errno == ERANGE || *endptr != '\0' || str == endptr) {
        fprintf (stderr, "out of range");
    }
    return (int) long_var;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/ebpf-ratelimiter-main/ratelimiting_user.c" funcheader="static void update_ports (char *ports)" startline="257" endline="270">
static void update_ports (char *ports)
{
    char *ptr, *tmp;
    uint16_t port = 0;
    uint8_t pval = 1;
    tmp = strdup (ports);
    while ((ptr = strsep (&tmp, delim)) != NULL) {
        ptr = trim_space (ptr);
        port = (uint16_t) (strtoi (ptr));
        bpf_map_update_elem (map_fd[4], &port, &pval, 0);
    }
    free (tmp);
}
</source>
<source file="/home/sayandes/opened_extraction/examples/ebpf-ratelimiter-main/ratelimiting_user.c" funcheader="int main (int argc, char **argv)" startline="272" endline="423">
int main (int argc, char **argv)
{
    int longindex = 0, rate = 0, opt;
    int ret = EXIT_SUCCESS;
    char bpf_obj_file [256];
    char ports [2048];
    verbosity = LOG_INFO;

#ifdef __linux__
    struct rlimit r = {RLIM_INFINITY, RLIM_INFINITY}
    ;

#endif
    int len = 0;
    snprintf (bpf_obj_file, sizeof (bpf_obj_file), "%s_kern.o", argv[0]);
    memset (&ports, 0, 2048);
    while ((opt = getopt_long (argc, argv, "h", long_options, &longindex)) != -1) {
        switch (opt) {
        case 'r' :
            rate = strtoi (optarg);
            break;
        case 'i' :
            ifindex = if_nametoindex (optarg);
            break;
        case 'v' :
            if (optarg) {
                verbosity = strtoi (optarg);
            }
            break;
        case 'm' :
            if (optarg) {
                len = get_length (optarg);
                strncpy (prev_prog_map, optarg, len);
                prev_prog_map[len] = '\0';
            }
            break;
        case 'p' :
            if (optarg) {
                len = get_length (optarg);
                strncpy (ports, optarg, len);
                ports[len] = '\0';
            }
            break;
        case 'd' :
            break;
        case 'h' :
        default :
            usage (argv);
            return EXIT_FAILURE;
        }
    }

#ifdef __linux__
    if (setrlimit (RLIMIT_MEMLOCK, &r)) {
        perror ("setrlimit(RLIMIT_MEMLOCK)");
        exit (EXIT_FAILURE);
    }

#endif
    set_logfile ();
    __u64 ckey = 0, rkey = 0, dkey = 0, pkey = 0;
    __u64 recv_count = 0, drop_count = 0;
    if (load_bpf_file (bpf_obj_file)) {
        log_err ("Failed to load bpf program");
        return 1;
    }
    if (!prog_fd[0]) {
        log_err ("Failed to get bpf program fd")
        return 1;
    }
    int prev_prog_map_fd = bpf_obj_get (prev_prog_map);
    if (prev_prog_map_fd < 0) {
        log_err ("Failed to fetch previous xdp function in the chain");
        exit (EXIT_FAILURE);
    }
    if (bpf_map_update_elem (prev_prog_map_fd, &pkey, &(prog_fd[0]), 0)) {
        log_err ("Failed to update prog fd in the chain");
        exit (EXIT_FAILURE);
    }
    close (prev_prog_map_fd);
    int next_prog_map_fd = bpf_obj_get (xdp_rl_ingress_next_prog);
    if (next_prog_map_fd < 0) {
        log_info ("Failed to fetch next prog map fd, creating one");
        if (bpf_obj_pin (map_fd[5], xdp_rl_ingress_next_prog)) {
            log_info ("Failed to pin next prog fd map");
            exit (EXIT_FAILURE);
        }
    }
    if (!map_fd[0]) {
        log_err ("Failed to fetch config map");
        return -1;
    }
    ret = bpf_map_update_elem (map_fd [0], & ckey, & rate, 0);
    if (ret) {
        perror ("Failed to update config map");
        return 1;
    }
    if (!map_fd[2]) {
        log_err ("Failed to fetch receive count map");
        return -1;
    }
    ret = bpf_map_update_elem (map_fd [2], & rkey, & recv_count, 0);
    if (ret) {
        perror ("Failed to update receive count map");
        return 1;
    }
    if (!map_fd[3]) {
        log_err ("Failed to fetch drop count map");
        return -1;
    }
    ret = bpf_map_update_elem (map_fd [3], & dkey, & drop_count, 0);
    if (ret) {
        perror ("Failed to update drop count map");
        return 1;
    }
    if (get_length (ports)) {
        log_info ("Configured port list is %s\n", ports);
        update_ports (ports);
    }
    signal (SIGINT, signal_handler);
    signal (SIGTERM, signal_handler);

#ifdef __linux__
    signal (SIGHUP, signal_handler);

#endif
    while (1) {
        sleep (60);
        delete_stale_entries ();
        fflush (info);
    }
}
</source>
</doc>
