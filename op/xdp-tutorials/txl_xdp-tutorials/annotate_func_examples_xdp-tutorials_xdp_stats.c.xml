<?xml version="1.0"?>
<doc>
<source file="/root/examples/xdp-tutorials/xdp_stats.c" funcheader="static __u64 gettime (void)" startline="43" endline="54">
static __u64 gettime (void)
{
    struct timespec t;
    int res;
    res = clock_gettime (CLOCK_MONOTONIC, & t);
    if (res < 0) {
        fprintf (stderr, "Error with gettimeofday! (%i)\n", res);
        exit (EXIT_FAIL);
    }
    return (__u64) t.tv_sec * NANOSEC_PER_SEC + t.tv_nsec;
}
</source>
<source file="/root/examples/xdp-tutorials/xdp_stats.c" funcheader="static double calc_period (struct record *r, struct record *p)" startline="65" endline="75">
static double calc_period (struct record *r, struct record *p)
{
    double period_ = 0;
    __u64 period = 0;
    period = r->timestamp - p->timestamp;
    if (period > 0)
        period_ = ((double) period / NANOSEC_PER_SEC);
    return period_;
}
</source>
<source file="/root/examples/xdp-tutorials/xdp_stats.c" funcheader="static void stats_print_header ()" startline="77" endline="81">
static void stats_print_header ()
{
    printf ("%-12s\n", "XDP-action");
}
</source>
<source file="/root/examples/xdp-tutorials/xdp_stats.c" funcheader="static void stats_print (struct stats_record *stats_rec, struct stats_record *stats_prev)" startline="83" endline="121">
static void stats_print (struct stats_record *stats_rec, struct stats_record *stats_prev)
{
    struct record *rec, *prev;
    __u64 packets, bytes;
    double period;
    double pps;
    double bps;
    int i;
    stats_print_header ();
    for (i = 0; i < XDP_ACTION_MAX; i++) {
        char *fmt = "%-12s %'11lld pkts (%'10.0f pps)" " %'11lld Kbytes (%'6.0f Mbits/s)" " period:%f\n";
        const char *action = action2str (i);
        rec = &stats_rec->stats[i];
        prev = &stats_prev->stats[i];
        period = calc_period (rec, prev);
        if (period == 0)
            return;
        packets = rec->total.rx_packets - prev->total.rx_packets;
        pps = packets / period;
        bytes = rec->total.rx_bytes - prev->total.rx_bytes;
        bps = (bytes * 8) / period / 1000000;
        printf (fmt, action, rec->total.rx_packets, pps, rec->total.rx_bytes / 1000, bps, period);
    }
    printf ("\n");
}
</source>
<source file="/root/examples/xdp-tutorials/xdp_stats.c" funcheader="void map_get_value_array (int fd, __u32 key, struct datarec *value)" startline="125" endline="131">
void map_get_value_array (int fd, __u32 key, struct datarec *value)
{
    if ((bpf_map_lookup_elem (fd, &key, value)) != 0) {
        fprintf (stderr, "ERR: bpf_map_lookup_elem failed key:0x%X\n", key);
    }
}
</source>
<source file="/root/examples/xdp-tutorials/xdp_stats.c" funcheader="void map_get_value_percpu_array (int fd, __u32 key, struct datarec *value)" startline="134" endline="156">
void map_get_value_percpu_array (int fd, __u32 key, struct datarec *value)
{
    unsigned int nr_cpus = bpf_num_possible_cpus ();
    struct datarec values [nr_cpus];
    __u64 sum_bytes = 0;
    __u64 sum_pkts = 0;
    int i;
    if ((bpf_map_lookup_elem (fd, &key, values)) != 0) {
        fprintf (stderr, "ERR: bpf_map_lookup_elem failed key:0x%X\n", key);
        return;
    }
    for (i = 0; i < nr_cpus; i++) {
        sum_pkts += values[i].rx_packets;
        sum_bytes += values[i].rx_bytes;
    }
    value->rx_packets = sum_pkts;
    value->rx_bytes = sum_bytes;
}
</source>
<source file="/root/examples/xdp-tutorials/xdp_stats.c" funcheader="static bool map_collect (int fd, __u32 map_type, __u32 key, struct record *rec)" startline="158" endline="182">
static bool map_collect (int fd, __u32 map_type, __u32 key, struct record *rec)
{
    struct datarec value;
    rec->timestamp = gettime ();
    switch (map_type) {
    case BPF_MAP_TYPE_ARRAY :
        map_get_value_array (fd, key, &value);
        break;
    case BPF_MAP_TYPE_PERCPU_ARRAY :
        map_get_value_percpu_array (fd, key, &value);
        break;
    default :
        fprintf (stderr, "ERR: Unknown map_type(%u) cannot handle\n", map_type);
        return false;
        break;
    }
    rec->total.rx_packets = value.rx_packets;
    rec->total.rx_bytes = value.rx_bytes;
    return true;
}
</source>
<source file="/root/examples/xdp-tutorials/xdp_stats.c" funcheader="static void stats_collect (int map_fd, __u32 map_type, struct stats_record *stats_rec)" startline="184" endline="193">
static void stats_collect (int map_fd, __u32 map_type, struct stats_record *stats_rec)
{
    __u32 key;
    for (key = 0; key < XDP_ACTION_MAX; key++) {
        map_collect (map_fd, map_type, key, &stats_rec->stats[key]);
    }
}
</source>
<source file="/root/examples/xdp-tutorials/xdp_stats.c" funcheader="static int stats_poll (const char *pin_dir, int map_fd, __u32 id, __u32 map_type, int interval)" startline="195" endline="227">
static int stats_poll (const char *pin_dir, int map_fd, __u32 id, __u32 map_type, int interval)
{
    struct bpf_map_info info = {}
    ;
    struct stats_record prev, record = {0};
    setlocale (LC_NUMERIC, "en_US");
    stats_collect (map_fd, map_type, &record);
    usleep (1000000 / 4);
    while (1) {
        prev = record;
        map_fd = open_bpf_map_file (pin_dir, "xdp_stats_map", & info);
        if (map_fd < 0) {
            return EXIT_FAIL_BPF;
        }
        else if (id != info.id) {
            printf ("BPF map xdp_stats_map changed its ID, restarting\n");
            close (map_fd);
            return 0;
        }
        stats_collect (map_fd, map_type, &record);
        stats_print (&record, &prev);
        close (map_fd);
        sleep (interval);
    }
    return 0;
}
</source>
<source file="/root/examples/xdp-tutorials/xdp_stats.c" funcheader="int main (int argc, char **argv)" startline="235" endline="299">
int main (int argc, char **argv)
{
    const struct bpf_map_info map_expect = {
        .key_size = sizeof (__u32),
        .value_size = sizeof (struct datarec),
        .max_entries = XDP_ACTION_MAX,}
    ;
    struct bpf_map_info info = {0}
    ;
    char pin_dir [PATH_MAX];
    int stats_map_fd;
    int interval = 2;
    int len, err;
    struct config cfg = {
        .ifindex = -1,
        .do_unload = false,}
    ;
    parse_cmdline_args (argc, argv, long_options, &cfg, __doc__);
    if (cfg.ifindex == -1) {
        fprintf (stderr, "ERR: required option --dev missing\n\n");
        usage (argv[0], __doc__, long_options, (argc == 1));
        return EXIT_FAIL_OPTION;
    }
    len = snprintf (pin_dir, PATH_MAX, "%s/%s", pin_basedir, cfg.ifname);
    if (len < 0) {
        fprintf (stderr, "ERR: creating pin dirname\n");
        return EXIT_FAIL_OPTION;
    }
    for (;;) {
        stats_map_fd = open_bpf_map_file (pin_dir, "xdp_stats_map", & info);
        if (stats_map_fd < 0) {
            return EXIT_FAIL_BPF;
        }
        err = check_map_fd_info (& info, & map_expect);
        if (err) {
            fprintf (stderr, "ERR: map via FD not compatible\n");
            close (stats_map_fd);
            return err;
        }
        if (verbose) {
            printf ("\nCollecting stats from BPF map\n");
            printf (" - BPF map (bpf_map_type:%d) id:%d name:%s" " key_size:%d value_size:%d max_entries:%d\n", info.type, info.id, info.name, info.key_size, info.value_size, info.max_entries);
        }
        err = stats_poll (pin_dir, stats_map_fd, info.id, info.type, interval);
        close (stats_map_fd);
        if (err < 0)
            return err;
    }
    return EXIT_OK;
}
</source>
</doc>
