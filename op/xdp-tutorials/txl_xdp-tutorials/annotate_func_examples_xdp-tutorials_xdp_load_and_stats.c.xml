<?xml version="1.0"?>
<doc>
<source file="/root/examples/xdp-tutorials/xdp_load_and_stats.c" funcheader="int find_map_fd (struct bpf_object *bpf_obj, const char *mapname)" startline="63" endline="78">
int find_map_fd (struct bpf_object *bpf_obj, const char *mapname)
{
    struct bpf_map *map;
    int map_fd = -1;
    map = bpf_object__find_map_by_name (bpf_obj, mapname);
    if (!map) {
        fprintf (stderr, "ERR: cannot find map by name: %s\n", mapname);
        goto out;
    }
    map_fd = bpf_map__fd (map);
out :
    return map_fd;
}
</source>
<source file="/root/examples/xdp-tutorials/xdp_load_and_stats.c" funcheader="static __u64 gettime (void)" startline="81" endline="92">
static __u64 gettime (void)
{
    struct timespec t;
    int res;
    res = clock_gettime (CLOCK_MONOTONIC, & t);
    if (res < 0) {
        fprintf (stderr, "Error with gettimeofday! (%i)\n", res);
        exit (EXIT_FAIL);
    }
    return (__u64) t.tv_sec * NANOSEC_PER_SEC + t.tv_nsec;
}
</source>
<source file="/root/examples/xdp-tutorials/xdp_load_and_stats.c" funcheader="static double calc_period (struct record *r, struct record *p)" startline="103" endline="113">
static double calc_period (struct record *r, struct record *p)
{
    double period_ = 0;
    __u64 period = 0;
    period = r->timestamp - p->timestamp;
    if (period > 0)
        period_ = ((double) period / NANOSEC_PER_SEC);
    return period_;
}
</source>
<source file="/root/examples/xdp-tutorials/xdp_load_and_stats.c" funcheader="static void stats_print (struct stats_record *stats_rec, struct stats_record *stats_prev)" startline="115" endline="141">
static void stats_print (struct stats_record *stats_rec, struct stats_record *stats_prev)
{
    struct record *rec, *prev;
    double period;
    __u64 packets;
    double pps;
    {
        char *fmt = "%-12s %'11lld pkts (%'10.0f pps)" " period:%f\n";
        const char *action = action2str (XDP_PASS);
        rec = &stats_rec->stats[0];
        prev = &stats_prev->stats[0];
        period = calc_period (rec, prev);
        if (period == 0)
            return;
        packets = rec->total.rx_packets - prev->total.rx_packets;
        pps = packets / period;
        printf (fmt, action, rec->total.rx_packets, pps, period);
    }
}
</source>
<source file="/root/examples/xdp-tutorials/xdp_load_and_stats.c" funcheader="void map_get_value_array (int fd, __u32 key, struct datarec *value)" startline="144" endline="150">
void map_get_value_array (int fd, __u32 key, struct datarec *value)
{
    if ((bpf_map_lookup_elem (fd, &key, value)) != 0) {
        fprintf (stderr, "ERR: bpf_map_lookup_elem failed key:0x%X\n", key);
    }
}
</source>
<source file="/root/examples/xdp-tutorials/xdp_load_and_stats.c" funcheader="void map_get_value_percpu_array (int fd, __u32 key, struct datarec *value)" startline="153" endline="160">
void map_get_value_percpu_array (int fd, __u32 key, struct datarec *value)
{
    fprintf (stderr, "ERR: %s() not impl. see assignment#3", __func__);
}
</source>
<source file="/root/examples/xdp-tutorials/xdp_load_and_stats.c" funcheader="static bool map_collect (int fd, __u32 map_type, __u32 key, struct record *rec)" startline="162" endline="185">
static bool map_collect (int fd, __u32 map_type, __u32 key, struct record *rec)
{
    struct datarec value;
    rec->timestamp = gettime ();
    switch (map_type) {
    case BPF_MAP_TYPE_ARRAY :
        map_get_value_array (fd, key, &value);
        break;
    case BPF_MAP_TYPE_PERCPU_ARRAY :
    default :
        fprintf (stderr, "ERR: Unknown map_type(%u) cannot handle\n", map_type);
        return false;
        break;
    }
    rec->total.rx_packets = value.rx_packets;
    return true;
}
</source>
<source file="/root/examples/xdp-tutorials/xdp_load_and_stats.c" funcheader="static void stats_collect (int map_fd, __u32 map_type, struct stats_record *stats_rec)" startline="187" endline="194">
static void stats_collect (int map_fd, __u32 map_type, struct stats_record *stats_rec)
{
    __u32 key = XDP_PASS;
    map_collect (map_fd, map_type, key, &stats_rec->stats[0]);
}
</source>
<source file="/root/examples/xdp-tutorials/xdp_load_and_stats.c" funcheader="static void stats_poll (int map_fd, __u32 map_type, int interval)" startline="196" endline="219">
static void stats_poll (int map_fd, __u32 map_type, int interval)
{
    struct stats_record prev, record = {0};
    setlocale (LC_NUMERIC, "en_US");
    if (verbose) {
        printf ("\n");
        printf ("%-12s\n", "XDP-action");
    }
    stats_collect (map_fd, map_type, &record);
    usleep (1000000 / 4);
    while (1) {
        prev = record;
        stats_collect (map_fd, map_type, &record);
        stats_print (&record, &prev);
        sleep (interval);
    }
}
</source>
<source file="/root/examples/xdp-tutorials/xdp_load_and_stats.c" funcheader="static int __check_map_fd_info (int map_fd, struct bpf_map_info *info, struct bpf_map_info *exp)" startline="225" endline="268">
static int __check_map_fd_info (int map_fd, struct bpf_map_info *info, struct bpf_map_info *exp)
{
    __u32 info_len = sizeof (*info);
    int err;
    if (map_fd < 0)
        return EXIT_FAIL;
    err = bpf_obj_get_info_by_fd (map_fd, info, & info_len);
    if (err) {
        fprintf (stderr, "ERR: %s() can't get info - %s\n", __func__, strerror (errno));
        return EXIT_FAIL_BPF;
    }
    if (exp->key_size && exp->key_size != info->key_size) {
        fprintf (stderr, "ERR: %s() " "Map key size(%d) mismatch expected size(%d)\n", __func__, info->key_size, exp->key_size);
        return EXIT_FAIL;
    }
    if (exp->value_size && exp->value_size != info->value_size) {
        fprintf (stderr, "ERR: %s() " "Map value size(%d) mismatch expected size(%d)\n", __func__, info->value_size, exp->value_size);
        return EXIT_FAIL;
    }
    if (exp->max_entries && exp->max_entries != info->max_entries) {
        fprintf (stderr, "ERR: %s() " "Map max_entries(%d) mismatch expected size(%d)\n", __func__, info->max_entries, exp->max_entries);
        return EXIT_FAIL;
    }
    if (exp->type && exp->type != info->type) {
        fprintf (stderr, "ERR: %s() " "Map type(%d) mismatch expected type(%d)\n", __func__, info->type, exp->type);
        return EXIT_FAIL;
    }
    return 0;
}
</source>
<source file="/root/examples/xdp-tutorials/xdp_load_and_stats.c" funcheader="int main (int argc, char **argv)" startline="270" endline="337">
int main (int argc, char **argv)
{
    struct bpf_map_info map_expect = {0}
    ;
    struct bpf_map_info info = {0}
    ;
    struct bpf_object *bpf_obj;
    int stats_map_fd;
    int interval = 2;
    int err;
    struct config cfg = {
        .xdp_flags = XDP_FLAGS_UPDATE_IF_NOEXIST | XDP_FLAGS_DRV_MODE,
        .ifindex = -1,
        .do_unload = false,}
    ;
    strncpy (cfg.filename, default_filename, sizeof (cfg.filename));
    strncpy (cfg.progsec, default_progsec, sizeof (cfg.progsec));
    parse_cmdline_args (argc, argv, long_options, &cfg, __doc__);
    if (cfg.ifindex == -1) {
        fprintf (stderr, "ERR: required option --dev missing\n");
        usage (argv[0], __doc__, long_options, (argc == 1));
        return EXIT_FAIL_OPTION;
    }
    if (cfg.do_unload)
        return xdp_link_detach (cfg.ifindex, cfg.xdp_flags, 0);
    bpf_obj = load_bpf_and_xdp_attach (& cfg);
    if (!bpf_obj)
        return EXIT_FAIL_BPF;
    if (verbose) {
        printf ("Success: Loaded BPF-object(%s) and used section(%s)\n", cfg.filename, cfg.progsec);
        printf (" - XDP prog attached on device:%s(ifindex:%d)\n", cfg.ifname, cfg.ifindex);
    }
    stats_map_fd = find_map_fd (bpf_obj, "xdp_stats_map");
    if (stats_map_fd < 0) {
        xdp_link_detach (cfg.ifindex, cfg.xdp_flags, 0);
        return EXIT_FAIL_BPF;
    }
    map_expect.key_size = sizeof (__u32);
    map_expect.value_size = sizeof (struct datarec);
    map_expect.max_entries = XDP_ACTION_MAX;
    err = __check_map_fd_info (stats_map_fd, & info, & map_expect);
    if (err) {
        fprintf (stderr, "ERR: map via FD not compatible\n");
        return err;
    }
    if (verbose) {
        printf ("\nCollecting stats from BPF map\n");
        printf (" - BPF map (bpf_map_type:%d) id:%d name:%s" " key_size:%d value_size:%d max_entries:%d\n", info.type, info.id, info.name, info.key_size, info.value_size, info.max_entries);
    }
    stats_poll (stats_map_fd, info.type, interval);
    return EXIT_OK;
}
</source>
</doc>
