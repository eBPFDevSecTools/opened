<?xml version="1.0"?>
<doc>
<source file="/root/examples/xdp-tutorials/xdp_prog_kern_03.c" funcheader="static __always_inline __u16 csum_fold_helper (__u32 csum)" startline="33" endline="39">
static __always_inline __u16 csum_fold_helper (__u32 csum)
{
    __u32 sum;
    sum = (csum >> 16) + (csum & 0xffff);
    sum += (sum >> 16);
    return ~sum;
}
</source>
<source file="/root/examples/xdp-tutorials/xdp_prog_kern_03.c" funcheader="static __always_inline __u16 icmp_checksum_diff (__u16 seed, struct icmphdr_common *icmphdr_new, struct icmphdr_common *icmphdr_old)" startline="48" endline="57">
static __always_inline __u16 icmp_checksum_diff (__u16 seed, struct icmphdr_common *icmphdr_new, struct icmphdr_common *icmphdr_old)
{
    __u32 csum, size = sizeof (struct icmphdr_common);
    csum = bpf_csum_diff ((__be32 *) icmphdr_old, size, (__be32 *) icmphdr_new, size, seed);
    return csum_fold_helper (csum);
}
</source>
<source file="/root/examples/xdp-tutorials/xdp_prog_kern_03.c" funcheader="int xdp_icmp_echo_func (struct xdp_md *ctx)" startline="61" endline="150">
int xdp_icmp_echo_func (struct xdp_md *ctx)
{
    void *data_end = (void *) (long) ctx->data_end;
    void *data = (void *) (long) ctx->data;
    struct hdr_cursor nh;
    struct ethhdr *eth;
    int eth_type;
    int ip_type;
    int icmp_type;
    struct iphdr *iphdr;
    struct ipv6hdr *ipv6hdr;
    __u16 echo_reply, old_csum;
    struct icmphdr_common *icmphdr;
    struct icmphdr_common icmphdr_old;
    __u32 action = XDP_PASS;
    nh.pos = data;
    eth_type = parse_ethhdr (& nh, data_end, & eth);
    if (eth_type == bpf_htons (ETH_P_IP)) {
        ip_type = parse_iphdr (& nh, data_end, & iphdr);
        if (ip_type != IPPROTO_ICMP)
            goto out;
    }
    else if (eth_type == bpf_htons (ETH_P_IPV6)) {
        ip_type = parse_ip6hdr (& nh, data_end, & ipv6hdr);
        if (ip_type != IPPROTO_ICMPV6)
            goto out;
    }
    else {
        goto out;
    }
    icmp_type = parse_icmphdr_common (& nh, data_end, & icmphdr);
    if (eth_type == bpf_htons (ETH_P_IP) && icmp_type == ICMP_ECHO) {
        swap_src_dst_ipv4 (iphdr);
        echo_reply = ICMP_ECHOREPLY;
    }
    else if (eth_type == bpf_htons (ETH_P_IPV6) && icmp_type == ICMPV6_ECHO_REQUEST) {
        swap_src_dst_ipv6 (ipv6hdr);
        echo_reply = ICMPV6_ECHO_REPLY;
    }
    else {
        goto out;
    }
    swap_src_dst_mac (eth);
    old_csum = icmphdr->cksum;
    icmphdr->cksum = 0;
    icmphdr_old = *icmphdr;
    icmphdr->type = echo_reply;
    icmphdr->cksum = icmp_checksum_diff (~old_csum, icmphdr, &icmphdr_old);
    action = XDP_TX;
out :
    return xdp_stats_record_action (ctx, action);
}
</source>
<source file="/root/examples/xdp-tutorials/xdp_prog_kern_03.c" funcheader="int xdp_redirect_func (struct xdp_md *ctx)" startline="154" endline="179">
int xdp_redirect_func (struct xdp_md *ctx)
{
    void *data_end = (void *) (long) ctx->data_end;
    void *data = (void *) (long) ctx->data;
    struct hdr_cursor nh;
    struct ethhdr *eth;
    int eth_type;
    int action = XDP_PASS;
    unsigned char dst [ETH_ALEN] = {};
    unsigned ifindex = 0;
    nh.pos = data;
    eth_type = parse_ethhdr (& nh, data_end, & eth);
    if (eth_type == -1)
        goto out;
    memcpy (eth->h_dest, dst, ETH_ALEN);
    action = bpf_redirect (ifindex, 0);
out :
    return xdp_stats_record_action (ctx, action);
}
</source>
<source file="/root/examples/xdp-tutorials/xdp_prog_kern_03.c" funcheader="int xdp_redirect_map_func (struct xdp_md *ctx)" startline="183" endline="212">
int xdp_redirect_map_func (struct xdp_md *ctx)
{
    void *data_end = (void *) (long) ctx->data_end;
    void *data = (void *) (long) ctx->data;
    struct hdr_cursor nh;
    struct ethhdr *eth;
    int eth_type;
    int action = XDP_PASS;
    unsigned char *dst;
    nh.pos = data;
    eth_type = parse_ethhdr (& nh, data_end, & eth);
    if (eth_type == -1)
        goto out;
    dst = bpf_map_lookup_elem (& redirect_params, eth -> h_source);
    if (!dst)
        goto out;
    memcpy (eth->h_dest, dst, ETH_ALEN);
    action = bpf_redirect_map (& tx_port, 0, 0);
out :
    return xdp_stats_record_action (ctx, action);
}
</source>
<source file="/root/examples/xdp-tutorials/xdp_prog_kern_03.c" funcheader="static __always_inline int ip_decrease_ttl (struct iphdr *iph)" startline="221" endline="227">
static __always_inline int ip_decrease_ttl (struct iphdr *iph)
{
    __u32 check = iph->check;
    check += bpf_htons (0x0100);
    iph->check = (__u16) (check + (check >= 0xFFFF));
    return --iph->ttl;
}
</source>
<source file="/root/examples/xdp-tutorials/xdp_prog_kern_03.c" funcheader="int xdp_router_func (struct xdp_md *ctx)" startline="231" endline="325">
int xdp_router_func (struct xdp_md *ctx)
{
    void *data_end = (void *) (long) ctx->data_end;
    void *data = (void *) (long) ctx->data;
    struct bpf_fib_lookup fib_params = {}
    ;
    struct ethhdr *eth = data;
    struct ipv6hdr *ip6h;
    struct iphdr *iph;
    __u16 h_proto;
    __u64 nh_off;
    int rc;
    int action = XDP_PASS;
    nh_off = sizeof (*eth);
    if (data + nh_off > data_end) {
        action = XDP_DROP;
        goto out;
    }
    h_proto = eth->h_proto;
    if (h_proto == bpf_htons (ETH_P_IP)) {
        iph = data + nh_off;
        if (iph + 1 > data_end) {
            action = XDP_DROP;
            goto out;
        }
        if (iph->ttl <= 1)
            goto out;
        fib_params.family = AF_INET;
        fib_params.tos = iph->tos;
        fib_params.l4_protocol = iph->protocol;
        fib_params.sport = 0;
        fib_params.dport = 0;
        fib_params.tot_len = bpf_ntohs (iph->tot_len);
        fib_params.ipv4_src = iph->saddr;
        fib_params.ipv4_dst = iph->daddr;
    }
    else if (h_proto == bpf_htons (ETH_P_IPV6)) {
        struct in6_addr *src = (struct in6_addr *) fib_params.ipv6_src;
        struct in6_addr *dst = (struct in6_addr *) fib_params.ipv6_dst;
        ip6h = data + nh_off;
        if (ip6h + 1 > data_end) {
            action = XDP_DROP;
            goto out;
        }
        if (ip6h->hop_limit <= 1)
            goto out;
        fib_params.family = AF_INET6;
        fib_params.flowinfo = *(__be32*) ip6h & IPV6_FLOWINFO_MASK;
        fib_params.l4_protocol = ip6h->nexthdr;
        fib_params.sport = 0;
        fib_params.dport = 0;
        fib_params.tot_len = bpf_ntohs (ip6h->payload_len);
        *src = ip6h->saddr;
        *dst = ip6h->daddr;
    }
    else {
        goto out;
    }
    fib_params.ifindex = ctx->ingress_ifindex;
    rc = bpf_fib_lookup (ctx, & fib_params, sizeof (fib_params), 0);
    switch (rc) {
    case BPF_FIB_LKUP_RET_SUCCESS :
        if (h_proto == bpf_htons (ETH_P_IP))
            ip_decrease_ttl (iph);
        else if (h_proto == bpf_htons (ETH_P_IPV6))
            ip6h->hop_limit--;
        memcpy (eth->h_dest, fib_params.dmac, ETH_ALEN);
        memcpy (eth->h_source, fib_params.smac, ETH_ALEN);
        action = bpf_redirect (fib_params.ifindex, 0);
        break;
    case BPF_FIB_LKUP_RET_BLACKHOLE :
    case BPF_FIB_LKUP_RET_UNREACHABLE :
    case BPF_FIB_LKUP_RET_PROHIBIT :
        action = XDP_DROP;
        break;
    case BPF_FIB_LKUP_RET_NOT_FWDED :
    case BPF_FIB_LKUP_RET_FWD_DISABLED :
    case BPF_FIB_LKUP_RET_UNSUPP_LWT :
    case BPF_FIB_LKUP_RET_NO_NEIGH :
    case BPF_FIB_LKUP_RET_FRAG_NEEDED :
        break;
    }
out :
    return xdp_stats_record_action (ctx, action);
}
</source>
<source file="/root/examples/xdp-tutorials/xdp_prog_kern_03.c" funcheader="int xdp_pass_func (struct xdp_md *ctx)" startline="328" endline="331">
int xdp_pass_func (struct xdp_md *ctx)
{
    return XDP_PASS;
}
</source>
</doc>
