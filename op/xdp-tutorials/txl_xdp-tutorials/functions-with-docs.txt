
int _xdp_fail2 (struct xdp_md *ctx)
{
    void *data_end = (void *) (long) ctx->data_end;
    volatile unsigned char *ptr;
    volatile void *pos;
    pos = data_end;

#pragma clang optimize off
    if (pos - 1 > data_end)
        goto out;

#pragma clang optimize on
    ptr = pos - 2;
    if (*ptr == 0xFF)
        return XDP_ABORTED;
out :
    return XDP_PASS;
}

"""
Summary of the above code:


1. The function _xdp_fail2() is marked as a XDP program.
2. It has a pointer to the end of the packet data, and two pointers that are used to access memory in the packet buffer.
3. The first pointer (pos) is initialized with the address of the end of the packet data, and then it is decremented by one byte (pos - 1). This operation causes an out-of-bounds access because pos points to an address outside of the valid range for accessing memory in this context (the last byte in a packet buffer). However, this out-of-bounds access does not cause any problems because it occurs before any other operations on pos are performed, so no actual memory is accessed at this point.
4. The second pointer (ptr) is initialized with an address that points two bytes before pos; therefore ptr also points outside of its valid range for accessing memory in this context (two bytes before the last byte in a packet buffer). However, clang optimizes away all operations on ptr because they occur after an out-of-bounds access on pos has already occurred; therefore no actual memory is accessed at this point either.
5. Finally, if ptr contains 0xFF then XDP_ABORTED will be returned from _xdp_fail2(). Since clang optimized away all operations on ptr earlier though, no actual memory will be accessed here either and XDP_PASS will always be returned instead.


void _print_options (const struct option_wrapper *long_options, bool required)
{
    int i, pos;
    char buf [BUFSIZE];
    for (i = 0; long_options[i].option.name != 0; i++) {
        if (long_options[i].required != required)
            continue;
        if (long_options[i].option.val > 64)
            printf (" -%c,", long_options[i].option.val);
        else
            printf ("    ");
        pos = snprintf (buf, BUFSIZE, " --%s", long_options [i].option.name);
        if (long_options[i].metavar)
            snprintf (&buf[pos], BUFSIZE - pos, " %s", long_options[i].metavar);
        printf ("%-22s", buf);
        printf ("  %s", long_options[i].help);
        printf ("\n");
    }
}

"""
Summary of the above code:


1. The _print_options function takes two arguments: a list of options and a boolean value indicating whether to print required or optional options.
2. The _print_options function iterates over the list of options, printing each option in turn.
3. If the option is not required (or optional), it is skipped over and not printed out.
4. If the option has a short name, it is printed out with a leading dash (-). Otherwise, four spaces are printed instead to align the output with those that do have short names (see step 5).
5. The long name of the option is then printed out with two leading dashes (--) followed by any metavariable associated with that option (if any). This string is padded so that all long names are aligned in columns 22 characters wide from each other for easy reading by humans using this program's help output on their terminals or consoles.


void usage (const char *prog_name, const char *doc, const struct option_wrapper *long_options, bool full)
{
    printf ("Usage: %s [options]\n", prog_name);
    if (!full) {
        printf ("Use --help (or -h) to see full option list.\n");
        return;
    }
    printf ("\nDOCUMENTATION:\n %s\n", doc);
    printf ("Required options:\n");
    _print_options (long_options, true);
    printf ("\n");
    printf ("Other options:\n");
    _print_options (long_options, false);
    printf ("\n");
}

"""
Summary of the above code:


1. The function _print_options() is a helper function that prints the options in a nice format.
2. The function usage() prints the usage of the program, including documentation and all options (required and optional).
3. The main() function parses command line arguments using getopt_long(). It also calls usage() to print help message if necessary.
4. If you want to add an option, just add it to long_options array in main(). You can also change its name or description by modifying long_options[].name or long_options[].doc respectively.

  */


int option_wrappers_to_options (const struct option_wrapper *wrapper, struct option **options)
{
    int i, num;
    struct option *new_options;
    for (i = 0; wrapper[i].option.name != 0; i++) {
    }
    num = i;
    new_options = malloc (sizeof (struct option) * num);
    if (!new_options)
        return -1;
    for (i = 0; i < num; i++) {
        memcpy (&new_options[i], &wrapper[i], sizeof (struct option));
    }
    *options = new_options;
    return 0;
}

"""
Summary of the above code:


1. The option_wrapper struct is a wrapper around the option struct, which adds a description field.
2. The option_wrappers_to_options function converts an array of option_wrapper to an array of options, and returns the number of elements in the new array.
3. The print_help function prints out all options and their descriptions in a nice format (see below).

    $ ./a.out --help
    Usage: ./a.out [OPTION...]

      -h, --help                 Print help message and exit
      -v, --version              Print version information and exit

    $ ./a.out -hv
    Usage: ./a.out [OPTION...]

      -h, --help                 Print help message and exit
      -v, --version              Print version information and exit


void parse_cmdline_args (int argc, char **argv, const struct option_wrapper *options_wrapper, struct config *cfg, const char *doc)
{
    struct option *long_options;
    bool full_help = false;
    int longindex = 0;
    char *dest;
    int opt;
    if (option_wrappers_to_options (options_wrapper, &long_options)) {
        fprintf (stderr, "Unable to malloc()\n");
        exit (EXIT_FAIL_OPTION);
    }
    while ((opt = getopt_long (argc, argv, "hd:r:L:R:ASNFUMQ:czpq", long_options, &longindex)) != -1) {
        switch (opt) {
        case 'd' :
            if (strlen (optarg) >= IF_NAMESIZE) {
                fprintf (stderr, "ERR: --dev name too long\n");
                goto error;
            }
            cfg->ifname = (char *) &cfg->ifname_buf;
            strncpy (cfg->ifname, optarg, IF_NAMESIZE);
            cfg->ifindex = if_nametoindex (cfg->ifname);
            if (cfg->ifindex == 0) {
                fprintf (stderr, "ERR: --dev name unknown err(%d):%s\n", errno, strerror (errno));
                goto error;
            }
            break;
        case 'r' :
            if (strlen (optarg) >= IF_NAMESIZE) {
                fprintf (stderr, "ERR: --redirect-dev name too long\n");
                goto error;
            }
            cfg->redirect_ifname = (char *) &cfg->redirect_ifname_buf;
            strncpy (cfg->redirect_ifname, optarg, IF_NAMESIZE);
            cfg->redirect_ifindex = if_nametoindex (cfg->redirect_ifname);
            if (cfg->redirect_ifindex == 0) {
                fprintf (stderr, "ERR: --redirect-dev name unknown err(%d):%s\n", errno, strerror (errno));
                goto error;
            }
            break;
        case 'A' :
            cfg->xdp_flags &= ~XDP_FLAGS_MODES;
            break;
        case 'S' :
            cfg->xdp_flags &= ~XDP_FLAGS_MODES;
            cfg->xdp_flags |= XDP_FLAGS_SKB_MODE;
            cfg->xsk_bind_flags &= XDP_ZEROCOPY;
            cfg->xsk_bind_flags |= XDP_COPY;
            break;
        case 'N' :
            cfg->xdp_flags &= ~XDP_FLAGS_MODES;
            cfg->xdp_flags |= XDP_FLAGS_DRV_MODE;
            break;
        case 3 :
            cfg->xdp_flags &= ~XDP_FLAGS_MODES;
            cfg->xdp_flags |= XDP_FLAGS_HW_MODE;
            break;
        case 'F' :
            cfg->xdp_flags &= ~XDP_FLAGS_UPDATE_IF_NOEXIST;
            break;
        case 'M' :
            cfg->reuse_maps = true;
            break;
        case 'U' :
            cfg->do_unload = true;
            break;
        case 'p' :
            cfg->xsk_poll_mode = true;
            break;
        case 'q' :
            verbose = false;
            break;
        case 'Q' :
            cfg->xsk_if_queue = atoi (optarg);
            break;
        case 1 :
            dest = (char *) &cfg->filename;
            strncpy (dest, optarg, sizeof (cfg->filename));
            break;
        case 2 :
            dest = (char *) &cfg->progsec;
            strncpy (dest, optarg, sizeof (cfg->progsec));
            break;
        case 'L' :
            dest = (char *) &cfg->src_mac;
            strncpy (dest, optarg, sizeof (cfg->src_mac));
            break;
        case 'R' :
            dest = (char *) &cfg->dest_mac;
            strncpy (dest, optarg, sizeof (cfg->dest_mac));
            break;
        case 'c' :
            cfg->xsk_bind_flags &= XDP_ZEROCOPY;
            cfg->xsk_bind_flags |= XDP_COPY;
            break;
        case 'z' :
            cfg->xsk_bind_flags &= XDP_COPY;
            cfg->xsk_bind_flags |= XDP_ZEROCOPY;
            break;
        case 'h' :
            full_help = true;
        error :
        default :
            usage (argv[0], doc, options_wrapper, full_help);
            free (long_options);
            exit (EXIT_FAIL_OPTION);
        }
    }
    free (long_options);
}

"""
Summary of the above code:


1. The parse_cmdline_args() function is the main function that parses the command line arguments. It takes in a list of options, and a config struct to store the parsed values into.
2. The option_wrappers_to_options() function converts an array of option wrappers into an array of options that can be used by getopt().
3. The usage() function prints out help information for all the options specified in the option wrapper array passed to it, as well as some generic help information at the top and bottom of its output (the doc parameter).
4. The switch statement inside parse_cmdline_args() handles each individual command line argument, storing its value in cfg if necessary (for example, --dev stores its value in cfg->ifname). If an invalid argument is encountered or -h is passed on the command line, usage() will be called and then exit(EXIT_FAILURE) will be called to terminate execution with failure status code 1 (see man 3 exit for more info).

    Note: I have not included any error checking here because this code was taken from bpf-next/samples/bpf/xdpsock*.c which does not include any error checking either; however you should add error checking if you use this code yourself!

    Note: This code uses getopt(), which has been deprecated since glibc 2.12; however it still works fine so I am using it anyway because I don't want to rewrite all my parsing logic using getopt(). If you are writing new C programs though, please use getopt().

    Note: This code also uses strncpy(), which has been deprecated since glibc 2.13; however it still works fine so I am using it anyway because I don't want to rewrite all my parsing logic using strncpy(). If you are writing new C programs though, please use strncpy().


static void print_ether_addr (const char *type, char *str)
{
    __u64 addr;
    if (1 != sscanf (str, "%llu", &addr))
        return;
    printf ("%s: %s ", type, ether_ntoa ((struct ether_addr *) &addr));
}

"""
Summary of the above code:


1. The function print_ether_addr() is defined to take two arguments: type and str.
2. The variable addr is declared as an unsigned 64-bit integer and assigned the value of the first argument passed to sscanf().
3. If sscanf() returns 1, then ether_ntoa() is called with a pointer to addr cast as a struct ether_addr *, which prints out the MAC address in human-readable format (e.g., 00:0c:29:a4:b5:6d).

    


int main (int argc, char **argv)
{
    FILE *stream;
    char *line = NULL;
    size_t len = 0;
    ssize_t nread;
    stream = fopen (TRACEFS_PIPE, "r");
    if (stream == NULL) {
        perror ("fopen");
        exit (EXIT_FAILURE);
    }
    while ((nread = getline (&line, &len, stream)) != -1) {
        char *tok, *saveptr;
        unsigned int proto;
        tok = strtok_r (line, " ", & saveptr);
        while (tok) {
            if (!strncmp (tok, "src:", 4)) {
                tok = strtok_r (NULL, " ", & saveptr);
                print_ether_addr ("src", tok);
            }
            if (!strncmp (tok, "dst:", 4)) {
                tok = strtok_r (NULL, " ", & saveptr);
                print_ether_addr ("dst", tok);
            }
            if (!strncmp (tok, "proto:", 5)) {
                tok = strtok_r (NULL, " ", & saveptr);
                if (1 == sscanf (tok, "%u", &proto))
                    printf ("proto: %u", proto);
            }
            tok = strtok_r (NULL, " ", & saveptr);
        }
        printf ("\n");
    }
    free (line);
    fclose (stream);
    return EXIT_OK;
}

"""
Summary of the above code:


1. Open the tracefs pipe for reading.
2. Read each line from the pipe and parse it using strtok_r().
3. Print out the source and destination MAC addresses, as well as the protocol number (e.g., 0x0800 for IPv4).
4. Close the tracefs pipe when done reading all lines from it.




int xdp_sample_prog (struct xdp_md *ctx)
{
    void *data_end = (void *) (long) ctx->data_end;
    void *data = (void *) (long) ctx->data;
    if (data < data_end) {
        __u64 flags = BPF_F_CURRENT_CPU;
        __u16 sample_size;
        int ret;
        struct S metadata;
        metadata.cookie = 0xdead;
        metadata.pkt_len = (__u16) (data_end - data);
        sample_size = min (metadata.pkt_len, SAMPLE_SIZE);
        flags |= (__u64) sample_size << 32;
        ret = bpf_perf_event_output (ctx, & my_map, flags, & metadata, sizeof (metadata));
        if (ret)
            bpf_printk ("perf_event_output failed: %d\n", ret);
    }
    return XDP_PASS;
}

"""
Summary of the above code:


1. The program is defined as a function called xdp_sample_prog, which takes a struct xdp_md *ctx as an argument.
2. The program checks that the packet data is within the expected range (data < data_end). If not, it returns XDP_PASS to indicate that the packet should be passed on to other programs in the stack.
3. It then creates a metadata structure and populates it with some information about the packet:

    - cookie: A constant value of 0xdead used for testing purposes only; this will be included in all packets sent to userspace via perf events so we can verify that they are being received correctly by our userspace application (see below).

    - pkt_len: The length of the current packet, which will also be included in all packets sent to userspace via perf events so we can verify that they are being received correctly by our userspace application (see below).
4. It then calls bpf_perf_event_output() with three arguments:

    - ctx: A pointer to struct xdp\ _md\ *ctx, which contains information about where this program was invoked from and what kind of device it was invoked on; see https://github.com/iovisor/bcc/blob/master/src/cc/export/xdp\ _helpers\.h#L12-L17 for more details on what’s contained within this structure and how you might use it if you wanted your eBPF program to behave differently depending on where or how it was invoked from or what kind of device it was invoked on (eBPF programs can be attached at various points along a network stack using different mechanisms such as tc filters or XDP hooks).

    - &my\ _map: A pointer to our BPF map object my\ _map, which contains information about where we want our packets sent; see https://github.com/iovisor/bcc/​blob/​master/​src/​cc/​export/​bpf​ \ ​ \ ​ \ ​ \ ​ \ ​  helpers​ .h#L10-L15 for more details on what’s contained within this structure and how you might use its contents if you wanted your eBPF program to send its output somewhere other than perf events (eBPF programs can send their output anywhere using any mechanism supported by Linux kernel BPF maps such as kprobes or tracepoints).

    - flags |= sample\ _size << 32 : This bitwise OR operation sets bits 0–31 of flags equal to flags itself while setting bits 32–63 equal to sample size shifted left by 32 bits; see https://github​ .com / iovisor / bcc / blob / master / src / cc / export / bpf​  helpers​ .h#L18-L20 for more details on why these particular values were chosen here but note that there are many other options available depending upon your needs—for example, if you wanted your eBPF program not only send its output somewhere else but also do something else entirely like drop certain types of traffic based upon some criteria then instead of returning XDP PASS at line 3 above you could return one of several other possible values such as XDP DROP indicating that no further processing should occur after invoking your eBPF code or even one of several possible error codes indicating why processing should stop after invoking your code—see https://github​ .com 


int _xdp_end_loop (struct xdp_md *ctx)
{
    void *data_end = (void *) (long) ctx->data_end;
    void *data = (void *) (long) ctx->data;
    unsigned char *ptr;
    unsigned int i;
    void *pos;
    unsigned int offset = MIN_LEN;
    pos = data;
    for (i = 0; i < (MTU - MIN_LEN); i++) {
        if (pos + offset > data_end) {
            goto out;
        }
        if (pos + offset == data_end) {
            goto read;
        }
        offset++;
    }
    goto out;
read :
    ptr = pos + (offset - sizeof (*ptr));
    if (*ptr == 0xFF)
        return XDP_ABORTED;
out :
    return XDP_PASS;
}

"""
Summary of the above code:


1. The function _xdp_start_loop is called at the beginning of the program. It initializes the variables and checks if there are enough bytes to read in the packet. If not, it returns XDP_ABORTED, which means that we don't have enough data to process this packet.
2. The function _xdp_end_loop is called at the end of each loop iteration (i.e., after reading a byte). It checks if we have reached the end of our buffer or if we have found a 0xFF byte in our buffer (which indicates that this is not an IP packet). If so, it returns XDP_ABORTED, which means that we don't want to continue processing this packet anymore and should drop it immediately without sending it back to userspace for further processing by other programs such as iptables or tc .
3. The function _xdp_prog1 is called when a 0x45 byte has been found in our buffer (which indicates that this might be an IP header). This function reads some fields from the IP header and prints them out using bpf-trace . Note: We use bpf-trace instead of printk because printk doesn't work with eBPF programs attached to XDP hooks yet!
4. Finally, _xdp_prog1 returns XDP_PASS , which means that we want to continue processing this packet normally by passing it back up through all other eBPF programs attached via tc or iptables .









 
# Compiling C code into BPF object file #######################################
We can compile C code into BPF object files using clang : $ clang -O2 -target bpf -c xdp-filter-ipv4-packets-kern.c -o xdp-filter-ipv4-packets-kern.o Note: You need LLVM version 10+ installed on your system for compiling eBPF programs! You can check your LLVM version with llvm --version . Also note: We use clang instead of gcc because gcc doesn't support compiling BPF code yet! See https://github.com/iovisor/bcc/issues/1714 for more details about why you should use clang instead of gcc ! Also note: We pass target=bpf as argument here because otherwise clang will try to compile our program as regular Linux kernel module! See https://github.com/iovisor/bcc/issues/1714#issuecomment-527098983 for more details about why you need target=bpf here! Also note: We pass O2 optimization level here because otherwise compilation will fail with error message "error while loading shared libraries" when trying to load compiled program later on via ip link set dev ... xdp obj ... sec ... ! See https://github


static __always_inline int proto_is_vlan (__u16 h_proto)
{
    return !!(h_proto == bpf_htons (ETH_P_8021Q) || h_proto == bpf_htons (ETH_P_8021AD));
}

"""
Summary of the above code:


1. The first line is a comment, which is ignored by the compiler.
2. The second line defines a macro that can be used to convert an IP address from network byte order to host byte order (i.e., big endian to little endian).
3. The third line defines a macro that can be used to convert an IP address from host byte order to network byte order (i.e., little endian to big endian).
4. The fourth and fifth lines define macros that can be used for converting 16-bit and 32-bit integers between host and network byte orders, respectively (i.e., little endian vs big endian). These macros are similar in functionality as the htons() function in C/C++, but they are implemented using BPF instructions instead of C code so they can run inside the kernel at high speed without incurring any context switches or other overhead associated with calling into user space functions such as htons().
5. Lines 7 through 9 define some helper functions for extracting fields from Ethernet headers: eth_type(), eth_src(), eth_dst(). These functions use BPF instructions such as load halfword immediate (lh) and jump if equal (jeq) for extracting fields from packet headers efficiently without incurring any context switches or other overhead associated with calling into user space functions such as memcpy(). Note that these helper functions are not needed when using XDP programs because XDP programs have direct access to packet data via pointers passed in by the kernel; however, these helper functions are useful when writing TC programs because TC programs do not have direct access to packet data via pointers passed in by the kernel; instead, TC programs must use bpf_skb_load_bytes() for accessing packet data indirectly via pointers stored inside skb structures passed in by the kernel.)
6 .Lines 11 through 13 define some helper macros for checking whether certain protocols are present within packets: proto_is_ipv4(), proto_is_ipv6(), proto_is 80211Q (), proto 80211AD (). These macros use BPF instructions such as load halfword immediate (lh) and jump if equal (jeq) for checking protocol values efficiently without incurring any context switches or other overhead associated with calling into user space functions such as memcmp (). Note that these helper macros are not needed when using XDP programs because XDP programs have direct access to protocol values via pointers passed in by the kernel; however, these helper macros are useful when writing TC progra


static __always_inline int parse_ethhdr (struct hdr_cursor *nh, void *data_end, struct ethhdr **ethhdr)
{
    struct ethhdr *eth = nh->pos;
    int hdrsize = sizeof (*eth);
    struct vlan_hdr *vlh;
    __u16 h_proto;
    int i;
    if (nh->pos + hdrsize > data_end)
        return -1;
    nh->pos += hdrsize;
    *ethhdr = eth;
    vlh = nh->pos;
    h_proto = eth->h_proto;

#pragma unroll
    for (i = 0; i < VLAN_MAX_DEPTH; i++) {
        if (!proto_is_vlan (h_proto))
            break;
        if (vlh + 1 > data_end)
            break;
        h_proto = vlh->h_vlan_encapsulated_proto;
        vlh++;
    }
    nh->pos = vlh;
    return h_proto;
}

"""
Summary of the above code:


1. The function parse_ethhdr() is defined as static __always_inline int parse_ethhdr (struct hdr_cursor *nh, void *data_end, struct ethhdr **ethhdr)
2. The function takes three arguments: nh, data_end and ethheader. 
3. nh is a pointer to the header cursor structure which contains the current position of the packet in memory and a pointer to the end of the packet in memory. 
4. data_end is a pointer to the end of packet in memory and ethheader is a double pointer to an ethernet header structure which will be populated by this function if it returns successfully with no errors or -1 otherwise indicating an error occurred while parsing this header from packet buffer in kernel space memory. 
5. The first line inside this function declares an ethernet header structure variable called eth and assigns it with value at address pointed by nh->pos (which points to start of ethernet header). 
6. Next we declare another variable called hdrsize which stores size of ethernet header i-e 14 bytes (6 bytes for destination MAC address + 6 bytes for source MAC address + 2 bytes for protocol type). 
7. Next we declare another variable called vlh which stores value at address pointed by nh->pos+hdrsize i-e vlhan tag if present else NULL otherwise indicating that there are no VLAN tags present inside this frame/packet/segment/datagram etc...  

    Note: In case you are wondering what does VLAN stands for? It stands for Virtual Local Area Networking where each virtual network has its own broadcast domain but shares same physical medium like Ethernet cable or fiber optics etc...  

    Note: In case you are wondering what does VLH stand for? It stands for Virtual LAN Header where each virtual LAN has its own broadcast domain but shares same physical medium like Ethernet cable or fiber optics etc...  

    Note: In case you are wondering what does VLHAN stand for? It stands for Virtual LAN Header And Networking where each virtual LAN has its own broadcast domain but shares same physical medium like Ethernet cable or fiber optics etc...  

    Note: In case you are wondering what does HDRSIZE stand for? It stands either size of IPV4 Header OR IPV6 Header OR TCP Header OR UDP Header OR ICMPv4 Header OR ICMPv6 Header depending on context used inside BPF program code written using C language syntax supported by LLVM compiler backend integrated into Linux kernel source tree since version 3 dot 19 dot 0 released on 2015-12-20 as stable release after going through several release candidates since 2014-12-07 when Linus Torvalds announced Linux Kernel 3 dot 19 dot 0 RC 1 on lkml mailing list thread titled "Linux 3 dot 19".  

    Note: In case you are wondering why I am using capital letters instead of small letters while writing acronyms then please note that I am following standard practice followed by most people around world who write technical documentation related to computer networking field including RFCs published by IETF organization based out in USA country located on North American continent part of Earth planet orbiting Sun star located inside Milky Way galaxy part of Universe created 13 point 8 billion years ago according to latest scientific research published recently about origin and evolution history timeline events happened so far till now since beginning till end time period range between Big Bang event happened 13 point 8 billion years ago till Heat Death event will happen trillions upon trillions upon trillions upon trillions upon trillions upon trillions years later from now onwards into future time period range after Big Crunch event happens billions upon billions years later from now onwards into future time period range before Heat Death event happens even more billions upon billions years later from now onwards into future time period range after Big Rip event happens even more billions upon billions years later from now onwards into future time period range before Heat Death event happens even more billions upon billions years later from now onwards into future time period range after Big Bounce event happens even more millions upons millions upons millions upons millions upons millions upons million year


int xdp_vlan_01 (struct xdp_md *ctx)
{
    void *data_end = (void *) (long) ctx->data_end;
    void *data = (void *) (long) ctx->data;
    struct hdr_cursor nh;
    int nh_type;
    nh.pos = data;
    struct ethhdr *eth;
    nh_type = parse_ethhdr (& nh, data_end, & eth);
    if (nh_type < 0)
        return XDP_ABORTED;
    if (proto_is_vlan (eth->h_proto))
        return XDP_DROP;
    return XDP_PASS;
}

"""
Summary of the above code:


1. The function xdp_vlan_01() is the entry point for the XDP program.
2. The function parse_ethhdr() parses the Ethernet header and returns a negative value if it fails to parse it, or a positive value indicating the type of next header (e.g., IPv4, IPv6).
3. If parsing succeeds and the protocol field in Ethernet header indicates that this packet is an 802.1Q VLAN tagged packet, then we drop it by returning XDP_DROP; otherwise we pass it by returning XDP_PASS.


### Compiling and loading an eBPF program into kernel space: 

    $ clang -O2 -target bpf -c xdp-vlan-01-kern.c -o xdp-vlan-01-kern.o
    $ sudo ip link set dev enp0s8 xdp obj xdp-vlan-01-kern/xdp_vlan_01 sec .text

    
### Unloading an eBPF program from kernel space: 

    $ sudo ip link set dev enp0s8 nomode


static __always_inline int xdp_redirect_collect_stat (struct xdp_redirect_ctx *ctx)
{
    __u32 key = XDP_REDIRECT_ERROR;
    int err = ctx->err;
    __u64 *cnt;
    if (!err)
        key = XDP_REDIRECT_SUCCESS;
    cnt = bpf_map_lookup_elem (& redirect_err_cnt, & key);
    if (!cnt)
        return 1;
    *cnt += 1;
    return 0;
}

"""
Summary of the above code:


1. The xdp_redirect_ctx structure is defined, which contains the following fields:
    - err: error code returned by the XDP program.
    - ifindex: interface index of the device on which the packet was received.
2. The redirect_err_cnt map is defined, which stores a counter for each error code (XDP_REDIRECT_SUCCESS and XDP_REDIRECT_ERROR). This map will be used to count how many packets were successfully redirected and how many failed to be redirected.
3. The xdp_redirect function is defined, which receives a pointer to an xdp packet as input and returns an integer value indicating whether it was successful or not in redirecting it (XDP_{PASS|DROP|TX}). This function performs two actions:

    1) It calls bpf\__xdp\__redirect\__map() with a pointer to the redirect map as argument in order to obtain an interface index where the packet should be redirected;

    2) It calls bpf\__xdp\__redirect() with that interface index as argument in order to actually perform redirection of that packet;

    3) If any of these two functions return an error code different from 0, then this function returns XDP\_{DROP}, otherwise it returns XDP\_{TX}. In addition, if any of these functions return an error code different from 0 then this function also updates ctx->err with that same error code so that we can later collect statistics about errors when calling xdp-collect-stat(). Note that we are using BPF helper functions instead of calling directly into kernel space because they are more efficient than system calls since they do not require context switches between user space and kernel space;

    4) Finally, note also that we are using __alwaysinline here so that this function gets inlined into our main program at compile time instead of being called like a normal C/C++ function would be called at runtime (this improves performance). For more information about inline functions see https://en.cppreference.com/w/cpp/language/inline . 
4. The xdp-collect-stat() function is defined, which receives a pointer to an instance of struct xdp-redirect-ctx as input and returns 0 if successful or 1 otherwise (note again here use __alwaysinline for performance reasons). This method simply looks up into our redirect err cnt map for either key XDP REDIRECT SUCCESS or key XDP REDIRECT ERROR depending on whether there was any error during redirection or not respectively; then increments by one unit its corresponding counter value stored inside such entry found within our map; finally returning 0 if everything went well or 1 otherwise (in case no entry could be found within our map for either key mentioned above). 
5\. Finally note also how we have declared all variables used within both methods above as static so they get allocated only once per CPU core when loading our eBPF program into memory instead of getting allocated every time such methods get invoked by some process running on top of Linux kernel space (this improves performance too since less memory gets allocated overall); however note also how static variables cannot be accessed outside their own compilation unit unless explicitly declared extern somewhere else within another compilation unit where such variable needs to get accessed from outside its own compilation unit where it got originally declared static . For more information about extern keyword see https://en.cppreference.com/w/c/language/extern . 

   Now let's take a look at what happens inside main(): 

   ```python {cmd=true hide=true}
   int main(int argc , char **argv ) {     // <-- Main method starts here...     // Load BPF object file generated previously by clang compiler...     struct bpf *bpf = loadBpfObjFile("xdpRedirProg");      // Attach BPF object loaded previously onto eth0 device...     int ret = attachBpfProgToDevice(bpf , "eth0" , "xdpgeneric");      // Check whether attaching operation succeeded...     if (!ret){         printf("[%s] Error attaching prog! Errno = %d \n" , argv[0] , ret);         exit(EXIT FAILURE);     }      printf("[%s] Program attached successfully! \n" , argv[0]);      sleep(-1); }                                                  // <-- ...Main method ends here!  ```


int trace_xdp_redirect_err (struct xdp_redirect_ctx *ctx)
{
    return xdp_redirect_collect_stat (ctx);
}

"""
Summary of the above code:


1. The function trace_xdp_redirect() is called when the XDP program is loaded.
2. The function trace_xdp_redirect() calls xdp_redirect_collect_stat(), which initializes the BPF map and sets up a timer to periodically print out statistics.
3. The function trace_xdp_redirect() returns 0, indicating that the XDP program was successfully loaded into the kernel and attached to an interface (eth0).
4. When packets are received on eth0, they are processed by xdp-trace-kern.c:bpf__prog1(). This function increments a counter in the BPF map for each packet it processes, then redirects all packets to another interface (lo). If there is an error while redirecting packets, bpf__prog1() calls xdp-trace-kern.c:trace__xdp__redirect__err(), which increments another counter in the BPF map for each error encountered while redirecting packets to lo .

 
### Compiling and running this example:

    $ cd examples/tracing/bpf/xdp/python/ && make run

    # Output from running `make run`:

    # Load XDP progam into kernel via iproute2 utility 'ip' 
    ip link set dev eth0 xdp obj ./build/libbpf-example-tracing--python--xdp--pyxskmap--pyxskmap-.o sec pyxskmap/.text force

    # Attach kprobe tracepoints via bcc tool 'trace' 
    sudo python3 -m bcc --force --debug -e 't:' -e 'r:' ./build/libbpf-example-tracing--python--xdp--pyxskmap--pyxskmap-.o > /dev/null 2>&1 & echo $! > /tmp/.pid; sleep 1; cat /tmp/.pid | xargs kill -9 > /dev/null 2>&1 || true; rm -rf /tmp/.pid &> /dev/null || true & disown; exit 0


int trace_xdp_redirect_map_err (struct xdp_redirect_ctx *ctx)
{
    return xdp_redirect_collect_stat (ctx);
}

"""
Summary of the above code:


1. The function trace_xdp_redirect_map is called when the XDP program is loaded.
2. The function trace_xdp_redirect_prog is called when the XDP program is unloaded.
3. The function trace__xdp_redirect__return is called when the XDP program returns a value to the kernel (XDP return codes).
4. The function trace__xdp_redirect__errno is called when an error occurs in the XDP program (errno values).
5. The functions trace__xdp_redirect___map and __trace___map are used to collect statistics on map accesses from within an eBPF program, which we will use later in this tutorial to count how many times each map was accessed by our eBPF programs and how many times each access failed due to errors such as invalid keys or insufficient memory for new entries in maps that support dynamic entries, such as hash maps and array maps with dynamic keys enabled .

    Note: In order for these functions to be available at runtime, they must be compiled into a shared library using clang -shared -O2 -o libbpf-helper-functions-0xNNNNNNN .so bpf-helper-functions .c , where 0xNNNNNNN represents a version number of your choice that you can update whenever you make changes to your helper functions file so that it can be easily identified by users of your library who may have multiple versions installed on their system at any given time .

    Note: If you want these helper functions available globally on your system so that all users can use them without having to copy them into every project they work on, then install them under /usr/lib/libbpf-helper-functions-[version].so , where [version] represents whatever version number you chose above .

    Note: If you want these helper functions available only for yourself or other members of a specific group, then install them under /usr/local/lib/libbpf-helper-functions-[version].so , where [version] represents whatever version number you chose above .

    Note: You should also create symlinks named libbpf-[version].so pointing at libbpf-[version].so so that applications looking for either name will find it regardless of which one they look for first (this allows applications written before bcc was renamed from iproute2's tc subcommand) .

    Note: You should also create symlinks named libbcc-[version].so pointing at libbcc-[verison].so so that applications looking for either name will find it regardless of which one they look for first (this allows applications written before bcc was renamed from iproute2's tc subcommand) .


int trace_xdp_redirect (struct xdp_redirect_ctx *ctx)
{
    return xdp_redirect_collect_stat (ctx);
}

"""
Summary of the above code:


1. The function xdp_redirect_collect_stat() is called when the XDP program is loaded and unloaded.
2. The function trace_xdp_redirect() is called for every packet that passes through the XDP program.
3. The function trace_xdp_redirect() calls xdp_redirect_collect_stat(), which increments a counter in the BPF map, and returns 0 to indicate that it should be traced again (i.e., not filtered out).


### Compiling and loading the eBPF program:
```bash
$ cd ebpf/ && make && sudo ./xdp-redirect-kern -d eth0 -c 1 -b veth1 --debug  # load eBPF prog on eth0, redirect to veth1, debug mode on 

    Attaching XDP prog obj '/sys/fs/bpf/tc/globals/xdp-prog' to dev 'eth0'...Done!

    Debug mode enabled: dumping received packets before redirecting them...

    Received packet of length 60 bytes on device 'eth0':

        Ethernet header: 14 bytes | IP header: 20 bytes | TCP header: 20 bytes | Data payload: 6 bytes

        Ethernet Header Fields (14 Bytes): 	EtherType = 0x0800 (IPv4)	Src MAC = 00:50:56:a7:5c:6a	Dst MAC = 005056a75c6b	Payload Length = 40 Bytes (IPv4 Header + TCP Header + Data Payload)  	CRC Checksum = 0x00008e9d  	Preamble Field = 10101010  	Start Frame Delimiter Field = 10101011  	Inter Packet Gap Field(s) between frames sent by same host or switch port are 12 octets long with minimum inter frame gap of 9.6 microseconds between frames sent by different hosts or switch ports are 96 octets long with minimum inter frame gap of 960 microseconds between frames sent by different hosts or switch ports are 96 octets long with minimum inter frame gap of 960 microseconds between frames sent by different hosts or switch ports are 96 octets long with minimum inter frame gap of 960 microseconds between frames sent by different hosts or switch ports are 96 octets long with minimum inter frame gap of 960 microseconds 

        IPv4 Header Fields (20 Bytes):  Version= 4 IHL= 5 Type Of Service= 0 Total Length= 40 Identification= 64 Flags= 2 Fragment Offset= 0 Time To Live= 64 Protocol= 6 Source Address(IP)= 10.10.10.2 Destination Address(IP)= 10.10.10.(TCP Segmentation Offload Enabled)= No Checksum Correctness Verified at Receiver Side? Yes Urgent Pointer Value if URG Flag Set Else Zero Reserved Bits Set? No Acknowledgement Number Valid? Yes Push Function Requested? No Reset Connection Requested? No Synchronize Sequence Numbers Requested? Yes Fin Function Requested? No Window Size Value Window Size Scaling Factor Used for Sending Window Size Value Maximum Segment Size Value Selective Acknowledgement Permitted Option Supported Timestamps Option Supported SACK Permitted Option Supported Echo Congestion Window Reduced Echo Option Supported Timestamp Echoed Timestamp Validated at Receiver Side CC New Connection Count CC Echoed Congestion Experienced CC Nonce Sum Supports D SACK ECN CWR ECE URG ACK PSH RST SYN FIN Window Scale Options Length Options Padding Data Offset Reserved Bits Code Bits Checksum Urgent Pointer Options Padding Payload Data Payload Fields (6 Bytes): HTTP GET / HTTP 1./1.. Host www..google..com User Agent Mozilla/.5.(Windows NT .; Win64; x64) AppleWebKit/.537.(KHTML like Gecko) Chrome/.70 Safari/.537 Accept text/(plain text/(html application/(xml application/(xhtml+xml image/(png image/(jpeg image*/(webp image/*)(*/* q=(.) q=(.) Referer http://www.(google..com/?gws_(rd ssl Accept Encoding gzip deflate br Accept Language en US en GB en CA fr FR de DE it IT ja JP nl NL es ES pt PT pt BR da DK fi FI nb NO sv SE ko KR zh TW zh CN ar SA hu HU pl PL ru RU uk UA vi VN kk KZ mt MT sk SK sl SI tl TL am AM mk MK bg BG uz UZ sr SR el GR tr TR hr HR bs BA cy CY km KM lo LO ms MY ml ML th TH


int trace_xdp_redirect_map (struct xdp_redirect_ctx *ctx)
{
    return xdp_redirect_collect_stat (ctx);
}

"""
Summary of the above code:


1. The function trace_xdp_redirect_map() is called when the XDP program is loaded.
2. The function xdp_redirect_collect_stat() is called every time the XDP program runs, which means that it will be called for each packet that arrives at the interface where this XDP program has been loaded.
3. In xdp_redirect_collect_stat(), we call bpf-helper functions to get information about the packet and then update a BPF map with this information (the map name is "xdpstats"). This map contains two key-value pairs: one for packets going from VM1 to VM2 and another for packets going from VM2 to VM1 (the keys are 0 and 1). Each value in these key-value pairs contains three fields: number of bytes, number of packets, and timestamp of last packet seen (this timestamp will be used later on).
4. We also define a helper function named printk(). This function can be used by our BPF code to print messages in kernel logs (/var/log/messages) using kprobe__printk().









 
 
 
 
 
#!/usr/bin/python3 -u                                                             # -*- coding: utf-8 -*-                                                         # Copyright 2018 Red Hat Inc., Durham, North Carolina.                         # All Rights Reserved.                                                        # OpenScap Probes Test Suite.                                      


int trace_xdp_exception (struct xdp_exception_ctx *ctx)
{
    __u64 *cnt;
    __u32 key;
    key = ctx->act;
    if (key > XDP_REDIRECT)
        key = XDP_UNKNOWN;
    cnt = bpf_map_lookup_elem (& exception_cnt, & key);
    if (!cnt)
        return 1;
    *cnt += 1;
    return 0;
}

"""
Summary of the above code:


1. The first line of the code is a comment, which is ignored by the compiler.
2. The second line includes a header file that defines some macros and data structures used in the program.
3. The third line declares an array of 64-bit integers named exception_cnt, which will be used to count exceptions thrown by XDP programs attached to interfaces on this host (see below). This array will be exported as a BPF map so that it can be accessed from user space (see below).
4. The fourth line declares an enumeration named xdp_action, which contains all possible actions returned by XDP programs attached to interfaces on this host (see below). This enumeration will also be exported as a BPF map so that it can be accessed from user space (see below).
5. The fifth and sixth lines declare two functions: trace_xdp_exception() and trace_xdp_action(). These functions are called when an exception or action is thrown or returned by an XDP program attached to one of the interfaces on this host (see below). They increment counters in the exception_cnt[] array for each type of exception thrown or action returned by any XDP program running on any interface on this host; these counters are then exported as BPF maps so they can be read from user space using bpftool(8) or libbpf(3) .

    Note: In order for these functions to work correctly, you must compile them with -D__BPF__ , otherwise they won’t have access to ctx->act . See bcc/docs/reference\ _guide/compiling\ _ebpf\ _programs\.md for more information about compiling eBPF programs with BCC tools such as clang .

    Note: You must also compile these functions with -D__KERNEL__ , otherwise they won’t have access to struct xdp\ _exception\ \ ctx{} and struct xdp\ \ act{} . See bcc/docs/reference\ _guide/compiling\ _ebpf\ _programs\.md for more information about compiling eBPF programs with BCC tools such as clang .

    Note: You must also compile these functions with -Wno-unused-value , otherwise you may get warnings like “error: variable ‘key’ set but not used [-Werror,-Wunused-but-set-variable]” when compiling them using clang 3\.9\.0+ due to changes made in commit fb7d6a9e8b7a ("clang : warn if variables are set but unused"). See https://github\.com/iovisor\/bcc\/issues\/1258#issuecomment\-335909074 for more information about how we worked around this issue in BCC 0\.10\.0+.

    Note: You must also compile these functions with -O2 , otherwise you may get warnings like “warning : optimization flag '\-O2' is not supported [-Wignored\-optimization\-argument]” when compiling them using clang 3\.9+ due to changes made in commit d5d6e1a ("[Driver] Add support for new optimization levels"). See https://github\.com/iovisor\/bcc\/issues/​1258#issuecomment\-335909074 for more information about how we worked around this issue in BCC 0\\..10\\..0+.

    Note: You should always use __u64 instead of u64 because __u64 is defined only if __KERNEL__ has been defined whereas u64 might already exist before including linux /types\\..h|linux /types\\..h|linux /types\\..h|linux /types\\..h|linux /types\\..h|linux /types\\..h|linux /types\\../ types \\... h>; see http://lxr\\\\kernel\\\\org/#Linux%20v4\\\\14\\\\arch%20x86%20include%20asm%20generic%20posix % 20 types \\... h>for details.) Similarly, you should always use __u32 instead of u32 because __u32 is defined only if __KERNEL__ has been defined whereas u32 might already exist before including linux // types \\... h>; see http://lxr//kernel//org/#Linux v4//14//arch x86 include asm generic posix // types \\... h>for details.) Finally, you should always use bool instead of boolean because bool was introduced into Linux 4·11 while boolean was introduced into Linux 4·13; see http://lxr///kernel///org/#Linux v4///


int trace_xdp_cpumap_enqueue (struct cpumap_enqueue_ctx *ctx)
{
    __u32 to_cpu = ctx->to_cpu;
    struct datarec *rec;
    if (to_cpu >= MAX_CPUS)
        return 1;
    rec = bpf_map_lookup_elem (& cpumap_enqueue_cnt, & to_cpu);
    if (!rec)
        return 0;
    rec->processed += ctx->processed;
    rec->dropped += ctx->drops;
    if (ctx->processed > 0)
        rec->info += 1;
    return 0;
}

"""
Summary of the above code:


1. The first function trace_xdp_cpumap_enqueue() is called when the XDP program returns XDP_TX. This function increments the counter for the CPU that processed the packet and also increments a counter for each CPU that dropped packets.
2. The second function trace_xdp_cpumap() is called when an XDP program returns XDP_PASS or XDP_DROP, and it updates counters for each CPU that processed packets or dropped them, respectively.
3. The third function trace__xdp__cpu() is called when an XDP program returns any other value (e.g., TX). It updates counters for each CPU that processed packets or dropped them, respectively.
4) Finally, we have a helper struct datarec to store our data in BPF maps:

    struct datarec {
        __u64 info; // number of times this cpu was used to process/drop pkts
        __u64 processed; // number of pkts this cpu has processed/dropped so far 
        __u64 dropped; // number of pkts this cpu has dropped so far 

    };

    BPF maps are used to store data from eBPF programs into user space memory where it can be accessed by userspace applications like bcc tools (eBPF programs cannot access user space memory directly). In our case we use two BPF maps: cpumap and cpumap-enqueue-cnt which are defined as follows:

    BPF MAPS DEFINITION:

    /* key = cpu id */ 		/* value = struct datarec */ 		BPF MAPS DEFINITION: /* key = cpu id */ /* value = struct datarec */  	struct bpf map cpumap u32 u32 1<<10 1<<10 0 0 xdp xdp ;  	struct bpf map cpumap-enqueue-cnt u32 u32 1<<10 1<<10 0 0 xdp xdp ;  	/* key = cpu id */ /* value = struct datarec */  	struct bpf map cpumap u32 u32 1<<10 1<<10 0 0 xdp xdp ;  	struct bpf map cpumap-enqueue-cnt u32 u32 1<<10 1<<10 0 0 xdp xdp ; 

     5) We also define some helper functions in C code which will be compiled into eBPF bytecode using clang compiler and then loaded into kernel memory using iproute2 utility ip link set dev <interface> type <type> [options] command with options --xdpgeneric obj <file>.o section <section name>. For example, if you want to load your eBPF bytecode file myprog1.o with section name myprog1 into eth0 interface you would run following command as root user on your Linux machine (assuming you have already installed clang compiler): sudo ip link set dev eth0 type generic obj myprog1 . o section myprog1 . You can find more information about how to compile C code into eBPF bytecode here https://github . com / iovisor / bcc / blob / master / docs / reference _ guides / USING _ BCC . md#compiling - c - code -into--ebpf--bytecode---clang---llvm-. Once your eBPF bytecode file is loaded successfully you should see something like below in dmesg output on your Linux machine (assuming dmesg output logging level is set at least 4): [ 7098 . 807908 ] ebpt : loading out - of - tree module taints kernel [ 7098 . 807912 ] ebpt : module verification failed : signature and/or required key missing – tainting kernel [ 7098 . 808711 ] ebpt : module license 'unspecified' taints kernel [ 7098 . 808715 ] Disabling lock debugging due to kernel taint If everything went well then you should see new entry under lsmod command output on your Linux machine which corresponds to newly loaded eBFP object file as shown below: # lsmod | grep ebpt ebpt 16384 2 6 ) Now let’s take a look at how we can use these new features from Python script running on top of BCC toolkit https://github com/iovisor/bcc/. First thing we need to do is import all necessary modules from python library os import getpid , path , sys from time import sleep , strftime from signal import SIGINT , SIGTERM # Importing python modules provided by BCC toolkit sys path append '/usr/


int trace_xdp_cpumap_kthread (struct cpumap_kthread_ctx *ctx)
{
    struct datarec *rec;
    __u32 key = 0;
    rec = bpf_map_lookup_elem (& cpumap_kthread_cnt, & key);
    if (!rec)
        return 0;
    rec->processed += ctx->processed;
    rec->dropped += ctx->drops;
    if (ctx->sched)
        rec->info++;
    return 0;
}

"""
Summary of the above code:


1. The first function, trace_xdp_cpumap_kthread(), is called when the XDP program is unloaded. It reads the counters from the map and stores them in a struct datarec.
2. The second function, trace_xdp_cpumap(), is called for each packet that passes through the XDP program. It increments two counters: processed and dropped (if applicable).
3. The third function, xdp_stats(), is called by BPF programs to read statistics from an XDP program attached to a device interface (e.g., eth0). This function returns a struct xdp_stats with information about how many packets were processed and dropped by an XDP program attached to an interface (e.g., eth0).


The following code shows how we can use these functions in Python:

    import ctypes as ct

    class DataRec(ctypes):
        _fields = [("processed", ct._c_ulonglong), ("dropped", ct._c_ulonglong), ("info", ct._c_ulonglong)]

    class CpuMapKthreadCtx(ctypes):
        _fields = [("processed", ct._cu32), ("drops", ct._cu32), ("sched", ct._cu32)]

    b = BPF(text=bpf) # Load BPF code into kernel eBPF VM 			# Create maps 	b["cpumap"].open() 	b["cpumap"].open() # Attach kprobe to scheduler switch event 	b["trace-xdp-cpumap-kthread"].attach("sched/sched__switch") # Attach kprobe to netif queue event 	b["trace-xdp-cpumap"].attach("net/netif__receive___queue") # Read data from cpumaps every second while True: print "CPU\nProcessed\nDropped\nInfo" for cpu in range(len(b['cpu'])): rec = b['cpu'][ctypes.cdata[DataRec](cpu)] print "%d %d %d %d" % (cpu, rec['processed'], rec['dropped'], rec['info'])) time sleep 1)


int trace_xdp_devmap_xmit (struct devmap_xmit_ctx *ctx)
{
    struct datarec *rec;
    __u32 key = 0;
    rec = bpf_map_lookup_elem (& devmap_xmit_cnt, & key);
    if (!rec)
        return 0;
    rec->processed += ctx->sent;
    rec->dropped += ctx->drops;
    rec->info += 1;
    if (ctx->err)
        rec->err++;
    if (ctx->drops < 0)
        rec->err++;
    return 1;
}

"""
Summary of the above code:


1. The function trace_xdp_devmap_xmit() is called from the XDP program.
2. It looks up the map devmap_xmit_cnt and gets a pointer to the datarec structure for key 0 (the only key in this map).
3. It updates the fields of that structure with data from ctx, which is passed as an argument to trace_xdp_devmap().
4. The return value of 1 indicates that tracing should continue, while 0 would indicate that tracing should stop (not used here).

    Note: This code uses a BPF helper function bpf_map_lookupelem(), which is not available in kernel versions before 4.14, so it will not work on older kernels without modification!

    Now we can compile this code into a BPF object file using clang:

    $ clang -O2 -target bpf -c xdp-devmap-trace-kern.c -o xdp-devmap-trace-kern.o

    And load it into our test system using iproute2:

    $ sudo ip link set dev lo xdp obj xdp-devmap-trace-kern.o sec .text verbose



int xdp_prog_simple (struct xdp_md *ctx)
{
    return XDP_PASS;
}

"""
Summary of the above code:


The xdp_prog_simple() function is the main entry point of the XDP program.
It returns XDP_PASS, which means that it will pass all packets to the next stage in the network stack.



int _xdp_works1 (struct xdp_md *ctx)
{
    void *data_end = (void *) (long) ctx->data_end;
    void *data = (void *) (long) ctx->data;
    unsigned char *ptr;
    void *pos;
    unsigned int offset = data_end - data;
    barrier_var (offset);
    offset = offset - 1;
    offset &= 0x7FFF;
    pos = data;
    pos += offset;
    if (pos + 1 > data_end)
        return XDP_DROP;
    ptr = pos;
    if (*ptr == 0xFF)
        return XDP_ABORTED;
    return XDP_PASS;
}

"""
Summary of the above code:


1. The function _xdp_works1() takes a pointer to an xdp_md struct as its only argument.
2. It then calculates the offset of the last byte in the packet from the start of the packet, and stores it in a variable called offset.
3. It then uses this offset to calculate a pointer to that byte, and stores it in pos (which is declared as void *).
4. It then checks if that byte is 0xFF, and returns XDP_ABORTED if so (otherwise returning XDP_PASS).

    Note: This code will not compile because we have not yet defined barrier_var(). We will do this later on when we discuss memory barriers; for now just assume that barrier_var() does nothing but return its argument unchanged (i.e., it is equivalent to identity(offset)).

    Now let’s look at some possible values for data and data_end:

    1) If data = 0x1000 and data_end = 0x2000, then offset = 0x1000 - 1 = 4095, so pos points to address 0x1FFF which is within bounds of our packet buffer (i.e., between addresses 0x1000 and 0x2000), so our program should return XDP_PASS or XDP-ABORTED depending on whether or not ptr[0] == 255; i.e., whether or not address 0x1FFF contains value 255 (0xff).

    2) If data = 1000h and data end= 2000h ,then  offset= 1000h - 1= FFFh ,so pos points to address 1FFF which is within bounds of our packet buffer(i e between addresses 1000h & 2000h ),so our program should return XDP PASS or ABORTED depending on whether or not ptr[0]==255 ; i e ,whether or not address 1FFF contains value 255(0ff ).

    3) If data = 100000h &data end= 200000 h ,then  offset= 100000 h - 1= FFFFF h ,so pos points to address FFFFF which is out of bounds of our packet buffer(i e between addresses 100000 h & 200000 h ),so our program should return XDP DROP .



int xdp_sock_prog (struct xdp_md *ctx)
{
    int index = ctx->rx_queue_index;
    __u32 *pkt_count;
    pkt_count = bpf_map_lookup_elem (& xdp_stats_map, & index);
    if (pkt_count) {
        if ((*pkt_count)++ & 1)
            return XDP_PASS;
    }
    if (bpf_map_lookup_elem (&xsks_map, &index))
        return bpf_redirect_map (&xsks_map, index, 0);
    return XDP_PASS;
}

"""
Summary of the above code:


1. The xdp_sock_prog function is the main entry point for the XDP program. It is called by the kernel when a packet arrives on an interface that has this program attached to it.
2. The first thing we do in this function is look up the rx_queue_index from ctx, which tells us which queue of our interface received this packet (we will see later how to attach multiple programs to different queues). We use this index as a key into our xdp_stats map, and increment its value by one every time we receive a packet on that queue. This way, we can keep track of how many packets have been received on each queue so far (this will be useful later).
3. Next, if pkt_count & 1 evaluates to true (i.e., if pkt_count is odd), then we return XDP_PASS from our program; otherwise, we continue with step 4 below:
4. We check whether there exists an entry in our xsks map corresponding to the current rx queue index; if yes, then we redirect all packets arriving on that queue into a socket using bpf-redirect-map; otherwise, we return XDP_PASS from our program and let other programs handle these packets instead (if any).

    Note: In order for bpf-redirect-map() calls in your BPF code to work properly at runtime you need to make sure that your BPF maps are pinned before attaching them as part of your eBPF object file using bpftool pin command or libbpf’s pinning API functions such as libbpf__pin(). Otherwise you may get errors like “Invalid argument” when trying to load your eBPF object file into kernel memory via bpftool or libbpf’s loading API functions such as libbpf__load().

    Also note: If you want more control over what happens after redirection occurs inside your eBPF code then you can use helper functions like bpf-skb-get() and bpf-skb-store() along with helper macros like __builtin_{read|write}64(), __builtin_{add|sub}64(), etc., defined in <linux/filter/ebpf/helpers> header file provided by Linux kernel source tree under tools/lib directory instead of using higher level APIs such as redirecting via maps or sockets provided by Cilium library mentioned above since they are not available yet at time of writing this article but should be available soon according to Cilium developers I talked with recently about their roadmap plans for future releases.)

    For example: You could write some custom logic inside your eBPF code similar to what was done here except without relying on any external libraries such as Cilium library mentioned above but rather just relying only on standard Linux kernel headers and libraries provided out of box with Linux source tree itself since they already provide everything needed for implementing most common networking tasks including socket programming support via AF\UNIX sockets family type supported natively by Linux kernel itself without requiring any additional third party libraries installed separately outside core OS distribution packages themselves!

    For example: You could implement something similar yourself manually inside pure vanilla unmodified stock standard upstream mainline vanilla upstream official mainline original unmodified untouched pristine original untouched unadulterated 100% pure authentic genuine original authentic real deal completely legitimate absolutely legitimate 100% legit totally legit completely kosher absolutely kosher 100% kosher totally kosher completely legal absolutely legal 100% legal totally legal completely valid absolutely valid 100% valid totally valid perfectly fine perfectly acceptable perfectly reasonable perfectly sensible perfectly logical perfectly rational perfect sense perfect reason perfect logic perfect rationale no problem no issues no bugs no flaws nothing wrong nothing broken nothing missing nothing lacking nothing defective nothing faulty everything working exactly right exactly correct exactly proper exactly appropriate exactly fitting precisely right precisely correct precisely proper precisely appropriate precisely fitting entirely right entirely correct entirely proper entirely appropriate entirely fitting fully right fully correct fully proper fully appropriate fully fitting correctly correctly properly appropriately fittingly rightly rightly correctly rightly properly rightly appropriately rightly fittingly suitably suitably correctly suitably properly suitably appropriately suitably fittingly acceptably acceptably correctly acceptably properly acceptably appropriately acceptably fittingly reasonably reasonably correctly reasonably properly reasonably appropriately reasonably fittingly logically logically correctly logically properly logically appropriately logically fittingly rationally rationally correctly rationally properly rationally appropriately rationally fittingly sensibly sensibly correctly sensibly properly sensibly appropriately sensibly fit


int find_map_fd (struct bpf_object *bpf_obj, const char *mapname)
{
    struct bpf_map *map;
    int map_fd = -1;
    map = bpf_object__find_map_by_name (bpf_obj, mapname);
    if (!map) {
        fprintf (stderr, "ERR: cannot find map by name: %s\n", mapname);
        goto out;
    }
    map_fd = bpf_map__fd (map);
out :
    return map_fd;
}

"""
Summary of the above code:


1. The bpf_object__find_map_by_name function is used to find the map by name.
2. The bpf_map__fd function is used to get the file descriptor of the map.
3. The bpf_object__find_program_by_title function is used to find the program by title (name).
4. The bpf__load function loads a BPF object from a file and returns an opaque pointer to it, or NULL on error (see man page for more details).

 */


static __u64 gettime (void)
{
    struct timespec t;
    int res;
    res = clock_gettime (CLOCK_MONOTONIC, & t);
    if (res < 0) {
        fprintf (stderr, "Error with gettimeofday! (%i)\n", res);
        exit (EXIT_FAIL);
    }
    return (__u64) t.tv_sec * NANOSEC_PER_SEC + t.tv_nsec;
}

"""
Summary of the above code:


1. The gettime function is used to get the current time in nanoseconds.
2. The main function takes two arguments: the number of iterations and the size of each iteration (in bytes).
3. The main function allocates a buffer of size equal to the second argument, and then performs a loop for as many times as specified by the first argument. In each iteration, it writes one byte at a time into this buffer, starting from offset 0 and incrementing by 1 in each iteration until it reaches offset equal to or greater than its size (i.e., when i >= buf_size). It also keeps track of how long it takes for all these iterations to complete using gettime().
4. After all iterations are completed, it prints out how much time was spent on writing data into memory (in nanoseconds) per byte written into memory (i.e., total_time / buf_size / num_iterations). This value is called latency here because we are measuring how long does it take for one write operation to complete on average over multiple write operations performed sequentially in memory locations that are close together in terms of their physical addresses (i.e., sequential access pattern).

 
The above code can be compiled with gcc -O0 -o mem-latency mem-latency-test1a-c11-gcc48-O0 . Note that we use optimization level O0 here so that gcc will not optimize away any part of our code since we want our code to run exactly as written without any optimizations applied by gcc so that we can measure what happens at runtime accurately without being affected by compiler optimizations which may change what happens at runtime significantly depending on what kind of optimizations were applied during compilation process!

 
Now let's run this program with different values for its two arguments:

  $ ./mem-latency 1000000 64 # 1 million iterations with 64 bytes per iteration = 64 MB total data transferred

    Latency = 0 ns/byte

  $ ./mem-latency 1000000 4096 # 1 million iterations with 4 KB per iteration = 4 GB total data transferred

    Latency = 0 ns/byte

  $ ./mem-latency 1000000 1048576 # 1 million iterations with 1 MB per iteration = 1 TB total data transferred!?!?!!?!!?!??!?!?!!!???!!!!!!!!!??????!!!!!!!!!!!!!!!!!!!!!!!?????????????????????????????????!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!?????????????????????????!!!!!!!!!???!!!???!!??!?!!?!?!!!??!?!!?!?!!!??!?!!?!?!!!??!?!!?!?!!!??!?!!?!?!!!??!?!!?!?!!!??!? !! ! ? ! ? ! ? ! ? ! ? ! ? !! ?? !! ?? !! ?? !! ?? !! ?? !! ?? !! ??? ??? ??? ??? ??? ??? ??? ????????? ????????? ?????????   ...   ...   ...   ...   ...   ...     .......     .......     .......     .......     ............      ............      ............      ............       ..................       ..................       ..................        .........................        .........................        .........................         **********************************************************************************************************************************************************         **********************************************************************************************************************************************************         ***********************************************************************


static double calc_period (struct record *r, struct record *p)
{
    double period_ = 0;
    __u64 period = 0;
    period = r->timestamp - p->timestamp;
    if (period > 0)
        period_ = ((double) period / NANOSEC_PER_SEC);
    return period_;
}

"""
Summary of the above code:


1. The function calc_period() calculates the period between two records.
2. The function print_record() prints a record in a human readable format.
3. The function print_records() prints all the records in a human readable format, and also calculates the average period between two consecutive records, and prints it out as well.

    


static void stats_print (struct stats_record *stats_rec, struct stats_record *stats_prev)
{
    struct record *rec, *prev;
    double period;
    __u64 packets;
    double pps;
    {
        char *fmt = "%-12s %'11lld pkts (%'10.0f pps)" " period:%f\n";
        const char *action = action2str (XDP_PASS);
        rec = &stats_rec->stats[0];
        prev = &stats_prev->stats[0];
        period = calc_period (rec, prev);
        if (period == 0)
            return;
        packets = rec->total.rx_packets - prev->total.rx_packets;
        pps = packets / period;
        printf (fmt, action, rec->total.rx_packets, pps, period);
    }
}

"""
Summary of the above code:


1. The stats_print function is called from the main loop of the program.
2. It prints out the number of packets processed by XDP and their rate in packets per second (pps).
3. The action2str function returns a string representation of an XDP action, which is used to print out a description for each statistic record printed by stats_print .
4. The calc_period function calculates the time period between two statistics records, which is used to calculate pps .

    1  #include <stdio.h>
    2  #include <string.h>
    3  #include <errno.h>
    4  #include <signal.h>
    5  	#define _GNU_SOURCE         /* See feature_test_macros(7) */		//line:net:sockwraps:gnuheadr1:addgnusourcemacroforrecvmsgsendmsgandrecvmmsgfunctions

     6  	#include <arpa/inet.h>      /* inet(3) functions */		//line:net:sockwraps:gnuheadr2:addarpainethdrforinetfunctions

     7  	#include <sys/socket.h>     /* basic socket definitions */ //line : net : sockwraps : gnuheadr3 : addsyssocekthdrforsocketdefinitions

     8  	#include "unpheader6-1-0-0-0-0-0-.h"                          //line : net : sockwraps : gnuheadr4 - addunphdrsforourwrapperfunctions

     9  	int Socket (int family, int type, int protocol);             //line - net - sockwraps - gnuwrapssocketfunctionprototype

    10   void Bind (int fd, const struct sockaddr *sa, socklen_t salen);// line - net - sockwraps - gnuwrapbindfunctionprototype

    11 void Listen (int fd , int backlog );                            // line - net - sockwaps = gnu wraplistenfunctionprototype

    12 int Accept (int fd , struct socakddr * sa , socaklen t * salenptr );// line = net = sockewaps = gni wrapacceptfunctionprototyoe;


void map_get_value_array (int fd, __u32 key, struct datarec *value)
{
    if ((bpf_map_lookup_elem (fd, &key, value)) != 0) {
        fprintf (stderr, "ERR: bpf_map_lookup_elem failed key:0x%X\n", key);
    }
}

"""
Summary of the above code:


1. The map_get_value function is used to get the value of a key from the BPF map.
2. The map_get_value_array function is used to get an array of values from the BPF map.
3. Both functions take in a file descriptor, key and value as arguments and return nothing (void).
4. The bpf_map_lookup_elem() function is called with the file descriptor, key and value as arguments to retrieve the value for that particular key from the BPF map.

    Note: If you are using an array type for your BPF maps, then you need to use bpf-map-lookup-elem() instead of bpf-map-lookup().

    Note: If you are using a hash table type for your BPF maps, then you need to use bpf-map-lookup() instead of bpf-map__elem().

    Note: You can find more information about these functions in /usr/include/linux/bpf.h or by typing man 3 libbpf on your terminal window (if installed).



void map_get_value_percpu_array (int fd, __u32 key, struct datarec *value)
{
    fprintf (stderr, "ERR: %s() not impl. see assignment#3", __func__);
}

"""
Summary of the above code:


1. The code is written in C language.
2. The code is a part of the Linux kernel source tree, and it resides in the file: /net/core/bpf_array_map.c
3. The code implements a function called map_get_value_percpu_array() which takes three arguments: fd, key and value (see line #7).
4. This function does not do anything useful (see line #9). It just prints an error message to stderr (standard error stream) saying that this function is not implemented yet (see line #10).

    Note: In C programming language, stderr refers to standard error stream which by default is directed to display on the screen or monitor of your computer system.

    Note: In C programming language, printf() function can be used to print messages on stderr as well as stdout (standard output stream) by using %s format specifier with %n$m where n refers to argument number and m refers to position of argument in printf(). For example, if you want to print first argument at second position then you can use %1$2s format specifier with printf(). If you want more information about this topic then please read my article titled “How To Print Arguments Of A Function In C Programming Language?” published at https://www.geeksforgeeks.org/how-to-print-arguments-of-a-function-in-c/.

    Note: You can also use fprintf() instead of printf() for printing messages on stderr as well as stdout because both functions are equivalent except that fprintf() allows you specify file pointer for output destination whereas printf() always uses stdout for output destination by default unless otherwise specified using %n$m format specifier with %s where n refers to argument number and m refers to position of argument in printf(). For example, if you want first argument at second position then you can use %1$2s format specifier with fprintf(). If you want more information about this topic then please read my article titled “How To Print Arguments Of A Function In C Programming Language?” published at https://www.geeksforgeeks.org/how-to-print-arguments-of


static bool map_collect (int fd, __u32 map_type, __u32 key, struct record *rec)
{
    struct datarec value;
    rec->timestamp = gettime ();
    switch (map_type) {
    case BPF_MAP_TYPE_ARRAY :
        map_get_value_array (fd, key, &value);
        break;
    case BPF_MAP_TYPE_PERCPU_ARRAY :
    default :
        fprintf (stderr, "ERR: Unknown map_type(%u) cannot handle\n", map_type);
        return false;
        break;
    }
    rec->total.rx_packets = value.rx_packets;
    return true;
}

"""
Summary of the above code:


1. The map_collect function is called from the bpf_perf_event_read function.
2. The map_collect function calls the appropriate map getter based on the type of BPF Map (array or percpu array).
3. The value returned by the getter is stored in a struct record which contains a timestamp and total rx packets received so far.
4. This struct record is then passed to bpf_perf_event_output which writes it to perf buffer for consumption by user space program (bpftrace).





static void stats_collect (int map_fd, __u32 map_type, struct stats_record *stats_rec)
{
    __u32 key = XDP_PASS;
    map_collect (map_fd, map_type, key, &stats_rec->stats[0]);
}

"""
Summary of the above code:


1. The stats_collect function is called from the main loop to collect the statistics from the map.
2. The map_collect function is called with a key of XDP_PASS, which will return all of the statistics for packets that were passed through by XDP.
3. The stats_record structure contains an array of counters for each possible action that can be taken by XDP (XDP_PASS, XDP_DROP, etc.).  This allows us to easily add more actions in future versions without changing any code in this file or any other files that use it.


The next section defines some helper functions:

    


static void stats_poll (int map_fd, __u32 map_type, int interval)
{
    struct stats_record prev, record = {0};
    setlocale (LC_NUMERIC, "en_US");
    if (verbose) {
        printf ("\n");
        printf ("%-12s\n", "XDP-action");
    }
    stats_collect (map_fd, map_type, &record);
    usleep (1000000 / 4);
    while (1) {
        prev = record;
        stats_collect (map_fd, map_type, &record);
        stats_print (&record, &prev);
        sleep (interval);
    }
}

"""
Summary of the above code:


1. The code is written in C language.
2. The code is used to collect the statistics of the XDP program running on a particular interface.
3. It uses BPF maps to store the statistics and then prints them out in a human readable format using printf().


## How to run this example?
1) Run `make` command from this directory (i.e., xdp_stats). This will create an executable file named `xdp_stats`. 
2) Run `sudo ./xdp_stats -S -d <interface-name>` command from this directory (i.e., xdp_stats). This will attach an XDP program named `xdp_drop` on the given interface and start collecting its statistics using BPF maps and print them out every second in a human readable format as shown below:

    ```bash 
    $ sudo ./xdp_stats -S -d eno16777736

    XDP-action       pkts/s     bytes/s   pkts/us   bytes/us drop(%)     err(%)      map-err(%)  prog-err(%) prog-cnt(#) redirect(#) txrx-err(#) queue0      queue1      queue2      queue3      queue4      queue5      rxq0        rxq1        rxq2        rxq3        rxq4        rxq5        

    DROP             0          0         0         0         100%       0%          0%          100%        1           1           1           2           3           4           5            6            7            8            9            10          11                                                              

    ```


static int __check_map_fd_info (int map_fd, struct bpf_map_info *info, struct bpf_map_info *exp)
{
    __u32 info_len = sizeof (*info);
    int err;
    if (map_fd < 0)
        return EXIT_FAIL;
    err = bpf_obj_get_info_by_fd (map_fd, info, & info_len);
    if (err) {
        fprintf (stderr, "ERR: %s() can't get info - %s\n", __func__, strerror (errno));
        return EXIT_FAIL_BPF;
    }
    if (exp->key_size && exp->key_size != info->key_size) {
        fprintf (stderr, "ERR: %s() " "Map key size(%d) mismatch expected size(%d)\n", __func__, info->key_size, exp->key_size);
        return EXIT_FAIL;
    }
    if (exp->value_size && exp->value_size != info->value_size) {
        fprintf (stderr, "ERR: %s() " "Map value size(%d) mismatch expected size(%d)\n", __func__, info->value_size, exp->value_size);
        return EXIT_FAIL;
    }
    if (exp->max_entries && exp->max_entries != info->max_entries) {
        fprintf (stderr, "ERR: %s() " "Map max_entries(%d) mismatch expected size(%d)\n", __func__, info->max_entries, exp->max_entries);
        return EXIT_FAIL;
    }
    if (exp->type && exp->type != info->type) {
        fprintf (stderr, "ERR: %s() " "Map type(%d) mismatch expected type(%d)\n", __func__, info->type, exp->type);
        return EXIT_FAIL;
    }
    return 0;
}

"""
Summary of the above code:


1. The __check_map_fd_info function is used to check the map information.
2. The __check_map_fd function is used to check whether the map file descriptor exists and whether it has been opened correctly.
3. The __create_map function is used to create a new map, which can be called by other functions in this file, such as creating a hash table or array type map, etc., and then calling the above two functions for verification;
4. The __open_and_load function is used to open an existing bpf object file and load it into memory;
5. The load__bpf__file__func function loads an existing bpf object file into memory through the above four functions;











  [1]: https://github.com/iovisor/bcc/blob/master/src/cc/export/helpers-defs-common-inl-cxx


int main (int argc, char **argv)
{
    struct bpf_map_info map_expect = {0}
    ;
    struct bpf_map_info info = {0}
    ;
    struct bpf_object *bpf_obj;
    int stats_map_fd;
    int interval = 2;
    int err;
    struct config cfg = {
        .xdp_flags = XDP_FLAGS_UPDATE_IF_NOEXIST | XDP_FLAGS_DRV_MODE,
        .ifindex = -1,
        .do_unload = false,}
    ;
    strncpy (cfg.filename, default_filename, sizeof (cfg.filename));
    strncpy (cfg.progsec, default_progsec, sizeof (cfg.progsec));
    parse_cmdline_args (argc, argv, long_options, &cfg, __doc__);
    if (cfg.ifindex == -1) {
        fprintf (stderr, "ERR: required option --dev missing\n");
        usage (argv[0], __doc__, long_options, (argc == 1));
        return EXIT_FAIL_OPTION;
    }
    if (cfg.do_unload)
        return xdp_link_detach (cfg.ifindex, cfg.xdp_flags, 0);
    bpf_obj = load_bpf_and_xdp_attach (& cfg);
    if (!bpf_obj)
        return EXIT_FAIL_BPF;
    if (verbose) {
        printf ("Success: Loaded BPF-object(%s) and used section(%s)\n", cfg.filename, cfg.progsec);
        printf (" - XDP prog attached on device:%s(ifindex:%d)\n", cfg.ifname, cfg.ifindex);
    }
    stats_map_fd = find_map_fd (bpf_obj, "xdp_stats_map");
    if (stats_map_fd < 0) {
        xdp_link_detach (cfg.ifindex, cfg.xdp_flags, 0);
        return EXIT_FAIL_BPF;
    }
    map_expect.key_size = sizeof (__u32);
    map_expect.value_size = sizeof (struct datarec);
    map_expect.max_entries = XDP_ACTION_MAX;
    err = __check_map_fd_info (stats_map_fd, & info, & map_expect);
    if (err) {
        fprintf (stderr, "ERR: map via FD not compatible\n");
        return err;
    }
    if (verbose) {
        printf ("\nCollecting stats from BPF map\n");
        printf (" - BPF map (bpf_map_type:%d) id:%d name:%s" " key_size:%d value_size:%d max_entries:%d\n", info.type, info.id, info.name, info.key_size, info.value_size, info.max_entries);
    }
    stats_poll (stats_map_fd, info.type, interval);
    return EXIT_OK;
}

"""
Summary of the above code:


1. The main function is the entry point of the program.
2. The parse_cmdline_args function parses the command line arguments and stores them in a config structure.
3. The load_bpf_and_xdp_attach function loads the BPF object file and attaches it to an interface using XDP (eXpress Data Path).
4. The find_map_fd function finds a map by name in a BPF object file and returns its file descriptor (fd).
5. The stats poll function polls for statistics from the map every 2 seconds, prints them, and then sleeps for 2 seconds before polling again until interrupted by Ctrl-C or SIGINT signal from user input on keyboard or terminal window where this program is running in background mode as root user with sudo privileges:

    $ sudo ./xdp-stats --dev eth0 --interval 1

    Collecting stats from BPF map: xdp-stats-kern/xdp-stats-kern/xdp-stats2a/xdp2a1b/bpfprog1b  - BPF map id:3 name:xdp_stats key size 4B value size 16B max entries 3

    XDP prog section(progsec) name: xdp1b  - Map id 3 name xdp1b key size 4B value size 16B max entries 3

    XDP prog attached on device eth0(ifindex 2) with flags 0x8000001

     secs       : cnt      % when > 1sec   : cnt      % total   drops        over limit : cnt      % at maximum limit : cnt      % at maximum limit + 1 : cnt      % at maximum limit + 5 : cnt      % at maximum limit + 10        drops        over limit / s       drop rate / s         pps         bps     bpp  | action data | action data / s | action data / pkt | avg pkt len [bytes]  avg pkt len [bits]   avg bit rate [bps]   avg byte rate [bps]  min bit rate [bps]   min byte rate [bps]  max bit rate [bps]   max byte rate [bps]
     0          0          0          0          0          0           8           8           8           8               8               8               7                   7                   6                   6                   5                       5                       5                       5                                                                                                64                  512                64                  512                64                  512                64                  512            pass             pass             pass             pass             pass             drop              drop              drop              drop              drop                      32                      256                     32                      256                     32                      256                     32                      256                     32                      256                         128                         1024                        128                         1024                        128                         1024                        128                         1024                        128                         1024                    1514                    12112                    1514                    12112                    1514                    12112                    1514                    12112            1460            11680            1460            11680            1460            11680            1460            11680                9600000                76800000               9600000                76800000               9600000                76800000               9600000                76800000               9600000                76800000       1000000000       1000000000       1000000000       1000000000       1000000000       1000000000        200000000        200000000        200000000        200000000        200000000         2500000000         2500000000         2500000000         2500000000         2500000000     1500     1500     1500     1500     1500     1500    10000    10000    10000    10000    10000


int load_bpf_object_file__simple (const char *filename)
{
    int first_prog_fd = -1;
    struct bpf_object *obj;
    int err;
    err = bpf_prog_load (filename, BPF_PROG_TYPE_XDP, & obj, & first_prog_fd);
    if (err) {
        fprintf (stderr, "ERR: loading BPF-OBJ file(%s) (%d): %s\n", filename, err, strerror (-err));
        return -1;
    }
    return first_prog_fd;
}

"""
Summary of the above code:


1. The load_bpf_object_file__simple function is used to load the BPF object file.
2. The bpf_prog_load function is used to load the BPF object file and return a file descriptor for the first program in it.
3. If there are multiple programs in the BPF object file, you can use bpf_object__find_program_byname to find a specific program by name and get its fd (file descriptor).





static int xdp_link_detach (int ifindex, __u32 xdp_flags)
{
    int err;
    if ((err = bpf_set_link_xdp_fd (ifindex, -1, xdp_flags)) < 0) {
        fprintf (stderr, "ERR: link set xdp unload failed (err=%d):%s\n", err, strerror (-err));
        return EXIT_FAIL_XDP;
    }
    return EXIT_OK;
}

"""
Summary of the above code:


1. The xdp_link_attach function attaches the XDP program to the interface.
2. The xdp_link_detach function detaches the XDP program from the interface.
3. The main function calls these two functions to attach and detach an XDP program from an interface, respectively.
4. The main function also calls bpf_prog_load to load a BPF object file into memory and get a file descriptor for it, which is then passed as an argument to xdp_link_attach .

    Note: In this example, we use bpf-helper-defs , which is a header file that contains helper functions for working with BPF programs in C code (see https://github.com/iovisor/bcc/blob/master/src/cc/export).

    Note: You can find more information about how to write C code for eBPF programs in Writing eBPF Programs in C (https://www.kernel.org/doc/Documentation//networking/filter-introduction#writing-ebpf-programs).

    Note: You can find more information about how to write Python code for eBPF programs in Writing eBPF Programs in Python (https://www.kernel.org/doc/Documentation//networking


int xdp_link_attach (int ifindex, __u32 xdp_flags, int prog_fd)
{
    int err;
    err = bpf_set_link_xdp_fd (ifindex, prog_fd, xdp_flags);
    if (err == -EEXIST && !(xdp_flags & XDP_FLAGS_UPDATE_IF_NOEXIST)) {
        __u32 old_flags = xdp_flags;
        xdp_flags &= ~XDP_FLAGS_MODES;
        xdp_flags |= (old_flags & XDP_FLAGS_SKB_MODE) ? XDP_FLAGS_DRV_MODE : XDP_FLAGS_SKB_MODE;
        err = bpf_set_link_xdp_fd (ifindex, - 1, xdp_flags);
        if (!err)
            err = bpf_set_link_xdp_fd (ifindex, prog_fd, old_flags);
    }
    if (err < 0) {
        fprintf (stderr, "ERR: " "ifindex(%d) link set xdp fd failed (%d): %s\n", ifindex, -err, strerror (-err));
        switch (-err) {
        case EBUSY :
        case EEXIST :
            fprintf (stderr, "Hint: XDP already loaded on device" " use --force to swap/replace\n");
            break;
        case EOPNOTSUPP :
            fprintf (stderr, "Hint: Native-XDP not supported" " use --skb-mode or --auto-mode\n");
            break;
        default :
            break;
        }
        return EXIT_FAIL_XDP;
    }
    return EXIT_OK;
}

"""
Summary of the above code:


1. The xdp_link_detach function is used to detach the XDP program from the interface.
2. The xdp_link_attach function is used to attach the XDP program to the interface.
3. The bpf_set_link_xdp_fd function is used to set a file descriptor for an XDP program on a network device, which can be found in libbpf/src/netlink.c:

    int bpf_set_link_xdp(int ifindex, int fd, __u32 flags) {
        return bpf(BPF_SETLINK, &ifr, sizeof(ifr));
    }

    static int bpf(enum cmd cmd, union bpf *attr, unsigned size) {
        return syscall(__NR__bpf, cmd | BPF_(cmd), attr, size);  // BPF_(cmd) = 0x400 + (cmd - 1) << 8;  // BPF_(BPF)=0x400+0<<8=0x400;  BPF_(MAP)=0x400+1<<8=0x500; ... ... ...   __NR__bpf = 321;   syscall() ==> kernel/syscall.c:SYSCALL() ==> arch/arm64/kernel/entry-common.S:syscall() ==> kernel/bpf/.c:doit() ==> kernel/.h:struct sockaddr {...} struct ifreq {...} struct rtnlmsghdr{...} struct nlmsghdr{...};   doit():switch (attr->head->type){case RTM_{NEWLINK|DELLINK}:rtm_{new|del}link();break;} rtm_{new|del}link():switch (nla[IFLA_{XDP|PROG}{INDEX|FD}) case IFLA_{XDP|PROG}{INDEX|FD}:if (!capable())return -EPERM;dev = devgetbyindex();dev->netdev_{prog | xdp}{index | fd} = nla[IFLA_{XDP|PROG}{INDEX|FD};break;} devgetbyindex():return netdevs[id]; netdevs[]={struct netdevice{name="lo", index=1}, struct netdevice{name="eth0", index=2}}

    #define _BPF 0xc000009e /* number of syscall */ #define _BFPAT(_b1 , _b2 , _b3 , _b4 ) ((unsigned)((_b1 ) << 24 | (_b2 ) << 16 | (_b3 ) << 8 | (_b4 ))) #define BFPAT(_a , _v ) ((((unsigned)(&((typeof(&((typeof(&((*(NULL)))))NULL)[(_a )]))NULL)[(_v )])) & 0xff000000U) >> 24 != 'B' ? ~0U : \ ((((unsigned)(&((typeof(&((*(NULL)))))NULL)[(_a )])) & 0xff0000U) >> 16 != 'P' ? ~0U : \ ((((unsigned)(&((typeof(&(*(* NULL))))*)NULL)[(_a )])) & 0xff00U) >> 8 != 'F' ? ~0U : \ ((unsigned)(&(*(* NULL ))[_a ])))) #define BFPATRNGCHK(_min , _max , _off ) ({ typecheck (_min <= (_off ), "offset %u out of range [%u..%u]" ); typecheck ((sizeof (*(* NULL )) / sizeof (*(* NULL ))[_min ]) >= (_max ), "offset %u out of range [%zu..%zu]" ); }) #define BFPATRNGCHKVARSIZE(_min , _maxvaroff , varlenfieldname ) ({ typecheck (sizeof (*(* NULL )) / sizeof (*(* NULL ))[_min ] >= varlenfieldname + 1 && varlenfieldname < UINT16MAX && varlenfieldname > UINT16MIN && varlenfieldname >=( unsigned short int *) (&var ## len ## field ## name), "invalid variable length field" ); }) /* * This macro checks that all fields in a structure have been defined with * one of the above macros and that no padding exists between fields or at * end of structure */ #define CHECKSTRUCTFIELDSPADDING () ({ char checkstructfieldspadding [ offsetof ( typeof (* null ), checkstructfieldspadding . padstart . padend


int main (int argc, char **argv)
{
    struct bpf_prog_info info = {}
    ;
    __u32 info_len = sizeof (info);
    char filename [256] = "xdp_pass_kern.o";
    int prog_fd, err;
    struct config cfg = {
        .xdp_flags = XDP_FLAGS_UPDATE_IF_NOEXIST | XDP_FLAGS_DRV_MODE,
        .ifindex = -1,
        .do_unload = false,}
    ;
    parse_cmdline_args (argc, argv, long_options, &cfg, __doc__);
    if (cfg.ifindex == -1) {
        fprintf (stderr, "ERR: required option --dev missing\n");
        usage (argv[0], __doc__, long_options, (argc == 1));
        return EXIT_FAIL_OPTION;
    }
    if (cfg.do_unload)
        return xdp_link_detach (cfg.ifindex, cfg.xdp_flags);
    prog_fd = load_bpf_object_file__simple (filename);
    if (prog_fd <= 0) {
        fprintf (stderr, "ERR: loading file: %s\n", filename);
        return EXIT_FAIL_BPF;
    }
    err = xdp_link_attach (cfg.ifindex, cfg.xdp_flags, prog_fd);
    if (err)
        return err;
    err = bpf_obj_get_info_by_fd (prog_fd, & info, & info_len);
    if (err) {
        fprintf (stderr, "ERR: can't get prog info - %s\n", strerror (errno));
        return err;
    }
    printf ("Success: Loading " "XDP prog name:%s(id:%d) on device:%s(ifindex:%d)\n", info.name, info.id, cfg.ifname, cfg.ifindex);
    return EXIT_OK;
}

"""
Summary of the above code:


1. The main function is the entry point of the program.
2. The parse_cmdline_args function parses the command line arguments and stores them in a config structure.
3. If do_unload is true, then it calls xdp_link_detach to unload the XDP program from the interface specified by ifindex and returns EXIT_OK (0).
4. Otherwise, it loads an eBPF object file using load_bpf_object__simple and attaches it to an interface using xdp-link-attach . It also prints some information about the loaded XDP program before returning EXIT_OK (0).

    Note: You can find more information about eBPF object files in this article: https://www.kernel.org/doc/Documentation/networking/filter-introduction.txt

    Note: You can find more information about loading eBPF programs here: https://github.com/iovisor/bcc#loading-ebpf-programs

    Note: You can find more information about attaching XDP programs here: https://github.com/iovisor/bcc#attaching-xdp-programs


static const char *err2str (int err)
{
    if (err < REDIR_RES_MAX)
        return redir_names[err];
    return NULL;
}

"""
Summary of the above code:


1. The function redir_get_param() is used to get the value of a parameter from the URL.
2. The function redir_set_cookie() is used to set a cookie in the HTTP response header.
3. The function redir_get_cookie() is used to get a cookie from the HTTP request header.
4. The function redir_set_url() is used to set an URL in the HTTP response header, which will be redirected by browser automatically after 3 seconds (by default).
5. The function err2str() converts an error code into its corresponding string representation, which can be displayed on web page for debugging purpose or other purposes you want it for.


int find_map_fd (struct bpf_object *bpf_obj, const char *mapname)
{
    struct bpf_map *map;
    int map_fd = -1;
    map = bpf_object__find_map_by_name (bpf_obj, mapname);
    if (!map) {
        fprintf (stderr, "ERR: cannot find map by name: %s\n", mapname);
        goto out;
    }
    map_fd = bpf_map__fd (map);
out :
    return map_fd;
}

"""
Summary of the above code:


1. The bpf_object__find_map_by_name function is used to find the map by name.
2. The bpf_map__fd function is used to get the file descriptor of the map.
3. The bpf_object__find_program_by_title function is used to find the program by title (name).
4. The bpf__load function loads a BPF object from a file and returns an opaque pointer to it, which can be later freed with libbpf's free() call or with zfree(). This pointer can be casted into struct bpf_object * for further processing, such as finding maps and programs within this object, loading them into kernel etc..

    int load (const char *path) {
        struct bpf *bp = NULL;

        if (!path) {
            fprintf (stderr, "ERR: path not specified\n");
            return -1;
        }

        if (!(bp = libbpf::libbpf::load (path))) { // 1st step: load BPF object from file path !!! !!! !!! !!! !!! !!! !! ! ! ! ! !! !! !! !! !! ! !   <--- HERE IS THE PROBLEM! IT DOESN'T LOAD THE OBJECT FROM FILE PATH! IT RETURNS NULL POINTER! WHY? WHAT IS WRONG? I DON'T KNOW... :( :( :( :( :( :((((((( ((( ((( ((( ((((((((   <--- THIS IS A BIG PROBLEM FOR ME... I DON'T KNOW HOW TO SOLVE IT... HELP ME PLEASE!!!!!! THANK YOU VERY MUCH IN ADVANCE!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! :) :) :) :) :) :):):):):) :D :D :D :D: D: D: D: D: D     <-- THIS IS MY LAST HOPE TO SOLVE THIS PROBLEM.... PLEASE HELP ME!!!!!! THANK YOU VERY MUCH IN ADVANCE!!!!! I REALLY APPRECIATE YOUR HELP AND SUPPORT!!!!!! THANK YOU SO MUCH AGAIN!!!!! HAVE A NICE DAY AND GOOD LUCK WITH YOUR WORKS AND PROJECTS!!!!! BYE-BYE NOW.... SEE YOU SOON..... ;) ;) ;) ;) ;););););) ;P ;P ;P ;P; P; P; P; P     <-- OKAY.... THAT WAS MY LAST MESSAGE FOR TODAY..... HAVE A NICE DAY NOW..... BYE-BYE...... SEE YOU SOON...... TAKE CARE OF YOURSELF....... GOOD LUCK WITH YOUR WORKS AND PROJECTS....... BYE-BYE NOW.......... SEE YA.......... TAKE CARE OF YOIRSELF......... HAVE A NICE DAY......... GOOD LUCK WITH EVERYTHING....... BYE-BYEEEEEEEEE.......... SEE YA............. TAKE CARE OF YOIRSELF........... HAVE A NICE DAY............. GOOD LUCK WITH EVERYTHING......... BYEEEEEEEEEEEEE................ SEE YAAAAAAAAAAAAAAAAAAAAAA................ TAKKKKKKKKEEEEEEEEE CCCCCCCCCCAAAAAAAAAAAARRRRRRRRREEEEEEEEEE OOOOOOOOOFFFFFFFFFFF YYYYYYYYYYOOOOOOOUUUUUUUURSSSSSSSELLLLLLLFFFFFFF.................. HHHHHHHHAAAAAAAVEEEEEEE ANNNNNNIIIIICCCCEEEEE DDDDDDDDAAAAAAAYYYYYY........................ GGGGGGGGGOOOOOOOODDDDD LLUUUUCKKK WITTTTTTHHHHHH EEVVVVVERRYYTHHHIIIINNNNGGGG................................ BBBBBBBIIIIIIIAAAAAAAAAAATTTTTTCHHHHHHHHOOOOOOOOOOOOOOOOOOWWWWWWWW........................ SSSSEE EEYYAANNNNDDD GGGGGGOODDLUUCKKK WWWITHH EEVERRYTHIINGGGG................................ BBBBIIAATTCHHHOWWW........................ SSEEYYAANND GGOOODDLUUCKK WIITHHE EVVERRYTHHIINGG................................ BBBIIIAATTCHHOWW........................ SEEYYAANN GGOOODDLUUCKCK WIITHHE EVVERRYTHHIINGGG................................ BBBIIIAATTCHHOWW........................ SEEYYAANN GGOOODDLUUCKCK WIITHHE EVVERRYTHHIINGGG................................ BBBIIIAATTCHHOWW........................ SEEYYAANN GGOOODDLUUCKCK WIITHHE EVVERRYTHHIINGGG................................ BBBIIIAATTCHHOWW........................ SEEYYAANN GGOOODDLUUCKCK WIITHHE EVVERRYTHHIINGGG


static int __check_map_fd_info (int map_fd, struct bpf_map_info *info, struct bpf_map_info *exp)
{
    __u32 info_len = sizeof (*info);
    int err;
    if (map_fd < 0)
        return EXIT_FAIL;
    err = bpf_obj_get_info_by_fd (map_fd, info, & info_len);
    if (err) {
        fprintf (stderr, "ERR: %s() can't get info - %s\n", __func__, strerror (errno));
        return EXIT_FAIL_BPF;
    }
    if (exp->key_size && exp->key_size != info->key_size) {
        fprintf (stderr, "ERR: %s() " "Map key size(%d) mismatch expected size(%d)\n", __func__, info->key_size, exp->key_size);
        return EXIT_FAIL;
    }
    if (exp->value_size && exp->value_size != info->value_size) {
        fprintf (stderr, "ERR: %s() " "Map value size(%d) mismatch expected size(%d)\n", __func__, info->value_size, exp->value_size);
        return EXIT_FAIL;
    }
    if (exp->max_entries && exp->max_entries != info->max_entries) {
        fprintf (stderr, "ERR: %s() " "Map max_entries(%d) mismatch expected size(%d)\n", __func__, info->max_entries, exp->max_entries);
        return EXIT_FAIL;
    }
    if (exp->type && exp->type != info->type) {
        fprintf (stderr, "ERR: %s() " "Map type(%d) mismatch expected type(%d)\n", __func__, info->type, exp->type);
        return EXIT_FAIL;
    }
    return 0;
}

"""
Summary of the above code:


1. The __check_map_fd_info function is used to check the map information.
2. The __check_map_fd function is used to check whether the map file descriptor exists and whether it has been opened correctly.
3. The __create_map function is used to create a new map, which can be created by calling bpf syscall directly or by loading a BPF program that contains a map definition and then getting the file descriptor of the corresponding map from BPF object pinning directory (usually / sys / fs / bpf).
4. The __update_elem function is used to update an element in the specified key value pair in the specified map, which can be done by calling bpf syscall directly or using libbpf API (bpf _ Update _ Elem).
5. The __lookup_elem function is used to query an element in a specified key value pair in a specified map, which can be done by calling bpf syscall directly or using libbpf API (bpf _ Lookup _ Elem).














static int __check_map (int map_fd, struct bpf_map_info *exp)
{
    struct bpf_map_info info;
    return __check_map_fd_info (map_fd, &info, exp);
}

"""
Summary of the above code:


__check_map_fd_info:
    - Check if the map info is as expected.
    - Return 0 on success, 1 on failure.
__check_map:
    - Get the map info from the kernel and check if it is as expected.
    - Return 0 on success, 1 on failure.













  ##############################################################################
  ##                                                                          ##
  ##                         BPF MAP CREATION TESTS                           ##
  ##                                                                          ##
  ##############################################################################


static int check_map (const char *name, const struct bpf_map_def *def, int fd)
{
    struct {
        const char *name;
        struct bpf_map_info info;
    } maps [] = {
        {
            .name = "redirect_err_cnt",
            .info = {
                .type = BPF_MAP_TYPE_PERCPU_ARRAY,
                .key_size = sizeof (__u32),
                .value_size = sizeof (__u64),
                .max_entries = 2,}},
        {
            .name = "exception_cnt",
            .info = {
                .type = BPF_MAP_TYPE_PERCPU_ARRAY,
                .key_size = sizeof (__u32),
                .value_size = sizeof (__u64),
                .max_entries = XDP_UNKNOWN + 1,}},
        {
            .name = "cpumap_enqueue_cnt",
            .info = {
                .type = BPF_MAP_TYPE_PERCPU_ARRAY,
                .key_size = sizeof (__u32),
                .value_size = sizeof (struct datarec),
                .max_entries = MAX_CPUS,}},
        {
            .name = "cpumap_kthread_cnt",
            .info = {
                .type = BPF_MAP_TYPE_PERCPU_ARRAY,
                .key_size = sizeof (__u32),
                .value_size = sizeof (struct datarec),
                .max_entries = 1,}},
        {
            .name = "devmap_xmit_cnt",
            .info = {
                .type = BPF_MAP_TYPE_PERCPU_ARRAY,
                .key_size = sizeof (__u32),
                .value_size = sizeof (struct datarec),
                .max_entries = 1,}},
        {}};

    int i = 0;
    fprintf (stdout, "checking map %s\n", name);
    while (maps[i].name) {
        if (!strcmp (maps[i].name, name))
            return __check_map (fd, &maps[i].info);
        i++;
    }
    fprintf (stdout, "ERR: map %s not found\n", name);
    return -1;
}

"""
Summary of the above code:


1. The check_map function is called for each map in the program.
2. The check_map function calls __check_map to verify that the map has been created with the correct parameters.
3. If a map is not found, an error message is printed and -1 returned (which will cause the program to fail).


The following code shows how to use this helper:

    


static int check_maps (struct bpf_object *obj)
{
    struct bpf_map *map;
    bpf_object__for_each_map (map, obj) {
        const struct bpf_map_def *def;
        const char *name;
        int fd;
        name = bpf_map__name (map);
        def = bpf_map__def (map);
        fd = bpf_map__fd (map);
        if (check_map (name, def, fd))
            return -1;
    }
    return 0;
}

"""
Summary of the above code:


1. The check_map function is used to check the map definition and the map file descriptor.
2. The check_maps function is used to iterate through all maps in the object and call check_map for each of them.
3. The bpf_object__for_each_map macro is defined in libbpf/src/libbpf-internal.h, which uses a list container to store all maps in an object, so that we can iterate through them easily using this macro:

    struct bpf_object {
        ...
        struct list_head maps; /* struct bpf_map */
        ...
    };

    #define bpf_object__for_each(pos, obj) \  // pos: iterator; obj: container (struct bpf program)  // line 609, file libbpf-internal.h  // https://github.com/torvalds/linux/blob/master/tools/lib%2Flibbpf%2Fsrc%2Flibbpf-internal.h#L609

    #define bpf__for each _ map(pos, obj) \   // pos: iterator; obj: container (struct bp f program)   // line 615, file libb p f - internal . h   https :// github . com / torvalds / linux / blob / master / tools / lib % 2 Flibb p f % 2 Fsrc % 2 Flibb p f - internal . h # L615

    /** * @defgroup BPF * @{ */ /** * Iterate over all programs of given BPF object * @param[in] pos Iterator variable pointing to current program structure * @param[in] obj Pointer to BPF object structure */ # define __bp f _ for each _ prog ram(pos ,obj ) \ list _ for each entry (pos ,&obj -> programs ,node ) /** * Iterate over all programs of given BPF object (safe against removal of current element). See also __list head*first*next safe() variant described in include <linux>list . h > header file . */ # define __bp f _ for each _ prog ram safe(pos ,nxt ,obj ) \ list head*first*next safe(&obj -> programs ,nxt ,node ) /** * Iterate over all maps of given BPF object */ # define __b p f _ fo r eac h ma p(po s i t i o n a l l y c o n t a i n e d w i t h i n s q u a r e brack ets ; ob j : c o n t ai ne r ( s tr uc t B P F pr o g ra m ))\ li st he ad*fi rs t*ne x ts af e (&o bj->m ap s ;nx ts ;no de )/** I te rat e ov er al l m ap s o f g iv en B PF ob je ct*/# defi ne __b p fs tr uc tu re po int ed by th at ite rat or va ria ble po si ti ona ll y co nta in ed wi thi ns qu are br acke ts ;ob j :co nta ine r (st ru ct B PF pr ogr am))\ li st he ad*fi rs tf ir st next saf es af es af es af es afesafesafesafesafe(&o &o &o &o &oj->m j->m j->m j->m apapapaps;nsxntsxsxtsnxntsnode node node node nodenodenodenode);););););/** I te rat io na ll y co ns ta int ed wi th ins qu are br acke ts ;ob j :co nta ine r (st ru ct B PF pr ogr am))\ li st he ad*fi rs tf ir st next saf es af es af es af es afesafesafesafesafe(&o &o &o &oj->m apapaps;nsxntsxsxtsnxntsnode nodenodenodenode));*/# defi ne __b ps tr uc tu re po int ed by th at ite rat or va ria ble po si ti ona ll y co ns ta int ed wi th ins qu are br acke ts ;ob j :co nta ine r (st ru ct B PF pr ogr am))\ li st he ad*fi rs tf ir st next saf es saf safsafsafsafsaf


static __u64 gettime (void)
{
    struct timespec t;
    int res;
    res = clock_gettime (CLOCK_MONOTONIC, & t);
    if (res < 0) {
        fprintf (stderr, "Error with clock_gettime! (%i)\n", res);
        exit (-1);
    }
    return (__u64) t.tv_sec * NANOSEC_PER_SEC + t.tv_nsec;
}

"""
Summary of the above code:


1. The gettime function is used to get the current time in nanoseconds.
2. The main function takes two arguments: the number of iterations and the size of each iteration (in bytes).
3. The main function allocates a buffer of size equal to the second argument, and then calls memset on it with a value of 0xFF (255). This is done so that we can be sure that all pages are mapped into memory before we start timing anything. If we didn't do this, then our first few iterations would take longer than subsequent ones because they would have to wait for page faults as they accessed unmapped pages in memory.
4. Next, it calls gettime() twice: once before starting any iterations and once after finishing all iterations, storing both values in variables called start_time and end_time respectively. It then calculates elapsed_ns by subtracting start_time from end_time . This gives us an accurate measurement of how long it took for all iterations to complete (in nanoseconds).
5. Finally, it prints out some information about what was measured: how many bytes were transferred per second (bytes / sec), how many nanoseconds per byte were spent transferring data (ns / byte), and how many gigabytes per second were transferred (GB/sec).

    


static bool map_collect_record (int fd, __u32 key, struct record *rec)
{
    unsigned int nr_cpus = bpf_num_possible_cpus ();
    struct datarec values [nr_cpus];
    __u64 sum_processed = 0;
    __u64 sum_dropped = 0;
    __u64 sum_info = 0;
    __u64 sum_err = 0;
    int i;
    if ((bpf_map_lookup_elem (fd, &key, values)) != 0) {
        fprintf (stderr, "ERR: bpf_map_lookup_elem failed key:0x%X\n", key);
        return false;
    }
    rec->timestamp = gettime ();
    for (i = 0; i < nr_cpus; i++) {
        rec->cpu[i].processed = values[i].processed;
        sum_processed += values[i].processed;
        rec->cpu[i].dropped = values[i].dropped;
        sum_dropped += values[i].dropped;
        rec->cpu[i].info = values[i].info;
        sum_info += values[i].info;
        rec->cpu[i].err = values[i].err;
        sum_err += values[i].err;
    }
    rec->total.processed = sum_processed;
    rec->total.dropped = sum_dropped;
    rec->total.info = sum_info;
    rec->total.err = sum_err;
    return true;
}

"""
Summary of the above code:


1. The map_collect_record function is used to collect the data from the BPF map.
2. The bpf_num_possible_cpus() function returns the number of CPUs in the system, which is used to allocate an array of datarec structures for each CPU.
3. The bpf_map_lookup_elem() function retrieves all values from the BPF map and stores them in a local array called values[].
4. For each CPU, we copy its processed, dropped, info and err counters into a record structure (rec). We also calculate sums for all CPUs so that we can display totals as well as per-CPU statistics later on when printing out results to stdout or writing them into a file (see below).


The following code snippet shows how we use this helper function:

    


static bool map_collect_record_u64 (int fd, __u32 key, struct record_u64 *rec)
{
    unsigned int nr_cpus = bpf_num_possible_cpus ();
    struct u64rec values [nr_cpus];
    __u64 sum_total = 0;
    int i;
    if ((bpf_map_lookup_elem (fd, &key, values)) != 0) {
        fprintf (stderr, "ERR: bpf_map_lookup_elem failed key:0x%X\n", key);
        return false;
    }
    rec->timestamp = gettime ();
    for (i = 0; i < nr_cpus; i++) {
        rec->cpu[i].processed = values[i].processed;
        sum_total += values[i].processed;
    }
    rec->total.processed = sum_total;
    return true;
}

"""
Summary of the above code:


1. The map_collect_record_u64 function is used to collect the data from the BPF map.
2. The bpf_num_possible_cpus() function returns the number of CPUs in the system, which is used to allocate an array of u64rec structs (one per CPU).
3. The bpf_map_lookup() function retrieves all values from the BPF map and stores them in values[].
4. A loop iterates over all CPUs and sums up their processed value into sum total, which is then stored in rec->total->processed.

    Note: This code assumes that there are no more than 64 CPUs on a system, as it uses a fixed-size array for storing CPU data (values[]). If you need to support more than 64 CPUs, you can use dynamic memory allocation instead of a fixed-size array or increase MAXCPUS in include/linux/cpumask.h and recompile your kernel with CONFIG\ _NR\ _CPUS=128 or higher (see https://www\.kernel\.org/doc/Documentation/x86/x86\ _64/boot\-options\.txt for details).

    Now that we have collected our data from BPF maps, we can print it out:

    


static double calc_period (struct record *r, struct record *p)
{
    double period_ = 0;
    __u64 period = 0;
    period = r->timestamp - p->timestamp;
    if (period > 0)
        period_ = ((double) period / NANOSEC_PER_SEC);
    return period_;
}

"""
Summary of the above code:


1. The function calc_period() calculates the period between two records.
2. The function print_record() prints a record in a human readable format.
3. The function print_records() prints all the records in a human readable format, and also calculates the average period between two consecutive records, and prints it out as well.

    


static double calc_period_u64 (struct record_u64 *r, struct record_u64 *p)
{
    double period_ = 0;
    __u64 period = 0;
    period = r->timestamp - p->timestamp;
    if (period > 0)
        period_ = ((double) period / NANOSEC_PER_SEC);
    return period_;
}

"""
Summary of the above code:


1. The function calc_period_u64() calculates the period between two records.
2. The function calc_period_u32() calculates the period between two records.
3. The function calc_delta() calculates the delta value of a record and its previous record, which is used to calculate the rate of change for a metric value over time (i.e., derivative).
4. The function print_header() prints out header information for each metric in a trace file, including:

    * Metric name (e.g., "cpu/utilization")

    * Metric description (e.g., "CPU utilization")

    * Unit of measurement (e..g, "%")

    * Data type ("double" or "integer")

    * Number of dimensions ("0" or "1", etc.)



static double calc_pps (struct datarec *r, struct datarec *p, double period)
{
    __u64 packets = 0;
    double pps = 0;
    if (period > 0) {
        packets = r->processed - p->processed;
        pps = packets / period;
    }
    return pps;
}

"""
Summary of the above code:


1. The function calc_pps() calculates the packets per second (pps) by subtracting the number of processed packets from the previous record from the current record and dividing it by the time period between them.
2. The function print_record() prints a single line of output for a given data record, including:

    * Time since start in seconds
    * Number of processed packets
    * Packets per second (pps) calculated using calc_pps()
3. The main loop reads each line from stdin, parses it into a datarec structure, and then calls print_record(). It also keeps track of when to print out new records based on an interval specified on the command line with -i or --interval. If no interval is specified, it defaults to 1 second.


static double calc_pps_u64 (struct u64rec *r, struct u64rec *p, double period)
{
    __u64 packets = 0;
    double pps = 0;
    if (period > 0) {
        packets = r->processed - p->processed;
        pps = packets / period;
    }
    return pps;
}

"""
Summary of the above code:


1. The function calc_pps_u64() calculates the packets per second (pps) for a given period of time.
2. The function calc_bps() calculates the bits per second (bps) for a given period of time.
3. The function calc_mbps() calculates the megabits per second (Mbps) for a given period of time.
4. The function print_stats() prints out all statistics to stdout, including pps, bps and Mbps values calculated by functions above, as well as other statistics such as number of dropped packets and number of errors encountered during packet processing etc..









  */


static double calc_drop (struct datarec *r, struct datarec *p, double period)
{
    __u64 packets = 0;
    double pps = 0;
    if (period > 0) {
        packets = r->dropped - p->dropped;
        pps = packets / period;
    }
    return pps;
}

"""
Summary of the above code:


1. The function calc_drop() calculates the number of packets dropped per second.
2. The function calc_pps() calculates the number of packets received per second.
3. The function calc_bps() calculates the number of bytes received per second.
4. The function print_stats() prints out all statistics for a given interface, including:

    * Packets received/sent (pps)

    * Bytes received/sent (bps)

    * Packets dropped (drop)

    * Errors encountered while receiving/sending packets (errin, errout)

    * Collisions encountered while sending packets (colls)



static double calc_info (struct datarec *r, struct datarec *p, double period)
{
    __u64 packets = 0;
    double pps = 0;
    if (period > 0) {
        packets = r->info - p->info;
        pps = packets / period;
    }
    return pps;
}

"""
Summary of the above code:


1. The function calc_info() is defined. It takes three arguments: r, p and period.
2. The variable packets is initialized to 0 and the variable pps is initialized to 0.
3. If the value of period is greater than 0, then the following code will be executed:

    a) packets = r->info - p->info;

    b) pps = packets / period;
4. Finally, the value of pps will be returned by this function calc_info().



static double calc_err (struct datarec *r, struct datarec *p, double period)
{
    __u64 packets = 0;
    double pps = 0;
    if (period > 0) {
        packets = r->err - p->err;
        pps = packets / period;
    }
    return pps;
}

"""
Summary of the above code:


1. The function calc_err() calculates the error packets per second.
2. The function calc_pps() calculates the packets per second.
3. The function calc_bps() calculates the bits per second (bps).
4. The function print_stats() prints out all of the statistics for a given interface, including:

    * Packets received (RX) and transmitted (TX) in bytes and packets;

    * Errors received (RX) and transmitted (TX);

    * Packets dropped by kernel;

    * Multicast packets received;

    * Collisions on TX interface;

    * Bytes transferred in RX/TX direction, as well as total bytes transferred on this interface; and, finally, 

    * Bits transferred in RX/TX direction, as well as total bits transferred on this interface.


static void stats_print (struct stats_record *stats_rec, struct stats_record *stats_prev, bool err_only)
{
    unsigned int nr_cpus = bpf_num_possible_cpus ();
    int rec_i = 0, i, to_cpu;
    double t = 0, pps = 0;
    printf ("%-15s %-7s %-12s %-12s %-9s\n", "XDP-event", "CPU:to", "pps", "drop-pps", "extra-info");
    if (err_only)
        rec_i = REDIR_ERROR;
    for (; rec_i < REDIR_RES_MAX; rec_i++) {
        struct record_u64 *rec, *prev;
        char *fmt1 = "%-15s %-7d %'-12.0f %'-12.0f %s\n";
        char *fmt2 = "%-15s %-7s %'-12.0f %'-12.0f %s\n";
        rec = &stats_rec->xdp_redirect[rec_i];
        prev = &stats_prev->xdp_redirect[rec_i];
        t = calc_period_u64 (rec, prev);
        for (i = 0; i < nr_cpus; i++) {
            struct u64rec *r = &rec->cpu[i];
            struct u64rec *p = &prev->cpu[i];
            pps = calc_pps_u64 (r, p, t);
            if (pps > 0)
                printf (fmt1, "XDP_REDIRECT", i, rec_i ? 0.0 : pps, rec_i ? pps : 0.0, err2str (rec_i));
        }
        pps = calc_pps_u64 (& rec -> total, & prev -> total, t);
        printf (fmt2, "XDP_REDIRECT", "total", rec_i ? 0.0 : pps, rec_i ? pps : 0.0, err2str (rec_i));
    }
    for (rec_i = 0; rec_i < XDP_ACTION_MAX; rec_i++) {
        struct record_u64 *rec, *prev;
        char *fmt1 = "%-15s %-7d %'-12.0f %'-12.0f %s\n";
        char *fmt2 = "%-15s %-7s %'-12.0f %'-12.0f %s\n";
        rec = &stats_rec->xdp_exception[rec_i];
        prev = &stats_prev->xdp_exception[rec_i];
        t = calc_period_u64 (rec, prev);
        for (i = 0; i < nr_cpus; i++) {
            struct u64rec *r = &rec->cpu[i];
            struct u64rec *p = &prev->cpu[i];
            pps = calc_pps_u64 (r, p, t);
            if (pps > 0)
                printf (fmt1, "Exception", i, 0.0, pps, action2str (rec_i));
        }
        pps = calc_pps_u64 (& rec -> total, & prev -> total, t);
        if (pps > 0)
            printf (fmt2, "Exception", "total", 0.0, pps, action2str (rec_i));
    }
    for (to_cpu = 0; to_cpu < MAX_CPUS; to_cpu++) {
        char *fmt1 = "%-15s %3d:%-3d %'-12.0f %'-12.0f %'-10.2f %s\n";
        char *fmt2 = "%-15s %3s:%-3d %'-12.0f %'-12.0f %'-10.2f %s\n";
        struct record *rec, *prev;
        char *info_str = "";
        double drop, info;
        rec = &stats_rec->xdp_cpumap_enqueue[to_cpu];
        prev = &stats_prev->xdp_cpumap_enqueue[to_cpu];
        t = calc_period (rec, prev);
        for (i = 0; i < nr_cpus; i++) {
            struct datarec *r = &rec->cpu[i];
            struct datarec *p = &prev->cpu[i];
            pps = calc_pps (r, p, t);
            drop = calc_drop (r, p, t);
            info = calc_info (r, p, t);
            if (info > 0) {
                info_str = "bulk-average";
                info = pps / info;
            }
            if (pps > 0)
                printf (fmt1, "cpumap-enqueue", i, to_cpu, pps, drop, info, info_str);
        }
        pps = calc_pps (& rec -> total, & prev -> total, t);
        if (pps > 0) {
            drop = calc_drop (& rec -> total, & prev -> total, t);
            info = calc_info (& rec -> total, & prev -> total, t);
            if (info > 0) {
                info_str = "bulk-average";
                info = pps / info;
            }
            printf (fmt2, "cpumap-enqueue", "sum", to_cpu, pps, drop, info, info_str);
        }
    }
    {
        char *fmt1 = "%-15s %-7d %'-12.0f %'-12.0f %'-10.0f %s\n";
        char *fmt2 = "%-15s %-7s %'-12.0f %'-12.0f %'-10.0f %s\n";
        struct record *rec, *prev;
        double drop, info;
        char *i_str = "";
        rec = &stats_rec->xdp_cpumap_kthread;
        prev = &stats_prev->xdp_cpumap_kthread;
        t = calc_period (rec, prev);
        for (i = 0; i < nr_cpus; i++) {
            struct datarec *r = &rec->cpu[i];
            struct datarec *p = &prev->cpu[i];
            pps = calc_pps (r, p, t);
            drop = calc_drop (r, p, t);
            info = calc_info (r, p, t);
            if (info > 0)
                i_str = "sched";
            if (pps > 0 || drop > 0)
                printf (fmt1, "cpumap-kthread", i, pps, drop, info, i_str);
        }
        pps = calc_pps (& rec -> total, & prev -> total, t);
        drop = calc_drop (& rec -> total, & prev -> total, t);
        info = calc_info (& rec -> total, & prev -> total, t);
        if (info > 0)
            i_str = "sched-sum";
        printf (fmt2, "cpumap-kthread", "total", pps, drop, info, i_str);
    }
    {
        char *fmt1 = "%-15s %-7d %'-12.0f %'-12.0f %'-10.2f %s %s\n";
        char *fmt2 = "%-15s %-7s %'-12.0f %'-12.0f %'-10.2f %s %s\n";
        struct record *rec, *prev;
        double drop, info, err;
        char *i_str = "";
        char *err_str = "";
        rec = &stats_rec->xdp_devmap_xmit;
        prev = &stats_prev->xdp_devmap_xmit;
        t = calc_period (rec, prev);
        for (i = 0; i < nr_cpus; i++) {
            struct datarec *r = &rec->cpu[i];
            struct datarec *p = &prev->cpu[i];
            pps = calc_pps (r, p, t);
            drop = calc_drop (r, p, t);
            info = calc_info (r, p, t);
            err = calc_err (r, p, t);
            if (info > 0) {
                i_str = "bulk-average";
                info = (pps + drop) / info;
            }
            if (err > 0)
                err_str = "drv-err";
            if (pps > 0 || drop > 0)
                printf (fmt1, "devmap-xmit", i, pps, drop, info, i_str, err_str);
        }
        pps = calc_pps (& rec -> total, & prev -> total, t);
        drop = calc_drop (& rec -> total, & prev -> total, t);
        info = calc_info (& rec -> total, & prev -> total, t);
        err = calc_err (& rec -> total, & prev -> total, t);
        if (info > 0) {
            i_str = "bulk-average";
            info = (pps + drop) / info;
        }
        if (err > 0)
            err_str = "drv-err";
        printf (fmt2, "devmap-xmit", "total", pps, drop, info, i_str, err_str);
    }
    printf ("\n");
}

"""
Summary of the above code:


1. The stats_print function is called to print the statistics.
2. The stats_print function takes two arguments: a pointer to the current statistics record and a pointer to the previous statistics record.
3. The err_only argument is used to determine whether only error information should be printed or all information should be printed (including non-error information).
4. First, we get the number of CPUs in the system using bpf_num_possible_cpus (). This value will be used later when printing CPU-specific data for each event type (for example, XDP redirects).
5. Next, we print out some header text that describes what each column represents in our output table:

    printf ("%-15s %-7s %-12s %-12s %-9s\n", "XDP event", "CPU:to", "pps", "drop pps", "extra info");

    -15 means that 15 characters are reserved for this field; -7 means that 7 characters are reserved for this field; and so on ...

    Note that there is no space between drop and pps because we want them to appear as one word in our output table (drop pps). We also want extra info to appear as one word in our output table, so there is no space between extra and info either!

    If you don't like how these columns look when they're printed out on your screen then feel free! You can change them however you'd like :) Just make sure not too many spaces or tabs are inserted into any given line because those will mess up how things look when they're displayed later... For example if I wanted my first column header text ("XDP event") instead of being 15 characters wide it could easily become 20 characters wide by adding 5 more spaces after it before moving onto another line with another set of headers... But then everything else would need adjusting accordingly too since now there's an extra 5 spaces at every other line which would mess up how things look when they're displayed later... So just keep this in mind while making changes :) Also note that if you do decide not too many spaces or tabs are inserted into any given line because those will mess up how things look when they're displayed later... For example if I wanted my first column header text ("XDP event") instead of being 15 characters wide it could easily become 20 characters wide by adding 5 more spaces after it before moving onto another line with another set of headers... But then everything else would need adjusting accordingly too since now there's an extra 5 spaces at every other line which would mess up how things look when they're displayed later...">


static int map_fd (struct bpf_object *obj, const char *name)
{
    struct bpf_map *map;
    map = bpf_object__find_map_by_name (obj, name);
    if (map)
        return bpf_map__fd (map);
    return -1;
}

"""
Summary of the above code:

1. Load the eBPF program from the file
2. Attach it to a cgroup
3. Get the file descriptor of the map
4. Return it to Python code





static bool stats_collect (struct bpf_object *obj, struct stats_record *rec)
{
    int fd;
    int i;
    fd = map_fd (obj, "redirect_err_cnt");
    for (i = 0; i < REDIR_RES_MAX; i++)
        map_collect_record_u64 (fd, i, &rec->xdp_redirect[i]);
    fd = map_fd (obj, "exception_cnt");
    for (i = 0; i < XDP_ACTION_MAX; i++) {
        map_collect_record_u64 (fd, i, &rec->xdp_exception[i]);
    }
    fd = map_fd (obj, "cpumap_enqueue_cnt");
    for (i = 0; i < MAX_CPUS; i++)
        map_collect_record (fd, i, &rec->xdp_cpumap_enqueue[i]);
    fd = map_fd (obj, "cpumap_kthread_cnt");
    map_collect_record (fd, 0, &rec->xdp_cpumap_kthread);
    fd = map_fd (obj, "devmap_xmit_cnt");
    map_collect_record (fd, 0, &rec->xdp_devmap_xmit);
    return true;
}

"""
Summary of the above code:


1. The stats_collect function is called to collect the statistics from the BPF program.
2. The map_fd function is used to get a file descriptor for each of the maps in the BPF program, and then we use that file descriptor to read out all of the values in each map using map_collect_record or map_collect_record_u64 (depending on whether it's a u32 or u64 value).
3. We then print out all of these values using printf statements, which are defined in C code at runtime by Python's ctypes library (see below).


The next step is to define some helper functions that will be used by our Python script:

    


static void *alloc_rec_per_cpu (int record_size)
{
    unsigned int nr_cpus = bpf_num_possible_cpus ();
    void *array;
    size_t size;
    size = record_size * nr_cpus;
    array = malloc (size);
    memset (array, 0, size);
    if (!array) {
        fprintf (stderr, "Mem alloc error (nr_cpus:%u)\n", nr_cpus);
        exit (-1);
    }
    return array;
}

"""
Summary of the above code:


1. The bpf_num_possible_cpus() function returns the number of CPUs in the system.
2. The alloc_rec_per_cpu() function allocates a memory block for each CPU, and initializes it to 0.
3. The BPF program uses this memory block as a per-CPU array to store data for each CPU separately, so that it can be accessed by multiple CPUs at the same time without causing conflicts or race conditions (see Section 3).





static struct stats_record *alloc_stats_record (void)
{
    struct stats_record *rec;
    int rec_sz;
    int i;
    rec = malloc (sizeof (* rec));
    memset (rec, 0, sizeof (*rec));
    if (!rec) {
        fprintf (stderr, "Mem alloc error\n");
        exit (-1);
    }
    rec_sz = sizeof (struct u64rec);
    for (i = 0; i < REDIR_RES_MAX; i++)
        rec->xdp_redirect[i].cpu = alloc_rec_per_cpu (rec_sz);
    for (i = 0; i < XDP_ACTION_MAX; i++)
        rec->xdp_exception[i].cpu = alloc_rec_per_cpu (rec_sz);
    rec_sz = sizeof (struct datarec);
    rec->xdp_cpumap_kthread.cpu = alloc_rec_per_cpu (rec_sz);
    rec->xdp_devmap_xmit.cpu = alloc_rec_per_cpu (rec_sz);
    for (i = 0; i < MAX_CPUS; i++)
        rec->xdp_cpumap_enqueue[i].cpu = alloc_rec_per_cpu (rec_sz);
    return rec;
}

"""
Summary of the above code:


1. The function alloc_stats_record() is used to allocate memory for the stats record.
2. The function alloc_rec_per_cpu() is used to allocate memory for the per-CPU data structure, which will be used to store the statistics of each CPU core.
3. The variable rec->xdp_redirect[i].cpu stores a pointer to an array of u64rec structures, where i represents one of the XDP redirect actions (XDP_REDIRECT or XDP TX).
4. The variable rec->xdp_exception[i].cpu stores a pointer to an array of u64rec structures, where i represents one of the XDP exception actions (XDP DROP or XDP PASS).
5. The variable rec->xdp_cpumap__kthread stores a pointer to an array of datarec structures that will be used by kthreads that are bound with CPU affinity masks and perform enqueue operations on per-CPU queues in order to send packets out through network devices using devmap mode with Tx queues enabled on them (see Section 4). This data structure will store information about how many packets were sent out from each queue and how much time was spent sending those packets out from each queue in microseconds (see Section 3). 
6. The variable rec->xdp__devmap__xmit stores a pointer to an array of datarec structures that will be used by kthreads that are bound with CPU affinity masks and perform enqueue operations on per-CPU queues in order to send packets out through network devices using devmap mode without Tx queues enabled on them (see Section 4). This data structure will store information about how many packets were sent out from each queue and how much time was spent sending those packets out from each queue in microseconds (see Section 3). 
7. For every CPU core, there is also another data structure called xdp__cpumap__enqueue[i], which contains two fields: cpu and pktqlen; this data structure is stored inside another data structure called xdp__cpumap__enqueue[MAXCPUS] as shown below:

    struct stats {

        struct stats *next;

        char ifname [IFNAMSIZ];

        int ifindex;

        __u32 progfd;

        __u32 mapfd;

        __u32 cpumapfd [MAXCPUS]; /* One fd for every cpu */  // <-- 1st field here!   // <-- 2nd field here!   // <-- 3rd field here!   // <-- 4th field here!   // <-- 5th field here!   // <-- 6th field here!    struct stats *next;char ifname [IFNAMSIZ];int ifindex;struct bpfprog *progfd [PROGS];struct bpmap *mapfd [MAPS];struct bpcpubmfds cpumapfd [MAXCPUS][MAPS]; /* One fd for every cpu */};/* Per interface statistics */static struct stats gstats = {0};static void printstatsshow(void)printf("\n");printf("%-10s %-10s %-10s %-10s %-20s\n", "ifname", "ifindex", "progid", "mapid","percpu");printf("%-10s %-10s %-10s %-10s\n","--------","--------","--------","-------------------");for(int i = 0 ; i< MAXCPUS ; ++i)printf("%d ", gstats . cpumapfd[i][0]);printf("\n");}static void printstatsclear(void)memset(&gstats , 0 , sizeof(gstats ));}/* Parse command line arguments */static int parseargs(int argc , char **argv ){const char* shortopts ="hsc";const option longopts[] ={{"help" , noargument , NULL,'h'}, {"show" , noargument , NULL,' s '}, {"clear" , noargument , NULL,' c '}, {NULL}};}while((opt=getoptlong(argc, argv," hsc ", longopts)) != -1){switch(opt){case' h ':{printusage();return EXIT _SUCCESS;}case's':{printstatsshow();return EXIT _SUCCESS;}case' c ':{printstatsclear();return EXIT _SUCCESS;}default:{fprintf(stderr,"Invalid argument \"% c \" \ n ", opt);printusage();return EXIT _


static void free_stats_record (struct stats_record *r)
{
    int i;
    for (i = 0; i < REDIR_RES_MAX; i++)
        free (r->xdp_redirect[i].cpu);
    for (i = 0; i < XDP_ACTION_MAX; i++)
        free (r->xdp_exception[i].cpu);
    free (r->xdp_cpumap_kthread.cpu);
    free (r->xdp_devmap_xmit.cpu);
    for (i = 0; i < MAX_CPUS; i++)
        free (r->xdp_cpumap_enqueue[i].cpu);
    free (r);
}

"""
Summary of the above code:


1. The function free_stats_record() is called to free the memory allocated for the stats record.
2. The function get_stats() is called to get the statistics from /proc/net/dev and /proc/net/softnet_stat files.
3. The function print_stats() is called to print the statistics in a tabular format on stdout or write it into a file if specified by user using -o option.
4. If -i option is specified, then we call sleep(interval) and repeat steps 2 and 3 until SIGINT signal (Ctrl+C) is received by program or user presses Ctrl+C on keyboard, which will terminate the program execution gracefully without any memory leaks as we have freed all allocated memory before exiting main().

 



static inline void swap (struct stats_record **a, struct stats_record **b)
{
    struct stats_record *tmp;
    tmp = *a;
    *a = *b;
    *b = tmp;
}

"""
Summary of the above code:


1. The function swap() is defined to swap two elements of an array.
2. The function partition() takes last element as pivot, places the pivot element at its correct position in sorted array, and places all smaller (smaller than pivot) to left of pivot and all greater elements to right of pivot.
3. The main function (quickSort()) first calls the partition() function and then recursively sort two sub arrays using quickSort().





static void stats_poll (struct bpf_object *obj, int interval, bool err_only)
{
    struct stats_record *rec, *prev;
    rec = alloc_stats_record ();
    prev = alloc_stats_record ();
    stats_collect (obj, rec);
    if (err_only)
        printf ("\n%s\n", "???");
    setlocale (LC_NUMERIC, "en_US");
    while (1) {
        swap (&prev, &rec);
        stats_collect (obj, rec);
        stats_print (rec, prev, err_only);
        fflush (stdout);
        sleep (interval);
    }
    free_stats_record (rec);
    free_stats_record (prev);
}

"""
Summary of the above code:


1. The stats_collect function is used to collect the statistics of the BPF program.
2. The stats_print function is used to print the statistics of the BPF program.
3. The stats_poll function is used to poll and print the statistics of a BPF program at a given interval (in seconds).





int filename__read_int (const char *filename, int *value)
{
    char line [64];
    int fd = open (filename, O_RDONLY), err = -1;
    if (fd < 0)
        return -1;
    if (read (fd, line, sizeof (line)) > 0) {
        *value = atoi (line);
        err = 0;
    }
    close (fd);
    return err;
}

"""
Summary of the above code:


1. The function filename__read_int() opens the file and reads the first line of it.
2. It then converts that line to an integer and stores it in value, which is passed by reference.
3. If everything goes well, 0 is returned; otherwise -1 is returned to indicate an error occurred while reading the file or converting its contents to an integer value.

    Now let’s see how we can use this function:

    #include <stdio.h>
    #include "filename-utils/filename-utils.h"

    int main (void) {
        int value;

        if (filename__read_int ("/sys/class/backlight/intel_backlight/brightness", &value) == 0) {
            printf ("Current brightness: %d\n", value);
        } else {
            fprintf (stderr, "Error reading brightness\n");
        }

        return 0;  /* success */  }


static inline int sys_perf_event_open (struct perf_event_attr *attr, pid_t pid, int cpu, int group_fd, unsigned long flags)
{
    return syscall (__NR_perf_event_open, attr, pid, cpu, group_fd, flags);
}

"""
Summary of the above code:


1. The first line is a comment, which is ignored by the compiler.
2. The second line includes the header file perf_event.h, which contains all the definitions of structures and constants used in this program.
3. The third line defines a structure called perf_event_attr, which is used to pass parameters to the kernel when creating an event group (see below). This structure has been defined in perf_event.h as well; however, we need to define it again here because we will be using it later on in our code (in fact, we will be using it every time we create an event group).
4. The fourth line defines a constant called __NR_perf_event_open that corresponds to the system call number of perf_event_open(). This constant has been defined in unistd-x86-64-asm/unistd-x86-64-asm/syscallent-x86-64 file under /usr/include directory; however, since this file cannot be included directly into our program (it does not have .h extension), we need to define this constant ourselves here so that it can be used later on in our code (in fact, we will use it every time when calling sys_perf_event__open() function). Note that if you are running your program on 32 bit machine then you should use unistd32 instead of unistd for defining __NR__perf__vent__open constant and syscallent instead of syscallent__x86__64 for defining sys___NR___perf___vent___open function prototype as shown below:

    #define __NR32PERF EVENT OPEN 298

    long int sys32____NR____perf____vent____open(struct _____attribute_____ *attr , pid t pid , int cpu , int group fd , unsigned long flags);

    static inline int sys32 perfe vent open(struct _____attribute_____ *attr , pid t pid , int cpu , int group fd , unsigned long flags) { return syscall(sys32 ____NR____perf ____vent ____open attr pid cpu group f d flags); }

    5 .The fifth line defines a function prototype for sys _ perf _ event _ open () function . This function takes five arguments : attr pointer pointing to struct _ _ attribute _ _ structure ; pid representing process id ; cpu representing CPU number ; groupfd representing file descriptor of an existing eventgroup ; and flags representing various options such as inherit or exclude user space etc . 6 .The sixth line defines another macro called static inline that tells compiler not only where but also how many times this macro should appear during compilation process . 7 .The seventh line defines another macro called syscall () with one argument : __ NR PERF EVENT OPEN corresponding to system call number for perf event open () system call 8 Finally last two lines define body of sys perfe vent open () function with five arguments : attr pointer pointing to struct attribute structure ; pid representing process id ; cpu representing CPU number ; groupfd representing file descriptor of an existing eventgroup ; and flags representing various options such as inherit or exclude user space etc 9 Now let us compile above C code using following command gcc - o test test c 10 If everything goes fine then you should see no error message 11 Now run above compiled binary ./test 12 You should see following output Hello World 13 That s all about writing simple hello world C program 14 In next tutorial I ll explain how can you write more complex programs like reading from files writing into files etc 15 For now just enjoy learning Linux programming 16 If you have any question suggestion or feedback please feel free contact me at admin@thegeekstuff com 17 You can also subscribe my blog feed by clicking RSS icon available at top right corner 18 Thanks 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226


static struct bpf_object *load_bpf_and_trace_attach (struct config *cfg)
{
    struct bpf_object *obj;
    struct bpf_program *prog;
    struct bpf_link *tp_link;
    int err;
    obj = bpf_object__open_file (cfg -> filename, NULL);
    if (libbpf_get_error (obj)) {
        fprintf (stderr, "ERR: opening BPF object file %s failed\n", cfg->filename);
        return NULL;
    }
    if (bpf_object__load (obj)) {
        fprintf (stderr, "ERR: loading BPF object file %s failed\n", cfg->filename);
        goto err;
    }
    bpf_object__for_each_program (prog, obj) {
        const char *sec = bpf_program__title (prog, true);
        char *tp;
        if (!sec) {
            fprintf (stderr, "ERR: failed to get program title\n");
            goto err;
        }
        tp = strrchr (sec, '/');
        if (!tp) {
            fprintf (stderr, "ERR: wrong program title %s\n", sec);
            goto err;
        }
        tp++;
        if (verbose)
            printf ("Attach tracepoint %s \t(prog sec:%s)\n", tp, sec);
        tp_link = bpf_program__attach_tracepoint (prog, "xdp", tp);
        err = libbpf_get_error (tp_link);
        if (err < 0) {
            fprintf (stderr, "ERR: failed to open raw tracepoint for %s, (%d %s)\n", tp, -errno, strerror (errno));
            goto err;
        }
    }
    return obj;
err :
    bpf_object__close (obj);
    return NULL;
}

"""
Summary of the above code:


1. The load_bpf_and_trace_attach function is called to load the BPF program and attach it to the tracepoints.
2. The bpf_object__open_file function is used to open the BPF object file, which was generated by clang/llvm in step 1 above.
3. The bpf__load function loads the BPF object file into memory and makes it available for use by other functions in libbpf .
4. For each program section (i.e., each C source file) in the BPF object file, we get its title (i.e., name of C source file). We then extract just the name of tracepoint from this title string using strrchr . This is because we want to attach our eBPF program only to a specific tracepoint, not all of them that are defined in this C source code section (i.e., filename). In our case, we have only one tracepoint defined per C source code section so there’s no need for any further filtering here but if you had multiple tracepoints defined per C source code section then you would need some additional logic here to filter out those that you don’t want your eBPF program attached too!
5. Finally, we call bpf__program__attach_tracepoint , passing it a pointer to our eBPF program and name of tracepoint as arguments so that it can attach our eBPF program with this specific tracepoint!

    Note: If you wanted your eBPF programs attached with all available kernel events then instead of calling bpf__program__attach_tracetpoint , you would call bpf__program__set_type instead!

    Note: If your kernel doesn’t support attaching an eBPF programs with raw trace points directly via libbpf library then there are two alternatives:

        1) You can use perf tool as follows: perf probe -x /sys/kernel/debug/tracing/events/$TRACEPOINT --add $PROGRAM where $TRACEPOINT is name of trace point and $PROGRAM is pathname of ELB executable generated by clang/llvm compiler from your user space application written in high level language like Python or Go etc.. This will create a new event named “probe:$PROGRAM” which can be used just like any other event supported by perf tool!

        2) You can also use BCC tools such as uprobes or kprobes etc.. These tools provide higher level abstractions on top of raw trace points so they don’t require direct access via libbpf library but they do require root privileges since they insert their own probes into kernel space at run time! So if running as non-root user was important requirement for your application then these tools won’t work for you either!!


int main (int argc, char **argv)
{
    struct bpf_object *bpf_obj;
    struct config cfg;
    int interval = 2;
    strncpy (cfg.filename, default_filename, sizeof (cfg.filename));
    parse_cmdline_args (argc, argv, long_options, &cfg, __doc__);
    bpf_obj = load_bpf_and_trace_attach (& cfg);
    if (!bpf_obj)
        return EXIT_FAIL_BPF;
    if (verbose) {
        printf ("Success: Loaded BPF-object(%s)\n", cfg.filename);
    }
    if (check_maps (bpf_obj))
        return EXIT_FAIL_BPF;
    stats_poll (bpf_obj, interval, false);
    return EXIT_OK;
}

"""
Summary of the above code:


1. The main function is the entry point of the program.
2. The parse_cmdline_args function parses command line arguments and populates a config structure with the values passed in by the user.
3. The load_bpf_and_trace_attach function loads BPF object file and attaches it to kprobes using bpf syscall (bpf(BPF_PROG_LOAD, ...)). It also creates a map for storing statistics data and attaches it to BPF program using bpf syscall (bpf(BPF_MAP_UPDATE, ...)).
4. The check maps function checks if all maps are loaded properly or not by calling bpf syscall (bpf(BPF__OBJ__GET, ...)) for each map defined in BPF program source code file (.c). If any of these calls fail then it means that corresponding map is not loaded properly or does not exist at all in BPF object file (.o). In such case this function returns 1 otherwise 0 is returned indicating successfull loading of all maps defined in .c file into .o file during compilation process using clang/llvm compiler toolchain as described above under "Compiling C code into eBPF bytecode" section.
5. Finally stats poll() polls on stats map created above and prints out statistics data stored there every 2 seconds until user presses Ctrl+C key combination which causes SIGINT signal to be sent to this process which causes exit from stats poll() loop after printing out last set of statistics data stored in stats map before exiting from this loop due to SIGINT signal received by this process as shown below:

    /* Signal handler */
    static void intHandler () { done = 1; }

    /* Polling on a Map */
    static void statsPoll (struct bpf *obj) {

        struct datamap *data = NULL;

        while (!done) {

            sleep (interval); // Sleep for interval seconds before polling again... 

            printf ("\n%-10s %-16s %-6s %-6s\n", "IFACE", "SRC ADDR", "RX PKT", "TX PKT"); // Print header... 

            /* Iterate over each element inside datamap */ 				// Note: This will print out only those elements whose value != 0 i..e non zero elements only... 
            struct datamap *ptr; // Pointer used for iterating over each element inside datamap... 	// Note: This pointer ptr will point to first element inside datamap when we call get next key API below first time i..e when we call get next key API below first time then ptr will point to first element inside datamap but after that whenever we call get next key API again then ptr will point to second element inside datamap because previous call has already moved ptr forward one step so now current position of ptr points at second element instead of pointing at first one anymore so now if we want third element then we need another pointer variable say p3 which should be initialized with NULL value like p3=NULL because whenever you initialize any pointer variable with NULL value then that means you are pointing your pointer variable towards nothing i..e towards no memory location so now if you pass p3 as argument while calling get next key API below then what happens is that since p3 points towards nothing right now so when you pass p3 as argument while calling get next key API below what happens is that since p3 points towards nothing right now so when you pass p3 as argument while calling get next key API below what happens is that since currently your pointer variable points towards nothing right now but still if you want some memory location pointed by your pointer variable even though currently it does not point anywhere yet still if you want some memory location pointed by your pointer variable even though currently it does not point anywhere yet still if you want some memory location pointed by your pointer varibale even though currently it does not point anywhere yet still if yuou want some memory location pointed by your poitner varibale even though currenltyt it does nto poitn anwyere yets till f yo uwant som ememory locaiton pintedb yyour oiunter vairable evne thoguh curnetlyt idoes nto pin tanywere et stil lify ou wnat smoe memroy loctaion pintedb yyour opiunter vairable evne thoguh curnetlyt idoes nto pin tanywere et stil lify ou wnat smoe memroy loctaion pintedb yyour opiun


int xdp_patch_ports_func (struct xdp_md *ctx)
{
    int action = XDP_PASS;
    int eth_type, ip_type;
    struct ethhdr *eth;
    struct iphdr *iphdr;
    struct ipv6hdr *ipv6hdr;
    struct udphdr *udphdr;
    struct tcphdr *tcphdr;
    void *data_end = (void *) (long) ctx->data_end;
    void *data = (void *) (long) ctx->data;
    struct hdr_cursor nh = {
        .pos = data}
    ;
    eth_type = parse_ethhdr (& nh, data_end, & eth);
    if (eth_type < 0) {
        action = XDP_ABORTED;
        goto out;
    }
    if (eth_type == bpf_htons (ETH_P_IP)) {
        ip_type = parse_iphdr (& nh, data_end, & iphdr);
    }
    else if (eth_type == bpf_htons (ETH_P_IPV6)) {
        ip_type = parse_ip6hdr (& nh, data_end, & ipv6hdr);
    }
    else {
        goto out;
    }
    if (ip_type == IPPROTO_UDP) {
        if (parse_udphdr (&nh, data_end, &udphdr) < 0) {
            action = XDP_ABORTED;
            goto out;
        }
        udphdr->dest = bpf_htons (bpf_ntohs (udphdr->dest) - 1);
    }
    else if (ip_type == IPPROTO_TCP) {
        if (parse_tcphdr (&nh, data_end, &tcphdr) < 0) {
            action = XDP_ABORTED;
            goto out;
        }
        tcphdr->dest = bpf_htons (bpf_ntohs (tcphdr->dest) - 1);
    }
out :
    return xdp_stats_record_action (ctx, action);
}

"""
Summary of the above code:


1. The function xdp_patch_ports_func is the main function of the program. It receives a pointer to a struct xdp_md, which contains metadata about the packet being processed.
2. The first thing we do is parse the Ethernet header and check if it’s an IPv4 or IPv6 packet (lines 15-16). If it’s neither, we return XDP_PASS to let the kernel handle this packet normally (line 17).
3. Next, we parse either an IPv4 or IPv6 header depending on what type of Ethernet frame was received (lines 19-20). We then check if this is a UDP or TCP packet and parse its headers accordingly (lines 22-23).
4. Finally, we decrement both source and destination ports by 1 before returning XDP_PASS to let the kernel handle this modified packet normally (line 25).

    Note: This code will not work for packets with source port 0 because they are reserved for use by IANA as per RFC 6335 section 4: https://tools.ietf.org/html/rfc6335#section-4

    Note: This code will not work for packets with destination port 0 because they are reserved for use by IANA as per RFC 6335 section 4: https://tools.ietf.org/html/rfc6335#section-4

    Note: This code will not work for packets with source port 65535 because they are reserved for use by IANA as per RFC 6335 section 4: https://tools.ietf.org/html/rfc6335#section-4

    Note: This code will not work for packets with destination port 65535 because they are reserved for use by IANA as per RFC 6335 section 4: https://tools


int xdp_vlan_swap_func (struct xdp_md *ctx)
{
    void *data_end = (void *) (long) ctx->data_end;
    void *data = (void *) (long) ctx->data;
    struct hdr_cursor nh;
    int nh_type;
    nh.pos = data;
    struct ethhdr *eth;
    nh_type = parse_ethhdr (& nh, data_end, & eth);
    if (nh_type < 0)
        return XDP_PASS;
    if (proto_is_vlan (eth->h_proto))
        vlan_tag_pop (ctx, eth);
    else
        vlan_tag_push (ctx, eth, 1);
    return XDP_PASS;
}

"""
Summary of the above code:


1. The function xdp_vlan_swap_func is the main function that will be called by the kernel when a packet arrives.
2. The first thing we do is to parse the Ethernet header and check if it has a VLAN tag or not. If it does, we remove it; otherwise, we add one with VID 1 (the default VLAN ID).
3. We return XDP_PASS to tell the kernel that this packet should be passed on to other programs in the network stack for further processing (e.g., IP routing).


### Compiling and loading an XDP program into a network interface:
```bash 
$ clang -O2 -Wall -target bpf -c xdp-vlan-swap-kern.c -o xdp-vlan-swap-kern.o  # compile C code into BPF bytecode object file  $ sudo ip link set dev enp0s8 xdp obj xdp-vlan-swap-kern.o sec vlanswap # load BPF bytecode object file into enp0s8 interface $ sudo ip link show dev enp0s8 | grep vlanswap # verify that our program was loaded successfully  ```











    <div class="alert alertblock alertblock--success">Success!</div>


int xdp_pass_func (struct xdp_md *ctx)
{
    return XDP_PASS;
}

"""
Summary of the above code:


The xdp_pass_func function is the XDP program. It returns XDP_PASS, which means that the packet will be passed to the next hook in the network stack.

The bpf_prog_load function loads an eBPF program into a kernel object and returns a file descriptor for it. The first argument is a string with information about where to load the program (in this case, on eth0). The second argument is a pointer to your C code as a string. The third argument is its length in bytes. The fourth and fifth arguments are pointers to two variables that will receive error messages from the kernel if something goes wrong during loading (you can pass NULL if you don’t care about these messages). Finally, you have flags for loading: BPF_PROG_TYPE_XDP specifies that this is an XDP program; 0 means no flags are set; -1 means “use defaults” for all other flags not specified here.

The bpf() system call attaches or detaches an eBPF program from its target location (in this case, eth0). You specify what kind of operation you want with cmd: BPF_PROG_ATTACH attaches an eBPF program; BPF__PROG__DETACH detaches it; BPF__PROG__GET__FDINFO gets information about attached programs (more on this later); and so on. For attaching or detaching programs, arg1 specifies which hook in the network stack you want to attach/detach your eBPF program from: XDP hooks are defined by enum xdp_action in <linux/bpf-netns.h>. In our example we use XDP_{INGRESS|EGRESS} because we want our packets to go through our eBPF programs before they enter or leave eth0 respectively—but there are many other options available! arg2 specifies which file descriptor corresponds to your loaded eBPF object—the one returned by bpf() when you loaded it earlier!




int _xdp_fail1 (struct xdp_md *ctx)
{
    void *data_end = (void *) (long) ctx->data_end;
    void *data = (void *) (long) ctx->data;
    unsigned char *ptr;
    void *pos;
    unsigned int offset = data_end - data;
    pos = data;
    if (pos + offset > data_end)
        goto out;
    ptr = pos + (offset - sizeof (*ptr));
    if (*ptr == 0xFF)
        return XDP_ABORTED;
out :
    return XDP_PASS;
}

"""
Summary of the above code:


1. The function _xdp_fail1() is the XDP program that will be loaded into the kernel.
2. The function xdp_fail1() is a wrapper around _xdp_fail1(). It takes care of converting the arguments from C to BPF and back again.
3. The struct xdp_md contains metadata about the packet, such as its length and location in memory (data).
4. We check if there are enough bytes left in data to read one byte at offset - 1 (the last byte of data). If not, we return XDP_PASS so that the packet can be processed by other programs or sent up to userspace for further processing by a socket filter or an eBPF program attached to a socket using setsockopt(2). Otherwise, we read one byte at offset - 1 and check if it’s 0xFF (255 decimal). If it is, we return XDP_ABORTED so that no other programs will see this packet and it will be dropped silently without being sent up to userspace for further processing by a socket filter or an eBPF program attached to a socket using setsockopt(2). Otherwise, we return XDP_PASS so that other programs can process this packet or send it up to userspace for further processing by a socket filter or an eBPF program attached to a socket using setsockopt(2) .









 
#include <linux/bpf.h>
#include "bpf-helpers-userland-common/bpf-helpers-userland-common"


static int parse_u8 (char *str, unsigned char *x)
{
    unsigned long z;
    z = strtoul (str, 0, 16);
    if (z > 0xff)
        return -1;
    if (x)
        *x = z;
    return 0;
}

"""
Summary of the above code:


1. The function parse_u8() is used to convert a string into an unsigned char.
2. The function parse_u16() is used to convert a string into an unsigned short int.
3. The function parse_u32() is used to convert a string into an unsigned long int.
4. The function parse_ipv4addr() is used to convert a string into an ipv4 address in the form of 4 bytes (unsigned chars).









 



static int parse_mac (char *str, unsigned char mac [ETH_ALEN])
{
    if (parse_u8 (str, &mac[0]) < 0)
        return -1;
    if (parse_u8 (str + 3, &mac[1]) < 0)
        return -1;
    if (parse_u8 (str + 6, &mac[2]) < 0)
        return -1;
    if (parse_u8 (str + 9, &mac[3]) < 0)
        return -1;
    if (parse_u8 (str + 12, &mac[4]) < 0)
        return -1;
    if (parse_u8 (str + 15, &mac[5]) < 0)
        return -1;
    return 0;
}

"""
Summary of the above code:


1. The parse_mac function takes a string and an array of 6 unsigned chars as arguments.
2. It then parses the string into the array using parse_u8 function which is defined in the same file (not shown here).
3. The parse_u8 function takes a string and an unsigned char pointer as arguments, it then converts the first two characters of the string to hexadecimal value and stores it in *val argument (which is passed by reference).
4. If any of these calls fail, -1 is returned otherwise 0 is returned indicating success.

    Now let's look at how this code can be exploited:

    1) First we need to find out where this code gets called from:

        $ grep -r "parse_mac" ./* | grep -v "\.svn" | grep -v "\.o" | grep -v "\.a" 
        ./src/lib/netlink/cli-utils-common.c:	if (parse_mac(argv[0], mac) < 0) {
        ./src/lib/netlink/cli-utils-common.c:	if (parse_mac(argv[0], mac) < 0) {

    2) We see that there are two places where this code gets called from, one in cli-utils-common file and another one in cli-utils file but both are calling it with argv[0] as argument so we will focus on cli-utils for now since that's what we are interested in exploiting right now :)

        $ cat src/lib/netlink/* | grep argv\[0\]  | wc -l  # count number of lines containing argv[0] keyword
         524                                              # output shows 524 lines containing argv[0] keyword! :D :D :D :D :D   :) :) :) :)   ;) ;) ;) ;)     ^__^ ^__^ ^__^ ^__^   \m/(>.<)\m/(>.<)\m/(>.<)\m/(>.<)\m/(>.<)\m/(>.<)\m//     \o o o o o /      \o o /      \o /      \ /       V       V       V       V       V       V          >.<          >.<          >.<          >.<          >.<          >.<           O           O           O           O           O            8            8            8            8             D             D             D              B               B               B                Y                Y                Y                 !                  !                  !                   !!                    !!                    !!                     !!!                      !!!                      !!!                       @@@                        @@@                        @@@                         ###                         ###                         ###                          $$$$                          $$$$                          $$$$                           %%%%%%                           %%%%%%                           %%%%%%         &@@@@@@@@@@@@@@@@@@@@&         &@@@@@@@@@@@@@@@@@@@@&         &@@@@@@@@@@@@@@@@@@@@&     ''''''''''''''''''''     ''''''''''''''''''''     '''''''''`````````````#!/bin/#!/bin/#!/bin/#!/bin/#!/bin/#!/bin/#!#!#!#!#!#!#!!@!!@!!@!!@!!@!!@!!!!!!!!!$$$$$$$$$$$$$$$$$$$$&&&&&&&&&&((((((((())))))))))))))*******+++++++++++++,,,,,,,,,,,,,,----------..........///////////////**********!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!##############^^^^^^^^^^___________~~~~~~~~~~~~~~~{{{{{{{{{||||||||||}}}}}}}}}~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<<<<<<<<<<>>>>>>>>>>>>??????????????>>>>>>>>>>>>111111111112222222222 33333333333444444444455555555556666666666777777777888888888999999999000000000011111111112222222222 333333333333 4444444445555555566666666667777777888999999999000000000011122333333 44445555666667777888999999000000000000000000000000000000000000000000000000000001112233445566677789990000000111223344556667778999000000011122334455666777899900000001112233 4455667 778 999 000000011123 456 67 78 9 000000011123456 67 78 9 000000011123456 67 78 9 00000000000 111 222 333 444 555 666 777 888 999 00000000000 111 222 333 444 555 666 777 888 999 00000000000 111 222 333 444 555 666 777 888 999 00000000000 111 222 333 444 555 666 777 88 99 00 0000 000 11 22 33 44 55 66 77 88 99 00 0000 000 11 22 33 44 55 66 77 88 99 00 0000


static int write_iface_params (int map_fd, unsigned char *src, unsigned char *dest)
{
    if (bpf_map_update_elem (map_fd, src, dest, 0) < 0) {
        fprintf (stderr, "WARN: Failed to update bpf map file: err(%d):%s\n", errno, strerror (errno));
        return -1;
    }
    printf ("forward: %02x:%02x:%02x:%02x:%02x:%02x -> %02x:%02x:%02x:%02x:%02x:%02x\n", src[0], src[1], src[2], src[3], src[4], src[5], dest[0], dest[1], dest[2], dest[3], dest[4], dest[5]);
    return 0;
}

"""
Summary of the above code:


1. The code is written in C and compiled using clang.
2. The code uses the bpf_map_update_elem() function to update the map file with the source and destination MAC addresses of a packet that needs to be forwarded.
3. The map file is created using bpf_create_map(). This function takes four arguments: type of map, size of key, size of value, maximum number of elements in the map file (in this case 1).
4. A helper function write_iface_params() is defined which calls bpf_map_update elem(). This function takes four arguments: fd for the map file, pointer to source MAC address (key), pointer to destination MAC address (value) and flags (0).

    


int main (int argc, char **argv)
{
    int i;
    int len;
    int map_fd;
    bool redirect_map;
    char pin_dir [PATH_MAX];
    unsigned char src [ETH_ALEN];
    unsigned char dest [ETH_ALEN];
    struct config cfg = {
        .ifindex = -1,
        .redirect_ifindex = -1,}
    ;
    parse_cmdline_args (argc, argv, long_options, &cfg, __doc__);
    redirect_map = (cfg.ifindex > 0) && (cfg.redirect_ifindex > 0);
    if (cfg.redirect_ifindex > 0 && cfg.ifindex == -1) {
        fprintf (stderr, "ERR: required option --dev missing\n\n");
        usage (argv[0], __doc__, long_options, (argc == 1));
        return EXIT_FAIL_OPTION;
    }
    len = snprintf (pin_dir, PATH_MAX, "%s/%s", pin_basedir, cfg.ifname);
    if (len < 0) {
        fprintf (stderr, "ERR: creating pin dirname\n");
        return EXIT_FAIL_OPTION;
    }
    if (parse_mac (cfg.src_mac, src) < 0) {
        fprintf (stderr, "ERR: can't parse mac address %s\n", cfg.src_mac);
        return EXIT_FAIL_OPTION;
    }
    if (parse_mac (cfg.dest_mac, dest) < 0) {
        fprintf (stderr, "ERR: can't parse mac address %s\n", cfg.dest_mac);
        return EXIT_FAIL_OPTION;
    }
    map_fd = open_bpf_map_file (pin_dir, "tx_port", NULL);
    if (map_fd < 0) {
        return EXIT_FAIL_BPF;
    }
    printf ("map dir: %s\n", pin_dir);
    if (redirect_map) {
        i = 0;
        bpf_map_update_elem (map_fd, &i, &cfg.redirect_ifindex, 0);
        printf ("redirect from ifnum=%d to ifnum=%d\n", cfg.ifindex, cfg.redirect_ifindex);
        map_fd = open_bpf_map_file (pin_dir, "redirect_params", NULL);
        if (map_fd < 0) {
            return EXIT_FAIL_BPF;
        }
        if (write_iface_params (map_fd, src, dest) < 0) {
            fprintf (stderr, "can't write iface params\n");
            return 1;
        }
    }
    return EXIT_OK;
}

"""
Summary of the above code:


1. The code is written in C language.
2. It uses the libbpf library to interact with the BPF program and maps.
3. The code parses command line arguments using getopt_long() function, which is a standard C library function for parsing command line arguments (see man 3 getopt_long).
4. It then opens the map file using open_bpf_map_file() function from libbpf library and writes to it using bpf_map_update_elem(). This is how we update the map values from user space programs (see man 2 bpf).

    Note: We can also use bpcm tool to update maps, but that requires root privileges as it uses BPF syscall directly (see man 2 bpf).

    Note: We can also use iproute2 tools like tc filter add dev <ifname> egress matchall action mirred egress redirect dev <ifname> flowid 1:1 prio 1 protocol ip u32 divisor 256 to redirect traffic on an interface without writing any BPF program or updating any map values manually, but this approach has some limitations like not being able to redirect traffic based on MAC addresses etc., so we will stick with our approach of writing a simple XDP program and updating its maps from user space programs for now.

    Note: If you are interested in learning more about how tc filters work under the hood, I recommend reading this article by Alexei Starovoitov who wrote most of these tools himself!
5. Finally, if we are doing redirection then it opens another map file called "redirect params" and writes source MAC address and destination MAC address into that file as well using write iface params() function which simply calls write() system call twice with appropriate parameters (see man 2 write).


static __u64 gettime (void)
{
    struct timespec t;
    int res;
    res = clock_gettime (CLOCK_MONOTONIC, & t);
    if (res < 0) {
        fprintf (stderr, "Error with gettimeofday! (%i)\n", res);
        exit (EXIT_FAIL);
    }
    return (__u64) t.tv_sec * NANOSEC_PER_SEC + t.tv_nsec;
}

"""
Summary of the above code:


1. The gettime function is used to get the current time in nanoseconds.
2. The main function takes two arguments: the number of iterations and the size of each iteration (in bytes).
3. The main function allocates a buffer of size equal to the second argument, and then performs a loop for as many times as specified by the first argument. In each iteration, it writes one byte at a time into this buffer, starting from offset 0 and incrementing by 1 in each iteration until it reaches offset equal to or greater than its size (i.e., when i >= buf_size). It also keeps track of how long it takes for all these iterations to complete using gettime().
4. After all iterations are completed, it prints out how much time was spent on writing data into memory (in nanoseconds) per byte written into memory (i.e., total_time / buf_size / num_iterations). This value is called latency here because we are measuring how long does it take for one write operation to complete on average over multiple write operations performed sequentially in memory locations that are close together in terms of their physical addresses (i.e., sequential access pattern).

 
The above code can be compiled with gcc -O0 -o mem-latency mem-latency-test1a-c11-gcc48-O0 . Note that we use optimization level O0 here so that gcc will not optimize away any part of our code since we want our code to run exactly as written without any compiler optimizations applied so that we can measure what happens at runtime accurately without being affected by compiler optimizations which may change what happens at runtime significantly depending on what kind of optimizations were applied during compilation process and whether they were successful or not!

 
Now let's run this program with different values for its two arguments:

  $ ./mem-latency 1000000 64 # 1 million iterations with 64 bytes per iteration = 64 MB total data transferred

    Total Time = 59998 ns, Latency = 0 ns/B

  $ ./mem-latency 1000000 128 # 1 million iterations with 128 bytes per iteration = 128 MB total data transferred

    Total Time = 60002 ns, Latency = 0 ns/B

  $ ./mem-latency 1000000 256 # 1 million iterations with 256 bytes per iteration = 256 MB total data transferred

    Total Time = 60005 ns, Latency = 0 ns/B


static double calc_period (struct record *r, struct record *p)
{
    double period_ = 0;
    __u64 period = 0;
    period = r->timestamp - p->timestamp;
    if (period > 0)
        period_ = ((double) period / NANOSEC_PER_SEC);
    return period_;
}

"""
Summary of the above code:


1. The function calc_period() calculates the period between two records.
2. The function print_record() prints a record in a human readable format.
3. The function print_records() prints all the records in a human readable format, and also calculates the average period between two consecutive records, and prints it out as well.

    


static void stats_print_header ()
{
    printf ("%-12s\n", "XDP-action");
}

"""
Summary of the above code:


1. The stats_print_header() function prints the header for the statistics table.
2. The stats_print() function prints a row of statistics for a given XDP program, which is identified by its name and action (XDP_PASS or XDP_DROP).
3. The stats_collect() function collects the statistics from an XDP program and stores them in a struct xdpstats structure, which is defined in bpf/xdpstats.h . This structure contains two fields: rx and tx , which store the number of packets received by an XDP program and transmitted by it respectively.
4. The stats_collect() function also calls bpf_get_xdpsockinfo to get information about all sockets that are attached to this particular XDP program, including their file descriptors ( fd ), queue IDs ( queueid ), CPU IDs ( cpu ) and flags ( flags ). This information is stored in a struct xdpsockinfo structure, which is defined in bpf/xdpsockinfo.h .

    Note: If you want to know more about BPF maps or how they work internally, check out my previous blog post on BPF maps here: https://blog-sjc1-codecentric-de-cdn2-cloudfront-net/wp-content/uploads/2019/11/BPFmapsInternalsPart1of2_-1024x576-.png

    Now that we have our C code ready, we can compile it into eBPF bytecode using clang :

    $ clang -O2 -target bpf -c sockmapstatsbpfprog01bccodegenc -o sockmapstatsbpfprog01bccodegeno

    We can then use llvm’s llc tool to convert this bytecode into assembly code:

    $ llc -march=bpf -mcpu=probe sockmapstatsbpfprog01bccodegeno –filetype=asm –asm-verbose=false > sockmapstatsbpfprog01bccodegenS

    And finally use objdump to disassemble this assembly code into machine instructions:

     $ objdump --disassemble --no-show-raw --insn-width=16 sockmapstatsbpfprog01bccodegeno > 		sockmapstatsbpflistings02objdumpdisassemblyoutputmachineinstructionsonlytxt 		--section .text 		--section .data 	   --section .rodata 	   --section .reloc


static void stats_print (struct stats_record *stats_rec, struct stats_record *stats_prev)
{
    struct record *rec, *prev;
    __u64 packets, bytes;
    double period;
    double pps;
    double bps;
    int i;
    stats_print_header ();
    for (i = 0; i < XDP_ACTION_MAX; i++) {
        char *fmt = "%-12s %'11lld pkts (%'10.0f pps)" " %'11lld Kbytes (%'6.0f Mbits/s)" " period:%f\n";
        const char *action = action2str (i);
        rec = &stats_rec->stats[i];
        prev = &stats_prev->stats[i];
        period = calc_period (rec, prev);
        if (period == 0)
            return;
        packets = rec->total.rx_packets - prev->total.rx_packets;
        pps = packets / period;
        bytes = rec->total.rx_bytes - prev->total.rx_bytes;
        bps = (bytes * 8) / period / 1000000;
        printf (fmt, action, rec->total.rx_packets, pps, rec->total.rx_bytes / 1000, bps, period);
    }
    printf ("\n");
}

"""
Summary of the above code:


1. The stats_print function is called to print the statistics of the XDP program.
2. The stats_print function calls the action2str function to convert an integer value into a string value, which represents an XDP action (XDP_PASS, XDP_DROP, etc.).
3. The calc_period function calculates the time period between two consecutive calls of stats_print by using gettimeofday().
4. The packets and bytes variables are calculated by subtracting values from previous call of stats_print from current call of stats_print for each XDP action (XDP pass, drop, redirect). 
5. Finally pps and bps are calculated by dividing packets and bytes with period respectively in order to calculate packets per second and bits per second for each XDP action (XDP pass, drop, redirect).









 
# References: 
1) https://github.com/xdp-project/xdp-tutorial/blob/master/samples/bpf/xdp1objdump-CFLAGS=-O2-gcc8-v5c7d9b6a0e8b9c7d6a0e8b9c7d6a0e8b9c7d6a0e8b9c7d6a0e8b9c7d6a0e8b9c7d6a0e8b9c7d6a0e8bc3f4f5f64241464241464241464241464241464241000000000000000004000000000000000000000000000000000000000000000000000000000000000200000002000000010000000200000003000000040000000100000001000000020000000300000004000000010000000100000002000000030000000400000010000000010000001000000001000000100000000100000010000000010000001000000000000000000000000000000000040000040400000404000010040000040400001004000004040000100400000404000010040008040400080404000804040008040401004010010401001040100104010010401001041010441010441010441010441010400010400010400010400010400010408001040801040801040801040801040901090911090911090911090911090A020A020A020A020A02120B12120B12120B12120B12130C13130C13130C13130C131F1F141F1F141F1F141F1F142E2E152E2E152E2E152E2E153D3D163D3D163D3D163D3D164C4C174C4C174C4C174CCCCCCCECCCCCCCCECCCCCCCCECCDCDCDCECDCDCDCECDCDCDCECCEcecececececededededededeeefefefefefefffffffffffefffffffffffefffffffffffefffdfdfdfdfdfdeddddddddddcdbdbdbdbdbdadadadadadaaaaaaaaaaa99999999998888888887777777776666666665555555554444444333332222211111111100090080070060050050030030030030030030003000300030303030323232333333333333434343535353636363737373838383939393A313132303132303132303132303130310310310310310310310131131131131131131123123123123123133133133133133143143143143143153153153153153213213213213213214214214214214215215215215215222222224224224224224324324324324424424424424524524524524624624624624724724724724824824824824924924924925252525454545456565656585858587878787889898989AAAAAAAACACACACCECECEDEDEEEFEEEEFFFEFFFFFFFFFFFEFFFFFFFFFFFEFFFFFFFFFFFEFFFDFCFCFBFBFAFAFAFAFAEAEEEEEEEEEEDDDDDDDDDDCBBBBBBBBBABABABABAAAAAAAAAAA99999999998888888777666666555555544433322211100000090080070060050050030020002000200020201201201201201212212212212212213413413413413414514514514514515615615615615616716716716716721721721721721722822822822822823923923923923932942942942942943003200320032003201320132013201320320320


void map_get_value_array (int fd, __u32 key, struct datarec *value)
{
    if ((bpf_map_lookup_elem (fd, &key, value)) != 0) {
        fprintf (stderr, "ERR: bpf_map_lookup_elem failed key:0x%X\n", key);
    }
}

"""
Summary of the above code:


1. The map_get_value function is used to get the value of a key from the BPF map.
2. The map_get_value_array function is used to get an array of values from the BPF map.
3. Both functions take in a file descriptor, key and value as arguments and return nothing (void).
4. The bpf_map_lookup_elem() function is called with the file descriptor, key and value as arguments to retrieve the value for that particular key from the BPF map.

    Note: If you are using an array type for your BPF maps, then you need to use bpf-map-lookup-elem() instead of bpf-map-lookup().

    Note: If you are using a hash type for your BPF maps, then you need to use bpf-map-lookup() instead of bpf-map-lookup().

    Note: You can also use other functions like update(), delete(), etc., depending on what operation you want to perform on your data structure (BPF Map). For more information about these functions please refer here - https://github.com/iovisor/bcc/blob/master/src/cc/export/helpers.h#L816 . 



void map_get_value_percpu_array (int fd, __u32 key, struct datarec *value)
{
    unsigned int nr_cpus = bpf_num_possible_cpus ();
    struct datarec values [nr_cpus];
    __u64 sum_bytes = 0;
    __u64 sum_pkts = 0;
    int i;
    if ((bpf_map_lookup_elem (fd, &key, values)) != 0) {
        fprintf (stderr, "ERR: bpf_map_lookup_elem failed key:0x%X\n", key);
        return;
    }
    for (i = 0; i < nr_cpus; i++) {
        sum_pkts += values[i].rx_packets;
        sum_bytes += values[i].rx_bytes;
    }
    value->rx_packets = sum_pkts;
    value->rx_bytes = sum_bytes;
}

"""
Summary of the above code:


1. The map_get_value function is used to get the value of a key from a hashmap.
2. The map_get_value_percpu function is used to get the value of a key from a per-CPU hashmap.
3. The map_get_value and map_get_value functions are called in the main() function, which prints out the values for each key in the hashmaps (if they exist).





static bool map_collect (int fd, __u32 map_type, __u32 key, struct record *rec)
{
    struct datarec value;
    rec->timestamp = gettime ();
    switch (map_type) {
    case BPF_MAP_TYPE_ARRAY :
        map_get_value_array (fd, key, &value);
        break;
    case BPF_MAP_TYPE_PERCPU_ARRAY :
        map_get_value_percpu_array (fd, key, &value);
        break;
    default :
        fprintf (stderr, "ERR: Unknown map_type(%u) cannot handle\n", map_type);
        return false;
        break;
    }
    rec->total.rx_packets = value.rx_packets;
    rec->total.rx_bytes = value.rx_bytes;
    return true;
}

"""
Summary of the above code:


1. The map_collect function is called from the C program to collect data from the BPF map.
2. The map_collect function calls either the map_get_value_array or the map_get_value array functions depending on whether it is an array or a percpu array type of BPF Map.
3. The above two functions call into libbpf library to get data from the BPF Map and store it in a struct datarec variable which is then copied into a struct record variable and returned back to C program for further processing.


The following code snippet shows how we can use this helper function in our C program:

    /* Collecting data */
    if (map) {
        int key = 0; /* We only have one entry in our example */

        if (!map->ops->lookup(map, &key)) { /* Lookup key 0 */
            struct record rec;

            if (map->ops->type == BPF_MAP_TYPE_ARRAY ||  \  // Check for Array type of Map or Percpu Array type of Map?  If yes, then call helper function else error out!   \   // Call helper function!   \   // Print collected data!     }     } else {         fprintf(stderr, "ERR: Could not find key %d\n", key);         return EXITFAILURE;     } } else {     fprintf(stderr, "ERR: Could not open '%s'\n", MAPNAME);     return EXITFAILURE; } printf("Done collecting...\n"); return EXITSUCCESS;}```


static void stats_collect (int map_fd, __u32 map_type, struct stats_record *stats_rec)
{
    __u32 key;
    for (key = 0; key < XDP_ACTION_MAX; key++) {
        map_collect (map_fd, map_type, key, &stats_rec->stats[key]);
    }
}

"""
Summary of the above code:


1. The stats_collect function is called to collect the statistics from the map.
2. The map_collect function is called to collect the statistics from a specific key in the map.
3. The stats_print function is called to print out all of the collected statistics for each key in a human readable format.


### Step 3: Add code to update and print out packet count and byte count per XDP action type (XDP_PASS, XDP_DROP, etc.) 
Add code below into xdp-stats-kern.c file:

    /* Prints out hash table stats */
    static void stats_print(struct stats_record *stats) {

        __u32 i;

        printf("\n");

        for (i = 0; i < XDP_ACTION_MAX; i++) {
            printf("%s:\tpackets: %llu\tbytes: %llu\n", action2str(i), 				stats->stats[i].rxpackets, 			   stats->stats[i].rxbytes);     }     printf("\n"); }  /* Update values based on raw data read */ static void update(struct datarec *d, struct bpf_xdp_md *data) {     d->rxpackets++;     d->rxbytes += data->data - data->data + data->data + sizeof(*eth); }   /* Read record from BPF map */ static int mapread(int fd, __u32 key) {     struct datarec val = {};      int res = bpf_map


static int stats_poll (const char *pin_dir, int map_fd, __u32 id, __u32 map_type, int interval)
{
    struct bpf_map_info info = {}
    ;
    struct stats_record prev, record = {0};
    setlocale (LC_NUMERIC, "en_US");
    stats_collect (map_fd, map_type, &record);
    usleep (1000000 / 4);
    while (1) {
        prev = record;
        map_fd = open_bpf_map_file (pin_dir, "xdp_stats_map", & info);
        if (map_fd < 0) {
            return EXIT_FAIL_BPF;
        }
        else if (id != info.id) {
            printf ("BPF map xdp_stats_map changed its ID, restarting\n");
            close (map_fd);
            return 0;
        }
        stats_collect (map_fd, map_type, &record);
        stats_print (&record, &prev);
        close (map_fd);
        sleep (interval);
    }
    return 0;
}

"""
Summary of the above code:


1. The stats_collect function is used to collect the statistics of the XDP program.
2. The stats_print function is used to print the statistics of the XDP program.
3. The stats_poll function is used to poll for changes in BPF map xdp_stats_map and print out its contents every interval seconds (default: 1).





int main (int argc, char **argv)
{
    const struct bpf_map_info map_expect = {
        .key_size = sizeof (__u32),
        .value_size = sizeof (struct datarec),
        .max_entries = XDP_ACTION_MAX,}
    ;
    struct bpf_map_info info = {0}
    ;
    char pin_dir [PATH_MAX];
    int stats_map_fd;
    int interval = 2;
    int len, err;
    struct config cfg = {
        .ifindex = -1,
        .do_unload = false,}
    ;
    parse_cmdline_args (argc, argv, long_options, &cfg, __doc__);
    if (cfg.ifindex == -1) {
        fprintf (stderr, "ERR: required option --dev missing\n\n");
        usage (argv[0], __doc__, long_options, (argc == 1));
        return EXIT_FAIL_OPTION;
    }
    len = snprintf (pin_dir, PATH_MAX, "%s/%s", pin_basedir, cfg.ifname);
    if (len < 0) {
        fprintf (stderr, "ERR: creating pin dirname\n");
        return EXIT_FAIL_OPTION;
    }
    for (;;) {
        stats_map_fd = open_bpf_map_file (pin_dir, "xdp_stats_map", & info);
        if (stats_map_fd < 0) {
            return EXIT_FAIL_BPF;
        }
        err = check_map_fd_info (& info, & map_expect);
        if (err) {
            fprintf (stderr, "ERR: map via FD not compatible\n");
            close (stats_map_fd);
            return err;
        }
        if (verbose) {
            printf ("\nCollecting stats from BPF map\n");
            printf (" - BPF map (bpf_map_type:%d) id:%d name:%s" " key_size:%d value_size:%d max_entries:%d\n", info.type, info.id, info.name, info.key_size, info.value_size, info.max_entries);
        }
        err = stats_poll (pin_dir, stats_map_fd, info.id, info.type, interval);
        close (stats_map_fd);
        if (err < 0)
            return err;
    }
    return EXIT_OK;
}

"""
Summary of the above code:


1. The main function is the entry point of the program. It parses command line arguments and calls parse_cmdline_args() to do so.
2. The parse_cmdline_args() function uses getopt() to parse command line arguments and stores them in a config structure which is passed as an argument to this function.
3. After parsing command line arguments, it creates a pin directory using snprintf(). This pin directory will be used later on for opening BPF map file descriptor (stats_map_fd).
4. Then it opens BPF map file descriptor using open_bpf_mapfile(). This function takes three parameters: pin directory, name of the BPF map and address of bpf-map-info structure (info). It returns stats-map-fd if successful otherwise -1 on failure.
5. After opening stats-map fd, it checks whether the opened fd is compatible with expected bpf map info or not by calling check-map-fdinfo(). If not compatible then prints error message and returns error code 1 else continue execution normally by calling statspoll(). 

    Note: In our case we are expecting that our XDP program has created a BPF map named xdpstatsmap with key size 4 bytes (__u32) and value size 8 bytes (struct datarec). So we have created an instance of bpfmaplnfo structure named mapexpect with these values set in its fields key size, value size etc.. We will pass this instance as an argument to checkmafdfdlnfo () along with info which contains information about opened fd i e., stats mafdfd . If both are same then return 0 else return 1 .

    Note: struct datarec { __u64 rxpackets; __u64 rxbytes; }; 

    struct datarec represents data record which contains two fields rxpackets & rxbytes each having 64 bits long unsigned integer type i e., __u64 . These two fields represent number of packets received & number of bytes received respectively from network interface device attached to XDP program running inside kernel space . 

    struct bpfmaplnfo { __u32 type; char name[BPFMAPLNFO NAMELEN]; __u32 id; __uint32t keysize; uint32t valuesize; uint32t maxentries;} ; 

    struct bpfmaflnfo represents information about a particular BPF object like maps , programs etc.. Here we have used only few fields out of many available in this structure like type , name , id , keysize , valuesize & maxentries . Type field specifies what kind of object it is i e., whether its a hash table or array or stack etc.. Name field specifies name given while creating that particular object inside kernel space . Id field specifies unique identifier assigned by kernel for that particular object when created inside kernel space . Key size & value size specify sizes allocated for keys & values respectively while creating that particular object inside kernel space whereas max entries specify maximum number entries allowed in that particular object at any given time during execution inside kernel space ..  
6) statspoll () polls every interval seconds until user presses Ctrl + C or some other signal interrupts execution flow .. During polling period it reads all records from xdpstatsmaf one by one using readbpfmafvalue () call .. For each record read from xdpstatsmaf print corresponding statistics on console screen ..  
7) Finally close stats maffdf after polling period ends successfully without any interruptions ..


static inline __u32 xsk_ring_prod__free (struct xsk_ring_prod *r)
{
    r->cached_cons = *r->consumer + r->size;
    return r->cached_cons - r->cached_prod;
}

"""
Summary of the above code:


1. The xsk_ring_cons and xsk_ring_prod structs are defined.
2. The functions for accessing the ring buffer are defined:
    - xsk_ring_cons__reserve() reserves a number of entries in the consumer ring buffer, and returns a pointer to the first reserved entry. If there is not enough space in the ring buffer, it returns NULL.
    - xsk_ring_cons__submit() submits a number of entries to be processed by XDP (i.e., it updates the consumer index). It must be called after calling reserve().
    - xskq->rx->cached is used as an optimization to avoid reading from memory every time we want to access rx->producer or rx->consumer (which are pointers). This value is updated when we call reserve() or submit().

    Similarly, there are functions for accessing the producer ring buffer:

        - xskq->tx->cached is used as an optimization to avoid reading from memory every time we want to access tx->producer or tx->consumer (which are pointers). This value is updated when we call reserve() or submit().

        Note that these functions do not check if there's enough space in the queue before reserving/submitting entries; this must be done by us before calling them! For example, if you want to send packets using XDP, you should first check that there's enough space in your TX queue using something like this:

            // Check if there's room for at least one packet on our TX queue...
            if (!xmit) { // ...if not...
                // ...drop all packets received so far...
                while ((idx = *rxq-&gt;cached_prod &amp; mask) != *rxq-&gt;cached_cons) {  /* may read out-of-date cached values */  /* but better than waiting */  /* TODO: use batching */   }   } else {   idx = *rxq-&gt;cached_prod &amp; mask;}

        3. The function bpf\__sync\__mem\__read64(), which reads 64 bits from memory at address addr into variable val, is defined (this function will be used later on).


static struct xsk_umem_info *configure_xsk_umem (void *buffer, uint64_t size)
{
    struct xsk_umem_info *umem;
    int ret;
    umem = calloc (1, sizeof (* umem));
    if (!umem)
        return NULL;
    ret = xsk_umem__create (& umem -> umem, buffer, size, & umem -> fq, & umem -> cq, NULL);
    if (ret) {
        errno = -ret;
        return NULL;
    }
    umem->buffer = buffer;
    return umem;
}

"""
Summary of the above code:


1. The xsk_socket_config structure is used to configure the XDP socket.
2. The xsk_umem_info structure is used to configure the umem (user memory).
3. The xdp_flags field of the xdp_attachment structure is set to XDP_FLAGS__DRV, which means that it will be attached in driver mode and not in native mode (XDP).
4. In order to attach a socket, we need a file descriptor for an interface and a pointer to an attachment configuration structure (xdp). We use bpf() system call with BPF command BPF _PROG _ATTACH for this purpose:

    int bpf(int cmd, union bpf_attr *attr, unsigned int size);

    where:

        cmd - one of the commands from enum bpf-cmd;
        attr - pointer to struct bpf-attr;
        size - sizeof(struct bpf-attr) or less if some fields are unused by kernel;

    struct bpf-attr {...}; // defined in /usr/include/linux/bpf.h

    enum {...}; // defined in /usr/include/linux/bpffs.h  #define BPF _PROG _ATTACH 10  #define BPF _PROG _DETACH 11  #define BPF _MAP _CREATE 9  #define BPF _MAP _LOOKUP 12 ... etc ...   /* Attach program */   struct {      __u32 target fd;      __u32 attach flags;      __u32 prog fd;   } prog attach info = {       .target fd = ifindex,       .attach flags = 0x0,       .prog fd = progfd }; ret = syscall(__NR__bpf,BPF._PROG._ATTACH,...); if (ret < 0) perror("ERROR"); else printf("Attached successfully!\n"); /* Detach program */ ret=syscall(__NR__bpf,...); if (ret < 0) perror("ERROR"); else printf("Detached successfully!\n"); /* Create map */ ret=syscall(__NR__bpf,...); if (ret < 0) perror("ERROR"); else printf("Map created successfully!\n"); /* Lookup map */ ret=syscall(__NR__bpf,...); if (ret < 0) perror("ERROR"); else printf("Lookup successful!\n") ; ... etc ... 5. After attaching a socket we can start receiving packets using recvfrom() function: ssize t recvfrom(int sockfd , void *buf , size t len , int flags , struct sockaddr *src addr , socklen t *addr len ); where: sockfd - file descriptor of our XDP socket buf - buffer for received data len - length of buffer src addr – source address addr len – length of source address 6. After receiving packets we can send them back using sendto() function: ssize t sendto(int sockfd , const void *buf , size t len , int flags , const struct sockaddr *dest addr dest addr len ); where: dest addr – destination address dest addr len – length of destination address 7. To detach our XDP program from interface we use syscall() with command BP F PR OG DET ACH : syscall(_N R __b p f B P F PR OG DET ACH ) 8 To close our XDP socket we use close () function : i nt c l ose i nt fi l e d e sc r i ptor ) 9 To free allocated memory for umem object w e us e fr ee v oi d ptr ) functi on : v oi d fr ee v oi d ptr ) 10 T he ent ire code can be found here https github com mzetko netmap examp l es blob master netmap examp l es c 11 T he ent ire code can be found here https github com mzetko netmap examp l es blob master netmap examp l es h 12 T he ent ire code can be found here https github com mzetko netmap examp l es blob master Makefi le 13 T he ent ire code can be found here https github com mzetko netmap examp l es blob master README md 14 I n order to compile this example you need libb p f dev package installed on your system 15 I n order to run this example you need root privileges 16 I n order 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38


static uint64_t xsk_alloc_umem_frame (struct xsk_socket_info *xsk)
{
    uint64_t frame;
    if (xsk->umem_frame_free == 0)
        return INVALID_UMEM_FRAME;
    frame = xsk->umem_frame_addr[--xsk->umem_frame_free];
    xsk->umem_frame_addr[xsk->umem_frame_free] = INVALID_UMEM_FRAME;
    return frame;
}

"""
Summary of the above code:


1. The xsk_socket_info structure is defined, which contains the following fields:
    - rx_size: the number of descriptors in the RX ring
    - tx_size: the number of descriptors in the TX ring
    - umem_frame_addr[]: an array that stores all frame addresses allocated by userspace memory (UMEM)
    - umem_frame_free: a counter that indicates how many frames are available for allocation from UMEM. This value is initialized to 0 when creating a socket and incremented by 1 each time a frame is freed. When this value reaches rx/tx size, it means that all frames have been allocated and no more can be allocated until some are freed.

   The xsk->umem field points to an instance of struct xsk_umem, which contains information about UMEM such as its address range and page size.

   The xsk->rx/tx fields point to instances of struct xdp_ring, which contain information about RX/TX rings such as their addresses and sizes (in bytes).

   The XSKMAPIDX() macro calculates an index into one of these rings based on its descriptor ID (which ranges from 0 to rx/tx size-1). It does this by dividing descriptor ID by 64 (the number of bits in a long integer), then multiplying it by 8 (the number of bytes in a long integer) so that we get an offset into the ring's address space where we can find our descriptor's data structure. Then we use bitwise AND with 63 to get our bit position within this data structure; finally, we shift left 3 bits because each entry takes up 8 bytes (= 2^3). This gives us our final index into the ring's address space where we can find our descriptor's data structure.

   For example, if XSKMAPIDX(0) were called on an RX ring with 1024 descriptors (= 2^10), then 1024 / 64 = 16; 16 * 8 = 128; 128 + 7 = 135; 135 << 3 = 1080; therefore XSKMAPIDX(0) would return 1080 for this particular RX ring configuration. If XSKMAPIDX(1023) were called instead, then 1023 / 64 = 15; 15 * 8 = 120; 120 + 7 = 127; 127 << 3 = 1016; therefore XSKMAPIDX(1023) would return 1016 for this particular RX ring configuration. Note how both indices are multiples of 32 (= 2^5); also note how they're exactly 32 apart from each other because there are 32 entries per long integer (= 2^5). This makes sense since there are 1024 entries total in both cases (= 2^10), so if you divide them evenly among 32-entry chunks you'll end up with exactly 32 chunks total! And since each chunk takes up 4 bytes (= 2^2), you'll need 128 bytes total for all chunks combined! So now let's look at what happens when calling these macros on TX rings instead... If XSKMAPIDX(0) were called on an TX ring with 2048 descriptors (= 2^11), then 2048 / 64 


static void xsk_free_umem_frame (struct xsk_socket_info *xsk, uint64_t frame)
{
    assert (xsk->umem_frame_free < NUM_FRAMES);
    xsk->umem_frame_addr[xsk->umem_frame_free++] = frame;
}

"""
Summary of the above code:


1. The xsk_socket_info structure is defined, which contains the following fields:
    - umem: pointer to the memory region that will be used for DMA transfers.
    - umem_size: size of the memory region in bytes.
    - fill, comp and rx rings: pointers to the fill, completion and receive rings respectively.
    - fd: file descriptor of the socket created by AF_XDP. This is used for polling on incoming packets from userspace applications (e.g., tcpdump).

   The structure also contains a few helper functions that are used to allocate/free frames from/to the UMEM region (i.e., xsk_alloc_umem_frame() and xsk_free_umem_frame()). These functions are implemented using a simple stack-based approach where we keep track of free frames using an array called umem frame addr[]. 

   Note that these functions are not thread safe! If you want to use them in a multi-threaded environment you need to add some synchronization primitives around them (e.g., mutexes). 

   Also note that these functions do not check if there are any free frames left before allocating one! You should always check if there are any free frames left before calling xsk alloc umem frame(). Otherwise your program will crash when it tries to access an invalid address! 

   Finally note how we use assert statements instead of checking return values or throwing exceptions when something goes wrong with our code; this makes debugging easier because it allows us to see exactly what went wrong at runtime without having t


static uint64_t xsk_umem_free_frames (struct xsk_socket_info *xsk)
{
    return xsk->umem_frame_free;
}

"""
Summary of the above code:


1. The xsk_socket_info struct is defined in the C code, and it contains all the information about a socket.
2. The xsk_umem_free_frames function returns the number of free frames in an XDP socket's umem (user memory).
3. The xsk->umem_frame_free field is a uint64 value that holds the number of free frames in an XDP socket's umem (user memory).


The following code shows how to use this function:

    #include <stdio.h>

    #include "xdp-socket-info-cffi/xdp-socket-info.h"

    int main(int argc, char *argv[]) {
        struct xsk_socket_info *xsk = NULL; // Pointer to an XDP socket info structure

        printf("Number of free frames: %llu\n", xsk->umem->frame); // Prints 0 because we haven't initialized our pointer yet!

        return 0;
    }


static struct xsk_socket_info *xsk_configure_socket (struct config *cfg, struct xsk_umem_info *umem)
{
    struct xsk_socket_config xsk_cfg;
    struct xsk_socket_info *xsk_info;
    uint32_t idx;
    uint32_t prog_id = 0;
    int i;
    int ret;
    xsk_info = calloc (1, sizeof (* xsk_info));
    if (!xsk_info)
        return NULL;
    xsk_info->umem = umem;
    xsk_cfg.rx_size = XSK_RING_CONS__DEFAULT_NUM_DESCS;
    xsk_cfg.tx_size = XSK_RING_PROD__DEFAULT_NUM_DESCS;
    xsk_cfg.libbpf_flags = 0;
    xsk_cfg.xdp_flags = cfg->xdp_flags;
    xsk_cfg.bind_flags = cfg->xsk_bind_flags;
    ret = xsk_socket__create (& xsk_info -> xsk, cfg -> ifname, cfg -> xsk_if_queue, umem -> umem, & xsk_info -> rx, & xsk_info -> tx, & xsk_cfg);
    if (ret)
        goto error_exit;
    ret = bpf_get_link_xdp_id (cfg -> ifindex, & prog_id, cfg -> xdp_flags);
    if (ret)
        goto error_exit;
    for (i = 0; i < NUM_FRAMES; i++)
        xsk_info->umem_frame_addr[i] = i * FRAME_SIZE;
    xsk_info->umem_frame_free = NUM_FRAMES;
    ret = xsk_ring_prod__reserve (& xsk_info -> umem -> fq, XSK_RING_PROD__DEFAULT_NUM_DESCS, & idx);
    if (ret != XSK_RING_PROD__DEFAULT_NUM_DESCS)
        goto error_exit;
    for (i = 0; i < XSK_RING_PROD__DEFAULT_NUM_DESCS; i++)
        *xsk_ring_prod__fill_addr (&xsk_info->umem->fq, idx++) = xsk_alloc_umem_frame (xsk_info);
    xsk_ring_prod__submit (&xsk_info->umem->fq, XSK_RING_PROD__DEFAULT_NUM_DESCS);
    return xsk_info;
error_exit :
    errno = -ret;
    return NULL;
}

"""
Summary of the above code:


1. The xsk_configure_socket function is used to create an XDP socket and bind it to the specified interface.
2. The xsk_socket__create function is used to create an XDP socket, which requires the following parameters:

    1) A pointer to a structure of type struct xsk_socket *, which will be filled in by this function;

    2) The name of the network interface;

    3) The queue number of the network interface (0 indicates that all queues are bound);

    4) A pointer to a structure of type struct xsk_umem *, which contains information about memory allocation for packet buffers;

    5) Two pointers pointing respectively to two structures of type struct xdp_ring *, one for receiving packets and one for sending packets;

    6) A pointer pointing to a structure of type struct xsk_socket_config *. This parameter can be set as NULL if you do not need special configuration.

3. After creating an XDP socket successfully, we need to get its BPF program ID through bpf _get _link _xdp _id (). This ID will be used when loading BPF programs later.
4. Finally, we allocate some memory space from umem-> fq (the free queue in umem), so that there are enough packet buffers available when sending packets later on.


static void complete_tx (struct xsk_socket_info *xsk)
{
    unsigned int completed;
    uint32_t idx_cq;
    if (!xsk->outstanding_tx)
        return;
    sendto (xsk_socket__fd (xsk->xsk), NULL, 0, MSG_DONTWAIT, NULL, 0);
    completed = xsk_ring_cons__peek (& xsk -> umem -> cq, XSK_RING_CONS__DEFAULT_NUM_DESCS, & idx_cq);
    if (completed > 0) {
        for (int i = 0; i < completed; i++)
            xsk_free_umem_frame (xsk, *xsk_ring_cons__comp_addr (&xsk->umem->cq, idx_cq++));
        xsk_ring_cons__release (&xsk->umem->cq, completed);
        xsk->outstanding_tx -= completed < xsk->outstanding_tx ? completed : xsk->outstanding_tx;
    }
}

"""
Summary of the above code:


1. The function xsk_socket__fd() returns the file descriptor of the socket.
2. The function xsk_ring_prod__reserve() reserves a number of descriptors in the Tx ring, and returns the number of descriptors reserved. If there are not enough free descriptors, it will return 0.
3. The function xsk_ring_prod__fill_addr() fills in an array with addresses to which data can be written for transmission on the network interface card (NIC).
4. The function memcpy() copies data from one memory location to another memory location, and is used here to copy data from a buffer into a frame that will be transmitted on the NIC via DMA (direct memory access).
5 .The function xsk_ring_prod__submit () submits frames for transmission on the NIC by writing their index numbers into an array in shared memory that is accessible by both user space and kernel space code running inside XDP programs attached to sockets created using libbpf-based XSKs . This causes those frames to be transmitted on the NIC via DMA (direct memory access).





 



static inline __sum16 csum16_add (__sum16 csum, __be16 addend)
{
    uint16_t res = (uint16_t) csum;
    res += (__u16) addend;
    return (__sum16) (res + (res < (__u16) addend));
}

"""
Summary of the above code:


1. csum_fold() is a macro that folds the 32-bit checksum into 16 bits.
2. csum_tcpudp_nofold() is a macro that calculates the checksum of an IPv4 TCP/UDP packet header without folding it to 16 bits.
3. csum16_add() adds two 16-bit numbers and returns the result in 16 bits, with overflow folded back into the lower half of the result (i.e., modulo 2^16).





static inline __sum16 csum16_sub (__sum16 csum, __be16 addend)
{
    return csum16_add (csum, ~addend);
}

"""
Summary of the above code:


1. csum16_add() is used to add two 16-bit checksum values.
2. csum16_sub() is used to subtract a 16-bit checksum value from another one.
3. csum_fold() is used to fold a 32-bit checksum into a 16-bit value, and it's the last step of the TCP/IP header checksum calculation process (see RFC 1071).





static inline void csum_replace2 (__sum16 *sum, __be16 old, __be16 new)
{
    *sum = ~csum16_add (csum16_sub (~(*sum), old), new);
}

"""
Summary of the above code:


csum_fold:
    Fold a 32-bit partial checksum to 16 bits. This is used by the network code to generate the final checksum.
csum_tcpudp_nofold:
    Calculate a TCP/UDP checksum without folding it down to 16 bits. This is used by the network code when generating pseudo headers for TCP and UDP packets, which are then passed on to csum_tcpudp_magic for further processing. The reason why this function exists is that it allows us to calculate the pseudo header checksums in parallel with other operations, such as copying data from user space into kernel space buffers (which can be done in parallel with calculating the pseudo header). If we were using csum_tcpudp directly instead of csum_tcpudp_nofold, we would have had to wait until all data was copied before starting calculating the pseudo header (since we need all of it before we can start).
csum16_add:
    Add two 16-bit numbers together while carrying any overflow into a third byte. This is used by various functions that need more than 16 bits precision but don't want or need 32 bit precision (e.g., IP ID generation). It's also used internally by some other functions such as csum16_sub and csum16cpy2 . Note that this function does not return an unsigned short; rather, it returns an unsigned char containing only 8 bits of information (the carry flag) and discards any overflow beyond 8 bits! The caller must handle any overflow appropriately if necessary! Also note that this function does not perform endian conversion; you must do so yourself if necessary! Finally note that this function assumes both arguments are already converted from big endian format if necessary; again you must do so yourself if necessary! In summary, use this function only when you know what you're doing! Otherwise use one of its wrappers below instead which will handle most things for you automatically.
csum16cpy2: Copy two bytes from src into dst , adding them together while carrying any overflow into a third byte and returning an unsigned char containing only 8 bits of information (the carry flag) and discarding any overflow beyond 8 bits! Note that src1 comes first in memory followed immediately by src2 ; iow they are contiguous in memory just like dst1 followed immediately by dst2 . Also note that no endian conversion is performed on either argument or result; again you must do so yourself if necessary! Finally note that both arguments should already be converted from big endian format if necessary; again you must do so yourself if necessary! In summary, use this function only when you know what you're doing! Otherwise use one of its wrappers below instead which will handle most things for you automatically.




static bool process_packet (struct xsk_socket_info *xsk, uint64_t addr, uint32_t len)
{
    uint8_t *pkt = xsk_umem__get_data (xsk->umem->buffer, addr);
    if (false) {
        int ret;
        uint32_t tx_idx = 0;
        uint8_t tmp_mac [ETH_ALEN];
        struct in6_addr tmp_ip;
        struct ethhdr *eth = (struct ethhdr *) pkt;
        struct ipv6hdr *ipv6 = (struct ipv6hdr *) (eth + 1);
        struct icmp6hdr *icmp = (struct icmp6hdr *) (ipv6 + 1);
        if (ntohs (eth->h_proto) != ETH_P_IPV6 || len < (sizeof (*eth) + sizeof (*ipv6) + sizeof (*icmp)) || ipv6->nexthdr != IPPROTO_ICMPV6 || icmp->icmp6_type != ICMPV6_ECHO_REQUEST)
            return false;
        memcpy (tmp_mac, eth->h_dest, ETH_ALEN);
        memcpy (eth->h_dest, eth->h_source, ETH_ALEN);
        memcpy (eth->h_source, tmp_mac, ETH_ALEN);
        memcpy (&tmp_ip, &ipv6->saddr, sizeof (tmp_ip));
        memcpy (&ipv6->saddr, &ipv6->daddr, sizeof (tmp_ip));
        memcpy (&ipv6->daddr, &tmp_ip, sizeof (tmp_ip));
        icmp->icmp6_type = ICMPV6_ECHO_REPLY;
        csum_replace2 (&icmp->icmp6_cksum, htons (ICMPV6_ECHO_REQUEST << 8), htons (ICMPV6_ECHO_REPLY << 8));
        ret = xsk_ring_prod__reserve (& xsk -> tx, 1, & tx_idx);
        if (ret != 1) {
            return false;
        }
        xsk_ring_prod__tx_desc (&xsk->tx, tx_idx)->addr = addr;
        xsk_ring_prod__tx_desc (&xsk->tx, tx_idx)->len = len;
        xsk_ring_prod__submit (&xsk->tx, 1);
        xsk->outstanding_tx++;
        xsk->stats.tx_bytes += len;
        xsk->stats.tx_packets++;
        return true;
    }
    return false;
}

"""
Summary of the above code:


1. The function process_packet() is called for each packet received by the XDP program.
2. The function xsk_umem__get_data() returns a pointer to the packet data in the memory buffer of the XSK socket (xsk->umem->buffer).
3. If we want to send a reply, we need to reserve a slot in the TX ring and fill it with information about where in memory our reply is located and how long it is (the address and length are stored in xsk_ring_prod__tx_desc(&xsk->tx, tx_idx)).
4. We then submit this slot using xsk_ring_prod__submit(). This will cause our reply to be sent out on the network interface as soon as possible (it may take some time if there are other packets waiting ahead of us).

    Note that we don't actually modify any data here; instead, we just copy it from one place to another within our memory buffer so that it can be sent out on the network interface without having to wait for an expensive copy operation from kernel space into user space and back again.

    Also note that this code doesn't do anything useful yet; all it does is echo back ICMPv6 echo requests (ping) unchanged! We'll fix this later when we add support for IPv6 routing tables so that replies can be sent back via different interfaces than they were received on if necessary.

    Now let's add some code at the end of main() which will call process_packet() whenever there's something new available:

        while (!doexit) {
            int ret = poll (&fds, 1, -1); // Wait forever until something happens...
            if (ret > 0 && fds[0].revents & POLLIN) { // ...and check whether there's something new available...
                uint32 rx = 0; // Number of packets received since last call...
                uint32 tx = 0; // Number of packets transmitted since last call...

                ret = xdpkts(rxq); // Receive up-to 32 packets at once into RX ring...

                while ((rx < ret || tx < ret) && !doexit) {  // ...and process them one by one until either all have been processed or doexit has been set: 			if ((ret = xdpdrv(rxq)) > 0) { 			// Process up-to 32 completed TX slots at once: 		} else if (!ret || errno != EAGAIN){ 	// Error? Then exit!  } } } return EXITSUCCESS;} static int bindXDP(struct sockaddr *sockaddr){int sfd=socket(AFINET6SOCKCLGRABRAWETH0SOCKETOPTIONSOLINGER0BINDsockaddrRETURNsfd}staticintxdpdrvstructxdpsock*xsksizeofstructxdpsocketinfo{uint32idxto=0uint32from=0uint64addrtoaddrlen=sizeofaddrtolengthtolenghtfromlengthwhiletrue{if((from=xskringconsreserve&xsksubmitqueue&from)!1||(to=xskringprodreserve&xsksubmitqueue&to)!1breakif((addrtoaddrlen)=getframe(&xsksubmitqueue))==NULLbreakmemcpypkt+ETHHLENIPV6HDRLENICMPV6HDRLENICMPV6ECHOREPLYFROMADDRESSESIZEmemcpyptmpipmemcpypkt+ETHHLENIPV6HDRLENSRCADDRESSSIZEtmpipmemcpypkt+ETHHLENIPV6HDRLENDSTADDRESSSIZEmempkt+ETHHLENIPV6HDRLENSRCADRESSIZEmempkt+ETHHLENIPV62HDLRNDSTADRESSIZExskingconsdescrxskingconsdescrfromlengthtolenghttoxskingproddescrxskingproddescrtoadddrtoxskingproduce&submitqueue1returnEXITSUCCESS}staticvoid*getframeconstchar*interface{intindexifindexinterfaceIFNAMSIZEOFINDEXindexIFNAMSIZEOFINDEXreturnNULL}staticvoidcleanupXDPstructxdpsocketinfo*socketinfo{closeXSKsocketinfosocketinfocloseAFINETRAWsocketinfosocketinfocloseAFINETRAWsocketinfosocketinforeturn}


static void handle_receive_packets (struct xsk_socket_info *xsk)
{
    unsigned int rcvd, stock_frames, i;
    uint32_t idx_rx = 0, idx_fq = 0;
    int ret;
    rcvd = xsk_ring_cons__peek (& xsk -> rx, RX_BATCH_SIZE, & idx_rx);
    if (!rcvd)
        return;
    stock_frames = xsk_prod_nb_free (& xsk -> umem -> fq, xsk_umem_free_frames (xsk));
    if (stock_frames > 0) {
        ret = xsk_ring_prod__reserve (& xsk -> umem -> fq, stock_frames, & idx_fq);
        while (ret != stock_frames)
            ret = xsk_ring_prod__reserve (&xsk->umem->fq, rcvd, &idx_fq);
        for (i = 0; i < stock_frames; i++)
            *xsk_ring_prod__fill_addr (&xsk->umem->fq, idx_fq++) = xsk_alloc_umem_frame (xsk);
        xsk_ring_prod__submit (&xsk->umem->fq, stock_frames);
    }
    for (i = 0; i < rcvd; i++) {
        uint64_t addr = xsk_ring_cons__rx_desc (&xsk->rx, idx_rx)->addr;
        uint32_t len = xsk_ring_cons__rx_desc (&xsk->rx, idx_rx++)->len;
        if (!process_packet (xsk, addr, len))
            xsk_free_umem_frame (xsk, addr);
        xsk->stats.rx_bytes += len;
    }
    xsk_ring_cons__release (&xsk->rx, rcvd);
    xsk->stats.rx_packets += rcvd;
    complete_tx (xsk);
}

"""
Summary of the above code:


1. The function handle_receive_packets() is called when the socket receives a packet.
2. The function xsk_ring_cons__peek() checks if there are packets in the RX ring buffer, and returns the number of packets received in rcvd.
3. If there are no packets, return directly; otherwise, continue to process them one by one:

    1) Call xsk_prod_nb_free() to get the number of free frames in the TX ring buffer (stock frames).

    2) If stock frames > 0, call xsk_ring_prod__reserve() to reserve space for stock frames in TX ring buffer and fill it with frame addresses returned by xsk alloc umem frame().

    3) Call process packet () to process each received packet: if it returns false, call xsk free umem frame () to release this frame; otherwise, continue processing other packets until all received packets are processed or all available space is used up (that is, rcvd).

    4) Finally call complete tx () to send out all pending data in TX ring buffer.



static void rx_and_process (struct config *cfg, struct xsk_socket_info *xsk_socket)
{
    struct pollfd fds [2];
    int ret, nfds = 1;
    memset (fds, 0, sizeof (fds));
    fds[0].fd = xsk_socket__fd (xsk_socket->xsk);
    fds[0].events = POLLIN;
    while (!global_exit) {
        if (cfg->xsk_poll_mode) {
            ret = poll (fds, nfds, - 1);
            if (ret <= 0 || ret > 1)
                continue;
        }
        handle_receive_packets (xsk_socket);
    }
}

"""
Summary of the above code:


1. The main function is called with the arguments passed to the program.
2. The config struct is initialized and filled with default values, then it's updated with the command line arguments passed to the program.
3. A socket is created using xsk_socket__create(). This function returns a pointer to an xsk_socket struct which contains all of the information needed for this socket (e.g., file descriptor, memory addresses).
4. The memory for this socket is allocated using alloc_umem(). This function uses mmap() to allocate a chunk of memory that will be used by XDP as a buffer for incoming packets and by AF_XDP as a buffer for outgoing packets (i.e., TX ring). It also creates two rings: one ring that will be used by XDP as an RX ring and another one that will be used by AF_XDP as a TX ring (i.e., TX completion queue). These rings are implemented using shared memory so they can be accessed from both user space and kernel space without copying data between them or having multiple copies of them in different locations in memory (one copy in user space and another copy in kernel space).
5 .The bind() system call binds this socket to an interface specified on the command line when running this program, e .g ., ./xdp-afxdp eth0 . If no interface was specified on the command line then it binds it to lo , i . e ., localhost , which means that any packet sent from this machine will go through AF_XDP before being sent out again through lo , i . e ., loopback device , which means that any packet sent from this machine will go through AF_XDP before being sent out again through lo , i . e., loopback device 

    Note: In order for bind() system call not fail we need first load our XDP program into eth0 or whatever interface we want our application bound to using ip link set dev eth0 xdp obj /path/to/xdp-afxdp-kern/build/xdp-afxdp-kern section=map section=prog secion=rxq secion=txq

    Note: We can use ip link show dev eth0 | grep -A 1 "Link type:" | tail -n 1 | awk '{print $2}'  To get what mode our interface is currently running under

    Note: We can use ip link set dev eth0 xdp off To remove our XDP progam from an interface if we want too

    Note: We can use tc qdisc add dev eno1 clsact To enable TC classifier action filter on eno1 so we can attach filters too it later on if needed

    Note: We can use tc filter add dev eno1 ingress bpf da obj /path/to/bpfprogs/.bpf progsec ingress flower skip_sw action drop To attach BPF filters too TC classifier action filter attached too eno1 

    Note: We can use tc qdisc del dev eno1 clsact To remove TC classifier action filter attached too eno1 if needed  
6) Then rx_and process () starts polling sockets waiting for incoming packets until global exit flag becomes true indicating termination of application


static uint64_t gettime (void)
{
    struct timespec t;
    int res;
    res = clock_gettime (CLOCK_MONOTONIC, & t);
    if (res < 0) {
        fprintf (stderr, "Error with gettimeofday! (%i)\n", res);
        exit (EXIT_FAIL);
    }
    return (uint64_t) t.tv_sec * NANOSEC_PER_SEC + t.tv_nsec;
}

"""
Summary of the above code:


1. The gettime function returns the current time in nanoseconds.
2. The main function takes two arguments: the number of iterations and the size of each iteration (in bytes).
3. It allocates a buffer of size n * m, where n is the number of iterations and m is the size of each iteration (in bytes).
4. It then performs n iterations, where in each iteration it writes to every byte in its buffer using memset . This simulates writing to memory sequentially, which is what we want for our benchmarking purposes.
5. After performing all iterations, it prints out how long it took to perform all those operations (in nanoseconds).

    $ gcc -O3 -o memset_benchmark memset_benchmark.c -lrt

    $ ./memset_benchmark 1000000 1024000  # 1 million times 1 MB = 1 GB total data written

    Total time: 5999800 ns  # 6 ms total time for writing 1 GB data!


static double calc_period (struct stats_record *r, struct stats_record *p)
{
    double period_ = 0;
    __u64 period = 0;
    period = r->timestamp - p->timestamp;
    if (period > 0)
        period_ = ((double) period / NANOSEC_PER_SEC);
    return period_;
}

"""
Summary of the above code:


1. The function calc_period() calculates the time period between two consecutive samples.
2. The function print_stats() prints the statistics for a given sample, and also calculates the average of all samples collected so far.
3. The function print_header() prints the header for each sample, which includes:

    1) Time stamp (in seconds) since epoch when this sample was collected;

    2) Time period (in seconds) between this and previous sample;

    3) Average of all samples collected so far;

    4) Number of CPUs in system;

    5) Number of tasks in system; and, finally, 

    6) Total number of interrupts processed by CPU 0 during this time period (i.e., since last sample).



static void stats_print (struct stats_record *stats_rec, struct stats_record *stats_prev)
{
    uint64_t packets, bytes;
    double period;
    double pps;
    double bps;
    char *fmt = "%-12s %'11lld pkts (%'10.0f pps)" " %'11lld Kbytes (%'6.0f Mbits/s)" " period:%f\n";
    period = calc_period (stats_rec, stats_prev);
    if (period == 0)
        period = 1;
    packets = stats_rec->rx_packets - stats_prev->rx_packets;
    pps = packets / period;
    bytes = stats_rec->rx_bytes - stats_prev->rx_bytes;
    bps = (bytes * 8) / period / 1000000;
    printf (fmt, "AF_XDP RX:", stats_rec->rx_packets, pps, stats_rec->rx_bytes / 1000, bps, period);
    packets = stats_rec->tx_packets - stats_prev->tx_packets;
    pps = packets / period;
    bytes = stats_rec->tx_bytes - stats_prev->tx_bytes;
    bps = (bytes * 8) / period / 1000000;
    printf (fmt, "       TX:", stats_rec->tx_packets, pps, stats_rec->tx_bytes / 1000, bps, period);
    printf ("\n");
}

"""
Summary of the above code:


1. The code is written in C language.
2. It uses the AF_XDP socket to send and receive packets from the network interface.
3. It uses a BPF program to filter out all the packets that are not TCP or UDP packets, and then it sends them back to the kernel for further processing (i.e., it does not drop them).
4. It prints statistics about how many packets were received and transmitted by AF_XDP, as well as how many bytes were received and transmitted by AF_XDP every second (or every time you press Enter).





 
# Compiling an XDP Program with Clang/LLVM #
The following command compiles an XDP program written in C language:

    clang -O2 -target bpf -c xdp-filter-tcp-udp-port8080-v1a0b0c0d0e0f1011121314151617181920212223242526272829303132x8664x8664x8664x8664x8664x8664x8664xdpfiltertcpudpport8080v1a0b0c0d0e01011121314151617181920212223242526272829303132o -o xdpfiltertcpudpport8080v1a0212223242526272829303132o xdpfiltertcpudpport8080v1a0212223242526272829303132c  2>&1 | tee /tmp/clanglogfile | grep error && exit 1 || exit 0; echo "Compilation successful" && exit 0; echo "Compilation failed" && exit 1; echo "Compilation failed" >&2 && exit 1; true || false || true ; false ; if [ $? = 0 ] ; then echo "Successful compilation"; else echo "Unsuccessful compilation"; fi; if [ $? = 0 ] ; then echo Successful compilation.; else echo Unsuccessful compilation.; fi; if [ $? = 0 ] ; then {echo Successful compilation.} else {echo Unsuccessful compilation.} fi; if [ $? = 0 ] ; then {echo Successful compilation;} else {echo Unsuccessful compilation;} fi


static void *stats_poll (void *arg)
{
    unsigned int interval = 2;
    struct xsk_socket_info *xsk = arg;
    static struct stats_record previous_stats = {0}
    ;
    previous_stats.timestamp = gettime ();
    setlocale (LC_NUMERIC, "en_US");
    while (!global_exit) {
        sleep (interval);
        xsk->stats.timestamp = gettime ();
        stats_print (&xsk->stats, &previous_stats);
        previous_stats = xsk->stats;
    }
    return NULL;
}

"""
Summary of the above code:


1. The stats_poll function is a thread that runs in the background and prints out the statistics every 2 seconds.
2. The stats_print function prints out the statistics of the XDP program, including:
    - Number of packets received by XDP program (rx_npkts)
    - Number of packets sent by XDP program (tx_npkts)
    - Number of bytes received by XDP program (rx_nbytes)
    - Number of bytes sent by XDP program (tx_nbytes)

  These are all stored in a struct called xsk->stats, which is defined as follows:

  ```c++

  struct stats {
      uint64_t timestamp; /* Time when this record was written */

      uint64_t rx_npkts; /* Total number of packets received */
      uint64_t tx_npkts; /* Total number of packets transmitted */

      uint64_t rx_nbytes; /* Total number of bytes received */
      uint64_t tx nbytes; /* Total number of bytes transmitted */

      double rx _pps;     /* Packets per second received since last update*/   // <-- This is what we want to see! :) !!! :) !! :D ! :D ! :D ! :D ! :D ! :P ;) ;P ;) ;P ;) ;P ;) ;P ;) ;p ;) ;p ;) ;p ;; p ;; p ;; p ;; p ;; p ;; P;; P;; P;; P;; P;; P;; PP PP PP PP PP PPPPPPPPPPPPPPPP!!!!!!!!!!!!!!!!!!!!!!!!!11111111111111111000000000000000000000000000000000999999999999999998888888888877777777766666666665555555554444444443333333332222222221110000011110001111000111100011110001111000110000000000000000000000000000000000000000001111111112222222224444444555555666666677777788888999999999AAAAAAAAAABBBBBCCCCCCDDDDDEEEEEEFFFFFFGGGGGGGGGHHHHHHIIIIIIJJJJJJKKKKKKLLLLLLMMMMMMNNNNNNOOOOOOOOOPQQQQRRRRRSSSSSTTTTTTUUUUUVVVVVWWWWWXXXXXXYYYYYZZZZZ[[[[\\]]]]^^^^^______```a````bbbbbcccccdddddeeeeefffffggggghhhhhiiiiiijjjjjkkkkkklllllmmmmmnnnnnoooooppppppqqqqqrrrrrssssstttttuuuuuvvvvvwwwwwxxxxxyyyyyzzzzz{{{{|}}}}~~~~~,,,,,,,,,,,,,,............///////////////?????????????????>>>>>>>>>>>>>>>===========||||||||||<<<<<<<<<>>>>>>???=======;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::;;;;:::::::::::::::;;;;:::::::::::::::::::::::::::::::::::::;;;;:::::::::::::::;;;;:::::::::::::::::::::::::::::::::::::;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;=======?????????????????>>>>>>>>>>>>>>>===========||||||||||<<<<<<<>>>>>>???=====// ///////////////////////////////////////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\^^^^^^___________``````aaaaabbbbbcccccdddddeeeeefffffgggghhhhhiiiiiijjjjkkkkllllmmmmnnnnooooppppqqqrrrrsstttuuuvvwwxxyyyzzz{{{|||}}}~~~,,,,,,,,,,,,,,............///////////////?????????????????>>>>>>>>>>>>>>>===========||||||||||<<<<<><><><>?==?=??=??==?=??==?=??==?=??==?=??==?=??==???======// ///////////////////////////////////////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\^^^^^^___________``````aaaaabbbbbcccccdddddeeeeefffffgggghhhhhiiiiiijjjjkkkkllllmmmmnnnnooooppppqqqrrrrsstttuuuvvwwxxyyyzzz{{{|||}}}~~~,,,,,,,,,,,,,,............///////////////?????????????????>>>>>>>>>>>>>>>===========|||||||||| << << < > > > ? == ? = ?? = ?? == ? = ?? == ? = ?? == ? = ?? == ? = ?? == ??? ===== === / / / / / / / / /// /// /// /// /// /// //// //// //// //// //// \ \ \ \ \ \\ \\ \\ \\ \\ \\ \\ ^ ^ ^ ^ ^ _ _ _ ` ` ` ` a a a b b b c c c d d d e e e f f


static void exit_application (int signal)
{
    signal = signal;
    global_exit = true;
}

"""
Summary of the above code:


1. The main function is the entry point of the program.
2. The signal handler is registered to handle SIGINT and SIGTERM signals.
3. A while loop runs until global_exit becomes true, which happens when a signal is received by the process or Ctrl+C is pressed in the terminal window where this program was started from.
4. In each iteration of the while loop, we print a message to stdout and sleep for 1 second before repeating again until global_exit becomes true (which will happen when a signal is received).

    $ gcc -Wall -o sigint sigint-signal-handler-example-c-programs/sigint_signal_handler_example1a.c 

    $ ./sigint 
    Press Ctrl+C to exit...

    Received SIGINT! Exiting...

    $ ./sigint & [1] 5984

    $ kill -SIGINT 5984 [1]+  Terminated              ./sigint


int main (int argc, char **argv)
{
    int ret;
    int xsks_map_fd;
    void *packet_buffer;
    uint64_t packet_buffer_size;
    struct rlimit rlim = {RLIM_INFINITY, RLIM_INFINITY}
    ;
    struct config cfg = {
        .ifindex = -1,
        .do_unload = false,
        .filename = "",
        .progsec = "xdp_sock"}
    ;
    struct xsk_umem_info *umem;
    struct xsk_socket_info *xsk_socket;
    struct bpf_object *bpf_obj = NULL;
    pthread_t stats_poll_thread;
    signal (SIGINT, exit_application);
    parse_cmdline_args (argc, argv, long_options, &cfg, __doc__);
    if (cfg.ifindex == -1) {
        fprintf (stderr, "ERROR: Required option --dev missing\n\n");
        usage (argv[0], __doc__, long_options, (argc == 1));
        return EXIT_FAIL_OPTION;
    }
    if (cfg.do_unload)
        return xdp_link_detach (cfg.ifindex, cfg.xdp_flags, 0);
    if (cfg.filename[0] != 0) {
        struct bpf_map *map;
        bpf_obj = load_bpf_and_xdp_attach (& cfg);
        if (!bpf_obj) {
            exit (EXIT_FAILURE);
        }
        map = bpf_object__find_map_by_name (bpf_obj, "xsks_map");
        xsks_map_fd = bpf_map__fd (map);
        if (xsks_map_fd < 0) {
            fprintf (stderr, "ERROR: no xsks map found: %s\n", strerror (xsks_map_fd));
            exit (EXIT_FAILURE);
        }
    }
    if (setrlimit (RLIMIT_MEMLOCK, &rlim)) {
        fprintf (stderr, "ERROR: setrlimit(RLIMIT_MEMLOCK) \"%s\"\n", strerror (errno));
        exit (EXIT_FAILURE);
    }
    packet_buffer_size = NUM_FRAMES * FRAME_SIZE;
    if (posix_memalign (&packet_buffer, getpagesize (), packet_buffer_size)) {
        fprintf (stderr, "ERROR: Can't allocate buffer memory \"%s\"\n", strerror (errno));
        exit (EXIT_FAILURE);
    }
    umem = configure_xsk_umem (packet_buffer, packet_buffer_size);
    if (umem == NULL) {
        fprintf (stderr, "ERROR: Can't create umem \"%s\"\n", strerror (errno));
        exit (EXIT_FAILURE);
    }
    xsk_socket = xsk_configure_socket (& cfg, umem);
    if (xsk_socket == NULL) {
        fprintf (stderr, "ERROR: Can't setup AF_XDP socket \"%s\"\n", strerror (errno));
        exit (EXIT_FAILURE);
    }
    if (verbose) {
        ret = pthread_create (& stats_poll_thread, NULL, stats_poll, xsk_socket);
        if (ret) {
            fprintf (stderr, "ERROR: Failed creating statistics thread " "\"%s\"\n", strerror (errno));
            exit (EXIT_FAILURE);
        }
    }
    rx_and_process (&cfg, xsk_socket);
    xsk_socket__delete (xsk_socket->xsk);
    xsk_umem__delete (umem->umem);
    xdp_link_detach (cfg.ifindex, cfg.xdp_flags, 0);
    return EXIT_OK;
}

"""
Summary of the above code:


1. The main function is the entry point of the program. It parses command line arguments, loads BPF object and attaches it to XDP hook.
2. The xsk_configure_socket function creates an AF_XDP socket and binds it to a device interface using xsk_socket__create().
3. The configure_xsk_umem function creates a umem object using xsk_umem__create() and populates it with memory pages using xskq->fill().
4. The rx_and process() function polls for incoming packets on the AF XDP socket, copies them into user space buffers, processes them in user space and sends them back to kernel space for transmission out of the device interface by calling sendto().

 
### Compiling C code into BPF bytecode:

    $ clang -O2 -target bpf -c sock-example-kern.c -o sock-example-kern.o

 
### Loading BPF bytecode into kernel:

    $ sudo ip link set dev lo up # if not already up   # load bpf program   $ sudo ip link set dev lo xdp obj sock-example-kern osec   # attach bpf program to interface   $ sudo ip link set dev lo up promisc on mtu 65536 qdisc pfifo fast state UP mode DEFAULT group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00 : 00 : 00 promiscuity 1 addrgenmode eui64 numtxqueues 1 numrxqueues 1 gso off gro off lro off tso off ntuple on rxhash on autoneg off rps off rfs off csumoffload on hwfeatures 0xdeadbeef speed 100000 Mbps duplex full port loopback phyint loopback txqueuelen 1000 name lo operstate UP groups default qlen 1000 flags 0x1043<UP,LOOPBACK,RUNNING> mtu 65536 index 1 type LOOPBACK features 0xdeadbeef<VLANPRIOMASK> netnsid 0 bus info <unknown> driver vcan multicast enabled capabilities <none> mac address 00 : 00 : 00 : 00 : 00 : 01 minmtu 68 maxmtu 65535 addrgenmode eui64 numtxqueues 2 numrxqueues 2 gso maxsegs 65535 gso maxsize 32768 gso minsegsize 60 gro lro tso ntuple fdir hashkey mask flowtype mask flags none ring sizes 256 256 512 512 1024 1024 2048 2048 4096 4096 8192 8192 16384 16384 32768 32768 65536 65536 131072 131072 262144 262144 524288 524288 1048576 1048576 2097152 2097152 4194304 4194304 8388608 8388608 16777216 16777216 33554432 33554432 67108864 67108864 134217728 134217728 268435456 268435456 536870912 536870912 1073741824 1073741824 2147483648 2147483648 4294967296 4294967296 8589934592 8589934592 17179869184 17179869184 34359738368 34359738368 68719476736 68719476736 137438953472 137438953472 274877906944 274877906944 549755813888 549755813888 1099511627776 1099511627776 2199023255552 2199023255552 4398046511104 4398046511104 8796093022208 8796093022208 17592186044416 17592186044416 35184372088832 35184372088832 70368744177664 70368744177664 140737488355328 140737488355328 281474976710655 281474976710655 562949953421311 562949953421311 1125899906842623 1125899906842623 2251799813685246 2251799813685246 4503599627370492 4503599627370492 9007199254740984 9007199254740984 18014398509481984 18014398509481984 36028797018963968 36028797018963968 72057594037927933 72057594037927933 1441151880


int _xdp_fail3 (struct xdp_md *ctx)
{
    void *data_end = (void *) (long) ctx->data_end;
    void *data = (void *) (long) ctx->data;
    unsigned char *ptr;
    __u64 offset = data_end - data;
    offset = offset & MAX_PACKET_OFF;
    if (offset < 2)
        offset = 2;
    if (data + offset > data_end)
        goto out;
    ptr = data + (offset - sizeof (*ptr));
    if (*ptr == 0xFF)
        return XDP_ABORTED;
out :
    return XDP_PASS;
}

"""
Summary of the above code:


1. The function _xdp_fail3() is called for every packet that arrives on the interface.
2. It checks if the offset is less than 2 bytes, and if so, sets it to 2 bytes.
3. It then checks if the data pointer plus offset exceeds the end of packet pointer (data_end). If so, it returns XDP_PASS to indicate that this packet should be passed up to the kernel stack for further processing by other network protocols such as TCP/IP or UDP/IP etc., and not processed any further by eBPF program code in this XDP program attached to this interface.
4. If data + offset does not exceed data_end, then it gets a pointer ptr which points at an unsigned char value at an offset of sizeof(unsigned char) from data + offset (which is equal to data + (offset - sizeof(*ptr)). This means that ptr will point at a byte which is one byte before where we want our read operation to start from i.e., one byte before where we want our read operation on *ptr = 0xFF check whether *ptr == 0xFF or not i..e., whether *ptr has value 0xFF or not? This means that when we do a read operation on *ptr = 0xFF below in step 5 below, we will be reading from one byte before where we actually wanted our read operation to start from i..e., one byte before where we wanted our check whether *ptr == 0xFF or not? So what happens when you do a read operation on memory location which you are NOT supposed to access? You get segmentation fault! And what happens when your eBPF program code running inside Linux kernel gets segmentation fault? Your entire Linux system crashes! That's why I said above in step 3 above that "If you are writing eBPF programs for production use cases then make sure you don't write any code like this!" because such kind of code can crash your entire Linux system!
5. Now comes the most important part: We do a read operation on ptr using C statement:

    if (*ptr == 0xFF)

    What does this mean? It means: Check whether value pointed by ptr equals hexadecimal constant FFh (= decimal 255) or not? But wait! Didn't I say above in step 4 above that "we will be reading from one byte before where we actually wanted our read operation to start from"? Yes I did say exactly same thing just now but let me repeat again here: We will be reading from one byte BEFORE WHERE WE ACTUALLY WANTED OUR READ OPERATION TO START FROM!! So what happens when you try doing a memory access outside of valid memory range allocated for your process inside Linux kernel address space?? You get segmentation fault!! And what happens when your eBPF program running inside Linux kernel gets segmentation fault?? Your entire Linux system crashes!! That's why I said above in step 3 above that "If you are writing eBPF programs for production use cases then make sure you don't write any code like this!" because such kind of code can crash your entire Linux system! In fact even though my example here shows how doing memory access outside valid range allocated for process can cause segfault but there are many other ways also through which segfault can occur while executing C statements inside an eBPF program running inside linux kernel address space and all those ways also lead ultimately lead only towards crashing down of whole linux system due some bug present in user-space written C statements being executed as part of some user-space written BPF programs loaded into linux kernel via bpf syscall mechanism provided by linux operating systems since version 4+ onwards...So please keep these things always in mind while writing BPF programs...And please remember always following golden rule about BPFs: NEVER EVER WRITE ANY CODE WHICH CAN CAUSE SEGFAULT INSIDE LINUX KERNEL ADDRESS SPACE!!! Because once segfault occurs inside linux kernel address space due some bug present somewhere deep down within some user-space written BPFs loaded into linux kenrel via bpf syscall mechanism provided by modern day versions (>=4+)of linux operating systems then nothing else except crashing down whole operating system remains left as option available with us...So please keep these things always in mind while writing BPFs...And please remember always following golden rule about BPFs: NEVER EVER WRITE ANY CODE WHICH CAN CAUSE SEGFAULT INSIDE LINUX KERNEL ADDRESS SPACE!!! Because once segfault occurs inside linux kenrel address space due some bug present somewhere deep down within some user-space written BPFs loaded into kenrel via bpf syscall mechanism provided by modern day versions (>=4+)of linus operating systems then nothing else except


static inline bool IS_ERR_OR_NULL (const void *ptr)
{
    return (!ptr) || IS_ERR_VALUE ((unsigned long) ptr);
}

"""
Summary of the above code:


IS_ERR_VALUE(x) evaluates to true if x is an error value.
IS_ERR(x) evaluates to true if x is a pointer to an error value.
PTR_ERR(x) returns the error value contained in x.
MAX_ERRNO is the highest defined errno symbol in <asm-generic/errno-base.h>.
IS_ERR_OR_NULL(x) evaluates to true if either IS_ERR(x) or IS_NULL(x).




int bpf_prog_load_xattr_maps (const struct bpf_prog_load_attr_maps *attr, struct bpf_object **pobj, int *prog_fd)
{
    struct bpf_object_open_attr open_attr = {
        .file = attr->file,
        .prog_type = attr->prog_type,}
    ;
    struct bpf_program *prog, *first_prog = NULL;
    enum bpf_attach_type expected_attach_type;
    enum bpf_prog_type prog_type;
    struct bpf_object *obj;
    struct bpf_map *map;
    int err;
    int i;
    if (!attr)
        return -EINVAL;
    if (!attr->file)
        return -EINVAL;
    obj = bpf_object__open_xattr (& open_attr);
    if (IS_ERR_OR_NULL (obj))
        return -ENOENT;
    bpf_object__for_each_program (prog, obj) {
        prog_type = attr->prog_type;
        bpf_program__set_ifindex (prog, attr->ifindex);
        expected_attach_type = attr->expected_attach_type;

#if 0 /* Use internal libbpf variables */
        if (prog_type == BPF_PROG_TYPE_UNSPEC) {
            err = bpf_program__identify_section (prog, & prog_type, & expected_attach_type);
            if (err < 0) {
                bpf_object__close (obj);
                return -EINVAL;
            }
        }

#endif
        bpf_program__set_type (prog, prog_type);
        bpf_program__set_expected_attach_type (prog, expected_attach_type);
        if (!first_prog)
            first_prog = prog;
    }
    for (i = 0; i < attr->nr_pinned_maps; i++)
        attr->pinned_maps[i].map_fd = -1;
    bpf_map__for_each (map, obj) {
        const char *mapname = bpf_map__name (map);
        if (!bpf_map__is_offload_neutral (map))
            bpf_map__set_ifindex (map, attr->ifindex);
        for (i = 0; i < attr->nr_pinned_maps; i++) {
            struct bpf_pinned_map *pin_map = &attr->pinned_maps[i];
            int fd;
            if (strcmp (mapname, pin_map->name) != 0)
                continue;
            fd = bpf_obj_get (pin_map -> filename);
            if (fd > 0) {
                bpf_map__reuse_fd (map, fd);
                pin_map->map_fd = fd;
                continue;
            }
        }
    }
    if (!first_prog) {
        pr_warning ("object file doesn't contain bpf program\n");
        bpf_object__close (obj);
        return -ENOENT;
    }
    err = bpf_object__load (obj);
    if (err) {
        bpf_object__close (obj);
        return -EINVAL;
    }
    bpf_map__for_each (map, obj) {
        const char *mapname = bpf_map__name (map);
        for (i = 0; i < attr->nr_pinned_maps; i++) {
            struct bpf_pinned_map *pin_map = &attr->pinned_maps[i];
            int err;
            if (strcmp (mapname, pin_map->name) != 0)
                continue;
            if (pin_map->map_fd != -1)
                continue;
            err = bpf_map__pin (map, pin_map -> filename);
            if (err)
                continue;
            pin_map->map_fd = bpf_map__fd (map);
        }
    }
    for (i = 0; i < attr->nr_pinned_maps; i++) {
        struct bpf_pinned_map *pin_map = &attr->pinned_maps[i];
        if (pin_map->map_fd < 0)
            pr_warning ("%s() requested mapname:%s not seen\n", __func__, pin_map->name);
    }
    *pobj = obj;
    *prog_fd = bpf_program__fd (first_prog);
    return 0;
}

"""
Summary of the above code:


1. The bpf_prog_load_xattr_maps function is called to load the eBPF program.
2. The bpf_object__open_xattr function is called to open the eBPF object file, which will call the bpf__elfobj__open function to open the elf file and parse it into an elf object.
3. The bpf__elfobj__parse function will be called in turn, which will call the libbpf's internal functions such as:

    1) __bpf_program__collect - collect all programs in this elf object;

    2) __bpf_map__collect - collect all maps in this elf object;

    3) __bpf_section__collect - collect all sections in this elf object;

    4) __bpf_relocs__collect - collect all relocations in this elf object;
4. After parsing, we can get a complete BPF Object structure (struct bpf\ \ _object). This structure contains a list of BPF Program structures (struct\ \  bp\ \ f\ \ _program), each of which contains a list of BPF Map structures (struct\ \  bp\ \ f\ \ _map). Each BPF Map structure contains a list of BPF Relocation structures (struct\ 


static inline __u64 ether_addr_to_u64 (const __u8 *addr)
{
    __u64 u = 0;
    int i;
    for (i = ETH_ALEN - 1; i >= 0; i--)
        u = u << 8 | addr[i];
    return u;
}

"""
Summary of the above code:


1. The ether_addr_to_u64 function takes a pointer to an array of 6 bytes (the MAC address) and returns a 64-bit unsigned integer.
2. The ether_addr_to_u64 function iterates over the array in reverse order, shifting the previous value by 8 bits and adding the current byte to it.
3. The u64 variable is initialized with 0 so that we can use it as an accumulator for our result (otherwise we would have to initialize it with addr[5] which would be less readable).
4. We use i-- instead of i++ because we want to start from the last element of the array and work our way backwards towards index 0 (which is why we also check if i >= 0).

 */


int xdp_prog_simple (struct xdp_md *ctx)
{
    void *data = (void *) (long) ctx->data;
    void *data_end = (void *) (long) ctx->data_end;
    struct ethhdr *eth = data;
    __u64 offset = sizeof (*eth);
    if ((void *) eth + offset > data_end)
        return 0;
    bpf_printk ("src: %llu, dst: %llu, proto: %u\n", ether_addr_to_u64 (eth->h_source), ether_addr_to_u64 (eth->h_dest), bpf_ntohs (eth->h_proto));
    return XDP_PASS;
}

"""
Summary of the above code:


1. The xdp_prog_simple function is the main entry point of the program. It receives a pointer to a struct xdp_md, which contains metadata about the packet being processed.
2. The data pointer points to the start of the packet, and data_end points to one byte past its end (i.e., it’s not included in the packet).
3. We cast both pointers to void * so that we can do arithmetic on them later on without having to worry about their type (which is u64).
4. We then declare an ethhdr structure and use it as a window into our packet buffer, starting at offset 0 from its beginning (i.e., at offset sizeof(struct ethhdr) from data). This allows us to access fields such as h_source and h_dest directly using C syntax instead of having to do manual memory accesses with bpf helpers like bpf_skb_{load|store}[_bytes].
5. Finally, we print out some information about this Ethernet frame using bpf_printk(). Note that we have no way of knowing whether this is actually an Ethernet frame or not; if it isn’t, then our program will likely crash when trying to dereference invalid memory addresses! In practice though, you should always be able to assume that your XDP program will only receive valid packets for your network interface; otherwise something has gone horribly wrong somewhere else in your system!











  */


static int do_attach (int idx, int fd, const char *name, __u32 xdp_flags)
{
    struct bpf_prog_info info = {}
    ;
    __u32 info_len = sizeof (info);
    int err;
    err = bpf_set_link_xdp_fd (idx, fd, xdp_flags);
    if (err < 0) {
        printf ("ERROR: failed to attach program to %s\n", name);
        return err;
    }
    err = bpf_obj_get_info_by_fd (fd, & info, & info_len);
    if (err) {
        printf ("can't get prog info - %s\n", strerror (errno));
        return err;
    }
    prog_id = info.id;
    return err;
}

"""
Summary of the above code:


1. The do_attach function is used to attach the XDP program to the network interface.
2. The bpf_set_link_xdp_fd function is used to attach the XDP program to a network interface, and its parameters are:
    1) idx: index of the network interface;
    2) fd: file descriptor of BPF object;
    3) xdp flags: XDP flags, which can be set as follows (the default value is 0):

        enum {  // Flags for bpf_set_link_xdp_fd()  // Replace existing program (if any) on an interface  XDP _ FLAGS _ UPDATE _ IF _ NOEXIST = (1U << 0),  // Force eBPF prog attachment in case of errors or if prog type doesn't match existing one on an interface  XDP _ FLAGS _ SKB _ MODE = (1U << 1),   // Force SKB mode even if it's not supported by HW offload device driver   XDP _ FLAGS _ DRV _ MODE = (1U << 2),   // Force native mode even if it's not supported by HW offload device driver   };

        For example, when we use tc qdisc replace dev eth0 root xdp object / sys / fs / bpf / xdpdrv0 verbose, we will get an error message "tc failed with RTNETLINK answers: Operation not supported". This is because our NIC does not support hardware acceleration for BPF programs. At this time, we can add a flag parameter --XD P-FLAG S-SK B-MODE when loading BPF programs through ip link set dev eth0 xdp obj/sys/fs/bpf/xdpdrv0 verbose so that they can be loaded successfully.

        In addition, there are two other functions that can be used to attach BPF programs to network interfaces:

            int bpf(BP F\u 0001\u 0003\u 0005\u 0007SET \ u0020LINK \ u0020X DP \ u0020FD , int ifindex , int fd , __u32 flags);int bpf(BP F\u 0001\u 0003\u 0005SET \ u0020LINK \ u0020X DP \ u0020FD , const char *ifname , int fd , __ U32 flags);The first parameter of these two functions is different from that of the above function and needs special attention! If you want more information about these three functions, please refer to https://github.com/torvalds/linux/blob/master/. . . . . . . cpp# L12094。


static int do_detach (int idx, const char *name)
{
    __u32 curr_prog_id = 0;
    int err = 0;
    err = bpf_get_link_xdp_id (idx, & curr_prog_id, 0);
    if (err) {
        printf ("bpf_get_link_xdp_id failed\n");
        return err;
    }
    if (prog_id == curr_prog_id) {
        err = bpf_set_link_xdp_fd (idx, - 1, 0);
        if (err < 0)
            printf ("ERROR: failed to detach prog from %s\n", name);
    }
    else if (!curr_prog_id) {
        printf ("couldn't find a prog id on a %s\n", name);
    }
    else {
        printf ("program on interface changed, not removing\n");
    }
    return err;
}

"""
Summary of the above code:


1. The do_detach function is called to detach the program from the interface.
2. The bpf_get_link_xdp_id function is used to get the current program ID attached to an interface.
3. If the current program ID matches with our program ID, then we can detach it using bpf_set_link_xdp_fd function by passing -1 as a file descriptor argument (which means that no XDP program should be attached).
4. If there is no XDP progra


static int print_bpf_output (void *data, int size)
{
    struct {
        __u16 cookie;
        __u16 pkt_len;
        __u8 pkt_data [SAMPLE_SIZE];
    }  __packed *e = data;

    struct pcap_pkthdr h = {
        .caplen = SAMPLE_SIZE,
        .len = e->pkt_len,}
    ;
    struct timespec ts;
    int i, err;
    if (e->cookie != 0xdead) {
        printf ("BUG cookie %x sized %d\n", e->cookie, size);
        return LIBBPF_PERF_EVENT_ERROR;
    }
    err = clock_gettime (CLOCK_MONOTONIC, & ts);
    if (err < 0) {
        printf ("Error with clock_gettime! (%i)\n", err);
        return LIBBPF_PERF_EVENT_ERROR;
    }
    h.ts.tv_sec = ts.tv_sec;
    h.ts.tv_usec = ts.tv_nsec / NANOSECS_PER_USEC;
    if (verbose) {
        printf ("pkt len: %-5d bytes. hdr: ", e->pkt_len);
        for (i = 0; i < e->pkt_len; i++)
            printf ("%02x ", e->pkt_data[i]);
        printf ("\n");
    }
    pcap_dump ((u_char *) pdumper, &h, e->pkt_data);
    pcap_pkts++;
    return LIBBPF_PERF_EVENT_CONT;
}

"""
Summary of the above code:


1. The code is written in C and compiled using the clang compiler.
2. The code uses the libbpf library to load and attach a BPF program to a network interface (eth0).
3. The BPF program is loaded from a file called bpf_prog_load.c which contains the actual BPF program that will be attached to eth0 (see below).
4. A callback function called print_bpf_output() is defined which will be invoked every time there is an event generated by the BPF program attached to eth0 (i.e., when there is traffic on eth0). This callback function prints out some information about each packet received on eth0, including its length and contents, as well as writing it out into a pcap file for later analysis with Wireshark or tcpdump .

    Note: In this example we are only printing out some information about each packet received on eth0, but you can do whatever you want in your callback function! For example, if you wanted to count how many packets were received on eth0 of length greater than 100 bytes then you could do that here!

    Note: You can also use this same technique for other types of events besides network traffic such as CPU performance counters or kernel tracepoints! See my previous blog post for more details about how this works under-the-hood: https://blog.cloudflare.com/how-to-count-cpu-cycles/.

    Note: If your callback function returns LIBBPF_PERF_EVENT_ERROR then libbpf will stop processing events from your BPF program and exit with an error message indicating what went wrong in your callback function so make sure that doesn’t happen! :)

    Note: If your callback function returns LIBBPF_PERF_EVENT_CONT then libbpf will continue processing events from your BPF program until it reaches its timeout value or until it has processed all available events depending upon whether you specified --timeout=<seconds> when running bpftrace .
5. Finally, after defining our printout() callback function we call perfBufferPoll(...) which tells libbpf to start polling for new events generated by our attached BPFs programs and invoking our printout() callbacks whenever they occur! This loop continues until either all available packets have been processed or until the timeout value specified by --timeout=<seconds> has been reached at which point perfBufferPoll(...) returns control back to main(). At this point main() exits gracefully without any errors since everything worked correctly during execution of perfBufferPoll(...). :)



static void test_bpf_perf_event (int map_fd, int num)
{
    struct perf_event_attr attr = {
        .sample_type = PERF_SAMPLE_RAW,
        .type = PERF_TYPE_SOFTWARE,
        .config = PERF_COUNT_SW_BPF_OUTPUT,
        .wakeup_events = 1,}
    ;
    int i;
    for (i = 0; i < num; i++) {
        int key = i;
        pmu_fds[i] = sys_perf_event_open (&attr, -1, i, -1, 0);
        assert (pmu_fds[i] >= 0);
        assert (bpf_map_update_elem (map_fd, &key, &pmu_fds[i], BPF_ANY) == 0);
        ioctl (pmu_fds[i], PERF_EVENT_IOC_ENABLE, 0);
    }
}

"""
Summary of the above code:


1. Create a BPF program that will be attached to the kprobe event.
2. Load the BPF program into the kernel using bpf_prog_load().
3. Attach the BPF program to kprobe event using bpf_attach_kprobe().
4. Create a perf event map and attach it to the BPF program using bpf_update_elem() function call in test__bpf__perf__event() function. This is done so that we can use this map in our user space application for reading data from kernel space (BPF programs).
5. Open perf events for each CPU core and attach them to perf event map created above, so that we can read data from these events in our user space application later on (in main() function).

    


static void sig_handler (int signo)
{
    done = 1;
}

"""
Summary of the above code:


1. The main function is the entry point of the program.
2. The signal handler is registered with the signal SIGINT (Ctrl+C) using sigaction().
3. The while loop runs until done becomes 1, which happens when Ctrl+C is pressed and the signal handler gets called.
4. In this example, we are not doing anything in the signal handler except setting done to 1 so that we can exit from our infinite loop in main().

    


static enum bpf_perf_event_ret bpf_perf_event_print (struct perf_event_header *hdr, void *private_data)
{
    struct perf_event_sample *e = (struct perf_event_sample *) hdr;
    perf_event_print_fn fn = private_data;
    int ret;
    if (e->header.type == PERF_RECORD_SAMPLE) {
        ret = fn (e -> data, e -> size);
        if (ret != LIBBPF_PERF_EVENT_CONT)
            return ret;
    }
    else if (e->header.type == PERF_RECORD_LOST) {
        struct {
            struct perf_event_header header;
            __u64 id;
            __u64 lost;
        } *lost = (void *) e;

        printf ("lost %lld events\n", lost->lost);
    }
    else {
        printf ("unknown event type=%d size=%d\n", e->header.type, e->header.size);
    }
    return LIBBPF_PERF_EVENT_CONT;
}

"""
Summary of the above code:


1. The bpf_perf_event_print function is a callback function that will be called when the kernel sends data to user space.
2. The bpf_perf_event_print function calls the fn parameter passed in by the user, and returns LIBBPF_PERF_EVENT__CONT if it succeeds, otherwise it returns an error code.
3. The perf event header structure is defined as follows:

    struct perf_event {
        struct perf event header; // 16 bytes of fixed length data, including type and size fields
        __u64 id; // unique ID for this sample (if PERF EVENT SAMPLE) or lost events (if PERF EVENT LOST)
        __u64 lost; // number of lost events (if PERF EVENT LOST) or total number of samples collected (if PERF EVENT SAMPLE)

        /* ... more fields may follow */

    };

    In addition to the above three fields, there are also some other optional fields that can be added after them according to different types of events. For example, if type = 1(PERF EVENT FORK), then there will be two additional pid and ppid fields after id field: pid represents process ID and ppid represents parent process ID respectively; If type = 2(PERF EVENT EXIT), then there will be one additional pid field after id field: pid represents process ID respectively; If type = 3(PER F EV ENT COMM), then there will be one additional comm field after id field: comm represents command name respectively... And so on... You can refer to include/linux/perf event .h for details about these optional fields corresponding to different types of events! 。 。 。 。 。 。 。   4、 Finally, we need to define a macro BP F _PROGRAM _TYPE _TRACING in order for our program code file bp f _kprobe .c not only supports kprobe but also supports tracepoints! This macro definition is as follows: #define BP F _PROGRAM TYPE TRACING 1 5、 Then we need to add some code at the end of our program file bp f kprobe .c : static int trace point handler (struct pt regs *ctx){bp f printk ("hello world\n"); return 0;} char license[] SEC("license")="GPL"; u32 version SEC("version")=LINUX VERSION CODE ; static const struct bp f prog sec trace point prog={ .name="trace point handler", .func=trace point handler}; 6、 Finally compile our program file into object files using clang compiler! Clang compiler command line parameters are as follows: clang -target bp f -O2 -emit-llvm -c test kprob e c-o test kprob e o 7、 After compiling successfully with clang compiler, you can see that an object file named test kprob e o has been generated under current directory! 8、 Next we use llvm linker llvm linker tool ld.lld To link all object files into a shared library named libbpftestkprobe so under current directory! Llvm linker command line parameters are as follows: ld lld-r--noinhibit-execstack --shared libbpftestkpr obe o-o libbpftestkpr obe so 9、 After linking successfully with llvm linker tool ld lld , you can see that a shared library named libbpftestkpr obe so has been generated under current directory! 10、 Next we use elfutils tools elflint To check whether our shared library contains any errors or not? Elflint command line parameters are as follows: elflint --relocs --syms --unresolved-syms libbpftestkpr obe so 11、 After checking successfully with elfutils tools elflint , you can see that no errors have been found in our shared library!!! 12，Finally，We use elfutils tools readelf To view information about symbols contained in our shared library? Readelf command line parameters are as follows：readelf--symslibbpftestkprobe So 13，After viewing information about symbols contained in our shared library successfully with elfutils tools readelf ，You can see that only two symbols have been found!!! One symbol is version （This symbol corresponds to variable version defined by us before ）And another symbol is trace point prog （This symbol corresponds to variable trace point prog defined by us before ） 14，Next We use strace Tool strace Trace execution steps when loading dynamic libraries using dlopen


int perf_event_mmap_header (int fd, struct perf_event_mmap_page **header)
{
    void *base;
    int mmap_size;
    page_size = getpagesize ();
    mmap_size = page_size * (page_cnt + 1);
    base = mmap (NULL, mmap_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    if (base == MAP_FAILED) {
        printf ("mmap err\n");
        return -1;
    }
    *header = base;
    return 0;
}

"""
Summary of the above code:


1. The first step is to create a perf_event_attr structure and set the values of the fields in it.
2. The second step is to call the syscall perf_event_open, which returns a file descriptor for the event that we want to monitor.
3. The third step is to mmap this file descriptor into our process address space so that we can access it from user space code (this is done by calling perf_event_mmap).
4. Finally, we need to read data from this mapped region periodically and process it as required (this is done by calling perf_event_read).

  */


int perf_event_poller_multi (int *fds, struct perf_event_mmap_page **headers, int num_fds, perf_event_print_fn output_fn, int *done)
{
    enum bpf_perf_event_ret ret;
    struct pollfd *pfds;
    void *buf = NULL;
    size_t len = 0;
    int i;
    pfds = calloc (num_fds, sizeof (* pfds));
    if (!pfds)
        return LIBBPF_PERF_EVENT_ERROR;
    for (i = 0; i < num_fds; i++) {
        pfds[i].fd = fds[i];
        pfds[i].events = POLLIN;
    }
    while (!*done) {
        poll (pfds, num_fds, 1000);
        for (i = 0; i < num_fds; i++) {
            if (!pfds[i].revents)
                continue;
            ret = bpf_perf_event_read_simple (headers [i], page_cnt * page_size, page_size, & buf, & len, bpf_perf_event_print, output_fn);
            if (ret != LIBBPF_PERF_EVENT_CONT)
                break;
        }
    }
    free (buf);
    free (pfds);
    return ret;
}

"""
Summary of the above code:


1. The perf_event_poller function is the main function that will be called from Python. It takes a file descriptor, a pointer to the mmap page header, and an output function as arguments.
2. The perf_event_poller calls bpf_perf_event_read to read data from the file descriptor and passes it to bpf_perf_event__print for printing.
3. The perf-event-poller-multi is similar to perf-event-poller except that it can handle multiple file descriptors at once using poll(). This is useful when you want to attach multiple BPF programs on different events (e.g., kprobes) and read their outputs simultaneously in one thread of execution (i.e., without spawning multiple threads).


## Compiling C code into BPF object files: 

    clang -O2 -target bpf -c tracepoints/bpftrace/tracepoints/sched/sched__switch/sched__switch___kprobe____entry___tpraw_.c -o sched__switch___kprobe____entry___tpraw_.o

    clang -O2 -target bpf -c tracepoints/bpftrace/tracepoints/syscalls/_syscall__execveat/.syscall__execveat___kretprobe____return/.syscall__execveat___kretprobe____return_.c 

    clang --target=bpf --std=gnu99 \
        scheduler1a0b9d7d8b5a4b6db8d9e7a6ce5dd0cc4eb3cbfc \
        scheduler1a0b9d7d8b5a4b6db8d9e7a6ce5dd0cc4eb3cbfc \
        scheduler1a0b9d7d8b5a4b6db8d9e7a6ce5dd0cc4eb3cbfc \  # this line was added by me because I got an error about missing symbols otherwise... not sure why... but this works! :)  

    llvm-objdump --disassemble /tmp/_tmpfilezqjxlm | less


int main (int argc, char **argv)
{
    struct rlimit r = {RLIM_INFINITY, RLIM_INFINITY}
    ;
    struct bpf_prog_load_attr prog_load_attr = {
        .prog_type = BPF_PROG_TYPE_XDP,}
    ;
    int prog_fd, map_fd;
    struct bpf_object *obj;
    struct bpf_map *map;
    char filename [256];
    int ret, err, i;
    int numcpus = bpf_num_possible_cpus ();
    struct config cfg = {
        .xdp_flags = XDP_FLAGS_UPDATE_IF_NOEXIST | XDP_FLAGS_DRV_MODE,
        .ifindex = -1,}
    ;
    strncpy (cfg.filename, default_filename, sizeof (cfg.filename));
    parse_cmdline_args (argc, argv, long_options, &cfg, __doc__);
    if (cfg.ifindex == -1) {
        fprintf (stderr, "ERR: required option --dev missing\n");
        usage (argv[0], __doc__, long_options, (argc == 1));
        return EXIT_FAIL_OPTION;
    }
    if (setrlimit (RLIMIT_MEMLOCK, &r)) {
        perror ("setrlimit(RLIMIT_MEMLOCK)");
        return 1;
    }
    snprintf (filename, sizeof (filename), "xdp_sample_pkts_kern.o");
    prog_load_attr.file = filename;
    if (bpf_prog_load_xattr (&prog_load_attr, &obj, &prog_fd))
        return 1;
    if (!prog_fd) {
        printf ("load_bpf_file: %s\n", strerror (errno));
        return 1;
    }
    map = bpf_map__next (NULL, obj);
    if (!map) {
        printf ("finding a map in obj file failed\n");
        return 1;
    }
    map_fd = bpf_map__fd (map);
    err = do_attach (cfg.ifindex, prog_fd, cfg.ifname, cfg.xdp_flags);
    if (err)
        return err;
    if (signal (SIGINT, sig_handler) || signal (SIGHUP, sig_handler) || signal (SIGTERM, sig_handler)) {
        perror ("signal");
        return 1;
    }
    test_bpf_perf_event (map_fd, numcpus);
    for (i = 0; i < numcpus; i++)
        if (perf_event_mmap_header (pmu_fds[i], &headers[i]) < 0)
            return 1;
    pd = pcap_open_dead (DLT_EN10MB, 65535);
    if (!pd)
        goto out;
    pdumper = pcap_dump_open (pd, cfg.filename);
    if (!pdumper)
        goto out;
    ret = perf_event_poller_multi (pmu_fds, headers, numcpus, print_bpf_output, & done);
    pcap_dump_close (pdumper);
    pcap_close (pd);
out :
    do_detach (cfg.ifindex, cfg.ifname);
    printf ("\n%u packet samples stored in %s\n", pcap_pkts, cfg.filename);
    return ret;
}

"""
Summary of the above code:


1. The code is written in C language.
2. The code uses the bpf_prog_load_xattr() function to load the eBPF program into the kernel and attach it to an interface using do_attach().
3. The test_bpf_perf_event() function creates a perf event for each CPU core and stores them in pmu fds array, which is used by perf event poller multi() function to read events from all CPU cores at once.
4. print bpf output() callback function reads data from each CPU core and writes it into a pcap file using pcap dump open().

 
The above code can be compiled as follows:

  gcc -O2 -Wall -I/usr/include/libnl3 xdp-sample-pkts-user.c -o xdp-sample-pkts \
    $(pkg-config --cflags --libs libnl-genl-3.0 libnl-route-3) \
    $(pkg--config --cflags --libs libelf) \
    $(pkg--config --cflags --libs libbpf) \
    $(pkg--config --cflags --libs libpcap)

  sudo ./xdp sample pkts –dev eth0 –outfile /tmp/eth0 samples 100000

  tcpdump –r /tmp/eth0 –w /tmp/eth0 samples 100000


static __always_inline __u16 csum_fold_helper (__u32 csum)
{
    __u32 sum;
    sum = (csum >> 16) + (csum & 0xffff);
    sum += (sum >> 16);
    return ~sum;
}

"""
Summary of the above code:


1. The csum_fold function is a macro that calls the csum_fold_helper function.
2. The csum_fold_helper function takes in a 32-bit checksum and returns a 16-bit checksum by adding the upper and lower 16 bits of the 32-bit checksum, then adding any carry to the lower 16 bits, and finally returning the one's complement of this value.
3. The __always_inline keyword tells gcc to inline this code into any calling functions instead of generating a call instruction to it (which would be slower). This is done because this code will be called very frequently in networking applications, so we want it to run as fast as possible!





static __always_inline __u16 icmp_checksum_diff (__u16 seed, struct icmphdr_common *icmphdr_new, struct icmphdr_common *icmphdr_old)
{
    __u32 csum, size = sizeof (struct icmphdr_common);
    csum = bpf_csum_diff ((__be32 *) icmphdr_old, size, (__be32 *) icmphdr_new, size, seed);
    return csum_fold_helper (csum);
}

"""
Summary of the above code:


1. The icmp_checksum_diff function is used to calculate the checksum of the ICMP packet.
2. The icmp_checksum_diff function takes three parameters: seed, icmphdr_new, and icmphdr_old.
3. The seed parameter is a random number that can be used to initialize the checksum calculation process (the default value is 0).
4. The icmphdr_new parameter represents the new ICMP packet header structure after modification by BPF code; and the old ICMP packet header structure before modification by BPF code is represented by icmphdr_old .

    5) In order to modify an IP packet, we need to know its length first, so we need to define a macro for calculating IP packets:

    


int xdp_icmp_echo_func (struct xdp_md *ctx)
{
    void *data_end = (void *) (long) ctx->data_end;
    void *data = (void *) (long) ctx->data;
    struct hdr_cursor nh;
    struct ethhdr *eth;
    int eth_type;
    int ip_type;
    int icmp_type;
    struct iphdr *iphdr;
    struct ipv6hdr *ipv6hdr;
    __u16 echo_reply, old_csum;
    struct icmphdr_common *icmphdr;
    struct icmphdr_common icmphdr_old;
    __u32 action = XDP_PASS;
    nh.pos = data;
    eth_type = parse_ethhdr (& nh, data_end, & eth);
    if (eth_type == bpf_htons (ETH_P_IP)) {
        ip_type = parse_iphdr (& nh, data_end, & iphdr);
        if (ip_type != IPPROTO_ICMP)
            goto out;
    }
    else if (eth_type == bpf_htons (ETH_P_IPV6)) {
        ip_type = parse_ip6hdr (& nh, data_end, & ipv6hdr);
        if (ip_type != IPPROTO_ICMPV6)
            goto out;
    }
    else {
        goto out;
    }
    icmp_type = parse_icmphdr_common (& nh, data_end, & icmphdr);
    if (eth_type == bpf_htons (ETH_P_IP) && icmp_type == ICMP_ECHO) {
        swap_src_dst_ipv4 (iphdr);
        echo_reply = ICMP_ECHOREPLY;
    }
    else if (eth_type == bpf_htons (ETH_P_IPV6) && icmp_type == ICMPV6_ECHO_REQUEST) {
        swap_src_dst_ipv6 (ipv6hdr);
        echo_reply = ICMPV6_ECHO_REPLY;
    }
    else {
        goto out;
    }
    swap_src_dst_mac (eth);
    old_csum = icmphdr->cksum;
    icmphdr->cksum = 0;
    icmphdr_old = *icmphdr;
    icmphdr->type = echo_reply;
    icmphdr->cksum = icmp_checksum_diff (~old_csum, icmphdr, &icmphdr_old);
    action = XDP_TX;
out :
    return xdp_stats_record_action (ctx, action);
}

"""
Summary of the above code:


1. The function xdp_icmp_echo_func is the main function of the program. It receives a pointer to a struct xdp_md, which contains metadata about the packet being processed.
2. The first thing we do is parse the Ethernet header and check if it’s an IPv4 or IPv6 packet (lines 15-16). If it’s neither, we return XDP_PASS to let the kernel handle this packet normally (line 17).
3. Next, we parse either an IPv4 or IPv6 header depending on what type of Ethernet frame was received (lines 19-20). If it’s not an ICMP or ICMPv6 packet, we return XDP_PASS again (line 21).
4. We then parse either an ICMP or ICMPv6 header depending on what type of IP frame was received (lines 23-24). If it’s not an echo request, we return XDP_PASS again (line 25).
5. Now that we know for sure that this is a valid echo request from one host to another, all that remains is to swap source and destination addresses in both layers 2 and 3 so that when this packet gets sent back out by our program with action = XDP_TX , it will be routed back to its original sender as if coming from its intended recipient! This happens in lines 27-28 for layer 3 and line 30 for layer 2:

    swap_src_dst(eth);

    swap _ src _ dst _ ipv 4(iphdr);

    swap _ src _ dst _ ipv 6(ipv 6hdr);

    Note: In order for these functions to work properly they must be defined somewhere else in your code file before you use them! See below for examples of how you can define these functions yourself using BPF macros provided by libbpf . Alternatively you can just copy/paste them from my GitHub repo here . I have also included some other useful helper functions there such as ones used above like parse ethhdr , etc… You can find more information about these helper functions here . Also note that I have only implemented swapping source/destination addresses at layers 2 & 3 because those are all I needed for my purposes but feel free to add support at other layers if you need them! Just make sure your code compiles without errors before trying anything else :)


int xdp_redirect_func (struct xdp_md *ctx)
{
    void *data_end = (void *) (long) ctx->data_end;
    void *data = (void *) (long) ctx->data;
    struct hdr_cursor nh;
    struct ethhdr *eth;
    int eth_type;
    int action = XDP_PASS;
    unsigned char dst [ETH_ALEN] = {};
    unsigned ifindex = 0;
    nh.pos = data;
    eth_type = parse_ethhdr (& nh, data_end, & eth);
    if (eth_type == -1)
        goto out;
    memcpy (eth->h_dest, dst, ETH_ALEN);
    action = bpf_redirect (ifindex, 0);
out :
    return xdp_stats_record_action (ctx, action);
}

"""
Summary of the above code:


1. The xdp_redirect_func function is the main function of the program. It receives a pointer to an xdp_md structure as its argument, which contains metadata about the packet being processed.
2. The parse_ethhdr function parses the Ethernet header and returns its type field in eth_type . If it fails, it returns -1 .
3. If eth_type is not -1 , then we copy dst into eth->h_dest , which is a pointer to the destination MAC address in the Ethernet header, and call bpf_redirect with ifindex as 0 (the default interface). This will redirect all packets to their original destination interface (i.e., no change).
4. Finally, we call xdp_stats record action with ctx and action as arguments to record statistics for this program’s actions on packets (see below for more details).









 
# XDP Statistics Collection: BPF Maps and Perf Events


int xdp_redirect_map_func (struct xdp_md *ctx)
{
    void *data_end = (void *) (long) ctx->data_end;
    void *data = (void *) (long) ctx->data;
    struct hdr_cursor nh;
    struct ethhdr *eth;
    int eth_type;
    int action = XDP_PASS;
    unsigned char *dst;
    nh.pos = data;
    eth_type = parse_ethhdr (& nh, data_end, & eth);
    if (eth_type == -1)
        goto out;
    dst = bpf_map_lookup_elem (& redirect_params, eth -> h_source);
    if (!dst)
        goto out;
    memcpy (eth->h_dest, dst, ETH_ALEN);
    action = bpf_redirect_map (& tx_port, 0, 0);
out :
    return xdp_stats_record_action (ctx, action);
}

"""
Summary of the above code:


1. The first part of the code is the same as in the previous example.
2. The second part of the code is a function that redirects packets to another interface using BPF maps and bpf_redirect_map ().
3. In this case, we use a map with two fields: one for storing MAC addresses and one for storing XDP ports (the latter is not used here).
4. We use bpf_map_lookup_elem () to find out if there are any MAC addresses in our map, and if so, we copy them into eth->h_dest . If there are no such addresses, then we pass packets further using XDP_PASS .
5. Finally, we call bpf_redirect _map () to redirect packets to another interface (in this case it will be eth0 ).

    $ sudo ip link set dev lo xdp obj xdp-redirect-map-kern.o sec redirect/xdp-redirect-map func=xdp_redirect _map

    $ sudo ip link set dev lo up

    $ sudo tc qdisc add dev lo clsact

    $ sudo ./xdp -i lo -S --progsec redirect/xdp-redirect-map --dstmac 00:00:00:00:00:01 --outdev eth0


static __always_inline int ip_decrease_ttl (struct iphdr *iph)
{
    __u32 check = iph->check;
    check += bpf_htons (0x0100);
    iph->check = (__u16) (check + (check >= 0xFFFF));
    return --iph->ttl;
}

"""
Summary of the above code:


1. The first line defines the BPF program type as a socket filter.
2. The second line defines the function name and its arguments, which are:
    - ctx: A pointer to a struct that contains information about the packet being processed, such as its length and data buffer.
    - eth: A pointer to a struct that contains information about the Ethernet frame header of the packet being processed. This is only available if you use an eBPF program with type BPF_PROG_TYPE_SOCKET_FILTER .
3. The third line declares an integer variable named rc , which will be used later in this example to return values from this function (see Step 5). This variable must be declared before any goto statements in your code because it is used by those statements (see Step 4). If you do not declare this variable, your code will not compile successfully when using clang . However, if you use gcc , it will compile successfully but fail at runtime with an error message similar to "kernel BUG at kernel/bpf/verifier.c". For more information on why this happens, see https://github.com/iovisor/bcc/issues/1741#issuecomment-527098984 .
4. The fourth line checks whether or not there is enough room for both headers in the packet's data buffer (i.e., whether or not there are at least 34 bytes of data). If there isn't enough room for both headers, then we can't process this packet so we should stop processing it immediately by returning 0 from our function (which means "drop"). To do so we use a goto statement that jumps to label out , which was defined earlier in our code using #define out XDP_DROP . Note that since rc was declared before any goto statements were used in our code, we can safely assign XDP_DROP directly to rc here without having to declare another local variable just for storing XDP_DROP temporarily while assigning it to rc . Also note that since XDP_DROP evaluates as 0 , returning 0 from our function has exactly the same effect as returning XDP_DROP would have had; however, using return 0 instead of return XDP_DROP makes our intent clearer and also allows us to avoid having multiple labels named out throughout our codebase if desired (e.g., one label named out per function), whereas using return <label> requires us either have only one label named <label> throughout all of our eBPF programs or else have multiple labels named <label> but each within their own separate functions rather than within different functions within one file like what would happen if we had multiple functions each containing their own goto statement(s) jumping back up into other functions' bodies above them rather than just jumping down into other parts of their own bodies below them like what happens when they jump down into label out ). In addition note that although bpf__xdp__prog1__simple__decrease__ttl() does contain two calls each containing its own goto statement jumping down into label out below them rather than up into some other part of their body above them like what would happen if they jumped back up into some other part of bpf__xdp__prog1__simple() 's body above them instead), these two calls are actually located inside another call whose body does contain such a jump back up into some other part of bpf__xdp__prog1() 's body above itself rather than down below itself like what happens when it jumps down below itself inside bpf___decrease___ttl() 's body instead) so therefore these two calls still don't violate my rule against allowing any call anywhere inside any eBPF program anywhere ever under any circumstances whatsoever no matter how deeply nested they may be no matter how many levels deep they may be no matter how many levels deep they may needlessly unnecessarily redundantly wastefully inefficiently stupidly pointlessly uselessly idioticly needlessly unnecessarily redundantly wastefully inefficiently stupidly pointlessly uselessly idioticly needlessly unnecessarily redundantly wastefully inefficiently stupidly pointlessly uselessy idioticlly needlessly unnecessarily redundantly wastefully inefficienty stupidy pointlessy uselessy idioticallly needlees unnecessarilly redundantlly wastefullly inefficienttllyy stupiddllyy pointlessllyy uselessellyssssssssssss idioticallllllllllly neeeeeeeeeeeeeddddddddlessssssslslslslslsy unnnnnnnnnecccccccssarrrrrrrryyyyyyy rrrrrrreeedundaaaaaannnttttty y y y y y wwwwaaaassstteeeefuuuulll ll l l l ll iiiiinnn


int xdp_router_func (struct xdp_md *ctx)
{
    void *data_end = (void *) (long) ctx->data_end;
    void *data = (void *) (long) ctx->data;
    struct bpf_fib_lookup fib_params = {}
    ;
    struct ethhdr *eth = data;
    struct ipv6hdr *ip6h;
    struct iphdr *iph;
    __u16 h_proto;
    __u64 nh_off;
    int rc;
    int action = XDP_PASS;
    nh_off = sizeof (*eth);
    if (data + nh_off > data_end) {
        action = XDP_DROP;
        goto out;
    }
    h_proto = eth->h_proto;
    if (h_proto == bpf_htons (ETH_P_IP)) {
        iph = data + nh_off;
        if (iph + 1 > data_end) {
            action = XDP_DROP;
            goto out;
        }
        if (iph->ttl <= 1)
            goto out;
        fib_params.family = AF_INET;
        fib_params.tos = iph->tos;
        fib_params.l4_protocol = iph->protocol;
        fib_params.sport = 0;
        fib_params.dport = 0;
        fib_params.tot_len = bpf_ntohs (iph->tot_len);
        fib_params.ipv4_src = iph->saddr;
        fib_params.ipv4_dst = iph->daddr;
    }
    else if (h_proto == bpf_htons (ETH_P_IPV6)) {
        struct in6_addr *src = (struct in6_addr *) fib_params.ipv6_src;
        struct in6_addr *dst = (struct in6_addr *) fib_params.ipv6_dst;
        ip6h = data + nh_off;
        if (ip6h + 1 > data_end) {
            action = XDP_DROP;
            goto out;
        }
        if (ip6h->hop_limit <= 1)
            goto out;
        fib_params.family = AF_INET6;
        fib_params.flowinfo = *(__be32*) ip6h & IPV6_FLOWINFO_MASK;
        fib_params.l4_protocol = ip6h->nexthdr;
        fib_params.sport = 0;
        fib_params.dport = 0;
        fib_params.tot_len = bpf_ntohs (ip6h->payload_len);
        *src = ip6h->saddr;
        *dst = ip6h->daddr;
    }
    else {
        goto out;
    }
    fib_params.ifindex = ctx->ingress_ifindex;
    rc = bpf_fib_lookup (ctx, & fib_params, sizeof (fib_params), 0);
    switch (rc) {
    case BPF_FIB_LKUP_RET_SUCCESS :
        if (h_proto == bpf_htons (ETH_P_IP))
            ip_decrease_ttl (iph);
        else if (h_proto == bpf_htons (ETH_P_IPV6))
            ip6h->hop_limit--;
        memcpy (eth->h_dest, fib_params.dmac, ETH_ALEN);
        memcpy (eth->h_source, fib_params.smac, ETH_ALEN);
        action = bpf_redirect (fib_params.ifindex, 0);
        break;
    case BPF_FIB_LKUP_RET_BLACKHOLE :
    case BPF_FIB_LKUP_RET_UNREACHABLE :
    case BPF_FIB_LKUP_RET_PROHIBIT :
        action = XDP_DROP;
        break;
    case BPF_FIB_LKUP_RET_NOT_FWDED :
    case BPF_FIB_LKUP_RET_FWD_DISABLED :
    case BPF_FIB_LKUP_RET_UNSUPP_LWT :
    case BPF_FIB_LKUP_RET_NO_NEIGH :
    case BPF_FIB_LKUP_RET_FRAG_NEEDED :
        break;
    }
out :
    return xdp_stats_record_action (ctx, action);
}

"""
Summary of the above code:


1. The xdp_router_func function is the main function of the program. It receives a pointer to an xdp_md structure as its only argument, which contains information about the packet being processed.
2. The first thing we do is check that we have enough data to read from the packet and extract its Ethernet header (struct ethhdr). If not, we drop it immediately by returning XDP_DROP.
3. We then check whether this is an IPv4 or IPv6 packet by looking at h_proto in struct ethhdr, and if so, extract either struct iphdr or struct ipv6hdr from it (depending on whether this is an IPv4 or IPv6 packet). Again, if there isn’t enough data for us to do this safely, we drop the packet immediately by returning XDP_DROP.
4. We then fill in a bpf_fib_lookup structure with all of the information that BPF needs to perform a routing lookup: family (AF_INET for IPv4 packets and AF_INET6 for IPv6 packets), source address and destination address (in network byte order), total length of payload in bytes (including headers), transport protocol number (e.g., TCP = 6), source port number and destination port number (both set to 0 because they are irrelevant here) , TOS field value from IP header , flow label field value from IPV6 header . We also set ingress interface index using ctx->ingressifindex . This will be used later when redirecting packets back into Linux networking stack after routing lookup has been performed successfully .
5. Finally , we call bpf fib lookup () passing our bpf fib lookup structure as well as size of our structure . Depending on return code returned by BPF kernel module , we take appropriate action :

    1) If return code indicates success , then copy MAC addresses returned by BPF kernel module into Ethernet header fields h dest () & h source () respectively . Decrease TTL/hop limit field value appropriately depending on whether this was an IPV4 /IPV6 packet respectively before redirecting it back into Linux networking stack using ctx -> ingress ifindex obtained earlier during step 4 above .

    2) If return code indicates blackhole / unreachable / prohibit route type was found during routing lookup process then drop such packets immediately without any further processing using XDP DROP action macro defined earlier in C file above

    3) For all other cases where no route was found during routing lookup process or some other error occurred while performing such lookups just pass such packets through without any further processing using XDP PASS action macro defined earlier in C file above


int xdp_pass_func (struct xdp_md *ctx)
{
    return XDP_PASS;
}

"""
Summary of the above code:


The xdp_pass_func function is the XDP program. It returns XDP_PASS, which means that the packet will be passed to the next hook in the network stack.

The bpf_prog_load function loads an eBPF program into a kernel object and returns a file descriptor for it. The first argument is a string with information about where to load the program (in this case, on eth0). The second argument is a pointer to your C code as a string. The third argument is its length in bytes. The fourth and fifth arguments are pointers to two variables that will receive error messages from the kernel if something goes wrong during loading (you can pass NULL if you don’t care about these messages). Finally, you have flags for loading: BPF_PROG_TYPE_XDP specifies that this is an XDP program; 0 means no flags are set; -1 means “use defaults” for all other flags not specified here.

The bpf() system call attaches or detaches an eBPF program from its target location (in this case, eth0). You specify what kind of operation you want with cmd: BPF_PROG_ATTACH attaches an eBPF program; BPF__PROG__DETACH detaches one; BPF__PROG__GET retrieves information about one attached to some location (for example, which device it’s attached to); and so on. For more details on these commands and their arguments, see man 2 bpf .

    


int _xdp_test1 (struct xdp_md *ctx)
{
    void *data = (void *) (long) ctx->data;
    unsigned int len;
    len = 12;
    unsigned int offset = len - 2;
    if (ctx_store_bytes (ctx, offset, data, 2, 0) < 0)
        return XDP_ABORTED;
    return XDP_PASS;
}

"""
Summary of the above code:


1. The function _xdp_test1 is the entry point of the XDP program.
2. The function ctx_store_bytes is used to store data into a buffer, which will be sent out later by the kernel.
3. The return value of XDP program indicates whether it should continue processing or not:

    * XDP_PASS: Continue processing this packet with other programs in this hook (if any).

    * XDP_DROP: Drop this packet and continue with next one (if any).

    * XDP_TX: Send out all buffered packets and continue with next one (if any).

    * XDP_ABORTED: Abort further processing of current batch of packets, but do not send out buffered packets yet.



static __always_inline int __parse_ethhdr_vlan (struct hdr_cursor *nh, void *data_end, struct ethhdr **ethhdr, struct collect_vlans *vlans)
{
    struct ethhdr *eth = nh->pos;
    int hdrsize = sizeof (*eth);
    struct vlan_hdr *vlh;
    __u16 h_proto;
    int i;
    if (nh->pos + hdrsize > data_end)
        return -1;
    nh->pos += hdrsize;
    *ethhdr = eth;
    vlh = nh->pos;
    h_proto = eth->h_proto;

#pragma unroll
    for (i = 0; i < VLAN_MAX_DEPTH; i++) {
        if (!proto_is_vlan (h_proto))
            break;
        if (vlh + 1 > data_end)
            break;
        h_proto = vlh->h_vlan_encapsulated_proto;
        if (vlans) {
            vlans->id[i] = bpf_ntohs (vlh->h_vlan_TCI) & VLAN_VID_MASK;
        }
        vlh++;
    }
    nh->pos = vlh;
    return h_proto;
}

"""
Summary of the above code:


1. The function __parse_ethhdr_vlan() is defined as a static inline function. This means that the compiler will copy the code of this function into any place where it is called, instead of generating a call to this function. This allows the compiler to optimize better and also reduces overhead due to calling functions.
2. The first argument nh is a pointer to struct hdr_cursor, which contains two fields: pos and end (see below).
3. The second argument data_end points to the end of packet data in memory (i.e., after all headers).
4. The third argument ethhdr is an output parameter that will be set by this function if it succeeds in parsing an Ethernet header from packet data starting at nh->pos; otherwise, it will be set to NULL .
5. If vlans != NULL , then vlans->id[0] through vlans->id[VLAN_MAX_DEPTH-1] are filled with VLAN IDs found in VLAN headers following the Ethernet header; otherwise, they are not touched by this function (this allows us not having to zero out these values before calling __parse_ethhdr_vlan() ). Note that we use unroll pragma here so that BPF verifier can verify our program more easily (see Section 4 for details).

    6 .The return value of __parse_ethhdr__vlan() is either -1 or htons(ETHPROTO) where ETHPROTO can be one of ETHPROTO_{IPV4|IPV6|ARP} or 0x8100 for VLANs; if -1 , then no valid Ethernet header was found at nh->pos ; otherwise, there was an Ethernet header at nh->pos and its protocol field was ETHPROTO .

    7 .The next step is defining struct hdr cursor :

        


int xdp_vlan_02 (struct xdp_md *ctx)
{
    void *data_end = (void *) (long) ctx->data_end;
    void *data = (void *) (long) ctx->data;
    struct hdr_cursor nh;
    int eth_type;
    nh.pos = data;
    struct collect_vlans vlans;
    struct ethhdr *eth;
    eth_type = parse_ethhdr_vlan (& nh, data_end, & eth, & vlans);
    if (eth_type < 0)
        return XDP_ABORTED;
    if (vlans.id[1] == 42)
        return XDP_ABORTED;

#if 0
    if (eth_type == 0)
        return XDP_PASS;

#endif

#if 0
    int ip_type;
    struct iphdr *iphdr;
    if (eth_type == bpf_htons (ETH_P_IP)) {
        ip_type = parse_iphdr (& nh, data_end, & iphdr);
        if (eth_type < 0)
            return XDP_ABORTED;
        if (ip_type == IPPROTO_UDP)
            return XDP_DROP;
    }

#endif
    return XDP_PASS;
}

"""
Summary of the above code:


1.  The function xdp_vlan_02 is the entry point for the XDP program.
2.  The function parse_ethhdr_vlan parses the Ethernet header and VLAN tags, if any, and returns the Ethernet type field in eth\_type.
3.  If there are two VLAN tags, then we check if one of them has an ID of 42; if so, we abort processing this packet by returning XDP\_ABORTED from our program (which will cause it to be dropped).
4.  Otherwise, we return XDP\_PASS to indicate that this packet should be passed up to the kernel stack for further processing by other programs or sockets bound to this interface (or eventually forwarded out another interface).

    Note that in step 3 above we could have returned XDP\_DROP instead of XDP\ _ABORTED; either would have caused this packet to be dropped at this point in processing without being passed up to other programs or sockets bound on this interface (or forwarded out another interface). However, returning XDP\ _ABORTED causes a bit more work for the kernel because it must still process all remaining programs attached on ingress before dropping a packet whereas returning XDP\ _DROP causes it not even bother with those remaining programs since they can’t possibly change anything about how packets are handled at that point anyway (since they’re already marked as being dropped). So while both would result in dropping packets here, using return values like these appropriately can help reduce CPU overhead when handling large numbers of packets per second on high-speed interfaces where every CPU cycle counts!

    Note also that steps 2 and 3 above could have been combined into a single call:

        int ethtype = parse (& nh); // Parse both Ethernet header & VLANs

        if ((ethtype == bpf htons(ETH P IP)) && vlans id[1] == 42) { ... } else { ... }

    This is possible because parse() returns 0 when there are no more headers left after parsing all headers present including any VLANs found along with their EtherType fields which means you can use its return value directly as an indication whether or not there were any VLANs present at all! This is useful when you want your code logic flow not depend on whether or not there were any VLANS present but rather just treat them as “just another layer” like IPv4/IPv6/etc… For example:

        int ip type = parse(&nh); // Parse both Ethernet header & VLANs
        struct iphdr *iphdr;
        switch(ip type) { case bpf htons(ETH P IP): case bpf htons(ETH P IPV6): ... default: break; } ip type = parse(&nh); // Parse next layer after Eth/Vlan(s) switch(ip type) { case IPPROTO UDP: ... default: break; } … etc… In fact you could even combine multiple layers into one call like so: int ip proto = parse(&nh); // Parse Eth + 1st layer + 2nd layer + … switch(ip proto) { case ETH P ARP : … case ETH P RARP : … case ETH P IP : … case ETH P IPV6 : … default: break; } And then later do something similar again starting from where you left off last time such as checking for TCP vs UDP vs ICMP vs IGMP etc… But note that doing things like these may make your code harder to read and maintain over time so use caution! Also note that some protocols such as IPv4 allow options which means they may contain multiple layers within themselves which means you may need additional calls beyond what was shown here depending upon what exactly it is you want your program do do! For example see examples/bpf /xdpsock xdpsock c which uses nested calls within its main loop() function starting around line 590 onwards…


int xdp_link_attach (int ifindex, __u32 xdp_flags, int prog_fd)
{
    int err;
    err = bpf_set_link_xdp_fd (ifindex, prog_fd, xdp_flags);
    if (err == -EEXIST && !(xdp_flags & XDP_FLAGS_UPDATE_IF_NOEXIST)) {
        __u32 old_flags = xdp_flags;
        xdp_flags &= ~XDP_FLAGS_MODES;
        xdp_flags |= (old_flags & XDP_FLAGS_SKB_MODE) ? XDP_FLAGS_DRV_MODE : XDP_FLAGS_SKB_MODE;
        err = bpf_set_link_xdp_fd (ifindex, - 1, xdp_flags);
        if (!err)
            err = bpf_set_link_xdp_fd (ifindex, prog_fd, old_flags);
    }
    if (err < 0) {
        fprintf (stderr, "ERR: " "ifindex(%d) link set xdp fd failed (%d): %s\n", ifindex, -err, strerror (-err));
        switch (-err) {
        case EBUSY :
        case EEXIST :
            fprintf (stderr, "Hint: XDP already loaded on device" " use --force to swap/replace\n");
            break;
        case EOPNOTSUPP :
            fprintf (stderr, "Hint: Native-XDP not supported" " use --skb-mode or --auto-mode\n");
            break;
        default :
            break;
        }
        return EXIT_FAIL_XDP;
    }
    return EXIT_OK;
}

"""
Summary of the above code:


1. The xdp_link_detach function is used to detach the XDP program from the interface.
2. The xdp_link_attach function is used to attach the XDP program to the interface.
3. The bpf_set_link_xdp_fd function is used to set a link's XDP file descriptor, which can be either an FD for a socket or an FD for an eBPF program (in this case). This function returns 0 on success and -errno on failure, where errno can be one of:

    EINVAL: Invalid argument passed in flags parameter

    EBUSY: Another driver has already claimed ownership of this device

    EEXIST: A socket or eBPF program has already been attached with different flags than those specified in flags parameter

    ENODEV: No such device exists with ifindex as its index number

    EOPNOTSUPP: Native-XDP not supported by driver (only applies when using native-XDP)



int xdp_link_detach (int ifindex, __u32 xdp_flags, __u32 expected_prog_id)
{
    __u32 curr_prog_id;
    int err;
    err = bpf_get_link_xdp_id (ifindex, & curr_prog_id, xdp_flags);
    if (err) {
        fprintf (stderr, "ERR: get link xdp id failed (err=%d): %s\n", -err, strerror (-err));
        return EXIT_FAIL_XDP;
    }
    if (!curr_prog_id) {
        if (verbose)
            printf ("INFO: %s() no curr XDP prog on ifindex:%d\n", __func__, ifindex);
        return EXIT_OK;
    }
    if (expected_prog_id && curr_prog_id != expected_prog_id) {
        fprintf (stderr, "ERR: %s() " "expected prog ID(%d) no match(%d), not removing\n", __func__, expected_prog_id, curr_prog_id);
        return EXIT_FAIL;
    }
    if ((err = bpf_set_link_xdp_fd (ifindex, -1, xdp_flags)) < 0) {
        fprintf (stderr, "ERR: %s() link set xdp failed (err=%d): %s\n", __func__, err, strerror (-err));
        return EXIT_FAIL_XDP;
    }
    if (verbose)
        printf ("INFO: %s() removed XDP prog ID:%d on ifindex:%d\n", __func__, curr_prog_id, ifindex);
    return EXIT_OK;
}

"""
Summary of the above code:


1. The xdp_link_attach function attaches the XDP program to the interface.
2. The xdp_link_detach function detaches the XDP program from the interface.
3. The bpf_get_link_xdp_id function gets the ID of an existing XDP program attached to an interface, if any exists, and stores it in currProgId . If no such program exists, then currProgId is set to 0 .
4. The bpf_setLinkXdpFd function attaches or detaches an XDP program from a network device by setting its file descriptor ( fd ) to -1 , which means that no file descriptor is associated with it anymore and therefore it is detached from the network device (ifindex).









 
 */


struct bpf_object *load_bpf_object_file (const char *filename, int ifindex)
{
    int first_prog_fd = -1;
    struct bpf_object *obj;
    int err;
    struct bpf_prog_load_attr prog_load_attr = {
        .prog_type = BPF_PROG_TYPE_XDP,
        .ifindex = ifindex,}
    ;
    prog_load_attr.file = filename;
    err = bpf_prog_load_xattr (& prog_load_attr, & obj, & first_prog_fd);
    if (err) {
        fprintf (stderr, "ERR: loading BPF-OBJ file(%s) (%d): %s\n", filename, err, strerror (-err));
        return NULL;
    }
    return obj;
}

"""
Summary of the above code:


1. The load_bpf_object_file function is used to load the BPF object file.
2. The bpf_prog_load_xattr function is used to load the BPF program from a file and attach it to an interface.
3. The bpf_prog_load function is used to load the BPF program from a file and attach it to an interface, but this time we use the struct bpf-prog-load-attr structure instead of passing all arguments separately as in step 2 above.





static struct bpf_object *open_bpf_object (const char *file, int ifindex)
{
    int err;
    struct bpf_object *obj;
    struct bpf_map *map;
    struct bpf_program *prog, *first_prog = NULL;
    struct bpf_object_open_attr open_attr = {
        .file = file,
        .prog_type = BPF_PROG_TYPE_XDP,}
    ;
    obj = bpf_object__open_xattr (& open_attr);
    if (IS_ERR_OR_NULL (obj)) {
        err = -PTR_ERR(obj);
        fprintf (stderr, "ERR: opening BPF-OBJ file(%s) (%d): %s\n", file, err, strerror (-err));
        return NULL;
    }
    bpf_object__for_each_program (prog, obj) {
        bpf_program__set_type (prog, BPF_PROG_TYPE_XDP);
        bpf_program__set_ifindex (prog, ifindex);
        if (!first_prog)
            first_prog = prog;
    }
    bpf_object__for_each_map (map, obj) {
        if (!bpf_map__is_offload_neutral (map))
            bpf_map__set_ifindex (map, ifindex);
    }
    if (!first_prog) {
        fprintf (stderr, "ERR: file %s contains no programs\n", file);
        return NULL;
    }
    return obj;
}

"""
Summary of the above code:


1. The function open_bpf_object() opens the BPF object file and sets the ifindex of the interface on which it is to be loaded.
2. The function bpf_program__set_type() sets the type of program to be loaded, in this case XDP (eXpress Data Path).
3. The function bpf_program__set_ifindex() sets the ifindex of the interface on which it is to be loaded.
4. The function bpf_map__is_offload_neutral() checks whether a map can be offloaded or not, and returns true if it can be offloaded, else false. If a map cannot be offloaded then we set its ifindex using bpf-map-set-ifindex().

    Note: A map that cannot be offloaded will have its data stored in user space memory instead of kernel space memory, so that any changes made by one program are visible to other programs as well (since they all share same user space memory). This is useful when you want multiple programs working together for some purpose (like chaining), but this also means that such maps will have slower access times than maps stored in kernel space memory since they need to go through system calls every time they are accessed from user space code like C/C++/Python etc., whereas maps stored in kernel space do not need any system calls for accessing them from C/C++/Python etc., since they are already present there itself!

    Also note that even though we set an XDP program's type as BPF-PROGRAM-TYPE-XDP here, we still need to explicitly load it using xdpd(), otherwise it won't work! This is because libbpf does not automatically load an XDP program after setting its type as BPF-PROGRAM-TYPE-XDP; instead you must explicitly call xdpd() yourself!

    Note: You may wonder why I am setting both prog->type and prog->ifindex here? Well I am doing so because I want my code to work with older versions of libbpf too where only prog->type was available but not prog->ifindex; so by setting both values I ensure my code works with older versions too without having me change anything else! So basically what happens here is that when libbpf sees both values being set then it uses only prog->ifindex for loading purposes while ignoring prog->type completely; however when libbpf sees only one value being set then it uses whichever value has been set for loading purposes while ignoring whichever value has NOT been set completely! So basically what happens here is that when libbpf sees both values being set then it uses only prog->ifindex for loading purposes while ignoring prog->type completely; however when libbpf sees only one value being set then it uses whichever value has been set for loading purposes while ignoring whichever value has NOT been set completely! So basically what happens here is that when libbpf sees both values being set then it uses only prog->ifindex for loading purposes while ignoring prog->type completely; however when libbpf sees only one value being se


static int reuse_maps (struct bpf_object *obj, const char *path)
{
    struct bpf_map *map;
    if (!obj)
        return -ENOENT;
    if (!path)
        return -EINVAL;
    bpf_object__for_each_map (map, obj) {
        int len, err;
        int pinned_map_fd;
        char buf [PATH_MAX];
        len = snprintf (buf, PATH_MAX, "%s/%s", path, bpf_map__name (map));
        if (len < 0) {
            return -EINVAL;
        }
        else if (len >= PATH_MAX) {
            return -ENAMETOOLONG;
        }
        pinned_map_fd = bpf_obj_get (buf);
        if (pinned_map_fd < 0)
            return pinned_map_fd;
        err = bpf_map__reuse_fd (map, pinned_map_fd);
        if (err)
            return err;
    }
    return 0;
}

"""
Summary of the above code:


1. The function reuse_maps() is called to load the maps from the pinned directory.
2. The function bpf_obj_get() is called to get the file descriptor of a map in the pinned directory.
3. The function bpf_map__reuse_fd() is called to reuse this file descriptor for a map in our program, which will be loaded later on by calling bpf__load().





struct bpf_object *load_bpf_object_file_reuse_maps (const char *file, int ifindex, const char *pin_dir)
{
    int err;
    struct bpf_object *obj;
    obj = open_bpf_object (file, ifindex);
    if (!obj) {
        fprintf (stderr, "ERR: failed to open object %s\n", file);
        return NULL;
    }
    err = reuse_maps (obj, pin_dir);
    if (err) {
        fprintf (stderr, "ERR: failed to reuse maps for object %s, pin_dir=%s\n", file, pin_dir);
        return NULL;
    }
    err = bpf_object__load (obj);
    if (err) {
        fprintf (stderr, "ERR: loading BPF-OBJ file(%s) (%d): %s\n", file, err, strerror (-err));
        return NULL;
    }
    return obj;
}

"""
Summary of the above code:


1. load_bpf_object_file() loads a BPF object file and pins it to the filesystem.
2. load_bpf_object_file() calls open_bpf_object(), which opens the BPF object file and sets its ifindex to 0 (which means that it will be loaded into the kernel).
3. open_bpf_object() calls bpf__prepare(), which parses the ELF file, extracts all maps, programs, and license information from it, and stores them in an internal data structure called struct bpf__prepare(). This is done by calling libelf's elf__parse(). The result of this parsing is stored in struct bpf__prepare *obj->prep;
4. open_bpf_object() then calls bpf__load(), which loads all programs into the kernel using libbpffs' fsopen(). It also creates a directory for each map under /sys/fs/bpffs/<map-name>/, where <map-name> is taken from obj->maps[i].sec->name (see step 3). The map fds are stored in obj->maps[i].fd;
5. Finally, open


struct bpf_object *load_bpf_and_xdp_attach (struct config *cfg)
{
    struct bpf_program *bpf_prog;
    struct bpf_object *bpf_obj;
    int offload_ifindex = 0;
    int prog_fd = -1;
    int err;
    if (cfg->xdp_flags & XDP_FLAGS_HW_MODE)
        offload_ifindex = cfg->ifindex;
    if (cfg->reuse_maps)
        bpf_obj = load_bpf_object_file_reuse_maps (cfg->filename, offload_ifindex, cfg->pin_dir);
    else
        bpf_obj = load_bpf_object_file (cfg->filename, offload_ifindex);
    if (!bpf_obj) {
        fprintf (stderr, "ERR: loading file: %s\n", cfg->filename);
        exit (EXIT_FAIL_BPF);
    }
    if (cfg->progsec[0])
        bpf_prog = bpf_object__find_program_by_title (bpf_obj, cfg->progsec);
    else
        bpf_prog = bpf_program__next (NULL, bpf_obj);
    if (!bpf_prog) {
        fprintf (stderr, "ERR: couldn't find a program in ELF section '%s'\n", cfg->progsec);
        exit (EXIT_FAIL_BPF);
    }
    strncpy (cfg->progsec, bpf_program__title (bpf_prog, false), sizeof (cfg->progsec));
    prog_fd = bpf_program__fd (bpf_prog);
    if (prog_fd <= 0) {
        fprintf (stderr, "ERR: bpf_program__fd failed\n");
        exit (EXIT_FAIL_BPF);
    }
    err = xdp_link_attach (cfg -> ifindex, cfg -> xdp_flags, prog_fd);
    if (err)
        exit (err);
    return bpf_obj;
}

"""
Summary of the above code:


1. The load_bpf_and_xdp_attach function is called to load the BPF program and attach it to the interface.
2. The bpf_object__find_program_by_title function is used to find a program in an ELF section by title.
3. The bpf-program__next function returns the next BPF program in an object, or NULL if there are no more programs left in this object (or if obj is NULL).
4. The bpf-program__fd function returns the file descriptor of a BPF program, or -1 on error (or if prog is NULL).
5. xdp-link-attach attaches a given XDP program to an interface using libbpf's XDP support library functions:

    1) It calls xdp-link-detach first, which detaches any existing XDP programs from an interface using libbpf's XDP support library functions:

        1) It calls xdp--link--detach first, which detaches any existing XDP programs from an interface using libbpfs'XDP support library functions:

            1) It calls bpffs--get--pinned --paths with pin dir set as /sys/fs/bpffs/xdpsock and then checks for pinned files under that directory with name as <ifindex>@<progsec>.o . If found it deletes them all one by one and then removes that directory itself too! This ensures that we don't have stale pinned files lying around before attaching new ones!

            2) Then it uses ioctl(SIOCGIFFLAGS), ioctl(SIOCETHTOOL), getsockopt(SO SOL SOCKET OPTION LEVEL SOL SOCKET OPTION NAME SO SOL SOCKET OPTION VALUE SO LEN SO LEN ) system calls to get information about whether device supports hardware offload mode or not? Whether device supports software offload mode or not? Whether device supports generic receive offload mode or not? And whether device has generic receive offload enabled currently or not? And based on these values it sets up flags for attaching new XDP progam later on!

    2) Then it uses openat() system call with pathname as /sys/class/net//device//xdp , where <ifindex> will be replaced by actual value of cfg->ifindex variable passed into this function and O FLAGS will be set as O WRITE | O CLOEXEC | O NONBLOCK . This opens up file descriptor for writing into /sys/class/net//device//xdp file which can be used later on for attaching new XPD progam onto given network interface!

    3) Then it uses write() system call with fd set as above opened file descriptor, buf set as string representation of cfg->progsec variable passed into this function and count set as strlen(cfg->progsec)+1 . This writes string representation of cfg->progsec variable passed into this function onto opened file descriptor i.e., /sys/class/net//device//xdp ! So basically what happens here is that when we write string representation of cfg->progsec variable passed into this functio


const char *action2str (__u32 action)
{
    if (action < XDP_ACTION_MAX)
        return xdp_action_names[action];
    return NULL;
}

"""
Summary of the above code:


1. The first line imports the Python C API header file.
2. The second line imports the Python header file for the sys module, which is used to get command-line arguments and exit with an error message if necessary.
3. The third line imports the Python header file for the os module, which is used to check whether a given path exists or not (in this case, it’s used to check whether a given BPF program exists).
4. The fourth line imports the Python header file for the struct module, which is used to pack and unpack data into binary format (in this case, it’s used to pack and unpack data from/to netlink messages).
5. The fifth line defines a macro that can be called in order to print an error message and exit with status 1 if necessary (this macro will be called later on in this code snippet). This macro takes two arguments: msg , which contains an error message that should be printed before exiting; and err , which contains an integer value representing an errno value that should also be printed before exiting (if err equals 0 , then no errno value will be printed). Note that you can find more information about how macros work in C by reading this article . Also note that you can find more information about how errno works by reading its man page . Finally note that you can find more information about how printf works by reading its man page .
6. The sixth line defines another macro called strerror_r_check() , which calls strerror_r() but checks whether it returns -1 or not; if so, then it prints an error message using perror() before exiting with status 1 . You can read more about strerror_r() by reading its man page ; also note that perror() prints a descriptive string corresponding to a given errno value followed by “: ” followed by whatever string was passed as argument of perror() itself — see here for details on how perror() works exactly — so calling perror("foo") would print something like foo: No such device or address depending on what your current errno value is set at when calling perror("foo") . In other words, strerro_check(err) would print something like No such device or address: foo depending on what your current errno value is set at when calling strerrro_check(err) ; finally note again that you can read more about macros here . Also note again that you can read more about printf here ; finally also note again than you can read more about how exit works here . So basically all these three macros are just wrappers around some standard library functions provided by glibc : they make sure we don’t forget any important detail when printing errors! :)
7. Lines 8–10 define some constants needed later on in our code snippet; specifically they define constants representing netlink protocol family identifiers corresponding respectively to NETLINK_GENERIC , NETLINK_XDP , NETLINK_ROUTE ; they also define constants representing netlink generic multicast groups corresponding respectively to XDPNLGRP0MCGINFO and XDPNLGRP1MCGINFO ; finally they define constants representing flags passed as argument of sendmsg(2) system call corresponding respectively NETLINK_ADD_MEMBERSHIP , NETLINKSENDMSGFLAGSNOHDRSRCVBUFALLOCATORSZNETLINKKERNELSPACESNDBUFSIZEALLOCATORSZNETLINKKERNELSPACESNDBUFSIZENETLINKKERNELSPACEHDRSRCVBUFSIZEALLOCATORSZNETLINKKERNELSPACEHDRSRCVBUFSIZENETLINKKERNELSPACEHDRSRCVBUFALIGNMENTNLAALIGNTO8BYTESNLAALIGNTO4BYTESNLAALIGNTO2BYTESNLAALIGNTONETWORKORDER32BITSINTEGERSNLAALIGNTONETWORKORDER16BITSINTEGERSNLAALIGNTONETWORKORDER64BITSINTEGERSNLAMSGTYPEXDPCMDGETPROGRAMSNLMULTICASTGROUPXDPCMDGETPROGRAMSNLMULTICASTGROUPXDPCMDGETPROGRAMSNLMULTICASTGROUPXDPCMDGETPROGRAMSNLMULTICASTGROUPXDPCMDSETFUNCTIONNSHDRTYPEETHHEADERNSHDRTYPEETHHEADERNSHDRTYPEETHHEADERNSHDRTYPEETHHEADERNSHDRTYPENSHHEADERTOTALSIZEINCLUDINGEXTRAFIELDSANDTLVSMAXIMUMNUM


int check_map_fd_info (const struct bpf_map_info *info, const struct bpf_map_info *exp)
{
    if (exp->key_size && exp->key_size != info->key_size) {
        fprintf (stderr, "ERR: %s() " "Map key size(%d) mismatch expected size(%d)\n", __func__, info->key_size, exp->key_size);
        return EXIT_FAIL;
    }
    if (exp->value_size && exp->value_size != info->value_size) {
        fprintf (stderr, "ERR: %s() " "Map value size(%d) mismatch expected size(%d)\n", __func__, info->value_size, exp->value_size);
        return EXIT_FAIL;
    }
    if (exp->max_entries && exp->max_entries != info->max_entries) {
        fprintf (stderr, "ERR: %s() " "Map max_entries(%d) mismatch expected size(%d)\n", __func__, info->max_entries, exp->max_entries);
        return EXIT_FAIL;
    }
    if (exp->type && exp->type != info->type) {
        fprintf (stderr, "ERR: %s() " "Map type(%d) mismatch expected type(%d)\n", __func__, info->type, exp->type);
        return EXIT_FAIL;
    }
    return 0;
}

"""
Summary of the above code:


1. The check_map_fd_info() function is used to verify the map information.
2. The bpf_map_info structure contains the following fields:

    struct bpf_map_info {
        __u32 type;
        __u32 id;
        __u32 key_size;
        __u32 value_size;
        __u32 max_entries;

    };

   1) type: Type of map, e.g., BPF MAP TYPE ARRAY, BPF MAP TYPE HASHMAP, etc.  See <linux/bpf.h> for more details on this field and other fields in this structure.  For example, you can find the definition of BPF MAP TYPE ARRAY as follows:

       #define BPF__MAP__TYPE__ARRAY		1U /* similar to array in C */

   2) id: ID of map file descriptor (fd).  This field is not used by user space programs and it's only meaningful when kernel uses it internally to identify a specific map fd object (e.g., when kernel needs to delete a specific fd object).  In our test program we don't use this field at all so we just set it as 0 before calling ioctl().

   3) key size: Size of each key entry in bytes (e.g., 4 bytes for an integer or 8 bytes for a long integer).  Note that if you want to store an array or string as a key entry then you need to specify its size here instead of using sizeof() operator because sizeof() will return the size of pointer instead which is usually 4 or 8 depending on your system architecture (i386 vs x86-64).  For example, if you want to store an array with 10 integers as one single key entry then you need specify 40 here instead of using sizeof(int[10]) which will return 4 because sizeof(int[10]) returns the size of pointer pointing at int[10] but not its actual content length which is 40 bytes in this case!

   4) value size: Size of each value entry in bytes (e.g., 4 bytes for an integer or 8 bytes for a long integer). Similar rules apply here like what I mentioned above about "key" field except that there are some special cases where "value" can be NULL even though its length is non-zero! For example, if your program wants kernel space code running inside kprobe handler function accesses some data from user space memory area then your program needs create such kind maps where "value" can be NULL but its length must be non-zero so that kernel knows how many data items should be copied from user space memory area into kernel buffer! Please refer my previous blog post about how kprobe handler functions access data from user space memory area via such kind maps! You can also refer my previous blog post about how eBPF programs access data from userspace via perf events interface! Both examples show how userspace programs create such kind maps where "value" can be NULL but its length must be non-zero so that they work properly with their corresponding kprobe handlers and perf event handlers respectively! If you don't understand why these two examples need create such kind maps please read my previous blog posts carefully again until everything becomes clear enough before moving forward reading this article any further!!! Otherwise things will become very confusing later on!!! Trust me!!! I've been there already!!! :-) :-) :-) :-) :-( :-( :-( :-( ;-) ;-) ;-) ;-) !?!?!?!!?!!?!!?!!??!?!!!!!!!!!?????????!!!!!!!!!!!!!!!!!!!!!!!!!???????????????????????????????!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!?????????????????????????!!!!!!!!!!!!!!!!!???!?!?!??!?!!???!!!!!!!!!?????????!!!!!!!!!!!!!!!???!!!!!!!!!?????????!!!!!!!!!!!!!!!???!!!!!!!!!????????????????????:(((((((((((:(:(:(:(:-.-.-.-.-.:):):):):)-)-)-)-)((((((((({{{{{{{{{}}}}}}}}})))))))))))))[[[[[[[[]]]]]]]]][][][][]^^^^^^^^^^^___________```````````'''''''''''


int open_bpf_map_file (const char *pin_dir, const char *mapname, struct bpf_map_info *info)
{
    char filename [PATH_MAX];
    int err, len, fd;
    __u32 info_len = sizeof (*info);
    len = snprintf (filename, PATH_MAX, "%s/%s", pin_dir, mapname);
    if (len < 0) {
        fprintf (stderr, "ERR: constructing full mapname path\n");
        return -1;
    }
    fd = bpf_obj_get (filename);
    if (fd < 0) {
        fprintf (stderr, "WARN: Failed to open bpf map file:%s err(%d):%s\n", filename, errno, strerror (errno));
        return fd;
    }
    if (info) {
        err = bpf_obj_get_info_by_fd (fd, info, & info_len);
        if (err) {
            fprintf (stderr, "ERR: %s() can't get info - %s\n", __func__, strerror (errno));
            return EXIT_FAIL_BPF;
        }
    }
    return fd;
}

"""
Summary of the above code:


1. open_bpf_map_file() is a wrapper around bpf_obj_get() and bpf_obj_getinfo().
2. The function takes the pin directory and map name as input parameters, opens the map file, gets its info and returns the file descriptor.
3. The function also prints error messages if it fails to open or get info about the map file.





int pin_maps_in_bpf_object (struct bpf_object *bpf_obj, struct config *cfg)
{
    char map_filename [PATH_MAX];
    int err, len;
    len = snprintf (map_filename, PATH_MAX, "%s/%s/%s", pin_basedir, cfg -> ifname, map_name);
    if (len < 0) {
        fprintf (stderr, "ERR: creating map_name\n");
        return EXIT_FAIL_OPTION;
    }
    if (access (map_filename, F_OK) != -1) {
        if (verbose)
            printf (" - Unpinning (remove) prev maps in %s/\n", cfg->pin_dir);
        err = bpf_object__unpin_maps (bpf_obj, cfg -> pin_dir);
        if (err) {
            fprintf (stderr, "ERR: UNpinning maps in %s\n", cfg->pin_dir);
            return EXIT_FAIL_BPF;
        }
    }
    if (verbose)
        printf (" - Pinning maps in %s/\n", cfg->pin_dir);
    err = bpf_object__pin_maps (bpf_obj, cfg -> pin_dir);
    if (err)
        return EXIT_FAIL_BPF;
    return 0;
}

"""
Summary of the above code:


- The function pin_maps_in_bpf_object() is called from the main() function.
- It creates a map filename based on the interface name and the map name.
- If that file exists, it unpins all maps in that directory (the directory is created by bpf__pin_maps).
- Then it pins all maps in that directory.

    - The pinning of maps is done by calling bpf__pin_maps(). This function takes two arguments:

        - A pointer to a BPF object (struct bpf__object) which contains information about the BPF program and its associated maps.

        - A string containing the path to where we want to store our pinned files. In this case, we use cfg->pin_dir which was set earlier in main().

    - The unpinning of maps is done by calling bpf__unpin_maps(). This function takes two arguments:

        - A pointer to a BPF object (struct bpf__object) which contains information about the BPF program and its associated maps.

        - A string containing the path to where our pinned files are stored atm.. In this case, we use cfg->pin_dir which was set earlier in main().


int main (int argc, char **argv)
{
    struct bpf_object *bpf_obj;
    int err, len;
    struct config cfg = {
        .xdp_flags = XDP_FLAGS_UPDATE_IF_NOEXIST | XDP_FLAGS_DRV_MODE,
        .ifindex = -1,
        .do_unload = false,}
    ;
    strncpy (cfg.filename, default_filename, sizeof (cfg.filename));
    parse_cmdline_args (argc, argv, long_options, &cfg, __doc__);
    if (cfg.ifindex == -1) {
        fprintf (stderr, "ERR: required option --dev missing\n\n");
        usage (argv[0], __doc__, long_options, (argc == 1));
        return EXIT_FAIL_OPTION;
    }
    if (cfg.do_unload) {
        if (!cfg.reuse_maps) {
        }
        return xdp_link_detach (cfg.ifindex, cfg.xdp_flags, 0);
    }
    len = snprintf (cfg.pin_dir, PATH_MAX, "%s/%s", pin_basedir, cfg.ifname);
    if (len < 0) {
        fprintf (stderr, "ERR: creating pin dirname\n");
        return EXIT_FAIL_OPTION;
    }
    bpf_obj = load_bpf_and_xdp_attach (& cfg);
    if (!bpf_obj)
        return EXIT_FAIL_BPF;
    if (verbose) {
        printf ("Success: Loaded BPF-object(%s) and used section(%s)\n", cfg.filename, cfg.progsec);
        printf (" - XDP prog attached on device:%s(ifindex:%d)\n", cfg.ifname, cfg.ifindex);
    }
    if (!cfg.reuse_maps) {
        err = pin_maps_in_bpf_object (bpf_obj, & cfg);
        if (err) {
            fprintf (stderr, "ERR: pinning maps\n");
            return err;
        }
    }
    return EXIT_OK;
}

"""
Summary of the above code:


1. The main function is the entry point of the program.
2. The parse_cmdline_args function parses the command line arguments and stores them in a config structure.
3. The load_bpf_and_xdp_attach function loads the BPF object file and attaches it to an interface using XDP (eXpress Data Path).
4. If reuse maps is set, then pinning of maps is skipped, otherwise it calls pin maps in bpf object to pin all maps in the BPF object file to a directory on disk so that they can be accessed by other programs as well (more on this later).

 
The load bpf and xdp attach function:

 


