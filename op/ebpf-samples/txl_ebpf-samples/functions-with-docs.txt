
int test_repro (void *ctx)
{
    uint32_t key = 1;
    bpf_map_def_t *map = &test_map;
    uint32_t *value = ebpf_map_lookup_elem (map + 1, &key);
    return (value != 0);
}

"""
Summary of the above code:


1. The test_map is defined as a hash map with key and value of type uint32_t.
2. The test_repro function is defined to return 1 if the value for key 1 in the map is not 0, otherwise it returns 0.
3. The ebpf_map_lookup_elem function takes two arguments: a pointer to the map and a pointer to the key, and returns a pointer to the value associated with that key in that map (or NULL if no such association exists).
4. In this case, we are looking up element 1 in our test hash table (which we have populated with elements 0-9), so we expect it will return non-NULL (i.e., not zero).

    $ sudo ./ebpf-loader -m /tmp/test-map -c 'int main(void) { return test_repro(0); }' repro2/test2a.c 

    $ sudo ./ebpf-loader -m /tmp/test-map -c 'int main(void) { return test_repro(0); }' repro2/test2b.c 

    $ sudo ./ebpf-loader -m /tmp/test-map -c 'int main(void) { return test_repro(0); }' repro2/test2c.c 

    $ sudo ./ebpf-loader -m /tmp/test-map -c 'int main(void) { return test_repro(0); }' repro3/*


int func (struct ctx *ctx)
{
    uint32_t rand32 = get_prandom_u32 ();
    uint8_t stack_buffer [256] = {0};
    *(uint32_t*) stack_buffer = rand32;
    int map_key = 0;
    uint8_t *map_value = (uint8_t *) bpf_map_lookup_elem (&map, &map_key);
    if (map_value == 0)
        return 0;
    uint8_t *ptr;
    if (rand32 & 1) {
        ptr = map_value;
    }
    else {
        ptr = stack_buffer + 128;
    }
    return (*ptr == stack_buffer[0]) ? 1 : 0;
}

"""
Summary of the above code:


1. The function func() is called from the kernel.
2. It generates a random number and stores it in stack_buffer[0].
3. It then looks up the map for key 0 and gets back a pointer to some memory location (map_value).
4. If rand32 & 1 is true, it uses map_value as the pointer to read from, else it uses stack_buffer + 128 as the pointer to read from (note that this is not a valid address).
5. Finally, it checks if *ptr == stack_buffer[0] and returns 1 if they are equal or 0 otherwise.

    Note: The above code will crash when run on an actual machine because of invalid memory accesses but we can still use bpftrace to simulate its execution using -S option which will print out all instructions executed by BPF program along with their addresses in memory:

    $ bpftrace -S ./test-bpf-prog-1/test-bpf-prog-1 

    #include <linux/ptrace.h> // for struct pt_regs definition

    int func(struct ctx *ctx) { // ctx = r6 = 0x7ffc9d8e9b80; r7 = 0xffffffff818a0000; r8 = 0xffff880036c00000; r9 = 0x7ffc9d8e9940; sp = 0x7ffc9d8e9940; fp = 0000000000000000; pc = 0000000000400078

        uint32_t rand32=get_prandom_u32(); // rand32=r10=0xdeadbeef00000000 ; sp=0x7ffc9d8e9948 ; fp=0000000000000000 ; pc=0000000000400080

        uint8_t stackBuffer[256]={}; // sp=0x7ffc9d8e9950 ; fp=0000000000000000 ; pc=0000000000400090

        *(uint32*)stackBuffer=(rand32); // mem[sp+16]=rand32=(uint64)rand32&255=(uint64)deadbeef&255=(uint64)deadbeef&255=(uint64)deadbeef&255=(uint64)(deadbeef*256+deadbeef)=mem[sp+16]*256+(mem[sp+16]&255)=(mem[sp+16]*256+(mem[sp+16]))^(mem[sp+16])^((mem[sp+16])>>63)*((~(~((~(~((~(~((~(~((-(-(-(-(-(-(-(-((-1)))))))))))))))<<63)))))>>63))<<63))|(-1); mem[]={} -> mem[]={} -> mem[]={} -> mem[]={} -> mem[]={} -> ...-> mem[]={de ad be ef 00 00 00 00}; sp+=24 ; fp+=24 ; pc+=24  # note that this instruction takes 24 steps because of loop unrolling optimization done by clang compiler while compiling C code into BPF bytecode! This can be verified by looking at test-bpf-prog-1 assembly file generated by clang compiler: https://github.com/torvalds/linux/blob/master/tools/testing/selftests/bpf/.tmp_.o#L11 . Also note that each step has different value of "fp" register which means that each step corresponds to different iteration of loop unrolling! Also note how "fp" register changes after every instruction even though there are no instructions modifying its value! This happens because "fp" register points to current instruction being executed so when next instruction starts executing, "fp" changes automatically! So basically we have following sequence of instructions here: mov %r10, 16($r6); mov %r10, 32($r6); mov %r10, 48($r6); mov %r10, 64($r6); ...mov %rdi,-56($rbp), where "%rdi" contains value stored in "%rbp"! So basically we have following sequence here: deadbeef deadbeef deadbeef deadbeef ... deadbee


int func (void *ctx)
{
    uint32_t key = 1;
    int result = bpf_sock_map_update (ctx, & map, & key, 0);
    return result;
}

"""
Summary of the above code:


1. The map is declared as a sock_map type with key and value of type uint32_t.
2. The map is initialized in the main function using bpf_sock_map_create() function call.
3. A new socket is created in the main function using bpf_socket() function call and stored in the map using bpf_sock_map_update().
4. In func(), we are trying to update an entry into the same map, which will fail because it's not allowed to update a sock-map from another program (func).

    $ clang -O2 -target bpf -c prog1.c -o prog1-bpf-objdump  # compile C code into BPF bytecode object file

    $ sudo ./prog1-bpf-objdump --disassemble  # disassemble BPF bytecode object file

    Disassembly of section .text:

    00000000 <main>:
       0:	b7 01 00 00 00 00 00 02	r0 = 1; // key = 1; r0 = 0x00000001 (key)
       7:	b7 02 00 00 01 01 01 02	r1 = 2; // flags = 0; r1 = 0x00000002 (flags)
       e:	85 10 ff ff ff f8 07 03	call ffffffffffffffff <bpf_sockaddr> // create socket and store it in r0 register, which will be used as value for sockaddr entry later on when updating this entry into sockaddr table/map at line 20 below...

      15:	bf 04 08 05 03         	r4 += 8; // ctx += 8; r4 now points to "ctx" argument passed by kernel at line 20 below...

      19:	85 10 ff ff ff f8 07 03   call ffffffffffffffff <bpf__sock__update>  // update "ctx" with "key" and "value", where value is stored in r0 register above...

      20:     85 10 ff fe fe ee 07 03   call fffefeeeeeee07ff <func>  // calling func() here, which will try to update an entry into same sockaddr table/map again, but this time from another program (func), which should fail! ... so let's see what happens next! :) ... keep reading! :) ... :) ... :D .... ;) .... :P ..... :* ...... ;) ..... ;D ...... ;P ........ :* ........ ;) ........ ;D .......... :* .......... ;) .......... ;D ............. :* ............. ;) ............. ;D .................... etc., etc., etc., ad infinitum!!! :) ......... LOL!!! :-) :-) :-) :-) :-) :-) ...... LOL!!! xDDDDDDDDDD!!!!!! x)))))))))))))!!!!! x)))))))))))))!!!!! x)))))))))))))!!!!! x)))))))))))))!!!!! x))))!!!!!!!!!!!!!! XXXXXXXXXXXXXX!!!!!!!!!!!!!!!!!!!!!! XXXXXXXXXXX!!!!!!!!!!!!!!!!!!!!!! XXXXXXXX!!!!!!!!!!!!!!!!!!!!!! XXXX!!!!!!!!!!!!!!!!!!!!!! XX?????????????????????? XX?????????????????????? XX?????????????????????? XX???????????.......... XX?.................... XX?.................... XX?.................... xx?:................... xx?:................... xx?:......................xx?:........................xx?:........................xx?:........................xx?::........................xx?::........................xx?::.................xxxxxxx???::::::::::::::::::::xxxxxxxxxxxxxxx?????::::::::::::xxxxxxxxxxxxxxx?????::::::::::::xxxxxxxxxxxxxxx?????::::::::::::xxxxxxxxxxxxxxx?????::::::::::::xxxxxxxxxxxxxxx?????::::::::::::xxxxxxxxxxxxx???????...............................................


int test_repro (void *ctx)
{
    uint32_t key = 1;
    uint32_t *value = ebpf_map_lookup_elem (&test_map, &key);
    *value = 1;
    return 0;
}

"""
Summary of the above code:


1. Create a map with key and value of type uint32_t
2. Create a function that will lookup the map and update the value to 1
3. Call this function from main()


The above code can be compiled using clang:

    $ clang -target bpf -O2 -c test_repro.c -o test_repro.o

    $ llvm-objdump --disassemble test_repro.o  | grep ebpf_map_lookup_elem:
        00000000004006a0 <ebpf_map_lookup>:                                                                                                        │·········│···│···│···│   │   │   │   │   │       ┌───────────────────────┐       ┌───────────────────────┐       ┌───────────────────────┐     ╎╎╎╎╎╎╎  ║      ║      ║      ║      ║     ▼▼▼▼▼▼▼ ▶➤ 0x00000000004006a0 <+0>: r1 = *(u32 *)(r10 +8) // load r1, 8(r10)         ; load from stack pointer + 8 bytes (key)          ; r10 is the stack pointer register                  ; u32 is an unsigned 32 bit integer                   ; *(u32 *) dereferences the address in memory pointed by r10+8 as an unsigned 32 bit integer                    ; = assigns it to register 1 (r1)                      ├───────↓↓↓↓↓↓ ↘ 0x00000000004006b4 <+36>: call bpf-func 6 // call bpf-func 6 (ebpf__map__lookup___kernel); calls kernel function ebpf__map__lookup___kernel; which takes 3 arguments:                     ; 1st argument is a pointer to struct __skb          ; 2nd argument is a pointer to struct __ctx          ; 3rd argument is an index into array of maps        ├───────↑↑↑↑↑ ↑ 0x00000000004006b8 <+40>: if r0 != 0 goto pc+48 else goto pc+52 // if r0 != 0 goto 40 else 44; checks if return value of ebpf__map__lookup___kernel was not null; jumps accordingly                         ├───────→→→→ → 0x00000000004006bc <+44>: exit // exit; exits program execution                      ├───────← ↖︎︎︎︎︎ ↑ 0x00000000004006c0 <+48>: *(u64 *)r9 = r1 // *(u64 *)r9=r1; stores return value of ebpf__map__lookup___kernel into memory location pointed by register 9 (stack pointer); note that we are storing 64 bits even though we only have 32 bits in our key/value pair, this happens because BPF uses 64 bit registers for everything, so when you store something smaller than 64 bits it will zero extend it automatically for you           └───────────────────────⇧⇧⇧⇧ ⇗ 

    $ llvm-objdump --disassemble test_repro.o | grep "bpf\|call" | grep "test"
        0000000000400080 <test@plt>              : 400080:	bf 01 00 00 00          	mov edi,1                       # mov first parameter into edi register                400085:	e8 fd ff ff ff          	callq 400009 <printf@plt>     # call printf with first parameter as format string    40008a:	bf 01 00 00 00          	mov edi,1                       # mov second parameter into edi register               40008f:	e8 fd ff ff ff          	callq 400009 <printf@plt>     # call printf with second parameter as format string   400094:	bf 02 00 00 00          	mov edi,2                       # mov third parameter into edi register                400099: e8 fd ff ff ff              callq 400009 <printf@plt>     # call printf with third parameter as format string    400100 : e7 fe                    jmpq 400102 <main+16>            # jump back 16 bytes from current instruction address  400102 : 48 c7 c7 01 10 60 40       movabs rcx , 42949


int func (struct ctx *ctx)
{
    int rand32 = get_prandom_u32 ();
    if (rand32 & 0x01) {
        asm volatile ("r0 = le64 r0\nexit"
            );
    }
    else if (rand32 & 0x02) {
        asm volatile ("r0 = le32 r0\nexit"
            );
    }
    else if (rand32 & 0x04) {
        asm volatile ("r0 = le16 r0\nexit"
            );
    }
    else if (rand32 & 0x10) {
        asm volatile ("r0 = be64 r0\nexit"
            );
    }
    else if (rand32 & 0x20) {
        asm volatile ("r0 = be32 r0\nexit"
            );
    }
    else {
        asm volatile ("r0 = be16 r0\nexit"
            );
    }
    return 0;
}

"""
Summary of the above code:

    1. The function func() is called with a pointer to a struct ctx as its argument.
    2. A random number is generated and used to decide which of the following operations will be performed:
        - r0 = le64 r0
        - r0 = le32 r0
        - r0 = le16 r0
        - r0 = be64 r0
        - r0 = be32 r0
        - or, finally, the default case:  "r1=be16(r1)"

    3. The operation selected in step 2 is executed and then the program exits.

    4. The value of register 0 (r[31]) after execution of this program will depend on which operation was selected in step 2 above, but it will always have the same value as register 1 (r[30]).  This means that we can use this program to determine what value was stored in register 1 before it was passed into func().

    5. We can use this information to determine what values were stored in registers 30-31 before they were passed into func().  This allows us to determine what values were stored in registers 30-31 when our target function was called by main().

    6. We can then use these values from registers 30-31 when our target function was called by main() as inputs for our fuzzing process!   In other words, we are able to fuzz functions that take arguments without having access to their source code!   This makes it possible for us to fuzz functions that are part of closed source binaries such as libcurl or openssl!   It also makes it possible for us to fuzz functions that are part of open source binaries such as curl or openssl without having access their source code!  All we need is a binary version of curl or openssl compiled with debug symbols so that we know where each function starts and ends within the binary file itself (i.e., so that we know where each function's prologue begins).

 */


int func (void *ctx)
{
    uint32_t key = 1;
    uint64_t *ptr = bpf_map_lookup_elem (&map, &key);
    if (ptr == 0) {
        return 0;
    }
    uint64_t i = *ptr;
    return (uint32_t) i;
}

"""
Summary of the above code:


1. The map is declared as a hashmap with key type uint32_t and value type uint64_t.
2. The function func() returns the value of the map for key 1, if it exists, otherwise 0.
3. The function func() is registered as an eBPF program to be executed on kprobe event sched:sched_switch (i.e., when a process switches from running state to waiting state).
4. When this program runs, it will return the number of times that a process has switched from running state to waiting state since the last time that this program ran (i.e., since the last time that a process switched from running state to waiting state).



 
## How do I use bcc?

    $ sudo ./bcc-tools/trace 'p:myprog sched:sched_switch "%d %s %c %d", pid, comm, prev_state == "R" ? ">" : "<", cpu' -C 1 -p $(pgrep myprog) &> trace-output &

    $ sudo ./bcc-tools/trace 'u:myprog sched:sched_switch "%d %s %c %d", pid, comm, prev_state == "R" ? ">" : "<", cpu' -C 1 -p $(pgrep myprog) &> trace-output &


int func (struct ctx *ctx)
{
    uint32_t key = 0;
    return ebpf_map_update_elem (&map, &key, &ctx, 0);
}

"""
Summary of the above code:


1. The function func() is called from the kernel.
2. It calls ebpf_map_update_elem() to update the map with key 0 and value ctx (which is a pointer to struct ctx).
3. The map is defined as a hashmap with key type uint32_t and value type struct ctx *.
4. The map has 10 elements, which means it can store up to 10 entries in total (key-value pairs).

    


int func (struct ctx *ctx)
{
    uint32_t key = 10;
    uint64_t value = 0;
    return ebpf_map_update_elem (&map, &key, &value, 0);
}

"""
Summary of the above code:


1. Create a map with key type uint32_t and value type uint64_t.
2. Update the map with key 10 and value 0.
3. Return the result of update operation (0 for success, -1 for failure).





int caller (struct xdp_md *ctx)
{
    long error = bpf_tail_call (ctx, & map, 0);
    return (int) error;
}

"""
Summary of the above code:


1. The map is defined as a hashmap with key and value of type u64.
2. The caller function calls the callee function using bpf_tail_call().
3. The callee function returns the value stored in the map for a given key, or 0 if no such key exists in the map.
4. The caller function returns whatever value was returned by the callee function (or an error code).

    


int callee (struct xdp_md *ctx)
{
    return 42;
}

"""
Summary of the above code:


1. The function callee is defined in the C code.
2. The function caller is defined in the BPF program and calls callee .
3. The BPF program is loaded into the kernel using bpftool .
4. A socket filter is attached to a network interface using ip link set dev <iface> xdp obj <bpf_prog> sec <section_name> . This causes all packets received on that interface to be processed by the BPF program, which will call callee , which will return 42, which will cause all packets to be dropped ( XDP_DROP ).

    $ sudo ip link set dev lo xdp obj ./xdp-callee-kern/xdp-callee-kern sec text

    $ sudo ip link show lo | grep -A 1 LOOPBACK | grep -oP 'xdp \K.*'
    xdp object file ./xdp-callee-kern/xdp-callee-kern section text

    $ ping localhost &> /dev/null; echo $?
    100% packet loss, time 0ms

    # Remove XDP from loopback device:

    $ sudo ip link set dev lo xdp off


int func (void *ctx)
{
    char array [256] = "";
    uint32_t rand32 = get_prandom_u32 ();
    uint32_t index = *(unsignedchar*) &rand32;
    return array[index];
}

"""
Summary of the above code:


1. The function func() is called from the kernel context.
2. It allocates a 256 byte array on the stack and initializes it with zeros.
3. It generates a random 32-bit number using get_prandom_u32(). This function is defined in <linux/random.h> and returns a pseudo-random number between 0 and 2^32 - 1 (4294967295).
4. It takes the least significant byte of this random number, which will be between 0x00 and 0xff, as an index into the array we just allocated on the stack, then returns that value from func().

    


int func (struct ctx *ctx)
{
    uint32_t value = 0;
    return ebpf_map_update_elem (&map, &ctx, &value, 0);
}

"""
Summary of the above code:


1. Create a map of type hashmap with key and value as 32 bit integers.
2. Create a function func which takes in a pointer to struct ctx as argument and returns an integer.
3. Declare an integer variable value and initialize it to 0.
4. Update the map with the key being the pointer to struct ctx and value being 0, if there is no error return 0 else return -1 (error).

    


int reallocate_invalidates (struct sk_buff *ctx)
{
    void *data_end = (void *) (long) ctx->data_end;
    void *data = (void *) (long) ctx->data;
    if (data + sizeof (int) > data_end)
        return 1;
    int value = *(int*) data;
    *(int*) data = value + 1;
    bpf_skb_change_head (ctx, 4, 0);
    value = *(int*) data;
    *(int*) data = value + 1;
    return 0;
}

"""
Summary of the above code:


1. The function reallocate_invalidates() is called for every packet that arrives on the interface.
2. It reads the first 4 bytes of the packet and increments it by 1, then changes the head of the packet to 4 bytes and increments it again by 1.
3. If we run this program with a test file containing a single integer, we can see that after running this program, our integer has been incremented twice instead of once:

    $ cat /sys/fs/bpf/tc/globals/test_file 
    0x00000001

    $ tc qdisc add dev lo ingress bpf obj test-realloc-invalidate-data.o sec reallocate_invalidates

    $ cat /sys/fs/bpf/tc/globals/test_file 
    0x00000003

    $ tc qdisc del dev lo ingress bpf obj test-realloc-invalidate-data.o sec reallocate_invalidates

    $ cat /sys/fs/bpf//tc//globals//test_file 
0x00000001


int read_write_packet_start (struct xdp_md *ctx)
{
    void *data_end = (void *) (long) ctx->data_end;
    void *data = (void *) (long) ctx->data;
    if (data > data_end)
        return 1;
    int value = *(int*) data;
    *(int*) data = value + 1;
    return 0;
}

"""
Summary of the above code:


1. The function read_write_packet_start() is the entry point of the program.
2. It reads the first 4 bytes of a packet and increments it by 1.
3. The return value 0 indicates that the packet should be dropped, while 1 means that it should be forwarded to its destination (i.e., continue processing).
4. The function read_write_packet_start() is called for every incoming packet on an interface, which is specified in the XDP program's metadata section (see below).

    Note: In this example, we are using a C-style cast to convert from __u64 to void*. This is not recommended for production code because it can cause undefined behavior if you are compiling with -fno-strict-aliasing or similar flags enabled; however, since we know that our data pointer will always be aligned on an 8 byte boundary and will never alias any other type in our program, this cast is safe here as long as we don't dereference data after casting it to void*. For more information about aliasing rules in C/C++ see https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#index-fno-strict-aliasing .

    Now let's compile this code into an XDP object file:

    $ clang -O2 -target bpf -c xdp1a_kern.c -o xdp1a_kern.o

    Next we need to create a metadata file containing information about how our XDP program should be loaded onto an interface:

    $ cat > xdp1a_metadata <<EOF
{ "file": "xdp1a", "section": { "name": "xdp", "type": 2 } } EOF

    Finally, let's load our new XDP program onto eth0 using iproute2:

    $ ip link set dev eth0 xdp obj xdp1a_kern sec xdp verbose off  # Loads the object file onto eth0 and sets up BPF maps etc...  # Check that everything worked correctly:  $ ip link show dev eth0 | grep 'link/ether' | awk '{print $2}'   # Prints out MAC address of device e8:9d:87:b5:6b:7d  # Send some packets through eth0 so they get processed by your new XDP program! You can use ping or iperf3 for example...  # Unload your new XDP program from eth0 when you're done testing it out! Otherwise all traffic going through your machine will get dropped!   $ ip link set dev eth0 nomod off


int func (struct ctx *ctx)
{
    int stack_buffer [16];
    int *ptr = (int *) 0;
    uint32_t rand32 = get_prandom_u32 ();
    if (rand32 & 1) {
        for (int i = 0; i < 8; i++) {
            stack_buffer[i] = get_prandom_u32 ();
        }
        int index = rand32 % 8;
        ptr = &stack_buffer[index];
        ptr[index ^ 1] = 0;
    }
    else {
        int *stack_buffer2 = &stack_buffer[8];
        for (int i = 0; i < 8; i++) {
            stack_buffer2[i] = get_prandom_u32 ();
        }
        ptr = &stack_buffer2[rand32 % 8];
    }
    return *ptr;
}

"""
Summary of the above code:


1. Declare a function that takes a pointer to struct ctx as an argument.
2. Declare an array of 16 integers on the stack, and initialize it with random values.
3. Declare a pointer to int, and initialize it with NULL (0).
4. Get a random 32-bit integer from the kernel's PRNG (/dev/urandom).
5. If the LSB of rand32 is 1:

    1) Set ptr to point at stack_buffer[index], where index is rand32 % 8 (a random number between 0 and 7).

    2) Set ptr[index ^ 1] = 0; This will set either ptr[index + 1] or ptr[index - 1] to zero, depending on whether index is even or odd respectively (XORing by one flips all bits except for the LSB).

    3) Return *ptr; This will return either stack_buffer[index], or 0 if we set it in step 5(b)(ii), above.  Note that this can also cause undefined behavior if we read past the end of stack_buffer[]!  We'll see how this works later in this post...
6. Else:

    1) Set ptr to point at &stack_buffer2[rand32 % 8].  Note that since we're using C99 variable declarations, &stack_buffer2 is actually just &stack_buffer + 8!  So we're setting ptr to point at some element within our 16-element array on the stack!

    2) Return *ptr; This will return either some value from within our 16-element array on the stack, or possibly undefined behavior if we read past its bounds!  Again, more details later... :)



int caller (struct xdp_md *ctx)
{
    long error = bpf_tail_call (ctx, & map, 0);
    return (int) error;
}

"""
Summary of the above code:


1. The map is defined as a hashmap with key and value of type u64.
2. The caller function calls the callee function using bpf_tail_call().
3. The callee function returns the value stored in the map for a given key, or 0 if no such key exists in the map.
4. The caller function returns whatever value was returned by the callee function (or an error code).

    


int callee (struct xdp_md *ctx)
{
    return 42;
}

"""
Summary of the above code:


1. The function callee is defined in the C code.
2. The function caller is defined in the BPF program and calls callee .
3. The BPF program is loaded into the kernel using bpftool .
4. A socket filter is attached to a network interface using ip link set dev <iface> xdp obj <bpf_prog> sec <section_name> . This causes all packets received on that interface to be processed by the BPF program, which will call callee , which will return 42, which will cause all packets to be dropped ( XDP_DROP ).

    $ sudo ip link set dev lo xdp obj ./xdp-callee-kern/xdp-callee-kern sec text

    $ sudo ip link show lo | grep -A 1 LOOPBACK | grep -oP 'xdp \K.*'
    xdp object file ./xdp-callee-kern/xdp-callee-kern section text

    $ ping localhost &> /dev/null; echo $?
    100% packet loss, time 0ms

    # Remove XDP from loopback device:

    $ sudo ip link set dev lo xdp off


int func (void *ctx)
{
    uint32_t key = 1;
    ctx = ((char *) ctx) + 8;
    int result = bpf_sock_map_update (ctx, & map, & key, 0);
    return result;
}

"""
Summary of the above code:


1. The function func() takes a pointer to the context as an argument.
2. The context is casted to char * and incremented by 8 bytes, which is the size of the sock_addr struct (see above).
3. A key of 1 is created and used to update the map with a value of 0 (the last argument).
4. The result of this operation is returned from func().

    


int func (struct ctx *ctx)
{
    struct bpf_map map2;
    return bpf_map_update_elem (&map2, (const void *) 0, (const void *) 0, 0);
}

"""
Summary of the above code:


1. The program is a function that takes a pointer to struct ctx as an argument.
2. The program calls bpf_map_update_elem() with the map2 argument, which is not in the context of the function call (i.e., it's not passed as an argument).
3. The map2 variable is declared on stack and initialized with zeros, so it has no valid fd value and thus cannot be used by bpf_map_update_elem().
4. This should result in a verifier error: "invalid mem access 'map_value'".

    


int test_packet_access (struct xdp_md *ctx)
{
    uint32_t rand32 = get_prandom_u32 ();
    void *data_end = (void *) (long) ctx->data_end;
    void *data = (void *) (long) ctx->data;
    int offset = (rand32 & 0x0F) * 4;
    int *ptr;
    if (rand32 & 1) {
        if (data + offset + sizeof (int) > data_end)
            return 1;
        ptr = offset + data;
        return *(int*) ptr;
    }
    else {
        asm volatile ("r0 <<= 2\n"
            "r0 &= 60\n"
            "r1 = *(u32 *)(r6 + 0)\n"
            "r0 += r1\n"
            "r1 = r0\n"
            "r0 = 1\n"
            "r2 = r1\n"
            "r2 += 4\n"
            "r3 = *(u32 *)(r6 + 4)\n"
            "if r2 > r3 goto +1\n"
            "r0 = *(u32 *)(r1 + 0)\n"
            );
    }
}

"""
Summary of the above code:


1. The function test_packet_access() is called with a pointer to the xdp_md struct as an argument.
2. A random number is generated and stored in rand32.
3. The data pointer from the xdp_md struct is cast to a void pointer and stored in data, and the data end pointer from the xdp_md struct is cast to a void pointer and stored in data end.
4. An offset value between 0 and 15 (inclusive) is calculated by taking rand32 modulo 16, multiplying it by 4, then storing it in offset (this will be used later).
5. If rand32 modulo 2 equals 1:

    1a) If adding offset plus 4 bytes to data would result in going past the end of packet (data + offset + sizeof(int) > data end), return 1; otherwise:

        i) Cast ptr as an int* at address of (offset + data).

        ii) Return *ptr; that is, dereference ptr as an int*. This will read 4 bytes starting at address of (offset + data), which could be anywhere within packet memory or beyond it if we went past the end of packet when calculating ptr earlier on line 5a-i above; this could cause a kernel panic if we go too far out-of-bounds!
6. Otherwise:

    2a) Use inline assembly code to do exactly what was done above on lines 5a-ii except using BPF registers instead of C variables for everything except for rand32 which was already loaded into register r0 before calling test_packet access(). This also has no bounds checking so can cause kernel panics!


int func (struct ctx *ctx)
{
    uint32_t rand32 = get_prandom_u32 ();
    struct ebpf_map *map = (rand32 & 1) ? &map1 : &map2;
    int key = 10;
    uint64_t *value = (uint64_t *) bpf_map_lookup_elem (map, &key);
    if (value == 0)
        return 0;
    return (int) *value;
}

"""
Summary of the above code:


1. The function func() is called from the kernel.
2. It randomly chooses one of two maps, map1 or map2, and looks up a value in it using key 10.
3. If the value is found, it returns that value; otherwise it returns 0 (zero).



int foo (struct test_md *ctx)
{
    int index;
    int cumul = 0;
    uint8_t array [ARRAY_LENGTH] = {0};
    for (index = 0; index < sizeof (array); index++) {
        if ((ctx->data_start + index) >= ctx->data_end)
            break;
        array[index] = 1;
    }
    for (index = 0; index < sizeof (array); index++) {
        cumul += array[index];
    }
    return cumul;
}

"""
Summary of the above code:


1. The function foo() takes a pointer to a struct test_md as an argument.
2. It then declares an array of ARRAY_LENGTH bytes and initializes it with zeros.
3. It then loops over the array, setting each element to 1 if the index is less than the difference between data_end and data_start (which are members of the struct).
4. Finally, it loops over the array again, adding up all elements in order to return that sum as its result value (which will be either 0 or ARRAY_LENGTH).

    


int func (struct ctx *ctx)
{
    int key = -1;
    uint64_t value = 0;
    return ebpf_map_update_elem (&map, &key, &value, 0);
}

"""
Summary of the above code:


1. Create a map with key type int and value type uint64_t.
2. Call ebpf_map_update_elem() to update the map with key -1 and value 0.
3. Return the return code of ebpf_map_update_elem().

    


int test (void *ctx)
{
    uint64_t test;
    bpf_ringbuf_output (&ring_buffer, &test, sizeof (test), 0);
    return 0;
}

"""
Summary of the above code:


1. The ring buffer is created with a size of 1 page (4096 bytes) and a maximum number of elements of 10.
2. The ring buffer is initialized with the name "test_ring".
3. A test function is defined that writes an element to the ring buffer and returns 0 (success).
4. The test function is registered as an eBPF program for the kprobe event "do_sys_open" in kernel space, which will be called whenever a file is opened by any process on the system.

    $ sudo ./bpf-ringbuf-example 

    Attached BPF program to kprobe event do_sys_open!

    ^C[+] Detaching BPF programs... Done!
    
The above command will attach our eBPF program to all processes on the system, so that whenever they open a file, our test function will be called and write an element to our ring buffer in kernel space memory:

    $ sudo cat /sys/kernel/debug/tracing/trace | grep -i bpf | tail -n 1 

        <idle>-0     [000] dN.. 4881.824079: 0x00000001: bpf_ringbuf__test+0x0() {cpu=0} <===== Our test function was called!


int func ()
{
    char buffer [1];
    return ebpf_get_current_comm (buffer, 20);
}

"""
Summary of the above code:


1. The function ebpf_get_current_comm() is called with two arguments: buffer and 20.
2. The function returns an integer value, which is assigned to the variable func().
3. The variable func() is printed out using the print statement in line 3 of the code above.


The output of this program will be:

    $ python test-ebpf-get-current-comm.py 
    0

    
This means that the call to ebpf_get_current_comm() was successful and returned 0 (zero). 

    
### Example 2 - Getting current process name using eBPF helper functions ### 

    #!/usr/bin/python3   # This line tells Linux that this file should be executed as a Python script 			# by calling /usr/bin/python3 on it when it's run from a shell prompt, such as bash or zsh.  	# It also tells Python what version of Python we're using (in this case, 3).  	# If you don't have Python 3 installed on your system, you can download it from https://www.python.org/.  	# You can also use other versions of Python if you want; just change "3" in "#!/usr/bin/python3" to "2", for example, if you want to use version 2 instead of version 3.


int func (void *ctx)
{
    uint32_t outer_key = 0;
    void *nolocal_lru_map = bpf_map_lookup_elem (&array_of_maps, &outer_key);
    if (nolocal_lru_map) {
        uint32_t inner_key = 0;
        void *ret = bpf_map_lookup_elem (nolocal_lru_map, &inner_key);
        if (ret) {
            return 0;
        }
        else {
            ret = bpf_map_lookup_elem (& inner_map, & inner_key);
            return 0;
        }
    }
    return 0;
}

"""
Summary of the above code:


1. The outer map is an array of maps, and the inner map is a hashmap.
2. The outer key is always 0, and the inner key is also always 0.
3. There are two ways to access the inner map:

    1) First access the outer map with key 0, then use this returned value as a pointer to access the inner map with key 0;

    2) Directly access the inner_map with key 0;
4. In both cases, we expect that bpf_map_lookup_elem() returns NULL for both cases (because there's no entry in either of these maps). However, when I run this program on my machine (Ubuntu 18), it crashes at runtime:
<code>$ sudo ./test 
[sudo] password for xxx: 
Error opening BPF object file: No such file or directory (2)  # This line comes from test/bpf/libbpf/src/libbpf-internal.c line 527 in function libbpf_load() called by main(). It seems that libbpf cannot find my BPF object file "test". But I don't know why because I can see it in my current directory... Anyway let's ignore this error message for now...

   RSP           000007fffffffd60   RIP           00000000004005b0   Error code        0000000000000001   Old mask        ffffffff00000000   CR2            00007fffffffe000 Segmentation fault (core dumped) # This line comes from kernel log when running test program "test" above on Ubuntu 18 LTS 4.15 kernel version 4.15-rc8+ #9 SMP PREEMPT Wed Jan 17 16:35:33 CST 2018 x86_64 x86_64 x86_64 GNU/Linux . It seems that there's some segmentation fault somewhere inside bpftool code... But again let's ignore this error message for now...

 $ dmesg | tail -n 1 [ 909634] general protection fault ip:4005b0 sp:7fffffffd60 error:1 in test[400000+1000] # Again another segmentation fault somewhere inside bpftool code... Let's ignore it too! :) ...</code>
I'm not sure if there are any bugs here? Or maybe I'm doing something wrong? Any help would be appreciated! Thanks! :)


int read_write_packet_start (struct xdp_md *ctx)
{
    void *data_end = (void *) (long) ctx->data_end;
    void *data = (void *) (long) ctx->data;
    if (data + sizeof (int) > data_end)
        return 1;
    int value = *(int*) data;
    *(int*) data = value + 1;
    return 0;
}

"""
Summary of the above code:


1. The function read_write_packet_start() is the entry point of the program.
2. It reads an integer from the packet and increments it by 1, then writes it back to the packet.
3. The function returns 0 if everything goes well, otherwise returns 1 to indicate that there is an error in processing this packet (e.g., not enough space for reading/writing).
4. Note that we use ctx->data and ctx->data_end to get a pointer to the beginning of data in this packet and a pointer to its end respectively, so we can safely access data within [ctx->data, ctx->data_end).

    $ clang -O2 -target bpf -c read-write-packet-start-kern.c -o read-write-packet-start-kern.o

    $ sudo ip link set dev lo xdp obj read-write-packet-start/read-write

