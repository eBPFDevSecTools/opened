{"_default": {"1": {"date": "2023-02-24", "File": " /home/sayandes/codequery/cilium/bpf_overlay.c", "Startline": " 46", "Endline": " 180 ", "Funcname": " handle_ipv6 ", "Input": " (struct __ctx_buff *ctx, __u32 *identity) ", "Output": " int ", "Helpers": " [revalidate_data_pull bpf_skip_nodeport nodeport_lb6 encap_remap_v6_host_address get_identity ctx_get_tunnel_key identity_is_remote_node ipcache_lookup6 ", "Read_maps": " [] ", "Update_maps": " [] ", "Func_Description": " The main goal of handle_ipv6 is to check the different condition including  if nodeport, IPSEC is enabled and if the pulling data or decrypting gets error.  Then make different action to handle according situatoins to convert the IPV6 to a virtual  network which points to overlay. The first step is to verify the background by  using revalidate_data_pull and the pointer ctx (maybe the starting point of a protocol?).  Ret should be the new address of this IPV6 sector. If nodeport is not activated,  ret is set by encap_remap_v6_host address.Then check if the net is decrypted by using mark. Identity is equal to identity of ctx if the net is decrypted, but tunnel id if not. Check if the ID is equal to host_ID since any node encapsulating will map any HOST_ID source to be presented as REMOTE_NODE_ID, therefore any attempt to signal HOST_ID as source from a remote node can be dropped.After that, check esp protocol,ESPis a member of the Internet Protocol Security set of protocols that encrypt and authenticate the packets of data between computers using a Virtual Private Network. If ESP is activated, we set mark for the ID and change the type of ctx to packet_host to pass it up.If Esp is not activated, we look up the IPV6 address in list of local endpoints. If the endpoints reach the host, we go to the host  and set the ret, else we find the next headerlength and return that. ", "author": "Yichen Wang", "email": "wyichen@bu.edu"}, "2": {"date": "2023-02-24", "File": " /home/sayandes/codequery/cilium/bpf_overlay.c", "Startline": " 182", "Endline": " 192 ", "Funcname": " tail_handle_ipv6 ", "Input": " (struct __ctx_buff *ctx) ", "Output": " int ", "Helpers": " [] ", "Read_maps": " [] ", "Update_maps": " [] ", "Func_Description": " This function is to handle the tail of a protocol and check it it has any error for ipv6 ", "author": "Yichen Wang", "email": "wyichen@bu.edu"}, "3": {"date": "2023-02-24", "File": " /home/sayandes/codequery/cilium/bpf_overlay.c", "Startline": " 196", "Endline": " 333 ", "Funcname": " handle_ipv4 ", "Input": " (struct __ctx_buff *ctx, __u32 *identity) ", "Output": " int ", "Helpers": " [revalidate_data_pull ipv4_is_fragment nodeport_lb4  get_identity ctx_get_tunnel_key identity_is_remote_node ipcache_lookup4 ", "Read_maps": " [] ", "Update_maps": " [] ", "Func_Description": " This function is similar to handle_ipv6 to handle ipv4 packet. The main goal of it is to check the different condition including  if nodeport, IPSEC is enabled and if the pulling data or decrypting gets error.  Then make different action to handle according situatoins to convert the IPV6 to a virtual  network which points to overlay. IPV4 fragmentation check is added. ", "author": "Yichen Wang", "email": "wyichen@bu.edu"}, "4": {"date": "2023-02-24", "File": " /home/sayandes/codequery/cilium/bpf_overlay.c", "Startline": " 335", "Endline": " 345 ", "Funcname": " tail_handle_ipv4 ", "Input": " (struct __ctx_buff *ctx) ", "Output": " int ", "Helpers": " [handle_ipv4 IS_ERR send_drop_notify_error] ", "Read_maps": " [] ", "Update_maps": " [] ", "Func_Description": " check if there is error about the tail of ipv4 packet. ", "author": "Yichen Wang", "email": "wyichen@bu.edu"}, "5": {"date": "2023-02-24", "File": " /home/sayandes/codequery/cilium/bpf_overlay.c", "Startline": " 352", "Endline": " 395 ", "Funcname": " tail_handle_arp ", "Input": " (struct __ctx_buff *ctx) ", "Output": " int ", "Helpers": " [] ", "Read_maps": " [] ", "Update_maps": " [] ", "Func_Description": " Handle the tail for ARP requests from VTEP. Check different occasions including tunnel_key geting, arp validating, and if endpoint of tunnel is reached. ", "author": "Yichen Wang", "email": "wyichen@bu.edu"}, "6": {"date": "2023-02-24", "File": " /home/sayandes/codequery/cilium/bpf_overlay.c", "Startline": " 401", "Endline": " 428 ", "Funcname": " is_esp ", "Input": " (struct __ctx_buff *ctx, __u16 proto) ", "Output": " bool ", "Helpers": " [bpf_htons revalidate_data_pull] ", "Read_maps": " [] ", "Update_maps": " [] ", "Func_Description": " The built in function to check if esp protocol is used and if pulling data have error. ", "author": "Yichen Wang", "email": "wyichen@bu.edu"}, "7": {"date": "2023-02-24", "File": " /home/sayandes/codequery/cilium/bpf_overlay.c", "Startline": " 434", "Endline": " 527 ", "Funcname": " from_overlay ", "Input": " (struct __ctx_buff *ctx) ", "Output": " int ", "Helpers": " [bpf_clear_meta bpf_skip_nodeport_clear validate_ethertype send_trace_notify bpf_htons ep_tail_call] ", "Read_maps": " [] ", "Update_maps": " [] ", "Func_Description": " handle different possible packets come to the program. First check if it is esp protocol, then check the decrypted or not and get the identity from the metadata.  ", "author": "Yichen Wang", "email": "wyichen@bu.edu"}, "8": {"date": "2023-02-24", "File": " /home/sayandes/codequery/cilium/bpf_overlay.c", "Startline": " 532", "Endline": " 568 ", "Funcname": " to_overlay ", "Input": " (struct __ctx_buff *ctx) ", "Output": " int ", "Helpers": " [] ", "Read_maps": " [] ", "Update_maps": " [] ", "Func_Description": " TO BE ADDED  ", "author": "Yichen Wang", "email": "wyichen@bu.edu"}, "9": {"date": "2023-02-24", "File": " /home/sayandes/codequery/cilium/bpf_lxc.c", "Startline": " 157", "Endline": " 162 ", "Funcname": " redirect_to_proxy ", "Input": " (int verdict, enum ct_status status) ", "Output": " bool ", "Helpers": " [] ", "Read_maps": " [] ", "Update_maps": " [] ", "Func_Description": " check if the proxy is able to be redirected, and redirect the proxy, store in status. Return true if successful. ", "author": "Yihe Bi", "email": "ybi@bu.edu"}, "10": {"date": "2023-02-24", "File": " /home/sayandes/codequery/cilium/bpf_lxc.c", "Startline": " 174", "Endline": " 189 ", "Funcname": " encode_custom_prog_meta ", "Input": " (struct __ctx_buff *ctx, int ret, __u32 identity) ", "Output": " int ", "Helpers": " [] ", "Read_maps": " [] ", "Update_maps": " [] ", "Func_Description": " encode meta data (return value and identity), and store it into ctx buffer ", "author": "Yihe Bi", "email": "ybi@bu.edu"}, "11": {"date": "2023-02-24", "File": " /home/sayandes/codequery/cilium/bpf_lxc.c", "Startline": " 214", "Endline": " 581 ", "Funcname": " handle_ipv6_from_lxc ", "Input": " (struct __ctx_buff *ctx, __u32 *dst_id) ", "Output": " int ", "Helpers": " [] ", "Read_maps": " [] ", "Update_maps": " [] ", "Func_Description": " Handling egress ipv6 traffic by  a) lookup the destination_id. For encrypted and tunneled traffic b) tunnel endpoint, and c) encryption key as well. Also mark the traffic if it has a remote endpoint destination. Restore ct_state from per packet lb handling in the previous tail call. Enable the per pecket load balancer, swap the address by CT_lookup and establish the connection. ", "author": "Yihe Bi", "email": "ybi@bu.edu"}, "12": {"date": "2023-02-24", "File": " /home/sayandes/codequery/cilium/bpf_lxc.c", "Startline": " 583", "Endline": " 603 ", "Funcname": " tail_handle_ipv6_cont ", "Input": " (struct __ctx_buff *ctx) ", "Output": " int ", "Helpers": " [] ", "Read_maps": " [] ", "Update_maps": " [] ", "Func_Description": " Count ipv6 tail calls ", "author": "Yihe Bi", "email": "ybi@bu.edu"}, "13": {"date": "2023-02-24", "File": " /home/sayandes/codequery/cilium/bpf_lxc.c", "Startline": " 605", "Endline": " 694 ", "Funcname": " __tail_handle_ipv6 ", "Input": " (struct __ctx_buff *ctx) ", "Output": " int ", "Helpers": " [] ", "Read_maps": " [] ", "Update_maps": " [] ", "Func_Description": " Handle tail messages. Check if it is not special ICMPv6 messages such as echo requests, neighbour advertisement, then check if the destination address is among the address that should be  load balanced. Then store information to ctx for continuous tail call. ", "author": "Yihe Bi", "email": "ybi@bu.edu"}, "14": {"date": "2023-02-24", "File": " /home/sayandes/codequery/cilium/bpf_lxc.c", "Startline": " 696", "Endline": " 705 ", "Funcname": " tail_handle_ipv6 ", "Input": " (struct __ctx_buff *ctx) ", "Output": " int ", "Helpers": " [] ", "Read_maps": " [] ", "Update_maps": " [] ", "Func_Description": " Handle egress IPv6 traffic from a container after service translation has been done either at the socket level or by the caller. ", "author": "Yihe Bi", "email": "ybi@bu.edu"}, "15": {"date": "2023-02-24", "File": " /home/sayandes/codequery/cilium/bpf_lxc.c", "Startline": " 728", "Endline": " 1157 ", "Funcname": " handle_ipv4_from_lxc ", "Input": " (struct __ctx_buff *ctx, __u32 *dst_id) ", "Output": " int ", "Helpers": " [] ", "Read_maps": " [] ", "Update_maps": " [] ", "Func_Description": " Handling egress ipv4 traffic. Mark the traffic if it has a remote endpoint destination. Restore ct_state from per packet lb handling in the previous tail call. Enable the per pecket load balancer, swap the address by CT_lookup and establish the connection. ", "author": "Yihe Bi", "email": "ybi@bu.edu"}, "16": {"date": "2023-02-24", "File": " /home/sayandes/codequery/cilium/bpf_lxc.c", "Startline": " 1159", "Endline": " 1179 ", "Funcname": " tail_handle_ipv4_cont ", "Input": " (struct __ctx_buff *ctx) ", "Output": " int ", "Helpers": " [] ", "Read_maps": " [] ", "Update_maps": " [] ", "Func_Description": " Count ipv4 tail call. Helper function for handling ipv4 traffic ", "author": "Yihe Bi", "email": "ybi@bu.edu"}, "17": {"date": "2023-02-24", "File": " /home/sayandes/codequery/cilium/bpf_lxc.c", "Startline": " 1181", "Endline": " 1256 ", "Funcname": " __tail_handle_ipv4 ", "Input": " (struct __ctx_buff *ctx) ", "Output": " int ", "Helpers": " [] ", "Read_maps": " [] ", "Update_maps": " [] ", "Func_Description": " helper function to handle ipv4 tail call ", "author": "Yihe Bi", "email": "ybi@bu.edu"}, "18": {"date": "2023-02-24", "File": " /home/sayandes/codequery/cilium/bpf_lxc.c", "Startline": " 1258", "Endline": " 1267 ", "Funcname": " tail_handle_ipv4 ", "Input": " (struct __ctx_buff *ctx) ", "Output": " int ", "Helpers": " [] ", "Read_maps": " [] ", "Update_maps": " [] ", "Func_Description": " handle ipv4 tail call. ", "author": "Yihe Bi", "email": "ybi@bu.edu"}, "19": {"date": "2023-02-24", "File": " /home/sayandes/codequery/cilium/bpf_lxc.c", "Startline": " 1274", "Endline": " 1300 ", "Funcname": " tail_handle_arp ", "Input": " (struct __ctx_buff *ctx) ", "Output": " int ", "Helpers": " [] ", "Read_maps": " [] ", "Update_maps": " [] ", "Func_Description": " Validate ARP requests. Send unknown and LXC endpoint ARP requests to linux kernel stack.  Send response for all other ARP requests. ", "author": "Yihe Bi", "email": "ybi@bu.edu"}, "20": {"date": "2023-02-24", "File": " /home/sayandes/codequery/cilium/bpf_lxc.c", "Startline": " 1307", "Endline": " 1358 ", "Funcname": " handle_xgress ", "Input": " (struct __ctx_buff *ctx) ", "Output": " int ", "Helpers": " [] ", "Read_maps": " [] ", "Update_maps": " [] ", "Func_Description": " Use previous exgress ipv6/v4 traffic handler to handle exgress traffic. ", "author": "Yihe Bi", "email": "ybi@bu.edu"}, "21": {"date": "2023-02-24", "File": " /home/sayandes/codequery/cilium/bpf_lxc.c", "Startline": " 1361", "Endline": " 1536 ", "Funcname": " ipv6_policy ", "Input": " (struct __ctx_buff *ctx, int ifindex, __u32 src_label, enum ct_status *ct_status, struct ipv6_ct_tuple *tuple_out, __u16 *proxy_port, bool from_host __maybe_unused) ", "Output": " int ", "Helpers": " [] ", "Read_maps": " [] ", "Update_maps": " [] ", "Func_Description": " Check if the packet is ingress or exgress traffic, redirect the traffic if necessary. ", "author": "Yihe Bi", "email": "ybi@bu.edu"}, "22": {"date": "2023-02-24", "File": " /home/sayandes/codequery/cilium/bpf_lxc.c", "Startline": " 1538", "Endline": " 1581 ", "Funcname": " tail_ipv6_policy ", "Input": " (struct __ctx_buff *ctx) ", "Output": " int ", "Helpers": " [] ", "Read_maps": " [] ", "Update_maps": " [] ", "Func_Description": " Identify ipv6 tail call, store data to ctx. Skip tail call when packet is being redirected to a L7 proxy. ", "author": "Yihe Bi", "email": "ybi@bu.edu"}, "23": {"date": "2023-02-24", "File": " /home/sayandes/codequery/cilium/bpf_lxc.c", "Startline": " 1583", "Endline": " 1659 ", "Funcname": " tail_ipv6_to_endpoint ", "Input": " (struct __ctx_buff *ctx) ", "Output": " int ", "Helpers": " [] ", "Read_maps": " [] ", "Update_maps": " [] ", "Func_Description": " delivery ipv6 tail call to endpoint, skip if it is send to L7 proxy ", "author": "Yihe Bi", "email": "ybi@bu.edu"}, "24": {"date": "2023-02-24", "File": " /home/sayandes/codequery/cilium/bpf_lxc.c", "Startline": " 1671", "Endline": " 1879 ", "Funcname": " ipv4_policy ", "Input": " (struct __ctx_buff *ctx, int ifindex, __u32 src_label, enum ct_status *ct_status, struct ipv4_ct_tuple *tuple_out, __u16 *proxy_port, bool from_host __maybe_unused) ", "Output": " int ", "Helpers": " [] ", "Read_maps": " [] ", "Update_maps": " [] ", "Func_Description": " Identify ipv4 message and store its meta data to ctx. ", "author": "Yihe Bi", "email": "ybi@bu.edu"}, "25": {"date": "2023-02-24", "File": " /home/sayandes/codequery/cilium/bpf_lxc.c", "Startline": " 1881", "Endline": " 1924 ", "Funcname": " tail_ipv4_policy ", "Input": " (struct __ctx_buff *ctx) ", "Output": " int ", "Helpers": " [] ", "Read_maps": " [] ", "Update_maps": " [] ", "Func_Description": " Redirect ipv4 tail call, skip tail calls when packet is being redirected to L7 proxy. ", "author": "Yihe Bi", "email": "ybi@bu.edu"}, "26": {"date": "2023-02-24", "File": " /home/sayandes/codequery/cilium/bpf_lxc.c", "Startline": " 1926", "Endline": " 2001 ", "Funcname": " tail_ipv4_to_endpoint ", "Input": " (struct __ctx_buff *ctx) ", "Output": " int ", "Helpers": " [] ", "Read_maps": " [] ", "Update_maps": " [] ", "Func_Description": " Send ipv4 tail call to its enpoint. ", "author": "Yihe Bi", "email": "ybi@bu.edu"}, "27": {"date": "2023-02-24", "File": " /home/sayandes/codequery/cilium/bpf_lxc.c", "Startline": " 2023", "Endline": " 2061 ", "Funcname": " handle_policy ", "Input": " (struct __ctx_buff *ctx) ", "Output": " int ", "Helpers": " [] ", "Read_maps": " [] ", "Update_maps": " [] ", "Func_Description": " Identify if the traffic is ipv6/v4, handle policy using previous helper function. ", "author": "Yihe Bi", "email": "ybi@bu.edu"}, "28": {"date": "2023-02-24", "File": " /home/sayandes/codequery/cilium/bpf_lxc.c", "Startline": " 2071", "Endline": " 2113 ", "Funcname": " handle_policy_egress ", "Input": " (struct __ctx_buff *ctx) ", "Output": " int ", "Helpers": " [] ", "Read_maps": " [] ", "Update_maps": " [] ", "Func_Description": " Handle egress traffic  ", "author": "Yihe Bi", "email": "ybi@bu.edu"}, "29": {"date": "2023-02-24", "File": " /home/sayandes/codequery/cilium/bpf_lxc.c", "Startline": " 2119", "Endline": " 2195 ", "Funcname": " handle_to_container ", "Input": " (struct __ctx_buff *ctx) ", "Output": " int ", "Helpers": " [] ", "Read_maps": " [] ", "Update_maps": " [] ", "Func_Description": " handle ingress policy by checking it's source and destination stored in ctx buffer. Check identity and drop the unsupported and tail calls. ", "author": "Yihe Bi", "email": "ybi@bu.edu"}, "30": {"date": "2023-02-24", "File": " /home/sayandes/codequery/cilium/bpf_network.c", "Startline": " 14", "Endline": " 88 ", "Funcname": " from_network ", "Input": " (struct __ctx_buff *ctx) ", "Output": " int ", "Helpers": " [bpf_clear_meta,validate_ethertype] ", "Read_maps": " [] ", "Update_maps": " [ctx] ", "Func_Description": " Initialize the ctx buffer, passing protocols to the stack according to the imput packets (ESP packets coming from network; Non-ESP packets coming from network; Non-ESP packets coming from stack re-inserted by xfrm) ", "author": "Shun Zhang", "email": "shunz@bu.edu"}, "31": {"date": "2023-02-24", "File": " /home/sayandes/codequery/cilium/cilium-probe-kernel-hz.c", "Startline": " 30", "Endline": " 38 ", "Funcname": " pin_to_cpu ", "Input": " (int cpu) ", "Output": " int ", "Helpers": " [] ", "Read_maps": " [] ", "Update_maps": " [set] ", "Func_Description": " clear CPU and reset a specific CPU in the set, then sets the CPU affinity mask of the thread ", "author": "Shun Zhang", "email": "shunz@bu.edu"}, "32": {"date": "2023-02-24", "File": " /home/sayandes/codequery/cilium/cilium-probe-kernel-hz.c", "Startline": " 40", "Endline": " 47 ", "Funcname": " fix_priority ", "Input": " (void) ", "Output": " int ", "Helpers": " [] ", "Read_maps": " [] ", "Update_maps": " [sp] ", "Func_Description": " reset the maxmium for the scheduling policy specified by policy  ", "author": "Shun Zhang", "email": "shunz@bu.edu"}, "33": {"date": "2023-02-24", "File": " /home/sayandes/codequery/cilium/cilium-probe-kernel-hz.c", "Startline": " 49", "Endline": " 52 ", "Funcname": " *timer_list_open ", "Input": " (void) ", "Output": " FILE ", "Helpers": " [] ", "Read_maps": " [] ", "Update_maps": " [] ", "Func_Description": " read the timer_list file ", "author": "Shun Zhang", "email": "shunz@bu.edu"}, "34": {"date": "2023-02-24", "File": " /home/sayandes/codequery/cilium/cilium-probe-kernel-hz.c", "Startline": " 54", "Endline": " 57 ", "Funcname": " timer_list_close ", "Input": " (FILE *fp) ", "Output": " void ", "Helpers": " [] ", "Read_maps": " [] ", "Update_maps": " [] ", "Func_Description": " close file ", "author": "Shun Zhang", "email": "shunz@bu.edu"}, "35": {"date": "2023-02-24", "File": " /home/sayandes/codequery/cilium/cilium-probe-kernel-hz.c", "Startline": " 59", "Endline": " 92 ", "Funcname": " prep_kern_jiffies ", "Input": " (struct cpu_jiffies *before, struct cpu_jiffies *after) ", "Output": " int ", "Helpers": " [] ", "Read_maps": " [] ", "Update_maps": " [] ", "Func_Description": " allocate the CPU jiffies with error check (*) ", "author": "Shun Zhang", "email": "shunz@bu.edu"}, "36": {"date": "2023-02-24", "File": " /home/sayandes/codequery/cilium/cilium-probe-kernel-hz.c", "Startline": " 94", "Endline": " 113 ", "Funcname": " fetch_kern_jiffies ", "Input": " (const struct cpu_jiffies *curr) ", "Output": " int ", "Helpers": " [] ", "Read_maps": " [] ", "Update_maps": " [] ", "Func_Description": " fetch the CPU jiffies to fit the cpus set in current cpu parameter ", "author": "Shun Zhang", "email": "shunz@bu.edu"}, "37": {"date": "2023-02-24", "File": " /home/sayandes/codequery/cilium/cilium-probe-kernel-hz.c", "Startline": " 115", "Endline": " 150 ", "Funcname": " dump_kern_jiffies ", "Input": " (const struct cpu_jiffies *fixed, const struct cpu_jiffies *result, bool macro) ", "Output": " int ", "Helpers": " [] ", "Read_maps": " [] ", "Update_maps": " [] ", "Func_Description": " decrease the fixed jiffies from the result jiffies, reset fixed jiffies to the closest kernel_hz stop when any fixed_jiffies isn't constant with the first one. With a macro bool for debugging  ", "author": "Shun Zhang", "email": "shunz@bu.edu"}, "38": {"date": "2023-02-24", "File": " /home/sayandes/codequery/cilium/cilium-probe-kernel-hz.c", "Startline": " 152", "Endline": " 194 ", "Funcname": " main ", "Input": " (int argc, char **argv) ", "Output": " int ", "Helpers": " [] ", "Read_maps": " [] ", "Update_maps": " [] ", "Func_Description": " Main function of above functions, initialize the cpu and deal with the  jiffies  accordingly  ", "author": "Shun Zhang", "email": "shunz@bu.edu"}, "39": {"date": "2023-02-24", "File": " /home/sayandes/codequery/cilium/sockops/bpf_sockops.c", "Startline": " 26", "Endline": " 40 ", "Funcname": " sk_extract4_key ", "Input": " (const struct bpf_sock_ops *ops, struct sock_key *key) ", "Output": " void ", "Helpers": " [] ", "Read_maps": " [msg] ", "Update_maps": " [key] ", "Func_Description": " set the sport and dport of the input key with 32 bits local port and remote port (ip4)  ", "author": "Shun Zhang", "email": "shunz@bu.edu"}, "40": {"date": "2023-02-24", "File": " /home/sayandes/codequery/cilium/sockops/bpf_sockops.c", "Startline": " 42", "Endline": " 48 ", "Funcname": " sk_lb4_key ", "Input": " (struct lb4_key *lb4, const struct sock_key *key) ", "Output": " void ", "Helpers": " [] ", "Read_maps": " [key] ", "Update_maps": " [lb4] ", "Func_Description": " copy address and dport of lb4 from socket key ", "author": "Shun Zhang", "email": "shunz@bu.edu"}, "41": {"date": "2023-02-24", "File": " /home/sayandes/codequery/cilium/sockops/bpf_sockops.c", "Startline": " 50", "Endline": " 53 ", "Funcname": " redirect_to_proxy ", "Input": " (int verdict) ", "Output": " bool ", "Helpers": " [] ", "Read_maps": " [] ", "Update_maps": " [] ", "Func_Description": " check if verdict is larger than 0  ", "author": "Shun Zhang", "email": "shunz@bu.edu"}, "42": {"date": "2023-02-24", "File": " /home/sayandes/codequery/cilium/sockops/bpf_sockops.c", "Startline": " 55", "Endline": " 118 ", "Funcname": " bpf_sock_ops_ipv4 ", "Input": " (struct bpf_sock_ops *skops) ", "Output": " void ", "Helpers": " [sk_extract4_key,sk_lb4_key,lb4_lookup_service,lookup_ip4_remote_endpoint", "Read_maps": " [] ", "Update_maps": " [skops] ", "Func_Description": " update the destination and source port, ip to the skops with respect to whther  the packet is redirect to proxy port (or we say whether verdict is larger than 0) ", "author": "Shun Zhang", "email": "shunz@bu.edu"}, "43": {"date": "2023-02-24", "File": " /home/sayandes/codequery/cilium/sockops/bpf_sockops.c", "Startline": " 122", "Endline": " 126 ", "Funcname": " bpf_sock_ops_ipv6 ", "Input": " (struct bpf_sock_ops *skops) ", "Output": " void ", "Helpers": " [bpf_sock_ops_ipv4] ", "Read_maps": " [] ", "Update_maps": " [skops] ", "Func_Description": " update the destination and source port, ip to the skops with respect to whther  the packet is redirect to proxy port (or we say whether verdict is larger than 0) same as bpf_sock_ops_ipv4 but adapt for ipv6 ", "author": "Shun Zhang", "email": "shunz@bu.edu"}, "44": {"date": "2023-02-24", "File": " /home/sayandes/codequery/cilium/sockops/bpf_sockops.c", "Startline": " 129", "Endline": " 154 ", "Funcname": " bpf_sockmap ", "Input": " (struct bpf_sock_ops *skops) ", "Output": " int ", "Helpers": " [bpf_sock_ops_ipv6, bpf_sock_ops_ipv4] ", "Read_maps": " [] ", "Update_maps": " [skops] ", "Func_Description": " calling bpf_sock_ops_ipv4 or bpf_sock_ops_ipv6 according to the family ip version  ", "author": "Shun Zhang", "email": "shunz@bu.edu"}, "45": {"date": "2023-02-24", "File": " /home/sayandes/codequery/cilium/bpf_alignchecker.c", "Startline": " 44", "Endline": " 99 ", "Funcname": " main ", "Input": " (void) ", "Output": " int ", "Helpers": " None", "Read_maps": " None", "Update_maps": " None", "Func_Description": " Print and debug all the existing variables (especially fast path  sections that printk is not appropriate for) ", "author": "Shun Zhang", "email": "shunz@bu.edu"}, "46": {"date": "2023-02-24", "File": " /home/sayandes/codequery/cilium/sockops/bpf_redir.c", "Startline": " 25", "Endline": " 39 ", "Funcname": " sk_msg_extract4_key ", "Input": " (const struct sk_msg_md *msg, struct sock_key *key) ", "Output": " void ", "Helpers": " [] ", "Read_maps": " [msg] ", "Update_maps": " [key] ", "Func_Description": " set the sport and dport of the input key with 32 bits local port and remote port (ip4)  ", "author": "Shun Zhang", "email": "shunz@bu.edu"}, "47": {"date": "2023-02-24", "File": " /home/sayandes/codequery/cilium/sockops/bpf_redir.c", "Startline": " 41", "Endline": " 67 ", "Funcname": " bpf_redir_proxy ", "Input": " (struct sk_msg_md *msg) ", "Output": " int ", "Helpers": " [sk_msg_extract4_key,lookup_ip4_remote_endpoint,policy_sk_egress,msg_redirect_hash] ", "Read_maps": " [msg] ", "Update_maps": " [key] ", "Func_Description": " Store infomations about destination id, dport and sport ip4 into message, flag set to be BPF_F_INGRESS ", "author": "Shun Zhang", "email": "shunz@bu.edu"}}}