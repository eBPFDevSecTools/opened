{"_default": {"1": {"date": "2023-02-24", "File": " /home/sayandes/codequery/katran/decap_kern.c", "Startline": " 34", "Endline": " 83", "Funcname": " process_l3_headers", "Input": " (struct packet_description *pckt, __u8 *protocol, __u64 off, __u16 *pkt_bytes, void *data, void *data_end, bool is_ipv6)", "Output": " int", "Helpers": " [bpf_ntohs]", "Read_maps": " []", "Update_maps": " []", "Func_Description": " Process layer 3 headers. Drop the packet if it is 1)bogus packet, len less than minimum ethernet frame size, 2)fragmented, 3)ipv4 header not equals to 20 bytes,                   which means it contains ip options, and we do not support them.                   Otherwise, perform decapsulation of the packet header. ", "author": "Qintian Huang", "email": "qthuang@bu.edu"}, "2": {"date": "2023-02-24", "File": " /home/sayandes/codequery/katran/decap_kern.c", "Startline": " 85", "Endline": " 120", "Funcname": " process_encaped_ipip_pckt", "Input": " (void **data, void **data_end, struct xdp_md *xdp, bool *is_ipv6, struct packet_description *pckt, __u8 *protocol, __u64 off, __u16 *pkt_bytes)", "Output": " int", "Helpers": " []", "Read_maps": " []", "Update_maps": " []", "Func_Description": " Process ip-in-ip encaped packet, drop the packet if 1) bogus packet, len less than minimum ethernet frame size, 2) not decaped successfully.                   Otherwise, perform decapsulation of the outer packet header. ", "author": "Qintian Huang", "email": "qthuang@bu.edu"}, "3": {"date": "2023-02-24", "File": " /home/sayandes/codequery/katran/decap_kern.c", "Startline": " 123", "Endline": " 161", "Funcname": " process_encaped_gue_pckt", "Input": " (void **data, void **data_end, struct xdp_md *xdp, bool is_ipv6)", "Output": " int", "Helpers": " []", "Read_maps": " []", "Update_maps": " []", "Func_Description": " Decapsulate the outer header of the packet based on whether the inner-outer combo is ipv6 or ipv4.                   Drop the packet if: 1) bogus packet, len less than minimum ethernet frame size, 2) not decaped succesfully.                   When ipv6, check the situation that the inner packet is ipv6 and ipv4                   When ipv4, check the situation that the inner packet is ipv4 ", "author": "Qintian Huang", "email": "qthuang@bu.edu"}, "4": {"date": "2023-02-24", "File": " /home/sayandes/codequery/katran/decap_kern.c", "Startline": " 164", "Endline": " 221", "Funcname": " process_packet", "Input": " (void *data, __u64 off, void *data_end, bool is_ipv6, struct xdp_md *xdp)", "Output": " int", "Helpers": " [bpf_map_lookup_elem, bpf_htons]", "Read_maps": " [ decap_counters,]", "Update_maps": " []", "Func_Description": " This is a function which assembles the previous 3 functions process_l3_headers, process_encaped_ipip_pckt                   and process_encaped_gue_pckt. It process the packet regardless the type of the packet. ", "author": "Qintian Huang", "email": "qthuang@bu.edu"}, "5": {"date": "2023-02-24", "File": " /home/sayandes/codequery/katran/decap_kern.c", "Startline": " 223", "Endline": " 247", "Funcname": " xdpdecap", "Input": " (struct xdp_md *ctx)", "Output": " int", "Helpers": " []", "Read_maps": " []", "Update_maps": " []", "Func_Description": " This is wrapper function which decapsulates the packet packet header for all types. After processing the packet, pass it to tcp/ip stack. ", "author": "Qintian Huang", "email": "qthuang@bu.edu"}, "6": {"date": "2023-02-24", "File": " /home/sayandes/codequery/katran/healthchecking_ipip.c", "Startline": " 88", "Endline": " 157", "Funcname": " healthcheck_encap", "Input": " (struct __sk_buff *skb)", "Output": " int", "Helpers": " [bpf_redirect,bpf_skb_set_tunnel_key,bpf_map_lookup_elem,]", "Read_maps": " [ hc_ctrl_map, hc_reals_map, hc_stats_map,]", "Update_maps": " []", "Func_Description": " Performs healthcheck for ip-in-ip encapsulated packets.                   Use default action configured from tc (TC_ACT_UNSPEC), which is skip the packet, if                    1) program stats is NULL/stats_key is not found in hc_stats_map,                    2)mark of the sk_buff is 0,                    3)somark is not found in hc_reals_map                   The program returns error/healthcheck fails (TC_ACT_SHOT) if                    1)packet is bigger than the specified size,                   2)do not have ipip v4 or v6 ifindex for main interface.                   Otherwise, Populate tunnel metadata for packet associated to skb, the tunnel metadata is set to the contents of tkey.                   The packet passes the healthcheck, and will be redirected to another net device of index intf_ifindex. ", "author": "Qintian Huang", "email": "qthuang@bu.edu"}, "7": {"date": "2023-02-24", "File": " /home/sayandes/codequery/katran/x.c", "Startline": " 8", "Endline": " 13", "Funcname": " xdp_prog_simple", "Input": " (struct xdp_md *ctx)", "Output": " int", "Helpers": " []", "Read_maps": " []", "Update_maps": " []", "Func_Description": " Same as decap_kern, it decaps the packet and pass it to the tcp/ip stack. ", "author": "Qintian Huang", "email": "qthuang@bu.edu"}, "8": {"date": "2023-02-24", "File": " /home/sayandes/codequery/katran/xdp_root.c", "Startline": " 30", "Endline": " 37", "Funcname": " xdp_root", "Input": " (struct xdp_md *ctx)", "Output": " \\xdp\\)", "Helpers": " [bpf_tail_call,]", "Read_maps": " []", "Update_maps": " []", "Func_Description": " Input (struct xdp_md* ctx) is user accessible metadata for XDP packet hook                   The program will jump into another eBPF program.                   For each index in root_array, the program attempts to jump into a program referenced at index i                   and passes ctx, a pointer to the context.                   This programs chains and executes the input program, and finally pass the packet. ", "author": "Qintian Huang", "email": "qthuang@bu.edu"}, "9": {"date": "2023-02-24", "File": " /home/sayandes/codequery/katran/xdp_root.c", "Startline": " 40", "Endline": " 47", "Funcname": " xdp_val", "Input": " (struct xdp_md *ctx)", "Output": " \\xdp\\)", "Helpers": " [bpf_tail_call,]", "Read_maps": " []", "Update_maps": " []", "Func_Description": " Input (struct xdp_md* ctx) is user accessible metadata for XDP packet hook                   The program will jump into another eBPF program.                   For each index in root_array, the program attempts to jump into a program referenced at index i                   and passes ctx, a pointer to the context.                   This programs chains and executes the input program, and finally pass the packet. ", "author": "Qintian Huang", "email": "qthuang@bu.edu"}, "10": {"date": "2023-02-24", "File": " /home/sayandes/codequery/katran/healthchecking_kern.c", "Startline": " 33", "Endline": " 139", "Funcname": " healthcheck_encap", "Input": " (struct __sk_buff *skb)", "Output": " int", "Helpers": " [bpf_map_lookup_elem,bpf_redirect,]", "Read_maps": " [ hc_ctrl_map, per_hckey_stats, hc_reals_map, hc_key_map, hc_stats_map, hc_pckt_macs,]", "Update_maps": " []", "Func_Description": " Input is user accessible mirror of in-kernel sk_buff                   This function performs healthcheck for encapsulation                   Use default action configured from tc (TC_ACT_UNSPEC), which is skip the packet, if                    1) program stats is NULL/stats_key is not found in hc_stats_map,                    2)mark of the sk_buff is 0,                    3)somark is not found in hc_reals_map                   The program returns error/healthcheck fails (TC_ACT_SHOT) if 1)packet is bigger than the specified size,                   2)do not have ifindex for main interface,                   3)do not find HC_SRC_MAC_POS or HC_DST_MAC_POS,                   4)the result for HC_ENCAP (healthcheck encap) is faulse.                   Otherwise, the packet passes the healthcheck, and will be redirected to another net device of index intf_ifindex. ", "author": "Qintian Huang", "email": "qthuang@bu.edu"}, "11": {"date": "2023-02-24", "File": " /home/sayandes/codequery/katran/balancer_kern.c", "Startline": " 24", "Endline": " 50 ", "Funcname": " is_under_flood ", "Input": " (__u64 *cur_time) ", "Output": " bool ", "Helpers": " [bpf_map_lookup_elem,bpf_ktime_get_ns,] ", "Read_maps": " [ stats,] ", "Update_maps": " [] ", "Func_Description": " Check how many connection have been made within the last one second(or other predefined value), function will return true if it's exceding the max connection rate and false otherwise. ", "author": "Nengneng Yu", "email": "ynn1999@bu.edu"}, "12": {"date": "2023-02-24", "File": " /home/sayandes/codequery/katran/balancer_kern.c", "Startline": " 52", "Endline": " 131 ", "Funcname": " get_packet_dst ", "Input": " (struct real_definition **real, struct packet_description *pckt, struct vip_meta *vip_info, bool is_ipv6, void *lru_map) ", "Output": " bool ", "Helpers": " [bpf_map_update_elem,bpf_map_lookup_elem,] ", "Read_maps": " [ stats, lpm_src_v6, ch_rings, reals, lpm_src_v4,] ", "Update_maps": " [ lru_map,] ", "Func_Description": " This function checks the source routing for new connections. ", "author": "Nengneng Yu", "email": "ynn1999@bu.edu"}, "13": {"date": "2023-02-24", "File": " /home/sayandes/codequery/katran/balancer_kern.c", "Startline": " 133", "Endline": " 156 ", "Funcname": " connection_table_lookup ", "Input": " (struct real_definition **real, struct packet_description *pckt, void *lru_map, bool isGlobalLru) ", "Output": " void ", "Helpers": " [bpf_map_lookup_elem,bpf_ktime_get_ns,] ", "Read_maps": " [ lru_map, reals,] ", "Update_maps": " [] ", "Func_Description": " First check if the packet flow exists in lru_map and whether this connection is legal regarding its connection time(only check this if it is UDP protocol). Then we update the input real using the info from reals ", "author": "Nengneng Yu", "email": "ynn1999@bu.edu"}, "14": {"date": "2023-02-24", "File": " /home/sayandes/codequery/katran/balancer_kern.c", "Startline": " 158", "Endline": " 230 ", "Funcname": " process_l3_headers ", "Input": " (struct packet_description *pckt, __u8 *protocol, __u64 off, __u16 *pkt_bytes, void *data, void *data_end, bool is_ipv6) ", "Output": " int ", "Helpers": " [] ", "Read_maps": " [] ", "Update_maps": " [] ", "Func_Description": " Function processes the packet based on protocol and stores information in packet_description structure  ", "author": "Nengneng Yu", "email": "ynn1999@bu.edu"}, "15": {"date": "2023-02-24", "File": " /home/sayandes/codequery/katran/balancer_kern.c", "Startline": " 233", "Endline": " 255 ", "Funcname": " check_decap_dst ", "Input": " (struct packet_description *pckt, bool is_ipv6, bool *pass) ", "Output": " int ", "Helpers": " [bpf_map_lookup_elem,] ", "Read_maps": " [ stats, decap_dst,] ", "Update_maps": " [] ", "Func_Description": " Given input \"pckt\", check if its flow's dst is legal. if it does, increase the coresponding stats's amount ", "author": "Nengneng Yu", "email": "ynn1999@bu.edu"}, "16": {"date": "2023-02-24", "File": " /home/sayandes/codequery/katran/balancer_kern.c", "Startline": " 261", "Endline": " 277 ", "Funcname": " reals_have_same_addr ", "Input": " (struct real_definition *a, struct real_definition *b) ", "Output": " bool ", "Helpers": " [] ", "Read_maps": " [] ", "Update_maps": " [] ", "Func_Description": " Function checks the input 2 backend servers have the same dst addresses ", "author": "Nengneng Yu", "email": "ynn1999@bu.edu"}, "17": {"date": "2023-02-24", "File": " /home/sayandes/codequery/katran/balancer_kern.c", "Startline": " 279", "Endline": " 335 ", "Funcname": " perform_global_lru_lookup ", "Input": " (struct real_definition **dst, struct packet_description *pckt, __u32 cpu_num, struct vip_meta *vip_info, bool is_ipv6) ", "Output": " int ", "Helpers": " [bpf_map_lookup_elem,] ", "Read_maps": " [ stats, global_lru_maps,] ", "Update_maps": " [] ", "Func_Description": " (can't understand) find the lru_map from global cache based on gicen cpu_num, ", "author": "Nengneng Yu", "email": "ynn1999@bu.edu"}, "18": {"date": "2023-02-24", "File": " /home/sayandes/codequery/katran/balancer_kern.c", "Startline": " 340", "Endline": " 387 ", "Funcname": " process_encaped_ipip_pckt ", "Input": " (void **data, void **data_end, struct xdp_md *xdp, bool *is_ipv6, __u8 *protocol, bool pass) ", "Output": " int ", "Helpers": " [] ", "Read_maps": " [] ", "Update_maps": " [] ", "Func_Description": " Used for IPIP packets, Based on the encapsulate packet protocol type,  call the appropriate decapsulation function and decrement ttl ", "author": "Nengneng Yu", "email": "ynn1999@bu.edu"}, "19": {"date": "2023-02-24", "File": " /home/sayandes/codequery/katran/balancer_kern.c", "Startline": " 391", "Endline": " 441 ", "Funcname": " process_encaped_gue_pckt ", "Input": " (void **data, void **data_end, struct xdp_md *xdp, bool is_ipv6, bool pass) ", "Output": " int ", "Helpers": " [] ", "Read_maps": " [] ", "Update_maps": " [] ", "Func_Description": " Used for GUE packets,Based on the encapsulate packet protocol type,  call the appropriate decapsulation function and decrement ttl ", "author": "Nengneng Yu", "email": "ynn1999@bu.edu"}, "20": {"date": "2023-02-24", "File": " /home/sayandes/codequery/katran/balancer_kern.c", "Startline": " 444", "Endline": " 457 ", "Funcname": " increment_quic_cid_version_stats ", "Input": " (int host_id) ", "Output": " void ", "Helpers": " [bpf_map_lookup_elem,] ", "Read_maps": " [ stats,] ", "Update_maps": " [] ", "Func_Description": " Function updates quic protocol stats ", "author": "Nengneng Yu", "email": "ynn1999@bu.edu"}, "21": {"date": "2023-02-24", "File": " /home/sayandes/codequery/katran/balancer_kern.c", "Startline": " 459", "Endline": " 468 ", "Funcname": " increment_quic_cid_drop_no_real ", "Input": " () ", "Output": " void ", "Helpers": " [bpf_map_lookup_elem,] ", "Read_maps": " [ stats,] ", "Update_maps": " [] ", "Func_Description": " lookup stats by QUIC_CID_DROP_STATS, increment stats v1 by 1 ", "author": "Nengneng Yu", "email": "ynn1999@bu.edu"}, "22": {"date": "2023-02-24", "File": " /home/sayandes/codequery/katran/balancer_kern.c", "Startline": " 470", "Endline": " 478 ", "Funcname": " increment_quic_cid_drop_real_0 ", "Input": " () ", "Output": " void ", "Helpers": " [bpf_map_lookup_elem,] ", "Read_maps": " [ stats,] ", "Update_maps": " [] ", "Func_Description": " lookup stats by QUIC_CID_DROP_STATS, update Corresponding stats's v2 ", "author": "Nengneng Yu", "email": "ynn1999@bu.edu"}, "23": {"date": "2023-02-24", "File": " /home/sayandes/codequery/katran/balancer_kern.c", "Startline": " 480", "Endline": " 791 ", "Funcname": " process_packet ", "Input": " (struct xdp_md *xdp, __u64 off, bool is_ipv6) ", "Output": " int ", "Helpers": " [bpf_map_lookup_elem,bpf_get_smp_processor_id,] ", "Read_maps": " [ lru_mapping, server_id_map, stats, reals, ctl_array, vip_map, reals_stats,] ", "Update_maps": " [] ", "Func_Description": " This function process the packet based on the protocol and updates corresponding stats. ", "author": "Nengneng Yu", "email": "ynn1999@bu.edu"}, "24": {"date": "2023-02-24", "File": " /home/sayandes/codequery/katran/balancer_kern.c", "Startline": " 793", "Endline": " 817 ", "Funcname": " balancer_ingress ", "Input": " (struct xdp_md *ctx) ", "Output": " int ", "Helpers": " [] ", "Read_maps": " [] ", "Update_maps": " [] ", "Func_Description": " process the input ctx packet ", "author": "Nengneng Yu", "email": "ynn1999@bu.edu"}, "25": {"date": "2023-02-24", "File": " /home/sayandes/codequery/katran/balancer_kern.c", "Startline": " 818", "Endline": " 827 ", "Funcname": " get_packet_hash ", "Input": " (struct packet_description *pckt, bool hash_16bytes) ", "Output": " __u32 ", "Helpers": " [] ", "Read_maps": " [] ", "Update_maps": " [] ", "Func_Description": " return the hash value of input packet ", "author": "Nengneng Yu", "email": "ynn1999@bu.edu"}}}