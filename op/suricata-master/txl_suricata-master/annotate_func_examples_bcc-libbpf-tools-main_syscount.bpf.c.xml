<?xml version="1.0"?>
<doc>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/syscount.bpf.c" funcheader="static __always_inline void save_proc_name (struct data_t *val)" startline="40" endline="50">
static __always_inline void save_proc_name (struct data_t *val)
{
    struct task_struct *current = (void *) bpf_get_current_task ();
    BPF_CORE_READ_STR_INTO (&val->comm, current, group_leader, comm);
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/syscount.bpf.c" funcheader="int sys_enter (struct trace_event_raw_sys_enter *args)" startline="53" endline="69">
int sys_enter (struct trace_event_raw_sys_enter *args)
{
    u64 id = bpf_get_current_pid_tgid ();
    pid_t pid = id >> 32;
    u32 tid = id;
    u64 ts;
    if (filter_cg && !bpf_current_task_under_cgroup (&cgroup_map, 0))
        return 0;
    if (filter_pid && pid != filter_pid)
        return 0;
    ts = bpf_ktime_get_ns ();
    bpf_map_update_elem (&start, &tid, &ts, 0);
    return 0;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/syscount.bpf.c" funcheader="int sys_exit (struct trace_event_raw_sys_exit *args)" startline="72" endline="113">
int sys_exit (struct trace_event_raw_sys_exit *args)
{
    if (filter_cg && !bpf_current_task_under_cgroup (&cgroup_map, 0))
        return 0;
    u64 id = bpf_get_current_pid_tgid ();
    static const struct data_t zero;
    pid_t pid = id >> 32;
    struct data_t *val;
    u64 *start_ts, lat = 0;
    u32 tid = id;
    u32 key;
    if (args->id == -1)
        return 0;
    if (filter_pid && pid != filter_pid)
        return 0;
    if (filter_failed && args->ret >= 0)
        return 0;
    if (filter_errno && args->ret != -filter_errno)
        return 0;
    if (measure_latency) {
        start_ts = bpf_map_lookup_elem (& start, & tid);
        if (!start_ts)
            return 0;
        lat = bpf_ktime_get_ns () - *start_ts;
    }
    key = (count_by_process) ? pid : args->id;
    val = bpf_map_lookup_or_try_init (& data, & key, & zero);
    if (val) {
        __sync_fetch_and_add (&val->count, 1);
        if (count_by_process)
            save_proc_name (val);
        if (measure_latency)
            __sync_fetch_and_add (&val->total_ns, lat);
    }
    return 0;
}
</source>
</doc>
