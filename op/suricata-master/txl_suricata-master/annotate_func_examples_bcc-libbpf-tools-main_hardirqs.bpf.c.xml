<?xml version="1.0"?>
<doc>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/hardirqs.bpf.c" funcheader="static int handle_entry (int irq, struct irqaction *action)" startline="41" endline="66">
static int handle_entry (int irq, struct irqaction *action)
{
    if (filter_cg && !bpf_current_task_under_cgroup (&cgroup_map, 0))
        return 0;
    if (do_count) {
        struct irq_key key = {}
        ;
        struct info *info;
        bpf_probe_read_kernel_str (&key.name, sizeof (key.name), BPF_CORE_READ (action, name));
        info = bpf_map_lookup_or_try_init (& infos, & key, & zero);
        if (!info)
            return 0;
        info->count += 1;
        return 0;
    }
    else {
        u64 ts = bpf_ktime_get_ns ();
        u32 key = 0;
        if (filter_cg && !bpf_current_task_under_cgroup (&cgroup_map, 0))
            return 0;
        bpf_map_update_elem (&start, &key, &ts, BPF_ANY);
        return 0;
    }
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/hardirqs.bpf.c" funcheader="static int handle_exit (int irq, struct irqaction *action)" startline="68" endline="104">
static int handle_exit (int irq, struct irqaction *action)
{
    struct irq_key ikey = {}
    ;
    struct info *info;
    u32 key = 0;
    u64 delta;
    u64 *tsp;
    if (filter_cg && !bpf_current_task_under_cgroup (&cgroup_map, 0))
        return 0;
    tsp = bpf_map_lookup_elem (& start, & key);
    if (!tsp)
        return 0;
    delta = bpf_ktime_get_ns () - *tsp;
    if (!targ_ns)
        delta /= 1000U;
    bpf_probe_read_kernel_str (&ikey.name, sizeof (ikey.name), BPF_CORE_READ (action, name));
    info = bpf_map_lookup_or_try_init (& infos, & ikey, & zero);
    if (!info)
        return 0;
    if (!targ_dist) {
        info->count += delta;
    }
    else {
        u64 slot;
        slot = log2 (delta);
        if (slot >= MAX_SLOTS)
            slot = MAX_SLOTS - 1;
        info->slots[slot]++;
    }
    return 0;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/hardirqs.bpf.c" funcheader="int BPF_PROG (irq_handler_entry_btf, int irq, struct irqaction *action)" startline="107" endline="110">
int BPF_PROG (irq_handler_entry_btf, int irq, struct irqaction *action)
{
    return handle_entry (irq, action);
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/hardirqs.bpf.c" funcheader="int BPF_PROG (irq_handler_exit_btf, int irq, struct irqaction *action)" startline="113" endline="116">
int BPF_PROG (irq_handler_exit_btf, int irq, struct irqaction *action)
{
    return handle_exit (irq, action);
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/hardirqs.bpf.c" funcheader="int BPF_PROG (irq_handler_entry, int irq, struct irqaction *action)" startline="119" endline="122">
int BPF_PROG (irq_handler_entry, int irq, struct irqaction *action)
{
    return handle_entry (irq, action);
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/hardirqs.bpf.c" funcheader="int BPF_PROG (irq_handler_exit, int irq, struct irqaction *action)" startline="125" endline="128">
int BPF_PROG (irq_handler_exit, int irq, struct irqaction *action)
{
    return handle_exit (irq, action);
}
</source>
</doc>
