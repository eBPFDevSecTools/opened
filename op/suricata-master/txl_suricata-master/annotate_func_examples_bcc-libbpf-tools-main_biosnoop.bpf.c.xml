<?xml version="1.0"?>
<doc>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/biosnoop.bpf.c" funcheader="static __always_inline int trace_pid (struct request *rq)" startline="57" endline="67">
static __always_inline int trace_pid (struct request *rq)
{
    u64 id = bpf_get_current_pid_tgid ();
    struct piddata piddata = {}
    ;
    piddata.pid = id >> 32;
    bpf_get_current_comm (&piddata.comm, sizeof (&piddata.comm));
    bpf_map_update_elem (&infobyreq, &rq, &piddata, 0);
    return 0;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/biosnoop.bpf.c" funcheader="int BPF_PROG (blk_account_io_start, struct request *rq)" startline="70" endline="76">
int BPF_PROG (blk_account_io_start, struct request *rq)
{
    if (filter_cg && !bpf_current_task_under_cgroup (&cgroup_map, 0))
        return 0;
    return trace_pid (rq);
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/biosnoop.bpf.c" funcheader="int BPF_KPROBE (blk_account_io_merge_bio, struct request *rq)" startline="79" endline="85">
int BPF_KPROBE (blk_account_io_merge_bio, struct request *rq)
{
    if (filter_cg && !bpf_current_task_under_cgroup (&cgroup_map, 0))
        return 0;
    return trace_pid (rq);
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/biosnoop.bpf.c" funcheader="static __always_inline int trace_rq_start (struct request *rq, bool insert)" startline="87" endline="110">
static __always_inline int trace_rq_start (struct request *rq, bool insert)
{
    struct stage *stagep, stage = {};
    u64 ts = bpf_ktime_get_ns ();
    stagep = bpf_map_lookup_elem (& start, & rq);
    if (!stagep) {
        struct gendisk *disk = get_disk (rq);
        stage.dev = disk ? MKDEV (BPF_CORE_READ (disk, major), BPF_CORE_READ (disk, first_minor)) : 0;
        if (filter_dev && targ_dev != stage.dev)
            return 0;
        stagep = &stage;
    }
    if (insert)
        stagep->insert = ts;
    else
        stagep->issue = ts;
    if (stagep == &stage)
        bpf_map_update_elem (&start, &rq, stagep, 0);
    return 0;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/biosnoop.bpf.c" funcheader="int BPF_PROG (block_rq_insert)" startline="113" endline="127">
int BPF_PROG (block_rq_insert)
{
    if (filter_cg && !bpf_current_task_under_cgroup (&cgroup_map, 0))
        return 0;
    if (LINUX_KERNEL_VERSION >= KERNEL_VERSION (5, 11, 0))
        return trace_rq_start ((void *) ctx[0], true);
    else
        return trace_rq_start ((void *) ctx[1], true);
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/biosnoop.bpf.c" funcheader="int BPF_PROG (block_rq_issue)" startline="130" endline="144">
int BPF_PROG (block_rq_issue)
{
    if (filter_cg && !bpf_current_task_under_cgroup (&cgroup_map, 0))
        return 0;
    if (LINUX_KERNEL_VERSION >= KERNEL_VERSION (5, 11, 0))
        return trace_rq_start ((void *) ctx[0], false);
    else
        return trace_rq_start ((void *) ctx[1], false);
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/biosnoop.bpf.c" funcheader="int BPF_PROG (block_rq_complete, struct request *rq, int error, unsigned int nr_bytes)" startline="147" endline="192">
int BPF_PROG (block_rq_complete, struct request *rq, int error, unsigned int nr_bytes)
{
    if (filter_cg && !bpf_current_task_under_cgroup (&cgroup_map, 0))
        return 0;
    u64 ts = bpf_ktime_get_ns ();
    struct piddata *piddatap;
    struct event event = {}
    ;
    struct stage *stagep;
    s64 delta;
    stagep = bpf_map_lookup_elem (& start, & rq);
    if (!stagep)
        return 0;
    delta = (s64) (ts - stagep->issue);
    if (delta < 0)
        goto cleanup;
    piddatap = bpf_map_lookup_elem (& infobyreq, & rq);
    if (!piddatap) {
        event.comm[0] = '?';
    }
    else {
        __builtin_memcpy (&event.comm, piddatap->comm, sizeof (event.comm));
        event.pid = piddatap->pid;
    }
    event.delta = delta;
    if (targ_queued && BPF_CORE_READ (rq, q, elevator)) {
        if (!stagep->insert)
            event.qdelta = -1;
        else
            event.qdelta = stagep->issue - stagep->insert;
    }
    event.ts = ts;
    event.sector = rq->__sector;
    event.len = rq->__data_len;
    event.cmd_flags = rq->cmd_flags;
    event.dev = stagep->dev;
    bpf_perf_event_output (ctx, &events, BPF_F_CURRENT_CPU, &event, sizeof (event));
cleanup :
    bpf_map_delete_elem (&start, &rq);
    bpf_map_delete_elem (&infobyreq, &rq);
    return 0;
}
</source>
</doc>
