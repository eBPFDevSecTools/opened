<?xml version="1.0"?>
<doc>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/biolatency.bpf.c" funcheader="static int __always_inline trace_rq_start (struct request *rq, int issue)" startline="47" endline="70">
static int __always_inline trace_rq_start (struct request *rq, int issue)
{
    u64 ts;
    if (filter_cg && !bpf_current_task_under_cgroup (&cgroup_map, 0))
        return 0;
    if (issue && targ_queued && BPF_CORE_READ (rq, q, elevator))
        return 0;
    ts = bpf_ktime_get_ns ();
    if (filter_dev) {
        struct gendisk *disk = get_disk (rq);
        u32 dev;
        dev = disk ? MKDEV (BPF_CORE_READ (disk, major), BPF_CORE_READ (disk, first_minor)) : 0;
        if (targ_dev != dev)
            return 0;
    }
    bpf_map_update_elem (&start, &rq, &ts, 0);
    return 0;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/biolatency.bpf.c" funcheader="static int handle_block_rq_insert (__u64 *ctx)" startline="72" endline="83">
static int handle_block_rq_insert (__u64 *ctx)
{
    if (LINUX_KERNEL_VERSION < KERNEL_VERSION (5, 11, 0))
        return trace_rq_start ((void *) ctx[1], false);
    else
        return trace_rq_start ((void *) ctx[0], false);
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/biolatency.bpf.c" funcheader="static int handle_block_rq_issue (__u64 *ctx)" startline="85" endline="96">
static int handle_block_rq_issue (__u64 *ctx)
{
    if (LINUX_KERNEL_VERSION < KERNEL_VERSION (5, 11, 0))
        return trace_rq_start ((void *) ctx[1], true);
    else
        return trace_rq_start ((void *) ctx[0], true);
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/biolatency.bpf.c" funcheader="static int handle_block_rq_complete (struct request *rq, int error, unsigned int nr_bytes)" startline="98" endline="145">
static int handle_block_rq_complete (struct request *rq, int error, unsigned int nr_bytes)
{
    u64 slot, *tsp, ts = bpf_ktime_get_ns ();
    struct hist_key hkey = {}
    ;
    struct hist *histp;
    s64 delta;
    if (filter_cg && !bpf_current_task_under_cgroup (&cgroup_map, 0))
        return 0;
    tsp = bpf_map_lookup_elem (& start, & rq);
    if (!tsp)
        return 0;
    delta = (s64) (ts - *tsp);
    if (delta < 0)
        goto cleanup;
    if (targ_per_disk) {
        struct gendisk *disk = get_disk (rq);
        hkey.dev = disk ? MKDEV (BPF_CORE_READ (disk, major), BPF_CORE_READ (disk, first_minor)) : 0;
    }
    if (targ_per_flag)
        hkey.cmd_flags = BPF_CORE_READ (rq, cmd_flags);
    histp = bpf_map_lookup_elem (& hists, & hkey);
    if (!histp) {
        bpf_map_update_elem (&hists, &hkey, &initial_hist, 0);
        histp = bpf_map_lookup_elem (& hists, & hkey);
        if (!histp)
            goto cleanup;
    }
    if (targ_ms)
        delta /= 1000000U;
    else
        delta /= 1000U;
    slot = log2l (delta);
    if (slot >= MAX_SLOTS)
        slot = MAX_SLOTS - 1;
    __sync_fetch_and_add (&histp->slots[slot], 1);
cleanup :
    bpf_map_delete_elem (&start, &rq);
    return 0;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/biolatency.bpf.c" funcheader="int block_rq_insert_btf (u64 *ctx)" startline="148" endline="151">
int block_rq_insert_btf (u64 *ctx)
{
    return handle_block_rq_insert (ctx);
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/biolatency.bpf.c" funcheader="int block_rq_issue_btf (u64 *ctx)" startline="154" endline="157">
int block_rq_issue_btf (u64 *ctx)
{
    return handle_block_rq_issue (ctx);
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/biolatency.bpf.c" funcheader="int BPF_PROG (block_rq_complete_btf, struct request *rq, int error, unsigned int nr_bytes)" startline="160" endline="163">
int BPF_PROG (block_rq_complete_btf, struct request *rq, int error, unsigned int nr_bytes)
{
    return handle_block_rq_complete (rq, error, nr_bytes);
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/biolatency.bpf.c" funcheader="int BPF_PROG (block_rq_insert)" startline="166" endline="169">
int BPF_PROG (block_rq_insert)
{
    return handle_block_rq_insert (ctx);
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/biolatency.bpf.c" funcheader="int BPF_PROG (block_rq_issue)" startline="172" endline="175">
int BPF_PROG (block_rq_issue)
{
    return handle_block_rq_issue (ctx);
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/biolatency.bpf.c" funcheader="int BPF_PROG (block_rq_complete, struct request *rq, int error, unsigned int nr_bytes)" startline="178" endline="181">
int BPF_PROG (block_rq_complete, struct request *rq, int error, unsigned int nr_bytes)
{
    return handle_block_rq_complete (rq, error, nr_bytes);
}
</source>
</doc>
