<?xml version="1.0"?>
<doc>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/slabratetop.c" funcheader="static error_t parse_arg (int key, char *arg, struct argp_state *state)" startline="69" endline="140">
static error_t parse_arg (int key, char *arg, struct argp_state *state)
{
    long pid, rows;
    static int pos_args;
    switch (key) {
    case 'p' :
        errno = 0;
        pid = strtol (arg, NULL, 10);
        if (errno || pid <= 0) {
            warn ("invalid PID: %s\n", arg);
            argp_usage (state);
        }
        target_pid = pid;
        break;
    case 'C' :
        clear_screen = false;
        break;
    case 's' :
        if (!strcmp (arg, "name")) {
            sort_by = SORT_BY_CACHE_NAME;
        }
        else if (!strcmp (arg, "count")) {
            sort_by = SORT_BY_CACHE_COUNT;
        }
        else if (!strcmp (arg, "size")) {
            sort_by = SORT_BY_CACHE_SIZE;
        }
        else {
            warn ("invalid sort method: %s\n", arg);
            argp_usage (state);
        }
        break;
    case 'r' :
        errno = 0;
        rows = strtol (arg, NULL, 10);
        if (errno || rows <= 0) {
            warn ("invalid rows: %s\n", arg);
            argp_usage (state);
        }
        output_rows = rows;
        if (output_rows > OUTPUT_ROWS_LIMIT)
            output_rows = OUTPUT_ROWS_LIMIT;
        break;
    case 'v' :
        verbose = true;
        break;
    case 'h' :
        argp_state_help (state, stderr, ARGP_HELP_STD_HELP);
        break;
    case ARGP_KEY_ARG :
        errno = 0;
        if (pos_args == 0) {
            interval = strtol (arg, NULL, 10);
            if (errno || interval <= 0) {
                warn ("invalid interval\n");
                argp_usage (state);
            }
        }
        else if (pos_args == 1) {
            count = strtol (arg, NULL, 10);
            if (errno || count <= 0) {
                warn ("invalid count\n");
                argp_usage (state);
            }
        }
        else {
            warn ("unrecognized positional argument: %s\n", arg);
            argp_usage (state);
        }
        pos_args++;
        break;
    default :
        return ARGP_ERR_UNKNOWN;
    }
    return 0;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/slabratetop.c" funcheader="static int libbpf_print_fn (enum libbpf_print_level level, const char *format, va_list args)" startline="142" endline="147">
static int libbpf_print_fn (enum libbpf_print_level level, const char *format, va_list args)
{
    if (level == LIBBPF_DEBUG && !verbose)
        return 0;
    return vfprintf (stderr, format, args);
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/slabratetop.c" funcheader="static void sig_int (int signo)" startline="149" endline="152">
static void sig_int (int signo)
{
    exiting = 1;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/slabratetop.c" funcheader="static int sort_column (const void *obj1, const void *obj2)" startline="154" endline="168">
static int sort_column (const void *obj1, const void *obj2)
{
    struct slabrate_info *s1 = (struct slabrate_info *) obj1;
    struct slabrate_info *s2 = (struct slabrate_info *) obj2;
    if (sort_by == SORT_BY_CACHE_NAME) {
        return strcasecmp (s1->name, s2->name);
    }
    else if (sort_by == SORT_BY_CACHE_COUNT) {
        return s2->count - s1->count;
    }
    else if (sort_by == SORT_BY_CACHE_SIZE) {
        return s2->size - s1->size;
    }
    else {
        return s2->size - s1->size;
    }
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/slabratetop.c" funcheader="static int print_stat (struct slabratetop_bpf *obj)" startline="170" endline="240">
static int print_stat (struct slabratetop_bpf *obj)
{
    FILE *f;
    time_t t;
    struct tm *tm;
    char ts [16], buf [256];
    char *key, **prev_key = NULL;
    static struct slabrate_info values [OUTPUT_ROWS_LIMIT];
    int n, i, err = 0, rows = 0;
    int fd = bpf_map__fd (obj -> maps.slab_entries);
    f = fopen ("/proc/loadavg", "r");
    if (f) {
        time (&t);
        tm = localtime (& t);
        strftime (ts, sizeof (ts), "%H:%M:%S", tm);
        memset (buf, 0, sizeof (buf));
        n = fread (buf, 1, sizeof (buf), f);
        if (n)
            printf ("%8s loadavg: %s\n", ts, buf);
        fclose (f);
    }
    printf ("%-32s %6s %10s\n", "CACHE", "ALLOCS", "BYTES");
    while (1) {
        err = bpf_map_get_next_key (fd, prev_key, & key);
        if (err) {
            if (errno == ENOENT) {
                err = 0;
                break;
            }
            warn ("bpf_map_get_next_key failed: %s\n", strerror (errno));
            return err;
        }
        err = bpf_map_lookup_elem (fd, & key, & values [rows ++]);
        if (err) {
            warn ("bpf_map_lookup_elem failed: %s\n", strerror (errno));
            return err;
        }
        prev_key = &key;
    }
    qsort (values, rows, sizeof (struct slabrate_info), sort_column);
    rows = rows < output_rows ? rows : output_rows;
    for (i = 0; i < rows; i++)
        printf ("%-32s %6lld %10lld\n", values[i].name, values[i].count, values[i].size);
    printf ("\n");
    prev_key = NULL;
    while (1) {
        err = bpf_map_get_next_key (fd, prev_key, & key);
        if (err) {
            if (errno == ENOENT) {
                err = 0;
                break;
            }
            warn ("bpf_map_get_next_key failed: %s\n", strerror (errno));
            return err;
        }
        err = bpf_map_delete_elem (fd, & key);
        if (err) {
            warn ("bpf_map_delete_elem failed: %s\n", strerror (errno));
            return err;
        }
        prev_key = &key;
    }
    return err;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/slabratetop.c" funcheader="int main (int argc, char **argv)" startline="242" endline="307">
int main (int argc, char **argv)
{
    static const struct argp argp = {
        .options = opts,
        .parser = parse_arg,
        .doc = argp_program_doc,}
    ;
    struct slabratetop_bpf *obj;
    int err;
    err = argp_parse (& argp, argc, argv, 0, NULL, NULL);
    if (err)
        return err;
    libbpf_set_strict_mode (LIBBPF_STRICT_ALL);
    libbpf_set_print (libbpf_print_fn);
    obj = slabratetop_bpf__open ();
    if (!obj) {
        warn ("failed to open BPF object\n");
        return 1;
    }
    obj->rodata->target_pid = target_pid;
    err = slabratetop_bpf__load (obj);
    if (err) {
        warn ("failed to load BPF object: %d\n", err);
        goto cleanup;
    }
    err = slabratetop_bpf__attach (obj);
    if (err) {
        warn ("failed to attach BPF programs: %d\n", err);
        goto cleanup;
    }
    if (signal (SIGINT, sig_int) == SIG_ERR) {
        warn ("can't set signal handler: %s\n", strerror (errno));
        err = 1;
        goto cleanup;
    }
    while (1) {
        sleep (interval);
        if (clear_screen) {
            err = system ("clear");
            if (err)
                goto cleanup;
        }
        err = print_stat (obj);
        if (err)
            goto cleanup;
        count--;
        if (exiting || !count)
            goto cleanup;
    }
cleanup :
    slabratetop_bpf__destroy (obj);
    return err != 0;
}
</source>
</doc>
