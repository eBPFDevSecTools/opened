<?xml version="1.0"?>
<doc>
<source file="/home/sayandes/opened_extraction/examples/xdp-mptm-main/src/kernel/lib/pkt-encap.h" funcheader="static __ALWAYS_INLINE__ void set_dst_mac (void *data, unsigned char *dst_mac)" startline="38" endline="46">
static __ALWAYS_INLINE__ void set_dst_mac (void *data, unsigned char *dst_mac)
{
    unsigned short *p = data;
    unsigned short *dst = (unsigned short *) dst_mac;
    p[0] = dst[0];
    p[1] = dst[1];
    p[2] = dst[2];
}
</source>
<source file="/home/sayandes/opened_extraction/examples/xdp-mptm-main/src/kernel/lib/pkt-encap.h" funcheader="static __ALWAYS_INLINE__ void set_src_mac (void *data, unsigned char *src_mac)" startline="48" endline="56">
static __ALWAYS_INLINE__ void set_src_mac (void *data, unsigned char *src_mac)
{
    unsigned short *p = data;
    unsigned short *src = (unsigned short *) src_mac;
    p[3] = src[0];
    p[4] = src[1];
    p[5] = src[2];
}
</source>
<source file="/home/sayandes/opened_extraction/examples/xdp-mptm-main/src/kernel/lib/pkt-encap.h" funcheader="static __ALWAYS_INLINE__ __u16 csum_fold_helper (__u64 csum)" startline="58" endline="67">
static __ALWAYS_INLINE__ __u16 csum_fold_helper (__u64 csum)
{
    int i;

#pragma unroll
    for (i = 0; i < 4; i++) {
        if (csum >> 16)
            csum = (csum & 0xffff) + (csum >> 16);
    }
    return ~csum;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/xdp-mptm-main/src/kernel/lib/pkt-encap.h" funcheader="static __ALWAYS_INLINE__ void ipv4_csum_inline (void *iph, __u64 *csum)" startline="69" endline="77">
static __ALWAYS_INLINE__ void ipv4_csum_inline (void *iph, __u64 *csum)
{
    __u16 *next_iph_u16 = (__u16 *) iph;

#pragma clang loop unroll(full)
    for (int i = 0; i < sizeof (struct iphdr) >> 1; i++) {
        *csum += *next_iph_u16++;
    }
    *csum = csum_fold_helper (*csum);
}
</source>
<source file="/home/sayandes/opened_extraction/examples/xdp-mptm-main/src/kernel/lib/pkt-encap.h" funcheader="static __ALWAYS_INLINE__ int __encap_geneve (struct xdp_md *ctx, struct ethhdr *eth, geneve_tunnel_info *tn)" startline="82" endline="192">
static __ALWAYS_INLINE__ int __encap_geneve (struct xdp_md *ctx, struct ethhdr *eth, geneve_tunnel_info *tn)
{
    int gnv_hdr_size = sizeof (struct genevehdr);
    int udp_hdr_size = sizeof (struct udphdr);
    int ip_hdr_size = sizeof (struct iphdr);
    int eth_hdr_size = sizeof (struct ethhdr);
    void *data = (void *) (long) ctx->data;
    void *data_end = (void *) (long) ctx->data_end;
    int old_size = (int) (data_end - data);
    struct ethhdr *eth_inner_hdr = (struct ethhdr *) data;
    if (eth_inner_hdr + 1 > data_end) {
        mptm_print ("[Agent: ] ABORTED: Bad ETH header offset \n");
        return XDP_ABORTED;
    }
    set_dst_mac (data, tn->inner_dest_mac);
    int outer_hdr_size = gnv_hdr_size + udp_hdr_size + ip_hdr_size + eth_hdr_size;
    long ret = bpf_xdp_adjust_head (ctx, (0 - outer_hdr_size));
    if (ret != 0l) {
        mptm_print ("[Agent:] DROP (BUG): Failure adjusting packet header!\n");
        return XDP_DROP;
    }
    data = (void *) (long) ctx->data;
    data_end = (void *) (long) ctx->data_end;
    struct ethhdr *ethcpy;
    ethcpy = data;
    if (ethcpy + 1 > data_end) {
        mptm_print ("[Agent: ] ABORTED: Bad ETH header offset \n");
        return XDP_ABORTED;
    }
    struct iphdr *ip = (struct iphdr *) (ethcpy + 1);
    if (ip + 1 > data_end) {
        mptm_print ("ABORTED: Bad ip header offset ip: %x data_end:%x \n", ip + 1, data_end);
        return XDP_ABORTED;
    }
    struct udphdr *udp = (struct udphdr *) (ip + 1);
    if (udp + 1 > data_end) {
        mptm_print ("ABORTED: Bad udp header offset \n");
        return XDP_ABORTED;
    }
    struct genevehdr *geneve = (struct genevehdr *) (udp + 1);
    if (geneve + 1 > data_end) {
        mptm_print ("ABORTED: Bad GENEVE header offset \n");
        return XDP_ABORTED;
    }
    ethcpy->h_proto = BE_ETH_P_IP;
    set_dst_mac (data, tn->dest_mac);
    set_src_mac (data, tn->source_mac);
    int outer_ip_payload = gnv_hdr_size + udp_hdr_size + ip_hdr_size + old_size;
    int outer_udp_payload = gnv_hdr_size + udp_hdr_size + old_size;
    ip->version = 4;
    ip->ihl = ip_hdr_size >> 2;
    ip->frag_off = 0;
    ip->protocol = IPPROTO_UDP;
    ip->check = 0;
    ip->tos = 0;
    ip->tot_len = bpf_htons (outer_ip_payload);
    ip->daddr = tn->dest_addr;
    ip->saddr = tn->source_addr;
    ip->ttl = DEFAULT_TTL;
    __u64 c_sum = 0;
    ipv4_csum_inline (ip, &c_sum);
    ip->check = c_sum;
    udp->check = 0;
    udp->source = tn->source_port;
    udp->dest = BE_GENEVE_DSTPORT;
    udp->len = bpf_htons (outer_udp_payload);
    __builtin_memset (geneve, 0, gnv_hdr_size);
    geneve->opt_len = 0 / 4;
    geneve->ver = 0;
    geneve->rsvd1 = 0;
    geneve->rsvd2 = 0;
    geneve->oam = 0;
    geneve->critical = 0;
    geneve->proto_type = bpf_htons (ETH_P_TEB);
    geneve->vni[0] = (__u8) (tn->vlan_id >> 16);
    geneve->vni[1] = (__u8) (tn->vlan_id >> 8);
    geneve->vni[2] = (__u8) tn->vlan_id;
    return XDP_PASS;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/xdp-mptm-main/src/kernel/lib/pkt-encap.h" funcheader="static __ALWAYS_INLINE__ int encap_geneve (struct xdp_md *ctx, struct ethhdr *eth, mptm_tunnel_info *tn)" startline="194" endline="200">
static __ALWAYS_INLINE__ int encap_geneve (struct xdp_md *ctx, struct ethhdr *eth, mptm_tunnel_info *tn)
{
    struct geneve_info *geneve = (geneve_tunnel_info *) (&tn->tnl_info.geneve);
    return __encap_geneve (ctx, eth, geneve);
}
</source>
<source file="/home/sayandes/opened_extraction/examples/xdp-mptm-main/src/kernel/lib/pkt-encap.h" funcheader="static __ALWAYS_INLINE__ int encap_vlan (struct xdp_md *ctx, struct ethhdr *eth, mptm_tunnel_info *tn)" startline="203" endline="214">
static __ALWAYS_INLINE__ int encap_vlan (struct xdp_md *ctx, struct ethhdr *eth, mptm_tunnel_info *tn)
{
    struct vlan_info *vlan = (vlan_tunnel_info *) (&tn->tnl_info.vlan);
    if (vlan_tag_push (ctx, eth, vlan->vlan_id) != 0) {
        mptm_print ("[ERR] vlan tag push failed %d\n", vlan->vlan_id);
        return XDP_ABORTED;
    }
    return XDP_PASS;
}
</source>
</doc>
