<?xml version="1.0"?>
<doc>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/cpufreq.bpf.c" funcheader="int BPF_PROG (cpu_frequency, unsigned int state, unsigned int cpu_id)" startline="37" endline="48">
int BPF_PROG (cpu_frequency, unsigned int state, unsigned int cpu_id)
{
    if (filter_cg && !bpf_current_task_under_cgroup (&cgroup_map, 0))
        return 0;
    if (cpu_id >= MAX_CPU_NR)
        return 0;
    clamp_umax (cpu_id, MAX_CPU_NR - 1);
    freqs_mhz[cpu_id] = state / 1000;
    return 0;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/cpufreq.bpf.c" funcheader="int do_sample (struct bpf_perf_event_data *ctx)" startline="51" endline="83">
int do_sample (struct bpf_perf_event_data *ctx)
{
    u32 freq_mhz, pid = bpf_get_current_pid_tgid ();
    u64 slot, cpu = bpf_get_smp_processor_id ();
    struct hist *hist;
    struct hkey hkey;
    if (filter_cg && !bpf_current_task_under_cgroup (&cgroup_map, 0))
        return 0;
    if (cpu >= MAX_CPU_NR)
        return 0;
    clamp_umax (cpu, MAX_CPU_NR - 1);
    freq_mhz = freqs_mhz[cpu];
    if (!freq_mhz)
        return 0;
    slot = freq_mhz / HIST_STEP_SIZE;
    if (slot >= MAX_SLOTS)
        slot = MAX_SLOTS - 1;
    __sync_fetch_and_add (&syswide.slots[slot], 1);
    if (!pid)
        return 0;
    bpf_get_current_comm (&hkey.comm, sizeof (hkey.comm));
    hist = bpf_map_lookup_or_try_init (& hists, & hkey, & zero);
    if (!hist)
        return 0;
    __sync_fetch_and_add (&hist->slots[slot], 1);
    return 0;
}
</source>
</doc>
