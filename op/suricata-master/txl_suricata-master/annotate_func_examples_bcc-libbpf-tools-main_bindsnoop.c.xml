<?xml version="1.0"?>
<doc>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/bindsnoop.c" funcheader="static error_t parse_arg (int key, char *arg, struct argp_state *state)" startline="77" endline="128">
static error_t parse_arg (int key, char *arg, struct argp_state *state)
{
    long pid, port_num;
    char *port;
    switch (key) {
    case 'p' :
        errno = 0;
        pid = strtol (arg, NULL, 10);
        if (errno || pid <= 0) {
            warn ("Invalid PID: %s\n", arg);
            argp_usage (state);
        }
        target_pid = pid;
        break;
    case 'c' :
        env.cgroupspath = arg;
        env.cg = true;
        break;
    case 'P' :
        if (!arg) {
            warn ("No ports specified\n");
            argp_usage (state);
        }
        target_ports = strdup (arg);
        port = strtok (arg, ",");
        while (port) {
            port_num = strtol (port, NULL, 10);
            if (errno || port_num <= 0 || port_num > 65536) {
                warn ("Invalid ports: %s\n", arg);
                argp_usage (state);
            }
            port = strtok (NULL, ",");
        }
        break;
    case 'x' :
        ignore_errors = false;
        break;
    case 't' :
        emit_timestamp = true;
        break;
    case 'v' :
        verbose = true;
        break;
    case 'h' :
        argp_state_help (state, stderr, ARGP_HELP_STD_HELP);
        break;
    default :
        return ARGP_ERR_UNKNOWN;
    }
    return 0;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/bindsnoop.c" funcheader="static int libbpf_print_fn (enum libbpf_print_level level, const char *format, va_list args)" startline="130" endline="135">
static int libbpf_print_fn (enum libbpf_print_level level, const char *format, va_list args)
{
    if (level == LIBBPF_DEBUG && !verbose)
        return 0;
    return vfprintf (stderr, format, args);
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/bindsnoop.c" funcheader="static void sig_int (int signo)" startline="137" endline="140">
static void sig_int (int signo)
{
    exiting = 1;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/bindsnoop.c" funcheader="static void handle_event (void *ctx, int cpu, void *data, __u32 data_sz)" startline="142" endline="177">
static void handle_event (void *ctx, int cpu, void *data, __u32 data_sz)
{
    struct bind_event *e = data;
    time_t t;
    struct tm *tm;
    char ts [32], addr [48];
    char opts [] = {'F', 'T', 'N', 'R', 'r', '\0'};
    const char *proto;
    int i = 0;
    if (emit_timestamp) {
        time (&t);
        tm = localtime (& t);
        strftime (ts, sizeof (ts), "%H:%M:%S", tm);
        printf ("%8s ", ts);
    }
    if (e->proto == IPPROTO_TCP)
        proto = "TCP";
    else if (e->proto == IPPROTO_UDP)
        proto = "UDP";
    else
        proto = "UNK";
    while (opts[i]) {
        if (!((1 << i) & e->opts)) {
            opts[i] = '.';
        }
        i++;
    }
    if (e->ver == 4) {
        inet_ntop (AF_INET, &e->addr, addr, sizeof (addr));
    }
    else {
        inet_ntop (AF_INET6, &e->addr, addr, sizeof (addr));
    }
    printf ("%-7d %-16s %-3d %-5s %-5s %-4d %-5d %-48s\n", e->pid, e->task, e->ret, proto, opts, e->bound_dev_if, e->port, addr);
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/bindsnoop.c" funcheader="static void handle_lost_events (void *ctx, int cpu, __u64 lost_cnt)" startline="179" endline="182">
static void handle_lost_events (void *ctx, int cpu, __u64 lost_cnt)
{
    warn ("lost %llu events on CPU #%d\n", lost_cnt, cpu);
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/bindsnoop.c" funcheader="int main (int argc, char **argv)" startline="184" endline="298">
int main (int argc, char **argv)
{
    LIBBPF_OPTS (bpf_object_open_opts, open_opts);
    static const struct argp argp = {
        .options = opts,
        .parser = parse_arg,
        .doc = argp_program_doc,}
    ;
    struct perf_buffer *pb = NULL;
    struct bindsnoop_bpf *obj;
    int err, port_map_fd;
    char *port;
    short port_num;
    int idx, cg_map_fd;
    int cgfd = -1;
    err = argp_parse (& argp, argc, argv, 0, NULL, NULL);
    if (err)
        return err;
    libbpf_set_strict_mode (LIBBPF_STRICT_ALL);
    libbpf_set_print (libbpf_print_fn);
    err = ensure_core_btf (& open_opts);
    if (err) {
        fprintf (stderr, "failed to fetch necessary BTF for CO-RE: %s\n", strerror (-err));
        return 1;
    }
    obj = bindsnoop_bpf__open_opts (& open_opts);
    if (!obj) {
        warn ("failed to open BPF object\n");
        return 1;
    }
    obj->rodata->filter_cg = env.cg;
    obj->rodata->target_pid = target_pid;
    obj->rodata->ignore_errors = ignore_errors;
    obj->rodata->filter_by_port = target_ports != NULL;
    err = bindsnoop_bpf__load (obj);
    if (err) {
        warn ("failed to load BPF object: %d\n", err);
        goto cleanup;
    }
    if (env.cg) {
        idx = 0;
        cg_map_fd = bpf_map__fd (obj -> maps.cgroup_map);
        cgfd = open (env.cgroupspath, O_RDONLY);
        if (cgfd < 0) {
            fprintf (stderr, "Failed opening Cgroup path: %s", env.cgroupspath);
            goto cleanup;
        }
        if (bpf_map_update_elem (cg_map_fd, &idx, &cgfd, BPF_ANY)) {
            fprintf (stderr, "Failed adding target cgroup to map");
            goto cleanup;
        }
    }
    if (target_ports) {
        port_map_fd = bpf_map__fd (obj -> maps.ports);
        port = strtok (target_ports, ",");
        while (port) {
            port_num = strtol (port, NULL, 10);
            bpf_map_update_elem (port_map_fd, &port_num, &port_num, BPF_ANY);
            port = strtok (NULL, ",");
        }
    }
    err = bindsnoop_bpf__attach (obj);
    if (err) {
        warn ("failed to attach BPF programs: %d\n", err);
        goto cleanup;
    }
    pb = perf_buffer__new (bpf_map__fd (obj -> maps.events), PERF_BUFFER_PAGES, handle_event, handle_lost_events, NULL, NULL);
    if (!pb) {
        err = -errno;
        warn ("failed to open perf buffer: %d\n", err);
        goto cleanup;
    }
    if (signal (SIGINT, sig_int) == SIG_ERR) {
        warn ("can't set signal handler: %s\n", strerror (errno));
        err = 1;
        goto cleanup;
    }
    if (emit_timestamp)
        printf ("%-8s ", "TIME(s)");
    printf ("%-7s %-16s %-3s %-5s %-5s %-4s %-5s %-48s\n", "PID", "COMM", "RET", "PROTO", "OPTS", "IF", "PORT", "ADDR");
    while (!exiting) {
        err = perf_buffer__poll (pb, PERF_POLL_TIMEOUT_MS);
        if (err < 0 && err != -EINTR) {
            warn ("error polling perf buffer: %s\n", strerror (-err));
            goto cleanup;
        }
        err = 0;
    }
cleanup :
    perf_buffer__free (pb);
    bindsnoop_bpf__destroy (obj);
    cleanup_core_btf (&open_opts);
    if (cgfd > 0)
        close (cgfd);
    return err != 0;
}
</source>
</doc>
