<?xml version="1.0"?>
<doc>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/bitesize.bpf.c" funcheader="static __always_inline bool comm_allowed (const char *comm)" startline="26" endline="35">
static __always_inline bool comm_allowed (const char *comm)
{
    int i;
    for (i = 0; targ_comm[i] != '\0' && i < TASK_COMM_LEN; i++) {
        if (comm[i] != targ_comm[i])
            return false;
    }
    return true;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/bitesize.bpf.c" funcheader="static int trace_rq_issue (struct request *rq)" startline="37" endline="69">
static int trace_rq_issue (struct request *rq)
{
    struct hist_key hkey;
    struct hist *histp;
    u64 slot;
    if (filter_dev) {
        struct gendisk *disk = get_disk (rq);
        u32 dev;
        dev = disk ? MKDEV (BPF_CORE_READ (disk, major), BPF_CORE_READ (disk, first_minor)) : 0;
        if (targ_dev != dev)
            return 0;
    }
    bpf_get_current_comm (&hkey.comm, sizeof (hkey.comm));
    if (!comm_allowed (hkey.comm))
        return 0;
    histp = bpf_map_lookup_elem (& hists, & hkey);
    if (!histp) {
        bpf_map_update_elem (&hists, &hkey, &initial_hist, 0);
        histp = bpf_map_lookup_elem (& hists, & hkey);
        if (!histp)
            return 0;
    }
    slot = log2l (rq -> __data_len / 1024);
    if (slot >= MAX_SLOTS)
        slot = MAX_SLOTS - 1;
    __sync_fetch_and_add (&histp->slots[slot], 1);
    return 0;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/bitesize.bpf.c" funcheader="int BPF_PROG (block_rq_issue)" startline="72" endline="83">
int BPF_PROG (block_rq_issue)
{
    if (LINUX_KERNEL_VERSION >= KERNEL_VERSION (5, 11, 0))
        return trace_rq_issue ((void *) ctx[0]);
    else
        return trace_rq_issue ((void *) ctx[1]);
}
</source>
</doc>
