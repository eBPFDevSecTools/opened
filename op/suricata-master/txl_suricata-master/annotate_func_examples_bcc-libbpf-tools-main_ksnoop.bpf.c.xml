<?xml version="1.0"?>
<doc>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/ksnoop.bpf.c" funcheader="static void clear_trace (struct trace *trace)" startline="60" endline="65">
static void clear_trace (struct trace *trace)
{
    __builtin_memset (&trace->trace_data, 0, sizeof (trace->trace_data));
    trace->data_flags = 0;
    trace->buf_len = 0;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/ksnoop.bpf.c" funcheader="static struct trace *get_trace (struct pt_regs *ctx, bool entry)" startline="67" endline="197">
static struct trace *get_trace (struct pt_regs *ctx, bool entry)
{
    __u8 stack_depth, last_stack_depth;
    struct func_stack *func_stack;
    __u64 ip, last_ip = 0, task;
    struct trace *trace;
    task = bpf_get_current_task ();
    func_stack = bpf_map_lookup_elem (& ksnoop_func_stack, & task);
    if (!func_stack) {
        struct func_stack new_stack = {
            .task = task}
        ;
        bpf_map_update_elem (&ksnoop_func_stack, &task, &new_stack, BPF_NOEXIST);
        func_stack = bpf_map_lookup_elem (& ksnoop_func_stack, & task);
        if (!func_stack)
            return NULL;
    }
    stack_depth = func_stack->stack_depth;
    if (stack_depth > FUNC_MAX_STACK_DEPTH)
        return NULL;
    if (entry) {
        ip = KSNOOP_IP_FIX (PT_REGS_IP_CORE (ctx));
        if (stack_depth >= FUNC_MAX_STACK_DEPTH - 1)
            return NULL;
        last_stack_depth = stack_depth - 1;
        if (last_stack_depth >= 0 && last_stack_depth < FUNC_MAX_STACK_DEPTH)
            last_ip = func_stack->ips[last_stack_depth];
        func_stack->ips[stack_depth] = ip;
        stack_depth = (stack_depth + 1) & FUNC_STACK_DEPTH_MASK;
        func_stack->stack_depth = stack_depth;
        if (stack_depth < FUNC_MAX_STACK_DEPTH)
            func_stack->ips[stack_depth] = 0;
    }
    else {
        if (stack_depth == 0 || stack_depth >= FUNC_MAX_STACK_DEPTH)
            return NULL;
        last_stack_depth = stack_depth;
        if (last_stack_depth >= 0 && last_stack_depth < FUNC_MAX_STACK_DEPTH)
            last_ip = func_stack->ips[last_stack_depth];
        if (stack_depth > 0) {
            stack_depth = (stack_depth - 1) & FUNC_STACK_DEPTH_MASK;
        }
        if (stack_depth >= 0 && stack_depth < FUNC_MAX_STACK_DEPTH)
            ip = func_stack->ips[stack_depth];
        if (stack_depth >= 0 && stack_depth < FUNC_MAX_STACK_DEPTH)
            func_stack->stack_depth = stack_depth;
    }
    trace = bpf_map_lookup_elem (& ksnoop_func_map, & ip);
    if (!trace)
        return NULL;
    if (!entry && (trace->flags & KSNOOP_F_STASH)) {
        if (!(trace->data_flags & KSNOOP_F_STASHED)) {
            return NULL;
        }
    }
    else {
        clear_trace (trace);
    }
    if (entry) {
        if (trace->prev_ip && trace->prev_ip != last_ip)
            return NULL;
        if (trace->next_ip)
            trace->data_flags |= KSNOOP_F_STASH;
        if (trace->flags & KSNOOP_F_STASH)
            trace->data_flags |= KSNOOP_F_STASH;
    }
    else {
        if (trace->next_ip && trace->next_ip != last_ip)
            return NULL;
        if (trace->prev_ip)
            trace->data_flags |= KSNOOP_F_STASH;
    }
    trace->task = task;
    return trace;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/ksnoop.bpf.c" funcheader="static void output_trace (struct pt_regs *ctx, struct trace *trace)" startline="199" endline="225">
static void output_trace (struct pt_regs *ctx, struct trace *trace)
{
    __u16 trace_len;
    if (trace->buf_len == 0)
        goto skip;
    if (trace->data_flags & KSNOOP_F_STASH) {
        trace->data_flags &= ~KSNOOP_F_STASH;
        trace->data_flags |= KSNOOP_F_STASHED;
        return;
    }
    if (trace->data_flags & KSNOOP_F_STASHED)
        trace->data_flags &= ~KSNOOP_F_STASHED;
    trace_len = sizeof (*trace) + trace->buf_len - MAX_TRACE_BUF;
    if (trace_len <= sizeof (*trace))
        bpf_perf_event_output (ctx, &ksnoop_perf_map, BPF_F_CURRENT_CPU, trace, trace_len);
skip :
    clear_trace (trace);
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/ksnoop.bpf.c" funcheader="static void output_stashed_traces (struct pt_regs *ctx, struct trace *currtrace, bool entry)" startline="227" endline="278">
static void output_stashed_traces (struct pt_regs *ctx, struct trace *currtrace, bool entry)
{
    struct func_stack *func_stack;
    struct trace *trace = NULL;
    __u8 i;
    __u64 task = 0;
    task = bpf_get_current_task ();
    func_stack = bpf_map_lookup_elem (& ksnoop_func_stack, & task);
    if (!func_stack)
        return;
    if (entry) {
        for (i = 0; i < func_stack->stack_depth - 1 && i < FUNC_MAX_STACK_DEPTH; i++) {
            trace = bpf_map_lookup_elem (& ksnoop_func_map, & func_stack -> ips [i]);
            if (!trace || !(trace->data_flags & KSNOOP_F_STASHED))
                break;
            if (trace->task != task)
                return;
            output_trace (ctx, trace);
        }
    }
    else {
        for (i = FUNC_MAX_STACK_DEPTH; i > 0; i--) {
            __u64 ip;
            ip = func_stack->ips[i];
            if (!ip)
                continue;
            trace = bpf_map_lookup_elem (& ksnoop_func_map, & ip);
            if (!trace || !(trace->data_flags & KSNOOP_F_STASHED))
                break;
            if (trace->task != task)
                return;
            output_trace (ctx, trace);
        }
    }
    output_trace (ctx, currtrace);
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/ksnoop.bpf.c" funcheader="static __u64 get_arg (struct pt_regs *ctx, enum arg argnum)" startline="280" endline="298">
static __u64 get_arg (struct pt_regs *ctx, enum arg argnum)
{
    switch (argnum) {
    case KSNOOP_ARG1 :
        return PT_REGS_PARM1_CORE (ctx);
    case KSNOOP_ARG2 :
        return PT_REGS_PARM2_CORE (ctx);
    case KSNOOP_ARG3 :
        return PT_REGS_PARM3_CORE (ctx);
    case KSNOOP_ARG4 :
        return PT_REGS_PARM4_CORE (ctx);
    case KSNOOP_ARG5 :
        return PT_REGS_PARM5_CORE (ctx);
    case KSNOOP_RETURN :
        return PT_REGS_RC_CORE (ctx);
    default :
        return 0;
    }
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/ksnoop.bpf.c" funcheader="static int ksnoop (struct pt_regs *ctx, bool entry)" startline="300" endline="442">
static int ksnoop (struct pt_regs *ctx, bool entry)
{
    void *data_ptr = NULL;
    struct trace *trace;
    __u64 data;
    __u32 currpid;
    int ret;
    __u8 i;
    trace = get_trace (ctx, entry);
    if (!trace)
        return 0;
    currpid = bpf_get_current_pid_tgid ();
    if (trace->filter_pid && trace->filter_pid != currpid)
        return 0;
    trace->pid = currpid;
    trace->cpu = bpf_get_smp_processor_id ();
    trace->time = bpf_ktime_get_ns ();
    trace->data_flags &= ~(KSNOOP_F_ENTRY | KSNOOP_F_RETURN);
    if (entry)
        trace->data_flags |= KSNOOP_F_ENTRY;
    else
        trace->data_flags |= KSNOOP_F_RETURN;
    for (i = 0; i < MAX_TRACES; i++) {
        struct trace_data *currdata;
        struct value *currtrace;
        char *buf_offset = NULL;
        __u32 tracesize;
        currdata = &trace->trace_data[i];
        currtrace = &trace->traces[i];
        if ((entry && !base_arg_is_entry (currtrace->base_arg)) || (!entry && base_arg_is_entry (currtrace->base_arg)))
            continue;
        if (currtrace->type_id == 0 && !(currtrace->flags & KSNOOP_F_PTR))
            continue;
        data = get_arg (ctx, currtrace -> base_arg);
        if (currtrace->flags & KSNOOP_F_MEMBER) {
            if (currtrace->offset)
                data += currtrace->offset;
            if (currtrace->flags & KSNOOP_F_PTR) {
                void *dataptr = (void *) data;
                ret = bpf_probe_read_kernel (& data, sizeof (data), dataptr);
                if (ret) {
                    currdata->err_type_id = currtrace->type_id;
                    currdata->err = ret;
                    continue;
                }
                currdata->raw_value = data;
            }
            else if (currtrace->size <= sizeof (currdata->raw_value)) {
                bpf_probe_read_kernel (&currdata->raw_value, currtrace->size, (void *) data);
            }
        }
        else {
            currdata->raw_value = data;
        }
        if (currtrace->flags & KSNOOP_F_PREDICATE_MASK) {
            bool ok = false;
            if (currtrace->flags & KSNOOP_F_PREDICATE_EQ && currdata->raw_value == currtrace->predicate_value)
                ok = true;
            if (currtrace->flags & KSNOOP_F_PREDICATE_NOTEQ && currdata->raw_value != currtrace->predicate_value)
                ok = true;
            if (currtrace->flags & KSNOOP_F_PREDICATE_GT && currdata->raw_value > currtrace->predicate_value)
                ok = true;
            if (currtrace->flags & KSNOOP_F_PREDICATE_LT && currdata->raw_value < currtrace->predicate_value)
                ok = true;
            if (!ok) {
                clear_trace (trace);
                return 0;
            }
        }
        if (currtrace->flags & (KSNOOP_F_PTR | KSNOOP_F_MEMBER))
            data_ptr = (void *) data;
        else
            data_ptr = &data;
        if (trace->buf_len + MAX_TRACE_DATA >= MAX_TRACE_BUF)
            break;
        buf_offset = &trace->buf[trace->buf_len];
        if (buf_offset > &trace->buf[MAX_TRACE_BUF]) {
            currdata->err_type_id = currtrace->type_id;
            currdata->err = -ENOSPC;
            continue;
        }
        currdata->buf_offset = trace->buf_len;
        tracesize = currtrace->size;
        if (tracesize > MAX_TRACE_DATA)
            tracesize = MAX_TRACE_DATA;
        ret = bpf_probe_read_kernel (buf_offset, tracesize, data_ptr);
        if (ret < 0) {
            currdata->err_type_id = currtrace->type_id;
            currdata->err = ret;
            continue;
        }
        else {
            currdata->buf_len = tracesize;
            trace->buf_len += tracesize;
        }
    }
    if ((entry && trace->prev_ip && !trace->next_ip) || (!entry && trace->next_ip && !trace->prev_ip))
        output_stashed_traces (ctx, trace, entry);
    else
        output_trace (ctx, trace);
    return 0;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/ksnoop.bpf.c" funcheader="int BPF_KPROBE (kprobe_entry)" startline="445" endline="448">
int BPF_KPROBE (kprobe_entry)
{
    return ksnoop (ctx, true);
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/ksnoop.bpf.c" funcheader="int BPF_KRETPROBE (kprobe_return)" startline="451" endline="454">
int BPF_KRETPROBE (kprobe_return)
{
    return ksnoop (ctx, false);
}
</source>
</doc>
