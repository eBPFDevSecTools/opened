<?xml version="1.0"?>
<doc>
<source file="/home/sayandes/opened_extraction/examples/hxdp_xdp_progs/xdp_fw_kern.c" funcheader="static inline void biflow (struct flow_ctx_table_key *flow_key)" startline="27" endline="41">
static inline void biflow (struct flow_ctx_table_key *flow_key)
{
    u32 swap;
    if (flow_key->ip_src > flow_key->ip_dst) {
        swap = flow_key->ip_src;
        flow_key->ip_src = flow_key->ip_dst;
        flow_key->ip_dst = swap;
    }
    if (flow_key->l4_src > flow_key->l4_dst) {
        swap = flow_key->l4_src;
        flow_key->l4_src = flow_key->l4_dst;
        flow_key->l4_dst = swap;
    }
}
</source>
<source file="/home/sayandes/opened_extraction/examples/hxdp_xdp_progs/xdp_fw_kern.c" funcheader="int xdp_fw_prog (struct xdp_md *ctx)" startline="59" endline="162">
int xdp_fw_prog (struct xdp_md *ctx)
{
    void *data_end = (void *) (long) ctx->data_end;
    void *data = (void *) (long) ctx->data;
    struct flow_ctx_table_leaf new_flow = {0}
    ;
    struct flow_ctx_table_key flow_key = {0}
    ;
    struct flow_ctx_table_leaf *flow_leaf;
    struct ethhdr *ethernet;
    struct iphdr *ip;
    struct udphdr *l4;
    int ingress_ifindex;
    uint64_t nh_off = 0;
    u8 port_redirect = 0;
    int ret = XDP_PASS;
    u8 is_new_flow = 0;
    int vport = 0;
    bpf_debug ("I'm in the pipeline\n");
ethernet :
    {
        ethernet = data;
        nh_off = sizeof (*ethernet);
        if (data + nh_off > data_end)
            goto EOP;
        ingress_ifindex = ctx->ingress_ifindex;
        bpf_debug ("I'm eth\n");
        switch (ntohs (ethernet->h_proto)) {
        case ETH_P_IP :
            goto ip;
        default :
            goto EOP;
        }
    }
ip :
    {
        bpf_debug ("I'm ip\n");
        ip = data + nh_off;
        nh_off += sizeof (*ip);
        if (data + nh_off > data_end)
            goto EOP;
        switch (ip->protocol) {
        case IPPROTO_TCP :
            goto l4;
        case IPPROTO_UDP :
            goto l4;
        default :
            goto EOP;
        }
    }
l4 :
    {
        bpf_debug ("I'm l4\n");
        l4 = data + nh_off;
        nh_off += sizeof (*l4);
        if (data + nh_off > data_end)
            goto EOP;
    }
    bpf_debug ("extracting flow key ... \n");
    flow_key.ip_proto = ip->protocol;
    flow_key.ip_src = ip->saddr;
    flow_key.ip_dst = ip->daddr;
    flow_key.l4_src = l4->source;
    flow_key.l4_dst = l4->dest;
    biflow (&flow_key);
    if (ingress_ifindex == B_PORT) {
        flow_leaf = bpf_map_lookup_elem (& flow_ctx_table, & flow_key);
        if (flow_leaf)
            return bpf_redirect_map (&tx_port, flow_leaf->out_port, 0);
        else
            return XDP_DROP;
    }
    else {
        flow_leaf = bpf_map_lookup_elem (& flow_ctx_table, & flow_key);
        if (!flow_leaf) {
            new_flow.in_port = B_PORT;
            new_flow.out_port = A_PORT;
            bpf_map_update_elem (&flow_ctx_table, &flow_key, &new_flow, BPF_ANY);
        }
        return bpf_redirect_map (&tx_port, B_PORT, 0);
    }
EOP :
    return XDP_DROP;
}
</source>
</doc>
