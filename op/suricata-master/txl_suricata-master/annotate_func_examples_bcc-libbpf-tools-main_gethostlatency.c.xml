<?xml version="1.0"?>
<doc>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/gethostlatency.c" funcheader="static error_t parse_arg (int key, char *arg, struct argp_state *state)" startline="55" endline="86">
static error_t parse_arg (int key, char *arg, struct argp_state *state)
{
    long pid;
    switch (key) {
    case 'p' :
        errno = 0;
        pid = strtol (arg, NULL, 10);
        if (errno || pid <= 0) {
            warn ("Invalid PID: %s\n", arg);
            argp_usage (state);
        }
        target_pid = pid;
        break;
    case 'l' :
        libc_path = strdup (arg);
        if (access (libc_path, F_OK)) {
            warn ("Invalid libc: %s\n", arg);
            argp_usage (state);
        }
        break;
    case 'v' :
        verbose = true;
        break;
    case 'h' :
        argp_state_help (state, stderr, ARGP_HELP_STD_HELP);
        break;
    default :
        return ARGP_ERR_UNKNOWN;
    }
    return 0;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/gethostlatency.c" funcheader="static int libbpf_print_fn (enum libbpf_print_level level, const char *format, va_list args)" startline="88" endline="93">
static int libbpf_print_fn (enum libbpf_print_level level, const char *format, va_list args)
{
    if (level == LIBBPF_DEBUG && !verbose)
        return 0;
    return vfprintf (stderr, format, args);
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/gethostlatency.c" funcheader="static void sig_int (int signo)" startline="95" endline="98">
static void sig_int (int signo)
{
    exiting = 1;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/gethostlatency.c" funcheader="static void handle_event (void *ctx, int cpu, void *data, __u32 data_sz)" startline="100" endline="112">
static void handle_event (void *ctx, int cpu, void *data, __u32 data_sz)
{
    const struct event *e = data;
    struct tm *tm;
    char ts [16];
    time_t t;
    time (&t);
    tm = localtime (& t);
    strftime (ts, sizeof (ts), "%H:%M:%S", tm);
    printf ("%-8s %-7d %-16s %-10.3f %-s\n", ts, e->pid, e->comm, (double) e->time / 1000000, e->host);
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/gethostlatency.c" funcheader="static void handle_lost_events (void *ctx, int cpu, __u64 lost_cnt)" startline="114" endline="117">
static void handle_lost_events (void *ctx, int cpu, __u64 lost_cnt)
{
    warn ("lost %llu events on CPU #%d\n", lost_cnt, cpu);
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/gethostlatency.c" funcheader="static int get_libc_path (char *path)" startline="119" endline="149">
static int get_libc_path (char *path)
{
    FILE *f;
    char buf [PATH_MAX] = {};
    char *filename;
    float version;
    if (libc_path) {
        memcpy (path, libc_path, strlen (libc_path));
        return 0;
    }
    f = fopen ("/proc/self/maps", "r");
    if (!f)
        return -errno;
    while (fscanf (f, "%*x-%*x %*s %*s %*s %*s %[^\n]\n", buf) != EOF) {
        if (strchr (buf, '/') != buf)
            continue;
        filename = strrchr (buf, '/') + 1;
        if (sscanf (filename, "libc-%f.so", &version) == 1 || sscanf (filename, "libc.so.%f", &version) == 1) {
            memcpy (path, buf, strlen (buf));
            fclose (f);
            return 0;
        }
    }
    fclose (f);
    return -1;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/gethostlatency.c" funcheader="static int attach_uprobes (struct gethostlatency_bpf *obj, struct bpf_link *links [])" startline="151" endline="218">
static int attach_uprobes (struct gethostlatency_bpf *obj, struct bpf_link *links [])
{
    int err;
    char libc_path [PATH_MAX] = {};
    off_t func_off;
    err = get_libc_path (libc_path);
    if (err) {
        warn ("could not find libc.so\n");
        return -1;
    }
    func_off = get_elf_func_offset (libc_path, "getaddrinfo");
    if (func_off < 0) {
        warn ("could not find getaddrinfo in %s\n", libc_path);
        return -1;
    }
    links[0] = bpf_program__attach_uprobe (obj->progs.handle_entry, false, target_pid ? : -1, libc_path, func_off);
    if (!links[0]) {
        warn ("failed to attach getaddrinfo: %d\n", -errno);
        return -1;
    }
    links[1] = bpf_program__attach_uprobe (obj->progs.handle_return, true, target_pid ? : -1, libc_path, func_off);
    if (!links[1]) {
        warn ("failed to attach getaddrinfo: %d\n", -errno);
        return -1;
    }
    func_off = get_elf_func_offset (libc_path, "gethostbyname");
    if (func_off < 0) {
        warn ("could not find gethostbyname in %s\n", libc_path);
        return -1;
    }
    links[2] = bpf_program__attach_uprobe (obj->progs.handle_entry, false, target_pid ? : -1, libc_path, func_off);
    if (!links[2]) {
        warn ("failed to attach gethostbyname: %d\n", -errno);
        return -1;
    }
    links[3] = bpf_program__attach_uprobe (obj->progs.handle_return, true, target_pid ? : -1, libc_path, func_off);
    if (!links[3]) {
        warn ("failed to attach gethostbyname: %d\n", -errno);
        return -1;
    }
    func_off = get_elf_func_offset (libc_path, "gethostbyname2");
    if (func_off < 0) {
        warn ("could not find gethostbyname2 in %s\n", libc_path);
        return -1;
    }
    links[4] = bpf_program__attach_uprobe (obj->progs.handle_entry, false, target_pid ? : -1, libc_path, func_off);
    if (!links[4]) {
        warn ("failed to attach gethostbyname2: %d\n", -errno);
        return -1;
    }
    links[5] = bpf_program__attach_uprobe (obj->progs.handle_return, true, target_pid ? : -1, libc_path, func_off);
    if (!links[5]) {
        warn ("failed to attach gethostbyname2: %d\n", -errno);
        return -1;
    }
    return 0;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/gethostlatency.c" funcheader="int main (int argc, char **argv)" startline="220" endline="299">
int main (int argc, char **argv)
{
    LIBBPF_OPTS (bpf_object_open_opts, open_opts);
    static const struct argp argp = {
        .options = opts,
        .parser = parse_arg,
        .doc = argp_program_doc,}
    ;
    struct perf_buffer *pb = NULL;
    struct bpf_link *links [6] = {};
    struct gethostlatency_bpf *obj;
    int i, err;
    err = argp_parse (& argp, argc, argv, 0, NULL, NULL);
    if (err)
        return err;
    libbpf_set_strict_mode (LIBBPF_STRICT_ALL);
    libbpf_set_print (libbpf_print_fn);
    err = ensure_core_btf (& open_opts);
    if (err) {
        fprintf (stderr, "failed to fetch necessary BTF for CO-RE: %s\n", strerror (-err));
        return 1;
    }
    obj = gethostlatency_bpf__open_opts (& open_opts);
    if (!obj) {
        warn ("failed to open BPF object\n");
        return 1;
    }
    obj->rodata->target_pid = target_pid;
    err = gethostlatency_bpf__load (obj);
    if (err) {
        warn ("failed to load BPF object: %d\n", err);
        goto cleanup;
    }
    err = attach_uprobes (obj, links);
    if (err)
        goto cleanup;
    pb = perf_buffer__new (bpf_map__fd (obj -> maps.events), PERF_BUFFER_PAGES, handle_event, handle_lost_events, NULL, NULL);
    if (!pb) {
        err = -errno;
        warn ("failed to open perf buffer: %d\n", err);
        goto cleanup;
    }
    if (signal (SIGINT, sig_int) == SIG_ERR) {
        warn ("can't set signal handler: %s\n", strerror (errno));
        err = 1;
        goto cleanup;
    }
    printf ("%-8s %-7s %-16s %-10s %-s\n", "TIME", "PID", "COMM", "LATms", "HOST");
    while (!exiting) {
        err = perf_buffer__poll (pb, PERF_POLL_TIMEOUT_MS);
        if (err < 0 && err != -EINTR) {
            warn ("error polling perf buffer: %s\n", strerror (-err));
            goto cleanup;
        }
        err = 0;
    }
cleanup :
    perf_buffer__free (pb);
    for (i = 0; i < 6; i++)
        bpf_link__destroy (links[i]);
    gethostlatency_bpf__destroy (obj);
    cleanup_core_btf (&open_opts);
    return err != 0;
}
</source>
</doc>
