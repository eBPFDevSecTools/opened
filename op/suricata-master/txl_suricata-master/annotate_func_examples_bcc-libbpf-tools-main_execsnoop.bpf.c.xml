<?xml version="1.0"?>
<doc>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/execsnoop.bpf.c" funcheader="static __always_inline bool valid_uid (uid_t uid)" startline="34" endline="36">
static __always_inline bool valid_uid (uid_t uid)
{
    return uid != INVALID_UID;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/execsnoop.bpf.c" funcheader="int tracepoint__syscalls__sys_enter_execve (struct trace_event_raw_sys_enter *ctx)" startline="39" endline="109">
int tracepoint__syscalls__sys_enter_execve (struct trace_event_raw_sys_enter *ctx)
{
    u64 id;
    pid_t pid, tgid;
    unsigned int ret;
    struct event *event;
    struct task_struct *task;
    const char **args = (const char **) (ctx->args[1]);
    const char *argp;
    if (filter_cg && !bpf_current_task_under_cgroup (&cgroup_map, 0))
        return 0;
    uid_t uid = (u32) bpf_get_current_uid_gid ();
    int i;
    if (valid_uid (targ_uid) && targ_uid != uid)
        return 0;
    id = bpf_get_current_pid_tgid ();
    pid = (pid_t) id;
    tgid = id >> 32;
    if (bpf_map_update_elem (&execs, &pid, &empty_event, BPF_NOEXIST))
        return 0;
    event = bpf_map_lookup_elem (& execs, & pid);
    if (!event)
        return 0;
    event->pid = tgid;
    event->uid = uid;
    task = (struct task_struct *) bpf_get_current_task ();
    event->ppid = (pid_t) BPF_CORE_READ (task, real_parent, tgid);
    event->args_count = 0;
    event->args_size = 0;
    ret = bpf_probe_read_user_str (event -> args, ARGSIZE, (const char *) ctx -> args [0]);
    if (ret <= ARGSIZE) {
        event->args_size += ret;
    }
    else {
        event->args[0] = '\0';
        event->args_size++;
    }
    event->args_count++;

#pragma unroll
    for (i = 1; i < TOTAL_MAX_ARGS && i < max_args; i++) {
        bpf_probe_read_user (&argp, sizeof (argp), &args[i]);
        if (!argp)
            return 0;
        if (event->args_size > LAST_ARG)
            return 0;
        ret = bpf_probe_read_user_str (& event -> args [event -> args_size], ARGSIZE, argp);
        if (ret > ARGSIZE)
            return 0;
        event->args_count++;
        event->args_size += ret;
    }
    bpf_probe_read_user (&argp, sizeof (argp), &args[max_args]);
    if (!argp)
        return 0;
    event->args_count++;
    return 0;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/execsnoop.bpf.c" funcheader="int tracepoint__syscalls__sys_exit_execve (struct trace_event_raw_sys_exit *ctx)" startline="112" endline="143">
int tracepoint__syscalls__sys_exit_execve (struct trace_event_raw_sys_exit *ctx)
{
    u64 id;
    pid_t pid;
    int ret;
    struct event *event;
    if (filter_cg && !bpf_current_task_under_cgroup (&cgroup_map, 0))
        return 0;
    u32 uid = (u32) bpf_get_current_uid_gid ();
    if (valid_uid (targ_uid) && targ_uid != uid)
        return 0;
    id = bpf_get_current_pid_tgid ();
    pid = (pid_t) id;
    event = bpf_map_lookup_elem (& execs, & pid);
    if (!event)
        return 0;
    ret = ctx->ret;
    if (ignore_failed && ret < 0)
        goto cleanup;
    event->retval = ret;
    bpf_get_current_comm (&event->comm, sizeof (event->comm));
    size_t len = EVENT_SIZE (event);
    if (len <= sizeof (*event))
        bpf_perf_event_output (ctx, &events, BPF_F_CURRENT_CPU, event, len);
cleanup :
    bpf_map_delete_elem (&execs, &pid);
    return 0;
}
</source>
</doc>
