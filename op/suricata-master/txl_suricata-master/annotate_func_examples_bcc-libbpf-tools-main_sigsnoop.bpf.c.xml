<?xml version="1.0"?>
<doc>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/sigsnoop.bpf.c" funcheader="static int probe_entry (pid_t tpid, int sig)" startline="26" endline="47">
static int probe_entry (pid_t tpid, int sig)
{
    struct event event = {}
    ;
    __u64 pid_tgid;
    __u32 pid, tid;
    if (target_signal && sig != target_signal)
        return 0;
    pid_tgid = bpf_get_current_pid_tgid ();
    pid = pid_tgid >> 32;
    tid = (__u32) pid_tgid;
    if (filtered_pid && pid != filtered_pid)
        return 0;
    event.pid = pid;
    event.tpid = tpid;
    event.sig = sig;
    bpf_get_current_comm (event.comm, sizeof (event.comm));
    bpf_map_update_elem (&values, &tid, &event, BPF_ANY);
    return 0;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/sigsnoop.bpf.c" funcheader="static int probe_exit (void *ctx, int ret)" startline="49" endline="68">
static int probe_exit (void *ctx, int ret)
{
    __u64 pid_tgid = bpf_get_current_pid_tgid ();
    __u32 tid = (__u32) pid_tgid;
    struct event *eventp;
    eventp = bpf_map_lookup_elem (& values, & tid);
    if (!eventp)
        return 0;
    if (failed_only && ret >= 0)
        goto cleanup;
    eventp->ret = ret;
    bpf_perf_event_output (ctx, &events, BPF_F_CURRENT_CPU, eventp, sizeof (*eventp));
cleanup :
    bpf_map_delete_elem (&values, &tid);
    return 0;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/sigsnoop.bpf.c" funcheader="int kill_entry (struct trace_event_raw_sys_enter *ctx)" startline="71" endline="77">
int kill_entry (struct trace_event_raw_sys_enter *ctx)
{
    pid_t tpid = (pid_t) ctx->args[0];
    int sig = (int) ctx->args[1];
    return probe_entry (tpid, sig);
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/sigsnoop.bpf.c" funcheader="int kill_exit (struct trace_event_raw_sys_exit *ctx)" startline="80" endline="83">
int kill_exit (struct trace_event_raw_sys_exit *ctx)
{
    return probe_exit (ctx, ctx->ret);
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/sigsnoop.bpf.c" funcheader="int tkill_entry (struct trace_event_raw_sys_enter *ctx)" startline="86" endline="92">
int tkill_entry (struct trace_event_raw_sys_enter *ctx)
{
    pid_t tpid = (pid_t) ctx->args[0];
    int sig = (int) ctx->args[1];
    return probe_entry (tpid, sig);
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/sigsnoop.bpf.c" funcheader="int tkill_exit (struct trace_event_raw_sys_exit *ctx)" startline="95" endline="98">
int tkill_exit (struct trace_event_raw_sys_exit *ctx)
{
    return probe_exit (ctx, ctx->ret);
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/sigsnoop.bpf.c" funcheader="int tgkill_entry (struct trace_event_raw_sys_enter *ctx)" startline="101" endline="107">
int tgkill_entry (struct trace_event_raw_sys_enter *ctx)
{
    pid_t tpid = (pid_t) ctx->args[1];
    int sig = (int) ctx->args[2];
    return probe_entry (tpid, sig);
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/sigsnoop.bpf.c" funcheader="int tgkill_exit (struct trace_event_raw_sys_exit *ctx)" startline="110" endline="113">
int tgkill_exit (struct trace_event_raw_sys_exit *ctx)
{
    return probe_exit (ctx, ctx->ret);
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/sigsnoop.bpf.c" funcheader="int sig_trace (struct trace_event_raw_signal_generate *ctx)" startline="116" endline="143">
int sig_trace (struct trace_event_raw_signal_generate *ctx)
{
    struct event event = {}
    ;
    pid_t tpid = ctx->pid;
    int ret = ctx->errno;
    int sig = ctx->sig;
    __u64 pid_tgid;
    __u32 pid;
    if (failed_only && ret == 0)
        return 0;
    if (target_signal && sig != target_signal)
        return 0;
    pid_tgid = bpf_get_current_pid_tgid ();
    pid = pid_tgid >> 32;
    if (filtered_pid && pid != filtered_pid)
        return 0;
    event.pid = pid;
    event.tpid = tpid;
    event.sig = sig;
    event.ret = ret;
    bpf_get_current_comm (event.comm, sizeof (event.comm));
    bpf_perf_event_output (ctx, &events, BPF_F_CURRENT_CPU, &event, sizeof (event));
    return 0;
}
</source>
</doc>
