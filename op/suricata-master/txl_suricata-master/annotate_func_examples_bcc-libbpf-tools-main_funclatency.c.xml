<?xml version="1.0"?>
<doc>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/funclatency.c" funcheader="static error_t parse_arg (int key, char *arg, struct argp_state *state)" startline="89" endline="171">
static error_t parse_arg (int key, char *arg, struct argp_state *state)
{
    struct prog_env *env = state->input;
    long duration, interval, pid;
    switch (key) {
    case 'p' :
        errno = 0;
        pid = strtol (arg, NULL, 10);
        if (errno || pid <= 0) {
            warn ("Invalid PID: %s\n", arg);
            argp_usage (state);
        }
        env->pid = pid;
        break;
    case 'm' :
        if (env->units != NSEC) {
            warn ("only set one of -m or -u\n");
            argp_usage (state);
        }
        env->units = MSEC;
        break;
    case 'c' :
        env->cgroupspath = arg;
        env->cg = true;
        break;
    case 'u' :
        if (env->units != NSEC) {
            warn ("only set one of -m or -u\n");
            argp_usage (state);
        }
        env->units = USEC;
        break;
    case 'd' :
        errno = 0;
        duration = strtol (arg, NULL, 10);
        if (errno || duration <= 0) {
            warn ("Invalid duration: %s\n", arg);
            argp_usage (state);
        }
        env->duration = duration;
        break;
    case 'i' :
        errno = 0;
        interval = strtol (arg, NULL, 10);
        if (errno || interval <= 0) {
            warn ("Invalid interval: %s\n", arg);
            argp_usage (state);
        }
        env->interval = interval;
        break;
    case 'T' :
        env->timestamp = true;
        break;
    case 'v' :
        env->verbose = true;
        break;
    case 'h' :
        argp_state_help (state, stderr, ARGP_HELP_STD_HELP);
        break;
    case ARGP_KEY_ARG :
        if (env->funcname) {
            warn ("Too many function names: %s\n", arg);
            argp_usage (state);
        }
        env->funcname = arg;
        break;
    case ARGP_KEY_END :
        if (!env->funcname) {
            warn ("Need a function to trace\n");
            argp_usage (state);
        }
        if (env->duration) {
            if (env->interval > env->duration)
                env->interval = env->duration;
            env->iterations = env->duration / env->interval;
        }
        break;
    default :
        return ARGP_ERR_UNKNOWN;
    }
    return 0;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/funclatency.c" funcheader="static int libbpf_print_fn (enum libbpf_print_level level, const char *format, va_list args)" startline="173" endline="178">
static int libbpf_print_fn (enum libbpf_print_level level, const char *format, va_list args)
{
    if (level == LIBBPF_DEBUG && !env.verbose)
        return 0;
    return vfprintf (stderr, format, args);
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/funclatency.c" funcheader="static const char *unit_str (void)" startline="180" endline="192">
static const char *unit_str (void)
{
    switch (env.units) {
    case NSEC :
        return "nsec";
    case USEC :
        return "usec";
    case MSEC :
        return "msec";
    }
    return "bad units";
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/funclatency.c" funcheader="static int attach_kprobes (struct funclatency_bpf *obj)" startline="194" endline="215">
static int attach_kprobes (struct funclatency_bpf *obj)
{
    long err;
    obj->links.dummy_kprobe = bpf_program__attach_kprobe (obj->progs.dummy_kprobe, false, env.funcname);
    if (!obj->links.dummy_kprobe) {
        err = -errno;
        warn ("failed to attach kprobe: %ld\n", err);
        return -1;
    }
    obj->links.dummy_kretprobe = bpf_program__attach_kprobe (obj->progs.dummy_kretprobe, true, env.funcname);
    if (!obj->links.dummy_kretprobe) {
        err = -errno;
        warn ("failed to attach kretprobe: %ld\n", err);
        return -1;
    }
    return 0;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/funclatency.c" funcheader="static int attach_uprobes (struct funclatency_bpf *obj)" startline="217" endline="271">
static int attach_uprobes (struct funclatency_bpf *obj)
{
    char *binary, *function;
    char bin_path [PATH_MAX];
    off_t func_off;
    int ret = -1;
    long err;
    binary = strdup (env.funcname);
    if (!binary) {
        warn ("strdup failed");
        return -1;
    }
    function = strchr (binary, ':');
    if (!function) {
        warn ("Binary should have contained ':' (internal bug!)\n");
        return -1;
    }
    *function = '\0';
    function++;
    if (resolve_binary_path (binary, env.pid, bin_path, sizeof (bin_path)))
        goto out_binary;
    func_off = get_elf_func_offset (bin_path, function);
    if (func_off < 0) {
        warn ("Could not find %s in %s\n", function, bin_path);
        goto out_binary;
    }
    obj->links.dummy_kprobe = bpf_program__attach_uprobe (obj->progs.dummy_kprobe, false, env.pid ? : -1, bin_path, func_off);
    if (!obj->links.dummy_kprobe) {
        err = -errno;
        warn ("Failed to attach uprobe: %ld\n", err);
        goto out_binary;
    }
    obj->links.dummy_kretprobe = bpf_program__attach_uprobe (obj->progs.dummy_kretprobe, true, env.pid ? : -1, bin_path, func_off);
    if (!obj->links.dummy_kretprobe) {
        err = -errno;
        warn ("Failed to attach uretprobe: %ld\n", err);
        goto out_binary;
    }
    ret = 0;
out_binary :
    free (binary);
    return ret;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/funclatency.c" funcheader="static int attach_probes (struct funclatency_bpf *obj)" startline="273" endline="278">
static int attach_probes (struct funclatency_bpf *obj)
{
    if (strchr (env.funcname, ':'))
        return attach_uprobes (obj);
    return attach_kprobes (obj);
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/funclatency.c" funcheader="static void sig_hand (int signr)" startline="282" endline="285">
static void sig_hand (int signr)
{
    exiting = true;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/funclatency.c" funcheader="int main (int argc, char **argv)" startline="289" endline="386">
int main (int argc, char **argv)
{
    LIBBPF_OPTS (bpf_object_open_opts, open_opts);
    static const struct argp argp = {
        .options = opts,
        .parser = parse_arg,
        .args_doc = args_doc,
        .doc = program_doc,}
    ;
    struct funclatency_bpf *obj;
    int i, err;
    struct tm *tm;
    char ts [32];
    time_t t;
    int idx, cg_map_fd;
    int cgfd = -1;
    err = argp_parse (& argp, argc, argv, 0, NULL, & env);
    if (err)
        return err;
    sigaction (SIGINT, &sigact, 0);
    libbpf_set_strict_mode (LIBBPF_STRICT_ALL);
    libbpf_set_print (libbpf_print_fn);
    err = ensure_core_btf (& open_opts);
    if (err) {
        fprintf (stderr, "failed to fetch necessary BTF for CO-RE: %s\n", strerror (-err));
        return 1;
    }
    obj = funclatency_bpf__open_opts (& open_opts);
    if (!obj) {
        warn ("failed to open BPF object\n");
        return 1;
    }
    obj->rodata->units = env.units;
    obj->rodata->targ_tgid = env.pid;
    obj->rodata->filter_cg = env.cg;
    err = funclatency_bpf__load (obj);
    if (err) {
        warn ("failed to load BPF object\n");
        return 1;
    }
    if (env.cg) {
        idx = 0;
        cg_map_fd = bpf_map__fd (obj -> maps.cgroup_map);
        cgfd = open (env.cgroupspath, O_RDONLY);
        if (cgfd < 0) {
            fprintf (stderr, "Failed opening Cgroup path: %s", env.cgroupspath);
            goto cleanup;
        }
        if (bpf_map_update_elem (cg_map_fd, &idx, &cgfd, BPF_ANY)) {
            fprintf (stderr, "Failed adding target cgroup to map");
            goto cleanup;
        }
    }
    if (!obj->bss) {
        warn ("Memory-mapping BPF maps is supported starting from Linux 5.7, please upgrade.\n");
        goto cleanup;
    }
    err = attach_probes (obj);
    if (err)
        goto cleanup;
    printf ("Tracing %s.  Hit Ctrl-C to exit\n", env.funcname);
    for (i = 0; i < env.iterations && !exiting; i++) {
        sleep (env.interval);
        printf ("\n");
        if (env.timestamp) {
            time (&t);
            tm = localtime (& t);
            strftime (ts, sizeof (ts), "%H:%M:%S", tm);
            printf ("%-8s\n", ts);
        }
        print_log2_hist (obj->bss->hist, MAX_SLOTS, unit_str ());
    }
    printf ("Exiting trace of %s\n", env.funcname);
cleanup :
    funclatency_bpf__destroy (obj);
    cleanup_core_btf (&open_opts);
    if (cgfd > 0)
        close (cgfd);
    return err != 0;
}
</source>
</doc>
