<?xml version="1.0"?>
<doc>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/biostacks.bpf.c" funcheader="static __always_inline int trace_start (void *ctx, struct request *rq, bool merge_bio)" startline="39" endline="68">
static __always_inline int trace_start (void *ctx, struct request *rq, bool merge_bio)
{
    struct internal_rqinfo *i_rqinfop = NULL, i_rqinfo = {};
    struct gendisk *disk = get_disk (rq);
    u32 dev;
    dev = disk ? MKDEV (BPF_CORE_READ (disk, major), BPF_CORE_READ (disk, first_minor)) : 0;
    if (filter_dev && targ_dev != dev)
        return 0;
    if (merge_bio)
        i_rqinfop = bpf_map_lookup_elem (&rqinfos, &rq);
    if (!i_rqinfop)
        i_rqinfop = &i_rqinfo;
    i_rqinfop->start_ts = bpf_ktime_get_ns ();
    i_rqinfop->rqinfo.pid = bpf_get_current_pid_tgid ();
    i_rqinfop->rqinfo.kern_stack_size = bpf_get_stack (ctx, i_rqinfop->rqinfo.kern_stack, sizeof (i_rqinfop->rqinfo.kern_stack), 0);
    bpf_get_current_comm (&i_rqinfop->rqinfo.comm, sizeof (&i_rqinfop->rqinfo.comm));
    i_rqinfop->rqinfo.dev = dev;
    if (i_rqinfop == &i_rqinfo)
        bpf_map_update_elem (&rqinfos, &rq, i_rqinfop, 0);
    return 0;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/biostacks.bpf.c" funcheader="int BPF_PROG (blk_account_io_start, struct request *rq)" startline="71" endline="74">
int BPF_PROG (blk_account_io_start, struct request *rq)
{
    return trace_start (ctx, rq, false);
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/biostacks.bpf.c" funcheader="int BPF_KPROBE (blk_account_io_merge_bio, struct request *rq)" startline="77" endline="80">
int BPF_KPROBE (blk_account_io_merge_bio, struct request *rq)
{
    return trace_start (ctx, rq, true);
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/biostacks.bpf.c" funcheader="int BPF_PROG (blk_account_io_done, struct request *rq)" startline="83" endline="111">
int BPF_PROG (blk_account_io_done, struct request *rq)
{
    u64 slot, ts = bpf_ktime_get_ns ();
    struct internal_rqinfo *i_rqinfop;
    struct hist *histp;
    s64 delta;
    i_rqinfop = bpf_map_lookup_elem (& rqinfos, & rq);
    if (!i_rqinfop)
        return 0;
    delta = (s64) (ts - i_rqinfop->start_ts);
    if (delta < 0)
        goto cleanup;
    histp = bpf_map_lookup_or_try_init (& hists, & i_rqinfop -> rqinfo, & zero);
    if (!histp)
        goto cleanup;
    if (targ_ms)
        delta /= 1000000U;
    else
        delta /= 1000U;
    slot = log2l (delta);
    if (slot >= MAX_SLOTS)
        slot = MAX_SLOTS - 1;
    __sync_fetch_and_add (&histp->slots[slot], 1);
cleanup :
    bpf_map_delete_elem (&rqinfos, &rq);
    return 0;
}
</source>
</doc>
