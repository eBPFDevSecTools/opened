<?xml version="1.0"?>
<doc>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/opensnoop.c" funcheader="static error_t parse_arg (int key, char *arg, struct argp_state *state)" startline="107" endline="188">
static error_t parse_arg (int key, char *arg, struct argp_state *state)
{
    static int pos_args;
    long int pid, uid, duration;
    switch (key) {
    case 'e' :
        env.extended = true;
        break;
    case 'h' :
        argp_usage (state);
        break;
    case 'T' :
        env.timestamp = true;
        break;
    case 'U' :
        env.print_uid = true;
        break;
    case 'v' :
        env.verbose = true;
        break;
    case 'x' :
        env.failed = true;
        break;
    case 'd' :
        errno = 0;
        duration = strtol (arg, NULL, 10);
        if (errno || duration <= 0) {
            fprintf (stderr, "Invalid duration: %s\n", arg);
            argp_usage (state);
        }
        env.duration = duration;
        break;
    case 'n' :
        errno = 0;
        env.name = arg;
        break;
    case 'p' :
        errno = 0;
        pid = strtol (arg, NULL, 10);
        if (errno || pid <= 0) {
            fprintf (stderr, "Invalid PID: %s\n", arg);
            argp_usage (state);
        }
        env.pid = pid;
        break;
    case 't' :
        errno = 0;
        pid = strtol (arg, NULL, 10);
        if (errno || pid <= 0) {
            fprintf (stderr, "Invalid TID: %s\n", arg);
            argp_usage (state);
        }
        env.tid = pid;
        break;
    case 'u' :
        errno = 0;
        uid = strtol (arg, NULL, 10);
        if (errno || uid < 0 || uid >= INVALID_UID) {
            fprintf (stderr, "Invalid UID %s\n", arg);
            argp_usage (state);
        }
        env.uid = uid;
        break;

#ifdef USE_BLAZESYM
    case 'c' :
        env.callers = true;
        break;

#endif
    case ARGP_KEY_ARG :
        if (pos_args++) {
            fprintf (stderr, "Unrecognized positional argument: %s\n", arg);
            argp_usage (state);
        }
        errno = 0;
        break;
    default :
        return ARGP_ERR_UNKNOWN;
    }
    return 0;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/opensnoop.c" funcheader="static int libbpf_print_fn (enum libbpf_print_level level, const char *format, va_list args)" startline="190" endline="195">
static int libbpf_print_fn (enum libbpf_print_level level, const char *format, va_list args)
{
    if (level == LIBBPF_DEBUG && !env.verbose)
        return 0;
    return vfprintf (stderr, format, args);
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/opensnoop.c" funcheader="static void sig_int (int signo)" startline="197" endline="200">
static void sig_int (int signo)
{
    exiting = 1;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/opensnoop.c" funcheader="void handle_event (void *ctx, int cpu, void *data, __u32 data_sz)" startline="202" endline="274">
void handle_event (void *ctx, int cpu, void *data, __u32 data_sz)
{
    const struct event *e = data;
    struct tm *tm;

#ifdef USE_BLAZESYM
    sym_src_cfg cfgs [] = {
        {
            .src_type = SRC_T_PROCESS,
            .params = {
                .process = {
                    .pid = e->pid}}},};
    const blazesym_result *result = NULL;
    const blazesym_csym *sym;
    int i, j;

#endif
    int sps_cnt;
    char ts [32];
    time_t t;
    int fd, err;
    if (env.name && strstr (e->comm, env.name) == NULL)
        return;
    time (&t);
    tm = localtime (& t);
    strftime (ts, sizeof (ts), "%H:%M:%S", tm);
    if (e->ret >= 0) {
        fd = e->ret;
        err = 0;
    }
    else {
        fd = -1;
        err = -e->ret;
    }

#ifdef USE_BLAZESYM
    if (env.callers)
        result = blazesym_symbolize (symbolizer, cfgs, 1, (const uint64_t *) &e->callers, 2);

#endif
    sps_cnt = 0;
    if (env.timestamp) {
        printf ("%-8s ", ts);
        sps_cnt += 9;
    }
    if (env.print_uid) {
        printf ("%-7d ", e->uid);
        sps_cnt += 8;
    }
    printf ("%-6d %-16s %3d %3d ", e->pid, e->comm, fd, err);
    sps_cnt += 7 + 17 + 4 + 4;
    if (env.extended) {
        printf ("%08o ", e->flags);
        sps_cnt += 9;
    }
    printf ("%s\n", e->fname);

#ifdef USE_BLAZESYM
    for (i = 0; result && i < result->size; i++) {
        if (result->entries[i].size == 0)
            continue;
        sym = &result->entries[i].syms[0];
        for (j = 0; j < sps_cnt; j++)
            printf (" ");
        if (sym->line_no)
            printf ("%s:%ld\n", sym->symbol, sym->line_no);
        else
            printf ("%s\n", sym->symbol);
    }
    blazesym_result_free (result);

#endif
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/opensnoop.c" funcheader="void handle_lost_events (void *ctx, int cpu, __u64 lost_cnt)" startline="276" endline="279">
void handle_lost_events (void *ctx, int cpu, __u64 lost_cnt)
{
    fprintf (stderr, "Lost %llu events on CPU #%d!\n", lost_cnt, cpu);
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/opensnoop.c" funcheader="int main (int argc, char **argv)" startline="281" endline="398">
int main (int argc, char **argv)
{
    LIBBPF_OPTS (bpf_object_open_opts, open_opts);
    static const struct argp argp = {
        .options = opts,
        .parser = parse_arg,
        .doc = argp_program_doc,}
    ;
    struct perf_buffer *pb = NULL;
    struct opensnoop_bpf *obj;
    __u64 time_end = 0;
    int err;
    err = argp_parse (& argp, argc, argv, 0, NULL, NULL);
    if (err)
        return err;
    libbpf_set_strict_mode (LIBBPF_STRICT_ALL);
    libbpf_set_print (libbpf_print_fn);
    err = ensure_core_btf (& open_opts);
    if (err) {
        fprintf (stderr, "failed to fetch necessary BTF for CO-RE: %s\n", strerror (-err));
        return 1;
    }
    obj = opensnoop_bpf__open_opts (& open_opts);
    if (!obj) {
        fprintf (stderr, "failed to open BPF object\n");
        return 1;
    }
    obj->rodata->targ_tgid = env.pid;
    obj->rodata->targ_pid = env.tid;
    obj->rodata->targ_uid = env.uid;
    obj->rodata->targ_failed = env.failed;
    if (!tracepoint_exists ("syscalls", "sys_enter_open")) {
        bpf_program__set_autoload (obj->progs.tracepoint__syscalls__sys_enter_open, false);
        bpf_program__set_autoload (obj->progs.tracepoint__syscalls__sys_exit_open, false);
    }
    err = opensnoop_bpf__load (obj);
    if (err) {
        fprintf (stderr, "failed to load BPF object: %d\n", err);
        goto cleanup;
    }
    err = opensnoop_bpf__attach (obj);
    if (err) {
        fprintf (stderr, "failed to attach BPF programs\n");
        goto cleanup;
    }

#ifdef USE_BLAZESYM
    if (env.callers)
        symbolizer = blazesym_new ();

#endif
    if (env.timestamp)
        printf ("%-8s ", "TIME");
    if (env.print_uid)
        printf ("%-7s ", "UID");
    printf ("%-6s %-16s %3s %3s ", "PID", "COMM", "FD", "ERR");
    if (env.extended)
        printf ("%-8s ", "FLAGS");
    printf ("%s", "PATH");

#ifdef USE_BLAZESYM
    if (env.callers)
        printf ("/CALLER");

#endif
    printf ("\n");
    pb = perf_buffer__new (bpf_map__fd (obj -> maps.events), PERF_BUFFER_PAGES, handle_event, handle_lost_events, NULL, NULL);
    if (!pb) {
        err = -errno;
        fprintf (stderr, "failed to open perf buffer: %d\n", err);
        goto cleanup;
    }
    if (env.duration)
        time_end = get_ktime_ns () + env.duration * NSEC_PER_SEC;
    if (signal (SIGINT, sig_int) == SIG_ERR) {
        fprintf (stderr, "can't set signal handler: %s\n", strerror (errno));
        err = 1;
        goto cleanup;
    }
    while (!exiting) {
        err = perf_buffer__poll (pb, PERF_POLL_TIMEOUT_MS);
        if (err < 0 && err != -EINTR) {
            fprintf (stderr, "error polling perf buffer: %s\n", strerror (-err));
            goto cleanup;
        }
        if (env.duration && get_ktime_ns () > time_end)
            goto cleanup;
        err = 0;
    }
cleanup :
    perf_buffer__free (pb);
    opensnoop_bpf__destroy (obj);
    cleanup_core_btf (&open_opts);

#ifdef USE_BLAZESYM
    blazesym_free (symbolizer);

#endif
    return err != 0;
}
</source>
</doc>
