<?xml version="1.0"?>
<doc>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/syscount.c" funcheader="static int get_int (const char *arg, int *ret, int min, int max)" startline="85" endline="101">
static int get_int (const char *arg, int *ret, int min, int max)
{
    char *end;
    long val;
    errno = 0;
    val = strtol (arg, & end, 10);
    if (errno) {
        warn ("strtol: %s: %s\n", arg, strerror (errno));
        return -1;
    }
    else if (end == arg || val < min || val > max) {
        return -1;
    }
    if (ret)
        *ret = val;
    return 0;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/syscount.c" funcheader="static int libbpf_print_fn (enum libbpf_print_level level, const char *format, va_list args)" startline="103" endline="109">
static int libbpf_print_fn (enum libbpf_print_level level, const char *format, va_list args)
{
    if (level == LIBBPF_DEBUG && !env.verbose)
        return 0;
    return vfprintf (stderr, format, args);
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/syscount.c" funcheader="static int compar_count (const void *dx, const void *dy)" startline="111" endline="116">
static int compar_count (const void *dx, const void *dy)
{
    __u64 x = ((struct data_ext_t *) dx)->count;
    __u64 y = ((struct data_ext_t *) dy)->count;
    return x > y ? -1 : !(x == y);
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/syscount.c" funcheader="static int compar_latency (const void *dx, const void *dy)" startline="118" endline="123">
static int compar_latency (const void *dx, const void *dy)
{
    __u64 x = ((struct data_ext_t *) dx)->total_ns;
    __u64 y = ((struct data_ext_t *) dy)->total_ns;
    return x > y ? -1 : !(x == y);
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/syscount.c" funcheader="static const char *agg_col (struct data_ext_t *val, char *buf, size_t size)" startline="125" endline="133">
static const char *agg_col (struct data_ext_t *val, char *buf, size_t size)
{
    if (env.process) {
        snprintf (buf, size, "%-6u %-15s", val->key, val->comm);
    }
    else {
        syscall_name (val->key, buf, size);
    }
    return buf;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/syscount.c" funcheader="static const char *agg_colname (void)" startline="135" endline="138">
static const char *agg_colname (void)
{
    return (env.process) ? "PID    COMM" : "SYSCALL";
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/syscount.c" funcheader="static const char *time_colname (void)" startline="140" endline="143">
static const char *time_colname (void)
{
    return (env.milliseconds) ? "TIME (ms)" : "TIME (us)";
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/syscount.c" funcheader="static void print_latency_header (void)" startline="145" endline="148">
static void print_latency_header (void)
{
    printf ("%-22s %8s %16s\n", agg_colname (), "COUNT", time_colname ());
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/syscount.c" funcheader="static void print_count_header (void)" startline="150" endline="153">
static void print_count_header (void)
{
    printf ("%-22s %8s\n", agg_colname (), "COUNT");
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/syscount.c" funcheader="static void print_latency (struct data_ext_t *vals, size_t count)" startline="155" endline="167">
static void print_latency (struct data_ext_t *vals, size_t count)
{
    double div = env.milliseconds ? 1000000.0 : 1000.0;
    char buf [2 * TASK_COMM_LEN];
    int i;
    print_latency_header ();
    for (i = 0; i < count && i < env.top; i++)
        printf ("%-22s %8llu %16.3lf\n", agg_col (&vals[i], buf, sizeof (buf)), vals[i].count, vals[i].total_ns / div);
    printf ("\n");
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/syscount.c" funcheader="static void print_count (struct data_ext_t *vals, size_t count)" startline="169" endline="179">
static void print_count (struct data_ext_t *vals, size_t count)
{
    char buf [2 * TASK_COMM_LEN];
    int i;
    print_count_header ();
    for (i = 0; i < count && i < env.top; i++)
        printf ("%-22s %8llu\n", agg_col (&vals[i], buf, sizeof (buf)), vals[i].count);
    printf ("\n");
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/syscount.c" funcheader="static void print_timestamp ()" startline="181" endline="190">
static void print_timestamp ()
{
    time_t now = time (NULL);
    struct tm tm;
    if (localtime_r (&now, &tm))
        printf ("[%02d:%02d:%02d]\n", tm.tm_hour, tm.tm_min, tm.tm_sec);
    else
        warn ("localtime_r: %s", strerror (errno));
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/syscount.c" funcheader="static bool read_vals_batch (int fd, struct data_ext_t *vals, __u32 *count)" startline="194" endline="227">
static bool read_vals_batch (int fd, struct data_ext_t *vals, __u32 *count)
{
    struct data_t orig_vals [*count];
    void *in = NULL, *out;
    __u32 i, n, n_read = 0;
    __u32 keys [*count];
    int err = 0;
    while (n_read < *count && !err) {
        n = *count - n_read;
        err = bpf_map_lookup_and_delete_batch (fd, & in, & out, keys + n_read, orig_vals + n_read, & n, NULL);
        if (err && errno != ENOENT) {
            if (errno != EINVAL)
                warn ("bpf_map_lookup_and_delete_batch: %s\n", strerror (-err));
            return false;
        }
        n_read += n;
        in = out;
    }
    for (i = 0; i < n_read; i++) {
        vals[i].count = orig_vals[i].count;
        vals[i].total_ns = orig_vals[i].total_ns;
        vals[i].key = keys[i];
        strncpy (vals[i].comm, orig_vals[i].comm, TASK_COMM_LEN);
    }
    *count = n_read;
    return true;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/syscount.c" funcheader="static bool read_vals (int fd, struct data_ext_t *vals, __u32 *count)" startline="229" endline="289">
static bool read_vals (int fd, struct data_ext_t *vals, __u32 *count)
{
    __u32 keys [MAX_ENTRIES];
    struct data_t val;
    __u32 key = -1;
    __u32 next_key;
    int i = 0, j;
    int err;
    if (batch_map_ops) {
        bool ok = read_vals_batch (fd, vals, count);
        if (!ok && errno == EINVAL) {
            batch_map_ops = false;
        }
        else {
            return ok;
        }
    }
    if (!vals || !count || !*count)
        return true;
    for (key = -1; i < *count;) {
        err = bpf_map_get_next_key (fd, & key, & next_key);
        if (err && errno != ENOENT) {
            warn ("failed to get next key: %s\n", strerror (errno));
            return false;
        }
        else if (err) {
            break;
        }
        key = keys[i++] = next_key;
    }
    for (j = 0; j < i; j++) {
        err = bpf_map_lookup_elem (fd, & keys [j], & val);
        if (err && errno != ENOENT) {
            warn ("failed to lookup element: %s\n", strerror (errno));
            return false;
        }
        vals[j].count = val.count;
        vals[j].total_ns = val.total_ns;
        vals[j].key = keys[j];
        memcpy (vals[j].comm, val.comm, TASK_COMM_LEN);
    }
    for (j = 0; j < i; j++) {
        err = bpf_map_delete_elem (fd, & keys [j]);
        if (err) {
            warn ("failed to delete element: %s\n", strerror (errno));
            return false;
        }
    }
    *count = i;
    return true;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/syscount.c" funcheader="static error_t parse_arg (int key, char *arg, struct argp_state *state)" startline="291" endline="368">
static error_t parse_arg (int key, char *arg, struct argp_state *state)
{
    int number;
    int err;
    switch (key) {
    case 'h' :
        argp_state_help (state, stderr, ARGP_HELP_STD_HELP);
        break;
    case 'v' :
        env.verbose = true;
        break;
    case 'x' :
        env.failures = true;
        break;
    case 'L' :
        env.latency = true;
        break;
    case 'm' :
        env.milliseconds = true;
        break;
    case 'P' :
        env.process = true;
        break;
    case 'p' :
        err = get_int (arg, &env.pid, 1, INT_MAX);
        if (err) {
            warn ("invalid PID: %s\n", arg);
            argp_usage (state);
        }
        break;
    case 'i' :
        err = get_int (arg, &env.interval, 0, INT_MAX);
        if (err) {
            warn ("invalid INTERVAL: %s\n", arg);
            argp_usage (state);
        }
        break;
    case 'd' :
        err = get_int (arg, &env.duration, 1, INT_MAX);
        if (err) {
            warn ("invalid DURATION: %s\n", arg);
            argp_usage (state);
        }
        break;
    case 'T' :
        err = get_int (arg, &env.top, 1, INT_MAX);
        if (err) {
            warn ("invalid TOP: %s\n", arg);
            argp_usage (state);
        }
        break;
    case 'c' :
        env.cgroupspath = arg;
        env.cg = true;
        break;
    case 'e' :
        err = get_int (arg, &number, 1, INT_MAX);
        if (err) {
            number = errno_by_name (arg);
            if (number < 0) {
                warn ("invalid errno: %s (bad, or can't " "parse dynamically; consider using " "numeric value and/or installing the " "errno program from moreutils)\n", arg);
                argp_usage (state);
            }
        }
        env.filter_errno = number;
        break;
    case 'l' :
        env.list_syscalls = true;
        break;
    default :
        return ARGP_ERR_UNKNOWN;
    }
    return 0;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/syscount.c" funcheader="void sig_int (int signo)" startline="372" endline="375">
void sig_int (int signo)
{
    hang_on = 0;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/syscount.c" funcheader="int main (int argc, char **argv)" startline="377" endline="511">
int main (int argc, char **argv)
{
    LIBBPF_OPTS (bpf_object_open_opts, open_opts);
    void (*print) (struct data_ext_t *, size_t);
    int (*compar) (const void *, const void *);
    static const struct argp argp = {
        .options = opts,
        .parser = parse_arg,
        .doc = argp_program_doc,}
    ;
    struct data_ext_t vals [MAX_ENTRIES];
    struct syscount_bpf *obj;
    int seconds = 0;
    __u32 count;
    int err;
    int idx, cg_map_fd;
    int cgfd = -1;
    init_syscall_names ();
    err = argp_parse (& argp, argc, argv, 0, NULL, NULL);
    if (err)
        goto free_names;
    if (env.list_syscalls) {
        list_syscalls ();
        goto free_names;
    }
    libbpf_set_strict_mode (LIBBPF_STRICT_ALL);
    libbpf_set_print (libbpf_print_fn);
    err = ensure_core_btf (& open_opts);
    if (err) {
        fprintf (stderr, "failed to fetch necessary BTF for CO-RE: %s\n", strerror (-err));
        return 1;
    }
    obj = syscount_bpf__open_opts (& open_opts);
    if (!obj) {
        warn ("failed to open BPF object\n");
        err = 1;
        goto free_names;
    }
    if (env.pid)
        obj->rodata->filter_pid = env.pid;
    if (env.failures)
        obj->rodata->filter_failed = true;
    if (env.latency)
        obj->rodata->measure_latency = true;
    if (env.process)
        obj->rodata->count_by_process = true;
    if (env.filter_errno)
        obj->rodata->filter_errno = env.filter_errno;
    if (env.cg)
        obj->rodata->filter_cg = env.cg;
    err = syscount_bpf__load (obj);
    if (err) {
        warn ("failed to load BPF object: %s\n", strerror (-err));
        goto cleanup_obj;
    }
    if (env.cg) {
        idx = 0;
        cg_map_fd = bpf_map__fd (obj -> maps.cgroup_map);
        cgfd = open (env.cgroupspath, O_RDONLY);
        if (cgfd < 0) {
            fprintf (stderr, "Failed opening Cgroup path: %s", env.cgroupspath);
            goto cleanup_obj;
        }
        if (bpf_map_update_elem (cg_map_fd, &idx, &cgfd, BPF_ANY)) {
            fprintf (stderr, "Failed adding target cgroup to map");
            goto cleanup_obj;
        }
    }
    obj->links.sys_exit = bpf_program__attach (obj->progs.sys_exit);
    if (!obj->links.sys_exit) {
        err = -errno;
        warn ("failed to attach sys_exit program: %s\n", strerror (-err));
        goto cleanup_obj;
    }
    if (env.latency) {
        obj->links.sys_enter = bpf_program__attach (obj->progs.sys_enter);
        if (!obj->links.sys_enter) {
            err = -errno;
            warn ("failed to attach sys_enter programs: %s\n", strerror (-err));
            goto cleanup_obj;
        }
    }
    if (signal (SIGINT, sig_int) == SIG_ERR) {
        warn ("can't set signal handler: %s\n", strerror (errno));
        goto cleanup_obj;
    }
    compar = env.latency ? compar_latency : compar_count;
    print = env.latency ? print_latency : print_count;
    printf ("Tracing syscalls, printing top %d... Ctrl+C to quit.\n", env.top);
    while (hang_on) {
        sleep (env.interval ? : 1);
        if (env.duration) {
            seconds += env.interval ? : 1;
            if (seconds >= env.duration)
                hang_on = 0;
        }
        if (hang_on && !env.interval)
            continue;
        count = MAX_ENTRIES;
        if (!read_vals (bpf_map__fd (obj->maps.data), vals, &count))
            break;
        if (!count)
            continue;
        qsort (vals, count, sizeof (vals [0]), compar);
        print_timestamp ();
        print (vals, count);
    }
cleanup_obj :
    syscount_bpf__destroy (obj);
free_names :
    free_syscall_names ();
    cleanup_core_btf (&open_opts);
    if (cgfd > 0)
        close (cgfd);
    return err != 0;
}
</source>
</doc>
