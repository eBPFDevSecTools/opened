<?xml version="1.0"?>
<doc>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/llcstat.c" funcheader="static error_t parse_arg (int key, char *arg, struct argp_state *state)" startline="51" endline="90">
static error_t parse_arg (int key, char *arg, struct argp_state *state)
{
    static int pos_args;
    switch (key) {
    case 'h' :
        argp_state_help (state, stderr, ARGP_HELP_STD_HELP);
        break;
    case 'v' :
        env.verbose = true;
        break;
    case 't' :
        env.per_thread = true;
        break;
    case 'c' :
        errno = 0;
        env.sample_period = strtol (arg, NULL, 10);
        if (errno) {
            fprintf (stderr, "invalid sample period\n");
            argp_usage (state);
        }
        break;
    case ARGP_KEY_ARG :
        if (pos_args++) {
            fprintf (stderr, "unrecognized positional argument: %s\n", arg);
            argp_usage (state);
        }
        errno = 0;
        env.duration = strtol (arg, NULL, 10);
        if (errno) {
            fprintf (stderr, "invalid duration\n");
            argp_usage (state);
        }
        break;
    default :
        return ARGP_ERR_UNKNOWN;
    }
    return 0;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/llcstat.c" funcheader="static int open_and_attach_perf_event (__u64 config, int period, struct bpf_program *prog, struct bpf_link *links [])" startline="94" endline="124">
static int open_and_attach_perf_event (__u64 config, int period, struct bpf_program *prog, struct bpf_link *links [])
{
    struct perf_event_attr attr = {
        .type = PERF_TYPE_HARDWARE,
        .freq = 0,
        .sample_period = period,
        .config = config,}
    ;
    int i, fd;
    for (i = 0; i < nr_cpus; i++) {
        fd = syscall (__NR_perf_event_open, & attr, - 1, i, - 1, 0);
        if (fd < 0) {
            if (errno == ENODEV)
                continue;
            fprintf (stderr, "failed to init perf sampling: %s\n", strerror (errno));
            return -1;
        }
        links[i] = bpf_program__attach_perf_event (prog, fd);
        if (!links[i]) {
            fprintf (stderr, "failed to attach perf event on cpu: %d\n", i);
            close (fd);
            return -1;
        }
    }
    return 0;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/llcstat.c" funcheader="static int libbpf_print_fn (enum libbpf_print_level level, const char *format, va_list args)" startline="126" endline="131">
static int libbpf_print_fn (enum libbpf_print_level level, const char *format, va_list args)
{
    if (level == LIBBPF_DEBUG && !env.verbose)
        return 0;
    return vfprintf (stderr, format, args);
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/llcstat.c" funcheader="static void sig_handler (int sig)" startline="133" endline="136">
static void sig_handler (int sig)
{
    exiting = true;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/llcstat.c" funcheader="static void print_map (struct bpf_map *map)" startline="138" endline="181">
static void print_map (struct bpf_map *map)
{
    __u64 total_ref = 0, total_miss = 0, total_hit, hit;
    __u32 pid, cpu, tid;
    struct key_info lookup_key = {
        .cpu = -1}, next_key;
    int err, fd = bpf_map__fd (map);
    struct value_info info;
    while (!bpf_map_get_next_key (fd, &lookup_key, &next_key)) {
        err = bpf_map_lookup_elem (fd, & next_key, & info);
        if (err < 0) {
            fprintf (stderr, "failed to lookup infos: %d\n", err);
            return;
        }
        hit = info.ref > info.miss ? info.ref - info.miss : 0;
        cpu = next_key.cpu;
        pid = next_key.pid;
        tid = next_key.tid;
        printf ("%-8u ", pid);
        if (env.per_thread) {
            printf ("%-8u ", tid);
        }
        printf ("%-16s %-4u %12llu %12llu %6.2f%%\n", info.comm, cpu, info.ref, info.miss, info.ref > 0 ? hit * 1.0 / info.ref * 100 : 0);
        total_miss += info.miss;
        total_ref += info.ref;
        lookup_key = next_key;
    }
    total_hit = total_ref > total_miss ? total_ref - total_miss : 0;
    printf ("Total References: %llu Total Misses: %llu Hit Rate: %.2f%%\n", total_ref, total_miss, total_ref > 0 ? total_hit * 1.0 / total_ref * 100 : 0);
    lookup_key.cpu = -1;
    while (!bpf_map_get_next_key (fd, &lookup_key, &next_key)) {
        err = bpf_map_delete_elem (fd, & next_key);
        if (err < 0) {
            fprintf (stderr, "failed to cleanup infos: %d\n", err);
            return;
        }
        lookup_key = next_key;
    }
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/llcstat.c" funcheader="int main (int argc, char **argv)" startline="183" endline="270">
int main (int argc, char **argv)
{
    struct bpf_link **rlinks = NULL, **mlinks = NULL;
    LIBBPF_OPTS (bpf_object_open_opts, open_opts);
    static const struct argp argp = {
        .options = opts,
        .parser = parse_arg,
        .doc = argp_program_doc,}
    ;
    struct llcstat_bpf *obj;
    int err, i;
    err = argp_parse (& argp, argc, argv, 0, NULL, NULL);
    if (err)
        return err;
    libbpf_set_strict_mode (LIBBPF_STRICT_ALL);
    libbpf_set_print (libbpf_print_fn);
    nr_cpus = libbpf_num_possible_cpus ();
    if (nr_cpus < 0) {
        fprintf (stderr, "failed to get # of possible cpus: '%s'!\n", strerror (-nr_cpus));
        return 1;
    }
    mlinks = calloc (nr_cpus, sizeof (* mlinks));
    rlinks = calloc (nr_cpus, sizeof (* rlinks));
    if (!mlinks || !rlinks) {
        fprintf (stderr, "failed to alloc mlinks or rlinks\n");
        return 1;
    }
    err = ensure_core_btf (& open_opts);
    if (err) {
        fprintf (stderr, "failed to fetch necessary BTF for CO-RE: %s\n", strerror (-err));
        return 1;
    }
    obj = llcstat_bpf__open_opts (& open_opts);
    if (!obj) {
        fprintf (stderr, "failed to open and/or load BPF object\n");
        goto cleanup;
    }
    obj->rodata->targ_per_thread = env.per_thread;
    err = llcstat_bpf__load (obj);
    if (err) {
        fprintf (stderr, "failed to load BPF object: %d\n", err);
        goto cleanup;
    }
    if (open_and_attach_perf_event (PERF_COUNT_HW_CACHE_MISSES, env.sample_period, obj->progs.on_cache_miss, mlinks))
        goto cleanup;
    if (open_and_attach_perf_event (PERF_COUNT_HW_CACHE_REFERENCES, env.sample_period, obj->progs.on_cache_ref, rlinks))
        goto cleanup;
    printf ("Running for %ld seconds or Hit Ctrl-C to end.\n", env.duration);
    signal (SIGINT, sig_handler);
    sleep (env.duration);
    printf ("%-8s ", "PID");
    if (env.per_thread) {
        printf ("%-8s ", "TID");
    }
    printf ("%-16s %-4s %12s %12s %7s\n", "NAME", "CPU", "REFERENCE", "MISS", "HIT%");
    print_map (obj->maps.infos);
cleanup :
    for (i = 0; i < nr_cpus; i++) {
        bpf_link__destroy (mlinks[i]);
        bpf_link__destroy (rlinks[i]);
    }
    free (mlinks);
    free (rlinks);
    llcstat_bpf__destroy (obj);
    cleanup_core_btf (&open_opts);
    return err != 0;
}
</source>
</doc>
