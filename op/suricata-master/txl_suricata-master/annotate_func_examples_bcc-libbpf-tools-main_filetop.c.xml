<?xml version="1.0"?>
<doc>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/filetop.c" funcheader="static error_t parse_arg (int key, char *arg, struct argp_state *state)" startline="72" endline="150">
static error_t parse_arg (int key, char *arg, struct argp_state *state)
{
    long pid, rows;
    static int pos_args;
    switch (key) {
    case 'p' :
        errno = 0;
        pid = strtol (arg, NULL, 10);
        if (errno || pid <= 0) {
            warn ("invalid PID: %s\n", arg);
            argp_usage (state);
        }
        target_pid = pid;
        break;
    case 'C' :
        clear_screen = false;
        break;
    case 'a' :
        regular_file_only = false;
        break;
    case 's' :
        if (!strcmp (arg, "all")) {
            sort_by = ALL;
        }
        else if (!strcmp (arg, "reads")) {
            sort_by = READS;
        }
        else if (!strcmp (arg, "writes")) {
            sort_by = WRITES;
        }
        else if (!strcmp (arg, "rbytes")) {
            sort_by = RBYTES;
        }
        else if (!strcmp (arg, "wbytes")) {
            sort_by = WBYTES;
        }
        else {
            warn ("invalid sort method: %s\n", arg);
            argp_usage (state);
        }
        break;
    case 'r' :
        errno = 0;
        rows = strtol (arg, NULL, 10);
        if (errno || rows <= 0) {
            warn ("invalid rows: %s\n", arg);
            argp_usage (state);
        }
        output_rows = rows;
        if (output_rows > OUTPUT_ROWS_LIMIT)
            output_rows = OUTPUT_ROWS_LIMIT;
        break;
    case 'v' :
        verbose = true;
        break;
    case 'h' :
        argp_state_help (state, stderr, ARGP_HELP_STD_HELP);
        break;
    case ARGP_KEY_ARG :
        errno = 0;
        if (pos_args == 0) {
            interval = strtol (arg, NULL, 10);
            if (errno || interval <= 0) {
                warn ("invalid interval\n");
                argp_usage (state);
            }
        }
        else if (pos_args == 1) {
            count = strtol (arg, NULL, 10);
            if (errno || count <= 0) {
                warn ("invalid count\n");
                argp_usage (state);
            }
        }
        else {
            warn ("unrecognized positional argument: %s\n", arg);
            argp_usage (state);
        }
        pos_args++;
        break;
    default :
        return ARGP_ERR_UNKNOWN;
    }
    return 0;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/filetop.c" funcheader="static int libbpf_print_fn (enum libbpf_print_level level, const char *format, va_list args)" startline="152" endline="157">
static int libbpf_print_fn (enum libbpf_print_level level, const char *format, va_list args)
{
    if (level == LIBBPF_DEBUG && !verbose)
        return 0;
    return vfprintf (stderr, format, args);
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/filetop.c" funcheader="static void sig_int (int signo)" startline="159" endline="162">
static void sig_int (int signo)
{
    exiting = 1;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/filetop.c" funcheader="static int sort_column (const void *obj1, const void *obj2)" startline="164" endline="181">
static int sort_column (const void *obj1, const void *obj2)
{
    struct file_stat *s1 = (struct file_stat *) obj1;
    struct file_stat *s2 = (struct file_stat *) obj2;
    if (sort_by == READS) {
        return s2->reads - s1->reads;
    }
    else if (sort_by == WRITES) {
        return s2->writes - s1->writes;
    }
    else if (sort_by == RBYTES) {
        return s2->read_bytes - s1->read_bytes;
    }
    else if (sort_by == WBYTES) {
        return s2->write_bytes - s1->write_bytes;
    }
    else {
        return (s2->reads + s2->writes + s2->read_bytes + s2->write_bytes) - (s1->reads + s1->writes + s1->read_bytes + s1->write_bytes);
    }
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/filetop.c" funcheader="static int print_stat (struct filetop_bpf *obj)" startline="183" endline="256">
static int print_stat (struct filetop_bpf *obj)
{
    FILE *f;
    time_t t;
    struct tm *tm;
    char ts [16], buf [256];
    struct file_id key, *prev_key = NULL;
    static struct file_stat values [OUTPUT_ROWS_LIMIT];
    int n, i, err = 0, rows = 0;
    int fd = bpf_map__fd (obj -> maps.entries);
    f = fopen ("/proc/loadavg", "r");
    if (f) {
        time (&t);
        tm = localtime (& t);
        strftime (ts, sizeof (ts), "%H:%M:%S", tm);
        memset (buf, 0, sizeof (buf));
        n = fread (buf, 1, sizeof (buf), f);
        if (n)
            printf ("%8s loadavg: %s\n", ts, buf);
        fclose (f);
    }
    printf ("%-7s %-16s %-6s %-6s %-7s %-7s %1s %s\n", "TID", "COMM", "READS", "WRITES", "R_Kb", "W_Kb", "T", "FILE");
    while (1) {
        err = bpf_map_get_next_key (fd, prev_key, & key);
        if (err) {
            if (errno == ENOENT) {
                err = 0;
                break;
            }
            warn ("bpf_map_get_next_key failed: %s\n", strerror (errno));
            return err;
        }
        err = bpf_map_lookup_elem (fd, & key, & values [rows ++]);
        if (err) {
            warn ("bpf_map_lookup_elem failed: %s\n", strerror (errno));
            return err;
        }
        prev_key = &key;
    }
    qsort (values, rows, sizeof (struct file_stat), sort_column);
    rows = rows < output_rows ? rows : output_rows;
    for (i = 0; i < rows; i++)
        printf ("%-7d %-16s %-6lld %-6lld %-7lld %-7lld %c %s\n", values[i].tid, values[i].comm, values[i].reads, values[i].writes, values[i].read_bytes / 1024, values[i].write_bytes / 1024, values[i].type, values[i].filename);
    printf ("\n");
    prev_key = NULL;
    while (1) {
        err = bpf_map_get_next_key (fd, prev_key, & key);
        if (err) {
            if (errno == ENOENT) {
                err = 0;
                break;
            }
            warn ("bpf_map_get_next_key failed: %s\n", strerror (errno));
            return err;
        }
        err = bpf_map_delete_elem (fd, & key);
        if (err) {
            warn ("bpf_map_delete_elem failed: %s\n", strerror (errno));
            return err;
        }
        prev_key = &key;
    }
    return err;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/filetop.c" funcheader="int main (int argc, char **argv)" startline="258" endline="332">
int main (int argc, char **argv)
{
    LIBBPF_OPTS (bpf_object_open_opts, open_opts);
    static const struct argp argp = {
        .options = opts,
        .parser = parse_arg,
        .doc = argp_program_doc,}
    ;
    struct filetop_bpf *obj;
    int err;
    err = argp_parse (& argp, argc, argv, 0, NULL, NULL);
    if (err)
        return err;
    libbpf_set_strict_mode (LIBBPF_STRICT_ALL);
    libbpf_set_print (libbpf_print_fn);
    err = ensure_core_btf (& open_opts);
    if (err) {
        fprintf (stderr, "failed to fetch necessary BTF for CO-RE: %s\n", strerror (-err));
        return 1;
    }
    obj = filetop_bpf__open_opts (& open_opts);
    if (!obj) {
        warn ("failed to open BPF object\n");
        return 1;
    }
    obj->rodata->target_pid = target_pid;
    obj->rodata->regular_file_only = regular_file_only;
    err = filetop_bpf__load (obj);
    if (err) {
        warn ("failed to load BPF object: %d\n", err);
        goto cleanup;
    }
    err = filetop_bpf__attach (obj);
    if (err) {
        warn ("failed to attach BPF programs: %d\n", err);
        goto cleanup;
    }
    if (signal (SIGINT, sig_int) == SIG_ERR) {
        warn ("can't set signal handler: %s\n", strerror (errno));
        err = 1;
        goto cleanup;
    }
    while (1) {
        sleep (interval);
        if (clear_screen) {
            err = system ("clear");
            if (err)
                goto cleanup;
        }
        err = print_stat (obj);
        if (err)
            goto cleanup;
        count--;
        if (exiting || !count)
            goto cleanup;
    }
cleanup :
    filetop_bpf__destroy (obj);
    cleanup_core_btf (&open_opts);
    return err != 0;
}
</source>
</doc>
