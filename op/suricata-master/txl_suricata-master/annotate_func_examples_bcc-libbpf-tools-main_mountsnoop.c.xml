<?xml version="1.0"?>
<doc>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/mountsnoop.c" funcheader="const char *strerrorname_np (int errnum)" startline="31" endline="34">
const char *strerrorname_np (int errnum)
{
    return NULL;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/mountsnoop.c" funcheader="static error_t parse_arg (int key, char *arg, struct argp_state *state)" startline="101" endline="131">
static error_t parse_arg (int key, char *arg, struct argp_state *state)
{
    long pid;
    switch (key) {
    case 'p' :
        errno = 0;
        pid = strtol (arg, NULL, 10);
        if (errno || pid <= 0) {
            warn ("Invalid PID: %s\n", arg);
            argp_usage (state);
        }
        target_pid = pid;
        break;
    case 't' :
        emit_timestamp = true;
        break;
    case 'd' :
        output_vertically = true;
        break;
    case 'v' :
        verbose = true;
        break;
    case 'h' :
        argp_state_help (state, stderr, ARGP_HELP_STD_HELP);
        break;
    default :
        return ARGP_ERR_UNKNOWN;
    }
    return 0;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/mountsnoop.c" funcheader="static int libbpf_print_fn (enum libbpf_print_level level, const char *format, va_list args)" startline="133" endline="138">
static int libbpf_print_fn (enum libbpf_print_level level, const char *format, va_list args)
{
    if (level == LIBBPF_DEBUG && !verbose)
        return 0;
    return vfprintf (stderr, format, args);
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/mountsnoop.c" funcheader="static void sig_int (int signo)" startline="140" endline="143">
static void sig_int (int signo)
{
    exiting = 1;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/mountsnoop.c" funcheader="static const char *strflags (__u64 flags)" startline="145" endline="162">
static const char *strflags (__u64 flags)
{
    static char str [512];
    int i;
    if (!flags)
        return "0x0";
    str[0] = '\0';
    for (i = 0; i < flag_count; i++) {
        if (!((1 << i) & flags))
            continue;
        if (str[0])
            strcat (str, " | ");
        strcat (str, flag_names[i]);
    }
    return str;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/mountsnoop.c" funcheader="static const char *strerrno (int errnum)" startline="164" endline="181">
static const char *strerrno (int errnum)
{
    const char *errstr;
    static char ret [32] = {};
    if (!errnum)
        return "0";
    ret[0] = '\0';
    errstr = strerrorname_np (- errnum);
    if (!errstr) {
        snprintf (ret, sizeof (ret), "%d", errnum);
        return ret;
    }
    snprintf (ret, sizeof (ret), "-%s", errstr);
    return ret;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/mountsnoop.c" funcheader="static const char *gen_call (const struct event *e)" startline="183" endline="196">
static const char *gen_call (const struct event *e)
{
    static char call [10240];
    memset (call, 0, sizeof (call));
    if (e->op == UMOUNT) {
        snprintf (call, sizeof (call), "umount(\"%s\", %s) = %s", e->dest, strflags (e->flags), strerrno (e->ret));
    }
    else {
        snprintf (call, sizeof (call), "mount(\"%s\", \"%s\", \"%s\", %s, \"%s\") = %s", e->src, e->dest, e->fs, strflags (e->flags), e->data, strerrno (e->ret));
    }
    return call;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/mountsnoop.c" funcheader="static int handle_event (void *ctx, void *data, size_t len)" startline="198" endline="241">
static int handle_event (void *ctx, void *data, size_t len)
{
    const struct event *e = data;
    struct tm *tm;
    char ts [32];
    time_t t;
    const char *indent;
    static const char *op_name [] = {
        [MOUNT] = "MOUNT",
        [UMOUNT] = "UMOUNT",};
    if (emit_timestamp) {
        time (&t);
        tm = localtime (& t);
        strftime (ts, sizeof (ts), "%H:%M:%S ", tm);
        printf ("%s", ts);
        indent = "    ";
    }
    else {
        indent = "";
    }
    if (!output_vertically) {
        printf ("%-16s %-7d %-7d %-11u %s\n", e->comm, e->pid, e->tid, e->mnt_ns, gen_call (e));
        return 0;
    }
    if (emit_timestamp)
        printf ("\n");
    printf ("%sPID:    %d\n", indent, e->pid);
    printf ("%sTID:    %d\n", indent, e->tid);
    printf ("%sCOMM:   %s\n", indent, e->comm);
    printf ("%sOP:     %s\n", indent, op_name[e->op]);
    printf ("%sRET:    %s\n", indent, strerrno (e->ret));
    printf ("%sLAT:    %lldus\n", indent, e->delta / 1000);
    printf ("%sMNT_NS: %u\n", indent, e->mnt_ns);
    printf ("%sFS:     %s\n", indent, e->fs);
    printf ("%sSOURCE: %s\n", indent, e->src);
    printf ("%sTARGET: %s\n", indent, e->dest);
    printf ("%sDATA:   %s\n", indent, e->data);
    printf ("%sFLAGS:  %s\n", indent, strflags (e->flags));
    printf ("\n");
    return 0;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/mountsnoop.c" funcheader="static void handle_lost_events (void *ctx, int cpu, __u64 lost_cnt)" startline="243" endline="246">
static void handle_lost_events (void *ctx, int cpu, __u64 lost_cnt)
{
    warn ("lost %llu events on CPU #%d\n", lost_cnt, cpu);
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/mountsnoop.c" funcheader="int main (int argc, char **argv)" startline="248" endline="334">
int main (int argc, char **argv)
{
    LIBBPF_OPTS (bpf_object_open_opts, open_opts);
    static const struct argp argp = {
        .options = opts,
        .parser = parse_arg,
        .doc = argp_program_doc,}
    ;
    struct bpf_buffer *buf = NULL;
    struct mountsnoop_bpf *obj;
    int err;
    err = argp_parse (& argp, argc, argv, 0, NULL, NULL);
    if (err)
        return err;
    libbpf_set_strict_mode (LIBBPF_STRICT_ALL);
    libbpf_set_print (libbpf_print_fn);
    err = ensure_core_btf (& open_opts);
    if (err) {
        fprintf (stderr, "failed to fetch necessary BTF for CO-RE: %s\n", strerror (-err));
        return 1;
    }
    obj = mountsnoop_bpf__open_opts (& open_opts);
    if (!obj) {
        warn ("failed to open BPF object\n");
        return 1;
    }
    obj->rodata->target_pid = target_pid;
    buf = bpf_buffer__new (obj -> maps.events, obj -> maps.heap);
    if (!buf) {
        err = -errno;
        warn ("failed to create ring/perf buffer: %d\n", err);
        goto cleanup;
    }
    err = mountsnoop_bpf__load (obj);
    if (err) {
        warn ("failed to load BPF object: %d\n", err);
        goto cleanup;
    }
    err = mountsnoop_bpf__attach (obj);
    if (err) {
        warn ("failed to attach BPF programs: %d\n", err);
        goto cleanup;
    }
    err = bpf_buffer__open (buf, handle_event, handle_lost_events, NULL);
    if (err) {
        warn ("failed to open ring/perf buffer: %d\n", err);
        goto cleanup;
    }
    if (signal (SIGINT, sig_int) == SIG_ERR) {
        warn ("can't set signal handler: %s\n", strerror (errno));
        err = 1;
        goto cleanup;
    }
    if (!output_vertically) {
        if (emit_timestamp)
            printf ("%-8s ", "TIME");
        printf ("%-16s %-7s %-7s %-11s %s\n", "COMM", "PID", "TID", "MNT_NS", "CALL");
    }
    while (!exiting) {
        err = bpf_buffer__poll (buf, POLL_TIMEOUT_MS);
        if (err < 0 && err != -EINTR) {
            fprintf (stderr, "error polling ring/perf buffer: %s\n", strerror (-err));
            goto cleanup;
        }
        err = 0;
    }
cleanup :
    bpf_buffer__free (buf);
    mountsnoop_bpf__destroy (obj);
    cleanup_core_btf (&open_opts);
    return err != 0;
}
</source>
</doc>
