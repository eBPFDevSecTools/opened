<?xml version="1.0"?>
<doc>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/tcpsynbl.bpf.c" funcheader="static int do_entry (struct sock *sk)" startline="23" endline="39">
static int do_entry (struct sock *sk)
{
    u64 max_backlog, backlog, slot;
    struct hist *histp;
    max_backlog = BPF_CORE_READ (sk, sk_max_ack_backlog);
    backlog = BPF_CORE_READ (sk, sk_ack_backlog);
    histp = bpf_map_lookup_or_try_init (& hists, & max_backlog, & zero);
    if (!histp)
        return 0;
    slot = log2l (backlog);
    if (slot >= MAX_SLOTS)
        slot = MAX_SLOTS - 1;
    __sync_fetch_and_add (&histp->slots[slot], 1);
    return 0;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/tcpsynbl.bpf.c" funcheader="int BPF_KPROBE (tcp_v4_syn_recv_kprobe, struct sock *sk)" startline="43" endline="46">
int BPF_KPROBE (tcp_v4_syn_recv_kprobe, struct sock *sk)
{
    return do_entry (sk);
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/tcpsynbl.bpf.c" funcheader="int BPF_KPROBE (tcp_v6_syn_recv_kprobe, struct sock *sk)" startline="49" endline="52">
int BPF_KPROBE (tcp_v6_syn_recv_kprobe, struct sock *sk)
{
    return do_entry (sk);
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/tcpsynbl.bpf.c" funcheader="int BPF_PROG (tcp_v4_syn_recv, struct sock *sk)" startline="55" endline="58">
int BPF_PROG (tcp_v4_syn_recv, struct sock *sk)
{
    return do_entry (sk);
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/tcpsynbl.bpf.c" funcheader="int BPF_PROG (tcp_v6_syn_recv, struct sock *sk)" startline="61" endline="64">
int BPF_PROG (tcp_v6_syn_recv, struct sock *sk)
{
    return do_entry (sk);
}
</source>
</doc>
