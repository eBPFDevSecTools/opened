<?xml version="1.0"?>
<doc>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/offcputime.bpf.c" funcheader="static bool allow_record (struct task_struct *t)" startline="45" endline="58">
static bool allow_record (struct task_struct *t)
{
    if (targ_tgid != -1 && targ_tgid != t->tgid)
        return false;
    if (targ_pid != -1 && targ_pid != t->pid)
        return false;
    if (user_threads_only && t->flags & PF_KTHREAD)
        return false;
    else if (kernel_threads_only && !(t->flags & PF_KTHREAD))
        return false;
    if (state != -1 && get_task_state (t) != state)
        return false;
    return true;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/offcputime.bpf.c" funcheader="int BPF_PROG (sched_switch, bool preempt, struct task_struct *prev, struct task_struct *next)" startline="61" endline="108">
int BPF_PROG (sched_switch, bool preempt, struct task_struct *prev, struct task_struct *next)
{
    struct internal_key *i_keyp, i_key;
    struct val_t *valp, val;
    s64 delta;
    u32 pid;
    if (allow_record (prev)) {
        pid = prev->pid;
        if (!pid)
            pid = bpf_get_smp_processor_id ();
        i_key.key.pid = pid;
        i_key.key.tgid = prev->tgid;
        i_key.start_ts = bpf_ktime_get_ns ();
        if (prev->flags & PF_KTHREAD)
            i_key.key.user_stack_id = -1;
        else
            i_key.key.user_stack_id = bpf_get_stackid (ctx, &stackmap, BPF_F_USER_STACK);
        i_key.key.kern_stack_id = bpf_get_stackid (ctx, &stackmap, 0);
        bpf_map_update_elem (&start, &pid, &i_key, 0);
        bpf_probe_read_kernel_str (&val.comm, sizeof (prev->comm), prev->comm);
        val.delta = 0;
        bpf_map_update_elem (&info, &i_key.key, &val, BPF_NOEXIST);
    }
    pid = next->pid;
    i_keyp = bpf_map_lookup_elem (& start, & pid);
    if (!i_keyp)
        return 0;
    delta = (s64) (bpf_ktime_get_ns () - i_keyp->start_ts);
    if (delta < 0)
        goto cleanup;
    delta /= 1000U;
    if (delta < min_block_ns || delta > max_block_ns)
        goto cleanup;
    valp = bpf_map_lookup_elem (& info, & i_keyp -> key);
    if (!valp)
        goto cleanup;
    __sync_fetch_and_add (&valp->delta, delta);
cleanup :
    bpf_map_delete_elem (&start, &pid);
    return 0;
}
</source>
</doc>
