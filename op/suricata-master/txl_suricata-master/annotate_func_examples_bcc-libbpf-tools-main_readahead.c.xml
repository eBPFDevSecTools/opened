<?xml version="1.0"?>
<doc>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/readahead.c" funcheader="static error_t parse_arg (int key, char *arg, struct argp_state *state)" startline="44" endline="65">
static error_t parse_arg (int key, char *arg, struct argp_state *state)
{
    switch (key) {
    case 'h' :
        argp_state_help (state, stderr, ARGP_HELP_STD_HELP);
        break;
    case 'v' :
        env.verbose = true;
        break;
    case 'd' :
        errno = 0;
        env.duration = strtol (arg, NULL, 10);
        if (errno || env.duration <= 0) {
            fprintf (stderr, "Invalid duration: %s\n", arg);
            argp_usage (state);
        }
        break;
    default :
        return ARGP_ERR_UNKNOWN;
    }
    return 0;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/readahead.c" funcheader="static int libbpf_print_fn (enum libbpf_print_level level, const char *format, va_list args)" startline="67" endline="72">
static int libbpf_print_fn (enum libbpf_print_level level, const char *format, va_list args)
{
    if (level == LIBBPF_DEBUG && !env.verbose)
        return 0;
    return vfprintf (stderr, format, args);
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/readahead.c" funcheader="static void sig_handler (int sig)" startline="74" endline="77">
static void sig_handler (int sig)
{
    exiting = true;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/readahead.c" funcheader="static int readahead__set_attach_target (struct bpf_program *prog)" startline="79" endline="95">
static int readahead__set_attach_target (struct bpf_program *prog)
{
    int err;
    err = bpf_program__set_attach_target (prog, 0, "do_page_cache_ra");
    if (!err)
        return 0;
    err = bpf_program__set_attach_target (prog, 0, "__do_page_cache_readahead");
    if (!err)
        return 0;
    fprintf (stderr, "failed to set attach target for %s: %s\n", bpf_program__name (prog), strerror (-err));
    return err;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/readahead.c" funcheader="int main (int argc, char **argv)" startline="97" endline="165">
int main (int argc, char **argv)
{
    static const struct argp argp = {
        .options = opts,
        .parser = parse_arg,
        .doc = argp_program_doc,}
    ;
    struct readahead_bpf *obj;
    struct hist *histp;
    int err;
    err = argp_parse (& argp, argc, argv, 0, NULL, NULL);
    if (err)
        return err;
    libbpf_set_strict_mode (LIBBPF_STRICT_ALL);
    libbpf_set_print (libbpf_print_fn);
    obj = readahead_bpf__open ();
    if (!obj) {
        fprintf (stderr, "failed to open BPF object\n");
        return 1;
    }
    err = readahead__set_attach_target (obj -> progs.do_page_cache_ra);
    if (err)
        goto cleanup;
    err = readahead__set_attach_target (obj -> progs.do_page_cache_ra_ret);
    if (err)
        goto cleanup;
    err = readahead_bpf__load (obj);
    if (err) {
        fprintf (stderr, "failed to load BPF object\n");
        goto cleanup;
    }
    if (!obj->bss) {
        fprintf (stderr, "Memory-mapping BPF maps is supported starting from Linux 5.7, please upgrade.\n");
        goto cleanup;
    }
    err = readahead_bpf__attach (obj);
    if (err) {
        fprintf (stderr, "failed to attach BPF programs\n");
        goto cleanup;
    }
    signal (SIGINT, sig_handler);
    printf ("Tracing fs read-ahead ... Hit Ctrl-C to end.\n");
    sleep (env.duration);
    printf ("\n");
    histp = &obj->bss->hist;
    printf ("Readahead unused/total pages: %d/%d\n", histp->unused, histp->total);
    print_log2_hist (histp->slots, MAX_SLOTS, "msecs");
cleanup :
    readahead_bpf__destroy (obj);
    return err != 0;
}
</source>
</doc>
