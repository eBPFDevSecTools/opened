<?xml version="1.0"?>
<doc>
<source file="/home/sayandes/opened_extraction/examples/hxdp_xdp_progs/xdp_csum_kern.c" funcheader="static void swap_src_dst_mac (void *data)" startline="26" endline="40">
static void swap_src_dst_mac (void *data)
{
    unsigned short *p = data;
    unsigned short dst [3];
    dst[0] = p[0];
    dst[1] = p[1];
    dst[2] = p[2];
    p[0] = p[3];
    p[1] = p[4];
    p[2] = p[5];
    p[3] = dst[0];
    p[4] = dst[1];
    p[5] = dst[2];
}
</source>
<source file="/home/sayandes/opened_extraction/examples/hxdp_xdp_progs/xdp_csum_kern.c" funcheader="static __always_inline __u16 csum_fold_helper (__u32 csum)" startline="42" endline="45">
static __always_inline __u16 csum_fold_helper (__u32 csum)
{
    return ~((csum & 0xffff) + (csum >> 16));
}
</source>
<source file="/home/sayandes/opened_extraction/examples/hxdp_xdp_progs/xdp_csum_kern.c" funcheader="static __always_inline void ipv4_csum (void *data_start, int data_size, __u32 *csum)" startline="47" endline="52">
static __always_inline void ipv4_csum (void *data_start, int data_size, __u32 *csum)
{
    *csum = bpf_csum_diff (0, 0, data_start, data_size, *csum);
    *csum = csum_fold_helper (*csum);
}
</source>
<source file="/home/sayandes/opened_extraction/examples/hxdp_xdp_progs/xdp_csum_kern.c" funcheader="int xdp_prog1 (struct xdp_md *ctx)" startline="55" endline="99">
int xdp_prog1 (struct xdp_md *ctx)
{
    void *data_end = (void *) (long) ctx->data_end;
    void *data = (void *) (long) ctx->data;
    struct ethhdr *eth = data;
    struct iphdr *iph;
    int rc = XDP_DROP;
    long *value;
    u16 h_proto;
    u64 nh_off;
    u32 dummy_int = 23;
    __u32 csum = 0;
    int i = 0;
    nh_off = sizeof (*eth);
    if (data + nh_off > data_end)
        return rc;
    h_proto = eth->h_proto;
    if (h_proto != htons (ETH_P_IP))
        return rc;
    iph = data + nh_off;
    nh_off += sizeof (*iph);
    if (data + nh_off > data_end)
        return rc;
    for (i = 0; i < LOOP_LEN; i++) {
        ipv4_csum (iph, sizeof (struct iphdr), &csum);
        iph->check = csum;
        value = bpf_map_lookup_elem (& rxcnt, & dummy_int);
    }
    value = bpf_map_lookup_elem (& rxcnt, & dummy_int);
    if (value)
        *value += 1;
    return rc;
}
</source>
</doc>
