<?xml version="1.0"?>
<doc>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/opensnoop.bpf.c" funcheader="static __always_inline bool valid_uid (uid_t uid)" startline="26" endline="28">
static __always_inline bool valid_uid (uid_t uid)
{
    return uid != INVALID_UID;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/opensnoop.bpf.c" funcheader="static __always_inline bool trace_allowed (u32 tgid, u32 pid)" startline="30" endline="47">
static __always_inline bool trace_allowed (u32 tgid, u32 pid)
{
    u32 uid;
    if (targ_tgid && targ_tgid != tgid)
        return false;
    if (targ_pid && targ_pid != pid)
        return false;
    if (valid_uid (targ_uid)) {
        uid = (u32) bpf_get_current_uid_gid ();
        if (targ_uid != uid) {
            return false;
        }
    }
    return true;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/opensnoop.bpf.c" funcheader="int tracepoint__syscalls__sys_enter_open (struct trace_event_raw_sys_enter *ctx)" startline="50" endline="65">
int tracepoint__syscalls__sys_enter_open (struct trace_event_raw_sys_enter *ctx)
{
    u64 id = bpf_get_current_pid_tgid ();
    u32 tgid = id >> 32;
    u32 pid = id;
    if (trace_allowed (tgid, pid)) {
        struct args_t args = {}
        ;
        args.fname = (const char *) ctx->args[0];
        args.flags = (int) ctx->args[1];
        bpf_map_update_elem (&start, &pid, &args, 0);
    }
    return 0;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/opensnoop.bpf.c" funcheader="int tracepoint__syscalls__sys_enter_openat (struct trace_event_raw_sys_enter *ctx)" startline="68" endline="83">
int tracepoint__syscalls__sys_enter_openat (struct trace_event_raw_sys_enter *ctx)
{
    u64 id = bpf_get_current_pid_tgid ();
    u32 tgid = id >> 32;
    u32 pid = id;
    if (trace_allowed (tgid, pid)) {
        struct args_t args = {}
        ;
        args.fname = (const char *) ctx->args[1];
        args.flags = (int) ctx->args[2];
        bpf_map_update_elem (&start, &pid, &args, 0);
    }
    return 0;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/opensnoop.bpf.c" funcheader="static __always_inline int trace_exit (struct trace_event_raw_sys_exit *ctx)" startline="85" endline="122">
static __always_inline int trace_exit (struct trace_event_raw_sys_exit *ctx)
{
    struct event event = {}
    ;
    struct args_t *ap;
    uintptr_t stack [3];
    int ret;
    u32 pid = bpf_get_current_pid_tgid ();
    ap = bpf_map_lookup_elem (& start, & pid);
    if (!ap)
        return 0;
    ret = ctx->ret;
    if (targ_failed && ret >= 0)
        goto cleanup;
    event.pid = bpf_get_current_pid_tgid () >> 32;
    event.uid = bpf_get_current_uid_gid ();
    bpf_get_current_comm (&event.comm, sizeof (event.comm));
    bpf_probe_read_user_str (&event.fname, sizeof (event.fname), ap->fname);
    event.flags = ap->flags;
    event.ret = ret;
    bpf_get_stack (ctx, &stack, sizeof (stack), BPF_F_USER_STACK);
    event.callers[0] = stack[1];
    event.callers[1] = stack[2];
    bpf_perf_event_output (ctx, &events, BPF_F_CURRENT_CPU, &event, sizeof (event));
cleanup :
    bpf_map_delete_elem (&start, &pid);
    return 0;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/opensnoop.bpf.c" funcheader="int tracepoint__syscalls__sys_exit_open (struct trace_event_raw_sys_exit *ctx)" startline="125" endline="128">
int tracepoint__syscalls__sys_exit_open (struct trace_event_raw_sys_exit *ctx)
{
    return trace_exit (ctx);
}
</source>
<source file="/home/sayandes/opened_extraction/examples/bcc-libbpf-tools-main/opensnoop.bpf.c" funcheader="int tracepoint__syscalls__sys_exit_openat (struct trace_event_raw_sys_exit *ctx)" startline="131" endline="134">
int tracepoint__syscalls__sys_exit_openat (struct trace_event_raw_sys_exit *ctx)
{
    return trace_exit (ctx);
}
</source>
</doc>
