<?xml version="1.0"?>
<doc>
<source file="/home/sayandes/opened_extraction/examples/sk-accelerate-main/src/sockmap_redir.c" funcheader="static inline void sk_msg_extract4_key (struct sk_msg_md *msg, struct sock_key *key)" startline="9" endline="19">
static inline void sk_msg_extract4_key (struct sk_msg_md *msg, struct sock_key *key)
{
    key->src.ip4 = msg->remote_ip4;
    key->dst.ip4 = msg->local_ip4;
    key->family = 2;
    key->dport = (bpf_htonl (msg->local_port) >> 16);
    key->sport = READ_ONCE (msg->remote_port) >> 16;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/sk-accelerate-main/src/sockmap_redir.c" funcheader="static inline void sk_msg_extract6_key (struct sk_msg_md *msg, struct sock_key *key)" startline="21" endline="41">
static inline void sk_msg_extract6_key (struct sk_msg_md *msg, struct sock_key *key)
{
    key->src.ip6[0] = msg->remote_ip6[0];
    key->src.ip6[1] = msg->remote_ip6[1];
    key->src.ip6[2] = msg->remote_ip6[2];
    key->src.ip6[3] = msg->remote_ip6[3];
    key->dst.ip6[0] = msg->local_ip6[0];
    key->dst.ip6[1] = msg->local_ip6[1];
    key->dst.ip6[2] = msg->local_ip6[2];
    key->dst.ip6[3] = msg->local_ip6[3];
    key->family = 10;
    key->dport = (bpf_htonl (msg->local_port) >> 16);
    key->sport = READ_ONCE (msg->remote_port) >> 16;
}
</source>
<source file="/home/sayandes/opened_extraction/examples/sk-accelerate-main/src/sockmap_redir.c" funcheader="int bpf_tcpip_bypass (struct sk_msg_md *msg)" startline="44" endline="69">
int bpf_tcpip_bypass (struct sk_msg_md *msg)
{
    struct sock_key key = {}
    ;
    if (msg->family == 2)
        sk_msg_extract4_key (msg, &key);
    else if (msg->family == 10) {
        if (msg->remote_ip4)
            sk_msg_extract4_key (msg, &key);
        else
            sk_msg_extract6_key (msg, &key);
    }
    else
        return SK_PASS;
    struct sock_key *aux_key;
    aux_key = bpf_map_lookup_elem (& sock_ops_aux_map, & key);
    if (aux_key) {
        bpf_msg_redirect_hash (msg, &sock_ops_map, aux_key, BPF_F_INGRESS);
    }
    else {
        bpf_msg_redirect_hash (msg, &sock_ops_map, &key, BPF_F_INGRESS);
    }
    return SK_PASS;
}
</source>
</doc>
