{"set_flags": [{"capabilities": [], "helperCallParams": {}, "startLine": 79, "endLine": 104, "File": "/home/sayandes/opened_extraction/examples/netobserv-bpf-main/flows.c", "funcName": "set_flags", "updateMaps": [], "readMaps": [], "input": ["struct tcphdr *th", " u16 *flags"], "output": "staticinlinevoid", "helper": [], "compatibleHookpoints": ["cgroup_sock_addr", "lwt_in", "flow_dissector", "cgroup_device", "sched_act", "lwt_seg6local", "tracepoint", "sk_msg", "cgroup_sysctl", "kprobe", "sock_ops", "cgroup_skb", "sched_cls", "sk_reuseport", "sk_skb", "lwt_out", "lwt_xmit", "cgroup_sock", "perf_event", "raw_tracepoint_writable", "socket_filter", "raw_tracepoint", "xdp"], "source": ["static inline void set_flags (struct tcphdr *th, u16 *flags)\n", "{\n", "    if (th->ack && th->syn) {\n", "        *flags |= SYN_ACK_FLAG;\n", "    }\n", "    else if (th->ack && th->fin) {\n", "        *flags |= FIN_ACK_FLAG;\n", "    }\n", "    else if (th->ack && th->rst) {\n", "        *flags |= RST_ACK_FLAG;\n", "    }\n", "    else if (th->fin) {\n", "        *flags |= FIN_FLAG;\n", "    }\n", "    else if (th->syn) {\n", "        *flags |= SYN_FLAG;\n", "    }\n", "    else if (th->rst) {\n", "        *flags |= RST_FLAG;\n", "    }\n", "    else if (th->psh) {\n", "        *flags |= PSH_FLAG;\n", "    }\n", "    else if (th->urg) {\n", "        *flags |= URG_FLAG;\n", "    }\n", "    else if (th->ece) {\n", "        *flags |= ECE_FLAG;\n", "    }\n", "    else if (th->cwr) {\n", "        *flags |= CWR_FLAG;\n", "    }\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "fill_iphdr": [{"capabilities": [], "helperCallParams": {}, "startLine": 106, "endLine": 138, "File": "/home/sayandes/opened_extraction/examples/netobserv-bpf-main/flows.c", "funcName": "fill_iphdr", "updateMaps": [], "readMaps": [], "input": ["struct iphdr *ip", " void *data_end", " flow_id *id", " u16 *flags"], "output": "staticinlineint", "helper": [], "compatibleHookpoints": ["cgroup_sock_addr", "lwt_in", "flow_dissector", "cgroup_device", "sched_act", "lwt_seg6local", "tracepoint", "sk_msg", "cgroup_sysctl", "kprobe", "sock_ops", "cgroup_skb", "sched_cls", "sk_reuseport", "sk_skb", "lwt_out", "lwt_xmit", "cgroup_sock", "perf_event", "raw_tracepoint_writable", "socket_filter", "raw_tracepoint", "xdp"], "source": ["static inline int fill_iphdr (struct iphdr *ip, void *data_end, flow_id *id, u16 *flags)\n", "{\n", "    if ((void *) ip + sizeof (*ip) > data_end) {\n", "        return DISCARD;\n", "    }\n", "    __builtin_memcpy (id->src_ip.s6_addr, ip4in6, sizeof (ip4in6));\n", "    __builtin_memcpy (id->dst_ip.s6_addr, ip4in6, sizeof (ip4in6));\n", "    __builtin_memcpy (id->src_ip.s6_addr + sizeof (ip4in6), &ip->saddr, sizeof (ip->saddr));\n", "    __builtin_memcpy (id->dst_ip.s6_addr + sizeof (ip4in6), &ip->daddr, sizeof (ip->daddr));\n", "    id->transport_protocol = ip->protocol;\n", "    id->src_port = 0;\n", "    id->dst_port = 0;\n", "    switch (ip->protocol) {\n", "    case IPPROTO_TCP :\n", "        {\n", "            struct tcphdr *tcp = (void *) ip + sizeof (*ip);\n", "            if ((void *) tcp + sizeof (*tcp) <= data_end) {\n", "                id->src_port = __bpf_ntohs (tcp->source);\n", "                id->dst_port = __bpf_ntohs (tcp->dest);\n", "                set_flags (tcp, flags);\n", "            }\n", "        }\n", "        break;\n", "    case IPPROTO_UDP :\n", "        {\n", "            struct udphdr *udp = (void *) ip + sizeof (*ip);\n", "            if ((void *) udp + sizeof (*udp) <= data_end) {\n", "                id->src_port = __bpf_ntohs (udp->source);\n", "                id->dst_port = __bpf_ntohs (udp->dest);\n", "            }\n", "        }\n", "        break;\n", "    default :\n", "        break;\n", "    }\n", "    return SUBMIT;\n", "}\n"], "called_function_list": ["set_flags"], "call_depth": 1, "humanFuncDescription": [{}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "fill_ip6hdr": [{"capabilities": [], "helperCallParams": {}, "startLine": 141, "endLine": 171, "File": "/home/sayandes/opened_extraction/examples/netobserv-bpf-main/flows.c", "funcName": "fill_ip6hdr", "updateMaps": [], "readMaps": [], "input": ["struct ipv6hdr *ip", " void *data_end", " flow_id *id", " u16 *flags"], "output": "staticinlineint", "helper": [], "compatibleHookpoints": ["cgroup_sock_addr", "lwt_in", "flow_dissector", "cgroup_device", "sched_act", "lwt_seg6local", "tracepoint", "sk_msg", "cgroup_sysctl", "kprobe", "sock_ops", "cgroup_skb", "sched_cls", "sk_reuseport", "sk_skb", "lwt_out", "lwt_xmit", "cgroup_sock", "perf_event", "raw_tracepoint_writable", "socket_filter", "raw_tracepoint", "xdp"], "source": ["static inline int fill_ip6hdr (struct ipv6hdr *ip, void *data_end, flow_id *id, u16 *flags)\n", "{\n", "    if ((void *) ip + sizeof (*ip) > data_end) {\n", "        return DISCARD;\n", "    }\n", "    id->src_ip = ip->saddr;\n", "    id->dst_ip = ip->daddr;\n", "    id->transport_protocol = ip->nexthdr;\n", "    id->src_port = 0;\n", "    id->dst_port = 0;\n", "    switch (ip->nexthdr) {\n", "    case IPPROTO_TCP :\n", "        {\n", "            struct tcphdr *tcp = (void *) ip + sizeof (*ip);\n", "            if ((void *) tcp + sizeof (*tcp) <= data_end) {\n", "                id->src_port = __bpf_ntohs (tcp->source);\n", "                id->dst_port = __bpf_ntohs (tcp->dest);\n", "                set_flags (tcp, flags);\n", "            }\n", "        }\n", "        break;\n", "    case IPPROTO_UDP :\n", "        {\n", "            struct udphdr *udp = (void *) ip + sizeof (*ip);\n", "            if ((void *) udp + sizeof (*udp) <= data_end) {\n", "                id->src_port = __bpf_ntohs (udp->source);\n", "                id->dst_port = __bpf_ntohs (udp->dest);\n", "            }\n", "        }\n", "        break;\n", "    default :\n", "        break;\n", "    }\n", "    return SUBMIT;\n", "}\n"], "called_function_list": ["set_flags"], "call_depth": 1, "humanFuncDescription": [{}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "fill_ethhdr": [{"capabilities": [], "helperCallParams": {}, "startLine": 173, "endLine": 197, "File": "/home/sayandes/opened_extraction/examples/netobserv-bpf-main/flows.c", "funcName": "fill_ethhdr", "updateMaps": [], "readMaps": [], "input": ["struct ethhdr *eth", " void *data_end", " flow_id *id", " u16 *flags"], "output": "staticinlineint", "helper": [], "compatibleHookpoints": ["cgroup_sock_addr", "lwt_in", "flow_dissector", "cgroup_device", "sched_act", "lwt_seg6local", "tracepoint", "sk_msg", "cgroup_sysctl", "kprobe", "sock_ops", "cgroup_skb", "sched_cls", "sk_reuseport", "sk_skb", "lwt_out", "lwt_xmit", "cgroup_sock", "perf_event", "raw_tracepoint_writable", "socket_filter", "raw_tracepoint", "xdp"], "source": ["static inline int fill_ethhdr (struct ethhdr *eth, void *data_end, flow_id *id, u16 *flags)\n", "{\n", "    if ((void *) eth + sizeof (*eth) > data_end) {\n", "        return DISCARD;\n", "    }\n", "    __builtin_memcpy (id->dst_mac, eth->h_dest, ETH_ALEN);\n", "    __builtin_memcpy (id->src_mac, eth->h_source, ETH_ALEN);\n", "    id->eth_protocol = __bpf_ntohs (eth->h_proto);\n", "    if (id->eth_protocol == ETH_P_IP) {\n", "        struct iphdr *ip = (void *) eth + sizeof (*eth);\n", "        return fill_iphdr (ip, data_end, id, flags);\n", "    }\n", "    else if (id->eth_protocol == ETH_P_IPV6) {\n", "        struct ipv6hdr *ip6 = (void *) eth + sizeof (*eth);\n", "        return fill_ip6hdr (ip6, data_end, id, flags);\n", "    }\n", "    else {\n", "        memset (&(id->src_ip), 0, sizeof (struct in6_addr));\n", "        memset (&(id->dst_ip), 0, sizeof (struct in6_addr));\n", "        id->transport_protocol = 0;\n", "        id->src_port = 0;\n", "        id->dst_port = 0;\n", "    }\n", "    return SUBMIT;\n", "}\n"], "called_function_list": ["fill_ip6hdr", "fill_iphdr"], "call_depth": 2, "humanFuncDescription": [{}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "flow_monitor": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "libbpf", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}, {"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}, {"capability": "map_update", "map_update": [{"Project": "libbpf", "Return Type": "int", "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_map_update_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}", "{Type:  const void ,Var: *value}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_update"]}]}, {"capability": "read_sys_info", "read_sys_info": [{"Project": "bcc", "FunctionName": "bpf_ktime_get_ns", "Return Type": "u64", "Description": "u64 bpf_ktime_get_ns(void) Return: u64 number of nanoseconds. Starts at system boot time but stops during suspend. Examples in situ: \"https://github.com/iovisor/bcc/search?q=bpf_ktime_get_ns+path%3Aexamples&type=Code search /examples , \"https://github.com/iovisor/bcc/search?q=bpf_ktime_get_ns+path%3Atools&type=Code search /tools ", "Return": "u64 number of nanoseconds", "Input Prameters": [], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "raw_tracepoint_writable"], "capabilities": ["read_sys_info"]}]}], "helperCallParams": {}, "startLine": 199, "endLine": 276, "File": "/home/sayandes/opened_extraction/examples/netobserv-bpf-main/flows.c", "funcName": "flow_monitor", "updateMaps": ["  aggregated_flows"], "readMaps": [" aggregated_flows"], "input": ["struct  __sk_buff *skb", " u8 direction"], "output": "staticinlineint", "helper": ["bpf_map_lookup_elem", "TC_ACT_OK", "bpf_map_update_elem", "bpf_ktime_get_ns"], "compatibleHookpoints": ["sched_cls", "sched_act"], "source": ["static inline int flow_monitor (struct  __sk_buff *skb, u8 direction)\n", "{\n", "    if (sampling != 0 && (bpf_get_prandom_u32 () % sampling) != 0) {\n", "        return TC_ACT_OK;\n", "    }\n", "    void *data_end = (void *) (long) skb->data_end;\n", "    void *data = (void *) (long) skb->data;\n", "    flow_id id;\n", "    u64 current_time = bpf_ktime_get_ns ();\n", "    struct ethhdr *eth = data;\n", "    u16 flags = 0;\n", "    if (fill_ethhdr (eth, data_end, &id, &flags) == DISCARD) {\n", "        return TC_ACT_OK;\n", "    }\n", "    id.if_index = skb->ifindex;\n", "    id.direction = direction;\n", "    flow_metrics *aggregate_flow = bpf_map_lookup_elem (&aggregated_flows, &id);\n", "    if (aggregate_flow != NULL) {\n", "        aggregate_flow->packets += 1;\n", "        aggregate_flow->bytes += skb->len;\n", "        aggregate_flow->end_mono_time_ts = current_time;\n", "        if (aggregate_flow->start_mono_time_ts == 0) {\n", "            aggregate_flow->start_mono_time_ts = current_time;\n", "        }\n", "        aggregate_flow->flags |= flags;\n", "        long ret = bpf_map_update_elem (& aggregated_flows, & id, aggregate_flow, BPF_ANY);\n", "        if (trace_messages && ret != 0) {\n", "            bpf_printk (\"error updating flow %d\\n\", ret);\n", "        }\n", "    }\n", "    else {\n", "        flow_metrics new_flow = {\n", "            .packets = 1,\n", "            .bytes = skb->len,\n", "            .start_mono_time_ts = current_time,\n", "            .end_mono_time_ts = current_time,\n", "            .flags = flags,}\n", "        ;\n", "        long ret = bpf_map_update_elem (& aggregated_flows, & id, & new_flow, BPF_ANY);\n", "        if (ret != 0) {\n", "            if (trace_messages) {\n", "                bpf_printk (\"error adding flow %d\\n\", ret);\n", "            }\n", "            new_flow.errno = -ret;\n", "            flow_record *record = bpf_ringbuf_reserve (&direct_flows, sizeof (flow_record), 0);\n", "            if (!record) {\n", "                if (trace_messages) {\n", "                    bpf_printk (\"couldn't reserve space in the ringbuf. Dropping flow\");\n", "                }\n", "                return TC_ACT_OK;\n", "            }\n", "            record->id = id;\n", "            record->metrics = new_flow;\n", "            bpf_ringbuf_submit (record, 0);\n", "        }\n", "    }\n", "    return TC_ACT_OK;\n", "}\n"], "called_function_list": ["fill_ethhdr"], "call_depth": 3, "humanFuncDescription": [{}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ingress_flow_parse": [{"capabilities": [], "helperCallParams": {}, "startLine": 278, "endLine": 280, "File": "/home/sayandes/opened_extraction/examples/netobserv-bpf-main/flows.c", "funcName": "ingress_flow_parse", "updateMaps": [], "readMaps": [], "input": ["struct  __sk_buff *skb"], "output": "int", "helper": [], "compatibleHookpoints": ["cgroup_sock_addr", "lwt_in", "flow_dissector", "cgroup_device", "sched_act", "lwt_seg6local", "tracepoint", "sk_msg", "cgroup_sysctl", "kprobe", "sock_ops", "cgroup_skb", "sched_cls", "sk_reuseport", "sk_skb", "lwt_out", "lwt_xmit", "cgroup_sock", "perf_event", "raw_tracepoint_writable", "socket_filter", "raw_tracepoint", "xdp"], "source": ["int ingress_flow_parse (struct  __sk_buff *skb)\n", "{\n", "    return flow_monitor (skb, INGRESS);\n", "}\n"], "called_function_list": ["flow_monitor"], "call_depth": 4, "humanFuncDescription": [{}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "egress_flow_parse": [{"capabilities": [], "helperCallParams": {}, "startLine": 283, "endLine": 285, "File": "/home/sayandes/opened_extraction/examples/netobserv-bpf-main/flows.c", "funcName": "egress_flow_parse", "updateMaps": [], "readMaps": [], "input": ["struct  __sk_buff *skb"], "output": "int", "helper": [], "compatibleHookpoints": ["cgroup_sock_addr", "lwt_in", "flow_dissector", "cgroup_device", "sched_act", "lwt_seg6local", "tracepoint", "sk_msg", "cgroup_sysctl", "kprobe", "sock_ops", "cgroup_skb", "sched_cls", "sk_reuseport", "sk_skb", "lwt_out", "lwt_xmit", "cgroup_sock", "perf_event", "raw_tracepoint_writable", "socket_filter", "raw_tracepoint", "xdp"], "source": ["int egress_flow_parse (struct  __sk_buff *skb)\n", "{\n", "    return flow_monitor (skb, EGRESS);\n", "}\n"], "called_function_list": ["flow_monitor"], "call_depth": 4, "humanFuncDescription": [{}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "bpf_tail_call_static": [{"capabilities": [], "helperCallParams": {}, "startLine": 98, "endLine": 123, "File": "/home/sayandes/opened_extraction/examples/netobserv-bpf-main/headers/bpf_helpers.h", "funcName": "bpf_tail_call_static", "updateMaps": [], "readMaps": [], "input": ["void *ctx", " const void *map", " const __u32 slot"], "output": "static__always_inlinevoid", "helper": ["bpf_tail_call"], "compatibleHookpoints": ["cgroup_sock_addr", "lwt_in", "flow_dissector", "sched_act", "lwt_seg6local", "tracepoint", "sk_msg", "kprobe", "sock_ops", "cgroup_skb", "sched_cls", "sk_reuseport", "sk_skb", "lwt_out", "lwt_xmit", "cgroup_sock", "perf_event", "raw_tracepoint_writable", "socket_filter", "raw_tracepoint", "xdp"], "source": ["static __always_inline void bpf_tail_call_static (void *ctx, const void *map, const __u32 slot)\n", "{\n", "    if (!__builtin_constant_p (slot))\n", "        __bpf_unreachable ();\n", "    asm volatile (\"r1 = %[ctx]\\n\\t\"\n", "        \"r2 = %[map]\\n\\t\"\n", "        \"r3 = %[slot]\\n\\t\"\n", "        \"call 12\"\n", "        : : [ctx] \"r\"\n", "        (ctx), [map] \"r\"\n", "        (map), [slot] \"i\"\n", "        (slot) : \"r0\",\n", "        \"r1\",\n", "        \"r2\",\n", "        \"r3\",\n", "        \"r4\",\n", "        \"r5\"\n", "        );\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}]}