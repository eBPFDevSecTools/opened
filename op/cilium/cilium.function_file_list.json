{"main": [{"capabilities": [], "helperCallParams": {}, "startLine": 44, "endLine": 99, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_alignchecker.c", "funcName": "main", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["void"], "output": "int", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["int main (void)\n", "{\n", "    DECLARE (struct ipv4_ct_tuple);\n", "    DECLARE (struct ipv6_ct_tuple);\n", "    DECLARE (struct ct_entry);\n", "    DECLARE (struct ipcache_key);\n", "    DECLARE (struct remote_endpoint_info);\n", "    DECLARE (struct lb4_key);\n", "    DECLARE (struct lb4_service);\n", "    DECLARE (struct lb4_backend);\n", "    DECLARE (struct lb6_key);\n", "    DECLARE (struct lb6_service);\n", "    DECLARE (struct lb6_backend);\n", "    DECLARE (struct endpoint_key);\n", "    DECLARE (struct endpoint_info);\n", "    DECLARE (struct metrics_key);\n", "    DECLARE (struct metrics_value);\n", "    DECLARE (struct sock_key);\n", "    DECLARE (struct policy_key);\n", "    DECLARE (struct policy_entry);\n", "    DECLARE (struct ipv4_nat_entry);\n", "    DECLARE (struct ipv6_nat_entry);\n", "    DECLARE (struct trace_notify);\n", "    DECLARE (struct drop_notify);\n", "    DECLARE (struct policy_verdict_notify);\n", "    DECLARE (struct debug_msg);\n", "    DECLARE (struct debug_capture_msg);\n", "    DECLARE (struct ipv4_revnat_tuple);\n", "    DECLARE (struct ipv4_revnat_entry);\n", "    DECLARE (struct ipv6_revnat_tuple);\n", "    DECLARE (struct ipv6_revnat_entry);\n", "    DECLARE (struct ipv4_frag_id);\n", "    DECLARE (struct ipv4_frag_l4ports);\n", "    DECLARE (union macaddr);\n", "    DECLARE (struct lb4_affinity_key);\n", "    DECLARE (struct lb6_affinity_key);\n", "    DECLARE (struct lb_affinity_val);\n", "    DECLARE (struct lb_affinity_match);\n", "    DECLARE (struct lb4_src_range_key);\n", "    DECLARE (struct lb6_src_range_key);\n", "    DECLARE (struct edt_id);\n", "    DECLARE (struct edt_info);\n", "    DECLARE (struct egress_gw_policy_key);\n", "    DECLARE (struct egress_gw_policy_entry);\n", "    DECLARE (struct vtep_key);\n", "    DECLARE (struct vtep_value);\n", "    DECLARE (struct capture4_wcard);\n", "    DECLARE (struct capture6_wcard);\n", "    DECLARE (struct capture_rule);\n", "    DECLARE (struct srv6_vrf_key4);\n", "    DECLARE (struct srv6_vrf_key6);\n", "    DECLARE (struct srv6_policy_key4);\n", "    DECLARE (struct srv6_policy_key6);\n", "    return 0;\n", "}\n"], "called_function_list": ["prep_kern_jiffies", "fix_priority", "fetch_kern_jiffies", "dump_kern_jiffies", "pin_to_cpu"], "call_depth": 1, "humanFuncDescription": [{"description": " Print and debug all the existing variables (especially fast path  sections that printk is not appropriate for) ", "author": "Shun Zhang", "authorEmail": "shunz@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 152, "endLine": 194, "File": "/home/sayandes/opened_extraction/examples/cilium/cilium-probe-kernel-hz.c", "funcName": "main", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["int argc", " char **argv"], "output": "int", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["int main (int argc, char **argv)\n", "{\n", "    struct cpu_jiffies before, after;\n", "    struct timespec tv = {\n", "        .tv_sec = 1,\n", "        .tv_nsec = 0,}\n", "    ;\n", "    int opt, sig, ret, tries = 4;\n", "    bool macro = false;\n", "    while ((opt = getopt (argc, argv, \"m\")) != -1) {\n", "        switch (opt) {\n", "        case 'm' :\n", "            macro = true;\n", "            break;\n", "        default :\n", "            return -1;\n", "        }\n", "    }\n", "    if (pin_to_cpu (0)) {\n", "        fprintf (stderr, \"Cannot pin to CPU 0: %s\\n\", strerror (errno));\n", "        return -1;\n", "    }\n", "    if (fix_priority ()) {\n", "        fprintf (stderr, \"Cannot set priority: %s\\n\", strerror (errno));\n", "        return -1;\n", "    }\n", "    if (prep_kern_jiffies (&before, &after)) {\n", "        fprintf (stderr, \"Cannot prep jiffies: %s\\n\", strerror (errno));\n", "        return -1;\n", "    }\n", "    do {\n", "        ret = fetch_kern_jiffies (& before);\n", "        sig = nanosleep (& tv, NULL);\n", "        ret += fetch_kern_jiffies (&after);\n", "    }\n", "    while (!ret && sig && errno == EINTR && --tries >= 0);\n", "    if (!ret && !sig)\n", "        ret = dump_kern_jiffies (&before, &after, macro);\n", "    return ret;\n", "}\n"], "called_function_list": ["prep_kern_jiffies", "fix_priority", "fetch_kern_jiffies", "dump_kern_jiffies", "pin_to_cpu"], "call_depth": 1, "humanFuncDescription": [{"description": " Main function of above functions, initialize the cpu and deal with the  jiffies  accordingly  ", "author": "Shun Zhang", "authorEmail": "shunz@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "bpf_xdp_exit": [{"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 96, "endLine": 117, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_xdp.c", "funcName": "bpf_xdp_exit", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " const int verdict"], "output": "static__always_inline__maybe_unusedint", "helper": ["CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["static __always_inline __maybe_unused int bpf_xdp_exit (struct  __ctx_buff *ctx, const int verdict)\n", "{\n", "    if (verdict == CTX_ACT_OK) {\n", "        __u32 meta_xfer = ctx_load_meta (ctx, XFER_MARKER);\n", "        if (meta_xfer) {\n", "            if (!ctx_adjust_meta (ctx, -(int) sizeof (meta_xfer))) {\n", "                __u32 *data_meta = ctx_data_meta (ctx);\n", "                __u32 *data = ctx_data (ctx);\n", "                if (!ctx_no_room (data_meta + 1, data))\n", "                    data_meta[0] = meta_xfer;\n", "            }\n", "        }\n", "    }\n", "    return verdict;\n", "}\n"], "called_function_list": ["ctx_data_meta", "ctx_no_room", "ctx_load_meta", "ctx_data"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "tail_lb_ipv4": [{"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 122, "endLine": 140, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_xdp.c", "funcName": "tail_lb_ipv4", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx"], "output": "int", "helper": ["CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["int tail_lb_ipv4 (struct  __ctx_buff *ctx)\n", "{\n", "    int ret = CTX_ACT_OK;\n", "    if (!bpf_skip_nodeport (ctx)) {\n", "        ret = nodeport_lb4 (ctx, 0);\n", "        if (ret == NAT_46X64_RECIRC) {\n", "            ep_tail_call (ctx, CILIUM_CALL_IPV6_FROM_NETDEV);\n", "            return send_drop_notify_error (ctx, 0, DROP_MISSED_TAIL_CALL, CTX_ACT_DROP, METRIC_INGRESS);\n", "        }\n", "        else if (IS_ERR (ret)) {\n", "            return send_drop_notify_error (ctx, 0, ret, CTX_ACT_DROP, METRIC_INGRESS);\n", "        }\n", "    }\n", "    return bpf_xdp_exit (ctx, ret);\n", "}\n"], "called_function_list": ["ep_tail_call", "nodeport_lb4", "bpf_xdp_exit", "bpf_skip_nodeport"], "call_depth": 6, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "check_v4_lb": [{"capabilities": [], "helperCallParams": {}, "startLine": 142, "endLine": 147, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_xdp.c", "funcName": "check_v4_lb", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int check_v4_lb (struct  __ctx_buff *ctx)\n", "{\n", "    ep_tail_call (ctx, CILIUM_CALL_IPV4_FROM_NETDEV);\n", "    return send_drop_notify_error (ctx, 0, DROP_MISSED_TAIL_CALL, CTX_ACT_DROP, METRIC_INGRESS);\n", "}\n"], "called_function_list": ["ep_tail_call"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 149, "endLine": 152, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_xdp.c", "funcName": "check_v4_lb", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff * ctx __maybe_unused"], "output": "static__always_inlineint", "helper": ["CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["static __always_inline int check_v4_lb (struct  __ctx_buff * ctx __maybe_unused)\n", "{\n", "    return CTX_ACT_OK;\n", "}\n"], "called_function_list": ["ep_tail_call"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "check_v4": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 156, "endLine": 179, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_xdp.c", "funcName": "check_v4", "developer_inline_comments": [], "updateMaps": [], "readMaps": [" CIDR4_LMAP_NAME", " CIDR4_HMAP_NAME"], "input": ["struct  __ctx_buff *ctx"], "output": "static__always_inlineint", "helper": ["map_lookup_elem"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int check_v4 (struct  __ctx_buff *ctx)\n", "{\n", "    void *data_end = ctx_data_end (ctx);\n", "    void *data = ctx_data (ctx);\n", "    struct iphdr *ipv4_hdr = data + sizeof (struct ethhdr);\n", "    struct lpm_v4_key pfx __maybe_unused;\n", "    if (ctx_no_room (ipv4_hdr + 1, data_end))\n", "        return CTX_ACT_DROP;\n", "\n", "#ifdef CIDR4_FILTER\n", "    memcpy (pfx.lpm.data, &ipv4_hdr->saddr, sizeof (pfx.addr));\n", "    pfx.lpm.prefixlen = 32;\n", "\n", "#ifdef CIDR4_LPM_PREFILTER\n", "    if (map_lookup_elem (&CIDR4_LMAP_NAME, &pfx))\n", "        return CTX_ACT_DROP;\n", "\n", "#endif /* CIDR4_LPM_PREFILTER */\n", "    return map_lookup_elem (&CIDR4_HMAP_NAME, &pfx) ? CTX_ACT_DROP : check_v4_lb (ctx);\n", "\n", "#else\n", "    return check_v4_lb (ctx);\n", "\n", "#endif /* CIDR4_FILTER */\n", "}\n"], "called_function_list": ["ctx_data_end", "memcpy", "ctx_no_room", "check_v4_lb", "ctx_data"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 181, "endLine": 184, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_xdp.c", "funcName": "check_v4", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int check_v4 (struct  __ctx_buff *ctx)\n", "{\n", "    return check_v4_lb (ctx);\n", "}\n"], "called_function_list": ["ctx_data_end", "memcpy", "ctx_no_room", "check_v4_lb", "ctx_data"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "tail_lb_ipv6": [{"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 191, "endLine": 203, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_xdp.c", "funcName": "tail_lb_ipv6", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx"], "output": "int", "helper": ["CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["int tail_lb_ipv6 (struct  __ctx_buff *ctx)\n", "{\n", "    int ret = CTX_ACT_OK;\n", "    if (!bpf_skip_nodeport (ctx)) {\n", "        ret = nodeport_lb6 (ctx, 0);\n", "        if (IS_ERR (ret))\n", "            return send_drop_notify_error (ctx, 0, ret, CTX_ACT_DROP, METRIC_INGRESS);\n", "    }\n", "    return bpf_xdp_exit (ctx, ret);\n", "}\n"], "called_function_list": ["nodeport_lb6", "bpf_xdp_exit", "bpf_skip_nodeport"], "call_depth": 4, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "check_v6_lb": [{"capabilities": [], "helperCallParams": {}, "startLine": 205, "endLine": 210, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_xdp.c", "funcName": "check_v6_lb", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int check_v6_lb (struct  __ctx_buff *ctx)\n", "{\n", "    ep_tail_call (ctx, CILIUM_CALL_IPV6_FROM_NETDEV);\n", "    return send_drop_notify_error (ctx, 0, DROP_MISSED_TAIL_CALL, CTX_ACT_DROP, METRIC_INGRESS);\n", "}\n"], "called_function_list": ["ep_tail_call"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 212, "endLine": 215, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_xdp.c", "funcName": "check_v6_lb", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff * ctx __maybe_unused"], "output": "static__always_inlineint", "helper": ["CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["static __always_inline int check_v6_lb (struct  __ctx_buff * ctx __maybe_unused)\n", "{\n", "    return CTX_ACT_OK;\n", "}\n"], "called_function_list": ["ep_tail_call"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "check_v6": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 219, "endLine": 242, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_xdp.c", "funcName": "check_v6", "developer_inline_comments": [], "updateMaps": [], "readMaps": [" CIDR6_HMAP_NAME", " CIDR6_LMAP_NAME"], "input": ["struct  __ctx_buff *ctx"], "output": "static__always_inlineint", "helper": ["map_lookup_elem"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int check_v6 (struct  __ctx_buff *ctx)\n", "{\n", "    void *data_end = ctx_data_end (ctx);\n", "    void *data = ctx_data (ctx);\n", "    struct ipv6hdr *ipv6_hdr = data + sizeof (struct ethhdr);\n", "    struct lpm_v6_key pfx __maybe_unused;\n", "    if (ctx_no_room (ipv6_hdr + 1, data_end))\n", "        return CTX_ACT_DROP;\n", "\n", "#ifdef CIDR6_FILTER\n", "    __bpf_memcpy_builtin (pfx.lpm.data, &ipv6_hdr->saddr, sizeof (pfx.addr));\n", "    pfx.lpm.prefixlen = 128;\n", "\n", "#ifdef CIDR6_LPM_PREFILTER\n", "    if (map_lookup_elem (&CIDR6_LMAP_NAME, &pfx))\n", "        return CTX_ACT_DROP;\n", "\n", "#endif /* CIDR6_LPM_PREFILTER */\n", "    return map_lookup_elem (&CIDR6_HMAP_NAME, &pfx) ? CTX_ACT_DROP : check_v6_lb (ctx);\n", "\n", "#else\n", "    return check_v6_lb (ctx);\n", "\n", "#endif /* CIDR6_FILTER */\n", "}\n"], "called_function_list": ["ctx_data_end", "ctx_no_room", "check_v6_lb", "ctx_data", "__bpf_memcpy_builtin"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 244, "endLine": 247, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_xdp.c", "funcName": "check_v6", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int check_v6 (struct  __ctx_buff *ctx)\n", "{\n", "    return check_v6_lb (ctx);\n", "}\n"], "called_function_list": ["ctx_data_end", "ctx_no_room", "check_v6_lb", "ctx_data", "__bpf_memcpy_builtin"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "check_filters": [{"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 251, "endLine": 278, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_xdp.c", "funcName": "check_filters", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx"], "output": "static__always_inlineint", "helper": ["CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["static __always_inline int check_filters (struct  __ctx_buff *ctx)\n", "{\n", "    int ret = CTX_ACT_OK;\n", "    __u16 proto;\n", "    if (!validate_ethertype (ctx, &proto))\n", "        return CTX_ACT_OK;\n", "    ctx_store_meta (ctx, XFER_MARKER, 0);\n", "    bpf_skip_nodeport_clear (ctx);\n", "    switch (proto) {\n", "\n", "#ifdef ENABLE_IPV4\n", "    case bpf_htons (ETH_P_IP) :\n", "        ret = check_v4 (ctx);\n", "        break;\n", "\n", "#endif /* ENABLE_IPV4 */\n", "\n", "#ifdef ENABLE_IPV6\n", "    case bpf_htons (ETH_P_IPV6) :\n", "        ret = check_v6 (ctx);\n", "        break;\n", "\n", "#endif /* ENABLE_IPV6 */\n", "    default :\n", "        break;\n", "    }\n", "    return bpf_xdp_exit (ctx, ret);\n", "}\n"], "called_function_list": ["ctx_store_meta", "validate_ethertype", "check_v4", "check_v6", "bpf_xdp_exit", "bpf_skip_nodeport_clear"], "call_depth": 3, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "bpf_xdp_entry": [{"capabilities": [], "helperCallParams": {}, "startLine": 281, "endLine": 284, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_xdp.c", "funcName": "bpf_xdp_entry", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx"], "output": "int", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["int bpf_xdp_entry (struct  __ctx_buff *ctx)\n", "{\n", "    return check_filters (ctx);\n", "}\n"], "called_function_list": ["check_filters"], "call_depth": 4, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "from_network": [{"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}, {"capability": "pkt_alter_or_redo_processing_or_interface", "pkt_alter_or_redo_processing_or_interface": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "CTX_ACT_REDIRECT", "Return": 7, "Description": "Cilium wrapper. This allows to redirect the skb to the same or another\u2019s device ingress or egress path together with the redirect() helper. Being able to inject the packet into another device\u2019s ingress or egress direction allows for full flexibility in packet forwarding with BPF. There are no requirements on the target networking device other than being a networking device itself, there is no need to run another instance of cls_bpf on the target device or other such restrictions.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_alter_or_redo_processing_or_interface"]}]}], "helperCallParams": {}, "startLine": 15, "endLine": 88, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_network.c", "funcName": "from_network", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx"], "output": "int", "helper": ["CTX_ACT_OK", "CTX_ACT_REDIRECT"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["int from_network (struct  __ctx_buff *ctx)\n", "{\n", "    int ret = CTX_ACT_OK;\n", "    __u16 proto __maybe_unused;\n", "    enum trace_reason reason = TRACE_REASON_UNKNOWN;\n", "    enum trace_point obs_point_to = TRACE_TO_STACK;\n", "    enum trace_point obs_point_from = TRACE_FROM_NETWORK;\n", "    bpf_clear_meta (ctx);\n", "    if ((ctx->mark & MARK_MAGIC_HOST_MASK) == MARK_MAGIC_DECRYPT)\n", "        obs_point_from = TRACE_FROM_STACK;\n", "\n", "#ifdef ENABLE_IPSEC\n", "    if (!validate_ethertype (ctx, &proto))\n", "        goto out;\n", "    ret = do_decrypt (ctx, proto);\n", "\n", "#endif\n", "\n", "#ifdef ENABLE_IPSEC\n", "    if ((ctx->mark & MARK_MAGIC_HOST_MASK) == MARK_MAGIC_DECRYPT)\n", "        reason = TRACE_REASON_ENCRYPTED;\n", "    if (ret == CTX_ACT_REDIRECT)\n", "        obs_point_to = TRACE_TO_HOST;\n", "\n", "#endif\n", "out :\n", "    send_trace_notify (ctx, obs_point_from, 0, 0, 0, ctx->ingress_ifindex, reason, TRACE_PAYLOAD_LEN);\n", "    send_trace_notify (ctx, obs_point_to, 0, 0, 0, ctx->ingress_ifindex, reason, TRACE_PAYLOAD_LEN);\n", "    return ret;\n", "}\n"], "called_function_list": ["bpf_clear_meta", "send_trace_notify", "validate_ethertype", "do_decrypt"], "call_depth": 3, "humanFuncDescription": [{"description": " Initialize the ctx buffer, passing protocols to the stack according to the imput packets (ESP packets coming from network; Non-ESP packets coming from network; Non-ESP packets coming from stack re-inserted by xfrm) ", "author": "Shun Zhang", "authorEmail": "shunz@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "handle_ipv6": [{"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 46, "endLine": 180, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_overlay.c", "funcName": "handle_ipv6", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " __u32 *identity"], "output": "static__always_inlineint", "helper": ["CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["static __always_inline int handle_ipv6 (struct  __ctx_buff *ctx, __u32 *identity)\n", "{\n", "    int ret, l3_off = ETH_HLEN, hdrlen;\n", "    void *data_end, *data;\n", "    struct ipv6hdr *ip6;\n", "    struct bpf_tunnel_key key = {}\n", "    ;\n", "    struct endpoint_info *ep;\n", "    bool decrypted;\n", "    if (!revalidate_data_pull (ctx, &data, &data_end, &ip6))\n", "        return DROP_INVALID;\n", "\n", "#ifdef ENABLE_NODEPORT\n", "    if (!bpf_skip_nodeport (ctx)) {\n", "        ret = nodeport_lb6 (ctx, * identity);\n", "        if (ret < 0)\n", "            return ret;\n", "    }\n", "\n", "#endif\n", "    ret = encap_remap_v6_host_address (ctx, false);\n", "    if (unlikely (ret < 0))\n", "        return ret;\n", "    if (!revalidate_data (ctx, &data, &data_end, &ip6))\n", "        return DROP_INVALID;\n", "    decrypted = ((ctx->mark & MARK_MAGIC_HOST_MASK) == MARK_MAGIC_DECRYPT);\n", "    if (decrypted) {\n", "        *identity = key.tunnel_id = get_identity (ctx);\n", "    }\n", "    else {\n", "        if (unlikely (ctx_get_tunnel_key (ctx, &key, sizeof (key), 0) < 0))\n", "            return DROP_NO_TUNNEL_KEY;\n", "        *identity = key.tunnel_id;\n", "        if (*identity == HOST_ID)\n", "            return DROP_INVALID_IDENTITY;\n", "        if (identity_is_remote_node (*identity)) {\n", "            struct remote_endpoint_info *info;\n", "            info = ipcache_lookup6 (& IPCACHE_MAP, (union v6addr *) & ip6 -> saddr, V6_CACHE_KEY_LEN);\n", "            if (info)\n", "                *identity = info->sec_label;\n", "        }\n", "    }\n", "    cilium_dbg (ctx, DBG_DECAP, key.tunnel_id, key.tunnel_label);\n", "\n", "#ifdef ENABLE_IPSEC\n", "    if (!decrypted) {\n", "        if (ip6->nexthdr != IPPROTO_ESP) {\n", "            update_metrics (ctx_full_len (ctx), METRIC_INGRESS, REASON_PLAINTEXT);\n", "            goto not_esp;\n", "        }\n", "        ctx->mark = MARK_MAGIC_DECRYPT;\n", "        set_identity_mark (ctx, *identity);\n", "        ctx_change_type (ctx, PACKET_HOST);\n", "        send_trace_notify (ctx, TRACE_TO_STACK, 0, 0, 0, ctx->ingress_ifindex, TRACE_REASON_ENCRYPTED, TRACE_PAYLOAD_LEN);\n", "        return CTX_ACT_OK;\n", "    }\n", "    ctx->mark = 0;\n", "not_esp :\n", "\n", "#endif\n", "    ep = lookup_ip6_endpoint (ip6);\n", "    if (ep) {\n", "        __u8 nexthdr;\n", "        if (ep->flags & ENDPOINT_F_HOST)\n", "            goto to_host;\n", "        nexthdr = ip6->nexthdr;\n", "        hdrlen = ipv6_hdrlen (ctx, & nexthdr);\n", "        if (hdrlen < 0)\n", "            return hdrlen;\n", "        return ipv6_local_delivery (ctx, l3_off, *identity, ep, METRIC_INGRESS, false);\n", "    }\n", "to_host :\n", "\n", "#ifdef HOST_IFINDEX\n", "    if (1) {\n", "        union macaddr host_mac = HOST_IFINDEX_MAC;\n", "        union macaddr router_mac = NODE_MAC;\n", "        ret = ipv6_l3 (ctx, ETH_HLEN, (__u8 *) & router_mac.addr, (__u8 *) & host_mac.addr, METRIC_INGRESS);\n", "        if (ret != CTX_ACT_OK)\n", "            return ret;\n", "        cilium_dbg_capture (ctx, DBG_CAPTURE_DELIVERY, HOST_IFINDEX);\n", "        return ctx_redirect (ctx, HOST_IFINDEX, 0);\n", "    }\n", "\n", "#else\n", "    return CTX_ACT_OK;\n", "\n", "#endif\n", "}\n"], "called_function_list": ["ep_tail_call", "nodeport_lb6", "ctx_full_len", "cilium_dbg_capture", "ctx_redirect", "is_srv6_packet", "set_identity_meta", "set_encrypt_dip", "encap_remap_v6_host_address", "ipv6_host_policy_ingress", "ctx_skip_host_fw", "update_metrics", "srv6_lookup_sid", "ipcache_lookup6", "ctx_get_xfer", "icmp6_host_handle", "set_encrypt_key_meta", "encap_and_redirect_with_nodeid", "ipv6_hdrlen", "lookup_ip6_endpoint", "encap_and_redirect_netdev", "set_identity_mark", "ipv6_local_delivery", "bpf_skip_nodeport", "rewrite_dmac_to_host", "identity_is_remote_node", "send_trace_notify", "get_min_encrypt_key", "ipv6_l3", "ipv6_host_policy_egress", "get_identity", "cilium_dbg"], "call_depth": 1, "humanFuncDescription": [{"description": " The main goal of handle_ipv6 is to check the different condition including  if nodeport, IPSEC is enabled and if the pulling data or decrypting gets error.  Then make different action to handle according situatoins to convert the IPV6 to a virtual  network which points to overlay. The first step is to verify the background by  using revalidate_data_pull and the pointer ctx (maybe the starting point of a protocol?).  Ret should be the new address of this IPV6 sector. If nodeport is not activated,  ret is set by encap_remap_v6_host address.Then check if the net is decrypted by using mark. Identity is equal to identity of ctx if the net is decrypted, but tunnel id if not. Check if the ID is equal to host_ID since any node encapsulating will map any HOST_ID source to be presented as REMOTE_NODE_ID, therefore any attempt to signal HOST_ID as source from a remote node can be dropped.After that, check esp protocol,ESPis a member of the Internet Protocol Security set of protocols that encrypt and authenticate the packets of data between computers using a Virtual Private Network. If ESP is activated, we set mark for the ID and change the type of ctx to packet_host to pass it up.If Esp is not activated, we look up the IPV6 address in list of local endpoints. If the endpoints reach the host, we go to the host  and set the ret, else we find the next headerlength and return that. ", "author": "Yichen Wang", "authorEmail": "wyichen@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [{"capability": "pkt_alter_or_redo_processing_or_interface", "pkt_alter_or_redo_processing_or_interface": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_REDIRECT", "Return": 7, "Description": "This allows to redirect the skb to the same or another\u2019s device ingress or egress path together with the bpf_redirect() helper. Being able to inject the packet into another device\u2019s ingress or egress direction allows for full flexibility in packet forwarding with BPF. There are no requirements on the target networking device other than being a networking device itself, there is no need to run another instance of cls_bpf on the target device or other such restrictions.", "compatible_hookpoints": ["sched_cls", "sched_act"], "capabilities": ["pkt_alter_or_redo_processing_or_interface"]}]}, {"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 178, "endLine": 351, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c", "funcName": "handle_ipv6", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " __u32 secctx", " const bool from_host"], "output": "static__always_inlineint", "helper": ["TC_ACT_REDIRECT", "CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "sched_act"], "source": ["static __always_inline int handle_ipv6 (struct  __ctx_buff *ctx, __u32 secctx, const bool from_host)\n", "{\n", "    struct trace_ctx __maybe_unused trace = {\n", "        .reason = TRACE_REASON_UNKNOWN,\n", "        .monitor = TRACE_PAYLOAD_LEN,}\n", "    ;\n", "    struct remote_endpoint_info *info = NULL;\n", "    void *data, *data_end;\n", "    struct ipv6hdr *ip6;\n", "    union v6addr *dst;\n", "    __u32 __maybe_unused remote_id = WORLD_ID;\n", "    int ret, l3_off = ETH_HLEN, hdrlen;\n", "    bool skip_redirect = false;\n", "    struct endpoint_info *ep;\n", "    __u8 nexthdr;\n", "    if (!revalidate_data (ctx, &data, &data_end, &ip6))\n", "        return DROP_INVALID;\n", "    nexthdr = ip6->nexthdr;\n", "    hdrlen = ipv6_hdrlen (ctx, & nexthdr);\n", "    if (hdrlen < 0)\n", "        return hdrlen;\n", "    if (likely (nexthdr == IPPROTO_ICMPV6)) {\n", "        ret = icmp6_host_handle (ctx);\n", "        if (ret == SKIP_HOST_FIREWALL)\n", "            goto skip_host_firewall;\n", "        if (IS_ERR (ret))\n", "            return ret;\n", "    }\n", "\n", "#ifdef ENABLE_NODEPORT\n", "    if (!from_host) {\n", "        if (ctx_get_xfer (ctx) != XFER_PKT_NO_SVC && !bpf_skip_nodeport (ctx)) {\n", "            ret = nodeport_lb6 (ctx, secctx);\n", "            if (ret < 0 || ret == TC_ACT_REDIRECT)\n", "                return ret;\n", "        }\n", "        if (!revalidate_data (ctx, &data, &data_end, &ip6))\n", "            return DROP_INVALID;\n", "    }\n", "\n", "#endif /* ENABLE_NODEPORT */\n", "\n", "#if defined(NO_REDIRECT) && !defined(ENABLE_HOST_ROUTING)\n", "    if (!from_host)\n", "        skip_redirect = true;\n", "\n", "#endif /* NO_REDIRECT && !ENABLE_HOST_ROUTING */\n", "\n", "#ifdef ENABLE_HOST_FIREWALL\n", "    if (from_host) {\n", "        ret = ipv6_host_policy_egress (ctx, secctx, & trace);\n", "        if (IS_ERR (ret))\n", "            return ret;\n", "    }\n", "    else if (!ctx_skip_host_fw (ctx)) {\n", "        ret = ipv6_host_policy_ingress (ctx, & remote_id, & trace);\n", "        if (IS_ERR (ret))\n", "            return ret;\n", "    }\n", "\n", "#endif /* ENABLE_HOST_FIREWALL */\n", "    if (skip_redirect)\n", "        return CTX_ACT_OK;\n", "skip_host_firewall :\n", "\n", "#ifdef ENABLE_SRV6\n", "    if (!from_host) {\n", "        if (is_srv6_packet (ip6) && srv6_lookup_sid (&ip6->daddr)) {\n", "            ep_tail_call (ctx, CILIUM_CALL_SRV6_DECAP);\n", "            return DROP_MISSED_TAIL_CALL;\n", "        }\n", "    }\n", "\n", "#endif /* ENABLE_SRV6 */\n", "    if (from_host) {\n", "        ret = rewrite_dmac_to_host (ctx, secctx);\n", "        if (IS_ERR (ret))\n", "            return ret;\n", "        if (!revalidate_data (ctx, &data, &data_end, &ip6))\n", "            return DROP_INVALID;\n", "    }\n", "    ep = lookup_ip6_endpoint (ip6);\n", "    if (ep) {\n", "        if (ep->flags & ENDPOINT_F_HOST)\n", "            return CTX_ACT_OK;\n", "        return ipv6_local_delivery (ctx, l3_off, secctx, ep, METRIC_INGRESS, from_host);\n", "    }\n", "    if (!from_host)\n", "        return CTX_ACT_OK;\n", "\n", "#ifdef TUNNEL_MODE\n", "    dst = (union v6addr *) &ip6->daddr;\n", "    info = ipcache_lookup6 (& IPCACHE_MAP, dst, V6_CACHE_KEY_LEN);\n", "    if (info != NULL && info->tunnel_endpoint != 0) {\n", "        ret = encap_and_redirect_with_nodeid (ctx, info -> tunnel_endpoint, info -> key, secctx, & trace);\n", "        if (ret == IPSEC_ENDPOINT)\n", "            return CTX_ACT_OK;\n", "        else\n", "            return ret;\n", "    }\n", "    else {\n", "        struct endpoint_key key = {}\n", "        ;\n", "        dst = (union v6addr *) &ip6->daddr;\n", "        key.ip6.p1 = dst->p1;\n", "        key.ip6.p2 = dst->p2;\n", "        key.ip6.p3 = dst->p3;\n", "        key.ip6.p4 = 0;\n", "        key.family = ENDPOINT_KEY_IPV6;\n", "        ret = encap_and_redirect_netdev (ctx, & key, secctx, & trace);\n", "        if (ret == IPSEC_ENDPOINT)\n", "            return CTX_ACT_OK;\n", "        else if (ret != DROP_NO_TUNNEL_ENDPOINT)\n", "            return ret;\n", "    }\n", "\n", "#endif\n", "    dst = (union v6addr *) &ip6->daddr;\n", "    info = ipcache_lookup6 (& IPCACHE_MAP, dst, V6_CACHE_KEY_LEN);\n", "    if (info == NULL || info->sec_label == WORLD_ID) {\n", "        return DROP_UNROUTABLE;\n", "    }\n", "\n", "#ifdef ENABLE_IPSEC\n", "    if (info && info->key && info->tunnel_endpoint) {\n", "        __u8 key = get_min_encrypt_key (info -> key);\n", "        set_encrypt_key_meta (ctx, key);\n", "\n", "#ifdef IP_POOLS\n", "        set_encrypt_dip (ctx, info->tunnel_endpoint);\n", "\n", "#else\n", "        set_identity_meta (ctx, secctx);\n", "\n", "#endif\n", "    }\n", "\n", "#endif\n", "    return CTX_ACT_OK;\n", "}\n"], "called_function_list": ["ep_tail_call", "nodeport_lb6", "ctx_full_len", "cilium_dbg_capture", "ctx_redirect", "is_srv6_packet", "set_identity_meta", "set_encrypt_dip", "encap_remap_v6_host_address", "ipv6_host_policy_ingress", "ctx_skip_host_fw", "update_metrics", "srv6_lookup_sid", "ipcache_lookup6", "ctx_get_xfer", "icmp6_host_handle", "set_encrypt_key_meta", "encap_and_redirect_with_nodeid", "ipv6_hdrlen", "lookup_ip6_endpoint", "encap_and_redirect_netdev", "set_identity_mark", "ipv6_local_delivery", "bpf_skip_nodeport", "rewrite_dmac_to_host", "identity_is_remote_node", "send_trace_notify", "get_min_encrypt_key", "ipv6_l3", "ipv6_host_policy_egress", "get_identity", "cilium_dbg"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "tail_handle_ipv6": [{"capabilities": [], "helperCallParams": {}, "startLine": 183, "endLine": 192, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_overlay.c", "funcName": "tail_handle_ipv6", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx"], "output": "int", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["int tail_handle_ipv6 (struct  __ctx_buff *ctx)\n", "{\n", "    __u32 src_identity = 0;\n", "    int ret = handle_ipv6 (ctx, & src_identity);\n", "    if (IS_ERR (ret))\n", "        return send_drop_notify_error (ctx, src_identity, ret, CTX_ACT_DROP, METRIC_INGRESS);\n", "    return ret;\n", "}\n"], "called_function_list": ["__tail_handle_ipv6", "handle_ipv6", "ctx_store_meta", "ctx_load_meta"], "call_depth": 1, "humanFuncDescription": [{"description": " This function is to handle the tail of a protocol and check it it has any error for ipv6 ", "author": "Yichen Wang", "authorEmail": "wyichen@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 697, "endLine": 705, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_lxc.c", "funcName": "tail_handle_ipv6", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx"], "output": "int", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["int tail_handle_ipv6 (struct  __ctx_buff *ctx)\n", "{\n", "    int ret = __tail_handle_ipv6 (ctx);\n", "    if (IS_ERR (ret))\n", "        return send_drop_notify_error (ctx, SECLABEL, ret, CTX_ACT_DROP, METRIC_EGRESS);\n", "    return ret;\n", "}\n"], "called_function_list": ["__tail_handle_ipv6", "handle_ipv6", "ctx_store_meta", "ctx_load_meta"], "call_depth": 1, "humanFuncDescription": [{"description": " Count ipv6 tail calls ", "author": "Yihe Bi", "authorEmail": "ybi@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 353, "endLine": 366, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c", "funcName": "tail_handle_ipv6", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " const bool from_host"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int tail_handle_ipv6 (struct  __ctx_buff *ctx, const bool from_host)\n", "{\n", "    __u32 proxy_identity = ctx_load_meta (ctx, CB_SRC_IDENTITY);\n", "    int ret;\n", "    ctx_store_meta (ctx, CB_SRC_IDENTITY, 0);\n", "    ret = handle_ipv6 (ctx, proxy_identity, from_host);\n", "    if (IS_ERR (ret))\n", "        return send_drop_notify_error (ctx, proxy_identity, ret, CTX_ACT_DROP, METRIC_INGRESS);\n", "    return ret;\n", "}\n"], "called_function_list": ["__tail_handle_ipv6", "handle_ipv6", "ctx_store_meta", "ctx_load_meta"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "handle_ipv4": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}, {"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 196, "endLine": 333, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_overlay.c", "funcName": "handle_ipv4", "developer_inline_comments": [], "updateMaps": [], "readMaps": ["  VTEP_MAP"], "input": ["struct  __ctx_buff *ctx", " __u32 *identity"], "output": "static__always_inlineint", "helper": ["map_lookup_elem", "CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["static __always_inline int handle_ipv4 (struct  __ctx_buff *ctx, __u32 *identity)\n", "{\n", "    void *data_end, *data;\n", "    struct iphdr *ip4;\n", "    struct endpoint_info *ep;\n", "    struct bpf_tunnel_key key = {}\n", "    ;\n", "    bool decrypted;\n", "    if (!revalidate_data_pull (ctx, &data, &data_end, &ip4))\n", "        return DROP_INVALID;\n", "\n", "#ifndef ENABLE_IPV4_FRAGMENTS\n", "    if (ipv4_is_fragment (ip4))\n", "        return DROP_FRAG_NOSUPPORT;\n", "\n", "#endif\n", "\n", "#ifdef ENABLE_NODEPORT\n", "    if (!bpf_skip_nodeport (ctx)) {\n", "        int ret = nodeport_lb4 (ctx, * identity);\n", "        if (ret < 0)\n", "            return ret;\n", "    }\n", "\n", "#endif\n", "    if (!revalidate_data (ctx, &data, &data_end, &ip4))\n", "        return DROP_INVALID;\n", "    decrypted = ((ctx->mark & MARK_MAGIC_HOST_MASK) == MARK_MAGIC_DECRYPT);\n", "    if (decrypted) {\n", "        *identity = key.tunnel_id = get_identity (ctx);\n", "    }\n", "    else {\n", "        if (unlikely (ctx_get_tunnel_key (ctx, &key, sizeof (key), 0) < 0))\n", "            return DROP_NO_TUNNEL_KEY;\n", "        *identity = key.tunnel_id;\n", "        if (*identity == HOST_ID)\n", "            return DROP_INVALID_IDENTITY;\n", "\n", "#ifdef ENABLE_VTEP\n", "        {\n", "            struct vtep_key vkey = {}\n", "            ;\n", "            struct vtep_value *info;\n", "            vkey.vtep_ip = ip4->saddr & VTEP_MASK;\n", "            info = map_lookup_elem (& VTEP_MAP, & vkey);\n", "            if (!info)\n", "                goto skip_vtep;\n", "            if (info->tunnel_endpoint) {\n", "                if (*identity != WORLD_ID)\n", "                    return DROP_INVALID_VNI;\n", "            }\n", "        }\n", "    skip_vtep :\n", "\n", "#endif\n", "        if (identity_is_remote_node (*identity)) {\n", "            struct remote_endpoint_info *info;\n", "            info = ipcache_lookup4 (& IPCACHE_MAP, ip4 -> saddr, V4_CACHE_KEY_LEN);\n", "            if (info)\n", "                *identity = info->sec_label;\n", "        }\n", "    }\n", "    cilium_dbg (ctx, DBG_DECAP, key.tunnel_id, key.tunnel_label);\n", "\n", "#ifdef ENABLE_IPSEC\n", "    if (!decrypted) {\n", "        if (ip4->protocol != IPPROTO_ESP) {\n", "            update_metrics (ctx_full_len (ctx), METRIC_INGRESS, REASON_PLAINTEXT);\n", "            goto not_esp;\n", "        }\n", "        ctx->mark = MARK_MAGIC_DECRYPT;\n", "        set_identity_mark (ctx, *identity);\n", "        ctx_change_type (ctx, PACKET_HOST);\n", "        send_trace_notify (ctx, TRACE_TO_STACK, 0, 0, 0, ctx->ingress_ifindex, TRACE_REASON_ENCRYPTED, TRACE_PAYLOAD_LEN);\n", "        return CTX_ACT_OK;\n", "    }\n", "    ctx->mark = 0;\n", "not_esp :\n", "\n", "#endif\n", "    ep = lookup_ip4_endpoint (ip4);\n", "    if (ep) {\n", "        if (ep->flags & ENDPOINT_F_HOST)\n", "            goto to_host;\n", "        return ipv4_local_delivery (ctx, ETH_HLEN, *identity, ip4, ep, METRIC_INGRESS, false);\n", "    }\n", "to_host :\n", "\n", "#ifdef HOST_IFINDEX\n", "    if (1) {\n", "        union macaddr host_mac = HOST_IFINDEX_MAC;\n", "        union macaddr router_mac = NODE_MAC;\n", "        int ret;\n", "        ret = ipv4_l3 (ctx, ETH_HLEN, (__u8 *) & router_mac.addr, (__u8 *) & host_mac.addr, ip4);\n", "        if (ret != CTX_ACT_OK)\n", "            return ret;\n", "        cilium_dbg_capture (ctx, DBG_CAPTURE_DELIVERY, HOST_IFINDEX);\n", "        return ctx_redirect (ctx, HOST_IFINDEX, 0);\n", "    }\n", "\n", "#else\n", "    return CTX_ACT_OK;\n", "\n", "#endif\n", "}\n"], "called_function_list": ["ipv4_host_policy_egress", "ipv4_is_fragment", "ep_tail_call", "eth_store_daddr", "ctx_full_len", "cilium_dbg_capture", "ctx_redirect", "set_identity_meta", "set_encrypt_dip", "ctx_skip_host_fw", "lookup_ip4_endpoint", "ipv4_l3", "update_metrics", "ipv4_host_policy_ingress", "ctx_get_xfer", "set_encrypt_key_meta", "encap_and_redirect_with_nodeid", "encap_and_redirect_netdev", "set_identity_mark", "bpf_skip_nodeport", "ipv4_local_delivery", "rewrite_dmac_to_host", "identity_is_remote_node", "send_trace_notify", "__encap_and_redirect_with_nodeid", "get_min_encrypt_key", "nodeport_lb4", "ctx_store_meta", "ipcache_lookup4", "get_identity", "cilium_dbg"], "call_depth": 1, "humanFuncDescription": [{"description": " This function is similar to handle_ipv6 to handle ipv4 packet. The main goal of it is to check the different condition including  if nodeport, IPSEC is enabled and if the pulling data or decrypting gets error.  Then make different action to handle according situatoins to convert the IPV6 to a virtual  network which points to overlay. IPV4 fragmentation check is added. ", "author": "Yichen Wang", "authorEmail": "wyichen@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}, {"capability": "pkt_alter_or_redo_processing_or_interface", "pkt_alter_or_redo_processing_or_interface": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_REDIRECT", "Return": 7, "Description": "This allows to redirect the skb to the same or another\u2019s device ingress or egress path together with the bpf_redirect() helper. Being able to inject the packet into another device\u2019s ingress or egress direction allows for full flexibility in packet forwarding with BPF. There are no requirements on the target networking device other than being a networking device itself, there is no need to run another instance of cls_bpf on the target device or other such restrictions.", "compatible_hookpoints": ["sched_cls", "sched_act"], "capabilities": ["pkt_alter_or_redo_processing_or_interface"]}]}, {"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 471, "endLine": 671, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c", "funcName": "handle_ipv4", "developer_inline_comments": [], "updateMaps": [], "readMaps": ["  VTEP_MAP"], "input": ["struct  __ctx_buff *ctx", " __u32 secctx", " __u32 ipcache_srcid __maybe_unused", " const bool from_host"], "output": "static__always_inlineint", "helper": ["map_lookup_elem", "TC_ACT_REDIRECT", "CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "sched_act"], "source": ["static __always_inline int handle_ipv4 (struct  __ctx_buff *ctx, __u32 secctx, __u32 ipcache_srcid __maybe_unused, const bool from_host)\n", "{\n", "    struct trace_ctx __maybe_unused trace = {\n", "        .reason = TRACE_REASON_UNKNOWN,\n", "        .monitor = TRACE_PAYLOAD_LEN,}\n", "    ;\n", "    struct remote_endpoint_info *info = NULL;\n", "    __u32 __maybe_unused remote_id = 0;\n", "    struct ipv4_ct_tuple tuple = {}\n", "    ;\n", "    bool skip_redirect = false;\n", "    struct endpoint_info *ep;\n", "    void *data, *data_end;\n", "    struct iphdr *ip4;\n", "    int ret;\n", "    if (!revalidate_data (ctx, &data, &data_end, &ip4))\n", "        return DROP_INVALID;\n", "\n", "#ifndef ENABLE_IPV4_FRAGMENTS\n", "    if (ipv4_is_fragment (ip4))\n", "        return DROP_FRAG_NOSUPPORT;\n", "\n", "#endif\n", "\n", "#ifdef ENABLE_NODEPORT\n", "    if (!from_host) {\n", "        if (ctx_get_xfer (ctx) != XFER_PKT_NO_SVC && !bpf_skip_nodeport (ctx)) {\n", "            ret = nodeport_lb4 (ctx, secctx);\n", "            if (ret == NAT_46X64_RECIRC) {\n", "                ctx_store_meta (ctx, CB_SRC_IDENTITY, secctx);\n", "                ep_tail_call (ctx, CILIUM_CALL_IPV6_FROM_NETDEV);\n", "                return send_drop_notify_error (ctx, secctx, DROP_MISSED_TAIL_CALL, CTX_ACT_DROP, METRIC_INGRESS);\n", "            }\n", "            if (ret < 0 || ret == TC_ACT_REDIRECT)\n", "                return ret;\n", "        }\n", "        if (!revalidate_data (ctx, &data, &data_end, &ip4))\n", "            return DROP_INVALID;\n", "    }\n", "\n", "#endif /* ENABLE_NODEPORT */\n", "\n", "#if defined(NO_REDIRECT) && !defined(ENABLE_HOST_ROUTING)\n", "    if (!from_host)\n", "        skip_redirect = true;\n", "\n", "#endif /* NO_REDIRECT && !ENABLE_HOST_ROUTING */\n", "\n", "#ifdef ENABLE_HOST_FIREWALL\n", "    if (from_host) {\n", "        ret = ipv4_host_policy_egress (ctx, secctx, ipcache_srcid, & trace);\n", "        if (IS_ERR (ret))\n", "            return ret;\n", "    }\n", "    else if (!ctx_skip_host_fw (ctx)) {\n", "        ret = ipv4_host_policy_ingress (ctx, & remote_id, & trace);\n", "        if (IS_ERR (ret))\n", "            return ret;\n", "    }\n", "\n", "#endif /* ENABLE_HOST_FIREWALL */\n", "    if (skip_redirect)\n", "        return CTX_ACT_OK;\n", "    tuple.nexthdr = ip4->protocol;\n", "    if (from_host) {\n", "        ret = rewrite_dmac_to_host (ctx, secctx);\n", "        if (IS_ERR (ret))\n", "            return ret;\n", "        if (!revalidate_data (ctx, &data, &data_end, &ip4))\n", "            return DROP_INVALID;\n", "    }\n", "    ep = lookup_ip4_endpoint (ip4);\n", "    if (ep) {\n", "        if (ep->flags & ENDPOINT_F_HOST)\n", "            return CTX_ACT_OK;\n", "        return ipv4_local_delivery (ctx, ETH_HLEN, secctx, ip4, ep, METRIC_INGRESS, from_host);\n", "    }\n", "    if (!from_host)\n", "        return CTX_ACT_OK;\n", "\n", "#ifdef ENABLE_VTEP\n", "    {\n", "        struct vtep_key vkey = {}\n", "        ;\n", "        struct vtep_value *vtep;\n", "        vkey.vtep_ip = ip4->daddr & VTEP_MASK;\n", "        vtep = map_lookup_elem (& VTEP_MAP, & vkey);\n", "        if (!vtep)\n", "            goto skip_vtep;\n", "        if (vtep->vtep_mac && vtep->tunnel_endpoint) {\n", "            if (eth_store_daddr (ctx, (__u8 *) &vtep->vtep_mac, 0) < 0)\n", "                return DROP_WRITE_ERROR;\n", "            return __encap_and_redirect_with_nodeid (ctx, vtep->tunnel_endpoint, secctx, WORLD_ID, &trace);\n", "        }\n", "    }\n", "skip_vtep :\n", "\n", "#endif\n", "\n", "#ifdef TUNNEL_MODE\n", "    info = ipcache_lookup4 (& IPCACHE_MAP, ip4 -> daddr, V4_CACHE_KEY_LEN);\n", "    if (info != NULL && info->tunnel_endpoint != 0) {\n", "        ret = encap_and_redirect_with_nodeid (ctx, info -> tunnel_endpoint, info -> key, secctx, & trace);\n", "        if (ret == IPSEC_ENDPOINT)\n", "            return CTX_ACT_OK;\n", "        else\n", "            return ret;\n", "    }\n", "    else {\n", "        struct endpoint_key key = {}\n", "        ;\n", "        key.ip4 = ip4->daddr & IPV4_MASK;\n", "        key.family = ENDPOINT_KEY_IPV4;\n", "        cilium_dbg (ctx, DBG_NETDEV_ENCAP4, key.ip4, secctx);\n", "        ret = encap_and_redirect_netdev (ctx, & key, secctx, & trace);\n", "        if (ret == IPSEC_ENDPOINT)\n", "            return CTX_ACT_OK;\n", "        else if (ret != DROP_NO_TUNNEL_ENDPOINT)\n", "            return ret;\n", "    }\n", "\n", "#endif\n", "    info = ipcache_lookup4 (& IPCACHE_MAP, ip4 -> daddr, V4_CACHE_KEY_LEN);\n", "    if (info == NULL || info->sec_label == WORLD_ID) {\n", "        return DROP_UNROUTABLE;\n", "    }\n", "\n", "#ifdef ENABLE_IPSEC\n", "    if (info && info->key && info->tunnel_endpoint) {\n", "        __u8 key = get_min_encrypt_key (info -> key);\n", "        set_encrypt_key_meta (ctx, key);\n", "\n", "#ifdef IP_POOLS\n", "        set_encrypt_dip (ctx, info->tunnel_endpoint);\n", "\n", "#else\n", "        set_identity_meta (ctx, secctx);\n", "\n", "#endif\n", "    }\n", "\n", "#endif\n", "    return CTX_ACT_OK;\n", "}\n"], "called_function_list": ["ipv4_host_policy_egress", "ipv4_is_fragment", "ep_tail_call", "eth_store_daddr", "ctx_full_len", "cilium_dbg_capture", "ctx_redirect", "set_identity_meta", "set_encrypt_dip", "ctx_skip_host_fw", "lookup_ip4_endpoint", "ipv4_l3", "update_metrics", "ipv4_host_policy_ingress", "ctx_get_xfer", "set_encrypt_key_meta", "encap_and_redirect_with_nodeid", "encap_and_redirect_netdev", "set_identity_mark", "bpf_skip_nodeport", "ipv4_local_delivery", "rewrite_dmac_to_host", "identity_is_remote_node", "send_trace_notify", "__encap_and_redirect_with_nodeid", "get_min_encrypt_key", "nodeport_lb4", "ctx_store_meta", "ipcache_lookup4", "get_identity", "cilium_dbg"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "tail_handle_ipv4": [{"capabilities": [], "helperCallParams": {}, "startLine": 336, "endLine": 345, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_overlay.c", "funcName": "tail_handle_ipv4", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx"], "output": "int", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["int tail_handle_ipv4 (struct  __ctx_buff *ctx)\n", "{\n", "    __u32 src_identity = 0;\n", "    int ret = handle_ipv4 (ctx, & src_identity);\n", "    if (IS_ERR (ret))\n", "        return send_drop_notify_error (ctx, src_identity, ret, CTX_ACT_DROP, METRIC_INGRESS);\n", "    return ret;\n", "}\n"], "called_function_list": ["__tail_handle_ipv4", "ctx_store_meta", "ctx_load_meta", "handle_ipv4"], "call_depth": 1, "humanFuncDescription": [{"description": " check if there is error about the tail of ipv4 packet. ", "author": "Yichen Wang", "authorEmail": "wyichen@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 1259, "endLine": 1267, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_lxc.c", "funcName": "tail_handle_ipv4", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx"], "output": "int", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["int tail_handle_ipv4 (struct  __ctx_buff *ctx)\n", "{\n", "    int ret = __tail_handle_ipv4 (ctx);\n", "    if (IS_ERR (ret))\n", "        return send_drop_notify_error (ctx, SECLABEL, ret, CTX_ACT_DROP, METRIC_EGRESS);\n", "    return ret;\n", "}\n"], "called_function_list": ["__tail_handle_ipv4", "ctx_store_meta", "ctx_load_meta", "handle_ipv4"], "call_depth": 1, "humanFuncDescription": [{"description": " Count ipv4 tail call. Helper function for handling ipv4 traffic ", "author": "Yihe Bi", "authorEmail": "ybi@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 673, "endLine": 686, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c", "funcName": "tail_handle_ipv4", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " __u32 ipcache_srcid", " const bool from_host"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int tail_handle_ipv4 (struct  __ctx_buff *ctx, __u32 ipcache_srcid, const bool from_host)\n", "{\n", "    __u32 proxy_identity = ctx_load_meta (ctx, CB_SRC_IDENTITY);\n", "    int ret;\n", "    ctx_store_meta (ctx, CB_SRC_IDENTITY, 0);\n", "    ret = handle_ipv4 (ctx, proxy_identity, ipcache_srcid, from_host);\n", "    if (IS_ERR (ret))\n", "        return send_drop_notify_error (ctx, proxy_identity, ret, CTX_ACT_DROP, METRIC_INGRESS);\n", "    return ret;\n", "}\n"], "called_function_list": ["__tail_handle_ipv4", "ctx_store_meta", "ctx_load_meta", "handle_ipv4"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "tail_handle_arp": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}, {"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 353, "endLine": 395, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_overlay.c", "funcName": "tail_handle_arp", "developer_inline_comments": [], "updateMaps": [], "readMaps": ["  VTEP_MAP"], "input": ["struct  __ctx_buff *ctx"], "output": "int", "helper": ["map_lookup_elem", "CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["int tail_handle_arp (struct  __ctx_buff *ctx)\n", "{\n", "    union macaddr mac = NODE_MAC;\n", "    union macaddr smac;\n", "    struct trace_ctx trace = {\n", "        .reason = TRACE_REASON_CT_REPLY,\n", "        .monitor = TRACE_PAYLOAD_LEN,}\n", "    ;\n", "    __be32 sip;\n", "    __be32 tip;\n", "    int ret;\n", "    struct bpf_tunnel_key key = {}\n", "    ;\n", "    struct vtep_key vkey = {}\n", "    ;\n", "    struct vtep_value *info;\n", "    if (unlikely (ctx_get_tunnel_key (ctx, &key, sizeof (key), 0) < 0))\n", "        return send_drop_notify_error (ctx, 0, DROP_NO_TUNNEL_KEY, CTX_ACT_DROP, METRIC_INGRESS);\n", "    if (!arp_validate (ctx, &mac, &smac, &sip, &tip) || !__lookup_ip4_endpoint (tip))\n", "        goto pass_to_stack;\n", "    vkey.vtep_ip = sip & VTEP_MASK;\n", "    info = map_lookup_elem (& VTEP_MAP, & vkey);\n", "    if (!info)\n", "        goto pass_to_stack;\n", "    ret = arp_prepare_response (ctx, & mac, tip, & smac, sip);\n", "    if (unlikely (ret != 0))\n", "        return send_drop_notify_error (ctx, 0, ret, CTX_ACT_DROP, METRIC_EGRESS);\n", "    if (info->tunnel_endpoint)\n", "        return __encap_and_redirect_with_nodeid (ctx, info->tunnel_endpoint, SECLABEL, WORLD_ID, &trace);\n", "    return send_drop_notify_error (ctx, 0, DROP_UNKNOWN_L3, CTX_ACT_DROP, METRIC_EGRESS);\n", "pass_to_stack :\n", "    send_trace_notify (ctx, TRACE_TO_STACK, 0, 0, 0, ctx->ingress_ifindex, trace.reason, trace.monitor);\n", "    return CTX_ACT_OK;\n", "}\n"], "called_function_list": ["send_trace_notify", "__encap_and_redirect_with_nodeid", "__lookup_ip4_endpoint", "arp_validate", "arp_prepare_response", "arp_respond"], "call_depth": 2, "humanFuncDescription": [{"description": " Handle the tail for ARP requests from VTEP. Check different occasions including tunnel_key geting, arp validating, and if endpoint of tunnel is reached. ", "author": "Yichen Wang", "authorEmail": "wyichen@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 1275, "endLine": 1300, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_lxc.c", "funcName": "tail_handle_arp", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx"], "output": "int", "helper": ["CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["int tail_handle_arp (struct  __ctx_buff *ctx)\n", "{\n", "    union macaddr mac = NODE_MAC;\n", "    union macaddr smac;\n", "    __be32 sip;\n", "    __be32 tip;\n", "    if (!arp_validate (ctx, &mac, &smac, &sip, &tip))\n", "        return CTX_ACT_OK;\n", "    if (tip == LXC_IPV4)\n", "        return CTX_ACT_OK;\n", "    return arp_respond (ctx, &mac, tip, &smac, sip, 0);\n", "}\n"], "called_function_list": ["send_trace_notify", "__encap_and_redirect_with_nodeid", "__lookup_ip4_endpoint", "arp_validate", "arp_prepare_response", "arp_respond"], "call_depth": 2, "humanFuncDescription": [{"description": " Validate ARP requests. Send unknown and LXC endpoint ARP requests to linux kernel stack.  Send response for all other ARP requests. ", "author": "Yihe Bi", "authorEmail": "ybi@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "is_esp": [{"capabilities": [], "helperCallParams": {}, "startLine": 401, "endLine": 428, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_overlay.c", "funcName": "is_esp", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " __u16 proto"], "output": "static__always_inlinebool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline bool is_esp (struct  __ctx_buff *ctx, __u16 proto)\n", "{\n", "    void *data, *data_end;\n", "    __u8 protocol = 0;\n", "    struct ipv6hdr * ip6 __maybe_unused;\n", "    struct iphdr * ip4 __maybe_unused;\n", "    switch (proto) {\n", "\n", "#ifdef ENABLE_IPV6\n", "    case bpf_htons (ETH_P_IPV6) :\n", "        if (!revalidate_data_pull (ctx, &data, &data_end, &ip6))\n", "            return false;\n", "        protocol = ip6->nexthdr;\n", "        break;\n", "\n", "#endif\n", "\n", "#ifdef ENABLE_IPV4\n", "    case bpf_htons (ETH_P_IP) :\n", "        if (!revalidate_data_pull (ctx, &data, &data_end, &ip4))\n", "            return false;\n", "        protocol = ip4->protocol;\n", "        break;\n", "\n", "#endif\n", "    default :\n", "        return false;\n", "    }\n", "    return protocol == IPPROTO_ESP;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{"description": " The built in function to check if esp protocol is used and if pulling data have error. ", "author": "Yichen Wang", "authorEmail": "wyichen@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "from_overlay": [{"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 435, "endLine": 527, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_overlay.c", "funcName": "from_overlay", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx"], "output": "int", "helper": ["CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["int from_overlay (struct  __ctx_buff *ctx)\n", "{\n", "    __u16 proto;\n", "    int ret;\n", "    bpf_clear_meta (ctx);\n", "    bpf_skip_nodeport_clear (ctx);\n", "    if (!validate_ethertype (ctx, &proto)) {\n", "        ret = CTX_ACT_OK;\n", "        goto out;\n", "    }\n", "\n", "#ifdef ENABLE_IPSEC\n", "    if (is_esp (ctx, proto))\n", "        send_trace_notify (ctx, TRACE_FROM_OVERLAY, 0, 0, 0, ctx->ingress_ifindex, TRACE_REASON_ENCRYPTED, TRACE_PAYLOAD_LEN);\n", "    else\n", "\n", "#endif\n", "        {\n", "            __u32 identity = 0;\n", "            enum trace_point obs_point = TRACE_FROM_OVERLAY;\n", "            if ((ctx->mark & MARK_MAGIC_HOST_MASK) == MARK_MAGIC_DECRYPT) {\n", "                identity = get_identity (ctx);\n", "                obs_point = TRACE_FROM_STACK;\n", "            }\n", "            send_trace_notify (ctx, obs_point, identity, 0, 0, ctx->ingress_ifindex, TRACE_REASON_UNKNOWN, TRACE_PAYLOAD_LEN);\n", "        }\n", "    switch (proto) {\n", "    case bpf_htons (ETH_P_IPV6) :\n", "\n", "#ifdef ENABLE_IPV6\n", "        ep_tail_call (ctx, CILIUM_CALL_IPV6_FROM_OVERLAY);\n", "        ret = DROP_MISSED_TAIL_CALL;\n", "\n", "#else\n", "        ret = DROP_UNKNOWN_L3;\n", "\n", "#endif\n", "        break;\n", "    case bpf_htons (ETH_P_IP) :\n", "\n", "#ifdef ENABLE_IPV4\n", "        ep_tail_call (ctx, CILIUM_CALL_IPV4_FROM_OVERLAY);\n", "        ret = DROP_MISSED_TAIL_CALL;\n", "\n", "#else\n", "        ret = DROP_UNKNOWN_L3;\n", "\n", "#endif\n", "        break;\n", "\n", "#ifdef ENABLE_VTEP\n", "    case bpf_htons (ETH_P_ARP) :\n", "        ep_tail_call (ctx, CILIUM_CALL_ARP);\n", "        ret = DROP_MISSED_TAIL_CALL;\n", "        break;\n", "\n", "#endif\n", "    default :\n", "        ret = CTX_ACT_OK;\n", "    }\n", "out :\n", "    if (IS_ERR (ret))\n", "        return send_drop_notify_error (ctx, 0, ret, CTX_ACT_DROP, METRIC_INGRESS);\n", "    return ret;\n", "}\n"], "called_function_list": ["send_trace_notify", "is_esp", "ep_tail_call", "validate_ethertype", "bpf_clear_meta", "get_identity", "bpf_skip_nodeport_clear"], "call_depth": 3, "humanFuncDescription": [{"description": " handle different possible packets come to the program. First check if it is esp protocol, then check the decrypted or not and get the identity from the metadata.  ", "author": "Yichen Wang", "authorEmail": "wyichen@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "to_overlay": [{"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 533, "endLine": 568, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_overlay.c", "funcName": "to_overlay", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx"], "output": "int", "helper": ["CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["int to_overlay (struct  __ctx_buff *ctx)\n", "{\n", "    int ret;\n", "    ret = encap_remap_v6_host_address (ctx, true);\n", "    if (unlikely (ret < 0))\n", "        goto out;\n", "\n", "#ifdef ENABLE_BANDWIDTH_MANAGER\n", "    ret = edt_sched_departure (ctx);\n", "    if (ret == CTX_ACT_DROP) {\n", "        update_metrics (ctx_full_len (ctx), METRIC_EGRESS, -DROP_EDT_HORIZON);\n", "        return CTX_ACT_DROP;\n", "    }\n", "\n", "#endif\n", "\n", "#ifdef ENABLE_NODEPORT\n", "    if ((ctx->mark & MARK_MAGIC_SNAT_DONE) == MARK_MAGIC_SNAT_DONE) {\n", "        ret = CTX_ACT_OK;\n", "        goto out;\n", "    }\n", "    ret = handle_nat_fwd (ctx);\n", "\n", "#endif\n", "out :\n", "    if (IS_ERR (ret))\n", "        return send_drop_notify_error (ctx, 0, ret, CTX_ACT_DROP, METRIC_EGRESS);\n", "    return ret;\n", "}\n"], "called_function_list": ["update_metrics", "ctx_full_len", "edt_sched_departure", "encap_remap_v6_host_address", "handle_nat_fwd"], "call_depth": 4, "humanFuncDescription": [{"description": " TO BE ADDED  ", "author": "Yichen Wang", "authorEmail": "wyichen@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "redirect_to_proxy": [{"capabilities": [], "helperCallParams": {}, "startLine": 157, "endLine": 162, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_lxc.c", "funcName": "redirect_to_proxy", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["int verdict", " enum ct_status status"], "output": "static__always_inlinebool", "helper": ["redirect"], "compatibleHookpoints": ["lwt_xmit", "sched_cls", "xdp", "sched_act"], "source": ["static __always_inline bool redirect_to_proxy (int verdict, enum ct_status status)\n", "{\n", "    return is_defined (ENABLE_HOST_REDIRECT) && verdict > 0 && (status == CT_NEW || status == CT_ESTABLISHED || status == CT_REOPENED);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{"description": " check if the proxy is able to be redirected, and redirect the proxy, store in status. Return true if successful. ", "author": "Yihe Bi", "authorEmail": "ybi@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 50, "endLine": 53, "File": "/home/sayandes/opened_extraction/examples/cilium/sockops/bpf_sockops.c", "funcName": "redirect_to_proxy", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["int verdict"], "output": "static__always_inlinebool", "helper": ["redirect"], "compatibleHookpoints": ["lwt_xmit", "sched_cls", "xdp", "sched_act"], "source": ["static __always_inline bool redirect_to_proxy (int verdict)\n", "{\n", "    return verdict > 0;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{"description": " check if verdict is larger than 0  ", "author": "Shun Zhang", "authorEmail": "shunz@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "encode_custom_prog_meta": [{"capabilities": [], "helperCallParams": {}, "startLine": 174, "endLine": 189, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_lxc.c", "funcName": "encode_custom_prog_meta", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " int ret", " __u32 identity"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int encode_custom_prog_meta (struct  __ctx_buff *ctx, int ret, __u32 identity)\n", "{\n", "    __u32 custom_meta = 0;\n", "    if ((ret & 0xff) != ret)\n", "        return -1;\n", "    custom_meta |= (__u32) (ret & 0xff) << 24;\n", "    custom_meta |= (identity & 0xffffff);\n", "    ctx_store_meta (ctx, CB_CUSTOM_CALLS, custom_meta);\n", "    return 0;\n", "}\n"], "called_function_list": ["ctx_store_meta"], "call_depth": 1, "humanFuncDescription": [{"description": " encode meta data (return value and identity), and store it into ctx buffer ", "author": "Yihe Bi", "authorEmail": "ybi@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "handle_ipv6_from_lxc": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}, {"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 214, "endLine": 581, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_lxc.c", "funcName": "handle_ipv6_from_lxc", "developer_inline_comments": [], "updateMaps": [], "readMaps": ["  CT_TAIL_CALL_BUFFER6"], "input": ["struct  __ctx_buff *ctx", " __u32 *dst_id"], "output": "static__always_inlineint", "helper": ["redirect", "map_lookup_elem", "tail_call", "CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["static __always_inline int handle_ipv6_from_lxc (struct  __ctx_buff *ctx, __u32 *dst_id)\n", "{\n", "    struct ct_state ct_state_on_stack __maybe_unused, *ct_state, ct_state_new = {};\n", "    struct ipv6_ct_tuple tuple_on_stack __maybe_unused, *tuple;\n", "\n", "#ifdef ENABLE_ROUTING\n", "    union macaddr router_mac = NODE_MAC;\n", "\n", "#endif\n", "    struct ct_buffer6 *ct_buffer;\n", "    void *data, *data_end;\n", "    struct ipv6hdr *ip6;\n", "    int ret, verdict = 0, l4_off, hdrlen, zero = 0;\n", "    struct trace_ctx trace = {\n", "        .reason = TRACE_REASON_UNKNOWN,\n", "        .monitor = 0,}\n", "    ;\n", "    __u32 __maybe_unused tunnel_endpoint = 0;\n", "    __u8 __maybe_unused encrypt_key = 0;\n", "    enum ct_status ct_status;\n", "    bool hairpin_flow = false;\n", "    __u8 policy_match_type = POLICY_MATCH_NONE;\n", "    __u8 audited = 0;\n", "    bool __maybe_unused dst_remote_ep = false;\n", "    __u16 proxy_port = 0;\n", "    bool from_l7lb = false;\n", "    bool emit_policy_verdict = true;\n", "    if (!revalidate_data (ctx, &data, &data_end, &ip6))\n", "        return DROP_INVALID;\n", "    if (1) {\n", "        const union v6addr *daddr = (union v6addr *) &ip6->daddr;\n", "        struct remote_endpoint_info *info;\n", "        info = lookup_ip6_remote_endpoint (daddr);\n", "        if (info && info->sec_label) {\n", "            *dst_id = info->sec_label;\n", "            tunnel_endpoint = info->tunnel_endpoint;\n", "            encrypt_key = get_min_encrypt_key (info -> key);\n", "\n", "#ifdef ENABLE_WIREGUARD\n", "            if (info->tunnel_endpoint != 0 && !identity_is_node (info->sec_label))\n", "                dst_remote_ep = true;\n", "\n", "#endif /* ENABLE_WIREGUARD */\n", "        }\n", "        else {\n", "            *dst_id = WORLD_ID;\n", "        }\n", "        cilium_dbg (ctx, info ? DBG_IP_ID_MAP_SUCCEED6 : DBG_IP_ID_MAP_FAILED6, daddr->p4, *dst_id);\n", "    }\n", "\n", "#ifdef ENABLE_PER_PACKET_LB\n", "\n", "#if !defined(DEBUG) && defined(TUNNEL_MODE)\n", "    if (!revalidate_data (ctx, &data, &data_end, &ip6))\n", "        return DROP_INVALID;\n", "\n", "#endif\n", "    lb6_ctx_restore_state (ctx, &ct_state_new, &proxy_port);\n", "\n", "#endif /* ENABLE_PER_PACKET_LB */\n", "    ct_buffer = map_lookup_elem (& CT_TAIL_CALL_BUFFER6, & zero);\n", "    if (!ct_buffer)\n", "        return DROP_INVALID_TC_BUFFER;\n", "    if (ct_buffer->tuple.saddr.d1 == 0 && ct_buffer->tuple.saddr.d2 == 0)\n", "        return DROP_INVALID_TC_BUFFER;\n", "\n", "#if HAVE_DIRECT_ACCESS_TO_MAP_VALUES\n", "    tuple = (struct ipv6_ct_tuple *) &ct_buffer->tuple;\n", "    ct_state = (struct ct_state *) &ct_buffer->ct_state;\n", "\n", "#else\n", "    memcpy (&tuple_on_stack, &ct_buffer->tuple, sizeof (tuple_on_stack));\n", "    tuple = &tuple_on_stack;\n", "    memcpy (&ct_state_on_stack, &ct_buffer->ct_state, sizeof (ct_state_on_stack));\n", "    ct_state = &ct_state_on_stack;\n", "\n", "#endif /* HAVE_DIRECT_ACCESS_TO_MAP_VALUES */\n", "    trace.monitor = ct_buffer->monitor;\n", "    ret = ct_buffer->ret;\n", "    ct_status = (enum ct_status) ret;\n", "    trace.reason = (enum trace_reason) ret;\n", "\n", "#if defined(ENABLE_L7_LB)\n", "    if (proxy_port > 0) {\n", "        cilium_dbg3 (ctx, DBG_L7_LB, tuple->daddr.p4, tuple->saddr.p4, bpf_ntohs (proxy_port));\n", "        verdict = proxy_port;\n", "        emit_policy_verdict = false;\n", "        goto skip_policy_enforcement;\n", "    }\n", "\n", "#endif /* ENABLE_L7_LB */\n", "    if ((ct_status == CT_REPLY || ct_status == CT_RELATED) && ct_state->proxy_redirect) {\n", "        return ctx_redirect_to_proxy6 (ctx, tuple, 0, false);\n", "    }\n", "    if (hairpin_flow) {\n", "        emit_policy_verdict = false;\n", "        goto skip_policy_enforcement;\n", "    }\n", "    verdict = policy_can_egress6 (ctx, tuple, SECLABEL, * dst_id, & policy_match_type, & audited);\n", "    if (ct_status != CT_REPLY && ct_status != CT_RELATED && verdict < 0) {\n", "        send_policy_verdict_notify (ctx, *dst_id, tuple->dport, tuple->nexthdr, POLICY_EGRESS, 1, verdict, policy_match_type, audited);\n", "        return verdict;\n", "    }\n", "skip_policy_enforcement :\n", "\n", "#if defined(ENABLE_L7_LB)\n", "    from_l7lb = ctx_load_meta (ctx, CB_FROM_HOST) == FROM_HOST_L7_LB;\n", "\n", "#endif\n", "    switch (ct_status) {\n", "    case CT_NEW :\n", "        if (emit_policy_verdict)\n", "            send_policy_verdict_notify (ctx, *dst_id, tuple->dport, tuple->nexthdr, POLICY_EGRESS, 1, verdict, policy_match_type, audited);\n", "    ct_recreate6 :\n", "        ct_state_new.src_sec_id = SECLABEL;\n", "        ret = ct_create6 (get_ct_map6 (tuple), & CT_MAP_ANY6, tuple, ctx, CT_EGRESS, & ct_state_new, verdict > 0, from_l7lb);\n", "        if (IS_ERR (ret))\n", "            return ret;\n", "        trace.monitor = TRACE_PAYLOAD_LEN;\n", "        break;\n", "    case CT_REOPENED :\n", "        if (emit_policy_verdict)\n", "            send_policy_verdict_notify (ctx, *dst_id, tuple->dport, tuple->nexthdr, POLICY_EGRESS, 1, verdict, policy_match_type, audited);\n", "    case CT_ESTABLISHED :\n", "        if (unlikely (ct_state->rev_nat_index != ct_state_new.rev_nat_index))\n", "            goto ct_recreate6;\n", "        break;\n", "    case CT_RELATED :\n", "    case CT_REPLY :\n", "        policy_mark_skip (ctx);\n", "        hdrlen = ipv6_hdrlen (ctx, & tuple -> nexthdr);\n", "        if (hdrlen < 0)\n", "            return hdrlen;\n", "        l4_off = ETH_HLEN + hdrlen;\n", "\n", "#ifdef ENABLE_NODEPORT\n", "\n", "# ifdef ENABLE_DSR\n", "        if (ct_state->dsr) {\n", "            ret = xlate_dsr_v6 (ctx, tuple, l4_off);\n", "            if (ret != 0)\n", "                return ret;\n", "        }\n", "        else\n", "\n", "# endif /* ENABLE_DSR */\n", "            if (ct_state->node_port) {\n", "                send_trace_notify (ctx, TRACE_TO_NETWORK, SECLABEL, *dst_id, 0, 0, trace.reason, trace.monitor);\n", "                ctx->tc_index |= TC_INDEX_F_SKIP_RECIRCULATION;\n", "                ep_tail_call (ctx, CILIUM_CALL_IPV6_NODEPORT_REVNAT);\n", "                return DROP_MISSED_TAIL_CALL;\n", "            }\n", "\n", "#endif /* ENABLE_NODEPORT */\n", "        if (ct_state->rev_nat_index) {\n", "            struct csum_offset csum_off = {}\n", "            ;\n", "            csum_l4_offset_and_flags (tuple->nexthdr, &csum_off);\n", "            ret = lb6_rev_nat (ctx, l4_off, & csum_off, ct_state -> rev_nat_index, tuple, 0);\n", "            if (IS_ERR (ret))\n", "                return ret;\n", "            policy_mark_skip (ctx);\n", "        }\n", "        break;\n", "    default :\n", "        return DROP_UNKNOWN_CT;\n", "    }\n", "    hairpin_flow |= ct_state->loopback;\n", "    if (!from_l7lb && redirect_to_proxy (verdict, ct_status)) {\n", "        proxy_port = (__u16) verdict;\n", "        send_trace_notify (ctx, TRACE_TO_PROXY, SECLABEL, 0, bpf_ntohs (proxy_port), 0, trace.reason, trace.monitor);\n", "        return ctx_redirect_to_proxy6 (ctx, tuple, proxy_port, false);\n", "    }\n", "    if (!revalidate_data (ctx, &data, &data_end, &ip6))\n", "        return DROP_INVALID;\n", "    if (is_defined (ENABLE_ROUTING) || hairpin_flow) {\n", "        struct endpoint_info *ep;\n", "        ep = lookup_ip6_endpoint (ip6);\n", "        if (ep) {\n", "\n", "#ifdef ENABLE_ROUTING\n", "            if (ep->flags & ENDPOINT_F_HOST) {\n", "\n", "#ifdef HOST_IFINDEX\n", "                goto to_host;\n", "\n", "#else\n", "                return DROP_HOST_UNREACHABLE;\n", "\n", "#endif\n", "            }\n", "\n", "#endif /* ENABLE_ROUTING */\n", "            policy_clear_mark (ctx);\n", "            return ipv6_local_delivery (ctx, ETH_HLEN, SECLABEL, ep, METRIC_EGRESS, from_l7lb);\n", "        }\n", "    }\n", "\n", "#if defined(ENABLE_HOST_FIREWALL) && !defined(ENABLE_ROUTING)\n", "    if (*dst_id == HOST_ID) {\n", "        ctx_store_meta (ctx, CB_FROM_HOST, 0);\n", "        tail_call_static (ctx, &POLICY_CALL_MAP, HOST_EP_ID);\n", "        return DROP_MISSED_TAIL_CALL;\n", "    }\n", "\n", "#endif /* ENABLE_HOST_FIREWALL && !ENABLE_ROUTING */\n", "\n", "#ifdef TUNNEL_MODE\n", "\n", "# ifdef ENABLE_WIREGUARD\n", "    if (!dst_remote_ep)\n", "\n", "# endif /* ENABLE_WIREGUARD */\n", "        {\n", "            struct endpoint_key key = {}\n", "            ;\n", "            union v6addr *daddr = (union v6addr *) &ip6->daddr;\n", "            key.ip6.p1 = daddr->p1;\n", "            key.ip6.p2 = daddr->p2;\n", "            key.ip6.p3 = daddr->p3;\n", "            key.family = ENDPOINT_KEY_IPV6;\n", "            ret = encap_and_redirect_lxc (ctx, tunnel_endpoint, encrypt_key, & key, SECLABEL, & trace);\n", "            if (ret == IPSEC_ENDPOINT)\n", "                goto encrypt_to_stack;\n", "            else if (ret != DROP_NO_TUNNEL_ENDPOINT)\n", "                return ret;\n", "        }\n", "\n", "#endif\n", "    if (is_defined (ENABLE_HOST_ROUTING))\n", "        return redirect_direct_v6 (ctx, ETH_HLEN, ip6);\n", "    goto pass_to_stack;\n", "\n", "#ifdef ENABLE_ROUTING\n", "to_host :\n", "    if (is_defined (ENABLE_HOST_FIREWALL) && *dst_id == HOST_ID) {\n", "        send_trace_notify (ctx, TRACE_TO_HOST, SECLABEL, HOST_ID, 0, HOST_IFINDEX, trace.reason, trace.monitor);\n", "        return ctx_redirect (ctx, HOST_IFINDEX, BPF_F_INGRESS);\n", "    }\n", "\n", "#endif\n", "pass_to_stack :\n", "\n", "#ifdef ENABLE_ROUTING\n", "    ret = ipv6_l3 (ctx, ETH_HLEN, NULL, (__u8 *) & router_mac.addr, METRIC_EGRESS);\n", "    if (unlikely (ret != CTX_ACT_OK))\n", "        return ret;\n", "\n", "#endif\n", "    if (ipv6_store_flowlabel (ctx, ETH_HLEN, SECLABEL_NB) < 0)\n", "        return DROP_WRITE_ERROR;\n", "\n", "#ifdef ENABLE_WIREGUARD\n", "    if (dst_remote_ep)\n", "        set_encrypt_mark (ctx);\n", "    else\n", "\n", "#elif !defined(TUNNEL_MODE)\n", "\n", "# ifdef ENABLE_IPSEC\n", "        if (encrypt_key && tunnel_endpoint) {\n", "            set_encrypt_key_mark (ctx, encrypt_key);\n", "\n", "#  ifdef IP_POOLS\n", "            set_encrypt_dip (ctx, tunnel_endpoint);\n", "\n", "#  endif /* IP_POOLS */\n", "\n", "#  ifdef ENABLE_IDENTITY_MARK\n", "            set_identity_mark (ctx, SECLABEL);\n", "\n", "#  endif /* ENABLE_IDENTITY_MARK */\n", "        }\n", "        else\n", "\n", "# endif /* ENABLE_IPSEC */\n", "\n", "#endif /* ENABLE_WIREGUARD */\n", "            {\n", "\n", "#ifdef ENABLE_IDENTITY_MARK\n", "                ctx->mark |= MARK_MAGIC_IDENTITY;\n", "                set_identity_mark (ctx, SECLABEL);\n", "\n", "#endif\n", "            }\n", "\n", "#ifdef TUNNEL_MODE\n", "encrypt_to_stack :\n", "\n", "#endif\n", "    send_trace_notify (ctx, TRACE_TO_STACK, SECLABEL, *dst_id, 0, 0, trace.reason, trace.monitor);\n", "    cilium_dbg_capture (ctx, DBG_CAPTURE_DELIVERY, 0);\n", "    return CTX_ACT_OK;\n", "}\n"], "called_function_list": ["xlate_dsr_v6", "get_ct_map6", "ep_tail_call", "cilium_dbg_capture", "ctx_redirect", "lb6_ctx_restore_state", "set_encrypt_dip", "encap_and_redirect_lxc", "cilium_dbg3", "lb6_rev_nat", "policy_mark_skip", "redirect_to_proxy", "tail_call_static", "redirect_direct_v6", "memcpy", "ctx_redirect_to_proxy6", "ipv6_store_flowlabel", "ipv6_hdrlen", "lookup_ip6_endpoint", "set_identity_mark", "set_encrypt_mark", "ipv6_local_delivery", "set_encrypt_key_mark", "send_policy_verdict_notify", "send_trace_notify", "policy_clear_mark", "ct_create6", "get_min_encrypt_key", "ipv6_l3", "cilium_dbg", "ctx_load_meta", "ctx_store_meta", "csum_l4_offset_and_flags", "policy_can_egress6", "identity_is_node"], "call_depth": 3, "humanFuncDescription": [{"description": " Handling egress ipv6 traffic by  a) lookup the destination_id. For encrypted and tunneled traffic b) tunnel endpoint, and c) encryption key as well. Also mark the traffic if it has a remote endpoint destination. Restore ct_state from per packet lb handling in the previous tail call. Enable the per pecket load balancer, swap the address by CT_lookup and establish the connection. ", "author": "Yihe Bi", "authorEmail": "ybi@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "tail_handle_ipv6_cont": [{"capabilities": [], "helperCallParams": {}, "startLine": 584, "endLine": 603, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_lxc.c", "funcName": "tail_handle_ipv6_cont", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx"], "output": "int", "helper": ["tail_call"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["int tail_handle_ipv6_cont (struct  __ctx_buff *ctx)\n", "{\n", "    __u32 dst_id = 0;\n", "    int ret = handle_ipv6_from_lxc (ctx, & dst_id);\n", "    if (IS_ERR (ret))\n", "        return send_drop_notify (ctx, SECLABEL, dst_id, 0, ret, CTX_ACT_DROP, METRIC_EGRESS);\n", "\n", "#ifdef ENABLE_CUSTOM_CALLS\n", "    if (!encode_custom_prog_meta (ctx, ret, dst_id)) {\n", "        tail_call_static (ctx, &CUSTOM_CALLS_MAP, CUSTOM_CALLS_IDX_IPV6_EGRESS);\n", "        update_metrics (ctx_full_len (ctx), METRIC_EGRESS, REASON_MISSED_CUSTOM_CALL);\n", "    }\n", "\n", "#endif\n", "    return ret;\n", "}\n"], "called_function_list": ["handle_ipv6_from_lxc", "encode_custom_prog_meta", "update_metrics", "ctx_full_len", "tail_call_static"], "call_depth": 4, "humanFuncDescription": [{"description": " Count ipv6 tail calls ", "author": "Yihe Bi", "authorEmail": "ybi@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__tail_handle_ipv6": [{"capabilities": [], "helperCallParams": {}, "startLine": 609, "endLine": 694, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_lxc.c", "funcName": "__tail_handle_ipv6", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int __tail_handle_ipv6 (struct  __ctx_buff *ctx)\n", "{\n", "    void *data, *data_end;\n", "    struct ipv6hdr *ip6;\n", "    int ret;\n", "    if (!revalidate_data_pull (ctx, &data, &data_end, &ip6))\n", "        return DROP_INVALID;\n", "    if (unlikely (ip6->nexthdr == IPPROTO_ICMPV6)) {\n", "        if (data + sizeof (*ip6) + ETH_HLEN + sizeof (struct icmp6hdr) > data_end)\n", "            return DROP_INVALID;\n", "        ret = icmp6_handle (ctx, ETH_HLEN, ip6, METRIC_EGRESS);\n", "        if (IS_ERR (ret))\n", "            return ret;\n", "    }\n", "    if (unlikely (!is_valid_lxc_src_ip (ip6)))\n", "        return DROP_INVALID_SIP;\n", "\n", "#ifdef ENABLE_PER_PACKET_LB\n", "    {\n", "        struct ipv6_ct_tuple tuple = {}\n", "        ;\n", "        struct csum_offset csum_off = {}\n", "        ;\n", "        struct ct_state ct_state_new = {}\n", "        ;\n", "        struct lb6_service *svc;\n", "        struct lb6_key key = {}\n", "        ;\n", "        __u16 proxy_port = 0;\n", "        int l4_off, hdrlen;\n", "        tuple.nexthdr = ip6->nexthdr;\n", "        ipv6_addr_copy (&tuple.daddr, (union v6addr *) &ip6->daddr);\n", "        ipv6_addr_copy (&tuple.saddr, (union v6addr *) &ip6->saddr);\n", "        hdrlen = ipv6_hdrlen (ctx, & tuple.nexthdr);\n", "        if (hdrlen < 0)\n", "            return hdrlen;\n", "        l4_off = ETH_HLEN + hdrlen;\n", "        ret = lb6_extract_key (ctx, & tuple, l4_off, & key, & csum_off, CT_EGRESS);\n", "        if (IS_ERR (ret)) {\n", "            if (ret == DROP_NO_SERVICE || ret == DROP_UNKNOWN_L4)\n", "                goto skip_service_lookup;\n", "            else\n", "                return ret;\n", "        }\n", "        svc = lb6_lookup_service (& key, is_defined (ENABLE_NODEPORT));\n", "        if (svc) {\n", "\n", "#if defined(ENABLE_L7_LB)\n", "            if (lb6_svc_is_l7loadbalancer (svc)) {\n", "                proxy_port = (__u16) svc->l7_lb_proxy_port;\n", "                goto skip_service_lookup;\n", "            }\n", "\n", "#endif /* ENABLE_L7_LB */\n", "            ret = lb6_local (get_ct_map6 (& tuple), ctx, ETH_HLEN, l4_off, & csum_off, & key, & tuple, svc, & ct_state_new, false);\n", "            if (IS_ERR (ret))\n", "                return ret;\n", "        }\n", "    skip_service_lookup :\n", "        lb6_ctx_store_state (ctx, &ct_state_new, proxy_port);\n", "    }\n", "\n", "#endif /* ENABLE_PER_PACKET_LB */\n", "    invoke_tailcall_if (is_defined (ENABLE_PER_PACKET_LB), CILIUM_CALL_IPV6_CT_EGRESS, tail_ipv6_ct_egress);\n", "    return ret;\n", "}\n"], "called_function_list": ["lb6_local", "lb6_lookup_service", "is_valid_lxc_src_ip", "lb6_extract_key", "icmp6_handle", "get_ct_map6", "lb6_ctx_store_state", "ipv6_hdrlen", "ipv6_addr_copy", "lb6_svc_is_l7loadbalancer"], "call_depth": 7, "humanFuncDescription": [{"description": " Handle tail messages. Check if it is not special ICMPv6 messages such as echo requests, neighbour advertisement, then check if the destination address is among the address that should be  load balanced. Then store information to ctx for continuous tail call. ", "author": "Yihe Bi", "authorEmail": "ybi@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "handle_ipv4_from_lxc": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}, {"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 728, "endLine": 1157, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_lxc.c", "funcName": "handle_ipv4_from_lxc", "developer_inline_comments": [], "updateMaps": [], "readMaps": ["  CT_TAIL_CALL_BUFFER4", "  VTEP_MAP"], "input": ["struct  __ctx_buff *ctx", " __u32 *dst_id"], "output": "static__always_inlineint", "helper": ["redirect", "map_lookup_elem", "tail_call", "CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["static __always_inline int handle_ipv4_from_lxc (struct  __ctx_buff *ctx, __u32 *dst_id)\n", "{\n", "    struct ct_state ct_state_on_stack __maybe_unused, *ct_state, ct_state_new = {};\n", "    struct ipv4_ct_tuple tuple_on_stack __maybe_unused, *tuple;\n", "\n", "#ifdef ENABLE_ROUTING\n", "    union macaddr router_mac = NODE_MAC;\n", "\n", "#endif\n", "    void *data, *data_end;\n", "    struct iphdr *ip4;\n", "    int ret, verdict = 0, l4_off;\n", "    struct trace_ctx trace = {\n", "        .reason = TRACE_REASON_UNKNOWN,\n", "        .monitor = 0,}\n", "    ;\n", "    __u32 __maybe_unused tunnel_endpoint = 0, zero = 0;\n", "    __u8 __maybe_unused encrypt_key = 0;\n", "    bool hairpin_flow = false;\n", "    __u8 policy_match_type = POLICY_MATCH_NONE;\n", "    struct ct_buffer4 *ct_buffer;\n", "    __u8 audited = 0;\n", "    bool has_l4_header = false;\n", "    bool __maybe_unused dst_remote_ep = false;\n", "    enum ct_status ct_status;\n", "    __u16 proxy_port = 0;\n", "    bool from_l7lb = false;\n", "    bool emit_policy_verdict = true;\n", "    if (!revalidate_data (ctx, &data, &data_end, &ip4))\n", "        return DROP_INVALID;\n", "    has_l4_header = ipv4_has_l4_header (ip4);\n", "    if (1) {\n", "        struct remote_endpoint_info *info;\n", "        info = lookup_ip4_remote_endpoint (ip4 -> daddr);\n", "        if (info && info->sec_label) {\n", "            *dst_id = info->sec_label;\n", "            tunnel_endpoint = info->tunnel_endpoint;\n", "            encrypt_key = get_min_encrypt_key (info -> key);\n", "\n", "#ifdef ENABLE_WIREGUARD\n", "            if (info->tunnel_endpoint != 0 && !identity_is_node (info->sec_label))\n", "                dst_remote_ep = true;\n", "\n", "#endif /* ENABLE_WIREGUARD */\n", "        }\n", "        else {\n", "            *dst_id = WORLD_ID;\n", "        }\n", "        cilium_dbg (ctx, info ? DBG_IP_ID_MAP_SUCCEED4 : DBG_IP_ID_MAP_FAILED4, ip4->daddr, *dst_id);\n", "    }\n", "\n", "#ifdef ENABLE_PER_PACKET_LB\n", "    lb4_ctx_restore_state (ctx, &ct_state_new, ip4->daddr, &proxy_port);\n", "    hairpin_flow = ct_state_new.loopback;\n", "\n", "#endif /* ENABLE_PER_PACKET_LB */\n", "    l4_off = ETH_HLEN + ipv4_hdrlen (ip4);\n", "    ct_buffer = map_lookup_elem (& CT_TAIL_CALL_BUFFER4, & zero);\n", "    if (!ct_buffer)\n", "        return DROP_INVALID_TC_BUFFER;\n", "    if (ct_buffer->tuple.saddr == 0)\n", "        return DROP_INVALID_TC_BUFFER;\n", "\n", "#if HAVE_DIRECT_ACCESS_TO_MAP_VALUES\n", "    tuple = (struct ipv4_ct_tuple *) &ct_buffer->tuple;\n", "    ct_state = (struct ct_state *) &ct_buffer->ct_state;\n", "\n", "#else\n", "    memcpy (&tuple_on_stack, &ct_buffer->tuple, sizeof (tuple_on_stack));\n", "    tuple = &tuple_on_stack;\n", "    memcpy (&ct_state_on_stack, &ct_buffer->ct_state, sizeof (ct_state_on_stack));\n", "    ct_state = &ct_state_on_stack;\n", "\n", "#endif /* HAVE_DIRECT_ACCESS_TO_MAP_VALUES */\n", "    trace.monitor = ct_buffer->monitor;\n", "    ret = ct_buffer->ret;\n", "    ct_status = (enum ct_status) ret;\n", "    trace.reason = (enum trace_reason) ret;\n", "\n", "#if defined(ENABLE_L7_LB)\n", "    if (proxy_port > 0) {\n", "        cilium_dbg3 (ctx, DBG_L7_LB, tuple->daddr, tuple->saddr, bpf_ntohs (proxy_port));\n", "        verdict = proxy_port;\n", "        emit_policy_verdict = false;\n", "        goto skip_policy_enforcement;\n", "    }\n", "\n", "#endif /* ENABLE_L7_LB */\n", "    if ((ct_status == CT_REPLY || ct_status == CT_RELATED) && ct_state->proxy_redirect) {\n", "        return ctx_redirect_to_proxy4 (ctx, tuple, 0, false);\n", "    }\n", "    if (hairpin_flow) {\n", "        emit_policy_verdict = false;\n", "        goto skip_policy_enforcement;\n", "    }\n", "    verdict = policy_can_egress4 (ctx, tuple, SECLABEL, * dst_id, & policy_match_type, & audited);\n", "    if (ct_status != CT_REPLY && ct_status != CT_RELATED && verdict < 0) {\n", "        send_policy_verdict_notify (ctx, *dst_id, tuple->dport, tuple->nexthdr, POLICY_EGRESS, 0, verdict, policy_match_type, audited);\n", "        return verdict;\n", "    }\n", "skip_policy_enforcement :\n", "\n", "#if defined(ENABLE_L7_LB)\n", "    from_l7lb = ctx_load_meta (ctx, CB_FROM_HOST) == FROM_HOST_L7_LB;\n", "\n", "#endif\n", "    switch (ct_status) {\n", "    case CT_NEW :\n", "        if (emit_policy_verdict)\n", "            send_policy_verdict_notify (ctx, *dst_id, tuple->dport, tuple->nexthdr, POLICY_EGRESS, 0, verdict, policy_match_type, audited);\n", "    ct_recreate4 :\n", "        ct_state_new.src_sec_id = SECLABEL;\n", "        ret = ct_create4 (get_ct_map4 (tuple), & CT_MAP_ANY4, tuple, ctx, CT_EGRESS, & ct_state_new, verdict > 0, from_l7lb);\n", "        if (IS_ERR (ret))\n", "            return ret;\n", "        break;\n", "    case CT_REOPENED :\n", "        if (emit_policy_verdict)\n", "            send_policy_verdict_notify (ctx, *dst_id, tuple->dport, tuple->nexthdr, POLICY_EGRESS, 0, verdict, policy_match_type, audited);\n", "    case CT_ESTABLISHED :\n", "        if (unlikely (ct_state->rev_nat_index != ct_state_new.rev_nat_index))\n", "            goto ct_recreate4;\n", "        break;\n", "    case CT_RELATED :\n", "    case CT_REPLY :\n", "        policy_mark_skip (ctx);\n", "\n", "#ifdef ENABLE_NODEPORT\n", "\n", "# ifdef ENABLE_DSR\n", "        if (ct_state->dsr) {\n", "            ret = xlate_dsr_v4 (ctx, tuple, l4_off, has_l4_header);\n", "            if (ret != 0)\n", "                return ret;\n", "        }\n", "        else\n", "\n", "# endif /* ENABLE_DSR */\n", "            if (ct_state->node_port) {\n", "                send_trace_notify (ctx, TRACE_TO_NETWORK, SECLABEL, *dst_id, 0, 0, trace.reason, trace.monitor);\n", "                ctx->tc_index |= TC_INDEX_F_SKIP_RECIRCULATION;\n", "                ep_tail_call (ctx, CILIUM_CALL_IPV4_NODEPORT_REVNAT);\n", "                return DROP_MISSED_TAIL_CALL;\n", "            }\n", "\n", "#endif /* ENABLE_NODEPORT */\n", "        if (ct_state->rev_nat_index) {\n", "            struct csum_offset csum_off = {}\n", "            ;\n", "            csum_l4_offset_and_flags (tuple->nexthdr, &csum_off);\n", "            ret = lb4_rev_nat (ctx, ETH_HLEN, l4_off, & csum_off, ct_state, tuple, 0, has_l4_header);\n", "            if (IS_ERR (ret))\n", "                return ret;\n", "        }\n", "        break;\n", "    default :\n", "        return DROP_UNKNOWN_CT;\n", "    }\n", "    hairpin_flow |= ct_state->loopback;\n", "    if (!from_l7lb && redirect_to_proxy (verdict, ct_status)) {\n", "        proxy_port = (__u16) verdict;\n", "        send_trace_notify (ctx, TRACE_TO_PROXY, SECLABEL, 0, bpf_ntohs (proxy_port), 0, trace.reason, trace.monitor);\n", "        return ctx_redirect_to_proxy4 (ctx, tuple, proxy_port, false);\n", "    }\n", "    if (!revalidate_data (ctx, &data, &data_end, &ip4))\n", "        return DROP_INVALID;\n", "    if (is_defined (ENABLE_ROUTING) || hairpin_flow) {\n", "        struct endpoint_info *ep;\n", "        ep = lookup_ip4_endpoint (ip4);\n", "        if (ep) {\n", "\n", "#ifdef ENABLE_ROUTING\n", "            if (ep->flags & ENDPOINT_F_HOST) {\n", "\n", "#ifdef HOST_IFINDEX\n", "                goto to_host;\n", "\n", "#else\n", "                return DROP_HOST_UNREACHABLE;\n", "\n", "#endif\n", "            }\n", "\n", "#endif /* ENABLE_ROUTING */\n", "            policy_clear_mark (ctx);\n", "            return ipv4_local_delivery (ctx, ETH_HLEN, SECLABEL, ip4, ep, METRIC_EGRESS, from_l7lb);\n", "        }\n", "    }\n", "\n", "#if defined(ENABLE_HOST_FIREWALL) && !defined(ENABLE_ROUTING)\n", "    if (*dst_id == HOST_ID) {\n", "        ctx_store_meta (ctx, CB_FROM_HOST, 0);\n", "        tail_call_static (ctx, &POLICY_CALL_MAP, HOST_EP_ID);\n", "        return DROP_MISSED_TAIL_CALL;\n", "    }\n", "\n", "#endif /* ENABLE_HOST_FIREWALL && !ENABLE_ROUTING */\n", "\n", "#ifdef ENABLE_EGRESS_GATEWAY\n", "    {\n", "        struct egress_gw_policy_entry *egress_gw_policy;\n", "        struct endpoint_info *gateway_node_ep;\n", "        struct endpoint_key key = {}\n", "        ;\n", "        if (identity_is_cluster (*dst_id))\n", "            goto skip_egress_gateway;\n", "        if (ct_status == CT_REPLY || ct_status == CT_RELATED)\n", "            goto skip_egress_gateway;\n", "        egress_gw_policy = lookup_ip4_egress_gw_policy (ip4 -> saddr, ip4 -> daddr);\n", "        if (!egress_gw_policy)\n", "            goto skip_egress_gateway;\n", "        gateway_node_ep = __lookup_ip4_endpoint (egress_gw_policy -> gateway_ip);\n", "        if (gateway_node_ep && (gateway_node_ep->flags & ENDPOINT_F_HOST))\n", "            goto skip_egress_gateway;\n", "        ret = encap_and_redirect_lxc (ctx, egress_gw_policy -> gateway_ip, encrypt_key, & key, SECLABEL, & trace);\n", "        if (ret == IPSEC_ENDPOINT)\n", "            goto encrypt_to_stack;\n", "        else\n", "            return ret;\n", "    }\n", "skip_egress_gateway :\n", "\n", "#endif\n", "\n", "#if defined(ENABLE_VTEP)\n", "    {\n", "        struct vtep_key vkey = {}\n", "        ;\n", "        struct vtep_value *vtep;\n", "        vkey.vtep_ip = ip4->daddr & VTEP_MASK;\n", "        vtep = map_lookup_elem (& VTEP_MAP, & vkey);\n", "        if (!vtep)\n", "            goto skip_vtep;\n", "        if (vtep->vtep_mac && vtep->tunnel_endpoint) {\n", "            if (eth_store_daddr (ctx, (__u8 *) &vtep->vtep_mac, 0) < 0)\n", "                return DROP_WRITE_ERROR;\n", "            return __encap_and_redirect_with_nodeid (ctx, vtep->tunnel_endpoint, SECLABEL, WORLD_ID, &trace);\n", "        }\n", "    }\n", "skip_vtep :\n", "\n", "#endif\n", "\n", "#ifdef TUNNEL_MODE\n", "\n", "# ifdef ENABLE_WIREGUARD\n", "    if (!dst_remote_ep)\n", "\n", "# endif /* ENABLE_WIREGUARD */\n", "        {\n", "            struct endpoint_key key = {}\n", "            ;\n", "            key.ip4 = ip4->daddr & IPV4_MASK;\n", "            key.family = ENDPOINT_KEY_IPV4;\n", "            ret = encap_and_redirect_lxc (ctx, tunnel_endpoint, encrypt_key, & key, SECLABEL, & trace);\n", "            if (ret == DROP_NO_TUNNEL_ENDPOINT)\n", "                goto pass_to_stack;\n", "            else if (ret == IPSEC_ENDPOINT)\n", "                goto encrypt_to_stack;\n", "            else\n", "                return ret;\n", "        }\n", "\n", "#endif /* TUNNEL_MODE */\n", "    if (is_defined (ENABLE_HOST_ROUTING))\n", "        return redirect_direct_v4 (ctx, ETH_HLEN, ip4);\n", "    goto pass_to_stack;\n", "\n", "#ifdef ENABLE_ROUTING\n", "to_host :\n", "    if (is_defined (ENABLE_HOST_FIREWALL) && *dst_id == HOST_ID) {\n", "        send_trace_notify (ctx, TRACE_TO_HOST, SECLABEL, HOST_ID, 0, HOST_IFINDEX, trace.reason, trace.monitor);\n", "        return ctx_redirect (ctx, HOST_IFINDEX, BPF_F_INGRESS);\n", "    }\n", "\n", "#endif\n", "pass_to_stack :\n", "\n", "#ifdef ENABLE_ROUTING\n", "    ret = ipv4_l3 (ctx, ETH_HLEN, NULL, (__u8 *) & router_mac.addr, ip4);\n", "    if (unlikely (ret != CTX_ACT_OK))\n", "        return ret;\n", "\n", "#endif\n", "\n", "#ifdef ENABLE_WIREGUARD\n", "    if (dst_remote_ep)\n", "        set_encrypt_mark (ctx);\n", "    else\n", "\n", "#elif !defined(TUNNEL_MODE)\n", "\n", "# ifdef ENABLE_IPSEC\n", "        if (encrypt_key && tunnel_endpoint) {\n", "            set_encrypt_key_mark (ctx, encrypt_key);\n", "\n", "#  ifdef IP_POOLS\n", "            set_encrypt_dip (ctx, tunnel_endpoint);\n", "\n", "#  endif /* IP_POOLS */\n", "\n", "#  ifdef ENABLE_IDENTITY_MARK\n", "            set_identity_mark (ctx, SECLABEL);\n", "\n", "#  endif\n", "        }\n", "        else\n", "\n", "# endif /* ENABLE_IPSEC */\n", "\n", "#endif /* ENABLE_WIREGUARD */\n", "            {\n", "\n", "#ifdef ENABLE_IDENTITY_MARK\n", "                ctx->mark |= MARK_MAGIC_IDENTITY;\n", "                set_identity_mark (ctx, SECLABEL);\n", "\n", "#endif\n", "            }\n", "\n", "#if defined(TUNNEL_MODE) || defined(ENABLE_EGRESS_GATEWAY)\n", "encrypt_to_stack :\n", "\n", "#endif\n", "    send_trace_notify (ctx, TRACE_TO_STACK, SECLABEL, *dst_id, 0, 0, trace.reason, trace.monitor);\n", "    cilium_dbg_capture (ctx, DBG_CAPTURE_DELIVERY, 0);\n", "    return CTX_ACT_OK;\n", "}\n"], "called_function_list": ["ep_tail_call", "eth_store_daddr", "identity_is_node", "lb4_rev_nat", "cilium_dbg_capture", "ctx_redirect", "ct_create4", "policy_can_egress4", "encap_and_redirect_lxc", "set_encrypt_dip", "lookup_ip4_endpoint", "ipv4_l3", "cilium_dbg3", "get_ct_map4", "xlate_dsr_v4", "policy_mark_skip", "ipv4_hdrlen", "redirect_to_proxy", "tail_call_static", "__lookup_ip4_endpoint", "memcpy", "set_identity_mark", "set_encrypt_mark", "lb4_ctx_restore_state", "set_encrypt_key_mark", "ctx_redirect_to_proxy4", "ipv4_local_delivery", "send_policy_verdict_notify", "send_trace_notify", "policy_clear_mark", "redirect_direct_v4", "__encap_and_redirect_with_nodeid", "get_min_encrypt_key", "lookup_ip4_egress_gw_policy", "ctx_store_meta", "ipv4_has_l4_header", "ctx_load_meta", "csum_l4_offset_and_flags", "identity_is_cluster", "cilium_dbg"], "call_depth": 3, "humanFuncDescription": [{"description": " Handling egress ipv4 traffic. Mark the traffic if it has a remote endpoint destination. Restore ct_state from per packet lb handling in the previous tail call. Enable the per pecket load balancer, swap the address by CT_lookup and establish the connection. ", "author": "Yihe Bi", "authorEmail": "ybi@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "tail_handle_ipv4_cont": [{"capabilities": [], "helperCallParams": {}, "startLine": 1160, "endLine": 1179, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_lxc.c", "funcName": "tail_handle_ipv4_cont", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx"], "output": "int", "helper": ["tail_call"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["int tail_handle_ipv4_cont (struct  __ctx_buff *ctx)\n", "{\n", "    __u32 dst_id = 0;\n", "    int ret = handle_ipv4_from_lxc (ctx, & dst_id);\n", "    if (IS_ERR (ret))\n", "        return send_drop_notify (ctx, SECLABEL, dst_id, 0, ret, CTX_ACT_DROP, METRIC_EGRESS);\n", "\n", "#ifdef ENABLE_CUSTOM_CALLS\n", "    if (!encode_custom_prog_meta (ctx, ret, dst_id)) {\n", "        tail_call_static (ctx, &CUSTOM_CALLS_MAP, CUSTOM_CALLS_IDX_IPV4_EGRESS);\n", "        update_metrics (ctx_full_len (ctx), METRIC_EGRESS, REASON_MISSED_CUSTOM_CALL);\n", "    }\n", "\n", "#endif\n", "    return ret;\n", "}\n"], "called_function_list": ["encode_custom_prog_meta", "update_metrics", "handle_ipv4_from_lxc", "ctx_full_len", "tail_call_static"], "call_depth": 4, "humanFuncDescription": [{"description": " Count ipv4 tail call. Helper function for handling ipv4 traffic ", "author": "Yihe Bi", "authorEmail": "ybi@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__tail_handle_ipv4": [{"capabilities": [], "helperCallParams": {}, "startLine": 1185, "endLine": 1256, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_lxc.c", "funcName": "__tail_handle_ipv4", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int __tail_handle_ipv4 (struct  __ctx_buff *ctx)\n", "{\n", "    void *data, *data_end;\n", "    struct iphdr *ip4;\n", "    int ret;\n", "    if (!revalidate_data_pull (ctx, &data, &data_end, &ip4))\n", "        return DROP_INVALID;\n", "\n", "#ifndef ENABLE_IPV4_FRAGMENTS\n", "    if (ipv4_is_fragment (ip4))\n", "        return DROP_FRAG_NOSUPPORT;\n", "\n", "#endif\n", "    if (unlikely (!is_valid_lxc_src_ipv4 (ip4)))\n", "        return DROP_INVALID_SIP;\n", "\n", "#ifdef ENABLE_PER_PACKET_LB\n", "    {\n", "        struct ipv4_ct_tuple tuple = {}\n", "        ;\n", "        struct csum_offset csum_off = {}\n", "        ;\n", "        struct ct_state ct_state_new = {}\n", "        ;\n", "        bool has_l4_header;\n", "        struct lb4_service *svc;\n", "        struct lb4_key key = {}\n", "        ;\n", "        __u16 proxy_port = 0;\n", "        int l4_off;\n", "        has_l4_header = ipv4_has_l4_header (ip4);\n", "        tuple.nexthdr = ip4->protocol;\n", "        tuple.daddr = ip4->daddr;\n", "        tuple.saddr = ip4->saddr;\n", "        l4_off = ETH_HLEN + ipv4_hdrlen (ip4);\n", "        ret = lb4_extract_key (ctx, ip4, l4_off, & key, & csum_off, CT_EGRESS);\n", "        if (IS_ERR (ret)) {\n", "            if (ret == DROP_NO_SERVICE || ret == DROP_UNKNOWN_L4)\n", "                goto skip_service_lookup;\n", "            else\n", "                return ret;\n", "        }\n", "        svc = lb4_lookup_service (& key, is_defined (ENABLE_NODEPORT));\n", "        if (svc) {\n", "\n", "#if defined(ENABLE_L7_LB)\n", "            if (lb4_svc_is_l7loadbalancer (svc)) {\n", "                proxy_port = (__u16) svc->l7_lb_proxy_port;\n", "                goto skip_service_lookup;\n", "            }\n", "\n", "#endif /* ENABLE_L7_LB */\n", "            ret = lb4_local (get_ct_map4 (& tuple), ctx, ETH_HLEN, l4_off, & csum_off, & key, & tuple, svc, & ct_state_new, ip4 -> saddr, has_l4_header, false);\n", "            if (IS_ERR (ret))\n", "                return ret;\n", "        }\n", "    skip_service_lookup :\n", "        lb4_ctx_store_state (ctx, &ct_state_new, proxy_port);\n", "    }\n", "\n", "#endif /* ENABLE_PER_PACKET_LB */\n", "    invoke_tailcall_if (is_defined (ENABLE_PER_PACKET_LB), CILIUM_CALL_IPV4_CT_EGRESS, tail_ipv4_ct_egress);\n", "    return ret;\n", "}\n"], "called_function_list": ["is_valid_lxc_src_ipv4", "lb4_extract_key", "ipv4_is_fragment", "lb4_lookup_service", "get_ct_map4", "ipv4_has_l4_header", "ipv4_hdrlen", "lb4_svc_is_l7loadbalancer", "lb4_ctx_store_state", "lb4_local"], "call_depth": 4, "humanFuncDescription": [{"description": " helper function to handle ipv4 tail call ", "author": "Yihe Bi", "authorEmail": "ybi@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "handle_xgress": [{"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 1308, "endLine": 1358, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_lxc.c", "funcName": "handle_xgress", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx"], "output": "int", "helper": ["CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["int handle_xgress (struct  __ctx_buff *ctx)\n", "{\n", "    __u16 proto;\n", "    int ret;\n", "    bpf_clear_meta (ctx);\n", "    reset_queue_mapping (ctx);\n", "    send_trace_notify (ctx, TRACE_FROM_LXC, SECLABEL, 0, 0, 0, TRACE_REASON_UNKNOWN, TRACE_PAYLOAD_LEN);\n", "    if (!validate_ethertype (ctx, &proto)) {\n", "        ret = DROP_UNSUPPORTED_L2;\n", "        goto out;\n", "    }\n", "    switch (proto) {\n", "\n", "#ifdef ENABLE_IPV6\n", "    case bpf_htons (ETH_P_IPV6) :\n", "        edt_set_aggregate (ctx, LXC_ID);\n", "        ep_tail_call (ctx, CILIUM_CALL_IPV6_FROM_LXC);\n", "        ret = DROP_MISSED_TAIL_CALL;\n", "        break;\n", "\n", "#endif /* ENABLE_IPV6 */\n", "\n", "#ifdef ENABLE_IPV4\n", "    case bpf_htons (ETH_P_IP) :\n", "        edt_set_aggregate (ctx, LXC_ID);\n", "        ep_tail_call (ctx, CILIUM_CALL_IPV4_FROM_LXC);\n", "        ret = DROP_MISSED_TAIL_CALL;\n", "        break;\n", "\n", "#ifdef ENABLE_ARP_PASSTHROUGH\n", "    case bpf_htons (ETH_P_ARP) :\n", "        ret = CTX_ACT_OK;\n", "        break;\n", "\n", "#elif defined(ENABLE_ARP_RESPONDER)\n", "    case bpf_htons (ETH_P_ARP) :\n", "        ep_tail_call (ctx, CILIUM_CALL_ARP);\n", "        ret = DROP_MISSED_TAIL_CALL;\n", "        break;\n", "\n", "#endif /* ENABLE_ARP_RESPONDER */\n", "\n", "#endif /* ENABLE_IPV4 */\n", "    default :\n", "        ret = DROP_UNKNOWN_L3;\n", "    }\n", "out :\n", "    if (IS_ERR (ret))\n", "        return send_drop_notify (ctx, SECLABEL, 0, 0, ret, CTX_ACT_DROP, METRIC_EGRESS);\n", "    return ret;\n", "}\n"], "called_function_list": ["reset_queue_mapping", "send_trace_notify", "edt_set_aggregate", "ep_tail_call", "validate_ethertype", "bpf_clear_meta"], "call_depth": 2, "humanFuncDescription": [{"description": " Use previous exgress ipv6/v4 traffic handler to handle exgress traffic. ", "author": "Yihe Bi", "authorEmail": "ybi@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ipv6_policy": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}, {"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 1361, "endLine": 1536, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_lxc.c", "funcName": "ipv6_policy", "developer_inline_comments": [], "updateMaps": [], "readMaps": ["  CT_TAIL_CALL_BUFFER6"], "input": ["struct  __ctx_buff *ctx", " int ifindex", " __u32 src_label", " enum ct_status *ct_status", " struct ipv6_ct_tuple *tuple_out", " __u16 *proxy_port", " bool from_host __maybe_unused"], "output": "static__always_inlineint", "helper": ["redirect", "map_lookup_elem", "CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["static __always_inline int ipv6_policy (struct  __ctx_buff *ctx, int ifindex, __u32 src_label, enum ct_status *ct_status, struct ipv6_ct_tuple *tuple_out, __u16 *proxy_port, bool from_host __maybe_unused)\n", "{\n", "    struct ct_state ct_state_on_stack __maybe_unused, *ct_state, ct_state_new = {};\n", "    struct ipv6_ct_tuple tuple_on_stack __maybe_unused, *tuple;\n", "    int ret, verdict, hdrlen, zero = 0;\n", "    struct ct_buffer6 *ct_buffer;\n", "    void *data, *data_end;\n", "    struct ipv6hdr *ip6;\n", "    bool skip_ingress_proxy = false;\n", "    enum trace_reason reason;\n", "    union v6addr orig_sip;\n", "    __u32 monitor = 0;\n", "    __u8 policy_match_type = POLICY_MATCH_NONE;\n", "    __u8 audited = 0;\n", "    bool emit_policy_verdict = true;\n", "    if (!revalidate_data (ctx, &data, &data_end, &ip6))\n", "        return DROP_INVALID;\n", "    policy_clear_mark (ctx);\n", "    ipv6_addr_copy (&orig_sip, (union v6addr *) &ip6->saddr);\n", "    skip_ingress_proxy = tc_index_skip_ingress_proxy (ctx);\n", "    ct_buffer = map_lookup_elem (& CT_TAIL_CALL_BUFFER6, & zero);\n", "    if (!ct_buffer)\n", "        return DROP_INVALID_TC_BUFFER;\n", "    if (ct_buffer->tuple.saddr.d1 == 0 && ct_buffer->tuple.saddr.d2 == 0)\n", "        return DROP_INVALID_TC_BUFFER;\n", "\n", "#if HAVE_DIRECT_ACCESS_TO_MAP_VALUES\n", "    tuple = (struct ipv6_ct_tuple *) &ct_buffer->tuple;\n", "    ct_state = (struct ct_state *) &ct_buffer->ct_state;\n", "\n", "#else\n", "    memcpy (&tuple_on_stack, &ct_buffer->tuple, sizeof (tuple_on_stack));\n", "    tuple = &tuple_on_stack;\n", "    memcpy (&ct_state_on_stack, &ct_buffer->ct_state, sizeof (ct_state_on_stack));\n", "    ct_state = &ct_state_on_stack;\n", "\n", "#endif /* HAVE_DIRECT_ACCESS_TO_MAP_VALUES */\n", "    monitor = ct_buffer->monitor;\n", "    ret = ct_buffer->ret;\n", "    *ct_status = (enum ct_status) ret;\n", "    if ((ret == CT_REPLY || ret == CT_RELATED) && (ct_state_is_from_l7lb (ct_state) || (ct_state->proxy_redirect && !tc_index_skip_egress_proxy (ctx)))) {\n", "        send_trace_notify6 (ctx, TRACE_TO_PROXY, src_label, SECLABEL, &orig_sip, 0, ifindex, (enum trace_reason) ret, monitor);\n", "        if (tuple_out)\n", "            memcpy (tuple_out, tuple, sizeof (*tuple));\n", "        return POLICY_ACT_PROXY_REDIRECT;\n", "    }\n", "    if (unlikely (ct_state->rev_nat_index)) {\n", "        struct csum_offset csum_off = {}\n", "        ;\n", "        int ret2, l4_off;\n", "        hdrlen = ipv6_hdrlen (ctx, & tuple -> nexthdr);\n", "        if (hdrlen < 0)\n", "            return hdrlen;\n", "        l4_off = ETH_HLEN + hdrlen;\n", "        csum_l4_offset_and_flags (tuple->nexthdr, &csum_off);\n", "        ret2 = lb6_rev_nat (ctx, l4_off, & csum_off, ct_state -> rev_nat_index, tuple, 0);\n", "        if (IS_ERR (ret2))\n", "            return ret2;\n", "    }\n", "    verdict = policy_can_access_ingress (ctx, src_label, SECLABEL, tuple -> dport, tuple -> nexthdr, false, & policy_match_type, & audited);\n", "    if (ret != CT_REPLY && ret != CT_RELATED && verdict < 0) {\n", "        send_policy_verdict_notify (ctx, src_label, tuple->dport, tuple->nexthdr, POLICY_INGRESS, 1, verdict, policy_match_type, audited);\n", "        return verdict;\n", "    }\n", "    if (skip_ingress_proxy) {\n", "        verdict = 0;\n", "        emit_policy_verdict = false;\n", "    }\n", "    if (emit_policy_verdict && (ret == CT_NEW || ret == CT_REOPENED)) {\n", "        send_policy_verdict_notify (ctx, src_label, tuple->dport, tuple->nexthdr, POLICY_INGRESS, 1, verdict, policy_match_type, audited);\n", "    }\n", "\n", "#ifdef ENABLE_NODEPORT\n", "    if (ret == CT_NEW || ret == CT_REOPENED) {\n", "        bool dsr = false;\n", "\n", "# ifdef ENABLE_DSR\n", "        int ret2;\n", "        ret2 = handle_dsr_v6 (ctx, & dsr);\n", "        if (ret2 != 0)\n", "            return ret2;\n", "        ct_state_new.dsr = dsr;\n", "        if (ret == CT_REOPENED && ct_state->dsr != dsr)\n", "            ct_update6_dsr (get_ct_map6 (tuple), tuple, dsr);\n", "\n", "# endif /* ENABLE_DSR */\n", "        if (!dsr) {\n", "            bool node_port = ct_has_nodeport_egress_entry6 (get_ct_map6 (tuple), tuple);\n", "            ct_state_new.node_port = node_port;\n", "            if (ret == CT_REOPENED && ct_state->node_port != node_port)\n", "                ct_update_nodeport (get_ct_map6 (tuple), tuple, node_port);\n", "        }\n", "    }\n", "\n", "#endif /* ENABLE_NODEPORT */\n", "    if (ret == CT_NEW) {\n", "        ct_state_new.src_sec_id = src_label;\n", "        ret = ct_create6 (get_ct_map6 (tuple), & CT_MAP_ANY6, tuple, ctx, CT_INGRESS, & ct_state_new, verdict > 0, false);\n", "        if (IS_ERR (ret))\n", "            return ret;\n", "    }\n", "    if (!revalidate_data (ctx, &data, &data_end, &ip6))\n", "        return DROP_INVALID;\n", "    reason = (enum trace_reason) *ct_status;\n", "    if (redirect_to_proxy (verdict, *ct_status)) {\n", "        *proxy_port = (__u16) verdict;\n", "        send_trace_notify6 (ctx, TRACE_TO_PROXY, src_label, SECLABEL, &orig_sip, bpf_ntohs (*proxy_port), ifindex, reason, monitor);\n", "        if (tuple_out)\n", "            memcpy (tuple_out, tuple, sizeof (*tuple));\n", "        return POLICY_ACT_PROXY_REDIRECT;\n", "    }\n", "    send_trace_notify6 (ctx, TRACE_TO_LXC, src_label, SECLABEL, &orig_sip, LXC_ID, ifindex, reason, monitor);\n", "\n", "#if !defined(ENABLE_ROUTING) && defined(TUNNEL_MODE) && !defined(ENABLE_NODEPORT)\n", "    ctx_change_type (ctx, PACKET_HOST);\n", "\n", "#else\n", "    ifindex = ctx_load_meta (ctx, CB_IFINDEX);\n", "    if (ifindex)\n", "        return redirect_ep (ctx, ifindex, from_host);\n", "\n", "#endif /* !ENABLE_ROUTING && TUNNEL_MODE && !ENABLE_NODEPORT */\n", "    return CTX_ACT_OK;\n", "}\n"], "called_function_list": ["ct_update_nodeport", "get_ct_map6", "ct_has_nodeport_egress_entry6", "policy_can_access_ingress", "tc_index_skip_ingress_proxy", "handle_dsr_v6", "ct_state_is_from_l7lb", "send_trace_notify6", "lb6_rev_nat", "ct_update6_dsr", "redirect_to_proxy", "memcpy", "ipv6_hdrlen", "policy_clear_mark", "send_policy_verdict_notify", "ct_create6", "redirect_ep", "ctx_load_meta", "ipv6_addr_copy", "csum_l4_offset_and_flags", "tc_index_skip_egress_proxy"], "call_depth": 3, "humanFuncDescription": [{"description": " Check if the packet is ingress or exgress traffic, redirect the traffic if necessary. ", "author": "Yihe Bi", "authorEmail": "ybi@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "tail_ipv6_policy": [{"capabilities": [], "helperCallParams": {}, "startLine": 1540, "endLine": 1581, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_lxc.c", "funcName": "tail_ipv6_policy", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx"], "output": "int", "helper": ["tail_call"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["int tail_ipv6_policy (struct  __ctx_buff *ctx)\n", "{\n", "    struct ipv6_ct_tuple tuple = {}\n", "    ;\n", "    int ret, ifindex = ctx_load_meta (ctx, CB_IFINDEX);\n", "    __u32 src_label = ctx_load_meta (ctx, CB_SRC_LABEL);\n", "    bool from_host = ctx_load_meta (ctx, CB_FROM_HOST);\n", "    bool proxy_redirect __maybe_unused = false;\n", "    __u16 proxy_port = 0;\n", "    enum ct_status ct_status = 0;\n", "    ctx_store_meta (ctx, CB_SRC_LABEL, 0);\n", "    ctx_store_meta (ctx, CB_FROM_HOST, 0);\n", "    ret = ipv6_policy (ctx, ifindex, src_label, & ct_status, & tuple, & proxy_port, from_host);\n", "    if (ret == POLICY_ACT_PROXY_REDIRECT) {\n", "        ret = ctx_redirect_to_proxy6 (ctx, & tuple, proxy_port, from_host);\n", "        proxy_redirect = true;\n", "    }\n", "    if (IS_ERR (ret))\n", "        return send_drop_notify (ctx, src_label, SECLABEL, LXC_ID, ret, CTX_ACT_DROP, METRIC_INGRESS);\n", "    ctx_store_meta (ctx, CB_PROXY_MAGIC, ctx->mark);\n", "\n", "#ifdef ENABLE_CUSTOM_CALLS\n", "    if (!proxy_redirect && !encode_custom_prog_meta (ctx, ret, src_label)) {\n", "        tail_call_static (ctx, &CUSTOM_CALLS_MAP, CUSTOM_CALLS_IDX_IPV6_INGRESS);\n", "        update_metrics (ctx_full_len (ctx), METRIC_INGRESS, REASON_MISSED_CUSTOM_CALL);\n", "    }\n", "\n", "#endif\n", "    return ret;\n", "}\n"], "called_function_list": ["encode_custom_prog_meta", "ipv6_policy", "update_metrics", "ctx_redirect_to_proxy6", "ctx_store_meta", "ctx_load_meta", "ctx_full_len", "tail_call_static"], "call_depth": 2, "humanFuncDescription": [{"description": " Identify ipv6 tail call, store data to ctx. Skip tail call when packet is being redirected to a L7 proxy. ", "author": "Yihe Bi", "authorEmail": "ybi@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "tail_ipv6_to_endpoint": [{"capabilities": [], "helperCallParams": {}, "startLine": 1584, "endLine": 1659, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_lxc.c", "funcName": "tail_ipv6_to_endpoint", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx"], "output": "int", "helper": ["tail_call"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["int tail_ipv6_to_endpoint (struct  __ctx_buff *ctx)\n", "{\n", "    __u32 src_identity = ctx_load_meta (ctx, CB_SRC_LABEL);\n", "    bool proxy_redirect __maybe_unused = false;\n", "    void *data, *data_end;\n", "    struct ipv6hdr *ip6;\n", "    __u16 proxy_port = 0;\n", "    enum ct_status ct_status;\n", "    int ret;\n", "    if (!revalidate_data (ctx, &data, &data_end, &ip6)) {\n", "        ret = DROP_INVALID;\n", "        goto out;\n", "    }\n", "    if (identity_is_reserved (src_identity)) {\n", "        union v6addr *src = (union v6addr *) &ip6->saddr;\n", "        struct remote_endpoint_info *info;\n", "        info = lookup_ip6_remote_endpoint (src);\n", "        if (info != NULL) {\n", "            __u32 sec_label = info->sec_label;\n", "            if (sec_label) {\n", "                if (sec_label != HOST_ID)\n", "                    src_identity = sec_label;\n", "            }\n", "        }\n", "        cilium_dbg (ctx, info ? DBG_IP_ID_MAP_SUCCEED6 : DBG_IP_ID_MAP_FAILED6, ((__u32 *) src)[3], src_identity);\n", "    }\n", "    cilium_dbg (ctx, DBG_LOCAL_DELIVERY, LXC_ID, SECLABEL);\n", "\n", "#ifdef LOCAL_DELIVERY_METRICS\n", "    update_metrics (ctx_full_len (ctx), METRIC_INGRESS, REASON_FORWARDED);\n", "\n", "#endif\n", "    ctx_store_meta (ctx, CB_SRC_LABEL, 0);\n", "    ret = ipv6_policy (ctx, 0, src_identity, & ct_status, NULL, & proxy_port, true);\n", "    if (ret == POLICY_ACT_PROXY_REDIRECT) {\n", "        ret = ctx_redirect_to_proxy_hairpin_ipv6 (ctx, proxy_port);\n", "        proxy_redirect = true;\n", "    }\n", "out :\n", "    if (IS_ERR (ret))\n", "        return send_drop_notify (ctx, src_identity, SECLABEL, LXC_ID, ret, CTX_ACT_DROP, METRIC_INGRESS);\n", "\n", "#ifdef ENABLE_CUSTOM_CALLS\n", "    if (!proxy_redirect && !encode_custom_prog_meta (ctx, ret, src_identity)) {\n", "        tail_call_static (ctx, &CUSTOM_CALLS_MAP, CUSTOM_CALLS_IDX_IPV6_INGRESS);\n", "        update_metrics (ctx_full_len (ctx), METRIC_INGRESS, REASON_MISSED_CUSTOM_CALL);\n", "    }\n", "\n", "#endif\n", "    return ret;\n", "}\n"], "called_function_list": ["identity_is_reserved", "encode_custom_prog_meta", "ipv6_policy", "update_metrics", "ctx_store_meta", "ctx_load_meta", "ctx_full_len", "ctx_redirect_to_proxy_hairpin_ipv6", "cilium_dbg", "tail_call_static"], "call_depth": 2, "humanFuncDescription": [{"description": " delivery ipv6 tail call to endpoint, skip if it is send to L7 proxy ", "author": "Yihe Bi", "authorEmail": "ybi@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ipv4_policy": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}, {"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 1671, "endLine": 1879, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_lxc.c", "funcName": "ipv4_policy", "developer_inline_comments": [], "updateMaps": [], "readMaps": ["  CT_TAIL_CALL_BUFFER4"], "input": ["struct  __ctx_buff *ctx", " int ifindex", " __u32 src_label", " enum ct_status *ct_status", " struct ipv4_ct_tuple *tuple_out", " __u16 *proxy_port", " bool from_host __maybe_unused"], "output": "static__always_inlineint", "helper": ["redirect", "map_lookup_elem", "CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["static __always_inline int ipv4_policy (struct  __ctx_buff *ctx, int ifindex, __u32 src_label, enum ct_status *ct_status, struct ipv4_ct_tuple *tuple_out, __u16 *proxy_port, bool from_host __maybe_unused)\n", "{\n", "    struct ct_state ct_state_on_stack __maybe_unused, *ct_state, ct_state_new = {};\n", "    struct ipv4_ct_tuple tuple_on_stack __maybe_unused, *tuple;\n", "    void *data, *data_end;\n", "    struct iphdr *ip4;\n", "    bool skip_ingress_proxy = false;\n", "    bool is_untracked_fragment = false;\n", "    struct ct_buffer4 *ct_buffer;\n", "    __u32 monitor = 0, zero = 0;\n", "    enum trace_reason reason;\n", "    int ret, verdict = 0;\n", "    __be32 orig_sip;\n", "    __u8 policy_match_type = POLICY_MATCH_NONE;\n", "    __u8 audited = 0;\n", "    bool emit_policy_verdict = true;\n", "    if (!revalidate_data (ctx, &data, &data_end, &ip4))\n", "        return DROP_INVALID;\n", "    policy_clear_mark (ctx);\n", "    skip_ingress_proxy = tc_index_skip_ingress_proxy (ctx);\n", "    orig_sip = ip4->saddr;\n", "\n", "#ifndef ENABLE_IPV4_FRAGMENTS\n", "    is_untracked_fragment = ipv4_is_fragment (ip4);\n", "\n", "#endif\n", "    ct_buffer = map_lookup_elem (& CT_TAIL_CALL_BUFFER4, & zero);\n", "    if (!ct_buffer)\n", "        return DROP_INVALID_TC_BUFFER;\n", "    if (ct_buffer->tuple.saddr == 0)\n", "        return DROP_INVALID_TC_BUFFER;\n", "\n", "#if HAVE_DIRECT_ACCESS_TO_MAP_VALUES\n", "    tuple = (struct ipv4_ct_tuple *) &ct_buffer->tuple;\n", "    ct_state = (struct ct_state *) &ct_buffer->ct_state;\n", "\n", "#else\n", "    memcpy (&tuple_on_stack, &ct_buffer->tuple, sizeof (tuple_on_stack));\n", "    tuple = &tuple_on_stack;\n", "    memcpy (&ct_state_on_stack, &ct_buffer->ct_state, sizeof (ct_state_on_stack));\n", "    ct_state = &ct_state_on_stack;\n", "\n", "#endif /* HAVE_DIRECT_ACCESS_TO_MAP_VALUES */\n", "    monitor = ct_buffer->monitor;\n", "    ret = ct_buffer->ret;\n", "    *ct_status = (enum ct_status) ret;\n", "    relax_verifier ();\n", "    if ((ret == CT_REPLY || ret == CT_RELATED) && (ct_state_is_from_l7lb (ct_state) || (ct_state->proxy_redirect && !tc_index_skip_egress_proxy (ctx)))) {\n", "        send_trace_notify4 (ctx, TRACE_TO_PROXY, src_label, SECLABEL, orig_sip, 0, ifindex, (enum trace_reason) ret, monitor);\n", "        if (tuple_out)\n", "            *tuple_out = *tuple;\n", "        return POLICY_ACT_PROXY_REDIRECT;\n", "    }\n", "    if (unlikely (ret == CT_REPLY && ct_state->rev_nat_index && !ct_state->loopback)) {\n", "        struct csum_offset csum_off = {}\n", "        ;\n", "        bool has_l4_header = false;\n", "        int ret2, l4_off;\n", "        l4_off = ETH_HLEN + ipv4_hdrlen (ip4);\n", "        has_l4_header = ipv4_has_l4_header (ip4);\n", "        if (has_l4_header)\n", "            csum_l4_offset_and_flags (tuple->nexthdr, &csum_off);\n", "        ret2 = lb4_rev_nat (ctx, ETH_HLEN, l4_off, & csum_off, ct_state, tuple, REV_NAT_F_TUPLE_SADDR, has_l4_header);\n", "        if (IS_ERR (ret2))\n", "            return ret2;\n", "    }\n", "\n", "#if defined(ENABLE_PER_PACKET_LB) && !defined(DISABLE_LOOPBACK_LB)\n", "    if (unlikely (ct_state->loopback))\n", "        goto skip_policy_enforcement;\n", "\n", "#endif /* ENABLE_PER_PACKET_LB && !DISABLE_LOOPBACK_LB */\n", "    verdict = policy_can_access_ingress (ctx, src_label, SECLABEL, tuple -> dport, tuple -> nexthdr, is_untracked_fragment, & policy_match_type, & audited);\n", "    if (ret != CT_REPLY && ret != CT_RELATED && verdict < 0) {\n", "        send_policy_verdict_notify (ctx, src_label, tuple->dport, tuple->nexthdr, POLICY_INGRESS, 0, verdict, policy_match_type, audited);\n", "        return verdict;\n", "    }\n", "    if (skip_ingress_proxy) {\n", "        verdict = 0;\n", "        emit_policy_verdict = false;\n", "    }\n", "    if (emit_policy_verdict && (ret == CT_NEW || ret == CT_REOPENED)) {\n", "        send_policy_verdict_notify (ctx, src_label, tuple->dport, tuple->nexthdr, POLICY_INGRESS, 0, verdict, policy_match_type, audited);\n", "    }\n", "\n", "#if defined(ENABLE_PER_PACKET_LB) && !defined(DISABLE_LOOPBACK_LB)\n", "skip_policy_enforcement :\n", "\n", "#endif /* ENABLE_PER_PACKET_LB && !DISABLE_LOOPBACK_LB */\n", "\n", "#ifdef ENABLE_NODEPORT\n", "    if (ret == CT_NEW || ret == CT_REOPENED) {\n", "        bool dsr = false;\n", "\n", "# ifdef ENABLE_DSR\n", "        int ret2;\n", "        ret2 = handle_dsr_v4 (ctx, & dsr);\n", "        if (ret2 != 0)\n", "            return ret2;\n", "        ct_state_new.dsr = dsr;\n", "        if (ret == CT_REOPENED && ct_state->dsr != dsr)\n", "            ct_update4_dsr (get_ct_map4 (tuple), tuple, dsr);\n", "\n", "# endif /* ENABLE_DSR */\n", "        if (!dsr) {\n", "            bool node_port = ct_has_nodeport_egress_entry4 (get_ct_map4 (tuple), tuple);\n", "            ct_state_new.node_port = node_port;\n", "            if (ret == CT_REOPENED && ct_state->node_port != node_port)\n", "                ct_update_nodeport (get_ct_map4 (tuple), tuple, node_port);\n", "        }\n", "    }\n", "\n", "#endif /* ENABLE_NODEPORT */\n", "    if (ret == CT_NEW) {\n", "        ct_state_new.src_sec_id = src_label;\n", "        ret = ct_create4 (get_ct_map4 (tuple), & CT_MAP_ANY4, tuple, ctx, CT_INGRESS, & ct_state_new, verdict > 0, false);\n", "        if (IS_ERR (ret))\n", "            return ret;\n", "    }\n", "    if (!revalidate_data (ctx, &data, &data_end, &ip4))\n", "        return DROP_INVALID;\n", "    reason = (enum trace_reason) *ct_status;\n", "    if (redirect_to_proxy (verdict, *ct_status)) {\n", "        *proxy_port = (__u16) verdict;\n", "        send_trace_notify4 (ctx, TRACE_TO_PROXY, src_label, SECLABEL, orig_sip, bpf_ntohs (*proxy_port), ifindex, reason, monitor);\n", "        if (tuple_out)\n", "            *tuple_out = *tuple;\n", "        return POLICY_ACT_PROXY_REDIRECT;\n", "    }\n", "    send_trace_notify4 (ctx, TRACE_TO_LXC, src_label, SECLABEL, orig_sip, LXC_ID, ifindex, reason, monitor);\n", "\n", "#if !defined(ENABLE_ROUTING) && defined(TUNNEL_MODE) && !defined(ENABLE_NODEPORT)\n", "    ctx_change_type (ctx, PACKET_HOST);\n", "\n", "#else\n", "    ifindex = ctx_load_meta (ctx, CB_IFINDEX);\n", "    if (ifindex)\n", "        return redirect_ep (ctx, ifindex, from_host);\n", "\n", "#endif /* !ENABLE_ROUTING && TUNNEL_MODE && !ENABLE_NODEPORT */\n", "    return CTX_ACT_OK;\n", "}\n"], "called_function_list": ["ipv4_is_fragment", "ct_has_nodeport_egress_entry4", "ct_update_nodeport", "ct_update4_dsr", "lb4_rev_nat", "policy_can_access_ingress", "tc_index_skip_ingress_proxy", "ct_create4", "ct_state_is_from_l7lb", "handle_dsr_v4", "get_ct_map4", "ipv4_hdrlen", "redirect_to_proxy", "memcpy", "relax_verifier", "policy_clear_mark", "send_policy_verdict_notify", "redirect_ep", "ipv4_has_l4_header", "ctx_load_meta", "csum_l4_offset_and_flags", "send_trace_notify4", "tc_index_skip_egress_proxy"], "call_depth": 3, "humanFuncDescription": [{"description": " Identify ipv4 message and store its meta data to ctx. ", "author": "Yihe Bi", "authorEmail": "ybi@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "tail_ipv4_policy": [{"capabilities": [], "helperCallParams": {}, "startLine": 1883, "endLine": 1924, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_lxc.c", "funcName": "tail_ipv4_policy", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx"], "output": "int", "helper": ["tail_call"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["int tail_ipv4_policy (struct  __ctx_buff *ctx)\n", "{\n", "    struct ipv4_ct_tuple tuple = {}\n", "    ;\n", "    int ret, ifindex = ctx_load_meta (ctx, CB_IFINDEX);\n", "    __u32 src_label = ctx_load_meta (ctx, CB_SRC_LABEL);\n", "    bool from_host = ctx_load_meta (ctx, CB_FROM_HOST);\n", "    bool proxy_redirect __maybe_unused = false;\n", "    enum ct_status ct_status = 0;\n", "    __u16 proxy_port = 0;\n", "    ctx_store_meta (ctx, CB_SRC_LABEL, 0);\n", "    ctx_store_meta (ctx, CB_FROM_HOST, 0);\n", "    ret = ipv4_policy (ctx, ifindex, src_label, & ct_status, & tuple, & proxy_port, from_host);\n", "    if (ret == POLICY_ACT_PROXY_REDIRECT) {\n", "        ret = ctx_redirect_to_proxy4 (ctx, & tuple, proxy_port, from_host);\n", "        proxy_redirect = true;\n", "    }\n", "    if (IS_ERR (ret))\n", "        return send_drop_notify (ctx, src_label, SECLABEL, LXC_ID, ret, CTX_ACT_DROP, METRIC_INGRESS);\n", "    ctx_store_meta (ctx, CB_PROXY_MAGIC, ctx->mark);\n", "\n", "#ifdef ENABLE_CUSTOM_CALLS\n", "    if (!proxy_redirect && !encode_custom_prog_meta (ctx, ret, src_label)) {\n", "        tail_call_static (ctx, &CUSTOM_CALLS_MAP, CUSTOM_CALLS_IDX_IPV4_INGRESS);\n", "        update_metrics (ctx_full_len (ctx), METRIC_INGRESS, REASON_MISSED_CUSTOM_CALL);\n", "    }\n", "\n", "#endif\n", "    return ret;\n", "}\n"], "called_function_list": ["encode_custom_prog_meta", "update_metrics", "ipv4_policy", "ctx_store_meta", "ctx_load_meta", "ctx_full_len", "ctx_redirect_to_proxy4", "tail_call_static"], "call_depth": 2, "humanFuncDescription": [{"description": " Redirect ipv4 tail call, skip tail calls when packet is being redirected to L7 proxy. ", "author": "Yihe Bi", "authorEmail": "ybi@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "tail_ipv4_to_endpoint": [{"capabilities": [], "helperCallParams": {}, "startLine": 1927, "endLine": 2001, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_lxc.c", "funcName": "tail_ipv4_to_endpoint", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx"], "output": "int", "helper": ["tail_call"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["int tail_ipv4_to_endpoint (struct  __ctx_buff *ctx)\n", "{\n", "    __u32 src_identity = ctx_load_meta (ctx, CB_SRC_LABEL);\n", "    bool proxy_redirect __maybe_unused = false;\n", "    void *data, *data_end;\n", "    struct iphdr *ip4;\n", "    __u16 proxy_port = 0;\n", "    enum ct_status ct_status;\n", "    int ret;\n", "    if (!revalidate_data (ctx, &data, &data_end, &ip4)) {\n", "        ret = DROP_INVALID;\n", "        goto out;\n", "    }\n", "    if (identity_is_reserved (src_identity)) {\n", "        struct remote_endpoint_info *info;\n", "        info = lookup_ip4_remote_endpoint (ip4 -> saddr);\n", "        if (info != NULL) {\n", "            __u32 sec_label = info->sec_label;\n", "            if (sec_label) {\n", "                if (sec_label != HOST_ID)\n", "                    src_identity = sec_label;\n", "            }\n", "        }\n", "        cilium_dbg (ctx, info ? DBG_IP_ID_MAP_SUCCEED4 : DBG_IP_ID_MAP_FAILED4, ip4->saddr, src_identity);\n", "    }\n", "    cilium_dbg (ctx, DBG_LOCAL_DELIVERY, LXC_ID, SECLABEL);\n", "\n", "#ifdef LOCAL_DELIVERY_METRICS\n", "    update_metrics (ctx_full_len (ctx), METRIC_INGRESS, REASON_FORWARDED);\n", "\n", "#endif\n", "    ctx_store_meta (ctx, CB_SRC_LABEL, 0);\n", "    ret = ipv4_policy (ctx, 0, src_identity, & ct_status, NULL, & proxy_port, true);\n", "    if (ret == POLICY_ACT_PROXY_REDIRECT) {\n", "        ret = ctx_redirect_to_proxy_hairpin_ipv4 (ctx, proxy_port);\n", "        proxy_redirect = true;\n", "    }\n", "out :\n", "    if (IS_ERR (ret))\n", "        return send_drop_notify (ctx, src_identity, SECLABEL, LXC_ID, ret, CTX_ACT_DROP, METRIC_INGRESS);\n", "\n", "#ifdef ENABLE_CUSTOM_CALLS\n", "    if (!proxy_redirect && !encode_custom_prog_meta (ctx, ret, src_identity)) {\n", "        tail_call_static (ctx, &CUSTOM_CALLS_MAP, CUSTOM_CALLS_IDX_IPV4_INGRESS);\n", "        update_metrics (ctx_full_len (ctx), METRIC_INGRESS, REASON_MISSED_CUSTOM_CALL);\n", "    }\n", "\n", "#endif\n", "    return ret;\n", "}\n"], "called_function_list": ["identity_is_reserved", "ctx_redirect_to_proxy_hairpin_ipv4", "update_metrics", "encode_custom_prog_meta", "ipv4_policy", "ctx_store_meta", "ctx_load_meta", "ctx_full_len", "cilium_dbg", "tail_call_static"], "call_depth": 2, "humanFuncDescription": [{"description": " Send ipv4 tail call to its enpoint. ", "author": "Yihe Bi", "authorEmail": "ybi@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "handle_policy": [{"capabilities": [], "helperCallParams": {}, "startLine": 2024, "endLine": 2061, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_lxc.c", "funcName": "handle_policy", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx"], "output": "int", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["int handle_policy (struct  __ctx_buff *ctx)\n", "{\n", "    __u32 src_label = ctx_load_meta (ctx, CB_SRC_LABEL);\n", "    __u16 proto;\n", "    int ret;\n", "    if (!validate_ethertype (ctx, &proto)) {\n", "        ret = DROP_UNSUPPORTED_L2;\n", "        goto out;\n", "    }\n", "    switch (proto) {\n", "\n", "#ifdef ENABLE_IPV6\n", "    case bpf_htons (ETH_P_IPV6) :\n", "        invoke_tailcall_if (__and (is_defined (ENABLE_IPV4), is_defined (ENABLE_IPV6)), CILIUM_CALL_IPV6_CT_INGRESS_POLICY_ONLY, tail_ipv6_ct_ingress_policy_only);\n", "        break;\n", "\n", "#endif /* ENABLE_IPV6 */\n", "\n", "#ifdef ENABLE_IPV4\n", "    case bpf_htons (ETH_P_IP) :\n", "        invoke_tailcall_if (__and (is_defined (ENABLE_IPV4), is_defined (ENABLE_IPV6)), CILIUM_CALL_IPV4_CT_INGRESS_POLICY_ONLY, tail_ipv4_ct_ingress_policy_only);\n", "        break;\n", "\n", "#endif /* ENABLE_IPV4 */\n", "    default :\n", "        ret = DROP_UNKNOWN_L3;\n", "        break;\n", "    }\n", "out :\n", "    if (IS_ERR (ret))\n", "        return send_drop_notify (ctx, src_label, SECLABEL, LXC_ID, ret, CTX_ACT_DROP, METRIC_INGRESS);\n", "    return ret;\n", "}\n"], "called_function_list": ["ctx_load_meta", "validate_ethertype"], "call_depth": 1, "humanFuncDescription": [{"description": " Identify if the traffic is ipv6/v4, handle policy using previous helper function. ", "author": "Yihe Bi", "authorEmail": "ybi@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "handle_policy_egress": [{"capabilities": [], "helperCallParams": {}, "startLine": 2072, "endLine": 2113, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_lxc.c", "funcName": "handle_policy_egress", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx"], "output": "int", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["int handle_policy_egress (struct  __ctx_buff *ctx)\n", "{\n", "    __u16 proto;\n", "    int ret;\n", "    if (!validate_ethertype (ctx, &proto)) {\n", "        ret = DROP_UNSUPPORTED_L2;\n", "        goto out;\n", "    }\n", "    ctx_store_meta (ctx, CB_FROM_HOST, FROM_HOST_L7_LB);\n", "    edt_set_aggregate (ctx, 0);\n", "    send_trace_notify (ctx, TRACE_FROM_PROXY, SECLABEL, 0, 0, 0, TRACE_REASON_UNKNOWN, TRACE_PAYLOAD_LEN);\n", "    switch (proto) {\n", "\n", "#ifdef ENABLE_IPV6\n", "    case bpf_htons (ETH_P_IPV6) :\n", "        ep_tail_call (ctx, CILIUM_CALL_IPV6_FROM_LXC);\n", "        ret = DROP_MISSED_TAIL_CALL;\n", "        break;\n", "\n", "#endif /* ENABLE_IPV6 */\n", "\n", "#ifdef ENABLE_IPV4\n", "    case bpf_htons (ETH_P_IP) :\n", "        ep_tail_call (ctx, CILIUM_CALL_IPV4_FROM_LXC);\n", "        ret = DROP_MISSED_TAIL_CALL;\n", "        break;\n", "\n", "#endif /* ENABLE_IPV4 */\n", "    default :\n", "        ret = DROP_UNKNOWN_L3;\n", "        break;\n", "    }\n", "out :\n", "    if (IS_ERR (ret))\n", "        return send_drop_notify (ctx, SECLABEL, 0, LXC_ID, ret, CTX_ACT_DROP, METRIC_EGRESS);\n", "    return ret;\n", "}\n"], "called_function_list": ["send_trace_notify", "edt_set_aggregate", "ep_tail_call", "ctx_store_meta", "validate_ethertype"], "call_depth": 2, "humanFuncDescription": [{"description": " Handle egress traffic  ", "author": "Yihe Bi", "authorEmail": "ybi@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "handle_to_container": [{"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 2120, "endLine": 2195, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_lxc.c", "funcName": "handle_to_container", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx"], "output": "int", "helper": ["tail_call", "CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["int handle_to_container (struct  __ctx_buff *ctx)\n", "{\n", "    enum trace_point trace = TRACE_FROM_STACK;\n", "    __u32 magic, identity = 0;\n", "    __u16 proto;\n", "    int ret;\n", "    if (!validate_ethertype (ctx, &proto)) {\n", "        ret = DROP_UNSUPPORTED_L2;\n", "        goto out;\n", "    }\n", "    bpf_clear_meta (ctx);\n", "    magic = inherit_identity_from_host (ctx, & identity);\n", "    if (magic == MARK_MAGIC_PROXY_INGRESS || magic == MARK_MAGIC_PROXY_EGRESS)\n", "        trace = TRACE_FROM_PROXY;\n", "\n", "#if defined(ENABLE_L7_LB)\n", "    else if (magic == MARK_MAGIC_PROXY_EGRESS_EPID) {\n", "        tail_call_dynamic (ctx, &POLICY_EGRESSCALL_MAP, identity);\n", "        return DROP_MISSED_TAIL_CALL;\n", "    }\n", "\n", "#endif\n", "    send_trace_notify (ctx, trace, identity, 0, 0, ctx->ingress_ifindex, TRACE_REASON_UNKNOWN, TRACE_PAYLOAD_LEN);\n", "\n", "#if defined(ENABLE_HOST_FIREWALL) && !defined(ENABLE_ROUTING)\n", "    if (identity == HOST_ID) {\n", "        ctx_store_meta (ctx, CB_FROM_HOST, 1);\n", "        ctx_store_meta (ctx, CB_DST_ENDPOINT_ID, LXC_ID);\n", "        tail_call_static (ctx, &POLICY_CALL_MAP, HOST_EP_ID);\n", "        return DROP_MISSED_TAIL_CALL;\n", "    }\n", "\n", "#endif /* ENABLE_HOST_FIREWALL && !ENABLE_ROUTING */\n", "    ctx_store_meta (ctx, CB_SRC_LABEL, identity);\n", "    switch (proto) {\n", "\n", "#if defined(ENABLE_ARP_PASSTHROUGH) || defined(ENABLE_ARP_RESPONDER)\n", "    case bpf_htons (ETH_P_ARP) :\n", "        ret = CTX_ACT_OK;\n", "        break;\n", "\n", "#endif\n", "\n", "#ifdef ENABLE_IPV6\n", "    case bpf_htons (ETH_P_IPV6) :\n", "        ep_tail_call (ctx, CILIUM_CALL_IPV6_CT_INGRESS);\n", "        ret = DROP_MISSED_TAIL_CALL;\n", "        break;\n", "\n", "#endif /* ENABLE_IPV6 */\n", "\n", "#ifdef ENABLE_IPV4\n", "    case bpf_htons (ETH_P_IP) :\n", "        ep_tail_call (ctx, CILIUM_CALL_IPV4_CT_INGRESS);\n", "        ret = DROP_MISSED_TAIL_CALL;\n", "        break;\n", "\n", "#endif /* ENABLE_IPV4 */\n", "    default :\n", "        ret = DROP_UNKNOWN_L3;\n", "        break;\n", "    }\n", "out :\n", "    if (IS_ERR (ret))\n", "        return send_drop_notify (ctx, identity, SECLABEL, LXC_ID, ret, CTX_ACT_DROP, METRIC_INGRESS);\n", "    return ret;\n", "}\n"], "called_function_list": ["send_trace_notify", "tail_call_dynamic", "ep_tail_call", "ctx_store_meta", "validate_ethertype", "bpf_clear_meta", "inherit_identity_from_host", "tail_call_static"], "call_depth": 2, "humanFuncDescription": [{"description": " handle ingress policy by checking it's source and destination stored in ctx buffer. Check identity and drop the unsupported and tail calls. ", "author": "Yihe Bi", "authorEmail": "ybi@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "is_v4_loopback": [{"capabilities": [], "helperCallParams": {}, "startLine": 27, "endLine": 31, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "funcName": "is_v4_loopback", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["__be32 daddr"], "output": "static__always_inline__maybe_unusedbool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused bool is_v4_loopback (__be32 daddr)\n", "{\n", "    return (daddr & bpf_htonl (0x7f000000)) == bpf_htonl (0x7f000000);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "is_v6_loopback": [{"capabilities": [], "helperCallParams": {}, "startLine": 33, "endLine": 39, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "funcName": "is_v6_loopback", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const union v6addr *daddr"], "output": "static__always_inline__maybe_unusedbool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused bool is_v6_loopback (const union v6addr *daddr)\n", "{\n", "    union v6addr loopback = {\n", "        .addr [15] = 1,}\n", "    ;\n", "    return ipv6_addrcmp (&loopback, daddr) == 0;\n", "}\n"], "called_function_list": ["ipv6_addrcmp"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ctx_dst_port": [{"capabilities": [], "helperCallParams": {}, "startLine": 42, "endLine": 48, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "funcName": "ctx_dst_port", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct bpf_sock_addr *ctx"], "output": "static__always_inline__maybe_unused__be16", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused __be16 ctx_dst_port (const struct bpf_sock_addr *ctx)\n", "{\n", "    volatile __u32 dport = ctx->user_port;\n", "    return (__be16) dport;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ctx_src_port": [{"capabilities": [], "helperCallParams": {}, "startLine": 50, "endLine": 56, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "funcName": "ctx_src_port", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct bpf_sock *ctx"], "output": "static__always_inline__maybe_unused__be16", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused __be16 ctx_src_port (const struct bpf_sock *ctx)\n", "{\n", "    volatile __u16 sport = (__u16) ctx->src_port;\n", "    return (__be16) bpf_htons (sport);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ctx_set_port": [{"capabilities": [], "helperCallParams": {}, "startLine": 58, "endLine": 62, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "funcName": "ctx_set_port", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct bpf_sock_addr *ctx", " __be16 dport"], "output": "static__always_inline__maybe_unusedvoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused void ctx_set_port (struct bpf_sock_addr *ctx, __be16 dport)\n", "{\n", "    ctx->user_port = (__u32) dport;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "task_in_extended_hostns": [{"capabilities": [{"capability": "read_sys_info", "read_sys_info": [{"Project": "cilium", "Return Type": "u32", "Description": "Retrieve the classid for the current task , i. e. for the net_cls cgroup to which <[ skb ]>(IP: 0) belongs. This helper can be used on TC egress path , but not on ingress. The net_cls cgroup provides an interface to tag network packets based on a user-provided identifier for all traffic coming from the tasks belonging to the related cgroup. See also the related kernel documentation , available from the Linux sources in file Documentation/admin-guide/cgroup-v1/net_cls. rst. The Linux kernel has two versions for cgroups: there are cgroups v1 and cgroups v2. Both are available to users , who can use a mixture of them , but note that the net_cls cgroup is for cgroup v1 only. This makes it incompatible with BPF programs run on cgroups , which is a cgroup-v2-only feature (a socket can only hold data for one version of cgroups at a time). This helper is only available is the kernel was compiled with the CONFIG_CGROUP_NET_CLASSID configuration option set to \"y\" or to \"m\" ", "Return": " The classid, or 0 for the default unconfigured classid.", "Function Name": "get_cgroup_classid", "Input Params": ["{Type: struct sk_buff ,Var: *skb}"], "compatible_hookpoints": ["sched_cls", "sched_act", "lwt_in", "lwt_out", "lwt_xmit", "lwt_seg6local"], "capabilities": ["read_sys_info"]}]}], "helperCallParams": {}, "startLine": 64, "endLine": 72, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "funcName": "task_in_extended_hostns", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["void"], "output": "static__always_inline__maybe_unusedbool", "helper": ["get_cgroup_classid"], "compatibleHookpoints": ["sched_cls", "lwt_xmit", "lwt_in", "sched_act", "lwt_out", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused bool task_in_extended_hostns (void)\n", "{\n", "\n", "#ifdef ENABLE_MKE\n", "    return get_cgroup_classid () == MKE_HOST;\n", "\n", "#else\n", "    return false;\n", "\n", "#endif\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ctx_in_hostns": [{"capabilities": [], "helperCallParams": {}, "startLine": 74, "endLine": 89, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "funcName": "ctx_in_hostns", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["void * ctx __maybe_unused", " __net_cookie *cookie"], "output": "static__always_inline__maybe_unusedbool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused bool ctx_in_hostns (void * ctx __maybe_unused, __net_cookie *cookie)\n", "{\n", "\n", "#ifdef BPF_HAVE_NETNS_COOKIE\n", "    __net_cookie own_cookie = get_netns_cookie (ctx);\n", "    if (cookie)\n", "        *cookie = own_cookie;\n", "    return own_cookie == HOST_NETNS_COOKIE || task_in_extended_hostns ();\n", "\n", "#else\n", "    if (cookie)\n", "        *cookie = 0;\n", "    return true;\n", "\n", "#endif\n", "}\n"], "called_function_list": ["task_in_extended_hostns"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "sock_local_cookie": [{"capabilities": [{"capability": "read_sys_info", "read_sys_info": [{"Project": "cilium", "Return Type": "u64", "Description": "Equivalent to get_socket_cookie() helper that accepts skb , but gets socket from struct sock_ops context. ", "Return": " A 8-byte long non-decreasing number.", "Function Name": "get_socket_cookie", "Input Params": ["{Type: struct sock_ops ,Var: *ctx}"], "compatible_hookpoints": ["socket_filter", "sched_cls", "sched_act", "cgroup_skb", "sock_ops", "sk_skb", "cgroup_sock_addr"], "capabilities": ["read_sys_info"]}, {"Project": "cilium", "Return Type": "u32", "Description": "Get a pseudo-random number. From a security point of view , this helper uses its own pseudo-random internal state , and cannot be used to infer the seed of other random functions in the kernel. However , it is essential to note that the generator used by the helper is not cryptographically secure. ", "Return": " A random 32-bit unsigned value.", "Function Name": "get_prandom_u32", "Input Params": ["{Type: voi ,Var: void}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "raw_tracepoint_writable"], "capabilities": ["read_sys_info"]}]}], "helperCallParams": {}, "startLine": 91, "endLine": 119, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "funcName": "sock_local_cookie", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct bpf_sock_addr *ctx"], "output": "static__always_inline__maybe_unused__sock_cookie", "helper": ["get_socket_cookie", "get_prandom_u32"], "compatibleHookpoints": ["cgroup_skb", "sched_cls", "cgroup_sock_addr", "sock_ops", "sched_act", "sk_skb", "socket_filter"], "source": ["static __always_inline __maybe_unused __sock_cookie sock_local_cookie (struct bpf_sock_addr *ctx)\n", "{\n", "\n", "#ifdef BPF_HAVE_SOCKET_COOKIE\n", "    return get_socket_cookie (ctx);\n", "\n", "#else\n", "    return ctx->protocol == IPPROTO_TCP ? get_prandom_u32 () : 0;\n", "\n", "#endif\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "sock_is_health_check": [{"capabilities": [], "helperCallParams": {}, "startLine": 121, "endLine": 131, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "funcName": "sock_is_health_check", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct bpf_sock_addr * ctx __maybe_unused"], "output": "static__always_inline__maybe_unusedbool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused bool sock_is_health_check (struct bpf_sock_addr * ctx __maybe_unused)\n", "{\n", "\n", "#ifdef ENABLE_HEALTH_CHECK\n", "    int val;\n", "    if (!get_socket_opt (ctx, SOL_SOCKET, SO_MARK, &val, sizeof (val)))\n", "        return val == MARK_MAGIC_HEALTH;\n", "\n", "#endif\n", "    return false;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "sock_select_slot": [{"capabilities": [{"capability": "read_sys_info", "read_sys_info": [{"Project": "cilium", "Return Type": "u32", "Description": "Get a pseudo-random number. From a security point of view , this helper uses its own pseudo-random internal state , and cannot be used to infer the seed of other random functions in the kernel. However , it is essential to note that the generator used by the helper is not cryptographically secure. ", "Return": " A random 32-bit unsigned value.", "Function Name": "get_prandom_u32", "Input Params": ["{Type: voi ,Var: void}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "raw_tracepoint_writable"], "capabilities": ["read_sys_info"]}]}], "helperCallParams": {}, "startLine": 133, "endLine": 138, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "funcName": "sock_select_slot", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct bpf_sock_addr *ctx"], "output": "static__always_inline__maybe_unused__u64", "helper": ["get_prandom_u32"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused __u64 sock_select_slot (struct bpf_sock_addr *ctx)\n", "{\n", "    return ctx->protocol == IPPROTO_TCP ? get_prandom_u32 () : sock_local_cookie (ctx);\n", "}\n"], "called_function_list": ["sock_local_cookie"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "sock_proto_enabled": [{"capabilities": [], "helperCallParams": {}, "startLine": 140, "endLine": 156, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "funcName": "sock_proto_enabled", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["__u32 proto"], "output": "static__always_inline__maybe_unusedbool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused bool sock_proto_enabled (__u32 proto)\n", "{\n", "    switch (proto) {\n", "\n", "#ifdef ENABLE_SOCKET_LB_TCP\n", "    case IPPROTO_TCP :\n", "        return true;\n", "\n", "#endif /* ENABLE_SOCKET_LB_TCP */\n", "\n", "#ifdef ENABLE_SOCKET_LB_UDP\n", "    case IPPROTO_UDPLITE :\n", "    case IPPROTO_UDP :\n", "        return true;\n", "\n", "#endif /* ENABLE_SOCKET_LB_UDP */\n", "    default :\n", "        return false;\n", "    }\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "sock4_update_revnat": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}, {"capability": "map_update", "map_update": [{"Project": "cilium", "Return Type": "int", "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "map_update_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}", "{Type:  const void ,Var: *value}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_update"]}]}], "helperCallParams": {}, "startLine": 168, "endLine": 190, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "funcName": "sock4_update_revnat", "developer_inline_comments": [], "updateMaps": [" LB4_REVERSE_NAT_SK_MAP"], "readMaps": ["  LB4_REVERSE_NAT_SK_MAP"], "input": ["struct bpf_sock_addr *ctx", " const struct lb4_backend *backend", " const struct lb4_key *orig_key", " __u16 rev_nat_id"], "output": "static__always_inlineint", "helper": ["map_lookup_elem", "map_update_elem"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int sock4_update_revnat (struct bpf_sock_addr *ctx, const struct lb4_backend *backend, const struct lb4_key *orig_key, __u16 rev_nat_id)\n", "{\n", "    struct ipv4_revnat_entry val = {}, *tmp;\n", "    struct ipv4_revnat_tuple key = {}\n", "    ;\n", "    int ret = 0;\n", "    key.cookie = sock_local_cookie (ctx);\n", "    key.address = backend->address;\n", "    key.port = backend->port;\n", "    val.address = orig_key->address;\n", "    val.port = orig_key->dport;\n", "    val.rev_nat_index = rev_nat_id;\n", "    tmp = map_lookup_elem (& LB4_REVERSE_NAT_SK_MAP, & key);\n", "    if (!tmp || memcmp (tmp, &val, sizeof (val)))\n", "        ret = map_update_elem (&LB4_REVERSE_NAT_SK_MAP, &key, &val, 0);\n", "    return ret;\n", "}\n"], "called_function_list": ["memcmp", "sock_local_cookie"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 192, "endLine": 199, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "funcName": "sock4_update_revnat", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct bpf_sock_addr * ctx __maybe_unused", " struct lb4_backend * backend __maybe_unused", " struct lb4_key * orig_key __maybe_unused", " __u16 rev_nat_id __maybe_unused"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int sock4_update_revnat (struct bpf_sock_addr * ctx __maybe_unused, struct lb4_backend * backend __maybe_unused, struct lb4_key * orig_key __maybe_unused, __u16 rev_nat_id __maybe_unused)\n", "{\n", "    return 0;\n", "}\n"], "called_function_list": ["memcmp", "sock_local_cookie"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "sock4_skip_xlate": [{"capabilities": [], "helperCallParams": {}, "startLine": 202, "endLine": 218, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "funcName": "sock4_skip_xlate", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct lb4_service *svc", " __be32 address"], "output": "static__always_inlinebool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline bool sock4_skip_xlate (struct lb4_service *svc, __be32 address)\n", "{\n", "    if (lb4_to_lb6_service (svc))\n", "        return true;\n", "    if (lb4_svc_is_external_ip (svc) || (lb4_svc_is_hostport (svc) && !is_v4_loopback (address))) {\n", "        struct remote_endpoint_info *info;\n", "        info = ipcache_lookup4 (& IPCACHE_MAP, address, V4_CACHE_KEY_LEN);\n", "        if (info == NULL || info->sec_label != HOST_ID)\n", "            return true;\n", "    }\n", "    return false;\n", "}\n"], "called_function_list": ["is_v4_loopback", "lb4_svc_is_external_ip", "lb4_svc_is_hostport", "ipcache_lookup4", "lb4_to_lb6_service"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "sock4_wildcard_lookup": [{"capabilities": [], "helperCallParams": {}, "startLine": 221, "endLine": 251, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "funcName": "sock4_wildcard_lookup", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct lb4_key * key __maybe_unused", " const bool include_remote_hosts __maybe_unused", " const bool inv_match __maybe_unused", " const bool in_hostns __maybe_unused"], "output": "static__always_inlinestructlb4_service", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline struct lb4_service *sock4_wildcard_lookup (struct lb4_key * key __maybe_unused, const bool include_remote_hosts __maybe_unused, const bool inv_match __maybe_unused, const bool in_hostns __maybe_unused)\n", "{\n", "    struct remote_endpoint_info *info;\n", "    __u16 service_port;\n", "    service_port = bpf_ntohs (key -> dport);\n", "    if ((service_port < NODEPORT_PORT_MIN || service_port > NODEPORT_PORT_MAX) ^ inv_match)\n", "        return NULL;\n", "    if (in_hostns && is_v4_loopback (key->address))\n", "        goto wildcard_lookup;\n", "    info = ipcache_lookup4 (& IPCACHE_MAP, key -> address, V4_CACHE_KEY_LEN);\n", "    if (info != NULL && (info->sec_label == HOST_ID || (include_remote_hosts && identity_is_remote_node (info->sec_label))))\n", "        goto wildcard_lookup;\n", "    return NULL;\n", "wildcard_lookup :\n", "    key->address = 0;\n", "    return lb4_lookup_service (key, true);\n", "}\n"], "called_function_list": ["identity_is_remote_node", "lb4_lookup_service", "is_v4_loopback", "ipcache_lookup4"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "sock4_wildcard_lookup_full": [{"capabilities": [], "helperCallParams": {}, "startLine": 254, "endLine": 272, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "funcName": "sock4_wildcard_lookup_full", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct lb4_key * key __maybe_unused", " const bool in_hostns __maybe_unused"], "output": "static__always_inlinestructlb4_service", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline struct lb4_service *sock4_wildcard_lookup_full (struct lb4_key * key __maybe_unused, const bool in_hostns __maybe_unused)\n", "{\n", "    struct lb4_service *svc = NULL;\n", "\n", "#ifdef ENABLE_NODEPORT\n", "    svc = sock4_wildcard_lookup (key, true, false, in_hostns);\n", "    if (svc && !lb4_svc_is_nodeport (svc))\n", "        svc = NULL;\n", "    if (!svc) {\n", "        svc = sock4_wildcard_lookup (key, false, true, in_hostns);\n", "        if (svc && !lb4_svc_is_hostport (svc))\n", "            svc = NULL;\n", "    }\n", "\n", "#endif /* ENABLE_NODEPORT */\n", "    return svc;\n", "}\n"], "called_function_list": ["sock4_wildcard_lookup", "lb4_svc_is_nodeport", "lb4_svc_is_hostport"], "call_depth": 3, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "sock4_skip_xlate_if_same_netns": [{"capabilities": [{"capability": "read_sys_info", "read_sys_info": [{"Project": "cilium", "Return Type": "struct sock*", "Description": "Look for UDP socket matching <[ tuple ]>(IP: 1) , optionally in a child network namespace netns. The return value must be checked , and if non-NULL , released via sk_release(). The <[ ctx ]>(IP: 0) should point to the context of the program , such as the skb or socket (depending on the hook in use). This is used to determine the base network namespace for the lookup. <[ tuple_size ]>(IP: 2) must be one of: sizeof(tuple->ipv4) Look for an IPv4 socket. sizeof(tuple->ipv6) Look for an IPv6 socket. If the <[ netns ]>(IP: 3) is a negative signed 32-bit integer , then the socket lookup table in the <[ netns ]>(IP: 3) associated with the <[ ctx ]>(IP: 0) will will be used. For the TC hooks , this is the <[ netns ]>(IP: 3) of the device in the skb. For socket hooks , this is the <[ netns ]>(IP: 3) of the socket. If <[ netns ]>(IP: 3) is any other signed 32-bit value greater than or equal to zero then it specifies the ID of the <[ netns ]>(IP: 3) relative to the <[ netns ]>(IP: 3) associated with the ctx. <[ netns ]>(IP: 3) values beyond the range of 32-bit integers are reserved for future use. All values for <[ flags ]>(IP: 4) are reserved for future usage , and must be left at zero. This helper is available only if the kernel was compiled with CONFIG_NET configuration option. ", "Return": " Pointer  to  struct  sock, or NULL in case of failure.  For sockets with                     reuseport option, the struct  sock result is  from  reuse->socks[]  using                     the hash of the tuple.", "Function Name": "sk_lookup_udp", "Input Params": ["{Type: void ,Var: *ctx}", "{Type:  struct sock_tuple ,Var: *tuple}", "{Type:  u32 ,Var: tuple_size}", "{Type:  u64 ,Var: netns}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp", "sk_skb", "cgroup_sock_addr"], "capabilities": ["read_sys_info"]}, {"Project": "cilium", "Return Type": "struct sock*", "Description": "Look for TCP socket matching <[ tuple ]>(IP: 1) , optionally in a child network namespace netns. The return value must be checked , and if non-NULL , released via sk_release(). The <[ ctx ]>(IP: 0) should point to the context of the program , such as the skb or socket (depending on the hook in use). This is used to determine the base network namespace for the lookup. <[ tuple_size ]>(IP: 2) must be one of: sizeof(tuple->ipv4) Look for an IPv4 socket. sizeof(tuple->ipv6) Look for an IPv6 socket. If the <[ netns ]>(IP: 3) is a negative signed 32-bit integer , then the socket lookup table in the <[ netns ]>(IP: 3) associated with the <[ ctx ]>(IP: 0) will will be used. For the TC hooks , this is the <[ netns ]>(IP: 3) of the device in the skb. For socket hooks , this is the <[ netns ]>(IP: 3) of the socket. If <[ netns ]>(IP: 3) is any other signed 32-bit value greater than or equal to zero then it specifies the ID of the <[ netns ]>(IP: 3) relative to the <[ netns ]>(IP: 3) associated with the ctx. <[ netns ]>(IP: 3) values beyond the range of 32-bit integers are reserved for future use. All values for <[ flags ]>(IP: 4) are reserved for future usage , and must be left at zero. This helper is available only if the kernel was compiled with CONFIG_NET configuration option. ", "Return": " Pointer to struct  sock, or NULL in case of failure.   For  sockets  with                     reuseport  option,  the  struct  sock result is from reuse->socks[] using                     the hash of the tuple.", "Function Name": "sk_lookup_tcp", "Input Params": ["{Type: void ,Var: *ctx}", "{Type:  struct sock_tuple ,Var: *tuple}", "{Type:  u32 ,Var: tuple_size}", "{Type:  u64 ,Var: netns}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp", "sk_skb", "cgroup_sock_addr"], "capabilities": ["read_sys_info"]}]}], "helperCallParams": {}, "startLine": 293, "endLine": 321, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "funcName": "sock4_skip_xlate_if_same_netns", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct bpf_sock_addr * ctx __maybe_unused", " const struct lb4_backend * backend __maybe_unused"], "output": "static__always_inlinebool", "helper": ["sk_lookup_udp", "sk_lookup_tcp", "sk_release"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "sched_act", "xdp", "sk_skb"], "source": ["static __always_inline bool sock4_skip_xlate_if_same_netns (struct bpf_sock_addr * ctx __maybe_unused, const struct lb4_backend * backend __maybe_unused)\n", "{\n", "\n", "#ifdef BPF_HAVE_SOCKET_LOOKUP\n", "    struct bpf_sock_tuple tuple = {\n", "        .ipv4.daddr = backend->address,\n", "        .ipv4.dport = backend->port,}\n", "    ;\n", "    struct bpf_sock *sk = NULL;\n", "    switch (ctx->protocol) {\n", "    case IPPROTO_TCP :\n", "        sk = sk_lookup_tcp (ctx, &tuple, sizeof (tuple.ipv4), BPF_F_CURRENT_NETNS, 0);\n", "        break;\n", "    case IPPROTO_UDP :\n", "        sk = sk_lookup_udp (ctx, &tuple, sizeof (tuple.ipv4), BPF_F_CURRENT_NETNS, 0);\n", "        break;\n", "    }\n", "    if (sk) {\n", "        sk_release (sk);\n", "        return true;\n", "    }\n", "\n", "#endif /* BPF_HAVE_SOCKET_LOOKUP */\n", "    return false;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__sock4_xlate_fwd": [{"capabilities": [], "helperCallParams": {}, "startLine": 323, "endLine": 458, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "funcName": "__sock4_xlate_fwd", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct bpf_sock_addr *ctx", " struct bpf_sock_addr *ctx_full", " const bool udp_only"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int __sock4_xlate_fwd (struct bpf_sock_addr *ctx, struct bpf_sock_addr *ctx_full, const bool udp_only)\n", "{\n", "    union lb4_affinity_client_id id;\n", "    const bool in_hostns = ctx_in_hostns (ctx_full, & id.client_cookie);\n", "    struct lb4_backend *backend;\n", "    struct lb4_service *svc;\n", "    struct lb4_key key = {\n", "        .address = ctx->user_ip4,\n", "        .dport = ctx_dst_port (ctx),}, orig_key = key;\n", "    struct lb4_service *backend_slot;\n", "    bool backend_from_affinity = false;\n", "    __u32 backend_id = 0;\n", "\n", "#ifdef ENABLE_L7_LB\n", "    struct lb4_backend l7backend;\n", "\n", "#endif\n", "    if (is_defined (ENABLE_SOCKET_LB_HOST_ONLY) && !in_hostns)\n", "        return -ENXIO;\n", "    if (!udp_only && !sock_proto_enabled (ctx->protocol))\n", "        return -ENOTSUP;\n", "    svc = lb4_lookup_service (& key, true);\n", "    if (!svc)\n", "        svc = sock4_wildcard_lookup_full (&key, in_hostns);\n", "    if (!svc)\n", "        return -ENXIO;\n", "    if (sock4_skip_xlate (svc, orig_key.address))\n", "        return -EPERM;\n", "\n", "#ifdef ENABLE_L7_LB\n", "    if (lb4_svc_is_l7loadbalancer (svc)) {\n", "        if (is_defined (BPF_HAVE_NETNS_COOKIE) && in_hostns) {\n", "            l7backend.address = bpf_htonl (0x7f000001);\n", "            l7backend.port = (__be16) svc->l7_lb_proxy_port;\n", "            l7backend.proto = 0;\n", "            l7backend.flags = 0;\n", "            backend = &l7backend;\n", "            goto out;\n", "        }\n", "        return 0;\n", "    }\n", "\n", "#endif /* ENABLE_L7_LB */\n", "    if (lb4_svc_is_affinity (svc)) {\n", "        backend_id = lb4_affinity_backend_id_by_netns (svc, & id);\n", "        backend_from_affinity = true;\n", "        if (backend_id != 0) {\n", "            backend = __lb4_lookup_backend (backend_id);\n", "            if (!backend)\n", "                backend_id = 0;\n", "        }\n", "    }\n", "    if (backend_id == 0) {\n", "        backend_from_affinity = false;\n", "        key.backend_slot = (sock_select_slot (ctx_full) % svc->count) + 1;\n", "        backend_slot = __lb4_lookup_backend_slot (& key);\n", "        if (!backend_slot) {\n", "            update_metrics (0, METRIC_EGRESS, REASON_LB_NO_BACKEND_SLOT);\n", "            return -ENOENT;\n", "        }\n", "        backend_id = backend_slot->backend_id;\n", "        backend = __lb4_lookup_backend (backend_id);\n", "    }\n", "    if (!backend) {\n", "        update_metrics (0, METRIC_EGRESS, REASON_LB_NO_BACKEND);\n", "        return -ENOENT;\n", "    }\n", "    if (lb4_svc_is_localredirect (svc) && sock4_skip_xlate_if_same_netns (ctx_full, backend))\n", "        return -ENXIO;\n", "    if (lb4_svc_is_affinity (svc) && !backend_from_affinity)\n", "        lb4_update_affinity_by_netns (svc, &id, backend_id);\n", "\n", "#ifdef ENABLE_L7_LB\n", "out :\n", "\n", "#endif\n", "    if (sock4_update_revnat (ctx_full, backend, &orig_key, svc->rev_nat_index) < 0) {\n", "        update_metrics (0, METRIC_EGRESS, REASON_LB_REVNAT_UPDATE);\n", "        return -ENOMEM;\n", "    }\n", "    ctx->user_ip4 = backend->address;\n", "    ctx_set_port (ctx, backend->port);\n", "    return 0;\n", "}\n"], "called_function_list": ["update_metrics", "sock4_update_revnat", "lb4_svc_is_localredirect", "sock4_wildcard_lookup_full", "ctx_set_port", "__lb4_lookup_backend", "lb4_svc_is_l7loadbalancer", "lb4_svc_is_affinity", "ctx_dst_port", "sock_proto_enabled", "sock_select_slot", "ctx_in_hostns", "sock4_skip_xlate_if_same_netns", "lb4_update_affinity_by_netns", "lb4_lookup_service", "sock4_skip_xlate", "__lb4_lookup_backend_slot", "lb4_affinity_backend_id_by_netns"], "call_depth": 4, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__sock4_health_fwd": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}, {"capability": "read_sys_info", "read_sys_info": [{"Project": "cilium", "Return Type": "u64", "Description": "Equivalent to get_socket_cookie() helper that accepts skb , but gets socket from struct sock_ops context. ", "Return": " A 8-byte long non-decreasing number.", "Function Name": "get_socket_cookie", "Input Params": ["{Type: struct sock_ops ,Var: *ctx}"], "compatible_hookpoints": ["socket_filter", "sched_cls", "sched_act", "cgroup_skb", "sock_ops", "sk_skb", "cgroup_sock_addr"], "capabilities": ["read_sys_info"]}]}], "helperCallParams": {}, "startLine": 460, "endLine": 476, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "funcName": "__sock4_health_fwd", "developer_inline_comments": [], "updateMaps": [], "readMaps": [" LB4_HEALTH_MAP"], "input": ["struct bpf_sock_addr * ctx __maybe_unused"], "output": "static__always_inlineint", "helper": ["map_lookup_elem", "get_socket_cookie"], "compatibleHookpoints": ["cgroup_skb", "sched_cls", "cgroup_sock_addr", "sock_ops", "sched_act", "sk_skb", "socket_filter"], "source": ["static __always_inline int __sock4_health_fwd (struct bpf_sock_addr * ctx __maybe_unused)\n", "{\n", "    int ret = lb_skip_l4_dnat () ? SYS_PROCEED : SYS_REJECT;\n", "\n", "#ifdef ENABLE_HEALTH_CHECK\n", "    __sock_cookie key = get_socket_cookie (ctx);\n", "    struct lb4_health *val = NULL;\n", "    if (!lb_skip_l4_dnat ())\n", "        val = map_lookup_elem (&LB4_HEALTH_MAP, &key);\n", "    if (val) {\n", "        ctx_set_port (ctx, val->peer.port);\n", "        ret = SYS_PROCEED;\n", "    }\n", "\n", "#endif /* ENABLE_HEALTH_CHECK */\n", "    return ret;\n", "}\n"], "called_function_list": ["ctx_set_port", "lb_skip_l4_dnat"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "sock4_connect": [{"capabilities": [], "helperCallParams": {}, "startLine": 479, "endLine": 486, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "funcName": "sock4_connect", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct bpf_sock_addr *ctx"], "output": "int", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["int sock4_connect (struct bpf_sock_addr *ctx)\n", "{\n", "    if (sock_is_health_check (ctx))\n", "        return __sock4_health_fwd (ctx);\n", "    __sock4_xlate_fwd (ctx, ctx, false);\n", "    return SYS_PROCEED;\n", "}\n"], "called_function_list": ["__sock4_health_fwd", "__sock4_xlate_fwd", "sock_is_health_check"], "call_depth": 5, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__sock4_post_bind": [{"capabilities": [], "helperCallParams": {}, "startLine": 489, "endLine": 520, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "funcName": "__sock4_post_bind", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct bpf_sock *ctx", " struct bpf_sock *ctx_full"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int __sock4_post_bind (struct bpf_sock *ctx, struct bpf_sock *ctx_full)\n", "{\n", "    struct lb4_service *svc;\n", "    struct lb4_key key = {\n", "        .address = ctx->src_ip4,\n", "        .dport = ctx_src_port (ctx),}\n", "    ;\n", "    if (!sock_proto_enabled (ctx->protocol) || !ctx_in_hostns (ctx_full, NULL))\n", "        return 0;\n", "    svc = lb4_lookup_service (& key, true);\n", "    if (!svc)\n", "        svc = sock4_wildcard_lookup (&key, false, false, true);\n", "    if (svc && (lb4_svc_is_nodeport (svc) || lb4_svc_is_external_ip (svc) || lb4_svc_is_loadbalancer (svc)))\n", "        return -EADDRINUSE;\n", "    return 0;\n", "}\n"], "called_function_list": ["lb4_lookup_service", "lb4_svc_is_nodeport", "lb4_svc_is_external_ip", "sock4_wildcard_lookup", "lb4_svc_is_loadbalancer", "ctx_src_port", "sock_proto_enabled", "ctx_in_hostns"], "call_depth": 3, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "sock4_post_bind": [{"capabilities": [], "helperCallParams": {}, "startLine": 523, "endLine": 529, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "funcName": "sock4_post_bind", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct bpf_sock *ctx"], "output": "int", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["int sock4_post_bind (struct bpf_sock *ctx)\n", "{\n", "    if (__sock4_post_bind (ctx, ctx) < 0)\n", "        return SYS_REJECT;\n", "    return SYS_PROCEED;\n", "}\n"], "called_function_list": ["__sock4_post_bind"], "call_depth": 4, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "sock4_auto_bind": [{"capabilities": [], "helperCallParams": {}, "startLine": 533, "endLine": 537, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "funcName": "sock4_auto_bind", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct bpf_sock_addr *ctx"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void sock4_auto_bind (struct bpf_sock_addr *ctx)\n", "{\n", "    ctx->user_ip4 = 0;\n", "    ctx_set_port (ctx, 0);\n", "}\n"], "called_function_list": ["ctx_set_port"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__sock4_pre_bind": [{"capabilities": [{"capability": "map_update", "map_update": [{"Project": "cilium", "Return Type": "int", "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "map_update_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}", "{Type:  const void ,Var: *value}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_update"]}]}, {"capability": "read_sys_info", "read_sys_info": [{"Project": "cilium", "Return Type": "u64", "Description": "Equivalent to get_socket_cookie() helper that accepts skb , but gets socket from struct sock_ops context. ", "Return": " A 8-byte long non-decreasing number.", "Function Name": "get_socket_cookie", "Input Params": ["{Type: struct sock_ops ,Var: *ctx}"], "compatible_hookpoints": ["socket_filter", "sched_cls", "sched_act", "cgroup_skb", "sock_ops", "sk_skb", "cgroup_sock_addr"], "capabilities": ["read_sys_info"]}]}], "helperCallParams": {}, "startLine": 539, "endLine": 559, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "funcName": "__sock4_pre_bind", "developer_inline_comments": [], "updateMaps": ["  LB4_HEALTH_MAP"], "readMaps": [], "input": ["struct bpf_sock_addr *ctx", " struct bpf_sock_addr *ctx_full"], "output": "static__always_inlineint", "helper": ["map_update_elem", "get_socket_cookie"], "compatibleHookpoints": ["cgroup_skb", "sched_cls", "cgroup_sock_addr", "sock_ops", "sched_act", "sk_skb", "socket_filter"], "source": ["static __always_inline int __sock4_pre_bind (struct bpf_sock_addr *ctx, struct bpf_sock_addr *ctx_full)\n", "{\n", "    __sock_cookie key = get_socket_cookie (ctx_full);\n", "    struct lb4_health val = {\n", "        .peer = {\n", "            .address = ctx->user_ip4,\n", "            .port = ctx_dst_port (ctx),\n", "            .proto = (__u8) ctx->protocol,},}\n", "    ;\n", "    int ret;\n", "    ret = map_update_elem (& LB4_HEALTH_MAP, & key, & val, 0);\n", "    if (!ret)\n", "        sock4_auto_bind (ctx);\n", "    return ret;\n", "}\n"], "called_function_list": ["sock4_auto_bind", "ctx_dst_port"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "sock4_pre_bind": [{"capabilities": [], "helperCallParams": {}, "startLine": 562, "endLine": 573, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "funcName": "sock4_pre_bind", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct bpf_sock_addr *ctx"], "output": "int", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["int sock4_pre_bind (struct bpf_sock_addr *ctx)\n", "{\n", "    int ret = SYS_PROCEED;\n", "    if (!sock_proto_enabled (ctx->protocol) || !ctx_in_hostns (ctx, NULL))\n", "        return ret;\n", "    if (sock_is_health_check (ctx) && __sock4_pre_bind (ctx, ctx))\n", "        ret = SYS_REJECT;\n", "    return ret;\n", "}\n"], "called_function_list": ["__sock4_pre_bind", "sock_proto_enabled", "ctx_in_hostns", "sock_is_health_check"], "call_depth": 3, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__sock4_xlate_rev": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 577, "endLine": 611, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "funcName": "__sock4_xlate_rev", "developer_inline_comments": [], "updateMaps": [" LB4_REVERSE_NAT_SK_MAP"], "readMaps": ["  LB4_REVERSE_NAT_SK_MAP"], "input": ["struct bpf_sock_addr *ctx", " struct bpf_sock_addr *ctx_full"], "output": "static__always_inlineint", "helper": ["map_delete_elem", "map_lookup_elem"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int __sock4_xlate_rev (struct bpf_sock_addr *ctx, struct bpf_sock_addr *ctx_full)\n", "{\n", "    struct ipv4_revnat_entry *val;\n", "    struct ipv4_revnat_tuple key = {\n", "        .cookie = sock_local_cookie (ctx_full),\n", "        .address = ctx->user_ip4,\n", "        .port = ctx_dst_port (ctx),}\n", "    ;\n", "    val = map_lookup_elem (& LB4_REVERSE_NAT_SK_MAP, & key);\n", "    if (val) {\n", "        struct lb4_service *svc;\n", "        struct lb4_key svc_key = {\n", "            .address = val->address,\n", "            .dport = val->port,}\n", "        ;\n", "        svc = lb4_lookup_service (& svc_key, true);\n", "        if (!svc)\n", "            svc = sock4_wildcard_lookup_full (&svc_key, ctx_in_hostns (ctx_full, NULL));\n", "        if (!svc || svc->rev_nat_index != val->rev_nat_index) {\n", "            map_delete_elem (&LB4_REVERSE_NAT_SK_MAP, &key);\n", "            update_metrics (0, METRIC_INGRESS, REASON_LB_REVNAT_STALE);\n", "            return -ENOENT;\n", "        }\n", "        ctx->user_ip4 = val->address;\n", "        ctx_set_port (ctx, val->port);\n", "        return 0;\n", "    }\n", "    return -ENXIO;\n", "}\n"], "called_function_list": ["lb4_lookup_service", "ctx_dst_port", "update_metrics", "sock4_wildcard_lookup_full", "ctx_set_port", "ctx_in_hostns", "sock_local_cookie"], "call_depth": 4, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "sock4_sendmsg": [{"capabilities": [], "helperCallParams": {}, "startLine": 614, "endLine": 618, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "funcName": "sock4_sendmsg", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct bpf_sock_addr *ctx"], "output": "int", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["int sock4_sendmsg (struct bpf_sock_addr *ctx)\n", "{\n", "    __sock4_xlate_fwd (ctx, ctx, true);\n", "    return SYS_PROCEED;\n", "}\n"], "called_function_list": ["__sock4_xlate_fwd"], "call_depth": 5, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "sock4_recvmsg": [{"capabilities": [], "helperCallParams": {}, "startLine": 621, "endLine": 625, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "funcName": "sock4_recvmsg", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct bpf_sock_addr *ctx"], "output": "int", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["int sock4_recvmsg (struct bpf_sock_addr *ctx)\n", "{\n", "    __sock4_xlate_rev (ctx, ctx);\n", "    return SYS_PROCEED;\n", "}\n"], "called_function_list": ["__sock4_xlate_rev"], "call_depth": 5, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "sock4_getpeername": [{"capabilities": [], "helperCallParams": {}, "startLine": 628, "endLine": 632, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "funcName": "sock4_getpeername", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct bpf_sock_addr *ctx"], "output": "int", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["int sock4_getpeername (struct bpf_sock_addr *ctx)\n", "{\n", "    __sock4_xlate_rev (ctx, ctx);\n", "    return SYS_PROCEED;\n", "}\n"], "called_function_list": ["__sock4_xlate_rev"], "call_depth": 5, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "sock6_update_revnat": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}, {"capability": "map_update", "map_update": [{"Project": "cilium", "Return Type": "int", "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "map_update_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}", "{Type:  const void ,Var: *value}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_update"]}]}], "helperCallParams": {}, "startLine": 647, "endLine": 669, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "funcName": "sock6_update_revnat", "developer_inline_comments": [], "updateMaps": [" LB6_REVERSE_NAT_SK_MAP"], "readMaps": ["  LB6_REVERSE_NAT_SK_MAP"], "input": ["struct bpf_sock_addr *ctx", " const struct lb6_backend *backend", " const struct lb6_key *orig_key", " __u16 rev_nat_index"], "output": "static__always_inlineint", "helper": ["map_lookup_elem", "map_update_elem"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int sock6_update_revnat (struct bpf_sock_addr *ctx, const struct lb6_backend *backend, const struct lb6_key *orig_key, __u16 rev_nat_index)\n", "{\n", "    struct ipv6_revnat_entry val = {}, *tmp;\n", "    struct ipv6_revnat_tuple key = {}\n", "    ;\n", "    int ret = 0;\n", "    key.cookie = sock_local_cookie (ctx);\n", "    key.address = backend->address;\n", "    key.port = backend->port;\n", "    val.address = orig_key->address;\n", "    val.port = orig_key->dport;\n", "    val.rev_nat_index = rev_nat_index;\n", "    tmp = map_lookup_elem (& LB6_REVERSE_NAT_SK_MAP, & key);\n", "    if (!tmp || memcmp (tmp, &val, sizeof (val)))\n", "        ret = map_update_elem (&LB6_REVERSE_NAT_SK_MAP, &key, &val, 0);\n", "    return ret;\n", "}\n"], "called_function_list": ["memcmp", "sock_local_cookie"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 671, "endLine": 678, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "funcName": "sock6_update_revnat", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct bpf_sock_addr * ctx __maybe_unused", " struct lb6_backend * backend __maybe_unused", " struct lb6_key * orig_key __maybe_unused", " __u16 rev_nat_index __maybe_unused"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int sock6_update_revnat (struct bpf_sock_addr * ctx __maybe_unused, struct lb6_backend * backend __maybe_unused, struct lb6_key * orig_key __maybe_unused, __u16 rev_nat_index __maybe_unused)\n", "{\n", "    return 0;\n", "}\n"], "called_function_list": ["memcmp", "sock_local_cookie"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ctx_get_v6_address": [{"capabilities": [], "helperCallParams": {}, "startLine": 682, "endLine": 693, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "funcName": "ctx_get_v6_address", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct bpf_sock_addr *ctx", " union v6addr *addr"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void ctx_get_v6_address (const struct bpf_sock_addr *ctx, union v6addr *addr)\n", "{\n", "    addr->p1 = ctx->user_ip6[0];\n", "    barrier ();\n", "    addr->p2 = ctx->user_ip6[1];\n", "    barrier ();\n", "    addr->p3 = ctx->user_ip6[2];\n", "    barrier ();\n", "    addr->p4 = ctx->user_ip6[3];\n", "    barrier ();\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ctx_get_v6_src_address": [{"capabilities": [], "helperCallParams": {}, "startLine": 696, "endLine": 707, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "funcName": "ctx_get_v6_src_address", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct bpf_sock *ctx", " union v6addr *addr"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void ctx_get_v6_src_address (const struct bpf_sock *ctx, union v6addr *addr)\n", "{\n", "    addr->p1 = ctx->src_ip6[0];\n", "    barrier ();\n", "    addr->p2 = ctx->src_ip6[1];\n", "    barrier ();\n", "    addr->p3 = ctx->src_ip6[2];\n", "    barrier ();\n", "    addr->p4 = ctx->src_ip6[3];\n", "    barrier ();\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ctx_set_v6_address": [{"capabilities": [], "helperCallParams": {}, "startLine": 710, "endLine": 721, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "funcName": "ctx_set_v6_address", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct bpf_sock_addr *ctx", " const union v6addr *addr"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void ctx_set_v6_address (struct bpf_sock_addr *ctx, const union v6addr *addr)\n", "{\n", "    ctx->user_ip6[0] = addr->p1;\n", "    barrier ();\n", "    ctx->user_ip6[1] = addr->p2;\n", "    barrier ();\n", "    ctx->user_ip6[2] = addr->p3;\n", "    barrier ();\n", "    ctx->user_ip6[3] = addr->p4;\n", "    barrier ();\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "sock6_skip_xlate": [{"capabilities": [], "helperCallParams": {}, "startLine": 723, "endLine": 739, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "funcName": "sock6_skip_xlate", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct lb6_service *svc", " const union v6addr *address"], "output": "static__always_inline__maybe_unusedbool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused bool sock6_skip_xlate (struct lb6_service *svc, const union v6addr *address)\n", "{\n", "    if (lb6_to_lb4_service (svc))\n", "        return true;\n", "    if (lb6_svc_is_external_ip (svc) || (lb6_svc_is_hostport (svc) && !is_v6_loopback (address))) {\n", "        struct remote_endpoint_info *info;\n", "        info = ipcache_lookup6 (& IPCACHE_MAP, address, V6_CACHE_KEY_LEN);\n", "        if (info == NULL || info->sec_label != HOST_ID)\n", "            return true;\n", "    }\n", "    return false;\n", "}\n"], "called_function_list": ["lb6_to_lb4_service", "lb6_svc_is_hostport", "lb6_svc_is_external_ip", "ipcache_lookup6", "is_v6_loopback"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "sock6_wildcard_lookup": [{"capabilities": [], "helperCallParams": {}, "startLine": 742, "endLine": 772, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "funcName": "sock6_wildcard_lookup", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct lb6_key * key __maybe_unused", " const bool include_remote_hosts __maybe_unused", " const bool inv_match __maybe_unused", " const bool in_hostns __maybe_unused"], "output": "static__always_inline__maybe_unusedstructlb6_service", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused struct lb6_service *sock6_wildcard_lookup (struct lb6_key * key __maybe_unused, const bool include_remote_hosts __maybe_unused, const bool inv_match __maybe_unused, const bool in_hostns __maybe_unused)\n", "{\n", "    struct remote_endpoint_info *info;\n", "    __u16 service_port;\n", "    service_port = bpf_ntohs (key -> dport);\n", "    if ((service_port < NODEPORT_PORT_MIN || service_port > NODEPORT_PORT_MAX) ^ inv_match)\n", "        return NULL;\n", "    if (in_hostns && is_v6_loopback (&key->address))\n", "        goto wildcard_lookup;\n", "    info = ipcache_lookup6 (& IPCACHE_MAP, & key -> address, V6_CACHE_KEY_LEN);\n", "    if (info != NULL && (info->sec_label == HOST_ID || (include_remote_hosts && identity_is_remote_node (info->sec_label))))\n", "        goto wildcard_lookup;\n", "    return NULL;\n", "wildcard_lookup :\n", "    memset (&key->address, 0, sizeof (key->address));\n", "    return lb6_lookup_service (key, true);\n", "}\n"], "called_function_list": ["identity_is_remote_node", "lb6_lookup_service", "ipcache_lookup6", "memset", "is_v6_loopback"], "call_depth": 3, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "sock6_wildcard_lookup_full": [{"capabilities": [], "helperCallParams": {}, "startLine": 775, "endLine": 793, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "funcName": "sock6_wildcard_lookup_full", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct lb6_key * key __maybe_unused", " const bool in_hostns __maybe_unused"], "output": "static__always_inline__maybe_unusedstructlb6_service", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused struct lb6_service *sock6_wildcard_lookup_full (struct lb6_key * key __maybe_unused, const bool in_hostns __maybe_unused)\n", "{\n", "    struct lb6_service *svc = NULL;\n", "\n", "#ifdef ENABLE_NODEPORT\n", "    svc = sock6_wildcard_lookup (key, true, false, in_hostns);\n", "    if (svc && !lb6_svc_is_nodeport (svc))\n", "        svc = NULL;\n", "    if (!svc) {\n", "        svc = sock6_wildcard_lookup (key, false, true, in_hostns);\n", "        if (svc && !lb6_svc_is_hostport (svc))\n", "            svc = NULL;\n", "    }\n", "\n", "#endif /* ENABLE_NODEPORT */\n", "    return svc;\n", "}\n"], "called_function_list": ["sock6_wildcard_lookup", "lb6_svc_is_hostport", "lb6_svc_is_nodeport"], "call_depth": 4, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "sock6_xlate_v4_in_v6": [{"capabilities": [], "helperCallParams": {}, "startLine": 795, "endLine": 824, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "funcName": "sock6_xlate_v4_in_v6", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct bpf_sock_addr * ctx __maybe_unused", " const bool udp_only __maybe_unused"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int sock6_xlate_v4_in_v6 (struct bpf_sock_addr * ctx __maybe_unused, const bool udp_only __maybe_unused)\n", "{\n", "\n", "#ifdef ENABLE_IPV4\n", "    struct bpf_sock_addr fake_ctx;\n", "    union v6addr addr6;\n", "    int ret;\n", "    ctx_get_v6_address (ctx, &addr6);\n", "    if (!is_v4_in_v6 (&addr6))\n", "        return -ENXIO;\n", "    memset (&fake_ctx, 0, sizeof (fake_ctx));\n", "    fake_ctx.protocol = ctx->protocol;\n", "    fake_ctx.user_ip4 = addr6.p4;\n", "    fake_ctx.user_port = ctx_dst_port (ctx);\n", "    ret = __sock4_xlate_fwd (& fake_ctx, ctx, udp_only);\n", "    if (ret < 0)\n", "        return ret;\n", "    build_v4_in_v6 (&addr6, fake_ctx.user_ip4);\n", "    ctx_set_v6_address (ctx, &addr6);\n", "    ctx_set_port (ctx, (__u16) fake_ctx.user_port);\n", "    return 0;\n", "\n", "#endif /* ENABLE_IPV4 */\n", "    return -ENXIO;\n", "}\n"], "called_function_list": ["ctx_dst_port", "build_v4_in_v6", "__sock4_xlate_fwd", "is_v4_in_v6", "ctx_set_port", "ctx_get_v6_address", "ctx_set_v6_address", "memset"], "call_depth": 5, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "sock6_post_bind_v4_in_v6": [{"capabilities": [], "helperCallParams": {}, "startLine": 827, "endLine": 846, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "funcName": "sock6_post_bind_v4_in_v6", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct bpf_sock * ctx __maybe_unused"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int sock6_post_bind_v4_in_v6 (struct bpf_sock * ctx __maybe_unused)\n", "{\n", "\n", "#ifdef ENABLE_IPV4\n", "    struct bpf_sock fake_ctx;\n", "    union v6addr addr6;\n", "    ctx_get_v6_src_address (ctx, &addr6);\n", "    if (!is_v4_in_v6 (&addr6))\n", "        return 0;\n", "    memset (&fake_ctx, 0, sizeof (fake_ctx));\n", "    fake_ctx.protocol = ctx->protocol;\n", "    fake_ctx.src_ip4 = addr6.p4;\n", "    fake_ctx.src_port = ctx->src_port;\n", "    return __sock4_post_bind (&fake_ctx, ctx);\n", "\n", "#endif /* ENABLE_IPV4 */\n", "    return 0;\n", "}\n"], "called_function_list": ["is_v4_in_v6", "memset", "ctx_get_v6_src_address", "__sock4_post_bind"], "call_depth": 4, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__sock6_post_bind": [{"capabilities": [], "helperCallParams": {}, "startLine": 848, "endLine": 874, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "funcName": "__sock6_post_bind", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct bpf_sock *ctx"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int __sock6_post_bind (struct bpf_sock *ctx)\n", "{\n", "    struct lb6_service *svc;\n", "    struct lb6_key key = {\n", "        .dport = ctx_src_port (ctx),}\n", "    ;\n", "    if (!sock_proto_enabled (ctx->protocol) || !ctx_in_hostns (ctx, NULL))\n", "        return 0;\n", "    ctx_get_v6_src_address (ctx, &key.address);\n", "    svc = lb6_lookup_service (& key, true);\n", "    if (!svc) {\n", "        svc = sock6_wildcard_lookup (& key, false, false, true);\n", "        if (!svc)\n", "            return sock6_post_bind_v4_in_v6 (ctx);\n", "    }\n", "    if (svc && (lb6_svc_is_nodeport (svc) || lb6_svc_is_external_ip (svc) || lb6_svc_is_loadbalancer (svc)))\n", "        return -EADDRINUSE;\n", "    return 0;\n", "}\n"], "called_function_list": ["sock6_post_bind_v4_in_v6", "ctx_get_v6_src_address", "lb6_lookup_service", "ctx_src_port", "sock6_wildcard_lookup", "sock_proto_enabled", "lb6_svc_is_external_ip", "ctx_in_hostns", "lb6_svc_is_loadbalancer", "lb6_svc_is_nodeport"], "call_depth": 5, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "sock6_post_bind": [{"capabilities": [], "helperCallParams": {}, "startLine": 877, "endLine": 883, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "funcName": "sock6_post_bind", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct bpf_sock *ctx"], "output": "int", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["int sock6_post_bind (struct bpf_sock *ctx)\n", "{\n", "    if (__sock6_post_bind (ctx) < 0)\n", "        return SYS_REJECT;\n", "    return SYS_PROCEED;\n", "}\n"], "called_function_list": ["__sock6_post_bind"], "call_depth": 6, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "sock6_pre_bind_v4_in_v6": [{"capabilities": [], "helperCallParams": {}, "startLine": 887, "endLine": 911, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "funcName": "sock6_pre_bind_v4_in_v6", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct bpf_sock_addr * ctx __maybe_unused"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int sock6_pre_bind_v4_in_v6 (struct bpf_sock_addr * ctx __maybe_unused)\n", "{\n", "\n", "#ifdef ENABLE_IPV4\n", "    struct bpf_sock_addr fake_ctx;\n", "    union v6addr addr6;\n", "    int ret;\n", "    ctx_get_v6_address (ctx, &addr6);\n", "    memset (&fake_ctx, 0, sizeof (fake_ctx));\n", "    fake_ctx.protocol = ctx->protocol;\n", "    fake_ctx.user_ip4 = addr6.p4;\n", "    fake_ctx.user_port = ctx_dst_port (ctx);\n", "    ret = __sock4_pre_bind (& fake_ctx, ctx);\n", "    if (ret < 0)\n", "        return ret;\n", "    build_v4_in_v6 (&addr6, fake_ctx.user_ip4);\n", "    ctx_set_v6_address (ctx, &addr6);\n", "    ctx_set_port (ctx, (__u16) fake_ctx.user_port);\n", "\n", "#endif /* ENABLE_IPV4 */\n", "    return 0;\n", "}\n"], "called_function_list": ["__sock4_pre_bind", "ctx_dst_port", "build_v4_in_v6", "ctx_set_port", "ctx_get_v6_address", "ctx_set_v6_address", "memset"], "call_depth": 4, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "sock6_auto_bind": [{"capabilities": [], "helperCallParams": {}, "startLine": 914, "endLine": 920, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "funcName": "sock6_auto_bind", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct bpf_sock_addr *ctx"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void sock6_auto_bind (struct bpf_sock_addr *ctx)\n", "{\n", "    union v6addr zero = {}\n", "    ;\n", "    ctx_set_v6_address (ctx, &zero);\n", "    ctx_set_port (ctx, 0);\n", "}\n"], "called_function_list": ["ctx_set_v6_address", "ctx_set_port"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__sock6_pre_bind": [{"capabilities": [{"capability": "map_update", "map_update": [{"Project": "cilium", "Return Type": "int", "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "map_update_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}", "{Type:  const void ,Var: *value}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_update"]}]}, {"capability": "read_sys_info", "read_sys_info": [{"Project": "cilium", "Return Type": "u64", "Description": "Equivalent to get_socket_cookie() helper that accepts skb , but gets socket from struct sock_ops context. ", "Return": " A 8-byte long non-decreasing number.", "Function Name": "get_socket_cookie", "Input Params": ["{Type: struct sock_ops ,Var: *ctx}"], "compatible_hookpoints": ["socket_filter", "sched_cls", "sched_act", "cgroup_skb", "sock_ops", "sk_skb", "cgroup_sock_addr"], "capabilities": ["read_sys_info"]}]}], "helperCallParams": {}, "startLine": 923, "endLine": 944, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "funcName": "__sock6_pre_bind", "developer_inline_comments": [], "updateMaps": ["  LB6_HEALTH_MAP"], "readMaps": [], "input": ["struct bpf_sock_addr *ctx"], "output": "static__always_inlineint", "helper": ["map_update_elem", "get_socket_cookie"], "compatibleHookpoints": ["cgroup_skb", "sched_cls", "cgroup_sock_addr", "sock_ops", "sched_act", "sk_skb", "socket_filter"], "source": ["static __always_inline int __sock6_pre_bind (struct bpf_sock_addr *ctx)\n", "{\n", "    __sock_cookie key __maybe_unused;\n", "    struct lb6_health val = {\n", "        .peer = {\n", "            .port = ctx_dst_port (ctx),\n", "            .proto = (__u8) ctx->protocol,},}\n", "    ;\n", "    int ret = 0;\n", "    ctx_get_v6_address (ctx, &val.peer.address);\n", "    if (is_v4_in_v6 (&val.peer.address))\n", "        return sock6_pre_bind_v4_in_v6 (ctx);\n", "\n", "#ifdef ENABLE_IPV6\n", "    key = get_socket_cookie (ctx);\n", "    ret = map_update_elem (& LB6_HEALTH_MAP, & key, & val, 0);\n", "    if (!ret)\n", "        sock6_auto_bind (ctx);\n", "\n", "#endif\n", "    return ret;\n", "}\n"], "called_function_list": ["ctx_dst_port", "is_v4_in_v6", "sock6_auto_bind", "ctx_get_v6_address", "sock6_pre_bind_v4_in_v6"], "call_depth": 5, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "sock6_pre_bind": [{"capabilities": [], "helperCallParams": {}, "startLine": 947, "endLine": 958, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "funcName": "sock6_pre_bind", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct bpf_sock_addr *ctx"], "output": "int", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["int sock6_pre_bind (struct bpf_sock_addr *ctx)\n", "{\n", "    int ret = SYS_PROCEED;\n", "    if (!sock_proto_enabled (ctx->protocol) || !ctx_in_hostns (ctx, NULL))\n", "        return ret;\n", "    if (sock_is_health_check (ctx) && __sock6_pre_bind (ctx))\n", "        ret = SYS_REJECT;\n", "    return ret;\n", "}\n"], "called_function_list": ["__sock6_pre_bind", "sock_proto_enabled", "ctx_in_hostns", "sock_is_health_check"], "call_depth": 6, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__sock6_xlate_fwd": [{"capabilities": [], "helperCallParams": {}, "startLine": 961, "endLine": 1062, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "funcName": "__sock6_xlate_fwd", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct bpf_sock_addr *ctx", " const bool udp_only"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int __sock6_xlate_fwd (struct bpf_sock_addr *ctx, const bool udp_only)\n", "{\n", "\n", "#ifdef ENABLE_IPV6\n", "    union lb6_affinity_client_id id;\n", "    const bool in_hostns = ctx_in_hostns (ctx, & id.client_cookie);\n", "    struct lb6_backend *backend;\n", "    struct lb6_service *svc;\n", "    struct lb6_key key = {\n", "        .dport = ctx_dst_port (ctx),}, orig_key;\n", "    struct lb6_service *backend_slot;\n", "    bool backend_from_affinity = false;\n", "    __u32 backend_id = 0;\n", "\n", "#ifdef ENABLE_L7_LB\n", "    struct lb6_backend l7backend;\n", "\n", "#endif\n", "    if (is_defined (ENABLE_SOCKET_LB_HOST_ONLY) && !in_hostns)\n", "        return -ENXIO;\n", "    if (!udp_only && !sock_proto_enabled (ctx->protocol))\n", "        return -ENOTSUP;\n", "    ctx_get_v6_address (ctx, &key.address);\n", "    memcpy (&orig_key, &key, sizeof (key));\n", "    svc = lb6_lookup_service (& key, true);\n", "    if (!svc)\n", "        svc = sock6_wildcard_lookup_full (&key, in_hostns);\n", "    if (!svc)\n", "        return sock6_xlate_v4_in_v6 (ctx, udp_only);\n", "    if (sock6_skip_xlate (svc, &orig_key.address))\n", "        return -EPERM;\n", "\n", "#ifdef ENABLE_L7_LB\n", "    if (lb6_svc_is_l7loadbalancer (svc)) {\n", "        if (is_defined (BPF_HAVE_NETNS_COOKIE) && in_hostns) {\n", "            union v6addr loopback = {\n", "                .addr [15] = 1,}\n", "            ;\n", "            l7backend.address = loopback;\n", "            l7backend.port = (__be16) svc->l7_lb_proxy_port;\n", "            l7backend.proto = 0;\n", "            l7backend.flags = 0;\n", "            backend = &l7backend;\n", "            goto out;\n", "        }\n", "        return 0;\n", "    }\n", "\n", "#endif /* ENABLE_L7_LB */\n", "    if (lb6_svc_is_affinity (svc)) {\n", "        backend_id = lb6_affinity_backend_id_by_netns (svc, & id);\n", "        backend_from_affinity = true;\n", "        if (backend_id != 0) {\n", "            backend = __lb6_lookup_backend (backend_id);\n", "            if (!backend)\n", "                backend_id = 0;\n", "        }\n", "    }\n", "    if (backend_id == 0) {\n", "        backend_from_affinity = false;\n", "        key.backend_slot = (sock_select_slot (ctx) % svc->count) + 1;\n", "        backend_slot = __lb6_lookup_backend_slot (& key);\n", "        if (!backend_slot) {\n", "            update_metrics (0, METRIC_EGRESS, REASON_LB_NO_BACKEND_SLOT);\n", "            return -ENOENT;\n", "        }\n", "        backend_id = backend_slot->backend_id;\n", "        backend = __lb6_lookup_backend (backend_id);\n", "    }\n", "    if (!backend) {\n", "        update_metrics (0, METRIC_EGRESS, REASON_LB_NO_BACKEND);\n", "        return -ENOENT;\n", "    }\n", "    if (lb6_svc_is_affinity (svc) && !backend_from_affinity)\n", "        lb6_update_affinity_by_netns (svc, &id, backend_id);\n", "\n", "#ifdef ENABLE_L7_LB\n", "out :\n", "\n", "#endif\n", "    if (sock6_update_revnat (ctx, backend, &orig_key, svc->rev_nat_index) < 0) {\n", "        update_metrics (0, METRIC_EGRESS, REASON_LB_REVNAT_UPDATE);\n", "        return -ENOMEM;\n", "    }\n", "    ctx_set_v6_address (ctx, &backend->address);\n", "    ctx_set_port (ctx, backend->port);\n", "    return 0;\n", "\n", "#else\n", "    return sock6_xlate_v4_in_v6 (ctx, udp_only);\n", "\n", "#endif /* ENABLE_IPV6 */\n", "}\n"], "called_function_list": ["sock6_update_revnat", "sock6_skip_xlate", "lb6_lookup_service", "update_metrics", "lb6_update_affinity_by_netns", "sock6_wildcard_lookup_full", "sock6_xlate_v4_in_v6", "ctx_set_port", "lb6_svc_is_l7loadbalancer", "lb6_affinity_backend_id_by_netns", "__lb6_lookup_backend_slot", "__lb6_lookup_backend", "memcpy", "ctx_dst_port", "sock_proto_enabled", "sock_select_slot", "ctx_get_v6_address", "ctx_in_hostns", "lb6_svc_is_affinity", "ctx_set_v6_address"], "call_depth": 3, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__sock6_health_fwd": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}, {"capability": "read_sys_info", "read_sys_info": [{"Project": "cilium", "Return Type": "u64", "Description": "Equivalent to get_socket_cookie() helper that accepts skb , but gets socket from struct sock_ops context. ", "Return": " A 8-byte long non-decreasing number.", "Function Name": "get_socket_cookie", "Input Params": ["{Type: struct sock_ops ,Var: *ctx}"], "compatible_hookpoints": ["socket_filter", "sched_cls", "sched_act", "cgroup_skb", "sock_ops", "sk_skb", "cgroup_sock_addr"], "capabilities": ["read_sys_info"]}]}], "helperCallParams": {}, "startLine": 1064, "endLine": 1089, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "funcName": "__sock6_health_fwd", "developer_inline_comments": [], "updateMaps": [], "readMaps": [" LB6_HEALTH_MAP"], "input": ["struct bpf_sock_addr * ctx __maybe_unused"], "output": "static__always_inlineint", "helper": ["map_lookup_elem", "get_socket_cookie"], "compatibleHookpoints": ["cgroup_skb", "sched_cls", "cgroup_sock_addr", "sock_ops", "sched_act", "sk_skb", "socket_filter"], "source": ["static __always_inline int __sock6_health_fwd (struct bpf_sock_addr * ctx __maybe_unused)\n", "{\n", "    int ret = lb_skip_l4_dnat () ? SYS_PROCEED : SYS_REJECT;\n", "\n", "#ifdef ENABLE_HEALTH_CHECK\n", "    union v6addr addr6;\n", "    ctx_get_v6_address (ctx, &addr6);\n", "    if (is_v4_in_v6 (&addr6)) {\n", "        return __sock4_health_fwd (ctx);\n", "    }\n", "    else {\n", "\n", "#ifdef ENABLE_IPV6\n", "        __sock_cookie key = get_socket_cookie (ctx);\n", "        struct lb6_health *val = NULL;\n", "        if (!lb_skip_l4_dnat ())\n", "            val = map_lookup_elem (&LB6_HEALTH_MAP, &key);\n", "        if (val) {\n", "            ctx_set_port (ctx, val->peer.port);\n", "            ret = SYS_PROCEED;\n", "        }\n", "\n", "#endif /* ENABLE_IPV6 */\n", "    }\n", "\n", "#endif /* ENABLE_HEALTH_CHECK */\n", "    return ret;\n", "}\n"], "called_function_list": ["lb_skip_l4_dnat", "__sock4_health_fwd", "is_v4_in_v6", "ctx_set_port", "ctx_get_v6_address"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "sock6_connect": [{"capabilities": [], "helperCallParams": {}, "startLine": 1092, "endLine": 1099, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "funcName": "sock6_connect", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct bpf_sock_addr *ctx"], "output": "int", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["int sock6_connect (struct bpf_sock_addr *ctx)\n", "{\n", "    if (sock_is_health_check (ctx))\n", "        return __sock6_health_fwd (ctx);\n", "    __sock6_xlate_fwd (ctx, false);\n", "    return SYS_PROCEED;\n", "}\n"], "called_function_list": ["__sock6_xlate_fwd", "__sock6_health_fwd", "sock_is_health_check"], "call_depth": 4, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "sock6_xlate_rev_v4_in_v6": [{"capabilities": [], "helperCallParams": {}, "startLine": 1102, "endLine": 1130, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "funcName": "sock6_xlate_rev_v4_in_v6", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct bpf_sock_addr * ctx __maybe_unused"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int sock6_xlate_rev_v4_in_v6 (struct bpf_sock_addr * ctx __maybe_unused)\n", "{\n", "\n", "#ifdef ENABLE_IPV4\n", "    struct bpf_sock_addr fake_ctx;\n", "    union v6addr addr6;\n", "    int ret;\n", "    ctx_get_v6_address (ctx, &addr6);\n", "    if (!is_v4_in_v6 (&addr6))\n", "        return -ENXIO;\n", "    memset (&fake_ctx, 0, sizeof (fake_ctx));\n", "    fake_ctx.protocol = ctx->protocol;\n", "    fake_ctx.user_ip4 = addr6.p4;\n", "    fake_ctx.user_port = ctx_dst_port (ctx);\n", "    ret = __sock4_xlate_rev (& fake_ctx, ctx);\n", "    if (ret < 0)\n", "        return ret;\n", "    build_v4_in_v6 (&addr6, fake_ctx.user_ip4);\n", "    ctx_set_v6_address (ctx, &addr6);\n", "    ctx_set_port (ctx, (__u16) fake_ctx.user_port);\n", "    return 0;\n", "\n", "#endif /* ENABLE_IPV4 */\n", "    return -ENXIO;\n", "}\n"], "called_function_list": ["ctx_dst_port", "build_v4_in_v6", "is_v4_in_v6", "ctx_set_port", "ctx_get_v6_address", "__sock4_xlate_rev", "ctx_set_v6_address", "memset"], "call_depth": 5, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__sock6_xlate_rev": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 1132, "endLine": 1167, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "funcName": "__sock6_xlate_rev", "developer_inline_comments": [], "updateMaps": [" LB6_REVERSE_NAT_SK_MAP"], "readMaps": ["  LB6_REVERSE_NAT_SK_MAP"], "input": ["struct bpf_sock_addr *ctx"], "output": "static__always_inlineint", "helper": ["map_delete_elem", "map_lookup_elem"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int __sock6_xlate_rev (struct bpf_sock_addr *ctx)\n", "{\n", "\n", "#ifdef ENABLE_IPV6\n", "    struct ipv6_revnat_tuple key = {}\n", "    ;\n", "    struct ipv6_revnat_entry *val;\n", "    key.cookie = sock_local_cookie (ctx);\n", "    key.port = ctx_dst_port (ctx);\n", "    ctx_get_v6_address (ctx, &key.address);\n", "    val = map_lookup_elem (& LB6_REVERSE_NAT_SK_MAP, & key);\n", "    if (val) {\n", "        struct lb6_service *svc;\n", "        struct lb6_key svc_key = {\n", "            .address = val->address,\n", "            .dport = val->port,}\n", "        ;\n", "        svc = lb6_lookup_service (& svc_key, true);\n", "        if (!svc)\n", "            svc = sock6_wildcard_lookup_full (&svc_key, ctx_in_hostns (ctx, NULL));\n", "        if (!svc || svc->rev_nat_index != val->rev_nat_index) {\n", "            map_delete_elem (&LB6_REVERSE_NAT_SK_MAP, &key);\n", "            update_metrics (0, METRIC_INGRESS, REASON_LB_REVNAT_STALE);\n", "            return -ENOENT;\n", "        }\n", "        ctx_set_v6_address (ctx, &val->address);\n", "        ctx_set_port (ctx, val->port);\n", "        return 0;\n", "    }\n", "\n", "#endif /* ENABLE_IPV6 */\n", "    return sock6_xlate_rev_v4_in_v6 (ctx);\n", "}\n"], "called_function_list": ["lb6_lookup_service", "ctx_dst_port", "update_metrics", "sock6_xlate_rev_v4_in_v6", "sock6_wildcard_lookup_full", "ctx_set_port", "ctx_get_v6_address", "ctx_in_hostns", "ctx_set_v6_address", "sock_local_cookie"], "call_depth": 6, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "sock6_sendmsg": [{"capabilities": [], "helperCallParams": {}, "startLine": 1170, "endLine": 1174, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "funcName": "sock6_sendmsg", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct bpf_sock_addr *ctx"], "output": "int", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["int sock6_sendmsg (struct bpf_sock_addr *ctx)\n", "{\n", "    __sock6_xlate_fwd (ctx, true);\n", "    return SYS_PROCEED;\n", "}\n"], "called_function_list": ["__sock6_xlate_fwd"], "call_depth": 4, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "sock6_recvmsg": [{"capabilities": [], "helperCallParams": {}, "startLine": 1177, "endLine": 1181, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "funcName": "sock6_recvmsg", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct bpf_sock_addr *ctx"], "output": "int", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["int sock6_recvmsg (struct bpf_sock_addr *ctx)\n", "{\n", "    __sock6_xlate_rev (ctx);\n", "    return SYS_PROCEED;\n", "}\n"], "called_function_list": ["__sock6_xlate_rev"], "call_depth": 7, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "sock6_getpeername": [{"capabilities": [], "helperCallParams": {}, "startLine": 1184, "endLine": 1188, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "funcName": "sock6_getpeername", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct bpf_sock_addr *ctx"], "output": "int", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["int sock6_getpeername (struct bpf_sock_addr *ctx)\n", "{\n", "    __sock6_xlate_rev (ctx);\n", "    return SYS_PROCEED;\n", "}\n"], "called_function_list": ["__sock6_xlate_rev"], "call_depth": 7, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "allow_vlan": [{"capabilities": [], "helperCallParams": {}, "startLine": 62, "endLine": 64, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c", "funcName": "allow_vlan", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["__u32 __maybe_unused ifindex", " __u32 __maybe_unused vlan_id"], "output": "static__always_inlinebool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline bool allow_vlan (__u32 __maybe_unused ifindex, __u32 __maybe_unused vlan_id)\n", "{\n", "    VLAN_FILTER (ifindex, vlan_id);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "rewrite_dmac_to_host": [{"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 67, "endLine": 82, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c", "funcName": "rewrite_dmac_to_host", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " __u32 src_identity"], "output": "static__always_inlineint", "helper": ["CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["static __always_inline int rewrite_dmac_to_host (struct  __ctx_buff *ctx, __u32 src_identity)\n", "{\n", "    union macaddr cilium_net_mac = CILIUM_NET_MAC;\n", "    if (eth_store_daddr (ctx, (__u8 *) &cilium_net_mac.addr, 0) < 0)\n", "        return send_drop_notify_error (ctx, src_identity, DROP_WRITE_ERROR, CTX_ACT_OK, METRIC_INGRESS);\n", "    return CTX_ACT_OK;\n", "}\n"], "called_function_list": ["eth_store_daddr"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "identity_from_ipcache_ok": [{"capabilities": [], "helperCallParams": {}, "startLine": 89, "endLine": 92, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c", "funcName": "identity_from_ipcache_ok", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["void"], "output": "static__always_inlinebool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline bool identity_from_ipcache_ok (void)\n", "{\n", "    return SECCTX_FROM_IPCACHE == SECCTX_FROM_IPCACHE_OK;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "derive_src_id": [{"capabilities": [], "helperCallParams": {}, "startLine": 96, "endLine": 112, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c", "funcName": "derive_src_id", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const union v6addr *node_ip", " struct ipv6hdr *ip6", " __u32 *identity"], "output": "static__always_inline__u32", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __u32 derive_src_id (const union v6addr *node_ip, struct ipv6hdr *ip6, __u32 *identity)\n", "{\n", "    if (ipv6_match_prefix_64 ((union v6addr *) &ip6->saddr, node_ip)) {\n", "        __u32 *tmp = (__u32 *) ip6;\n", "        *identity = bpf_ntohl (*tmp & IPV6_FLOWLABEL_MASK);\n", "        if (*identity == HOST_ID)\n", "            return DROP_INVALID_IDENTITY;\n", "    }\n", "    return 0;\n", "}\n"], "called_function_list": ["ipv6_match_prefix_64"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ipcache_lookup_srcid6": [{"capabilities": [], "helperCallParams": {}, "startLine": 115, "endLine": 133, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c", "funcName": "ipcache_lookup_srcid6", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx"], "output": "static__always_inline__u32", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __u32 ipcache_lookup_srcid6 (struct  __ctx_buff *ctx)\n", "{\n", "    struct remote_endpoint_info *info = NULL;\n", "    void *data, *data_end;\n", "    struct ipv6hdr *ip6;\n", "    __u32 srcid = 0;\n", "    if (!revalidate_data (ctx, &data, &data_end, &ip6))\n", "        return DROP_INVALID;\n", "    info = lookup_ip6_remote_endpoint ((union v6addr *) & ip6 -> saddr);\n", "    if (info != NULL)\n", "        srcid = info->sec_label;\n", "    cilium_dbg (ctx, info ? DBG_IP_ID_MAP_SUCCEED6 : DBG_IP_ID_MAP_FAILED6, ip6->saddr.s6_addr32[3], srcid);\n", "    return srcid;\n", "}\n"], "called_function_list": ["cilium_dbg"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "resolve_srcid_ipv6": [{"capabilities": [], "helperCallParams": {}, "startLine": 136, "endLine": 176, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c", "funcName": "resolve_srcid_ipv6", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " __u32 srcid_from_proxy", " const bool from_host"], "output": "static__always_inline__u32", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __u32 resolve_srcid_ipv6 (struct  __ctx_buff *ctx, __u32 srcid_from_proxy, const bool from_host)\n", "{\n", "    __u32 src_id = WORLD_ID, srcid_from_ipcache = srcid_from_proxy;\n", "    struct remote_endpoint_info *info = NULL;\n", "    void *data, *data_end;\n", "    struct ipv6hdr *ip6;\n", "    union v6addr *src;\n", "    int ret;\n", "    if (!revalidate_data_maybe_pull (ctx, &data, &data_end, &ip6, !from_host))\n", "        return DROP_INVALID;\n", "    if (!from_host) {\n", "        union v6addr node_ip = {}\n", "        ;\n", "        BPF_V6 (node_ip, ROUTER_IP);\n", "        ret = derive_src_id (& node_ip, ip6, & src_id);\n", "        if (IS_ERR (ret))\n", "            return ret;\n", "    }\n", "    if (identity_is_reserved (srcid_from_ipcache)) {\n", "        src = (union v6addr *) &ip6->saddr;\n", "        info = lookup_ip6_remote_endpoint (src);\n", "        if (info != NULL && info->sec_label)\n", "            srcid_from_ipcache = info->sec_label;\n", "        cilium_dbg (ctx, info ? DBG_IP_ID_MAP_SUCCEED6 : DBG_IP_ID_MAP_FAILED6, ((__u32 *) src)[3], srcid_from_ipcache);\n", "    }\n", "    if (from_host)\n", "        src_id = srcid_from_ipcache;\n", "    else if (src_id == WORLD_ID && identity_from_ipcache_ok () && !identity_is_reserved (srcid_from_ipcache))\n", "        src_id = srcid_from_ipcache;\n", "    return src_id;\n", "}\n"], "called_function_list": ["identity_is_reserved", "derive_src_id", "identity_from_ipcache_ok", "cilium_dbg"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "tail_handle_ipv6_from_host": [{"capabilities": [], "helperCallParams": {}, "startLine": 369, "endLine": 372, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c", "funcName": "tail_handle_ipv6_from_host", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff * ctx __maybe_unused"], "output": "int", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["int tail_handle_ipv6_from_host (struct  __ctx_buff * ctx __maybe_unused)\n", "{\n", "    return tail_handle_ipv6 (ctx, true);\n", "}\n"], "called_function_list": ["tail_handle_ipv6"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "tail_handle_ipv6_from_netdev": [{"capabilities": [], "helperCallParams": {}, "startLine": 375, "endLine": 378, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c", "funcName": "tail_handle_ipv6_from_netdev", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx"], "output": "int", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["int tail_handle_ipv6_from_netdev (struct  __ctx_buff *ctx)\n", "{\n", "    return tail_handle_ipv6 (ctx, false);\n", "}\n"], "called_function_list": ["tail_handle_ipv6"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "handle_to_netdev_ipv6": [{"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 381, "endLine": 409, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c", "funcName": "handle_to_netdev_ipv6", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " struct trace_ctx *trace"], "output": "static__always_inlineint", "helper": ["CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["static __always_inline int handle_to_netdev_ipv6 (struct  __ctx_buff *ctx, struct trace_ctx *trace)\n", "{\n", "    void *data, *data_end;\n", "    struct ipv6hdr *ip6;\n", "    int hdrlen, ret;\n", "    __u32 src_id = 0;\n", "    __u8 nexthdr;\n", "    if (!revalidate_data_pull (ctx, &data, &data_end, &ip6))\n", "        return DROP_INVALID;\n", "    nexthdr = ip6->nexthdr;\n", "    hdrlen = ipv6_hdrlen (ctx, & nexthdr);\n", "    if (hdrlen < 0)\n", "        return hdrlen;\n", "    if (likely (nexthdr == IPPROTO_ICMPV6)) {\n", "        ret = icmp6_host_handle (ctx);\n", "        if (ret == SKIP_HOST_FIREWALL)\n", "            return CTX_ACT_OK;\n", "        if (IS_ERR (ret))\n", "            return ret;\n", "    }\n", "    src_id = ipcache_lookup_srcid6 (ctx);\n", "    return ipv6_host_policy_egress (ctx, src_id, trace);\n", "}\n"], "called_function_list": ["icmp6_host_handle", "ipv6_hdrlen", "ipcache_lookup_srcid6", "ipv6_host_policy_egress"], "call_depth": 4, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "resolve_srcid_ipv4": [{"capabilities": [], "helperCallParams": {}, "startLine": 414, "endLine": 469, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c", "funcName": "resolve_srcid_ipv4", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " __u32 srcid_from_proxy", " __u32 *sec_label", " const bool from_host"], "output": "static__always_inline__u32", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __u32 resolve_srcid_ipv4 (struct  __ctx_buff *ctx, __u32 srcid_from_proxy, __u32 *sec_label, const bool from_host)\n", "{\n", "    __u32 src_id = WORLD_ID, srcid_from_ipcache = srcid_from_proxy;\n", "    struct remote_endpoint_info *info = NULL;\n", "    void *data, *data_end;\n", "    struct iphdr *ip4;\n", "    if (!revalidate_data_maybe_pull (ctx, &data, &data_end, &ip4, !from_host))\n", "        return DROP_INVALID;\n", "    if (identity_is_reserved (srcid_from_ipcache)) {\n", "        info = lookup_ip4_remote_endpoint (ip4 -> saddr);\n", "        if (info != NULL) {\n", "            *sec_label = info->sec_label;\n", "            if (*sec_label) {\n", "\n", "#ifndef ENABLE_EXTRA_HOST_DEV\n", "                if (*sec_label != HOST_ID)\n", "                    srcid_from_ipcache = *sec_label;\n", "\n", "#else\n", "                if ((*sec_label != HOST_ID && !from_host) || from_host)\n", "                    srcid_from_ipcache = *sec_label;\n", "\n", "#endif /* ENABLE_EXTRA_HOST_DEV */\n", "            }\n", "        }\n", "        cilium_dbg (ctx, info ? DBG_IP_ID_MAP_SUCCEED4 : DBG_IP_ID_MAP_FAILED4, ip4->saddr, srcid_from_ipcache);\n", "    }\n", "    if (from_host)\n", "        src_id = srcid_from_ipcache;\n", "    else if (identity_from_ipcache_ok () && !identity_is_reserved (srcid_from_ipcache))\n", "        src_id = srcid_from_ipcache;\n", "    return src_id;\n", "}\n"], "called_function_list": ["identity_is_reserved", "identity_from_ipcache_ok", "cilium_dbg"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "tail_handle_ipv4_from_host": [{"capabilities": [], "helperCallParams": {}, "startLine": 689, "endLine": 699, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c", "funcName": "tail_handle_ipv4_from_host", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx"], "output": "int", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["int tail_handle_ipv4_from_host (struct  __ctx_buff *ctx)\n", "{\n", "    __u32 ipcache_srcid = 0;\n", "\n", "#if defined(ENABLE_HOST_FIREWALL) && !defined(ENABLE_MASQUERADE)\n", "    ipcache_srcid = ctx_load_meta (ctx, CB_IPCACHE_SRC_LABEL);\n", "    ctx_store_meta (ctx, CB_IPCACHE_SRC_LABEL, 0);\n", "\n", "#endif\n", "    return tail_handle_ipv4 (ctx, ipcache_srcid, true);\n", "}\n"], "called_function_list": ["ctx_store_meta", "ctx_load_meta", "tail_handle_ipv4"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "tail_handle_ipv4_from_netdev": [{"capabilities": [], "helperCallParams": {}, "startLine": 702, "endLine": 705, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c", "funcName": "tail_handle_ipv4_from_netdev", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx"], "output": "int", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["int tail_handle_ipv4_from_netdev (struct  __ctx_buff *ctx)\n", "{\n", "    return tail_handle_ipv4 (ctx, 0, false);\n", "}\n"], "called_function_list": ["tail_handle_ipv4"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "handle_to_netdev_ipv4": [{"capabilities": [], "helperCallParams": {}, "startLine": 708, "endLine": 727, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c", "funcName": "handle_to_netdev_ipv4", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " struct trace_ctx *trace"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int handle_to_netdev_ipv4 (struct  __ctx_buff *ctx, struct trace_ctx *trace)\n", "{\n", "    void *data, *data_end;\n", "    struct iphdr *ip4;\n", "    __u32 src_id = 0, ipcache_srcid = 0;\n", "    if ((ctx->mark & MARK_MAGIC_HOST_MASK) == MARK_MAGIC_HOST)\n", "        src_id = HOST_ID;\n", "    src_id = resolve_srcid_ipv4 (ctx, src_id, & ipcache_srcid, true);\n", "    if (!revalidate_data (ctx, &data, &data_end, &ip4))\n", "        return DROP_INVALID;\n", "    return ipv4_host_policy_egress (ctx, src_id, ipcache_srcid, trace);\n", "}\n"], "called_function_list": ["ipv4_host_policy_egress", "resolve_srcid_ipv4"], "call_depth": 4, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "do_netdev_encrypt_pools": [{"capabilities": [{"capability": "read_skb", "read_skb": [{"Project": "cilium", "Return Type": "s64", "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ", "Return": " The checksum result, or a negative error code in case of failure.", "Function Name": "csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp", "lwt_in", "lwt_out", "lwt_xmit", "lwt_seg6local"], "capabilities": ["read_skb"]}]}], "helperCallParams": {}, "startLine": 733, "endLine": 788, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c", "funcName": "do_netdev_encrypt_pools", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff * ctx __maybe_unused"], "output": "static__always_inlineint", "helper": ["csum_diff"], "compatibleHookpoints": ["sched_cls", "lwt_xmit", "xdp", "lwt_in", "sched_act", "lwt_out", "lwt_seg6local"], "source": ["static __always_inline int do_netdev_encrypt_pools (struct  __ctx_buff * ctx __maybe_unused)\n", "{\n", "    int ret = 0;\n", "\n", "#ifdef IP_POOLS\n", "    __u32 tunnel_endpoint = 0;\n", "    void *data, *data_end;\n", "    __u32 tunnel_source = IPV4_ENCRYPT_IFACE;\n", "    struct iphdr *iphdr;\n", "    __be32 sum;\n", "    tunnel_endpoint = ctx_load_meta (ctx, CB_ENCRYPT_DST);\n", "    ctx->mark = 0;\n", "    if (!revalidate_data (ctx, &data, &data_end, &iphdr)) {\n", "        ret = DROP_INVALID;\n", "        goto drop_err;\n", "    }\n", "    sum = csum_diff (& iphdr -> daddr, 4, & tunnel_endpoint, 4, 0);\n", "    if (ctx_store_bytes (ctx, ETH_HLEN + offsetof (struct iphdr, daddr), &tunnel_endpoint, 4, 0) < 0) {\n", "        ret = DROP_WRITE_ERROR;\n", "        goto drop_err;\n", "    }\n", "    if (l3_csum_replace (ctx, ETH_HLEN + offsetof (struct iphdr, check), 0, sum, 0) < 0) {\n", "        ret = DROP_CSUM_L3;\n", "        goto drop_err;\n", "    }\n", "    if (!revalidate_data (ctx, &data, &data_end, &iphdr)) {\n", "        ret = DROP_INVALID;\n", "        goto drop_err;\n", "    }\n", "    sum = csum_diff (& iphdr -> saddr, 4, & tunnel_source, 4, 0);\n", "    if (ctx_store_bytes (ctx, ETH_HLEN + offsetof (struct iphdr, saddr), &tunnel_source, 4, 0) < 0) {\n", "        ret = DROP_WRITE_ERROR;\n", "        goto drop_err;\n", "    }\n", "    if (l3_csum_replace (ctx, ETH_HLEN + offsetof (struct iphdr, check), 0, sum, 0) < 0) {\n", "        ret = DROP_CSUM_L3;\n", "        goto drop_err;\n", "    }\n", "drop_err :\n", "\n", "#endif /* IP_POOLS */\n", "    return ret;\n", "}\n"], "called_function_list": ["ctx_load_meta"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "do_netdev_encrypt_fib": [{"capabilities": [{"capability": "read_sys_info", "read_sys_info": [{"Project": "libbpf", "Return Type": "int", "Description": "Do FIB lookup in kernel tables using parameters in params. If lookup is successful and result shows packet is to be forwarded , the neighbor tables are searched for the nexthop. If successful (ie. , FIB lookup shows forwarding and nexthop is resolved) , the nexthop address is returned in ipv4_dst or ipv6_dst based on family , smac is set to mac address of egress device , dmac is set to nexthop mac address , rt_metric is set to metric from route (IPv4/IPv6 only) , and ifindex is set to the device index of the nexthop from the FIB lookup. <[ plen ]>(IP: 2) argument is the size of the passed in struct. <[ flags ]>(IP: 3) argument can be a combination of one or more of the following values: BPF_FIB_LOOKUP_DIRECT Do a direct table lookup vs full lookup using FIB rules. BPF_FIB_LOOKUP_OUTPUT Perform lookup from an egress perspective (default is ingress). <[ ctx ]>(IP: 0) is either struct xdp_md for XDP programs or struct sk_buff tc cls_act programs. Return \u00b7 < 0 if any input argument is invalid \u00b7 0 on success (packet is forwarded , nexthop neighbor exists) \u00b7 > 0 one of BPF_FIB_LKUP_RET_ codes explaining why the packet is not forwarded or needs assist from full stack ", "Function Name": "bpf_fib_lookup", "Input Params": ["{Type: void ,Var: *ctx}", "{Type:  struct bpf_fib_lookup ,Var: *params}", "{Type:  int ,Var: plen}", "{Type:  u32 ,Var: flags}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp"], "capabilities": ["read_sys_info"]}, {"Project": "cilium", "Return Type": "int", "Description": "Do FIB lookup in kernel tables using parameters in params. If lookup is successful and result shows packet is to be forwarded , the neighbor tables are searched for the nexthop. If successful (ie. , FIB lookup shows forwarding and nexthop is resolved) , the nexthop address is returned in ipv4_dst or ipv6_dst based on family , smac is set to mac address of egress device , dmac is set to nexthop mac address , rt_metric is set to metric from route (IPv4/IPv6 only) , and ifindex is set to the device index of the nexthop from the FIB lookup. <[ plen ]>(IP: 2) argument is the size of the passed in struct. <[ flags ]>(IP: 3) argument can be a combination of one or more of the following values: BPF_FIB_LOOKUP_DIRECT Do a direct table lookup vs full lookup using FIB rules. BPF_FIB_LOOKUP_OUTPUT Perform lookup from an egress perspective (default is ingress). <[ ctx ]>(IP: 0) is either struct xdp_md for XDP programs or struct sk_buff tc cls_act programs. Return \u00b7 < 0 if any input argument is invalid \u00b7 0 on success (packet is forwarded , nexthop neighbor exists) \u00b7 > 0 one of BPF_FIB_LKUP_RET_ codes explaining why the packet is not forwarded or needs assist from full stack ", "Function Name": "fib_lookup", "Input Params": ["{Type: void ,Var: *ctx}", "{Type:  struct fib_lookup ,Var: *params}", "{Type:  int ,Var: plen}", "{Type:  u32 ,Var: flags}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp"], "capabilities": ["read_sys_info"]}]}], "helperCallParams": {}, "startLine": 790, "endLine": 853, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c", "funcName": "do_netdev_encrypt_fib", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff * ctx __maybe_unused", " __u16 proto __maybe_unused", " int * encrypt_iface __maybe_unused", " int * ext_err __maybe_unused"], "output": "static__always_inlineint", "helper": ["bpf_fib_lookup", "fib_lookup"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["static __always_inline int do_netdev_encrypt_fib (struct  __ctx_buff * ctx __maybe_unused, __u16 proto __maybe_unused, int * encrypt_iface __maybe_unused, int * ext_err __maybe_unused)\n", "{\n", "    int ret = 0;\n", "\n", "#if defined(BPF_HAVE_FIB_LOOKUP) && defined(ENCRYPT_IFACE)\n", "    struct bpf_fib_lookup fib_params = {}\n", "    ;\n", "    void *data, *data_end;\n", "    int err;\n", "    if (proto == bpf_htons (ETH_P_IP)) {\n", "        struct iphdr *ip4;\n", "        if (!revalidate_data (ctx, &data, &data_end, &ip4)) {\n", "            ret = DROP_INVALID;\n", "            goto drop_err_fib;\n", "        }\n", "        fib_params.family = AF_INET;\n", "        fib_params.ipv4_src = ip4->saddr;\n", "        fib_params.ipv4_dst = ip4->daddr;\n", "    }\n", "    else {\n", "        struct ipv6hdr *ip6;\n", "        if (!revalidate_data (ctx, &data, &data_end, &ip6)) {\n", "            ret = DROP_INVALID;\n", "            goto drop_err_fib;\n", "        }\n", "        fib_params.family = AF_INET6;\n", "        ipv6_addr_copy ((union v6addr *) &fib_params.ipv6_src, (union v6addr *) &ip6->saddr);\n", "        ipv6_addr_copy ((union v6addr *) &fib_params.ipv6_dst, (union v6addr *) &ip6->daddr);\n", "    }\n", "    fib_params.ifindex = *encrypt_iface;\n", "    err = fib_lookup (ctx, & fib_params, sizeof (fib_params), BPF_FIB_LOOKUP_DIRECT | BPF_FIB_LOOKUP_OUTPUT);\n", "    if (err != 0) {\n", "        *ext_err = err;\n", "        ret = DROP_NO_FIB;\n", "        goto drop_err_fib;\n", "    }\n", "    if (eth_store_daddr (ctx, fib_params.dmac, 0) < 0) {\n", "        ret = DROP_WRITE_ERROR;\n", "        goto drop_err_fib;\n", "    }\n", "    if (eth_store_saddr (ctx, fib_params.smac, 0) < 0) {\n", "        ret = DROP_WRITE_ERROR;\n", "        goto drop_err_fib;\n", "    }\n", "    *encrypt_iface = fib_params.ifindex;\n", "drop_err_fib :\n", "\n", "#endif /* BPF_HAVE_FIB_LOOKUP */\n", "    return ret;\n", "}\n"], "called_function_list": ["eth_store_daddr", "eth_store_saddr", "ipv6_addr_copy"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "do_netdev_encrypt": [{"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 855, "endLine": 885, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c", "funcName": "do_netdev_encrypt", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " __u16 proto", " __u32 src_id"], "output": "static__always_inlineint", "helper": ["CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["static __always_inline int do_netdev_encrypt (struct  __ctx_buff *ctx, __u16 proto, __u32 src_id)\n", "{\n", "    int encrypt_iface = 0;\n", "    int ext_err = 0;\n", "    int ret = 0;\n", "\n", "#if defined(ENCRYPT_IFACE) && defined(BPF_HAVE_FIB_LOOKUP)\n", "    encrypt_iface = ENCRYPT_IFACE;\n", "\n", "#endif\n", "    ret = do_netdev_encrypt_pools (ctx);\n", "    if (ret)\n", "        return send_drop_notify_error (ctx, src_id, ret, CTX_ACT_DROP, METRIC_INGRESS);\n", "    ret = do_netdev_encrypt_fib (ctx, proto, & encrypt_iface, & ext_err);\n", "    if (ret)\n", "        return send_drop_notify_error_ext (ctx, src_id, ret, ext_err, CTX_ACT_DROP, METRIC_INGRESS);\n", "    bpf_clear_meta (ctx);\n", "\n", "#ifdef BPF_HAVE_FIB_LOOKUP\n", "    if (encrypt_iface)\n", "        return ctx_redirect (ctx, encrypt_iface, 0);\n", "\n", "#endif\n", "    return CTX_ACT_OK;\n", "}\n"], "called_function_list": ["do_netdev_encrypt_fib", "do_netdev_encrypt_encap", "ctx_redirect", "bpf_clear_meta", "do_netdev_encrypt_pools"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 904, "endLine": 908, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c", "funcName": "do_netdev_encrypt", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " __u16 proto __maybe_unused", " __u32 src_id"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int do_netdev_encrypt (struct  __ctx_buff *ctx, __u16 proto __maybe_unused, __u32 src_id)\n", "{\n", "    return do_netdev_encrypt_encap (ctx, src_id);\n", "}\n"], "called_function_list": ["do_netdev_encrypt_fib", "do_netdev_encrypt_encap", "ctx_redirect", "bpf_clear_meta", "do_netdev_encrypt_pools"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "do_netdev_encrypt_encap": [{"capabilities": [], "helperCallParams": {}, "startLine": 888, "endLine": 902, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c", "funcName": "do_netdev_encrypt_encap", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " __u32 src_id"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int do_netdev_encrypt_encap (struct  __ctx_buff *ctx, __u32 src_id)\n", "{\n", "    struct trace_ctx trace = {\n", "        .reason = TRACE_REASON_ENCRYPTED,\n", "        .monitor = TRACE_PAYLOAD_LEN,}\n", "    ;\n", "    __u32 tunnel_endpoint = 0;\n", "    tunnel_endpoint = ctx_load_meta (ctx, CB_ENCRYPT_DST);\n", "    ctx->mark = 0;\n", "    bpf_clear_meta (ctx);\n", "    return __encap_and_redirect_with_nodeid (ctx, tunnel_endpoint, src_id, NOT_VTEP_DST, &trace);\n", "}\n"], "called_function_list": ["bpf_clear_meta", "ctx_load_meta", "__encap_and_redirect_with_nodeid"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "do_netdev": [{"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 912, "endLine": 1022, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c", "funcName": "do_netdev", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " __u16 proto", " const bool from_host"], "output": "static__always_inlineint", "helper": ["tail_call", "CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["static __always_inline int do_netdev (struct  __ctx_buff *ctx, __u16 proto, const bool from_host)\n", "{\n", "    __u32 __maybe_unused identity = 0;\n", "    __u32 __maybe_unused ipcache_srcid = 0;\n", "    int ret;\n", "\n", "#if defined(ENABLE_L7_LB)\n", "    if (from_host) {\n", "        __u32 magic = ctx->mark & MARK_MAGIC_HOST_MASK;\n", "        if (magic == MARK_MAGIC_PROXY_EGRESS_EPID) {\n", "            __u32 lxc_id = get_epid (ctx);\n", "            ctx->mark = 0;\n", "            tail_call_dynamic (ctx, &POLICY_EGRESSCALL_MAP, lxc_id);\n", "            return DROP_MISSED_TAIL_CALL;\n", "        }\n", "    }\n", "\n", "#endif\n", "\n", "#ifdef ENABLE_IPSEC\n", "    if (!from_host && !do_decrypt (ctx, proto))\n", "        return CTX_ACT_OK;\n", "\n", "#endif\n", "    if (from_host) {\n", "        __u32 magic;\n", "        enum trace_point trace = TRACE_FROM_HOST;\n", "        magic = inherit_identity_from_host (ctx, & identity);\n", "        if (magic == MARK_MAGIC_PROXY_INGRESS || magic == MARK_MAGIC_PROXY_EGRESS)\n", "            trace = TRACE_FROM_PROXY;\n", "\n", "#ifdef ENABLE_IPSEC\n", "        if (magic == MARK_MAGIC_ENCRYPT) {\n", "            send_trace_notify (ctx, TRACE_FROM_STACK, identity, 0, 0, ctx->ingress_ifindex, TRACE_REASON_ENCRYPTED, TRACE_PAYLOAD_LEN);\n", "            return do_netdev_encrypt (ctx, proto, identity);\n", "        }\n", "\n", "#endif\n", "        send_trace_notify (ctx, trace, identity, 0, 0, ctx->ingress_ifindex, TRACE_REASON_UNKNOWN, TRACE_PAYLOAD_LEN);\n", "    }\n", "    else {\n", "        bpf_skip_nodeport_clear (ctx);\n", "        send_trace_notify (ctx, TRACE_FROM_NETWORK, 0, 0, 0, ctx->ingress_ifindex, TRACE_REASON_UNKNOWN, TRACE_PAYLOAD_LEN);\n", "    }\n", "    bpf_clear_meta (ctx);\n", "    switch (proto) {\n", "\n", "# if defined ENABLE_ARP_PASSTHROUGH || defined ENABLE_ARP_RESPONDER\n", "    case bpf_htons (ETH_P_ARP) :\n", "        ret = CTX_ACT_OK;\n", "        break;\n", "\n", "# endif\n", "\n", "#ifdef ENABLE_IPV6\n", "    case bpf_htons (ETH_P_IPV6) :\n", "        identity = resolve_srcid_ipv6 (ctx, identity, from_host);\n", "        ctx_store_meta (ctx, CB_SRC_IDENTITY, identity);\n", "        if (from_host)\n", "            ep_tail_call (ctx, CILIUM_CALL_IPV6_FROM_HOST);\n", "        else\n", "            ep_tail_call (ctx, CILIUM_CALL_IPV6_FROM_NETDEV);\n", "        return send_drop_notify_error (ctx, identity, DROP_MISSED_TAIL_CALL, CTX_ACT_OK, METRIC_INGRESS);\n", "\n", "#endif\n", "\n", "#ifdef ENABLE_IPV4\n", "    case bpf_htons (ETH_P_IP) :\n", "        identity = resolve_srcid_ipv4 (ctx, identity, &ipcache_srcid, from_host);\n", "        ctx_store_meta (ctx, CB_SRC_IDENTITY, identity);\n", "        if (from_host) {\n", "\n", "# if defined(ENABLE_HOST_FIREWALL) && !defined(ENABLE_MASQUERADE)\n", "            ctx_store_meta (ctx, CB_IPCACHE_SRC_LABEL, ipcache_srcid);\n", "\n", "# endif\n", "            ep_tail_call (ctx, CILIUM_CALL_IPV4_FROM_HOST);\n", "        }\n", "        else {\n", "            ep_tail_call (ctx, CILIUM_CALL_IPV4_FROM_NETDEV);\n", "        }\n", "        return send_drop_notify_error (ctx, identity, DROP_MISSED_TAIL_CALL, CTX_ACT_OK, METRIC_INGRESS);\n", "\n", "#endif\n", "    default :\n", "\n", "#ifdef ENABLE_HOST_FIREWALL\n", "        ret = send_drop_notify_error (ctx, identity, DROP_UNKNOWN_L3, CTX_ACT_DROP, METRIC_INGRESS);\n", "\n", "#else\n", "        ret = CTX_ACT_OK;\n", "\n", "#endif /* ENABLE_HOST_FIREWALL */\n", "    }\n", "    return ret;\n", "}\n"], "called_function_list": ["send_trace_notify", "bpf_skip_nodeport_clear", "get_epid", "resolve_srcid_ipv4", "resolve_srcid_ipv6", "tail_call_dynamic", "ep_tail_call", "ctx_store_meta", "do_decrypt", "bpf_clear_meta", "do_netdev_encrypt", "inherit_identity_from_host"], "call_depth": 3, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "handle_netdev": [{"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 1031, "endLine": 1051, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c", "funcName": "handle_netdev", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " const bool from_host"], "output": "static__always_inlineint", "helper": ["CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["static __always_inline int handle_netdev (struct  __ctx_buff *ctx, const bool from_host)\n", "{\n", "    __u16 proto;\n", "    if (!validate_ethertype (ctx, &proto)) {\n", "\n", "#ifdef ENABLE_HOST_FIREWALL\n", "        int ret = DROP_UNSUPPORTED_L2;\n", "        return send_drop_notify (ctx, SECLABEL, WORLD_ID, 0, ret, CTX_ACT_DROP, METRIC_EGRESS);\n", "\n", "#else\n", "        send_trace_notify (ctx, TRACE_TO_STACK, HOST_ID, 0, 0, 0, TRACE_REASON_UNKNOWN, 0);\n", "        return CTX_ACT_OK;\n", "\n", "#endif /* ENABLE_HOST_FIREWALL */\n", "    }\n", "    return do_netdev (ctx, proto, from_host);\n", "}\n"], "called_function_list": ["send_trace_notify", "validate_ethertype", "do_netdev"], "call_depth": 4, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "handle_srv6": [{"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 1054, "endLine": 1142, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c", "funcName": "handle_srv6", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx"], "output": "static__always_inline", "helper": ["CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["static __always_inline handle_srv6 (struct  __ctx_buff *ctx)\n", "{\n", "    __u32 *vrf_id, dst_id, tunnel_ep = 0;\n", "    struct srv6_ipv6_2tuple *outer_ips;\n", "    struct iphdr * ip4 __maybe_unused;\n", "    struct remote_endpoint_info *ep;\n", "    void *data, *data_end;\n", "    struct ipv6hdr *ip6;\n", "    union v6addr *sid;\n", "    __u16 proto;\n", "    if (!validate_ethertype (ctx, &proto))\n", "        return DROP_UNSUPPORTED_L2;\n", "    switch (proto) {\n", "    case bpf_htons (ETH_P_IPV6) :\n", "        if (!revalidate_data (ctx, &data, &data_end, &ip6))\n", "            return DROP_INVALID;\n", "        outer_ips = srv6_lookup_state_entry6 (ip6);\n", "        if (outer_ips) {\n", "            ep_tail_call (ctx, CILIUM_CALL_SRV6_REPLY);\n", "            return DROP_MISSED_TAIL_CALL;\n", "        }\n", "        ep = lookup_ip6_remote_endpoint ((union v6addr *) & ip6 -> daddr);\n", "        if (ep) {\n", "            tunnel_ep = ep->tunnel_endpoint;\n", "            dst_id = ep->sec_label;\n", "        }\n", "        else {\n", "            dst_id = WORLD_ID;\n", "        }\n", "        if (identity_is_cluster (dst_id))\n", "            return CTX_ACT_OK;\n", "        vrf_id = srv6_lookup_vrf6 (& ip6 -> saddr, & ip6 -> daddr);\n", "        if (!vrf_id)\n", "            return CTX_ACT_OK;\n", "        sid = srv6_lookup_policy6 (* vrf_id, & ip6 -> daddr);\n", "        if (!sid)\n", "            return CTX_ACT_OK;\n", "        srv6_store_meta_sid (ctx, sid);\n", "        ctx_store_meta (ctx, CB_SRV6_VRF_ID, *vrf_id);\n", "        ep_tail_call (ctx, CILIUM_CALL_SRV6_ENCAP);\n", "        return DROP_MISSED_TAIL_CALL;\n", "\n", "# ifdef ENABLE_IPV4\n", "    case bpf_htons (ETH_P_IP) :\n", "        if (!revalidate_data (ctx, &data, &data_end, &ip4))\n", "            return DROP_INVALID;\n", "        outer_ips = srv6_lookup_state_entry4 (ip4);\n", "        if (outer_ips) {\n", "            ep_tail_call (ctx, CILIUM_CALL_SRV6_REPLY);\n", "            return DROP_MISSED_TAIL_CALL;\n", "        }\n", "        ep = lookup_ip4_remote_endpoint (ip4 -> daddr);\n", "        if (ep) {\n", "            tunnel_ep = ep->tunnel_endpoint;\n", "            dst_id = ep->sec_label;\n", "        }\n", "        else {\n", "            dst_id = WORLD_ID;\n", "        }\n", "        if (identity_is_cluster (dst_id))\n", "            return CTX_ACT_OK;\n", "        vrf_id = srv6_lookup_vrf4 (ip4 -> saddr, ip4 -> daddr);\n", "        if (!vrf_id)\n", "            return CTX_ACT_OK;\n", "        sid = srv6_lookup_policy4 (* vrf_id, ip4 -> daddr);\n", "        if (!sid)\n", "            return CTX_ACT_OK;\n", "        srv6_store_meta_sid (ctx, sid);\n", "        ctx_store_meta (ctx, CB_SRV6_VRF_ID, *vrf_id);\n", "        ep_tail_call (ctx, CILIUM_CALL_SRV6_ENCAP);\n", "        return DROP_MISSED_TAIL_CALL;\n", "        break;\n", "\n", "# endif\n", "    }\n", "    return CTX_ACT_OK;\n", "}\n"], "called_function_list": ["srv6_lookup_vrf6", "srv6_lookup_vrf4", "srv6_lookup_policy4", "ep_tail_call", "ctx_store_meta", "srv6_lookup_policy6", "srv6_lookup_state_entry4", "validate_ethertype", "srv6_lookup_state_entry6", "identity_is_cluster", "srv6_store_meta_sid"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "from_netdev": [{"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 1152, "endLine": 1170, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c", "funcName": "from_netdev", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx"], "output": "int", "helper": ["CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["int from_netdev (struct  __ctx_buff *ctx)\n", "{\n", "    __u32 __maybe_unused vlan_id;\n", "    if (ctx->vlan_present) {\n", "        vlan_id = ctx->vlan_tci & 0xfff;\n", "        if (vlan_id) {\n", "            if (allow_vlan (ctx->ifindex, vlan_id))\n", "                return CTX_ACT_OK;\n", "            else\n", "                return send_drop_notify_error (ctx, 0, DROP_VLAN_FILTERED, CTX_ACT_DROP, METRIC_INGRESS);\n", "        }\n", "    }\n", "    return handle_netdev (ctx, false);\n", "}\n"], "called_function_list": ["allow_vlan", "handle_netdev"], "call_depth": 5, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "from_host": [{"capabilities": [], "helperCallParams": {}, "startLine": 1177, "endLine": 1184, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c", "funcName": "from_host", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx"], "output": "int", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["int from_host (struct  __ctx_buff *ctx)\n", "{\n", "    edt_set_aggregate (ctx, 0);\n", "    return handle_netdev (ctx, true);\n", "}\n"], "called_function_list": ["edt_set_aggregate", "handle_netdev"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "to_netdev": [{"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 1193, "endLine": 1319, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c", "funcName": "to_netdev", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff * ctx __maybe_unused"], "output": "int", "helper": ["CTX_ACT_OK", "tail_call"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["int to_netdev (struct  __ctx_buff * ctx __maybe_unused)\n", "{\n", "    struct trace_ctx trace = {\n", "        .reason = TRACE_REASON_UNKNOWN,\n", "        .monitor = 0,}\n", "    ;\n", "    __u16 __maybe_unused proto = 0;\n", "    __u32 __maybe_unused vlan_id;\n", "    int ret = CTX_ACT_OK;\n", "    bool traced = false;\n", "    if (ctx->vlan_present) {\n", "        vlan_id = ctx->vlan_tci & 0xfff;\n", "        if (vlan_id) {\n", "            if (allow_vlan (ctx->ifindex, vlan_id))\n", "                return CTX_ACT_OK;\n", "            else\n", "                return send_drop_notify_error (ctx, 0, DROP_VLAN_FILTERED, CTX_ACT_DROP, METRIC_EGRESS);\n", "        }\n", "    }\n", "\n", "#if defined(ENABLE_L7_LB)\n", "    {\n", "        __u32 magic = ctx->mark & MARK_MAGIC_HOST_MASK;\n", "        if (magic == MARK_MAGIC_PROXY_EGRESS_EPID) {\n", "            __u32 lxc_id = get_epid (ctx);\n", "            ctx->mark = 0;\n", "            tail_call_dynamic (ctx, &POLICY_EGRESSCALL_MAP, lxc_id);\n", "            return DROP_MISSED_TAIL_CALL;\n", "        }\n", "    }\n", "\n", "#endif\n", "\n", "#ifdef ENABLE_HOST_FIREWALL\n", "    if (!proto && !validate_ethertype (ctx, &proto)) {\n", "        ret = DROP_UNSUPPORTED_L2;\n", "        goto out;\n", "    }\n", "    policy_clear_mark (ctx);\n", "    switch (proto) {\n", "\n", "# if defined ENABLE_ARP_PASSTHROUGH || defined ENABLE_ARP_RESPONDER\n", "    case bpf_htons (ETH_P_ARP) :\n", "        ret = CTX_ACT_OK;\n", "        break;\n", "\n", "# endif\n", "\n", "# ifdef ENABLE_IPV6\n", "    case bpf_htons (ETH_P_IPV6) :\n", "        ret = handle_to_netdev_ipv6 (ctx, &trace);\n", "        break;\n", "\n", "# endif\n", "\n", "# ifdef ENABLE_IPV4\n", "    case bpf_htons (ETH_P_IP) :\n", "        {\n", "            ret = handle_to_netdev_ipv4 (ctx, & trace);\n", "            break;\n", "        }\n", "\n", "# endif\n", "    default :\n", "        ret = DROP_UNKNOWN_L3;\n", "        break;\n", "    }\n", "out :\n", "    if (IS_ERR (ret))\n", "        return send_drop_notify_error (ctx, 0, ret, CTX_ACT_DROP, METRIC_EGRESS);\n", "\n", "#endif /* ENABLE_HOST_FIREWALL */\n", "\n", "#if defined(ENABLE_BANDWIDTH_MANAGER)\n", "    ret = edt_sched_departure (ctx);\n", "    if (ret == CTX_ACT_DROP) {\n", "        update_metrics (ctx_full_len (ctx), METRIC_EGRESS, -DROP_EDT_HORIZON);\n", "        return ret;\n", "    }\n", "\n", "#endif\n", "\n", "#ifdef ENABLE_SRV6\n", "    ret = handle_srv6 (ctx);\n", "    if (ret != CTX_ACT_OK)\n", "        return send_drop_notify_error (ctx, 0, ret, CTX_ACT_DROP, METRIC_EGRESS);\n", "\n", "#endif /* ENABLE_SRV6 */\n", "\n", "#if defined(ENABLE_NODEPORT) && \\\n", "\t(!defined(ENABLE_DSR) || \\\n", "\t (defined(ENABLE_DSR) && defined(ENABLE_DSR_HYBRID)) || \\\n", "\t defined(ENABLE_MASQUERADE) || \\\n", "\t defined(ENABLE_EGRESS_GATEWAY))\n", "    if ((ctx->mark & MARK_MAGIC_SNAT_DONE) != MARK_MAGIC_SNAT_DONE) {\n", "        ret = handle_nat_fwd (ctx);\n", "        if (IS_ERR (ret))\n", "            return send_drop_notify_error (ctx, 0, ret, CTX_ACT_DROP, METRIC_EGRESS);\n", "        traced = true;\n", "    }\n", "\n", "#endif\n", "\n", "#ifdef ENABLE_HEALTH_CHECK\n", "    ret = lb_handle_health (ctx);\n", "    if (IS_ERR (ret))\n", "        return send_drop_notify_error (ctx, 0, ret, CTX_ACT_DROP, METRIC_EGRESS);\n", "\n", "#endif\n", "    if (!traced)\n", "        send_trace_notify (ctx, TRACE_TO_NETWORK, 0, 0, 0, 0, trace.reason, trace.monitor);\n", "    return ret;\n", "}\n"], "called_function_list": ["policy_clear_mark", "send_trace_notify", "update_metrics", "allow_vlan", "tail_call_dynamic", "handle_to_netdev_ipv6", "ctx_full_len", "handle_nat_fwd", "validate_ethertype", "handle_srv6", "edt_sched_departure", "lb_handle_health", "get_epid", "handle_to_netdev_ipv4"], "call_depth": 5, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "to_host": [{"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 1326, "endLine": 1406, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c", "funcName": "to_host", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx"], "output": "int", "helper": ["CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["int to_host (struct  __ctx_buff *ctx)\n", "{\n", "    __u32 magic = ctx_load_meta (ctx, ENCRYPT_OR_PROXY_MAGIC);\n", "    __u16 __maybe_unused proto = 0;\n", "    struct trace_ctx trace = {\n", "        .reason = TRACE_REASON_UNKNOWN,\n", "        .monitor = 0,}\n", "    ;\n", "    int ret = CTX_ACT_OK;\n", "    bool traced = false;\n", "    __u32 src_id = 0;\n", "    if ((magic & MARK_MAGIC_HOST_MASK) == MARK_MAGIC_ENCRYPT) {\n", "        ctx->mark = magic;\n", "        src_id = ctx_load_meta (ctx, CB_ENCRYPT_IDENTITY);\n", "        set_identity_mark (ctx, src_id);\n", "    }\n", "    else if ((magic & 0xFFFF) == MARK_MAGIC_TO_PROXY) {\n", "        __be16 port = magic >> 16;\n", "        ctx_store_meta (ctx, CB_PROXY_MAGIC, 0);\n", "        ret = ctx_redirect_to_proxy_first (ctx, port);\n", "        if (IS_ERR (ret))\n", "            goto out;\n", "        traced = true;\n", "    }\n", "\n", "#ifdef ENABLE_IPSEC\n", "    ctx_change_type (ctx, PACKET_HOST);\n", "\n", "#endif\n", "\n", "#ifdef ENABLE_HOST_FIREWALL\n", "    if (!validate_ethertype (ctx, &proto)) {\n", "        ret = DROP_UNSUPPORTED_L2;\n", "        goto out;\n", "    }\n", "    policy_clear_mark (ctx);\n", "    switch (proto) {\n", "\n", "# if defined ENABLE_ARP_PASSTHROUGH || defined ENABLE_ARP_RESPONDER\n", "    case bpf_htons (ETH_P_ARP) :\n", "        ret = CTX_ACT_OK;\n", "        break;\n", "\n", "# endif\n", "\n", "# ifdef ENABLE_IPV6\n", "    case bpf_htons (ETH_P_IPV6) :\n", "        ret = ipv6_host_policy_ingress (ctx, &src_id, &trace);\n", "        break;\n", "\n", "# endif\n", "\n", "# ifdef ENABLE_IPV4\n", "    case bpf_htons (ETH_P_IP) :\n", "        ret = ipv4_host_policy_ingress (ctx, &src_id, &trace);\n", "        break;\n", "\n", "# endif\n", "    default :\n", "        ret = DROP_UNKNOWN_L3;\n", "        break;\n", "    }\n", "\n", "#else\n", "    ret = CTX_ACT_OK;\n", "\n", "#endif /* ENABLE_HOST_FIREWALL */\n", "out :\n", "    if (IS_ERR (ret))\n", "        return send_drop_notify_error (ctx, src_id, ret, CTX_ACT_DROP, METRIC_INGRESS);\n", "    if (!traced)\n", "        send_trace_notify (ctx, TRACE_TO_STACK, src_id, 0, 0, CILIUM_IFINDEX, trace.reason, trace.monitor);\n", "    return ret;\n", "}\n"], "called_function_list": ["policy_clear_mark", "ipv6_host_policy_ingress", "send_trace_notify", "ctx_store_meta", "ctx_load_meta", "validate_ethertype", "set_identity_mark", "ipv4_host_policy_ingress", "ctx_redirect_to_proxy_first"], "call_depth": 3, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "tail_ipv6_host_policy_ingress": [{"capabilities": [], "helperCallParams": {}, "startLine": 1412, "endLine": 1426, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c", "funcName": "tail_ipv6_host_policy_ingress", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx"], "output": "int", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["int tail_ipv6_host_policy_ingress (struct  __ctx_buff *ctx)\n", "{\n", "    struct trace_ctx __maybe_unused trace = {\n", "        .reason = TRACE_REASON_UNKNOWN,\n", "        .monitor = 0,}\n", "    ;\n", "    __u32 src_id = 0;\n", "    int ret;\n", "    ret = ipv6_host_policy_ingress (ctx, & src_id, & trace);\n", "    if (IS_ERR (ret))\n", "        return send_drop_notify_error (ctx, src_id, ret, CTX_ACT_DROP, METRIC_INGRESS);\n", "    return ret;\n", "}\n"], "called_function_list": ["ipv6_host_policy_ingress"], "call_depth": 3, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "tail_ipv4_host_policy_ingress": [{"capabilities": [], "helperCallParams": {}, "startLine": 1432, "endLine": 1446, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c", "funcName": "tail_ipv4_host_policy_ingress", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx"], "output": "int", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["int tail_ipv4_host_policy_ingress (struct  __ctx_buff *ctx)\n", "{\n", "    struct trace_ctx __maybe_unused trace = {\n", "        .reason = TRACE_REASON_UNKNOWN,\n", "        .monitor = TRACE_PAYLOAD_LEN,}\n", "    ;\n", "    __u32 src_id = 0;\n", "    int ret;\n", "    ret = ipv4_host_policy_ingress (ctx, & src_id, & trace);\n", "    if (IS_ERR (ret))\n", "        return send_drop_notify_error (ctx, src_id, ret, CTX_ACT_DROP, METRIC_INGRESS);\n", "    return ret;\n", "}\n"], "called_function_list": ["ipv4_host_policy_ingress"], "call_depth": 4, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "to_host_from_lxc": [{"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 1449, "endLine": 1497, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c", "funcName": "to_host_from_lxc", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff * ctx __maybe_unused"], "output": "static__always_inlineint", "helper": ["CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["static __always_inline int to_host_from_lxc (struct  __ctx_buff * ctx __maybe_unused)\n", "{\n", "    int ret = CTX_ACT_OK;\n", "    __u16 proto = 0;\n", "    if (!validate_ethertype (ctx, &proto)) {\n", "        ret = DROP_UNSUPPORTED_L2;\n", "        goto out;\n", "    }\n", "    switch (proto) {\n", "\n", "# if defined ENABLE_ARP_PASSTHROUGH || defined ENABLE_ARP_RESPONDER\n", "    case bpf_htons (ETH_P_ARP) :\n", "        ret = CTX_ACT_OK;\n", "        break;\n", "\n", "# endif\n", "\n", "# ifdef ENABLE_IPV6\n", "    case bpf_htons (ETH_P_IPV6) :\n", "        invoke_tailcall_if (__or (__and (is_defined (ENABLE_IPV4), is_defined (ENABLE_IPV6)), is_defined (DEBUG)), CILIUM_CALL_IPV6_TO_HOST_POLICY_ONLY, tail_ipv6_host_policy_ingress);\n", "        break;\n", "\n", "# endif\n", "\n", "# ifdef ENABLE_IPV4\n", "    case bpf_htons (ETH_P_IP) :\n", "        invoke_tailcall_if (__or (__and (is_defined (ENABLE_IPV4), is_defined (ENABLE_IPV6)), is_defined (DEBUG)), CILIUM_CALL_IPV4_TO_HOST_POLICY_ONLY, tail_ipv4_host_policy_ingress);\n", "        break;\n", "\n", "# endif\n", "    default :\n", "        ret = DROP_UNKNOWN_L3;\n", "        break;\n", "    }\n", "out :\n", "    if (IS_ERR (ret))\n", "        return send_drop_notify_error (ctx, 0, ret, CTX_ACT_DROP, METRIC_INGRESS);\n", "    return ret;\n", "}\n"], "called_function_list": ["validate_ethertype"], "call_depth": 3, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "from_host_to_lxc": [{"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 1503, "endLine": 1545, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c", "funcName": "from_host_to_lxc", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx"], "output": "static__always_inlineint", "helper": ["CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["static __always_inline int from_host_to_lxc (struct  __ctx_buff *ctx)\n", "{\n", "    struct trace_ctx trace = {\n", "        .reason = TRACE_REASON_UNKNOWN,\n", "        .monitor = 0,}\n", "    ;\n", "    int ret = CTX_ACT_OK;\n", "    __u16 proto = 0;\n", "    if (!validate_ethertype (ctx, &proto))\n", "        return DROP_UNSUPPORTED_L2;\n", "    switch (proto) {\n", "\n", "# if defined ENABLE_ARP_PASSTHROUGH || defined ENABLE_ARP_RESPONDER\n", "    case bpf_htons (ETH_P_ARP) :\n", "        ret = CTX_ACT_OK;\n", "        break;\n", "\n", "# endif\n", "\n", "# ifdef ENABLE_IPV6\n", "    case bpf_htons (ETH_P_IPV6) :\n", "        ret = ipv6_host_policy_egress (ctx, HOST_ID, &trace);\n", "        break;\n", "\n", "# endif\n", "\n", "# ifdef ENABLE_IPV4\n", "    case bpf_htons (ETH_P_IP) :\n", "        ret = ipv4_host_policy_egress (ctx, HOST_ID, 0, &trace);\n", "        break;\n", "\n", "# endif\n", "    default :\n", "        ret = DROP_UNKNOWN_L3;\n", "        break;\n", "    }\n", "    return ret;\n", "}\n"], "called_function_list": ["validate_ethertype", "ipv4_host_policy_egress", "ipv6_host_policy_egress"], "call_depth": 4, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "handle_lxc_traffic": [{"capabilities": [], "helperCallParams": {}, "startLine": 1553, "endLine": 1572, "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c", "funcName": "handle_lxc_traffic", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx"], "output": "int", "helper": ["tail_call"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["int handle_lxc_traffic (struct  __ctx_buff *ctx)\n", "{\n", "    bool from_host = ctx_load_meta (ctx, CB_FROM_HOST);\n", "    __u32 lxc_id;\n", "    int ret;\n", "    if (from_host) {\n", "        ret = from_host_to_lxc (ctx);\n", "        if (IS_ERR (ret))\n", "            return send_drop_notify_error (ctx, HOST_ID, ret, CTX_ACT_DROP, METRIC_EGRESS);\n", "        lxc_id = ctx_load_meta (ctx, CB_DST_ENDPOINT_ID);\n", "        ctx_store_meta (ctx, CB_SRC_LABEL, HOST_ID);\n", "        tail_call_dynamic (ctx, &POLICY_CALL_MAP, lxc_id);\n", "        return DROP_MISSED_TAIL_CALL;\n", "    }\n", "    return to_host_from_lxc (ctx);\n", "}\n"], "called_function_list": ["to_host_from_lxc", "tail_call_dynamic", "ctx_store_meta", "ctx_load_meta", "from_host_to_lxc"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "pin_to_cpu": [{"capabilities": [], "helperCallParams": {}, "startLine": 30, "endLine": 38, "File": "/home/sayandes/opened_extraction/examples/cilium/cilium-probe-kernel-hz.c", "funcName": "pin_to_cpu", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["int cpu"], "output": "staticint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static int pin_to_cpu (int cpu)\n", "{\n", "    cpu_set_t set;\n", "    CPU_ZERO (&set);\n", "    CPU_SET (cpu, &set);\n", "    return sched_setaffinity (0, sizeof (set), &set);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{"description": " clear CPU and reset a specific CPU in the set, then sets the CPU affinity mask of the thread ", "author": "Shun Zhang", "authorEmail": "shunz@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "fix_priority": [{"capabilities": [], "helperCallParams": {}, "startLine": 40, "endLine": 47, "File": "/home/sayandes/opened_extraction/examples/cilium/cilium-probe-kernel-hz.c", "funcName": "fix_priority", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["void"], "output": "staticint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static int fix_priority (void)\n", "{\n", "    struct sched_param sp = {\n", "        .sched_priority = sched_get_priority_max (SCHED_FIFO),}\n", "    ;\n", "    return sched_setscheduler (0, SCHED_FIFO, &sp);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{"description": " reset the maxmium for the scheduling policy specified by policy  ", "author": "Shun Zhang", "authorEmail": "shunz@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "timer_list_open": [{"capabilities": [], "helperCallParams": {}, "startLine": 49, "endLine": 52, "File": "/home/sayandes/opened_extraction/examples/cilium/cilium-probe-kernel-hz.c", "funcName": "timer_list_open", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["void"], "output": "staticFILE", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static FILE *timer_list_open (void)\n", "{\n", "    return fopen (\"/proc/timer_list\", \"r\");\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{"description": " read the timer_list file ", "author": "Shun Zhang", "authorEmail": "shunz@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "timer_list_close": [{"capabilities": [], "helperCallParams": {}, "startLine": 54, "endLine": 57, "File": "/home/sayandes/opened_extraction/examples/cilium/cilium-probe-kernel-hz.c", "funcName": "timer_list_close", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["FILE *fp"], "output": "staticvoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static void timer_list_close (FILE *fp)\n", "{\n", "    fclose (fp);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{"description": " close file ", "author": "Shun Zhang", "authorEmail": "shunz@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "prep_kern_jiffies": [{"capabilities": [], "helperCallParams": {}, "startLine": 59, "endLine": 92, "File": "/home/sayandes/opened_extraction/examples/cilium/cilium-probe-kernel-hz.c", "funcName": "prep_kern_jiffies", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct cpu_jiffies *before", " struct cpu_jiffies *after"], "output": "staticint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static int prep_kern_jiffies (struct cpu_jiffies *before, struct cpu_jiffies *after)\n", "{\n", "    uint64_t jiffies = 0;\n", "    char buff [512];\n", "    int cpus = 0;\n", "    FILE *fp;\n", "    fp = timer_list_open ();\n", "    while (fp && fgets (buff, sizeof (buff), fp)) {\n", "        if (sscanf (buff, \"jiffies: %lu\\n\", &jiffies) == 1)\n", "            cpus++;\n", "    }\n", "    timer_list_close (fp);\n", "    if (!cpus) {\n", "        fprintf (stderr, \"No procfs support?\\n\");\n", "        return -EIO;\n", "    }\n", "    before->cpus = after->cpus = cpus;\n", "    before->jiffies = calloc (cpus, sizeof (*before->jiffies));\n", "    after->jiffies = calloc (cpus, sizeof (*before->jiffies));\n", "    if (!before->jiffies || !after->jiffies) {\n", "        free (before->jiffies);\n", "        free (after->jiffies);\n", "        fprintf (stderr, \"Error allocating per CPU jiffies: %s\\n\", strerror (errno));\n", "        return -EIO;\n", "    }\n", "    return 0;\n", "}\n"], "called_function_list": ["timer_list_open", "timer_list_close"], "call_depth": 1, "humanFuncDescription": [{"description": " allocate the CPU jiffies with error check (*) ", "author": "Shun Zhang", "authorEmail": "shunz@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "fetch_kern_jiffies": [{"capabilities": [], "helperCallParams": {}, "startLine": 94, "endLine": 113, "File": "/home/sayandes/opened_extraction/examples/cilium/cilium-probe-kernel-hz.c", "funcName": "fetch_kern_jiffies", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct cpu_jiffies *curr"], "output": "staticint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static int fetch_kern_jiffies (const struct cpu_jiffies *curr)\n", "{\n", "    char buff [512];\n", "    int cpus = 0;\n", "    FILE *fp;\n", "    fp = timer_list_open ();\n", "    while (fp && fgets (buff, sizeof (buff), fp) && cpus < curr->cpus) {\n", "        if (sscanf (buff, \"jiffies: %lu\\n\", &curr->jiffies[cpus]) == 1)\n", "            cpus++;\n", "    }\n", "    timer_list_close (fp);\n", "    if (cpus != curr->cpus) {\n", "        fprintf (stderr, \"CPU mismatch when fetching jiffies\\n\");\n", "        return -EIO;\n", "    }\n", "    return 0;\n", "}\n"], "called_function_list": ["timer_list_open", "timer_list_close"], "call_depth": 1, "humanFuncDescription": [{"description": " fetch the CPU jiffies to fit the cpus set in current cpu parameter ", "author": "Shun Zhang", "authorEmail": "shunz@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "dump_kern_jiffies": [{"capabilities": [], "helperCallParams": {}, "startLine": 115, "endLine": 150, "File": "/home/sayandes/opened_extraction/examples/cilium/cilium-probe-kernel-hz.c", "funcName": "dump_kern_jiffies", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct cpu_jiffies *fixed", " const struct cpu_jiffies *result", " bool macro"], "output": "staticint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static int dump_kern_jiffies (const struct cpu_jiffies *fixed, const struct cpu_jiffies *result, bool macro)\n", "{\n", "    uint64_t delta, warp = 0;\n", "    int i, j, ret = -1;\n", "    int64_t x;\n", "    for (i = 0; i < result->cpus; i++) {\n", "        result->jiffies[i] -= fixed->jiffies[i];\n", "        for (j = 0, delta = ~0; j < ARRAY_SIZE (kernel_hz); j++) {\n", "            x = abs ((int64_t) (kernel_hz [j] - result -> jiffies [i]));\n", "            if (x < delta) {\n", "                delta = x;\n", "                fixed->jiffies[i] = kernel_hz[j];\n", "            }\n", "        }\n", "        if (delta > warp)\n", "            warp = delta;\n", "        if (fixed->jiffies[i] != fixed->jiffies[0]) {\n", "            fprintf (stderr, \"Probed jiffies mismatch: %lu vs %lu HZ\\n\", fixed->jiffies[i], fixed->jiffies[0]);\n", "            goto out;\n", "        }\n", "    }\n", "    if (macro)\n", "        printf (\"#define KERNEL_HZ %lu\\t/* warp: %lu jiffies */\\n\", fixed->jiffies[0], warp);\n", "    else\n", "        printf (\"%lu, %lu\\n\", fixed->jiffies[0], warp);\n", "    ret = 0;\n", "out :\n", "    free (fixed->jiffies);\n", "    free (result->jiffies);\n", "    return ret;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{"description": " decrease the fixed jiffies from the result jiffies, reset fixed jiffies to the closest kernel_hz stop when any fixed_jiffies isn't constant with the first one. With a macro bool for debugging  ", "author": "Shun Zhang", "authorEmail": "shunz@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "sk_extract4_key": [{"capabilities": [], "helperCallParams": {}, "startLine": 26, "endLine": 40, "File": "/home/sayandes/opened_extraction/examples/cilium/sockops/bpf_sockops.c", "funcName": "sk_extract4_key", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct bpf_sock_ops *ops", " struct sock_key *key"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void sk_extract4_key (const struct bpf_sock_ops *ops, struct sock_key *key)\n", "{\n", "    key->dip4 = ops->remote_ip4;\n", "    key->sip4 = ops->local_ip4;\n", "    key->family = ENDPOINT_KEY_IPV4;\n", "    key->sport = (bpf_ntohl (ops->local_port) >> 16);\n", "    key->dport = READ_ONCE (ops->remote_port) >> 16;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{"description": " set the sport and dport of the input key with 32 bits local port and remote port (ip4)  ", "author": "Shun Zhang", "authorEmail": "shunz@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "sk_lb4_key": [{"capabilities": [], "helperCallParams": {}, "startLine": 42, "endLine": 48, "File": "/home/sayandes/opened_extraction/examples/cilium/sockops/bpf_sockops.c", "funcName": "sk_lb4_key", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct lb4_key *lb4", " const struct sock_key *key"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void sk_lb4_key (struct lb4_key *lb4, const struct sock_key *key)\n", "{\n", "    lb4->address = key->dip4;\n", "    lb4->dport = (__u16) key->dport;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{"description": " copy address and dport of lb4 from socket key ", "author": "Shun Zhang", "authorEmail": "shunz@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "bpf_sock_ops_ipv4": [{"capabilities": [], "helperCallParams": {}, "startLine": 55, "endLine": 118, "File": "/home/sayandes/opened_extraction/examples/cilium/sockops/bpf_sockops.c", "funcName": "bpf_sock_ops_ipv4", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct bpf_sock_ops *skops"], "output": "staticinlinevoid", "helper": ["sock_hash_update"], "compatibleHookpoints": ["sock_ops"], "source": ["static inline void bpf_sock_ops_ipv4 (struct bpf_sock_ops *skops)\n", "{\n", "    struct lb4_key lb4_key = {}\n", "    ;\n", "    __u32 dip4, dport, dst_id = 0;\n", "    struct endpoint_info *exists;\n", "    struct lb4_service *svc;\n", "    struct sock_key key = {}\n", "    ;\n", "    int verdict;\n", "    sk_extract4_key (skops, &key);\n", "    sk_lb4_key (&lb4_key, &key);\n", "    svc = lb4_lookup_service (& lb4_key, true);\n", "    if (svc)\n", "        return;\n", "    if (1) {\n", "        struct remote_endpoint_info *info;\n", "        info = lookup_ip4_remote_endpoint (key.dip4);\n", "        if (info != NULL && info->sec_label)\n", "            dst_id = info->sec_label;\n", "        else\n", "            dst_id = WORLD_ID;\n", "    }\n", "    verdict = policy_sk_egress (dst_id, key.sip4, (__u16) key.dport);\n", "    if (redirect_to_proxy (verdict)) {\n", "        __be32 host_ip = IPV4_GATEWAY;\n", "        key.dip4 = key.sip4;\n", "        key.dport = key.sport;\n", "        key.sip4 = host_ip;\n", "        key.sport = verdict;\n", "        sock_hash_update (skops, &SOCK_OPS_MAP, &key, BPF_NOEXIST);\n", "        return;\n", "    }\n", "    exists = __lookup_ip4_endpoint (key.dip4);\n", "    if (!exists)\n", "        return;\n", "    dip4 = key.dip4;\n", "    dport = key.dport;\n", "    key.dip4 = key.sip4;\n", "    key.dport = key.sport;\n", "    key.sip4 = dip4;\n", "    key.sport = dport;\n", "    sock_hash_update (skops, &SOCK_OPS_MAP, &key, BPF_NOEXIST);\n", "}\n"], "called_function_list": ["sk_extract4_key", "sk_lb4_key", "lb4_lookup_service", "__lookup_ip4_endpoint", "policy_sk_egress", "redirect_to_proxy"], "call_depth": 2, "humanFuncDescription": [{"description": " update the destination and source port, ip to the skops with respect to whther  the packet is redirect to proxy port (or we say whether verdict is larger than 0) ", "author": "Shun Zhang", "authorEmail": "shunz@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "bpf_sock_ops_ipv6": [{"capabilities": [], "helperCallParams": {}, "startLine": 122, "endLine": 126, "File": "/home/sayandes/opened_extraction/examples/cilium/sockops/bpf_sockops.c", "funcName": "bpf_sock_ops_ipv6", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct bpf_sock_ops *skops"], "output": "staticinlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static inline void bpf_sock_ops_ipv6 (struct bpf_sock_ops *skops)\n", "{\n", "    if (skops->remote_ip4)\n", "        bpf_sock_ops_ipv4 (skops);\n", "}\n"], "called_function_list": ["bpf_sock_ops_ipv4"], "call_depth": 3, "humanFuncDescription": [{"description": " update the destination and source port, ip to the skops with respect to whther  the packet is redirect to proxy port (or we say whether verdict is larger than 0) same as bpf_sock_ops_ipv4 but adapt for ipv6 ", "author": "Shun Zhang", "authorEmail": "shunz@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "bpf_sockmap": [{"capabilities": [], "helperCallParams": {}, "startLine": 130, "endLine": 154, "File": "/home/sayandes/opened_extraction/examples/cilium/sockops/bpf_sockops.c", "funcName": "bpf_sockmap", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct bpf_sock_ops *skops"], "output": "int", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["int bpf_sockmap (struct bpf_sock_ops *skops)\n", "{\n", "    __u32 family, op;\n", "    family = skops->family;\n", "    op = skops->op;\n", "    switch (op) {\n", "    case BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB :\n", "    case BPF_SOCK_OPS_ACTIVE_ESTABLISHED_CB :\n", "\n", "#ifdef ENABLE_IPV6\n", "        if (family == AF_INET6)\n", "            bpf_sock_ops_ipv6 (skops);\n", "\n", "#endif\n", "\n", "#ifdef ENABLE_IPV4\n", "        if (family == AF_INET)\n", "            bpf_sock_ops_ipv4 (skops);\n", "\n", "#endif\n", "        break;\n", "    default :\n", "        break;\n", "    }\n", "    return 0;\n", "}\n"], "called_function_list": ["bpf_sock_ops_ipv6", "bpf_sock_ops_ipv4"], "call_depth": 4, "humanFuncDescription": [{"description": " calling bpf_sock_ops_ipv4 or bpf_sock_ops_ipv6 according to the family ip version  ", "author": "Shun Zhang", "authorEmail": "shunz@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "sk_msg_extract4_key": [{"capabilities": [], "helperCallParams": {}, "startLine": 25, "endLine": 39, "File": "/home/sayandes/opened_extraction/examples/cilium/sockops/bpf_redir.c", "funcName": "sk_msg_extract4_key", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct sk_msg_md *msg", " struct sock_key *key"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void sk_msg_extract4_key (const struct sk_msg_md *msg, struct sock_key *key)\n", "{\n", "    key->dip4 = msg->remote_ip4;\n", "    key->sip4 = msg->local_ip4;\n", "    key->family = ENDPOINT_KEY_IPV4;\n", "    key->sport = (bpf_ntohl (msg->local_port) >> 16);\n", "    key->dport = READ_ONCE (msg->remote_port) >> 16;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [{"description": " set the sport and dport of the input key with 32 bits local port and remote port (ip4)  ", "author": "Shun Zhang", "authorEmail": "shunz@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "bpf_redir_proxy": [{"capabilities": [], "helperCallParams": {}, "startLine": 42, "endLine": 67, "File": "/home/sayandes/opened_extraction/examples/cilium/sockops/bpf_redir.c", "funcName": "bpf_redir_proxy", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct sk_msg_md *msg"], "output": "int", "helper": ["msg_redirect_hash"], "compatibleHookpoints": ["sk_msg"], "source": ["int bpf_redir_proxy (struct sk_msg_md *msg)\n", "{\n", "    struct remote_endpoint_info *info;\n", "    __u64 flags = BPF_F_INGRESS;\n", "    struct sock_key key = {}\n", "    ;\n", "    __u32 dst_id = 0;\n", "    int verdict;\n", "    sk_msg_extract4_key (msg, &key);\n", "    info = lookup_ip4_remote_endpoint (key.dip4);\n", "    if (info != NULL && info->sec_label)\n", "        dst_id = info->sec_label;\n", "    else\n", "        dst_id = WORLD_ID;\n", "    verdict = policy_sk_egress (dst_id, key.sip4, (__u16) key.dport);\n", "    if (verdict >= 0)\n", "        msg_redirect_hash (msg, &SOCK_OPS_MAP, &key, flags);\n", "    return SK_PASS;\n", "}\n"], "called_function_list": ["policy_sk_egress", "sk_msg_extract4_key"], "call_depth": 2, "humanFuncDescription": [{"description": " Store infomations about destination id, dport and sport ip4 into message, flag set to be BPF_F_INGRESS ", "author": "Shun Zhang", "authorEmail": "shunz@bu.edu", "date": "2023-02-24"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "custom_hook": [{"capabilities": [], "helperCallParams": {}, "startLine": 32, "endLine": 45, "File": "/home/sayandes/opened_extraction/examples/cilium/custom/bpf_custom.c", "funcName": "custom_hook", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct  __ctx_buff *ctx"], "output": "int", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["int custom_hook (const struct  __ctx_buff *ctx)\n", "{\n", "    __u32 custom_meta = ctx_load_meta (ctx, CB_CUSTOM_CALLS);\n", "    __u32 identity = custom_meta & 0xffffff;\n", "    int ret = (custom_meta >> 24) & 0xff;\n", "    custom_prog (ctx, identity);\n", "    return ret;\n", "}\n"], "called_function_list": ["custom_prog", "ctx_load_meta"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "l4_modify_port": [{"capabilities": [], "helperCallParams": {}, "startLine": 36, "endLine": 47, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/l4.h", "funcName": "l4_modify_port", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " int l4_off", " int off", " struct csum_offset *csum_off", " __be16 port", " __be16 old_port"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int l4_modify_port (struct  __ctx_buff *ctx, int l4_off, int off, struct csum_offset *csum_off, __be16 port, __be16 old_port)\n", "{\n", "    if (csum_l4_replace (ctx, l4_off, csum_off, old_port, port, sizeof (port)) < 0)\n", "        return DROP_CSUM_L4;\n", "    if (ctx_store_bytes (ctx, l4_off + off, &port, sizeof (port), 0) < 0)\n", "        return DROP_WRITE_ERROR;\n", "    return 0;\n", "}\n"], "called_function_list": ["csum_l4_replace"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "l4_load_port": [{"capabilities": [], "helperCallParams": {}, "startLine": 49, "endLine": 53, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/l4.h", "funcName": "l4_load_port", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " int off", " __be16 *port"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int l4_load_port (struct  __ctx_buff *ctx, int off, __be16 *port)\n", "{\n", "    return ctx_load_bytes (ctx, off, port, sizeof (__be16));\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "cilium_capture": [{"capabilities": [], "helperCallParams": {}, "startLine": 48, "endLine": 75, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/pcap.h", "funcName": "cilium_capture", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " const __u8 subtype", " const __u16 rule_id", " const __u64 tstamp", " __u64  __cap_len"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void cilium_capture (struct  __ctx_buff *ctx, const __u8 subtype, const __u16 rule_id, const __u64 tstamp, __u64  __cap_len)\n", "{\n", "    __u64 ctx_len = ctx_full_len (ctx);\n", "    __u64 cap_len = (!__cap_len || ctx_len < __cap_len) ? ctx_len : __cap_len;\n", "    struct capture_msg msg = {\n", "        .type = CILIUM_NOTIFY_CAPTURE,\n", "        .subtype = subtype,\n", "        .source = rule_id,\n", "        .hdr = {\n", "            .to = {\n", "                .tv_boot = tstamp,},\n", "            .caplen = cap_len,\n", "            .len = ctx_len,},}\n", "    ;\n", "    ctx_event_output (ctx, &EVENTS_MAP, (cap_len << 32) | BPF_F_CURRENT_CPU, &msg, sizeof (msg));\n", "}\n"], "called_function_list": ["ctx_full_len"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__cilium_capture_in": [{"capabilities": [], "helperCallParams": {}, "startLine": 77, "endLine": 86, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/pcap.h", "funcName": "__cilium_capture_in", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " __u16 rule_id", " __u32 cap_len"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void __cilium_capture_in (struct  __ctx_buff *ctx, __u16 rule_id, __u32 cap_len)\n", "{\n", "    cilium_capture (ctx, CAPTURE_INGRESS, rule_id, bpf_ktime_cache_set (boot_ns), cap_len);\n", "}\n"], "called_function_list": ["cilium_capture"], "call_depth": 3, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__cilium_capture_out": [{"capabilities": [], "helperCallParams": {}, "startLine": 88, "endLine": 93, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/pcap.h", "funcName": "__cilium_capture_out", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " __u16 rule_id", " __u32 cap_len"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void __cilium_capture_out (struct  __ctx_buff *ctx, __u16 rule_id, __u32 cap_len)\n", "{\n", "    cilium_capture (ctx, CAPTURE_EGRESS, rule_id, bpf_ktime_cache_get (), cap_len);\n", "}\n"], "called_function_list": ["cilium_capture"], "call_depth": 3, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "cilium_capture4_masked_key": [{"capabilities": [], "helperCallParams": {}, "startLine": 158, "endLine": 170, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/pcap.h", "funcName": "cilium_capture4_masked_key", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct capture4_wcard *orig", " const struct capture4_wcard *mask", " struct capture4_wcard *out"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void cilium_capture4_masked_key (const struct capture4_wcard *orig, const struct capture4_wcard *mask, struct capture4_wcard *out)\n", "{\n", "    out->daddr = orig->daddr & mask->daddr;\n", "    out->saddr = orig->saddr & mask->saddr;\n", "    out->dport = orig->dport & mask->dport;\n", "    out->sport = orig->sport & mask->sport;\n", "    out->nexthdr = orig->nexthdr & mask->nexthdr;\n", "    out->dmask = mask->dmask;\n", "    out->smask = mask->smask;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "cilium_capture4_classify_wcard": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 217, "endLine": 257, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/pcap.h", "funcName": "cilium_capture4_classify_wcard", "developer_inline_comments": [], "updateMaps": [], "readMaps": ["  CAPTURE4_RULES"], "input": ["struct  __ctx_buff *ctx"], "output": "static__always_inlinestructcapture_rule", "helper": ["map_lookup_elem"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline struct capture_rule *cilium_capture4_classify_wcard (struct  __ctx_buff *ctx)\n", "{\n", "    struct capture4_wcard prefix_masks [] = {PREFIX_MASKS4};\n", "    struct capture4_wcard okey, lkey;\n", "    struct capture_rule *match;\n", "    void *data, *data_end;\n", "    struct iphdr *ip4;\n", "    int i;\n", "    const int size = sizeof (prefix_masks) / sizeof (prefix_masks [0]);\n", "    if (!revalidate_data (ctx, &data, &data_end, &ip4))\n", "        return NULL;\n", "    okey.daddr = ip4->daddr;\n", "    okey.dmask = 32;\n", "    okey.saddr = ip4->saddr;\n", "    okey.smask = 32;\n", "    okey.nexthdr = ip4->protocol;\n", "    if (ip4->protocol != IPPROTO_TCP && ip4->protocol != IPPROTO_UDP)\n", "        return NULL;\n", "    if (ctx_load_bytes (ctx, ETH_HLEN + ipv4_hdrlen (ip4), &okey.sport, 4) < 0)\n", "        return NULL;\n", "    okey.flags = 0;\n", "    lkey.flags = 0;\n", "    _Pragma (\"unroll\")\n", "    for (i = 0; i < size; i++) {\n", "        cilium_capture4_masked_key (&okey, &prefix_masks[i], &lkey);\n", "        match = map_lookup_elem (& CAPTURE4_RULES, & lkey);\n", "        if (match)\n", "            return match;\n", "    }\n", "    return NULL;\n", "}\n"], "called_function_list": ["cilium_capture4_masked_key", "ipv4_hdrlen"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "cilium_capture6_masked_key": [{"capabilities": [], "helperCallParams": {}, "startLine": 270, "endLine": 284, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/pcap.h", "funcName": "cilium_capture6_masked_key", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct capture6_wcard *orig", " const struct capture6_wcard *mask", " struct capture6_wcard *out"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void cilium_capture6_masked_key (const struct capture6_wcard *orig, const struct capture6_wcard *mask, struct capture6_wcard *out)\n", "{\n", "    out->daddr.d1 = orig->daddr.d1 & mask->daddr.d1;\n", "    out->daddr.d2 = orig->daddr.d2 & mask->daddr.d2;\n", "    out->saddr.d1 = orig->saddr.d1 & mask->saddr.d1;\n", "    out->saddr.d2 = orig->saddr.d2 & mask->saddr.d2;\n", "    out->dport = orig->dport & mask->dport;\n", "    out->sport = orig->sport & mask->sport;\n", "    out->nexthdr = orig->nexthdr & mask->nexthdr;\n", "    out->dmask = mask->dmask;\n", "    out->smask = mask->smask;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "cilium_capture6_classify_wcard": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 339, "endLine": 382, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/pcap.h", "funcName": "cilium_capture6_classify_wcard", "developer_inline_comments": [], "updateMaps": [], "readMaps": ["  CAPTURE6_RULES"], "input": ["struct  __ctx_buff *ctx"], "output": "static__always_inlinestructcapture_rule", "helper": ["map_lookup_elem"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline struct capture_rule *cilium_capture6_classify_wcard (struct  __ctx_buff *ctx)\n", "{\n", "    struct capture6_wcard prefix_masks [] = {PREFIX_MASKS6};\n", "    struct capture6_wcard okey, lkey;\n", "    struct capture_rule *match;\n", "    void *data, *data_end;\n", "    struct ipv6hdr *ip6;\n", "    int i, ret, l3_off = ETH_HLEN;\n", "    const int size = sizeof (prefix_masks) / sizeof (prefix_masks [0]);\n", "    if (!revalidate_data (ctx, &data, &data_end, &ip6))\n", "        return NULL;\n", "    ipv6_addr_copy (&okey.daddr, (union v6addr *) &ip6->daddr);\n", "    okey.dmask = 128;\n", "    ipv6_addr_copy (&okey.saddr, (union v6addr *) &ip6->saddr);\n", "    okey.smask = 128;\n", "    okey.nexthdr = ip6->nexthdr;\n", "    ret = ipv6_hdrlen (ctx, & okey.nexthdr);\n", "    if (ret < 0)\n", "        return NULL;\n", "    if (okey.nexthdr != IPPROTO_TCP && okey.nexthdr != IPPROTO_UDP)\n", "        return NULL;\n", "    if (ctx_load_bytes (ctx, l3_off + ret, &okey.sport, 4) < 0)\n", "        return NULL;\n", "    okey.flags = 0;\n", "    lkey.flags = 0;\n", "    _Pragma (\"unroll\")\n", "    for (i = 0; i < size; i++) {\n", "        cilium_capture6_masked_key (&okey, &prefix_masks[i], &lkey);\n", "        match = map_lookup_elem (& CAPTURE6_RULES, & lkey);\n", "        if (match)\n", "            return match;\n", "    }\n", "    return NULL;\n", "}\n"], "called_function_list": ["cilium_capture6_masked_key", "ipv6_hdrlen", "ipv6_addr_copy"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "cilium_capture_classify_wcard": [{"capabilities": [], "helperCallParams": {}, "startLine": 385, "endLine": 408, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/pcap.h", "funcName": "cilium_capture_classify_wcard", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx"], "output": "static__always_inlinestructcapture_rule", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline struct capture_rule *cilium_capture_classify_wcard (struct  __ctx_buff *ctx)\n", "{\n", "    struct capture_rule *ret = NULL;\n", "    __u16 proto;\n", "    if (!validate_ethertype (ctx, &proto))\n", "        return ret;\n", "    switch (proto) {\n", "\n", "#ifdef ENABLE_IPV4\n", "    case bpf_htons (ETH_P_IP) :\n", "        ret = cilium_capture4_classify_wcard (ctx);\n", "        break;\n", "\n", "#endif\n", "\n", "#ifdef ENABLE_IPV6\n", "    case bpf_htons (ETH_P_IPV6) :\n", "        ret = cilium_capture6_classify_wcard (ctx);\n", "        break;\n", "\n", "#endif\n", "    default :\n", "        break;\n", "    }\n", "    return ret;\n", "}\n"], "called_function_list": ["validate_ethertype", "cilium_capture6_classify_wcard", "cilium_capture4_classify_wcard"], "call_depth": 3, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "cilium_capture_candidate": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 410, "endLine": 432, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/pcap.h", "funcName": "cilium_capture_candidate", "developer_inline_comments": [], "updateMaps": [], "readMaps": ["  cilium_capture_cache"], "input": ["struct  __ctx_buff * ctx __maybe_unused", " __u16 * rule_id __maybe_unused", " __u16 * cap_len __maybe_unused"], "output": "static__always_inlinebool", "helper": ["map_lookup_elem"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline bool cilium_capture_candidate (struct  __ctx_buff * ctx __maybe_unused, __u16 * rule_id __maybe_unused, __u16 * cap_len __maybe_unused)\n", "{\n", "    if (capture_enabled) {\n", "        struct capture_cache *c;\n", "        struct capture_rule *r;\n", "        __u32 zero = 0;\n", "        c = map_lookup_elem (& cilium_capture_cache, & zero);\n", "        if (always_succeeds (c)) {\n", "            r = cilium_capture_classify_wcard (ctx);\n", "            c->rule_seen = r;\n", "            if (r) {\n", "                c->cap_len = *cap_len = (__u16) r->cap_len;\n", "                c->rule_id = *rule_id = r->rule_id;\n", "                return true;\n", "            }\n", "        }\n", "    }\n", "    return false;\n", "}\n"], "called_function_list": ["cilium_capture_classify_wcard"], "call_depth": 4, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "cilium_capture_cached": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 434, "endLine": 455, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/pcap.h", "funcName": "cilium_capture_cached", "developer_inline_comments": [], "updateMaps": [], "readMaps": ["  cilium_capture_cache"], "input": ["struct  __ctx_buff * ctx __maybe_unused", " __u16 * rule_id __maybe_unused", " __u32 * cap_len __maybe_unused"], "output": "static__always_inlinebool", "helper": ["map_lookup_elem"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline bool cilium_capture_cached (struct  __ctx_buff * ctx __maybe_unused, __u16 * rule_id __maybe_unused, __u32 * cap_len __maybe_unused)\n", "{\n", "    if (capture_enabled) {\n", "        struct capture_cache *c;\n", "        __u32 zero = 0;\n", "        c = map_lookup_elem (& cilium_capture_cache, & zero);\n", "        if (always_succeeds (c) && c->rule_seen) {\n", "            *cap_len = c->cap_len;\n", "            *rule_id = c->rule_id;\n", "            return true;\n", "        }\n", "    }\n", "    return false;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "cilium_capture_in": [{"capabilities": [], "helperCallParams": {}, "startLine": 457, "endLine": 465, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/pcap.h", "funcName": "cilium_capture_in", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff * ctx __maybe_unused"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void cilium_capture_in (struct  __ctx_buff * ctx __maybe_unused)\n", "{\n", "    __u16 cap_len;\n", "    __u16 rule_id;\n", "    if (cilium_capture_candidate (ctx, &rule_id, &cap_len))\n", "        __cilium_capture_in (ctx, rule_id, cap_len);\n", "}\n"], "called_function_list": ["__cilium_capture_in", "cilium_capture_candidate"], "call_depth": 4, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 483, "endLine": 486, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/pcap.h", "funcName": "cilium_capture_in", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff * ctx __maybe_unused"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void cilium_capture_in (struct  __ctx_buff * ctx __maybe_unused)\n", "{\n", "}\n"], "called_function_list": ["__cilium_capture_in", "cilium_capture_candidate"], "call_depth": 4, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "cilium_capture_out": [{"capabilities": [], "helperCallParams": {}, "startLine": 467, "endLine": 479, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/pcap.h", "funcName": "cilium_capture_out", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff * ctx __maybe_unused"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void cilium_capture_out (struct  __ctx_buff * ctx __maybe_unused)\n", "{\n", "    __u32 cap_len;\n", "    __u16 rule_id;\n", "    if (cilium_capture_cached (ctx, &rule_id, &cap_len))\n", "        __cilium_capture_out (ctx, rule_id, cap_len);\n", "}\n"], "called_function_list": ["__cilium_capture_out", "cilium_capture_cached"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 488, "endLine": 491, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/pcap.h", "funcName": "cilium_capture_out", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff * ctx __maybe_unused"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void cilium_capture_out (struct  __ctx_buff * ctx __maybe_unused)\n", "{\n", "}\n"], "called_function_list": ["__cilium_capture_out", "cilium_capture_cached"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "hash_from_tuple_v4": [{"capabilities": [], "helperCallParams": {}, "startLine": 13, "endLine": 18, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/hash.h", "funcName": "hash_from_tuple_v4", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct ipv4_ct_tuple *tuple"], "output": "static__always_inline__u32", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __u32 hash_from_tuple_v4 (const struct ipv4_ct_tuple *tuple)\n", "{\n", "    return jhash_3words (tuple->saddr, ((__u32) tuple->dport << 16) | tuple->sport, tuple->nexthdr, HASH_INIT4_SEED);\n", "}\n"], "called_function_list": ["jhash_3words"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "hash_from_tuple_v6": [{"capabilities": [], "helperCallParams": {}, "startLine": 20, "endLine": 35, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/hash.h", "funcName": "hash_from_tuple_v6", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct ipv6_ct_tuple *tuple"], "output": "static__always_inline__u32", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __u32 hash_from_tuple_v6 (const struct ipv6_ct_tuple *tuple)\n", "{\n", "    __u32 a, b, c;\n", "    a = tuple->saddr.p1;\n", "    b = tuple->saddr.p2;\n", "    c = tuple->saddr.p3;\n", "    __jhash_mix (a, b, c);\n", "    a += tuple->saddr.p4;\n", "    b += ((__u32) tuple->dport << 16) | tuple->sport;\n", "    c += tuple->nexthdr;\n", "    __jhash_mix (a, b, c);\n", "    a += HASH_INIT6_SEED;\n", "    __jhash_final (a, b, c);\n", "    return c;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "get_ct_map6": [{"capabilities": [], "helperCallParams": {}, "startLine": 40, "endLine": 47, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack_map.h", "funcName": "get_ct_map6", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct ipv6_ct_tuple *tuple"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void *get_ct_map6 (const struct ipv6_ct_tuple *tuple)\n", "{\n", "    if (tuple->nexthdr == IPPROTO_TCP)\n", "        return &CT_MAP_TCP6;\n", "    return &CT_MAP_ANY6;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "get_ct_map4": [{"capabilities": [], "helperCallParams": {}, "startLine": 73, "endLine": 80, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack_map.h", "funcName": "get_ct_map4", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct ipv4_ct_tuple *tuple"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void *get_ct_map4 (const struct ipv4_ct_tuple *tuple)\n", "{\n", "    if (tuple->nexthdr == IPPROTO_TCP)\n", "        return &CT_MAP_TCP4;\n", "    return &CT_MAP_ANY4;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "lookup_ip4_egress_gw_policy": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 20, "endLine": 29, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/egress_policies.h", "funcName": "lookup_ip4_egress_gw_policy", "developer_inline_comments": [], "updateMaps": [], "readMaps": [" EGRESS_POLICY_MAP"], "input": ["__be32 saddr", " __be32 daddr"], "output": "static__always_inlinestructegress_gw_policy_entry", "helper": ["map_lookup_elem"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline struct egress_gw_policy_entry *lookup_ip4_egress_gw_policy (__be32 saddr, __be32 daddr)\n", "{\n", "    struct egress_gw_policy_key key = {\n", "        .lpm_key = {EGRESS_IPV4_PREFIX,\n", "            {}},\n", "        .saddr = saddr,\n", "        .daddr = daddr,}\n", "    ;\n", "    return map_lookup_elem (&EGRESS_POLICY_MAP, &key);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "srv6_lookup_vrf4": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 44, "endLine": 53, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/egress_policies.h", "funcName": "srv6_lookup_vrf4", "developer_inline_comments": [], "updateMaps": [], "readMaps": [" SRV6_VRF_MAP4"], "input": ["__be32 sip", " __be32 dip"], "output": "static__always_inline__u32", "helper": ["map_lookup_elem"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __u32 *srv6_lookup_vrf4 (__be32 sip, __be32 dip)\n", "{\n", "    struct srv6_vrf_key4 key = {\n", "        .lpm = {SRV6_VRF_IPV4_PREFIX,\n", "            {}},\n", "        .src_ip = sip,\n", "        .dst_cidr = dip,}\n", "    ;\n", "    return map_lookup_elem (&SRV6_VRF_MAP4, &key);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "srv6_lookup_policy4": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 63, "endLine": 72, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/egress_policies.h", "funcName": "srv6_lookup_policy4", "developer_inline_comments": [], "updateMaps": [], "readMaps": [" SRV6_POLICY_MAP4"], "input": ["__u32 vrf_id", " __be32 dip"], "output": "static__always_inlineunionv6addr", "helper": ["map_lookup_elem"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline union v6addr *srv6_lookup_policy4 (__u32 vrf_id, __be32 dip)\n", "{\n", "    struct srv6_policy_key4 key = {\n", "        .lpm = {SRV6_POLICY_IPV4_PREFIX,\n", "            {}},\n", "        .vrf_id = vrf_id,\n", "        .dst_cidr = dip,}\n", "    ;\n", "    return map_lookup_elem (&SRV6_POLICY_MAP4, &key);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "srv6_lookup_vrf6": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 83, "endLine": 92, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/egress_policies.h", "funcName": "srv6_lookup_vrf6", "developer_inline_comments": [], "updateMaps": [], "readMaps": [" SRV6_VRF_MAP6"], "input": ["const struct in6_addr *sip", " const struct in6_addr *dip"], "output": "static__always_inline__u32", "helper": ["map_lookup_elem"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __u32 *srv6_lookup_vrf6 (const struct in6_addr *sip, const struct in6_addr *dip)\n", "{\n", "    struct srv6_vrf_key6 key = {\n", "        .lpm = {SRV6_VRF_IPV6_PREFIX,\n", "            {}},\n", "        .src_ip = *(unionv6addr*) sip,\n", "        .dst_cidr = *(unionv6addr*) dip,}\n", "    ;\n", "    return map_lookup_elem (&SRV6_VRF_MAP6, &key);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "srv6_lookup_policy6": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 103, "endLine": 112, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/egress_policies.h", "funcName": "srv6_lookup_policy6", "developer_inline_comments": [], "updateMaps": [], "readMaps": [" SRV6_POLICY_MAP6"], "input": ["__u32 vrf_id", " const struct in6_addr *dip"], "output": "static__always_inlineunionv6addr", "helper": ["map_lookup_elem"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline union v6addr *srv6_lookup_policy6 (__u32 vrf_id, const struct in6_addr *dip)\n", "{\n", "    struct srv6_policy_key6 key = {\n", "        .lpm = {SRV6_POLICY_IPV6_PREFIX,\n", "            {}},\n", "        .vrf_id = vrf_id,\n", "        .dst_cidr = *(unionv6addr*) dip,}\n", "    ;\n", "    return map_lookup_elem (&SRV6_POLICY_MAP6, &key);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "srv6_lookup_sid": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 114, "endLine": 123, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/egress_policies.h", "funcName": "srv6_lookup_sid", "developer_inline_comments": [], "updateMaps": [], "readMaps": ["  SRV6_SID_MAP"], "input": ["const struct in6_addr *sid"], "output": "static__always_inline__u32", "helper": ["map_lookup_elem"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __u32 srv6_lookup_sid (const struct in6_addr *sid)\n", "{\n", "    __u32 *vrf_id;\n", "    vrf_id = map_lookup_elem (& SRV6_SID_MAP, sid);\n", "    if (vrf_id)\n", "        return *vrf_id;\n", "    return 0;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "is_srv6_packet": [{"capabilities": [], "helperCallParams": {}, "startLine": 125, "endLine": 134, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/egress_policies.h", "funcName": "is_srv6_packet", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct ipv6hdr *ip6"], "output": "static__always_inlinebool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline bool is_srv6_packet (const struct ipv6hdr *ip6)\n", "{\n", "\n", "#ifndef ENABLE_SRV6_REDUCED_ENCAP\n", "    if (ip6->nexthdr == NEXTHDR_ROUTING)\n", "        return true;\n", "\n", "#endif\n", "    return ip6->nexthdr == IPPROTO_IPIP || ip6->nexthdr == IPPROTO_IPV6;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ctx_adjust_hroom_flags": [{"capabilities": [], "helperCallParams": {}, "startLine": 137, "endLine": 144, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/egress_policies.h", "funcName": "ctx_adjust_hroom_flags", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["void"], "output": "static__always_inline__u64", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __u64 ctx_adjust_hroom_flags (void)\n", "{\n", "\n", "#ifdef BPF_HAVE_CSUM_LEVEL\n", "    return BPF_F_ADJ_ROOM_NO_CSUM_RESET;\n", "\n", "#else\n", "    return 0;\n", "\n", "#endif\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "srv6_encapsulation": [{"capabilities": [], "helperCallParams": {}, "startLine": 146, "endLine": 171, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/egress_policies.h", "funcName": "srv6_encapsulation", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " int growth", " __u16 new_payload_len", " __u8 nexthdr", " union v6addr *saddr", " struct in6_addr *sid"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int srv6_encapsulation (struct  __ctx_buff *ctx, int growth, __u16 new_payload_len, __u8 nexthdr, union v6addr *saddr, struct in6_addr *sid)\n", "{\n", "    __u32 len = sizeof (struct ipv6hdr) - 2 * sizeof (struct in6_addr);\n", "    struct ipv6hdr new_ip6 = {\n", "        .version = 0x6,\n", "        .payload_len = bpf_htons (new_payload_len),\n", "        .nexthdr = nexthdr,\n", "        .hop_limit = IPDEFTTL,}\n", "    ;\n", "    if (ctx_adjust_hroom (ctx, growth, BPF_ADJ_ROOM_MAC, ctx_adjust_hroom_flags ()))\n", "        return DROP_INVALID;\n", "    if (ctx_store_bytes (ctx, ETH_HLEN, &new_ip6, len, 0) < 0)\n", "        return DROP_WRITE_ERROR;\n", "    if (ctx_store_bytes (ctx, ETH_HLEN + offsetof (struct ipv6hdr, saddr), saddr, sizeof (union v6addr), 0) < 0)\n", "        return DROP_WRITE_ERROR;\n", "    if (ctx_store_bytes (ctx, ETH_HLEN + offsetof (struct ipv6hdr, daddr), sid, sizeof (struct in6_addr), 0) < 0)\n", "        return DROP_WRITE_ERROR;\n", "    return 0;\n", "}\n"], "called_function_list": ["ctx_adjust_hroom_flags", "ctx_adjust_hroom"], "call_depth": 3, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "srv6_decapsulation": [{"capabilities": [], "helperCallParams": {}, "startLine": 173, "endLine": 210, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/egress_policies.h", "funcName": "srv6_decapsulation", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int srv6_decapsulation (struct  __ctx_buff *ctx)\n", "{\n", "    __u16 new_proto = bpf_htons (ETH_P_IP);\n", "    void *data, *data_end;\n", "    struct ipv6hdr *ip6;\n", "    int shrink;\n", "    if (!revalidate_data (ctx, &data, &data_end, &ip6))\n", "        return DROP_INVALID;\n", "    switch (ip6->nexthdr) {\n", "    case IPPROTO_IPIP :\n", "        if (ctx_change_proto (ctx, new_proto, 0) < 0)\n", "            return DROP_WRITE_ERROR;\n", "        if (ctx_store_bytes (ctx, offsetof (struct ethhdr, h_proto), &new_proto, sizeof (new_proto), 0) < 0)\n", "            return DROP_WRITE_ERROR;\n", "        shrink = sizeof (struct iphdr);\n", "        break;\n", "    case IPPROTO_IPV6 :\n", "        shrink = sizeof (struct ipv6hdr);\n", "        break;\n", "    default :\n", "        return DROP_INVALID;\n", "    }\n", "    if (ctx_adjust_hroom (ctx, -shrink, BPF_ADJ_ROOM_MAC, ctx_adjust_hroom_flags ()))\n", "        return DROP_INVALID;\n", "    return 0;\n", "}\n"], "called_function_list": ["ctx_change_proto", "ctx_adjust_hroom_flags", "ctx_adjust_hroom"], "call_depth": 3, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "srv6_create_state_entry": [{"capabilities": [], "helperCallParams": {}, "startLine": 212, "endLine": 252, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/egress_policies.h", "funcName": "srv6_create_state_entry", "developer_inline_comments": [], "updateMaps": [" SRV6_STATE_MAP6", " SRV6_STATE_MAP4"], "readMaps": [], "input": ["struct  __ctx_buff *ctx"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int srv6_create_state_entry (struct  __ctx_buff *ctx)\n", "{\n", "    struct srv6_ipv6_2tuple *outer_ips;\n", "    void *data, *data_end;\n", "    struct ipv6hdr *ip6;\n", "    if (!revalidate_data (ctx, &data, &data_end, &ip6))\n", "        return DROP_INVALID;\n", "    outer_ips = (struct srv6_ipv6_2tuple *) &ip6->saddr;\n", "    switch (ip6->nexthdr) {\n", "    case IPPROTO_IPV6 :\n", "        {\n", "            struct ipv6hdr *inner = ip6 + 1;\n", "            struct srv6_ipv6_2tuple *inner_ips;\n", "            if ((void *) inner + sizeof (*inner) > data_end)\n", "                return DROP_INVALID;\n", "            inner_ips = (struct srv6_ipv6_2tuple *) &inner->saddr;\n", "            if (map_update_elem (&SRV6_STATE_MAP6, inner_ips, outer_ips, 0) < 0)\n", "                return DROP_INVALID;\n", "        }\n", "\n", "#  ifdef ENABLE_IPV4\n", "    case IPPROTO_IPIP :\n", "        {\n", "            struct iphdr *inner = (struct iphdr *) (ip6 + 1);\n", "            struct srv6_ipv4_2tuple *inner_ips;\n", "            if ((void *) inner + sizeof (*inner) > data_end)\n", "                return DROP_INVALID;\n", "            inner_ips = (struct srv6_ipv4_2tuple *) &inner->saddr;\n", "            if (map_update_elem (&SRV6_STATE_MAP4, inner_ips, outer_ips, 0) < 0)\n", "                return DROP_INVALID;\n", "        }\n", "\n", "#  endif /* ENABLE_IPV4 */\n", "    }\n", "    return 0;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "srv6_lookup_state_entry4": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 255, "endLine": 260, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/egress_policies.h", "funcName": "srv6_lookup_state_entry4", "developer_inline_comments": [], "updateMaps": [], "readMaps": [" SRV6_STATE_MAP4"], "input": ["struct iphdr *ip4"], "output": "static__always_inlinestructsrv6_ipv6_2tuple", "helper": ["map_lookup_elem"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline struct srv6_ipv6_2tuple *srv6_lookup_state_entry4 (struct iphdr *ip4)\n", "{\n", "    return map_lookup_elem (&SRV6_STATE_MAP4, (struct srv6_ipv4_2tuple *) &ip4->saddr);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "srv6_lookup_state_entry6": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 263, "endLine": 268, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/egress_policies.h", "funcName": "srv6_lookup_state_entry6", "developer_inline_comments": [], "updateMaps": [], "readMaps": [" SRV6_STATE_MAP6"], "input": ["struct ipv6hdr *ip6"], "output": "static__always_inlinestructsrv6_ipv6_2tuple", "helper": ["map_lookup_elem"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline struct srv6_ipv6_2tuple *srv6_lookup_state_entry6 (struct ipv6hdr *ip6)\n", "{\n", "    return map_lookup_elem (&SRV6_STATE_MAP6, (struct srv6_ipv6_2tuple *) &ip6->saddr);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "srv6_handling4": [{"capabilities": [], "helperCallParams": {}, "startLine": 270, "endLine": 310, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/egress_policies.h", "funcName": "srv6_handling4", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " union v6addr *src_sid", " struct in6_addr *dst_sid"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int srv6_handling4 (struct  __ctx_buff *ctx, union v6addr *src_sid, struct in6_addr *dst_sid)\n", "{\n", "    __u16 new_payload_len, outer_proto = bpf_htons (ETH_P_IPV6);\n", "    void *data, *data_end;\n", "    struct iphdr *ip4;\n", "    __u8 nexthdr;\n", "    int growth;\n", "    if (!revalidate_data (ctx, &data, &data_end, &ip4))\n", "        return DROP_INVALID;\n", "    nexthdr = IPPROTO_IPIP;\n", "    new_payload_len = bpf_ntohs (ip4->tot_len) - (__u16) (ip4->ihl << 2) + sizeof (struct iphdr);\n", "    if (ctx_change_proto (ctx, outer_proto, 0) < 0)\n", "        return DROP_WRITE_ERROR;\n", "    if (ctx_store_bytes (ctx, offsetof (struct ethhdr, h_proto), &outer_proto, sizeof (outer_proto), 0) < 0)\n", "        return DROP_WRITE_ERROR;\n", "    growth = sizeof (struct iphdr);\n", "    return srv6_encapsulation (ctx, growth, new_payload_len, nexthdr, src_sid, dst_sid);\n", "}\n"], "called_function_list": ["ctx_change_proto", "srv6_encapsulation"], "call_depth": 4, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "srv6_handling6": [{"capabilities": [], "helperCallParams": {}, "startLine": 312, "endLine": 331, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/egress_policies.h", "funcName": "srv6_handling6", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " union v6addr *src_sid", " struct in6_addr *dst_sid"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int srv6_handling6 (struct  __ctx_buff *ctx, union v6addr *src_sid, struct in6_addr *dst_sid)\n", "{\n", "    __u16 new_payload_len;\n", "    void *data, *data_end;\n", "    struct ipv6hdr *ip6;\n", "    __u8 nexthdr;\n", "    int growth;\n", "    if (!revalidate_data (ctx, &data, &data_end, &ip6))\n", "        return DROP_INVALID;\n", "    nexthdr = IPPROTO_IPV6;\n", "    new_payload_len = bpf_ntohs (ip6->payload_len) + sizeof (struct ipv6hdr);\n", "    growth = sizeof (struct ipv6hdr);\n", "    return srv6_encapsulation (ctx, growth, new_payload_len, nexthdr, src_sid, dst_sid);\n", "}\n"], "called_function_list": ["srv6_encapsulation"], "call_depth": 4, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "srv6_handling": [{"capabilities": [], "helperCallParams": {}, "startLine": 333, "endLine": 373, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/egress_policies.h", "funcName": "srv6_handling", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " __u32 vrf_id", " struct in6_addr *dst_sid"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int srv6_handling (struct  __ctx_buff *ctx, __u32 vrf_id, struct in6_addr *dst_sid)\n", "{\n", "    union v6addr *src_sid;\n", "    void *data, *data_end;\n", "    __u16 inner_proto;\n", "    if (!validate_ethertype (ctx, &inner_proto))\n", "        return DROP_UNSUPPORTED_L2;\n", "    switch (inner_proto) {\n", "\n", "#  ifdef ENABLE_IPV6\n", "    case bpf_htons (ETH_P_IPV6) :\n", "        {\n", "            struct ipv6hdr *ip6;\n", "            if (!revalidate_data (ctx, &data, &data_end, &ip6))\n", "                return DROP_INVALID;\n", "            src_sid = srv6_lookup_policy6 (vrf_id, & ip6 -> saddr);\n", "            if (!src_sid)\n", "                return DROP_NO_SID;\n", "            return srv6_handling6 (ctx, src_sid, dst_sid);\n", "        }\n", "\n", "#  endif /* ENABLE_IPV6 */\n", "\n", "#  ifdef ENABLE_IPV4\n", "    case bpf_htons (ETH_P_IP) :\n", "        {\n", "            struct iphdr *ip4;\n", "            if (!revalidate_data (ctx, &data, &data_end, &ip4))\n", "                return DROP_INVALID;\n", "            src_sid = srv6_lookup_policy4 (vrf_id, ip4 -> saddr);\n", "            if (!src_sid)\n", "                return DROP_NO_SID;\n", "            return srv6_handling4 (ctx, src_sid, dst_sid);\n", "        }\n", "\n", "#  endif /* ENABLE_IPV4 */\n", "    default :\n", "        return DROP_INVALID;\n", "    }\n", "}\n"], "called_function_list": ["srv6_lookup_policy4", "srv6_lookup_policy6", "validate_ethertype", "srv6_handling4", "srv6_handling6"], "call_depth": 5, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "srv6_reply": [{"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 375, "endLine": 413, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/egress_policies.h", "funcName": "srv6_reply", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx"], "output": "static__always_inlineint", "helper": ["CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["static __always_inline int srv6_reply (struct  __ctx_buff *ctx)\n", "{\n", "    struct srv6_ipv6_2tuple *outer_ips;\n", "    struct iphdr * ip4 __maybe_unused;\n", "    void *data, *data_end;\n", "    struct ipv6hdr *ip6;\n", "    __u16 proto;\n", "    if (!validate_ethertype (ctx, &proto))\n", "        return DROP_UNSUPPORTED_L2;\n", "    switch (proto) {\n", "    case bpf_htons (ETH_P_IPV6) :\n", "        if (!revalidate_data (ctx, &data, &data_end, &ip6))\n", "            return DROP_INVALID;\n", "        outer_ips = srv6_lookup_state_entry6 (ip6);\n", "        if (!outer_ips)\n", "            return DROP_MISSING_SRV6_STATE;\n", "        return srv6_handling6 (ctx, &outer_ips->src, (struct in6_addr *) &outer_ips->dst);\n", "\n", "#  ifdef ENABLE_IPV4\n", "    case bpf_htons (ETH_P_IP) :\n", "        if (!revalidate_data (ctx, &data, &data_end, &ip4))\n", "            return DROP_INVALID;\n", "        outer_ips = srv6_lookup_state_entry4 (ip4);\n", "        if (!outer_ips)\n", "            return DROP_MISSING_SRV6_STATE;\n", "        return srv6_handling4 (ctx, &outer_ips->src, (struct in6_addr *) &outer_ips->dst);\n", "\n", "#  endif /* ENABLE_IPV4 */\n", "    }\n", "    return CTX_ACT_OK;\n", "}\n"], "called_function_list": ["srv6_lookup_state_entry4", "validate_ethertype", "srv6_handling4", "srv6_lookup_state_entry6", "srv6_handling6"], "call_depth": 5, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "srv6_load_meta_sid": [{"capabilities": [], "helperCallParams": {}, "startLine": 415, "endLine": 422, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/egress_policies.h", "funcName": "srv6_load_meta_sid", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " struct in6_addr *sid"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void srv6_load_meta_sid (struct  __ctx_buff *ctx, struct in6_addr *sid)\n", "{\n", "    sid->s6_addr32[0] = ctx_load_meta (ctx, CB_SRV6_SID_1);\n", "    sid->s6_addr32[1] = ctx_load_meta (ctx, CB_SRV6_SID_2);\n", "    sid->s6_addr32[2] = ctx_load_meta (ctx, CB_SRV6_SID_3);\n", "    sid->s6_addr32[3] = ctx_load_meta (ctx, CB_SRV6_SID_4);\n", "}\n"], "called_function_list": ["ctx_load_meta"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "srv6_store_meta_sid": [{"capabilities": [], "helperCallParams": {}, "startLine": 424, "endLine": 431, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/egress_policies.h", "funcName": "srv6_store_meta_sid", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " const union v6addr *sid"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void srv6_store_meta_sid (struct  __ctx_buff *ctx, const union v6addr *sid)\n", "{\n", "    ctx_store_meta (ctx, CB_SRV6_SID_1, sid->p1);\n", "    ctx_store_meta (ctx, CB_SRV6_SID_2, sid->p2);\n", "    ctx_store_meta (ctx, CB_SRV6_SID_3, sid->p3);\n", "    ctx_store_meta (ctx, CB_SRV6_SID_4, sid->p4);\n", "}\n"], "called_function_list": ["ctx_store_meta"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "tail_srv6_encap": [{"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 434, "endLine": 452, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/egress_policies.h", "funcName": "tail_srv6_encap", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx"], "output": "int", "helper": ["CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["int tail_srv6_encap (struct  __ctx_buff *ctx)\n", "{\n", "    struct in6_addr dst_sid;\n", "    __u32 vrf_id;\n", "    int ret = 0;\n", "    srv6_load_meta_sid (ctx, &dst_sid);\n", "    vrf_id = ctx_load_meta (ctx, CB_SRV6_VRF_ID);\n", "    ret = srv6_handling (ctx, vrf_id, & dst_sid);\n", "    if (ret < 0)\n", "        return send_drop_notify_error (ctx, SECLABEL, ret, CTX_ACT_DROP, METRIC_EGRESS);\n", "    send_trace_notify (ctx, TRACE_TO_STACK, SECLABEL, 0, 0, 0, TRACE_REASON_UNKNOWN, 0);\n", "    return CTX_ACT_OK;\n", "}\n"], "called_function_list": ["send_trace_notify", "srv6_handling", "srv6_load_meta_sid", "ctx_load_meta"], "call_depth": 3, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "tail_srv6_decap": [{"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 455, "endLine": 473, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/egress_policies.h", "funcName": "tail_srv6_decap", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx"], "output": "int", "helper": ["CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["int tail_srv6_decap (struct  __ctx_buff *ctx)\n", "{\n", "    int ret = 0;\n", "    ret = srv6_create_state_entry (ctx);\n", "    if (ret < 0)\n", "        goto error_drop;\n", "    ret = srv6_decapsulation (ctx);\n", "    if (ret < 0)\n", "        goto error_drop;\n", "    send_trace_notify (ctx, TRACE_TO_STACK, SECLABEL, 0, 0, 0, TRACE_REASON_UNKNOWN, 0);\n", "    return CTX_ACT_OK;\n", "error_drop :\n", "    return send_drop_notify_error (ctx, SECLABEL, ret, CTX_ACT_DROP, METRIC_EGRESS);\n", "}\n"], "called_function_list": ["srv6_create_state_entry", "send_trace_notify", "srv6_decapsulation"], "call_depth": 4, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "tail_srv6_reply": [{"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 476, "endLine": 485, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/egress_policies.h", "funcName": "tail_srv6_reply", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx"], "output": "int", "helper": ["CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["int tail_srv6_reply (struct  __ctx_buff *ctx)\n", "{\n", "    int ret;\n", "    ret = srv6_reply (ctx);\n", "    if (ret < 0)\n", "        return send_drop_notify_error (ctx, SECLABEL, ret, CTX_ACT_DROP, METRIC_EGRESS);\n", "    return CTX_ACT_OK;\n", "}\n"], "called_function_list": ["srv6_reply"], "call_depth": 6, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "update_trace_metrics": [{"capabilities": [], "helperCallParams": {}, "startLine": 80, "endLine": 124, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/trace.h", "funcName": "update_trace_metrics", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " enum trace_point obs_point", " enum trace_reason reason"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void update_trace_metrics (struct  __ctx_buff *ctx, enum trace_point obs_point, enum trace_reason reason)\n", "{\n", "    __u8 encrypted;\n", "    switch (obs_point) {\n", "    case TRACE_TO_LXC :\n", "        update_metrics (ctx_full_len (ctx), METRIC_INGRESS, REASON_FORWARDED);\n", "        break;\n", "    case TRACE_TO_HOST :\n", "    case TRACE_TO_STACK :\n", "    case TRACE_TO_OVERLAY :\n", "    case TRACE_TO_NETWORK :\n", "        update_metrics (ctx_full_len (ctx), METRIC_EGRESS, REASON_FORWARDED);\n", "        break;\n", "    case TRACE_FROM_HOST :\n", "    case TRACE_FROM_STACK :\n", "    case TRACE_FROM_OVERLAY :\n", "    case TRACE_FROM_NETWORK :\n", "        encrypted = reason & TRACE_REASON_ENCRYPTED;\n", "        if (!encrypted)\n", "            update_metrics (ctx_full_len (ctx), METRIC_INGRESS, REASON_PLAINTEXT);\n", "        else\n", "            update_metrics (ctx_full_len (ctx), METRIC_INGRESS, REASON_DECRYPT);\n", "        break;\n", "    case TRACE_FROM_LXC :\n", "    case TRACE_FROM_PROXY :\n", "    case TRACE_TO_PROXY :\n", "        break;\n", "    }\n", "}\n"], "called_function_list": ["ctx_full_len", "update_metrics"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "emit_trace_notify": [{"capabilities": [], "helperCallParams": {}, "startLine": 154, "endLine": 182, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/trace.h", "funcName": "emit_trace_notify", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["enum trace_point obs_point", " __u32 monitor"], "output": "static__always_inlinebool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline bool emit_trace_notify (enum trace_point obs_point, __u32 monitor)\n", "{\n", "    if (MONITOR_AGGREGATION >= TRACE_AGGREGATE_RX) {\n", "        switch (obs_point) {\n", "        case TRACE_FROM_LXC :\n", "        case TRACE_FROM_PROXY :\n", "        case TRACE_FROM_HOST :\n", "        case TRACE_FROM_STACK :\n", "        case TRACE_FROM_OVERLAY :\n", "        case TRACE_FROM_NETWORK :\n", "            return false;\n", "        default :\n", "            break;\n", "        }\n", "    }\n", "    if (MONITOR_AGGREGATION >= TRACE_AGGREGATE_ACTIVE_CT && !monitor)\n", "        return false;\n", "    return true;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "send_trace_notify": [{"capabilities": [], "helperCallParams": {}, "startLine": 184, "endLine": 213, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/trace.h", "funcName": "send_trace_notify", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " enum trace_point obs_point", " __u32 src", " __u32 dst", " __u16 dst_id", " __u32 ifindex", " enum trace_reason reason", " __u32 monitor"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void send_trace_notify (struct  __ctx_buff *ctx, enum trace_point obs_point, __u32 src, __u32 dst, __u16 dst_id, __u32 ifindex, enum trace_reason reason, __u32 monitor)\n", "{\n", "    __u64 ctx_len = ctx_full_len (ctx);\n", "    __u64 cap_len = min_t (__u64, monitor ? : TRACE_PAYLOAD_LEN, ctx_len);\n", "    struct trace_notify msg __align_stack_8;\n", "    update_trace_metrics (ctx, obs_point, reason);\n", "    if (!emit_trace_notify (obs_point, monitor))\n", "        return;\n", "    msg = (typeof (msg)) {__notify_common_hdr (CILIUM_NOTIFY_TRACE, obs_point), __notify_pktcap_hdr (ctx_len, (__u16) cap_len),\n", "        .src_label = src,\n", "        .dst_label = dst,\n", "        .dst_id = dst_id,\n", "        .reason = reason,\n", "        .ifindex = ifindex,};\n", "    memset (&msg.orig_ip6, 0, sizeof (union v6addr));\n", "    ctx_event_output (ctx, &EVENTS_MAP, (cap_len << 32) | BPF_F_CURRENT_CPU, &msg, sizeof (msg));\n", "}\n"], "called_function_list": ["update_trace_metrics", "ctx_full_len", "emit_trace_notify", "memset"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 281, "endLine": 288, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/trace.h", "funcName": "send_trace_notify", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " enum trace_point obs_point", " __u32 src __maybe_unused", " __u32 dst __maybe_unused", " __u16 dst_id __maybe_unused", " __u32 ifindex __maybe_unused", " enum trace_reason reason", " __u32 monitor __maybe_unused"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void send_trace_notify (struct  __ctx_buff *ctx, enum trace_point obs_point, __u32 src __maybe_unused, __u32 dst __maybe_unused, __u16 dst_id __maybe_unused, __u32 ifindex __maybe_unused, enum trace_reason reason, __u32 monitor __maybe_unused)\n", "{\n", "    update_trace_metrics (ctx, obs_point, reason);\n", "}\n"], "called_function_list": ["update_trace_metrics", "ctx_full_len", "emit_trace_notify", "memset"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "send_trace_notify4": [{"capabilities": [], "helperCallParams": {}, "startLine": 215, "endLine": 245, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/trace.h", "funcName": "send_trace_notify4", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " enum trace_point obs_point", " __u32 src", " __u32 dst", " __be32 orig_addr", " __u16 dst_id", " __u32 ifindex", " enum trace_reason reason", " __u32 monitor"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void send_trace_notify4 (struct  __ctx_buff *ctx, enum trace_point obs_point, __u32 src, __u32 dst, __be32 orig_addr, __u16 dst_id, __u32 ifindex, enum trace_reason reason, __u32 monitor)\n", "{\n", "    __u64 ctx_len = ctx_full_len (ctx);\n", "    __u64 cap_len = min_t (__u64, monitor ? : TRACE_PAYLOAD_LEN, ctx_len);\n", "    struct trace_notify msg;\n", "    update_trace_metrics (ctx, obs_point, reason);\n", "    if (!emit_trace_notify (obs_point, monitor))\n", "        return;\n", "    msg = (typeof (msg)) {__notify_common_hdr (CILIUM_NOTIFY_TRACE, obs_point), __notify_pktcap_hdr (ctx_len, (__u16) cap_len),\n", "        .src_label = src,\n", "        .dst_label = dst,\n", "        .dst_id = dst_id,\n", "        .reason = reason,\n", "        .ifindex = ifindex,\n", "        .ipv6 = 0,\n", "        .orig_ip4 = orig_addr,};\n", "    ctx_event_output (ctx, &EVENTS_MAP, (cap_len << 32) | BPF_F_CURRENT_CPU, &msg, sizeof (msg));\n", "}\n"], "called_function_list": ["update_trace_metrics", "ctx_full_len", "emit_trace_notify"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 290, "endLine": 298, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/trace.h", "funcName": "send_trace_notify4", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " enum trace_point obs_point", " __u32 src __maybe_unused", " __u32 dst __maybe_unused", " __be32 orig_addr __maybe_unused", " __u16 dst_id __maybe_unused", " __u32 ifindex __maybe_unused", " enum trace_reason reason", " __u32 monitor __maybe_unused"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void send_trace_notify4 (struct  __ctx_buff *ctx, enum trace_point obs_point, __u32 src __maybe_unused, __u32 dst __maybe_unused, __be32 orig_addr __maybe_unused, __u16 dst_id __maybe_unused, __u32 ifindex __maybe_unused, enum trace_reason reason, __u32 monitor __maybe_unused)\n", "{\n", "    update_trace_metrics (ctx, obs_point, reason);\n", "}\n"], "called_function_list": ["update_trace_metrics", "ctx_full_len", "emit_trace_notify"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "send_trace_notify6": [{"capabilities": [], "helperCallParams": {}, "startLine": 247, "endLine": 279, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/trace.h", "funcName": "send_trace_notify6", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " enum trace_point obs_point", " __u32 src", " __u32 dst", " const union v6addr *orig_addr", " __u16 dst_id", " __u32 ifindex", " enum trace_reason reason", " __u32 monitor"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void send_trace_notify6 (struct  __ctx_buff *ctx, enum trace_point obs_point, __u32 src, __u32 dst, const union v6addr *orig_addr, __u16 dst_id, __u32 ifindex, enum trace_reason reason, __u32 monitor)\n", "{\n", "    __u64 ctx_len = ctx_full_len (ctx);\n", "    __u64 cap_len = min_t (__u64, monitor ? : TRACE_PAYLOAD_LEN, ctx_len);\n", "    struct trace_notify msg;\n", "    update_trace_metrics (ctx, obs_point, reason);\n", "    if (!emit_trace_notify (obs_point, monitor))\n", "        return;\n", "    msg = (typeof (msg)) {__notify_common_hdr (CILIUM_NOTIFY_TRACE, obs_point), __notify_pktcap_hdr (ctx_len, (__u16) cap_len),\n", "        .src_label = src,\n", "        .dst_label = dst,\n", "        .dst_id = dst_id,\n", "        .reason = reason,\n", "        .ifindex = ifindex,\n", "        .ipv6 = 1,};\n", "    ipv6_addr_copy (&msg.orig_ip6, orig_addr);\n", "    ctx_event_output (ctx, &EVENTS_MAP, (cap_len << 32) | BPF_F_CURRENT_CPU, &msg, sizeof (msg));\n", "}\n"], "called_function_list": ["update_trace_metrics", "ctx_full_len", "ipv6_addr_copy", "emit_trace_notify"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 300, "endLine": 308, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/trace.h", "funcName": "send_trace_notify6", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " enum trace_point obs_point", " __u32 src __maybe_unused", " __u32 dst __maybe_unused", " union v6addr * orig_addr __maybe_unused", " __u16 dst_id __maybe_unused", " __u32 ifindex __maybe_unused", " enum trace_reason reason", " __u32 monitor __maybe_unused"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void send_trace_notify6 (struct  __ctx_buff *ctx, enum trace_point obs_point, __u32 src __maybe_unused, __u32 dst __maybe_unused, union v6addr * orig_addr __maybe_unused, __u16 dst_id __maybe_unused, __u32 ifindex __maybe_unused, enum trace_reason reason, __u32 monitor __maybe_unused)\n", "{\n", "    update_trace_metrics (ctx, obs_point, reason);\n", "}\n"], "called_function_list": ["update_trace_metrics", "ctx_full_len", "ipv6_addr_copy", "emit_trace_notify"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "bpf_clear_meta": [{"capabilities": [], "helperCallParams": {}, "startLine": 7, "endLine": 17, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_skb.h", "funcName": "bpf_clear_meta", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __sk_buff *ctx"], "output": "static__always_inline__maybe_unusedvoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused void bpf_clear_meta (struct  __sk_buff *ctx)\n", "{\n", "    __u32 zero = 0;\n", "    WRITE_ONCE (ctx->cb[0], zero);\n", "    WRITE_ONCE (ctx->cb[1], zero);\n", "    WRITE_ONCE (ctx->cb[2], zero);\n", "    WRITE_ONCE (ctx->cb[3], zero);\n", "    WRITE_ONCE (ctx->cb[4], zero);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 7, "endLine": 10, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_xdp.h", "funcName": "bpf_clear_meta", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct xdp_md * ctx __maybe_unused"], "output": "static__always_inline__maybe_unusedvoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused void bpf_clear_meta (struct xdp_md * ctx __maybe_unused)\n", "{\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "get_identity": [{"capabilities": [], "helperCallParams": {}, "startLine": 22, "endLine": 26, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_skb.h", "funcName": "get_identity", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct  __sk_buff *ctx"], "output": "static__always_inline__maybe_unusedint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused int get_identity (const struct  __sk_buff *ctx)\n", "{\n", "    return ((ctx->mark & 0xFF) << 16) | ctx->mark >> 16;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 12, "endLine": 16, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_xdp.h", "funcName": "get_identity", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct xdp_md * ctx __maybe_unused"], "output": "static__always_inline__maybe_unusedint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused int get_identity (struct xdp_md * ctx __maybe_unused)\n", "{\n", "    return 0;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "get_epid": [{"capabilities": [], "helperCallParams": {}, "startLine": 31, "endLine": 35, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_skb.h", "funcName": "get_epid", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct  __sk_buff *ctx"], "output": "static__always_inline__maybe_unused__u32", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused __u32 get_epid (const struct  __sk_buff *ctx)\n", "{\n", "    return ctx->mark >> 16;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "set_encrypt_dip": [{"capabilities": [], "helperCallParams": {}, "startLine": 37, "endLine": 41, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_skb.h", "funcName": "set_encrypt_dip", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __sk_buff *ctx", " __u32 ip_endpoint"], "output": "static__always_inline__maybe_unusedvoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused void set_encrypt_dip (struct  __sk_buff *ctx, __u32 ip_endpoint)\n", "{\n", "    ctx->cb[4] = ip_endpoint;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 18, "endLine": 22, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_xdp.h", "funcName": "set_encrypt_dip", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct xdp_md * ctx __maybe_unused", " __u32 ip_endpoint __maybe_unused"], "output": "static__always_inline__maybe_unusedvoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused void set_encrypt_dip (struct xdp_md * ctx __maybe_unused, __u32 ip_endpoint __maybe_unused)\n", "{\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "set_identity_mark": [{"capabilities": [], "helperCallParams": {}, "startLine": 46, "endLine": 51, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_skb.h", "funcName": "set_identity_mark", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __sk_buff *ctx", " __u32 identity"], "output": "static__always_inline__maybe_unusedvoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused void set_identity_mark (struct  __sk_buff *ctx, __u32 identity)\n", "{\n", "    ctx->mark = ctx->mark & MARK_MAGIC_KEY_MASK;\n", "    ctx->mark |= ((identity & 0xFFFF) << 16) | ((identity & 0xFF0000) >> 16);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 24, "endLine": 27, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_xdp.h", "funcName": "set_identity_mark", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct xdp_md * ctx __maybe_unused", " __u32 identity __maybe_unused"], "output": "static__always_inline__maybe_unusedvoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused void set_identity_mark (struct xdp_md * ctx __maybe_unused, __u32 identity __maybe_unused)\n", "{\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "set_identity_meta": [{"capabilities": [], "helperCallParams": {}, "startLine": 53, "endLine": 57, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_skb.h", "funcName": "set_identity_meta", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __sk_buff *ctx", " __u32 identity"], "output": "static__always_inline__maybe_unusedvoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused void set_identity_meta (struct  __sk_buff *ctx, __u32 identity)\n", "{\n", "    ctx->cb[1] = identity;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 29, "endLine": 33, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_xdp.h", "funcName": "set_identity_meta", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct xdp_md * ctx __maybe_unused", " __u32 identity __maybe_unused"], "output": "static__always_inline__maybe_unusedvoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused void set_identity_meta (struct xdp_md * ctx __maybe_unused, __u32 identity __maybe_unused)\n", "{\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "set_encrypt_key_mark": [{"capabilities": [], "helperCallParams": {}, "startLine": 62, "endLine": 66, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_skb.h", "funcName": "set_encrypt_key_mark", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __sk_buff *ctx", " __u8 key"], "output": "static__always_inline__maybe_unusedvoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused void set_encrypt_key_mark (struct  __sk_buff *ctx, __u8 key)\n", "{\n", "    ctx->mark = or_encrypt_key (key);\n", "}\n"], "called_function_list": ["or_encrypt_key"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 35, "endLine": 38, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_xdp.h", "funcName": "set_encrypt_key_mark", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct xdp_md * ctx __maybe_unused", " __u8 key __maybe_unused"], "output": "static__always_inline__maybe_unusedvoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused void set_encrypt_key_mark (struct xdp_md * ctx __maybe_unused, __u8 key __maybe_unused)\n", "{\n", "}\n"], "called_function_list": ["or_encrypt_key"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "set_encrypt_key_meta": [{"capabilities": [], "helperCallParams": {}, "startLine": 68, "endLine": 72, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_skb.h", "funcName": "set_encrypt_key_meta", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __sk_buff *ctx", " __u8 key"], "output": "static__always_inline__maybe_unusedvoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused void set_encrypt_key_meta (struct  __sk_buff *ctx, __u8 key)\n", "{\n", "    ctx->cb[0] = or_encrypt_key (key);\n", "}\n"], "called_function_list": ["or_encrypt_key"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 40, "endLine": 43, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_xdp.h", "funcName": "set_encrypt_key_meta", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct xdp_md * ctx __maybe_unused", " __u8 key __maybe_unused"], "output": "static__always_inline__maybe_unusedvoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused void set_encrypt_key_meta (struct xdp_md * ctx __maybe_unused, __u8 key __maybe_unused)\n", "{\n", "}\n"], "called_function_list": ["or_encrypt_key"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "set_encrypt_mark": [{"capabilities": [], "helperCallParams": {}, "startLine": 79, "endLine": 83, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_skb.h", "funcName": "set_encrypt_mark", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __sk_buff *ctx"], "output": "static__always_inline__maybe_unusedvoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused void set_encrypt_mark (struct  __sk_buff *ctx)\n", "{\n", "    ctx->mark |= MARK_MAGIC_ENCRYPT;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "redirect_self": [{"capabilities": [], "helperCallParams": {}, "startLine": 85, "endLine": 99, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_skb.h", "funcName": "redirect_self", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct  __sk_buff *ctx"], "output": "static__always_inline__maybe_unusedint", "helper": ["redirect"], "compatibleHookpoints": ["lwt_xmit", "sched_cls", "xdp", "sched_act"], "source": ["static __always_inline __maybe_unused int redirect_self (const struct  __sk_buff *ctx)\n", "{\n", "\n", "#ifdef ENABLE_HOST_REDIRECT\n", "    return ctx_redirect (ctx, ctx->ifindex, 0);\n", "\n", "#else\n", "    return ctx_redirect (ctx, ctx->ifindex, BPF_F_INGRESS);\n", "\n", "#endif\n", "}\n"], "called_function_list": ["ctx_redirect"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [{"capability": "pkt_alter_or_redo_processing_or_interface", "pkt_alter_or_redo_processing_or_interface": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_TX", "Return": 3, "Description": "an efficient option to transmit the network packet out of the same NIC it just arrived on again. This is typically useful when few nodes are implementing, for example, firewalling with subsequent load balancing in a cluster and thus act as a hairpinned load balancer pushing the incoming packets back into the switch after rewriting them in XDP BPF.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_alter_or_redo_processing_or_interface"]}]}], "helperCallParams": {}, "startLine": 45, "endLine": 53, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_xdp.h", "funcName": "redirect_self", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct xdp_md * ctx __maybe_unused"], "output": "static__always_inline__maybe_unusedint", "helper": ["redirect", "XDP_TX"], "compatibleHookpoints": ["xdp"], "source": ["static __always_inline __maybe_unused int redirect_self (struct xdp_md * ctx __maybe_unused)\n", "{\n", "\n", "#ifdef ENABLE_HOST_REDIRECT\n", "    return XDP_TX;\n", "\n", "#else\n", "    return -ENOTSUP;\n", "\n", "#endif\n", "}\n"], "called_function_list": ["ctx_redirect"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ctx_skip_nodeport_clear": [{"capabilities": [], "helperCallParams": {}, "startLine": 101, "endLine": 107, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_skb.h", "funcName": "ctx_skip_nodeport_clear", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __sk_buff * ctx __maybe_unused"], "output": "static__always_inline__maybe_unusedvoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused void ctx_skip_nodeport_clear (struct  __sk_buff * ctx __maybe_unused)\n", "{\n", "\n", "#ifdef ENABLE_NODEPORT\n", "    ctx->tc_index &= ~TC_INDEX_F_SKIP_NODEPORT;\n", "\n", "#endif\n", "}\n"], "called_function_list": ["ctx_store_meta"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 58, "endLine": 64, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_xdp.h", "funcName": "ctx_skip_nodeport_clear", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct xdp_md * ctx __maybe_unused"], "output": "static__always_inline__maybe_unusedvoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused void ctx_skip_nodeport_clear (struct xdp_md * ctx __maybe_unused)\n", "{\n", "\n", "#ifdef ENABLE_NODEPORT\n", "    ctx_store_meta (ctx, RECIRC_MARKER, 0);\n", "\n", "#endif\n", "}\n"], "called_function_list": ["ctx_store_meta"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ctx_skip_nodeport_set": [{"capabilities": [], "helperCallParams": {}, "startLine": 109, "endLine": 115, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_skb.h", "funcName": "ctx_skip_nodeport_set", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __sk_buff * ctx __maybe_unused"], "output": "static__always_inline__maybe_unusedvoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused void ctx_skip_nodeport_set (struct  __sk_buff * ctx __maybe_unused)\n", "{\n", "\n", "#ifdef ENABLE_NODEPORT\n", "    ctx->tc_index |= TC_INDEX_F_SKIP_NODEPORT;\n", "\n", "#endif\n", "}\n"], "called_function_list": ["ctx_store_meta"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 66, "endLine": 72, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_xdp.h", "funcName": "ctx_skip_nodeport_set", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct xdp_md * ctx __maybe_unused"], "output": "static__always_inline__maybe_unusedvoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused void ctx_skip_nodeport_set (struct xdp_md * ctx __maybe_unused)\n", "{\n", "\n", "#ifdef ENABLE_NODEPORT\n", "    ctx_store_meta (ctx, RECIRC_MARKER, 1);\n", "\n", "#endif\n", "}\n"], "called_function_list": ["ctx_store_meta"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ctx_skip_nodeport": [{"capabilities": [], "helperCallParams": {}, "startLine": 117, "endLine": 127, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_skb.h", "funcName": "ctx_skip_nodeport", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __sk_buff * ctx __maybe_unused"], "output": "static__always_inline__maybe_unusedbool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused bool ctx_skip_nodeport (struct  __sk_buff * ctx __maybe_unused)\n", "{\n", "\n", "#ifdef ENABLE_NODEPORT\n", "    volatile __u32 tc_index = ctx->tc_index;\n", "    ctx->tc_index &= ~TC_INDEX_F_SKIP_NODEPORT;\n", "    return tc_index & TC_INDEX_F_SKIP_NODEPORT;\n", "\n", "#else\n", "    return true;\n", "\n", "#endif\n", "}\n"], "called_function_list": ["ctx_load_meta"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 74, "endLine": 82, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_xdp.h", "funcName": "ctx_skip_nodeport", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct xdp_md * ctx __maybe_unused"], "output": "static__always_inline__maybe_unusedbool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused bool ctx_skip_nodeport (struct xdp_md * ctx __maybe_unused)\n", "{\n", "\n", "#ifdef ENABLE_NODEPORT\n", "    return ctx_load_meta (ctx, RECIRC_MARKER);\n", "\n", "#else\n", "    return true;\n", "\n", "#endif\n", "}\n"], "called_function_list": ["ctx_load_meta"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ctx_skip_host_fw_set": [{"capabilities": [], "helperCallParams": {}, "startLine": 130, "endLine": 134, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_skb.h", "funcName": "ctx_skip_host_fw_set", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __sk_buff *ctx"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void ctx_skip_host_fw_set (struct  __sk_buff *ctx)\n", "{\n", "    ctx->tc_index |= TC_INDEX_F_SKIP_HOST_FIREWALL;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ctx_skip_host_fw": [{"capabilities": [], "helperCallParams": {}, "startLine": 136, "endLine": 143, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_skb.h", "funcName": "ctx_skip_host_fw", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __sk_buff *ctx"], "output": "static__always_inlinebool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline bool ctx_skip_host_fw (struct  __sk_buff *ctx)\n", "{\n", "    volatile __u32 tc_index = ctx->tc_index;\n", "    ctx->tc_index &= ~TC_INDEX_F_SKIP_HOST_FIREWALL;\n", "    return tc_index & TC_INDEX_F_SKIP_HOST_FIREWALL;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ctx_get_xfer": [{"capabilities": [], "helperCallParams": {}, "startLine": 146, "endLine": 152, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_skb.h", "funcName": "ctx_get_xfer", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __sk_buff *ctx"], "output": "static__always_inline__maybe_unused__u32", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused __u32 ctx_get_xfer (struct  __sk_buff *ctx)\n", "{\n", "    __u32 *data_meta = ctx_data_meta (ctx);\n", "    void *data = ctx_data (ctx);\n", "    return !ctx_no_room (data_meta + 1, data) ? data_meta[0] : 0;\n", "}\n"], "called_function_list": ["ctx_data_meta", "ctx_no_room", "ctx_data"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 84, "endLine": 88, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_xdp.h", "funcName": "ctx_get_xfer", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct xdp_md * ctx __maybe_unused"], "output": "static__always_inline__maybe_unused__u32", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused __u32 ctx_get_xfer (struct xdp_md * ctx __maybe_unused)\n", "{\n", "    return 0;\n", "}\n"], "called_function_list": ["ctx_data_meta", "ctx_no_room", "ctx_data"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ctx_set_xfer": [{"capabilities": [], "helperCallParams": {}, "startLine": 154, "endLine": 158, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_skb.h", "funcName": "ctx_set_xfer", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __sk_buff * ctx __maybe_unused", " __u32 meta __maybe_unused"], "output": "static__always_inline__maybe_unusedvoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused void ctx_set_xfer (struct  __sk_buff * ctx __maybe_unused, __u32 meta __maybe_unused)\n", "{\n", "}\n"], "called_function_list": ["ctx_store_meta"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 90, "endLine": 94, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_xdp.h", "funcName": "ctx_set_xfer", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct xdp_md *ctx", " __u32 meta"], "output": "static__always_inline__maybe_unusedvoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused void ctx_set_xfer (struct xdp_md *ctx, __u32 meta)\n", "{\n", "    ctx_store_meta (ctx, XFER_MARKER, meta);\n", "}\n"], "called_function_list": ["ctx_store_meta"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ctx_change_head": [{"capabilities": [{"capability": "update_pkt", "update_pkt": [{"Project": "cilium", "Return Type": "int", "Description": "Grows headroom of packet associated to <[ skb ]>(IP: 0) and adjusts the offset of the MAC header accordingly , adding <[ len ]>(IP: 1) bytes of space. It automatically extends and reallocates memory as required. This helper can be used on a layer 3 <[ skb ]>(IP: 0) to push a MAC header for redirection into a layer 2 device. All values for <[ flags ]>(IP: 2) are reserved for future usage , and must be left at zero. A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "skb_change_head", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  u32 ,Var: len}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["sched_cls", "sched_act", "lwt_xmit", "sk_skb"], "capabilities": ["update_pkt"]}]}], "helperCallParams": {}, "startLine": 160, "endLine": 164, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_skb.h", "funcName": "ctx_change_head", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __sk_buff *ctx", " __u32 head_room", " __u64 flags"], "output": "static__always_inline__maybe_unusedint", "helper": ["skb_change_head"], "compatibleHookpoints": ["lwt_xmit", "sched_cls", "sk_skb", "sched_act"], "source": ["static __always_inline __maybe_unused int ctx_change_head (struct  __sk_buff *ctx, __u32 head_room, __u64 flags)\n", "{\n", "    return skb_change_head (ctx, head_room, flags);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 96, "endLine": 102, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_xdp.h", "funcName": "ctx_change_head", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct xdp_md * ctx __maybe_unused", " __u32 head_room __maybe_unused", " __u64 flags __maybe_unused"], "output": "static__always_inline__maybe_unusedint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused int ctx_change_head (struct xdp_md * ctx __maybe_unused, __u32 head_room __maybe_unused, __u64 flags __maybe_unused)\n", "{\n", "    return 0;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ipv6_host_policy_egress": [{"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 17, "endLine": 100, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/host_firewall.h", "funcName": "ipv6_host_policy_egress", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " __u32 src_id", " struct trace_ctx *trace"], "output": "static__always_inlineint", "helper": ["CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["static __always_inline int ipv6_host_policy_egress (struct  __ctx_buff *ctx, __u32 src_id, struct trace_ctx *trace)\n", "{\n", "    int ret, verdict, l3_off = ETH_HLEN, l4_off, hdrlen;\n", "    struct ct_state ct_state_new = {}, ct_state = {};\n", "    __u8 policy_match_type = POLICY_MATCH_NONE;\n", "    __u8 audited = 0;\n", "    struct remote_endpoint_info *info;\n", "    struct ipv6_ct_tuple tuple = {}\n", "    ;\n", "    __u32 dst_id = 0;\n", "    union v6addr orig_dip;\n", "    void *data, *data_end;\n", "    struct ipv6hdr *ip6;\n", "    if (src_id != HOST_ID)\n", "        return CTX_ACT_OK;\n", "    if (!revalidate_data (ctx, &data, &data_end, &ip6))\n", "        return DROP_INVALID;\n", "    tuple.nexthdr = ip6->nexthdr;\n", "    ipv6_addr_copy (&tuple.saddr, (union v6addr *) &ip6->saddr);\n", "    ipv6_addr_copy (&tuple.daddr, (union v6addr *) &ip6->daddr);\n", "    ipv6_addr_copy (&orig_dip, (union v6addr *) &ip6->daddr);\n", "    hdrlen = ipv6_hdrlen (ctx, & tuple.nexthdr);\n", "    if (hdrlen < 0)\n", "        return hdrlen;\n", "    l4_off = l3_off + hdrlen;\n", "    ret = ct_lookup6 (get_ct_map6 (& tuple), & tuple, ctx, l4_off, CT_EGRESS, & ct_state, & trace -> monitor);\n", "    if (ret < 0)\n", "        return ret;\n", "    trace->reason = (enum trace_reason) ret;\n", "    info = lookup_ip6_remote_endpoint (& orig_dip);\n", "    if (info && info->sec_label)\n", "        dst_id = info->sec_label;\n", "    cilium_dbg (ctx, info ? DBG_IP_ID_MAP_SUCCEED6 : DBG_IP_ID_MAP_FAILED6, orig_dip.p4, dst_id);\n", "    verdict = policy_can_egress6 (ctx, & tuple, src_id, dst_id, & policy_match_type, & audited);\n", "    if (ret != CT_REPLY && ret != CT_RELATED && verdict < 0) {\n", "        send_policy_verdict_notify (ctx, dst_id, tuple.dport, tuple.nexthdr, POLICY_EGRESS, 1, verdict, policy_match_type, audited);\n", "        return verdict;\n", "    }\n", "    switch (ret) {\n", "    case CT_NEW :\n", "        send_policy_verdict_notify (ctx, dst_id, tuple.dport, tuple.nexthdr, POLICY_EGRESS, 1, verdict, policy_match_type, audited);\n", "        ct_state_new.src_sec_id = HOST_ID;\n", "        ret = ct_create6 (get_ct_map6 (& tuple), & CT_MAP_ANY6, & tuple, ctx, CT_EGRESS, & ct_state_new, verdict > 0, false);\n", "        if (IS_ERR (ret))\n", "            return ret;\n", "        break;\n", "    case CT_REOPENED :\n", "        send_policy_verdict_notify (ctx, dst_id, tuple.dport, tuple.nexthdr, POLICY_EGRESS, 1, verdict, policy_match_type, audited);\n", "    case CT_ESTABLISHED :\n", "    case CT_RELATED :\n", "    case CT_REPLY :\n", "        break;\n", "    default :\n", "        return DROP_UNKNOWN_CT;\n", "    }\n", "    return CTX_ACT_OK;\n", "}\n"], "called_function_list": ["send_policy_verdict_notify", "ct_create6", "ct_lookup6", "get_ct_map6", "ipv6_hdrlen", "ipv6_addr_copy", "policy_can_egress6", "cilium_dbg"], "call_depth": 3, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ipv6_host_policy_ingress": [{"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 102, "endLine": 199, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/host_firewall.h", "funcName": "ipv6_host_policy_ingress", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " __u32 *src_id", " struct trace_ctx *trace"], "output": "static__always_inlineint", "helper": ["CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["static __always_inline int ipv6_host_policy_ingress (struct  __ctx_buff *ctx, __u32 *src_id, struct trace_ctx *trace)\n", "{\n", "    struct ct_state ct_state_new = {}, ct_state = {};\n", "    __u8 policy_match_type = POLICY_MATCH_NONE;\n", "    __u8 audited = 0;\n", "    __u32 dst_id = WORLD_ID;\n", "    struct remote_endpoint_info *info;\n", "    int ret, verdict, l4_off, hdrlen;\n", "    struct ipv6_ct_tuple tuple = {}\n", "    ;\n", "    union v6addr orig_sip;\n", "    void *data, *data_end;\n", "    struct ipv6hdr *ip6;\n", "    if (!revalidate_data (ctx, &data, &data_end, &ip6))\n", "        return DROP_INVALID;\n", "    ipv6_addr_copy (&tuple.daddr, (union v6addr *) &ip6->daddr);\n", "    info = lookup_ip6_remote_endpoint (& tuple.daddr);\n", "    if (info && info->sec_label)\n", "        dst_id = info->sec_label;\n", "    cilium_dbg (ctx, info ? DBG_IP_ID_MAP_SUCCEED6 : DBG_IP_ID_MAP_FAILED6, tuple.daddr.p4, dst_id);\n", "    if (dst_id != HOST_ID)\n", "        return CTX_ACT_OK;\n", "    tuple.nexthdr = ip6->nexthdr;\n", "    ipv6_addr_copy (&tuple.saddr, (union v6addr *) &ip6->saddr);\n", "    ipv6_addr_copy (&orig_sip, (union v6addr *) &ip6->saddr);\n", "    hdrlen = ipv6_hdrlen (ctx, & tuple.nexthdr);\n", "    if (hdrlen < 0)\n", "        return hdrlen;\n", "    l4_off = ETH_HLEN + hdrlen;\n", "    ret = ct_lookup6 (get_ct_map6 (& tuple), & tuple, ctx, l4_off, CT_INGRESS, & ct_state, & trace -> monitor);\n", "    if (ret < 0)\n", "        return ret;\n", "    trace->reason = (enum trace_reason) ret;\n", "    info = lookup_ip6_remote_endpoint (& orig_sip);\n", "    if (info && info->sec_label)\n", "        *src_id = info->sec_label;\n", "    cilium_dbg (ctx, info ? DBG_IP_ID_MAP_SUCCEED6 : DBG_IP_ID_MAP_FAILED6, orig_sip.p4, *src_id);\n", "    verdict = policy_can_access_ingress (ctx, * src_id, dst_id, tuple.dport, tuple.nexthdr, false, & policy_match_type, & audited);\n", "    if (ret != CT_REPLY && ret != CT_RELATED && verdict < 0) {\n", "        send_policy_verdict_notify (ctx, *src_id, tuple.dport, tuple.nexthdr, POLICY_INGRESS, 1, verdict, policy_match_type, audited);\n", "        return verdict;\n", "    }\n", "    switch (ret) {\n", "    case CT_NEW :\n", "        send_policy_verdict_notify (ctx, *src_id, tuple.dport, tuple.nexthdr, POLICY_INGRESS, 1, verdict, policy_match_type, audited);\n", "        ct_state_new.src_sec_id = *src_id;\n", "        ct_state_new.node_port = ct_state.node_port;\n", "        ret = ct_create6 (get_ct_map6 (& tuple), & CT_MAP_ANY6, & tuple, ctx, CT_INGRESS, & ct_state_new, verdict > 0, false);\n", "        if (IS_ERR (ret))\n", "            return ret;\n", "    case CT_REOPENED :\n", "        send_policy_verdict_notify (ctx, *src_id, tuple.dport, tuple.nexthdr, POLICY_INGRESS, 1, verdict, policy_match_type, audited);\n", "    case CT_ESTABLISHED :\n", "    case CT_RELATED :\n", "    case CT_REPLY :\n", "        break;\n", "    default :\n", "        return DROP_UNKNOWN_CT;\n", "    }\n", "    ctx_change_type (ctx, PACKET_HOST);\n", "    return CTX_ACT_OK;\n", "}\n"], "called_function_list": ["send_policy_verdict_notify", "ct_create6", "ct_lookup6", "get_ct_map6", "ipv6_hdrlen", "policy_can_access_ingress", "ipv6_addr_copy", "cilium_dbg"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "whitelist_snated_egress_connections": [{"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 204, "endLine": 249, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/host_firewall.h", "funcName": "whitelist_snated_egress_connections", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " __u32 ipcache_srcid", " struct trace_ctx *trace"], "output": "static__always_inlineint", "helper": ["CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["static __always_inline int whitelist_snated_egress_connections (struct  __ctx_buff *ctx, __u32 ipcache_srcid, struct trace_ctx *trace)\n", "{\n", "    struct ct_state ct_state_new = {}, ct_state = {};\n", "    struct ipv4_ct_tuple tuple = {}\n", "    ;\n", "    void *data, *data_end;\n", "    struct iphdr *ip4;\n", "    int ret, l4_off;\n", "    if (ipcache_srcid == HOST_ID) {\n", "        if (!revalidate_data (ctx, &data, &data_end, &ip4))\n", "            return DROP_INVALID;\n", "        tuple.nexthdr = ip4->protocol;\n", "        tuple.daddr = ip4->daddr;\n", "        tuple.saddr = ip4->saddr;\n", "        l4_off = ETH_HLEN + ipv4_hdrlen (ip4);\n", "        ret = ct_lookup4 (get_ct_map4 (& tuple), & tuple, ctx, l4_off, CT_EGRESS, & ct_state, & trace -> monitor);\n", "        if (ret < 0)\n", "            return ret;\n", "        trace->reason = (enum trace_reason) ret;\n", "        if (ret == CT_NEW) {\n", "            ret = ct_create4 (get_ct_map4 (& tuple), & CT_MAP_ANY4, & tuple, ctx, CT_EGRESS, & ct_state_new, false, false);\n", "            if (IS_ERR (ret))\n", "                return ret;\n", "        }\n", "    }\n", "    return CTX_ACT_OK;\n", "}\n"], "called_function_list": ["ct_lookup4", "get_ct_map4", "ipv4_hdrlen", "ct_create4"], "call_depth": 3, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ipv4_host_policy_egress": [{"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 252, "endLine": 337, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/host_firewall.h", "funcName": "ipv4_host_policy_egress", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " __u32 src_id", " __u32 ipcache_srcid __maybe_unused", " struct trace_ctx *trace"], "output": "static__always_inlineint", "helper": ["CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["static __always_inline int ipv4_host_policy_egress (struct  __ctx_buff *ctx, __u32 src_id, __u32 ipcache_srcid __maybe_unused, struct trace_ctx *trace)\n", "{\n", "    struct ct_state ct_state_new = {}, ct_state = {};\n", "    int ret, verdict, l4_off, l3_off = ETH_HLEN;\n", "    __u8 policy_match_type = POLICY_MATCH_NONE;\n", "    __u8 audited = 0;\n", "    struct remote_endpoint_info *info;\n", "    struct ipv4_ct_tuple tuple = {}\n", "    ;\n", "    __u32 dst_id = 0;\n", "    void *data, *data_end;\n", "    struct iphdr *ip4;\n", "    if (src_id != HOST_ID) {\n", "\n", "#  ifndef ENABLE_MASQUERADE\n", "        return whitelist_snated_egress_connections (ctx, ipcache_srcid, trace);\n", "\n", "#  else\n", "        return CTX_ACT_OK;\n", "\n", "#  endif\n", "    }\n", "    if (!revalidate_data (ctx, &data, &data_end, &ip4))\n", "        return DROP_INVALID;\n", "    tuple.nexthdr = ip4->protocol;\n", "    tuple.daddr = ip4->daddr;\n", "    tuple.saddr = ip4->saddr;\n", "    l4_off = l3_off + ipv4_hdrlen (ip4);\n", "    ret = ct_lookup4 (get_ct_map4 (& tuple), & tuple, ctx, l4_off, CT_EGRESS, & ct_state, & trace -> monitor);\n", "    if (ret < 0)\n", "        return ret;\n", "    trace->reason = (enum trace_reason) ret;\n", "    info = lookup_ip4_remote_endpoint (ip4 -> daddr);\n", "    if (info && info->sec_label)\n", "        dst_id = info->sec_label;\n", "    cilium_dbg (ctx, info ? DBG_IP_ID_MAP_SUCCEED4 : DBG_IP_ID_MAP_FAILED4, ip4->daddr, dst_id);\n", "    verdict = policy_can_egress4 (ctx, & tuple, src_id, dst_id, & policy_match_type, & audited);\n", "    if (ret != CT_REPLY && ret != CT_RELATED && verdict < 0) {\n", "        send_policy_verdict_notify (ctx, dst_id, tuple.dport, tuple.nexthdr, POLICY_EGRESS, 0, verdict, policy_match_type, audited);\n", "        return verdict;\n", "    }\n", "    switch (ret) {\n", "    case CT_NEW :\n", "        send_policy_verdict_notify (ctx, dst_id, tuple.dport, tuple.nexthdr, POLICY_EGRESS, 0, verdict, policy_match_type, audited);\n", "        ct_state_new.src_sec_id = HOST_ID;\n", "        ret = ct_create4 (get_ct_map4 (& tuple), & CT_MAP_ANY4, & tuple, ctx, CT_EGRESS, & ct_state_new, verdict > 0, false);\n", "        if (IS_ERR (ret))\n", "            return ret;\n", "        break;\n", "    case CT_REOPENED :\n", "        send_policy_verdict_notify (ctx, dst_id, tuple.dport, tuple.nexthdr, POLICY_EGRESS, 0, verdict, policy_match_type, audited);\n", "    case CT_ESTABLISHED :\n", "    case CT_RELATED :\n", "    case CT_REPLY :\n", "        break;\n", "    default :\n", "        return DROP_UNKNOWN_CT;\n", "    }\n", "    return CTX_ACT_OK;\n", "}\n"], "called_function_list": ["send_policy_verdict_notify", "ct_lookup4", "get_ct_map4", "ipv4_hdrlen", "ct_create4", "whitelist_snated_egress_connections", "cilium_dbg", "policy_can_egress4"], "call_depth": 3, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ipv4_host_policy_ingress": [{"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 339, "endLine": 439, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/host_firewall.h", "funcName": "ipv4_host_policy_ingress", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " __u32 *src_id", " struct trace_ctx *trace"], "output": "static__always_inlineint", "helper": ["CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["static __always_inline int ipv4_host_policy_ingress (struct  __ctx_buff *ctx, __u32 *src_id, struct trace_ctx *trace)\n", "{\n", "    struct ct_state ct_state_new = {}, ct_state = {};\n", "    int ret, verdict, l4_off, l3_off = ETH_HLEN;\n", "    __u8 policy_match_type = POLICY_MATCH_NONE;\n", "    __u8 audited = 0;\n", "    __u32 dst_id = WORLD_ID;\n", "    struct remote_endpoint_info *info;\n", "    struct ipv4_ct_tuple tuple = {}\n", "    ;\n", "    bool is_untracked_fragment = false;\n", "    void *data, *data_end;\n", "    struct iphdr *ip4;\n", "    if (!revalidate_data (ctx, &data, &data_end, &ip4))\n", "        return DROP_INVALID;\n", "    info = lookup_ip4_remote_endpoint (ip4 -> daddr);\n", "    if (info && info->sec_label)\n", "        dst_id = info->sec_label;\n", "    cilium_dbg (ctx, info ? DBG_IP_ID_MAP_SUCCEED4 : DBG_IP_ID_MAP_FAILED4, ip4->daddr, dst_id);\n", "    if (dst_id != HOST_ID)\n", "        return CTX_ACT_OK;\n", "    tuple.nexthdr = ip4->protocol;\n", "    tuple.daddr = ip4->daddr;\n", "    tuple.saddr = ip4->saddr;\n", "    l4_off = l3_off + ipv4_hdrlen (ip4);\n", "\n", "#  ifndef ENABLE_IPV4_FRAGMENTS\n", "    is_untracked_fragment = ipv4_is_fragment (ip4);\n", "\n", "#  endif\n", "    ret = ct_lookup4 (get_ct_map4 (& tuple), & tuple, ctx, l4_off, CT_INGRESS, & ct_state, & trace -> monitor);\n", "    if (ret < 0)\n", "        return ret;\n", "    trace->reason = (enum trace_reason) ret;\n", "    info = lookup_ip4_remote_endpoint (ip4 -> saddr);\n", "    if (info && info->sec_label)\n", "        *src_id = info->sec_label;\n", "    cilium_dbg (ctx, info ? DBG_IP_ID_MAP_SUCCEED4 : DBG_IP_ID_MAP_FAILED4, ip4->saddr, *src_id);\n", "    verdict = policy_can_access_ingress (ctx, * src_id, dst_id, tuple.dport, tuple.nexthdr, is_untracked_fragment, & policy_match_type, & audited);\n", "    if (ret != CT_REPLY && ret != CT_RELATED && verdict < 0) {\n", "        send_policy_verdict_notify (ctx, *src_id, tuple.dport, tuple.nexthdr, POLICY_INGRESS, 0, verdict, policy_match_type, audited);\n", "        return verdict;\n", "    }\n", "    switch (ret) {\n", "    case CT_NEW :\n", "        send_policy_verdict_notify (ctx, *src_id, tuple.dport, tuple.nexthdr, POLICY_INGRESS, 0, verdict, policy_match_type, audited);\n", "        ct_state_new.src_sec_id = *src_id;\n", "        ct_state_new.node_port = ct_state.node_port;\n", "        ret = ct_create4 (get_ct_map4 (& tuple), & CT_MAP_ANY4, & tuple, ctx, CT_INGRESS, & ct_state_new, verdict > 0, false);\n", "        if (IS_ERR (ret))\n", "            return ret;\n", "    case CT_REOPENED :\n", "        send_policy_verdict_notify (ctx, *src_id, tuple.dport, tuple.nexthdr, POLICY_INGRESS, 0, verdict, policy_match_type, audited);\n", "    case CT_ESTABLISHED :\n", "    case CT_RELATED :\n", "    case CT_REPLY :\n", "        break;\n", "    default :\n", "        return DROP_UNKNOWN_CT;\n", "    }\n", "    ctx_change_type (ctx, PACKET_HOST);\n", "    return CTX_ACT_OK;\n", "}\n"], "called_function_list": ["send_policy_verdict_notify", "ipv4_is_fragment", "ct_lookup4", "get_ct_map4", "policy_can_access_ingress", "ipv4_hdrlen", "ct_create4", "cilium_dbg"], "call_depth": 3, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ipv6_l3": [{"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 18, "endLine": 38, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/l3.h", "funcName": "ipv6_l3", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " int l3_off", " const __u8 *smac", " const __u8 *dmac", " __u8 direction"], "output": "static__always_inlineint", "helper": ["CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["static __always_inline int ipv6_l3 (struct  __ctx_buff *ctx, int l3_off, const __u8 *smac, const __u8 *dmac, __u8 direction)\n", "{\n", "    int ret;\n", "    ret = ipv6_dec_hoplimit (ctx, l3_off);\n", "    if (IS_ERR (ret))\n", "        return ret;\n", "    if (ret > 0) {\n", "        return icmp6_send_time_exceeded (ctx, l3_off, direction);\n", "    }\n", "    if (smac && eth_store_saddr (ctx, smac, 0) < 0)\n", "        return DROP_WRITE_ERROR;\n", "    if (dmac && eth_store_daddr (ctx, dmac, 0) < 0)\n", "        return DROP_WRITE_ERROR;\n", "    return CTX_ACT_OK;\n", "}\n"], "called_function_list": ["ipv6_dec_hoplimit", "icmp6_send_time_exceeded", "eth_store_daddr", "eth_store_saddr"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ipv4_l3": [{"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 41, "endLine": 56, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/l3.h", "funcName": "ipv4_l3", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " int l3_off", " const __u8 *smac", " const __u8 *dmac", " struct iphdr *ip4"], "output": "static__always_inlineint", "helper": ["CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["static __always_inline int ipv4_l3 (struct  __ctx_buff *ctx, int l3_off, const __u8 *smac, const __u8 *dmac, struct iphdr *ip4)\n", "{\n", "    if (ipv4_dec_ttl (ctx, l3_off, ip4)) {\n", "        return DROP_INVALID;\n", "    }\n", "    if (smac && eth_store_saddr (ctx, smac, 0) < 0)\n", "        return DROP_WRITE_ERROR;\n", "    if (dmac && eth_store_daddr (ctx, dmac, 0) < 0)\n", "        return DROP_WRITE_ERROR;\n", "    return CTX_ACT_OK;\n", "}\n"], "called_function_list": ["ipv4_dec_ttl", "eth_store_daddr", "eth_store_saddr"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ipv6_local_delivery": [{"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 65, "endLine": 106, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/l3.h", "funcName": "ipv6_local_delivery", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " int l3_off", " __u32 seclabel", " const struct endpoint_info *ep", " __u8 direction", " bool from_host __maybe_unused"], "output": "static__always_inlineint", "helper": ["redirect", "CTX_ACT_OK", "tail_call"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["static __always_inline int ipv6_local_delivery (struct  __ctx_buff *ctx, int l3_off, __u32 seclabel, const struct endpoint_info *ep, __u8 direction, bool from_host __maybe_unused)\n", "{\n", "    mac_t router_mac = ep->node_mac;\n", "    mac_t lxc_mac = ep->mac;\n", "    int ret;\n", "    cilium_dbg (ctx, DBG_LOCAL_DELIVERY, ep->lxc_id, seclabel);\n", "    ret = ipv6_l3 (ctx, l3_off, (__u8 *) & router_mac, (__u8 *) & lxc_mac, direction);\n", "    if (ret != CTX_ACT_OK)\n", "        return ret;\n", "\n", "#ifdef LOCAL_DELIVERY_METRICS\n", "    update_metrics (ctx_full_len (ctx), direction, REASON_FORWARDED);\n", "\n", "#endif\n", "\n", "#if defined(USE_BPF_PROG_FOR_INGRESS_POLICY) && \\\n", "\t!defined(FORCE_LOCAL_POLICY_EVAL_AT_SOURCE)\n", "    ctx->mark |= MARK_MAGIC_IDENTITY;\n", "    set_identity_mark (ctx, seclabel);\n", "    return redirect_ep (ctx, ep->ifindex, from_host);\n", "\n", "#else\n", "    ctx_store_meta (ctx, CB_SRC_LABEL, seclabel);\n", "    ctx_store_meta (ctx, CB_IFINDEX, ep->ifindex);\n", "    ctx_store_meta (ctx, CB_FROM_HOST, from_host ? 1 : 0);\n", "    tail_call_dynamic (ctx, &POLICY_CALL_MAP, ep->lxc_id);\n", "    return DROP_MISSED_TAIL_CALL;\n", "\n", "#endif\n", "}\n"], "called_function_list": ["update_metrics", "tail_call_dynamic", "redirect_ep", "ipv6_l3", "ctx_store_meta", "ctx_full_len", "set_identity_mark", "cilium_dbg"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ipv4_local_delivery": [{"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 114, "endLine": 154, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/l3.h", "funcName": "ipv4_local_delivery", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " int l3_off", " __u32 seclabel", " struct iphdr *ip4", " const struct endpoint_info *ep", " __u8 direction __maybe_unused", " bool from_host __maybe_unused"], "output": "static__always_inlineint", "helper": ["redirect", "CTX_ACT_OK", "tail_call"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["static __always_inline int ipv4_local_delivery (struct  __ctx_buff *ctx, int l3_off, __u32 seclabel, struct iphdr *ip4, const struct endpoint_info *ep, __u8 direction __maybe_unused, bool from_host __maybe_unused)\n", "{\n", "    mac_t router_mac = ep->node_mac;\n", "    mac_t lxc_mac = ep->mac;\n", "    int ret;\n", "    cilium_dbg (ctx, DBG_LOCAL_DELIVERY, ep->lxc_id, seclabel);\n", "    ret = ipv4_l3 (ctx, l3_off, (__u8 *) & router_mac, (__u8 *) & lxc_mac, ip4);\n", "    if (ret != CTX_ACT_OK)\n", "        return ret;\n", "\n", "#ifdef LOCAL_DELIVERY_METRICS\n", "    update_metrics (ctx_full_len (ctx), direction, REASON_FORWARDED);\n", "\n", "#endif\n", "\n", "#if defined(USE_BPF_PROG_FOR_INGRESS_POLICY) && \\\n", "\t!defined(FORCE_LOCAL_POLICY_EVAL_AT_SOURCE)\n", "    ctx->mark |= MARK_MAGIC_IDENTITY;\n", "    set_identity_mark (ctx, seclabel);\n", "    return redirect_ep (ctx, ep->ifindex, from_host);\n", "\n", "#else\n", "    ctx_store_meta (ctx, CB_SRC_LABEL, seclabel);\n", "    ctx_store_meta (ctx, CB_IFINDEX, ep->ifindex);\n", "    ctx_store_meta (ctx, CB_FROM_HOST, from_host ? 1 : 0);\n", "    tail_call_dynamic (ctx, &POLICY_CALL_MAP, ep->lxc_id);\n", "    return DROP_MISSED_TAIL_CALL;\n", "\n", "#endif\n", "}\n"], "called_function_list": ["ipv4_l3", "update_metrics", "tail_call_dynamic", "redirect_ep", "ctx_store_meta", "ctx_full_len", "set_identity_mark", "cilium_dbg"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "get_min_encrypt_key": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 157, "endLine": 185, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/l3.h", "funcName": "get_min_encrypt_key", "developer_inline_comments": [], "updateMaps": [], "readMaps": ["  ENCRYPT_MAP"], "input": ["__u8 peer_key __maybe_unused"], "output": "static__always_inline__u8", "helper": ["map_lookup_elem"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __u8 get_min_encrypt_key (__u8 peer_key __maybe_unused)\n", "{\n", "\n", "#ifdef ENABLE_IPSEC\n", "    __u8 local_key = 0;\n", "    __u32 encrypt_key = 0;\n", "    struct encrypt_config *cfg;\n", "    cfg = map_lookup_elem (& ENCRYPT_MAP, & encrypt_key);\n", "    if (cfg)\n", "        local_key = cfg->encrypt_key;\n", "    if (peer_key == MAX_KEY_INDEX)\n", "        return local_key == 1 ? peer_key : local_key;\n", "    if (local_key == MAX_KEY_INDEX)\n", "        return peer_key == 1 ? local_key : peer_key;\n", "    return local_key < peer_key ? local_key : peer_key;\n", "\n", "#else\n", "    return 0;\n", "\n", "#endif /* ENABLE_IPSEC */\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "send_signal": [{"capabilities": [], "helperCallParams": {}, "startLine": 36, "endLine": 41, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/signal.h", "funcName": "send_signal", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " struct signal_msg *msg"], "output": "static__always_inlinevoid", "helper": ["send_signal"], "compatibleHookpoints": ["kprobe", "raw_tracepoint", "raw_tracepoint_writable", "perf_event", "tracepoint"], "source": ["static __always_inline void send_signal (struct  __ctx_buff *ctx, struct signal_msg *msg)\n", "{\n", "    ctx_event_output (ctx, &SIGNAL_MAP, BPF_F_CURRENT_CPU, msg, sizeof (*msg));\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "send_signal_nat_fill_up": [{"capabilities": [], "helperCallParams": {}, "startLine": 43, "endLine": 52, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/signal.h", "funcName": "send_signal_nat_fill_up", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " __u32 proto"], "output": "static__always_inlinevoid", "helper": ["send_signal"], "compatibleHookpoints": ["kprobe", "raw_tracepoint", "raw_tracepoint_writable", "perf_event", "tracepoint"], "source": ["static __always_inline void send_signal_nat_fill_up (struct  __ctx_buff *ctx, __u32 proto)\n", "{\n", "    struct signal_msg msg = {\n", "        .signal_nr = SIGNAL_NAT_FILL_UP,\n", "        .proto = proto,}\n", "    ;\n", "    send_signal (ctx, &msg);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "send_signal_ct_fill_up": [{"capabilities": [], "helperCallParams": {}, "startLine": 54, "endLine": 63, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/signal.h", "funcName": "send_signal_ct_fill_up", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " __u32 proto"], "output": "static__always_inlinevoid", "helper": ["send_signal"], "compatibleHookpoints": ["kprobe", "raw_tracepoint", "raw_tracepoint_writable", "perf_event", "tracepoint"], "source": ["static __always_inline void send_signal_ct_fill_up (struct  __ctx_buff *ctx, __u32 proto)\n", "{\n", "    struct signal_msg msg = {\n", "        .signal_nr = SIGNAL_CT_FILL_UP,\n", "        .proto = proto,}\n", "    ;\n", "    send_signal (ctx, &msg);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ct_entry_seen_both_syns": [{"capabilities": [], "helperCallParams": {}, "startLine": 26, "endLine": 32, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h", "funcName": "ct_entry_seen_both_syns", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct ct_entry *entry"], "output": "static__always_inlinebool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline bool ct_entry_seen_both_syns (const struct ct_entry *entry)\n", "{\n", "    bool rx_syn = entry->rx_flags_seen & TCP_FLAG_SYN;\n", "    bool tx_syn = entry->tx_flags_seen & TCP_FLAG_SYN;\n", "    return rx_syn && tx_syn;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__ct_update_timeout": [{"capabilities": [], "helperCallParams": {}, "startLine": 62, "endLine": 126, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h", "funcName": "__ct_update_timeout", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct ct_entry *entry", " __u32 lifetime", " int dir", " union tcp_flags flags", " __u8 report_mask"], "output": "static__always_inline__u32", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __u32 __ct_update_timeout (struct ct_entry *entry, __u32 lifetime, int dir, union tcp_flags flags, __u8 report_mask)\n", "{\n", "    __u32 now = bpf_mono_now ();\n", "    __u8 accumulated_flags;\n", "    __u8 seen_flags = flags.lower_bits & report_mask;\n", "    __u32 last_report;\n", "    WRITE_ONCE (entry->lifetime, now + lifetime);\n", "    if (dir == CT_INGRESS) {\n", "        accumulated_flags = READ_ONCE (entry -> rx_flags_seen);\n", "        last_report = READ_ONCE (entry -> last_rx_report);\n", "    }\n", "    else {\n", "        accumulated_flags = READ_ONCE (entry -> tx_flags_seen);\n", "        last_report = READ_ONCE (entry -> last_tx_report);\n", "    }\n", "    seen_flags |= accumulated_flags;\n", "    if (last_report + bpf_sec_to_mono (CT_REPORT_INTERVAL) < now || accumulated_flags != seen_flags) {\n", "        if (dir == CT_INGRESS) {\n", "            WRITE_ONCE (entry->rx_flags_seen, seen_flags);\n", "            WRITE_ONCE (entry->last_rx_report, now);\n", "        }\n", "        else {\n", "            WRITE_ONCE (entry->tx_flags_seen, seen_flags);\n", "            WRITE_ONCE (entry->last_tx_report, now);\n", "        }\n", "        return TRACE_PAYLOAD_LEN;\n", "    }\n", "    return 0;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ct_update_timeout": [{"capabilities": [], "helperCallParams": {}, "startLine": 134, "endLine": 156, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h", "funcName": "ct_update_timeout", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct ct_entry *entry", " bool tcp", " int dir", " union tcp_flags seen_flags"], "output": "static__always_inline__u32", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __u32 ct_update_timeout (struct ct_entry *entry, bool tcp, int dir, union tcp_flags seen_flags)\n", "{\n", "    __u32 lifetime = dir == CT_SERVICE ? bpf_sec_to_mono (CT_SERVICE_LIFETIME_NONTCP) : bpf_sec_to_mono (CT_CONNECTION_LIFETIME_NONTCP);\n", "    bool syn = seen_flags.value & TCP_FLAG_SYN;\n", "    if (tcp) {\n", "        entry->seen_non_syn |= !syn;\n", "        if (entry->seen_non_syn) {\n", "            lifetime = dir == CT_SERVICE ? bpf_sec_to_mono (CT_SERVICE_LIFETIME_TCP) : bpf_sec_to_mono (CT_CONNECTION_LIFETIME_TCP);\n", "        }\n", "        else {\n", "            lifetime = bpf_sec_to_mono (CT_SYN_TIMEOUT);\n", "        }\n", "    }\n", "    return __ct_update_timeout (entry, lifetime, dir, seen_flags, CT_REPORT_FLAGS);\n", "}\n"], "called_function_list": ["__ct_update_timeout"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ct_reset_closing": [{"capabilities": [], "helperCallParams": {}, "startLine": 158, "endLine": 162, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h", "funcName": "ct_reset_closing", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct ct_entry *entry"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void ct_reset_closing (struct ct_entry *entry)\n", "{\n", "    entry->rx_closing = 0;\n", "    entry->tx_closing = 0;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ct_entry_alive": [{"capabilities": [], "helperCallParams": {}, "startLine": 164, "endLine": 167, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h", "funcName": "ct_entry_alive", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct ct_entry *entry"], "output": "static__always_inlinebool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline bool ct_entry_alive (const struct ct_entry *entry)\n", "{\n", "    return !entry->rx_closing || !entry->tx_closing;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ct_entry_closing": [{"capabilities": [], "helperCallParams": {}, "startLine": 169, "endLine": 172, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h", "funcName": "ct_entry_closing", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct ct_entry *entry"], "output": "static__always_inlinebool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline bool ct_entry_closing (const struct ct_entry *entry)\n", "{\n", "    return entry->tx_closing || entry->rx_closing;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ct_entry_expired_rebalance": [{"capabilities": [], "helperCallParams": {}, "startLine": 174, "endLine": 183, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h", "funcName": "ct_entry_expired_rebalance", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct ct_entry *entry"], "output": "static__always_inlinebool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline bool ct_entry_expired_rebalance (const struct ct_entry *entry)\n", "{\n", "    __u32 wait_time = bpf_sec_to_mono (CT_SERVICE_CLOSE_REBALANCE);\n", "    return READ_ONCE (entry->last_tx_report) + wait_time <= bpf_mono_now ();\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__ct_lookup": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 185, "endLine": 273, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h", "funcName": "__ct_lookup", "developer_inline_comments": [], "updateMaps": [], "readMaps": [" map"], "input": ["const void *map", " struct  __ctx_buff *ctx", " const void *tuple", " int action", " int dir", " struct ct_state *ct_state", " bool is_tcp", " union tcp_flags seen_flags", " __u32 *monitor"], "output": "static__always_inline__u8", "helper": ["map_lookup_elem"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __u8 __ct_lookup (const void *map, struct  __ctx_buff *ctx, const void *tuple, int action, int dir, struct ct_state *ct_state, bool is_tcp, union tcp_flags seen_flags, __u32 *monitor)\n", "{\n", "    bool syn = seen_flags.value & TCP_FLAG_SYN;\n", "    struct ct_entry *entry;\n", "    int reopen;\n", "    relax_verifier ();\n", "    entry = map_lookup_elem (map, tuple);\n", "    if (entry) {\n", "        cilium_dbg (ctx, DBG_CT_MATCH, entry->lifetime, entry->rev_nat_index);\n", "\n", "#ifdef HAVE_LARGE_INSN_LIMIT\n", "        if (dir == CT_SERVICE && syn && ct_entry_closing (entry) && ct_entry_expired_rebalance (entry))\n", "            goto ct_new;\n", "\n", "#endif\n", "        if (ct_entry_alive (entry))\n", "            *monitor = ct_update_timeout (entry, is_tcp, dir, seen_flags);\n", "        if (ct_state) {\n", "            ct_state->rev_nat_index = entry->rev_nat_index;\n", "            ct_state->loopback = entry->lb_loopback;\n", "            ct_state->node_port = entry->node_port;\n", "            ct_state->ifindex = entry->ifindex;\n", "            ct_state->dsr = entry->dsr;\n", "            ct_state->proxy_redirect = entry->proxy_redirect;\n", "            ct_state->from_l7lb = entry->from_l7lb;\n", "            if (dir == CT_SERVICE) {\n", "                ct_state->backend_id = entry->backend_id;\n", "                ct_state->syn = syn;\n", "            }\n", "        }\n", "\n", "#ifdef CONNTRACK_ACCOUNTING\n", "        if (dir == CT_INGRESS) {\n", "            __sync_fetch_and_add (&entry->rx_packets, 1);\n", "            __sync_fetch_and_add (&entry->rx_bytes, ctx_full_len (ctx));\n", "        }\n", "        else if (dir == CT_EGRESS) {\n", "            __sync_fetch_and_add (&entry->tx_packets, 1);\n", "            __sync_fetch_and_add (&entry->tx_bytes, ctx_full_len (ctx));\n", "        }\n", "\n", "#endif\n", "        switch (action) {\n", "        case ACTION_CREATE :\n", "            reopen = entry->rx_closing | entry->tx_closing;\n", "            reopen |= seen_flags.value & TCP_FLAG_SYN;\n", "            if (unlikely (reopen == (TCP_FLAG_SYN | 0x1))) {\n", "                ct_reset_closing (entry);\n", "                *monitor = ct_update_timeout (entry, is_tcp, dir, seen_flags);\n", "                return CT_REOPENED;\n", "            }\n", "            break;\n", "        case ACTION_CLOSE :\n", "            if (!ct_entry_seen_both_syns (entry) && (seen_flags.value & TCP_FLAG_RST) && dir != CT_SERVICE) {\n", "                entry->rx_closing = 1;\n", "                entry->tx_closing = 1;\n", "            }\n", "            else if (dir == CT_INGRESS) {\n", "                entry->rx_closing = 1;\n", "            }\n", "            else {\n", "                entry->tx_closing = 1;\n", "            }\n", "            *monitor = TRACE_PAYLOAD_LEN;\n", "            if (ct_entry_alive (entry))\n", "                break;\n", "            __ct_update_timeout (entry, bpf_sec_to_mono (CT_CLOSE_TIMEOUT), dir, seen_flags, CT_REPORT_FLAGS);\n", "            break;\n", "        }\n", "        return CT_ESTABLISHED;\n", "    }\n", "ct_new :\n", "    __maybe_unused * monitor = TRACE_PAYLOAD_LEN;\n", "    return CT_NEW;\n", "}\n"], "called_function_list": ["__ct_update_timeout", "ct_entry_seen_both_syns", "ct_entry_expired_rebalance", "ct_entry_alive", "ct_update_timeout", "ctx_full_len", "ct_entry_closing", "ct_reset_closing", "relax_verifier", "cilium_dbg"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ipv6_extract_tuple": [{"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 275, "endLine": 303, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h", "funcName": "ipv6_extract_tuple", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " struct ipv6_ct_tuple *tuple", " int *l4_off"], "output": "static__always_inlineint", "helper": ["CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["static __always_inline int ipv6_extract_tuple (struct  __ctx_buff *ctx, struct ipv6_ct_tuple *tuple, int *l4_off)\n", "{\n", "    int ret, l3_off = ETH_HLEN;\n", "    void *data, *data_end;\n", "    struct ipv6hdr *ip6;\n", "    if (!revalidate_data (ctx, &data, &data_end, &ip6))\n", "        return DROP_INVALID;\n", "    tuple->nexthdr = ip6->nexthdr;\n", "    ipv6_addr_copy (&tuple->daddr, (union v6addr *) &ip6->daddr);\n", "    ipv6_addr_copy (&tuple->saddr, (union v6addr *) &ip6->saddr);\n", "    ret = ipv6_hdrlen (ctx, & tuple -> nexthdr);\n", "    if (ret < 0)\n", "        return ret;\n", "    if (unlikely (tuple->nexthdr != IPPROTO_TCP && tuple->nexthdr != IPPROTO_UDP))\n", "        return DROP_CT_UNKNOWN_PROTO;\n", "    if (ret < 0)\n", "        return ret;\n", "    *l4_off = l3_off + ret;\n", "    return CTX_ACT_OK;\n", "}\n"], "called_function_list": ["ipv6_hdrlen", "ipv6_addr_copy"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ct_flip_tuple_dir6": [{"capabilities": [], "helperCallParams": {}, "startLine": 305, "endLine": 311, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h", "funcName": "ct_flip_tuple_dir6", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct ipv6_ct_tuple *tuple"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void ct_flip_tuple_dir6 (struct ipv6_ct_tuple *tuple)\n", "{\n", "    if (tuple->flags & TUPLE_F_IN)\n", "        tuple->flags &= ~TUPLE_F_IN;\n", "    else\n", "        tuple->flags |= TUPLE_F_IN;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__ipv6_ct_tuple_reverse": [{"capabilities": [], "helperCallParams": {}, "startLine": 313, "endLine": 326, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h", "funcName": "__ipv6_ct_tuple_reverse", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct ipv6_ct_tuple *tuple"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void __ipv6_ct_tuple_reverse (struct ipv6_ct_tuple *tuple)\n", "{\n", "    union v6addr tmp_addr = {}\n", "    ;\n", "    __be16 tmp;\n", "    ipv6_addr_copy (&tmp_addr, &tuple->saddr);\n", "    ipv6_addr_copy (&tuple->saddr, &tuple->daddr);\n", "    ipv6_addr_copy (&tuple->daddr, &tmp_addr);\n", "    tmp = tuple->sport;\n", "    tuple->sport = tuple->dport;\n", "    tuple->dport = tmp;\n", "}\n"], "called_function_list": ["ipv6_addr_copy"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ipv6_ct_tuple_reverse": [{"capabilities": [], "helperCallParams": {}, "startLine": 328, "endLine": 333, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h", "funcName": "ipv6_ct_tuple_reverse", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct ipv6_ct_tuple *tuple"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void ipv6_ct_tuple_reverse (struct ipv6_ct_tuple *tuple)\n", "{\n", "    __ipv6_ct_tuple_reverse (tuple);\n", "    ct_flip_tuple_dir6 (tuple);\n", "}\n"], "called_function_list": ["__ipv6_ct_tuple_reverse", "ct_flip_tuple_dir6"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ct_lookup6": [{"capabilities": [], "helperCallParams": {}, "startLine": 336, "endLine": 459, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h", "funcName": "ct_lookup6", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const void *map", " struct ipv6_ct_tuple *tuple", " struct  __ctx_buff *ctx", " int l4_off", " int dir", " struct ct_state *ct_state", " __u32 *monitor"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int ct_lookup6 (const void *map, struct ipv6_ct_tuple *tuple, struct  __ctx_buff *ctx, int l4_off, int dir, struct ct_state *ct_state, __u32 *monitor)\n", "{\n", "    int ret = CT_NEW, action = ACTION_UNSPEC;\n", "    bool is_tcp = tuple->nexthdr == IPPROTO_TCP;\n", "    union tcp_flags tcp_flags = {\n", "        .value = 0}\n", "    ;\n", "    if (dir == CT_INGRESS)\n", "        tuple->flags = TUPLE_F_OUT;\n", "    else if (dir == CT_EGRESS)\n", "        tuple->flags = TUPLE_F_IN;\n", "    else if (dir == CT_SERVICE)\n", "        tuple->flags = TUPLE_F_SERVICE;\n", "    else\n", "        return DROP_CT_INVALID_HDR;\n", "    switch (tuple->nexthdr) {\n", "    case IPPROTO_ICMPV6 :\n", "        if (1) {\n", "            __be16 identifier = 0;\n", "            __u8 type;\n", "            if (ctx_load_bytes (ctx, l4_off, &type, 1) < 0)\n", "                return DROP_CT_INVALID_HDR;\n", "            if ((type == ICMPV6_ECHO_REQUEST || type == ICMPV6_ECHO_REPLY) && ctx_load_bytes (ctx, l4_off + offsetof (struct icmp6hdr, icmp6_dataun.u_echo.identifier), &identifier, 2) < 0)\n", "                return DROP_CT_INVALID_HDR;\n", "            tuple->sport = 0;\n", "            tuple->dport = 0;\n", "            switch (type) {\n", "            case ICMPV6_DEST_UNREACH :\n", "            case ICMPV6_PKT_TOOBIG :\n", "            case ICMPV6_TIME_EXCEED :\n", "            case ICMPV6_PARAMPROB :\n", "                tuple->flags |= TUPLE_F_RELATED;\n", "                break;\n", "            case ICMPV6_ECHO_REPLY :\n", "                tuple->sport = identifier;\n", "                break;\n", "            case ICMPV6_ECHO_REQUEST :\n", "                tuple->dport = identifier;\n", "            default :\n", "                action = ACTION_CREATE;\n", "                break;\n", "            }\n", "        }\n", "        break;\n", "    case IPPROTO_TCP :\n", "        if (1) {\n", "            if (ctx_load_bytes (ctx, l4_off + 12, &tcp_flags, 2) < 0)\n", "                return DROP_CT_INVALID_HDR;\n", "            if (unlikely (tcp_flags.value & (TCP_FLAG_RST | TCP_FLAG_FIN)))\n", "                action = ACTION_CLOSE;\n", "            else\n", "                action = ACTION_CREATE;\n", "        }\n", "        if (ctx_load_bytes (ctx, l4_off, &tuple->dport, 4) < 0)\n", "            return DROP_CT_INVALID_HDR;\n", "        break;\n", "    case IPPROTO_UDP :\n", "        if (ctx_load_bytes (ctx, l4_off, &tuple->dport, 4) < 0)\n", "            return DROP_CT_INVALID_HDR;\n", "        action = ACTION_CREATE;\n", "        break;\n", "    default :\n", "        return DROP_CT_UNKNOWN_PROTO;\n", "    }\n", "    cilium_dbg3 (ctx, DBG_CT_LOOKUP6_1, (__u32) tuple->saddr.p4, (__u32) tuple->daddr.p4, (bpf_ntohs (tuple->sport) << 16) | bpf_ntohs (tuple->dport));\n", "    cilium_dbg3 (ctx, DBG_CT_LOOKUP6_2, (tuple->nexthdr << 8) | tuple->flags, 0, 0);\n", "    ret = __ct_lookup (map, ctx, tuple, action, dir, ct_state, is_tcp, tcp_flags, monitor);\n", "    if (ret != CT_NEW) {\n", "        if (likely (ret == CT_ESTABLISHED || ret == CT_REOPENED)) {\n", "            if (unlikely (tuple->flags & TUPLE_F_RELATED))\n", "                ret = CT_RELATED;\n", "            else\n", "                ret = CT_REPLY;\n", "        }\n", "        goto out;\n", "    }\n", "    if (dir != CT_SERVICE) {\n", "        ipv6_ct_tuple_reverse (tuple);\n", "        ret = __ct_lookup (map, ctx, tuple, action, dir, ct_state, is_tcp, tcp_flags, monitor);\n", "    }\n", "out :\n", "    cilium_dbg (ctx, DBG_CT_VERDICT, ret < 0 ? -ret : ret, ct_state->rev_nat_index);\n", "    return ret;\n", "}\n"], "called_function_list": ["cilium_dbg3", "__ct_lookup", "cilium_dbg", "ipv6_ct_tuple_reverse"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ipv4_extract_tuple": [{"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 461, "endLine": 483, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h", "funcName": "ipv4_extract_tuple", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " struct ipv4_ct_tuple *tuple", " int *l4_off"], "output": "static__always_inlineint", "helper": ["CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["static __always_inline int ipv4_extract_tuple (struct  __ctx_buff *ctx, struct ipv4_ct_tuple *tuple, int *l4_off)\n", "{\n", "    int l3_off = ETH_HLEN;\n", "    void *data, *data_end;\n", "    struct iphdr *ip4;\n", "    if (!revalidate_data (ctx, &data, &data_end, &ip4))\n", "        return DROP_INVALID;\n", "    tuple->nexthdr = ip4->protocol;\n", "    if (unlikely (tuple->nexthdr != IPPROTO_TCP && tuple->nexthdr != IPPROTO_UDP))\n", "        return DROP_CT_UNKNOWN_PROTO;\n", "    tuple->daddr = ip4->daddr;\n", "    tuple->saddr = ip4->saddr;\n", "    *l4_off = l3_off + ipv4_hdrlen (ip4);\n", "    return CTX_ACT_OK;\n", "}\n"], "called_function_list": ["ipv4_hdrlen"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ct_flip_tuple_dir4": [{"capabilities": [], "helperCallParams": {}, "startLine": 485, "endLine": 491, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h", "funcName": "ct_flip_tuple_dir4", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct ipv4_ct_tuple *tuple"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void ct_flip_tuple_dir4 (struct ipv4_ct_tuple *tuple)\n", "{\n", "    if (tuple->flags & TUPLE_F_IN)\n", "        tuple->flags &= ~TUPLE_F_IN;\n", "    else\n", "        tuple->flags |= TUPLE_F_IN;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__ipv4_ct_tuple_reverse": [{"capabilities": [], "helperCallParams": {}, "startLine": 493, "endLine": 505, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h", "funcName": "__ipv4_ct_tuple_reverse", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct ipv4_ct_tuple *tuple"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void __ipv4_ct_tuple_reverse (struct ipv4_ct_tuple *tuple)\n", "{\n", "    __be32 tmp_addr = tuple->saddr;\n", "    __be16 tmp;\n", "    tuple->saddr = tuple->daddr;\n", "    tuple->daddr = tmp_addr;\n", "    tmp = tuple->sport;\n", "    tuple->sport = tuple->dport;\n", "    tuple->dport = tmp;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ipv4_ct_tuple_reverse": [{"capabilities": [], "helperCallParams": {}, "startLine": 507, "endLine": 512, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h", "funcName": "ipv4_ct_tuple_reverse", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct ipv4_ct_tuple *tuple"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void ipv4_ct_tuple_reverse (struct ipv4_ct_tuple *tuple)\n", "{\n", "    __ipv4_ct_tuple_reverse (tuple);\n", "    ct_flip_tuple_dir4 (tuple);\n", "}\n"], "called_function_list": ["__ipv4_ct_tuple_reverse", "ct_flip_tuple_dir4"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ipv4_ct_extract_l4_ports": [{"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 514, "endLine": 540, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h", "funcName": "ipv4_ct_extract_l4_ports", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " int off", " enum ct_dir dir __maybe_unused", " struct ipv4_ct_tuple *tuple", " bool * has_l4_header __maybe_unused"], "output": "static__always_inlineint", "helper": ["CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["static __always_inline int ipv4_ct_extract_l4_ports (struct  __ctx_buff *ctx, int off, enum ct_dir dir __maybe_unused, struct ipv4_ct_tuple *tuple, bool * has_l4_header __maybe_unused)\n", "{\n", "\n", "#ifdef ENABLE_IPV4_FRAGMENTS\n", "    void *data, *data_end;\n", "    struct iphdr *ip4;\n", "    if (!revalidate_data (ctx, &data, &data_end, &ip4))\n", "        return DROP_CT_INVALID_HDR;\n", "    return ipv4_handle_fragmentation (ctx, ip4, off, dir, (struct ipv4_frag_l4ports *) &tuple->dport, has_l4_header);\n", "\n", "#else\n", "    if (ctx_load_bytes (ctx, off, &tuple->dport, 4) < 0)\n", "        return DROP_CT_INVALID_HDR;\n", "\n", "#endif\n", "    return CTX_ACT_OK;\n", "}\n"], "called_function_list": ["ipv4_handle_fragmentation"], "call_depth": 5, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ct4_cilium_dbg_tuple": [{"capabilities": [], "helperCallParams": {}, "startLine": 542, "endLine": 549, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h", "funcName": "ct4_cilium_dbg_tuple", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " __u8 type", " const struct ipv4_ct_tuple *tuple", " __u32 rev_nat_index", " int dir"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void ct4_cilium_dbg_tuple (struct  __ctx_buff *ctx, __u8 type, const struct ipv4_ct_tuple *tuple, __u32 rev_nat_index, int dir)\n", "{\n", "    __be32 addr = (dir == CT_INGRESS) ? tuple->saddr : tuple->daddr;\n", "    cilium_dbg (ctx, type, addr, rev_nat_index);\n", "}\n"], "called_function_list": ["cilium_dbg"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ct_extract_ports4": [{"capabilities": [], "helperCallParams": {}, "startLine": 551, "endLine": 606, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h", "funcName": "ct_extract_ports4", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " int off", " enum ct_dir dir", " struct ipv4_ct_tuple *tuple"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int ct_extract_ports4 (struct  __ctx_buff *ctx, int off, enum ct_dir dir, struct ipv4_ct_tuple *tuple)\n", "{\n", "    int err;\n", "    switch (tuple->nexthdr) {\n", "    case IPPROTO_ICMP :\n", "        if (1) {\n", "            __be16 identifier = 0;\n", "            __u8 type;\n", "            if (ctx_load_bytes (ctx, off, &type, 1) < 0)\n", "                return DROP_CT_INVALID_HDR;\n", "            if ((type == ICMP_ECHO || type == ICMP_ECHOREPLY) && ctx_load_bytes (ctx, off + offsetof (struct icmphdr, un.echo.id), &identifier, 2) < 0)\n", "                return DROP_CT_INVALID_HDR;\n", "            tuple->sport = 0;\n", "            tuple->dport = 0;\n", "            switch (type) {\n", "            case ICMP_DEST_UNREACH :\n", "            case ICMP_TIME_EXCEEDED :\n", "            case ICMP_PARAMETERPROB :\n", "                tuple->flags |= TUPLE_F_RELATED;\n", "                break;\n", "            case ICMP_ECHOREPLY :\n", "                tuple->sport = identifier;\n", "                break;\n", "            case ICMP_ECHO :\n", "                tuple->dport = identifier;\n", "            default :\n", "                break;\n", "            }\n", "        }\n", "        break;\n", "    case IPPROTO_TCP :\n", "    case IPPROTO_UDP :\n", "        err = ipv4_ct_extract_l4_ports (ctx, off, dir, tuple, NULL);\n", "        if (err < 0)\n", "            return err;\n", "        break;\n", "    default :\n", "        return DROP_CT_UNKNOWN_PROTO;\n", "    }\n", "    return 0;\n", "}\n"], "called_function_list": ["ipv4_ct_extract_l4_ports"], "call_depth": 6, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ct_is_reply4": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 616, "endLine": 631, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h", "funcName": "ct_is_reply4", "developer_inline_comments": [], "updateMaps": [], "readMaps": [" map"], "input": ["const void *map", " struct  __ctx_buff *ctx", " int off", " struct ipv4_ct_tuple *tuple", " bool *is_reply"], "output": "static__always_inlineint", "helper": ["map_lookup_elem"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int ct_is_reply4 (const void *map, struct  __ctx_buff *ctx, int off, struct ipv4_ct_tuple *tuple, bool *is_reply)\n", "{\n", "    int err = 0;\n", "    err = ct_extract_ports4 (ctx, off, CT_EGRESS, tuple);\n", "    if (err < 0)\n", "        return err;\n", "    tuple->flags = TUPLE_F_IN;\n", "    *is_reply = map_lookup_elem (map, tuple) != NULL;\n", "    return 0;\n", "}\n"], "called_function_list": ["ct_extract_ports4"], "call_depth": 7, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ct_lookup4": [{"capabilities": [], "helperCallParams": {}, "startLine": 634, "endLine": 757, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h", "funcName": "ct_lookup4", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const void *map", " struct ipv4_ct_tuple *tuple", " struct  __ctx_buff *ctx", " int off", " enum ct_dir dir", " struct ct_state *ct_state", " __u32 *monitor"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int ct_lookup4 (const void *map, struct ipv4_ct_tuple *tuple, struct  __ctx_buff *ctx, int off, enum ct_dir dir, struct ct_state *ct_state, __u32 *monitor)\n", "{\n", "    int err, ret = CT_NEW, action = ACTION_UNSPEC;\n", "    bool is_tcp = tuple->nexthdr == IPPROTO_TCP, has_l4_header = true;\n", "    union tcp_flags tcp_flags = {\n", "        .value = 0}\n", "    ;\n", "    if (dir == CT_INGRESS)\n", "        tuple->flags = TUPLE_F_OUT;\n", "    else if (dir == CT_EGRESS)\n", "        tuple->flags = TUPLE_F_IN;\n", "    else if (dir == CT_SERVICE)\n", "        tuple->flags = TUPLE_F_SERVICE;\n", "    else\n", "        return DROP_CT_INVALID_HDR;\n", "    switch (tuple->nexthdr) {\n", "    case IPPROTO_ICMP :\n", "        if (1) {\n", "            __be16 identifier = 0;\n", "            __u8 type;\n", "            if (ctx_load_bytes (ctx, off, &type, 1) < 0)\n", "                return DROP_CT_INVALID_HDR;\n", "            if ((type == ICMP_ECHO || type == ICMP_ECHOREPLY) && ctx_load_bytes (ctx, off + offsetof (struct icmphdr, un.echo.id), &identifier, 2) < 0)\n", "                return DROP_CT_INVALID_HDR;\n", "            tuple->sport = 0;\n", "            tuple->dport = 0;\n", "            switch (type) {\n", "            case ICMP_DEST_UNREACH :\n", "            case ICMP_TIME_EXCEEDED :\n", "            case ICMP_PARAMETERPROB :\n", "                tuple->flags |= TUPLE_F_RELATED;\n", "                break;\n", "            case ICMP_ECHOREPLY :\n", "                tuple->sport = identifier;\n", "                break;\n", "            case ICMP_ECHO :\n", "                tuple->dport = identifier;\n", "            default :\n", "                action = ACTION_CREATE;\n", "                break;\n", "            }\n", "        }\n", "        break;\n", "    case IPPROTO_TCP :\n", "        err = ipv4_ct_extract_l4_ports (ctx, off, dir, tuple, &has_l4_header);\n", "        if (err < 0)\n", "            return err;\n", "        action = ACTION_CREATE;\n", "        if (has_l4_header) {\n", "            if (ctx_load_bytes (ctx, off + 12, &tcp_flags, 2) < 0)\n", "                return DROP_CT_INVALID_HDR;\n", "            if (unlikely (tcp_flags.value & (TCP_FLAG_RST | TCP_FLAG_FIN)))\n", "                action = ACTION_CLOSE;\n", "        }\n", "        break;\n", "    case IPPROTO_UDP :\n", "        err = ipv4_ct_extract_l4_ports (ctx, off, dir, tuple, NULL);\n", "        if (err < 0)\n", "            return err;\n", "        action = ACTION_CREATE;\n", "        break;\n", "    default :\n", "        return DROP_CT_UNKNOWN_PROTO;\n", "    }\n", "\n", "#ifndef QUIET_CT\n", "    cilium_dbg3 (ctx, DBG_CT_LOOKUP4_1, tuple->saddr, tuple->daddr, (bpf_ntohs (tuple->sport) << 16) | bpf_ntohs (tuple->dport));\n", "    cilium_dbg3 (ctx, DBG_CT_LOOKUP4_2, (tuple->nexthdr << 8) | tuple->flags, 0, 0);\n", "\n", "#endif\n", "    ret = __ct_lookup (map, ctx, tuple, action, dir, ct_state, is_tcp, tcp_flags, monitor);\n", "    if (ret != CT_NEW) {\n", "        if (likely (ret == CT_ESTABLISHED || ret == CT_REOPENED)) {\n", "            if (unlikely (tuple->flags & TUPLE_F_RELATED))\n", "                ret = CT_RELATED;\n", "            else\n", "                ret = CT_REPLY;\n", "        }\n", "        goto out;\n", "    }\n", "    relax_verifier ();\n", "    if (dir != CT_SERVICE) {\n", "        ipv4_ct_tuple_reverse (tuple);\n", "        ret = __ct_lookup (map, ctx, tuple, action, dir, ct_state, is_tcp, tcp_flags, monitor);\n", "    }\n", "out :\n", "    cilium_dbg (ctx, DBG_CT_VERDICT, ret < 0 ? -ret : ret, ct_state->rev_nat_index);\n", "    return ret;\n", "}\n"], "called_function_list": ["cilium_dbg3", "ipv4_ct_tuple_reverse", "__ct_lookup", "relax_verifier", "cilium_dbg", "ipv4_ct_extract_l4_ports"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ct_update6_backend_id": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 759, "endLine": 770, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h", "funcName": "ct_update6_backend_id", "developer_inline_comments": [], "updateMaps": [], "readMaps": [" map"], "input": ["const void *map", " const struct ipv6_ct_tuple *tuple", " const struct ct_state *state"], "output": "static__always_inlinevoid", "helper": ["map_lookup_elem"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void ct_update6_backend_id (const void *map, const struct ipv6_ct_tuple *tuple, const struct ct_state *state)\n", "{\n", "    struct ct_entry *entry;\n", "    entry = map_lookup_elem (map, tuple);\n", "    if (!entry)\n", "        return;\n", "    entry->backend_id = state->backend_id;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ct_update6_rev_nat_index": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 772, "endLine": 783, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h", "funcName": "ct_update6_rev_nat_index", "developer_inline_comments": [], "updateMaps": [], "readMaps": [" map"], "input": ["const void *map", " const struct ipv6_ct_tuple *tuple", " const struct ct_state *state"], "output": "static__always_inlinevoid", "helper": ["map_lookup_elem"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void ct_update6_rev_nat_index (const void *map, const struct ipv6_ct_tuple *tuple, const struct ct_state *state)\n", "{\n", "    struct ct_entry *entry;\n", "    entry = map_lookup_elem (map, tuple);\n", "    if (!entry)\n", "        return;\n", "    entry->rev_nat_index = state->rev_nat_index;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ct_update6_dsr": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 785, "endLine": 796, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h", "funcName": "ct_update6_dsr", "developer_inline_comments": [], "updateMaps": [], "readMaps": [" map"], "input": ["const void *map", " const struct ipv6_ct_tuple *tuple", " const bool dsr"], "output": "static__always_inlinevoid", "helper": ["map_lookup_elem"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void ct_update6_dsr (const void *map, const struct ipv6_ct_tuple *tuple, const bool dsr)\n", "{\n", "    struct ct_entry *entry;\n", "    entry = map_lookup_elem (map, tuple);\n", "    if (!entry)\n", "        return;\n", "    entry->dsr = dsr;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ct_create6": [{"capabilities": [], "helperCallParams": {}, "startLine": 799, "endLine": 865, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h", "funcName": "ct_create6", "developer_inline_comments": [], "updateMaps": [" map_related", " map_main"], "readMaps": [], "input": ["const void *map_main", " const void *map_related", " struct ipv6_ct_tuple *tuple", " struct  __ctx_buff *ctx", " const int dir", " const struct ct_state *ct_state", " bool proxy_redirect", " bool from_l7lb"], "output": "static__always_inlineint", "helper": ["send_signal"], "compatibleHookpoints": ["kprobe", "raw_tracepoint", "raw_tracepoint_writable", "perf_event", "tracepoint"], "source": ["static __always_inline int ct_create6 (const void *map_main, const void *map_related, struct ipv6_ct_tuple *tuple, struct  __ctx_buff *ctx, const int dir, const struct ct_state *ct_state, bool proxy_redirect, bool from_l7lb)\n", "{\n", "    struct ct_entry entry = {}\n", "    ;\n", "    bool is_tcp = tuple->nexthdr == IPPROTO_TCP;\n", "    union tcp_flags seen_flags = {\n", "        .value = 0}\n", "    ;\n", "    entry.proxy_redirect = proxy_redirect;\n", "    entry.from_l7lb = from_l7lb;\n", "    if (dir == CT_SERVICE)\n", "        entry.backend_id = ct_state->backend_id;\n", "    entry.lb_loopback = ct_state->loopback;\n", "    entry.node_port = ct_state->node_port;\n", "    relax_verifier ();\n", "    entry.dsr = ct_state->dsr;\n", "    entry.ifindex = ct_state->ifindex;\n", "    entry.rev_nat_index = ct_state->rev_nat_index;\n", "    seen_flags.value |= is_tcp ? TCP_FLAG_SYN : 0;\n", "    ct_update_timeout (&entry, is_tcp, dir, seen_flags);\n", "    if (dir == CT_INGRESS) {\n", "        entry.rx_packets = 1;\n", "        entry.rx_bytes = ctx_full_len (ctx);\n", "    }\n", "    else if (dir == CT_EGRESS) {\n", "        entry.tx_packets = 1;\n", "        entry.tx_bytes = ctx_full_len (ctx);\n", "    }\n", "    cilium_dbg3 (ctx, DBG_CT_CREATED6, entry.rev_nat_index, ct_state->src_sec_id, 0);\n", "    entry.src_sec_id = ct_state->src_sec_id;\n", "    if (map_update_elem (map_main, tuple, &entry, 0) < 0) {\n", "        send_signal_ct_fill_up (ctx, SIGNAL_PROTO_V6);\n", "        return DROP_CT_CREATE_FAILED;\n", "    }\n", "    if (map_related != NULL) {\n", "        struct ipv6_ct_tuple icmp_tuple = {\n", "            .nexthdr = IPPROTO_ICMPV6,\n", "            .sport = 0,\n", "            .dport = 0,\n", "            .flags = tuple->flags | TUPLE_F_RELATED,}\n", "        ;\n", "        entry.seen_non_syn = true;\n", "        ipv6_addr_copy (&icmp_tuple.daddr, &tuple->daddr);\n", "        ipv6_addr_copy (&icmp_tuple.saddr, &tuple->saddr);\n", "        if (map_update_elem (map_related, &icmp_tuple, &entry, 0) < 0) {\n", "            send_signal_ct_fill_up (ctx, SIGNAL_PROTO_V6);\n", "            return DROP_CT_CREATE_FAILED;\n", "        }\n", "    }\n", "    return 0;\n", "}\n"], "called_function_list": ["cilium_dbg3", "ct_update_timeout", "ctx_full_len", "relax_verifier", "ipv6_addr_copy", "send_signal_ct_fill_up"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ct_update4_backend_id": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 867, "endLine": 878, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h", "funcName": "ct_update4_backend_id", "developer_inline_comments": [], "updateMaps": [], "readMaps": [" map"], "input": ["const void *map", " const struct ipv4_ct_tuple *tuple", " const struct ct_state *state"], "output": "static__always_inlinevoid", "helper": ["map_lookup_elem"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void ct_update4_backend_id (const void *map, const struct ipv4_ct_tuple *tuple, const struct ct_state *state)\n", "{\n", "    struct ct_entry *entry;\n", "    entry = map_lookup_elem (map, tuple);\n", "    if (!entry)\n", "        return;\n", "    entry->backend_id = state->backend_id;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ct_update4_rev_nat_index": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 880, "endLine": 891, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h", "funcName": "ct_update4_rev_nat_index", "developer_inline_comments": [], "updateMaps": [], "readMaps": [" map"], "input": ["const void *map", " const struct ipv4_ct_tuple *tuple", " const struct ct_state *state"], "output": "static__always_inlinevoid", "helper": ["map_lookup_elem"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void ct_update4_rev_nat_index (const void *map, const struct ipv4_ct_tuple *tuple, const struct ct_state *state)\n", "{\n", "    struct ct_entry *entry;\n", "    entry = map_lookup_elem (map, tuple);\n", "    if (!entry)\n", "        return;\n", "    entry->rev_nat_index = state->rev_nat_index;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ct_update4_dsr": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 893, "endLine": 904, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h", "funcName": "ct_update4_dsr", "developer_inline_comments": [], "updateMaps": [], "readMaps": [" map"], "input": ["const void *map", " const struct ipv4_ct_tuple *tuple", " const bool dsr"], "output": "static__always_inlinevoid", "helper": ["map_lookup_elem"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void ct_update4_dsr (const void *map, const struct ipv4_ct_tuple *tuple, const bool dsr)\n", "{\n", "    struct ct_entry *entry;\n", "    entry = map_lookup_elem (map, tuple);\n", "    if (!entry)\n", "        return;\n", "    entry->dsr = dsr;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ct_create4": [{"capabilities": [], "helperCallParams": {}, "startLine": 906, "endLine": 1006, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h", "funcName": "ct_create4", "developer_inline_comments": [], "updateMaps": [" map_related", " map_main"], "readMaps": [], "input": ["const void *map_main", " const void *map_related", " struct ipv4_ct_tuple *tuple", " struct  __ctx_buff *ctx", " const int dir", " const struct ct_state *ct_state", " bool proxy_redirect", " bool from_l7lb"], "output": "static__always_inlineint", "helper": ["send_signal"], "compatibleHookpoints": ["kprobe", "raw_tracepoint", "raw_tracepoint_writable", "perf_event", "tracepoint"], "source": ["static __always_inline int ct_create4 (const void *map_main, const void *map_related, struct ipv4_ct_tuple *tuple, struct  __ctx_buff *ctx, const int dir, const struct ct_state *ct_state, bool proxy_redirect, bool from_l7lb)\n", "{\n", "    struct ct_entry entry = {}\n", "    ;\n", "    bool is_tcp = tuple->nexthdr == IPPROTO_TCP;\n", "    union tcp_flags seen_flags = {\n", "        .value = 0}\n", "    ;\n", "    entry.proxy_redirect = proxy_redirect;\n", "    entry.from_l7lb = from_l7lb;\n", "    entry.lb_loopback = ct_state->loopback;\n", "    entry.node_port = ct_state->node_port;\n", "    relax_verifier ();\n", "    entry.dsr = ct_state->dsr;\n", "    entry.ifindex = ct_state->ifindex;\n", "    if (dir == CT_SERVICE)\n", "        entry.backend_id = ct_state->backend_id;\n", "    entry.rev_nat_index = ct_state->rev_nat_index;\n", "    seen_flags.value |= is_tcp ? TCP_FLAG_SYN : 0;\n", "    ct_update_timeout (&entry, is_tcp, dir, seen_flags);\n", "    if (dir == CT_INGRESS) {\n", "        entry.rx_packets = 1;\n", "        entry.rx_bytes = ctx_full_len (ctx);\n", "    }\n", "    else if (dir == CT_EGRESS) {\n", "        entry.tx_packets = 1;\n", "        entry.tx_bytes = ctx_full_len (ctx);\n", "    }\n", "    cilium_dbg3 (ctx, DBG_CT_CREATED4, entry.rev_nat_index, ct_state->src_sec_id, ct_state->addr);\n", "    entry.src_sec_id = ct_state->src_sec_id;\n", "    if (map_update_elem (map_main, tuple, &entry, 0) < 0) {\n", "        send_signal_ct_fill_up (ctx, SIGNAL_PROTO_V4);\n", "        return DROP_CT_CREATE_FAILED;\n", "    }\n", "    if (ct_state->addr && ct_state->loopback) {\n", "        __u8 flags = tuple->flags;\n", "        __be32 saddr, daddr;\n", "        saddr = tuple->saddr;\n", "        daddr = tuple->daddr;\n", "        tuple->flags = TUPLE_F_IN;\n", "        if (dir == CT_INGRESS) {\n", "            tuple->saddr = ct_state->addr;\n", "            tuple->daddr = ct_state->svc_addr;\n", "        }\n", "        else {\n", "            tuple->saddr = ct_state->svc_addr;\n", "            tuple->daddr = ct_state->addr;\n", "        }\n", "        if (map_update_elem (map_main, tuple, &entry, 0) < 0) {\n", "            send_signal_ct_fill_up (ctx, SIGNAL_PROTO_V4);\n", "            return DROP_CT_CREATE_FAILED;\n", "        }\n", "        tuple->saddr = saddr;\n", "        tuple->daddr = daddr;\n", "        tuple->flags = flags;\n", "    }\n", "    if (map_related != NULL) {\n", "        struct ipv4_ct_tuple icmp_tuple = {\n", "            .daddr = tuple->daddr,\n", "            .saddr = tuple->saddr,\n", "            .nexthdr = IPPROTO_ICMP,\n", "            .sport = 0,\n", "            .dport = 0,\n", "            .flags = tuple->flags | TUPLE_F_RELATED,}\n", "        ;\n", "        entry.seen_non_syn = true;\n", "        if (map_update_elem (map_related, &icmp_tuple, &entry, 0) < 0) {\n", "            send_signal_ct_fill_up (ctx, SIGNAL_PROTO_V4);\n", "            return DROP_CT_CREATE_FAILED;\n", "        }\n", "    }\n", "    return 0;\n", "}\n"], "called_function_list": ["cilium_dbg3", "ct_update_timeout", "ctx_full_len", "relax_verifier", "send_signal_ct_fill_up"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ct_has_nodeport_egress_entry4": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 1017, "endLine": 1032, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h", "funcName": "ct_has_nodeport_egress_entry4", "developer_inline_comments": [], "updateMaps": [], "readMaps": [" map"], "input": ["const void *map", " struct ipv4_ct_tuple *ingress_tuple"], "output": "static__always_inlinebool", "helper": ["map_lookup_elem"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline bool ct_has_nodeport_egress_entry4 (const void *map, struct ipv4_ct_tuple *ingress_tuple)\n", "{\n", "    __u8 prev_flags = ingress_tuple->flags;\n", "    struct ct_entry *entry;\n", "    ingress_tuple->flags = TUPLE_F_OUT;\n", "    entry = map_lookup_elem (map, ingress_tuple);\n", "    ingress_tuple->flags = prev_flags;\n", "    if (entry)\n", "        return entry->node_port;\n", "    return 0;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ct_has_nodeport_egress_entry6": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 1034, "endLine": 1049, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h", "funcName": "ct_has_nodeport_egress_entry6", "developer_inline_comments": [], "updateMaps": [], "readMaps": [" map"], "input": ["const void *map", " struct ipv6_ct_tuple *ingress_tuple"], "output": "static__always_inlinebool", "helper": ["map_lookup_elem"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline bool ct_has_nodeport_egress_entry6 (const void *map, struct ipv6_ct_tuple *ingress_tuple)\n", "{\n", "    __u8 prev_flags = ingress_tuple->flags;\n", "    struct ct_entry *entry;\n", "    ingress_tuple->flags = TUPLE_F_OUT;\n", "    entry = map_lookup_elem (map, ingress_tuple);\n", "    ingress_tuple->flags = prev_flags;\n", "    if (entry)\n", "        return entry->node_port;\n", "    return 0;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ct_update_nodeport": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 1051, "endLine": 1061, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h", "funcName": "ct_update_nodeport", "developer_inline_comments": [], "updateMaps": [], "readMaps": [" map"], "input": ["const void *map", " const void *tuple", " const bool node_port"], "output": "static__always_inlinevoid", "helper": ["map_lookup_elem"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void ct_update_nodeport (const void *map, const void *tuple, const bool node_port)\n", "{\n", "    struct ct_entry *entry;\n", "    entry = map_lookup_elem (map, tuple);\n", "    if (!entry)\n", "        return;\n", "    entry->node_port = node_port;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "update_metrics": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 24, "endLine": 43, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/metrics.h", "funcName": "update_metrics", "developer_inline_comments": [], "updateMaps": [" METRICS_MAP"], "readMaps": ["  METRICS_MAP"], "input": ["__u64 bytes", " __u8 direction", " __u8 reason"], "output": "static__always_inlinevoid", "helper": ["map_lookup_elem", "map_update_elem"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void update_metrics (__u64 bytes, __u8 direction, __u8 reason)\n", "{\n", "    struct metrics_value *entry, new_entry = {};\n", "    struct metrics_key key = {}\n", "    ;\n", "    key.reason = reason;\n", "    key.dir = direction;\n", "    entry = map_lookup_elem (& METRICS_MAP, & key);\n", "    if (entry) {\n", "        entry->count += 1;\n", "        entry->bytes += bytes;\n", "    }\n", "    else {\n", "        new_entry.count = 1;\n", "        new_entry.bytes = bytes;\n", "        map_update_elem (&METRICS_MAP, &key, &new_entry, 0);\n", "    }\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ct_to_metrics_dir": [{"capabilities": [], "helperCallParams": {}, "startLine": 50, "endLine": 62, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/metrics.h", "funcName": "ct_to_metrics_dir", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["enum ct_dir ct_dir"], "output": "static__always_inlineenummetric_dir", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline enum metric_dir ct_to_metrics_dir (enum ct_dir ct_dir)\n", "{\n", "    switch (ct_dir) {\n", "    case CT_INGRESS :\n", "        return METRIC_INGRESS;\n", "    case CT_EGRESS :\n", "        return METRIC_EGRESS;\n", "    case CT_SERVICE :\n", "        return METRIC_SERVICE;\n", "    default :\n", "        return 0;\n", "    }\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "rol32": [{"capabilities": [], "helperCallParams": {}, "startLine": 14, "endLine": 17, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/jhash.h", "funcName": "rol32", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["__u32 word", " __u32 shift"], "output": "static__always_inline__u32", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __u32 rol32 (__u32 word, __u32 shift)\n", "{\n", "    return (word << shift) | (word >> ((-shift) & 31));\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "jhash": [{"capabilities": [], "helperCallParams": {}, "startLine": 40, "endLine": 81, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/jhash.h", "funcName": "jhash", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const void *key", " __u32 length", " __u32 initval"], "output": "static__always_inline__u32", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __u32 jhash (const void *key, __u32 length, __u32 initval)\n", "{\n", "    const unsigned char *k = key;\n", "    __u32 a, b, c;\n", "    if (!__builtin_constant_p (length))\n", "        __throw_build_bug ();\n", "    a = b = c = JHASH_INITVAL + length + initval;\n", "    while (length > 12) {\n", "        a += *(__u32*) (k);\n", "        b += *(__u32*) (k + 4);\n", "        c += *(__u32*) (k + 8);\n", "        __jhash_mix (a, b, c);\n", "        length -= 12;\n", "        k += 12;\n", "    }\n", "    switch (length) {\n", "    case 12 :\n", "        c += (__u32) k[11] << 24;\n", "    case 11 :\n", "        c += (__u32) k[10] << 16;\n", "    case 10 :\n", "        c += (__u32) k[9] << 8;\n", "    case 9 :\n", "        c += (__u32) k[8];\n", "    case 8 :\n", "        b += (__u32) k[7] << 24;\n", "    case 7 :\n", "        b += (__u32) k[6] << 16;\n", "    case 6 :\n", "        b += (__u32) k[5] << 8;\n", "    case 5 :\n", "        b += (__u32) k[4];\n", "    case 4 :\n", "        a += (__u32) k[3] << 24;\n", "    case 3 :\n", "        a += (__u32) k[2] << 16;\n", "    case 2 :\n", "        a += (__u32) k[1] << 8;\n", "    case 1 :\n", "        a += (__u32) k[0];\n", "        __jhash_final (a, b, c);\n", "    case 0 :\n", "        break;\n", "    }\n", "    return c;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__jhash_nwords": [{"capabilities": [], "helperCallParams": {}, "startLine": 83, "endLine": 91, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/jhash.h", "funcName": "__jhash_nwords", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["__u32 a", " __u32 b", " __u32 c", " __u32 initval"], "output": "static__always_inline__u32", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __u32 __jhash_nwords (__u32 a, __u32 b, __u32 c, __u32 initval)\n", "{\n", "    a += initval;\n", "    b += initval;\n", "    c += initval;\n", "    __jhash_final (a, b, c);\n", "    return c;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "jhash_3words": [{"capabilities": [], "helperCallParams": {}, "startLine": 93, "endLine": 97, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/jhash.h", "funcName": "jhash_3words", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["__u32 a", " __u32 b", " __u32 c", " __u32 initval"], "output": "static__always_inline__u32", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __u32 jhash_3words (__u32 a, __u32 b, __u32 c, __u32 initval)\n", "{\n", "    return __jhash_nwords (a, b, c, initval + JHASH_INITVAL + (3 << 2));\n", "}\n"], "called_function_list": ["__jhash_nwords"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "jhash_2words": [{"capabilities": [], "helperCallParams": {}, "startLine": 99, "endLine": 102, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/jhash.h", "funcName": "jhash_2words", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["__u32 a", " __u32 b", " __u32 initval"], "output": "static__always_inline__u32", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __u32 jhash_2words (__u32 a, __u32 b, __u32 initval)\n", "{\n", "    return __jhash_nwords (a, b, 0, initval + JHASH_INITVAL + (2 << 2));\n", "}\n"], "called_function_list": ["__jhash_nwords"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "jhash_1word": [{"capabilities": [], "helperCallParams": {}, "startLine": 104, "endLine": 107, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/jhash.h", "funcName": "jhash_1word", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["__u32 a", " __u32 initval"], "output": "static__always_inline__u32", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __u32 jhash_1word (__u32 a, __u32 initval)\n", "{\n", "    return __jhash_nwords (a, 0, 0, initval + JHASH_INITVAL + (1 << 2));\n", "}\n"], "called_function_list": ["__jhash_nwords"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ep_tail_call": [{"capabilities": [], "helperCallParams": {}, "startLine": 276, "endLine": 280, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/maps.h", "funcName": "ep_tail_call", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff * ctx __maybe_unused", " const __u32 index __maybe_unused"], "output": "static__always_inlinevoid", "helper": ["tail_call"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void ep_tail_call (struct  __ctx_buff * ctx __maybe_unused, const __u32 index __maybe_unused)\n", "{\n", "    tail_call_static (ctx, &CALLS_MAP, index);\n", "}\n"], "called_function_list": ["tail_call_static"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__lookup_ip6_endpoint": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 12, "endLine": 21, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/eps.h", "funcName": "__lookup_ip6_endpoint", "developer_inline_comments": [], "updateMaps": [], "readMaps": [" ENDPOINTS_MAP"], "input": ["const union v6addr *ip6"], "output": "static__always_inline__maybe_unusedstructendpoint_info", "helper": ["map_lookup_elem"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused struct endpoint_info *__lookup_ip6_endpoint (const union v6addr *ip6)\n", "{\n", "    struct endpoint_key key = {}\n", "    ;\n", "    key.ip6 = *ip6;\n", "    key.family = ENDPOINT_KEY_IPV6;\n", "    return map_lookup_elem (&ENDPOINTS_MAP, &key);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "lookup_ip6_endpoint": [{"capabilities": [], "helperCallParams": {}, "startLine": 23, "endLine": 27, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/eps.h", "funcName": "lookup_ip6_endpoint", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct ipv6hdr *ip6"], "output": "static__always_inline__maybe_unusedstructendpoint_info", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused struct endpoint_info *lookup_ip6_endpoint (const struct ipv6hdr *ip6)\n", "{\n", "    return __lookup_ip6_endpoint ((union v6addr *) &ip6->daddr);\n", "}\n"], "called_function_list": ["__lookup_ip6_endpoint"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__lookup_ip4_endpoint": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 29, "endLine": 38, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/eps.h", "funcName": "__lookup_ip4_endpoint", "developer_inline_comments": [], "updateMaps": [], "readMaps": [" ENDPOINTS_MAP"], "input": ["__u32 ip"], "output": "static__always_inline__maybe_unusedstructendpoint_info", "helper": ["map_lookup_elem"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused struct endpoint_info *__lookup_ip4_endpoint (__u32 ip)\n", "{\n", "    struct endpoint_key key = {}\n", "    ;\n", "    key.ip4 = ip;\n", "    key.family = ENDPOINT_KEY_IPV4;\n", "    return map_lookup_elem (&ENDPOINTS_MAP, &key);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "lookup_ip4_endpoint": [{"capabilities": [], "helperCallParams": {}, "startLine": 40, "endLine": 44, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/eps.h", "funcName": "lookup_ip4_endpoint", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct iphdr *ip4"], "output": "static__always_inline__maybe_unusedstructendpoint_info", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused struct endpoint_info *lookup_ip4_endpoint (const struct iphdr *ip4)\n", "{\n", "    return __lookup_ip4_endpoint (ip4->daddr);\n", "}\n"], "called_function_list": ["__lookup_ip4_endpoint"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "lookup_ip4_endpoint_policy_map": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 47, "endLine": 56, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/eps.h", "funcName": "lookup_ip4_endpoint_policy_map", "developer_inline_comments": [], "updateMaps": [], "readMaps": [" EP_POLICY_MAP"], "input": ["__u32 ip"], "output": "static__always_inlinevoid", "helper": ["map_lookup_elem"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void *lookup_ip4_endpoint_policy_map (__u32 ip)\n", "{\n", "    struct endpoint_key key = {}\n", "    ;\n", "    key.ip4 = ip;\n", "    key.family = ENDPOINT_KEY_IPV4;\n", "    return map_lookup_elem (&EP_POLICY_MAP, &key);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ipcache_lookup6": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 67, "endLine": 78, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/eps.h", "funcName": "ipcache_lookup6", "developer_inline_comments": [], "updateMaps": [], "readMaps": [" map"], "input": ["const void *map", " const union v6addr *addr", " __u32 prefix"], "output": "static__always_inline__maybe_unusedstructremote_endpoint_info", "helper": ["map_lookup_elem"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused struct remote_endpoint_info *ipcache_lookup6 (const void *map, const union v6addr *addr, __u32 prefix)\n", "{\n", "    struct ipcache_key key = {\n", "        .lpm_key = {IPCACHE_PREFIX_LEN (prefix),\n", "            {}},\n", "        .family = ENDPOINT_KEY_IPV6,\n", "        .ip6 = *addr,}\n", "    ;\n", "    ipv6_addr_clear_suffix (&key.ip6, prefix);\n", "    return map_lookup_elem (map, &key);\n", "}\n"], "called_function_list": ["ipv6_addr_clear_suffix"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ipcache_lookup4": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 82, "endLine": 92, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/eps.h", "funcName": "ipcache_lookup4", "developer_inline_comments": [], "updateMaps": [], "readMaps": [" map"], "input": ["const void *map", " __be32 addr", " __u32 prefix"], "output": "static__always_inline__maybe_unusedstructremote_endpoint_info", "helper": ["map_lookup_elem"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused struct remote_endpoint_info *ipcache_lookup4 (const void *map, __be32 addr, __u32 prefix)\n", "{\n", "    struct ipcache_key key = {\n", "        .lpm_key = {IPCACHE_PREFIX_LEN (prefix),\n", "            {}},\n", "        .family = ENDPOINT_KEY_IPV4,\n", "        .ip4 = addr,}\n", "    ;\n", "    key.ip4 &= GET_PREFIX (prefix);\n", "    return map_lookup_elem (map, &key);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "bpf_skip_nodeport_clear": [{"capabilities": [], "helperCallParams": {}, "startLine": 31, "endLine": 35, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "funcName": "bpf_skip_nodeport_clear", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx"], "output": "static__always_inline__maybe_unusedvoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused void bpf_skip_nodeport_clear (struct  __ctx_buff *ctx)\n", "{\n", "    ctx_skip_nodeport_clear (ctx);\n", "}\n"], "called_function_list": ["ctx_skip_nodeport_clear"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "bpf_skip_nodeport_set": [{"capabilities": [], "helperCallParams": {}, "startLine": 37, "endLine": 41, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "funcName": "bpf_skip_nodeport_set", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx"], "output": "static__always_inline__maybe_unusedvoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused void bpf_skip_nodeport_set (struct  __ctx_buff *ctx)\n", "{\n", "    ctx_skip_nodeport_set (ctx);\n", "}\n"], "called_function_list": ["ctx_skip_nodeport_set"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "bpf_skip_nodeport": [{"capabilities": [], "helperCallParams": {}, "startLine": 43, "endLine": 47, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "funcName": "bpf_skip_nodeport", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx"], "output": "static__always_inline__maybe_unusedbool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused bool bpf_skip_nodeport (struct  __ctx_buff *ctx)\n", "{\n", "    return ctx_skip_nodeport (ctx);\n", "}\n"], "called_function_list": ["ctx_skip_nodeport"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "nodeport_uses_dsr": [{"capabilities": [], "helperCallParams": {}, "startLine": 81, "endLine": 92, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "funcName": "nodeport_uses_dsr", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["__u8 nexthdr __maybe_unused"], "output": "static__always_inlinebool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline bool nodeport_uses_dsr (__u8 nexthdr __maybe_unused)\n", "{\n", "\n", "# if defined(ENABLE_DSR) && !defined(ENABLE_DSR_HYBRID)\n", "    return true;\n", "\n", "# elif defined(ENABLE_DSR) && defined(ENABLE_DSR_HYBRID)\n", "    if (nexthdr == IPPROTO_TCP)\n", "        return true;\n", "    return false;\n", "\n", "# else\n", "    return false;\n", "\n", "# endif\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "bpf_mark_snat_done": [{"capabilities": [], "helperCallParams": {}, "startLine": 94, "endLine": 103, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "funcName": "bpf_mark_snat_done", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff * ctx __maybe_unused"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void bpf_mark_snat_done (struct  __ctx_buff * ctx __maybe_unused)\n", "{\n", "\n", "#if __ctx_is == __ctx_skb\n", "    ctx->mark |= MARK_MAGIC_SNAT_DONE;\n", "\n", "#endif\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "bpf_skip_recirculation": [{"capabilities": [], "helperCallParams": {}, "startLine": 105, "endLine": 116, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "funcName": "bpf_skip_recirculation", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct  __ctx_buff * ctx __maybe_unused"], "output": "static__always_inlinebool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline bool bpf_skip_recirculation (const struct  __ctx_buff * ctx __maybe_unused)\n", "{\n", "\n", "#if __ctx_is == __ctx_skb\n", "    return ctx->tc_index & TC_INDEX_F_SKIP_RECIRCULATION;\n", "\n", "#else\n", "    return false;\n", "\n", "#endif\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ctx_adjust_hroom_dsr_flags": [{"capabilities": [], "helperCallParams": {}, "startLine": 118, "endLine": 125, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "funcName": "ctx_adjust_hroom_dsr_flags", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["void"], "output": "static__always_inline__u64", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __u64 ctx_adjust_hroom_dsr_flags (void)\n", "{\n", "\n", "#ifdef BPF_HAVE_CSUM_LEVEL\n", "    return BPF_F_ADJ_ROOM_NO_CSUM_RESET;\n", "\n", "#else\n", "    return 0;\n", "\n", "#endif\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "dsr_fail_needs_reply": [{"capabilities": [], "helperCallParams": {}, "startLine": 127, "endLine": 134, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "funcName": "dsr_fail_needs_reply", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["int code __maybe_unused"], "output": "static__always_inlinebool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline bool dsr_fail_needs_reply (int code __maybe_unused)\n", "{\n", "\n", "#ifdef ENABLE_DSR_ICMP_ERRORS\n", "    if (code == DROP_FRAG_NEEDED)\n", "        return true;\n", "\n", "#endif\n", "    return false;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "dsr_is_too_big": [{"capabilities": [], "helperCallParams": {}, "startLine": 136, "endLine": 144, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "funcName": "dsr_is_too_big", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff * ctx __maybe_unused", " __u16 expanded_len __maybe_unused"], "output": "static__always_inlinebool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline bool dsr_is_too_big (struct  __ctx_buff * ctx __maybe_unused, __u16 expanded_len __maybe_unused)\n", "{\n", "\n", "#ifdef ENABLE_DSR_ICMP_ERRORS\n", "    if (expanded_len > THIS_MTU)\n", "        return true;\n", "\n", "#endif\n", "    return false;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "maybe_add_l2_hdr": [{"capabilities": [], "helperCallParams": {}, "startLine": 146, "endLine": 170, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "funcName": "maybe_add_l2_hdr", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff * ctx __maybe_unused", " __u32 ifindex __maybe_unused", " bool * l2_hdr_required __maybe_unused"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int maybe_add_l2_hdr (struct  __ctx_buff * ctx __maybe_unused, __u32 ifindex __maybe_unused, bool * l2_hdr_required __maybe_unused)\n", "{\n", "    if (IS_L3_DEV (ifindex))\n", "        *l2_hdr_required = false;\n", "    else if (ETH_HLEN == 0) {\n", "        __u16 proto = ctx_get_protocol (ctx);\n", "        if (ctx_change_head (ctx, __ETH_HLEN, 0))\n", "            return DROP_INVALID;\n", "        if (eth_store_proto (ctx, proto, 0) < 0)\n", "            return DROP_WRITE_ERROR;\n", "    }\n", "    return 0;\n", "}\n"], "called_function_list": ["ctx_change_head", "ctx_get_protocol", "eth_store_proto"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "nodeport_uses_dsr6": [{"capabilities": [], "helperCallParams": {}, "startLine": 173, "endLine": 176, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "funcName": "nodeport_uses_dsr6", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct ipv6_ct_tuple *tuple"], "output": "static__always_inlinebool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline bool nodeport_uses_dsr6 (const struct ipv6_ct_tuple *tuple)\n", "{\n", "    return nodeport_uses_dsr (tuple->nexthdr);\n", "}\n"], "called_function_list": ["nodeport_uses_dsr"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "snat_v6_needed": [{"capabilities": [], "helperCallParams": {}, "startLine": 181, "endLine": 203, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "funcName": "snat_v6_needed", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " const union v6addr *addr"], "output": "static__always_inlinebool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline bool snat_v6_needed (struct  __ctx_buff *ctx, const union v6addr *addr)\n", "{\n", "    void *data, *data_end;\n", "    struct ipv6hdr *ip6;\n", "    if (!revalidate_data (ctx, &data, &data_end, &ip6))\n", "        return false;\n", "\n", "#ifdef ENABLE_DSR_HYBRID\n", "    {\n", "        __u8 nexthdr = ip6->nexthdr;\n", "        int ret;\n", "        ret = ipv6_hdrlen (ctx, & nexthdr);\n", "        if (ret > 0) {\n", "            if (nodeport_uses_dsr (nexthdr))\n", "                return false;\n", "        }\n", "    }\n", "\n", "#endif /* ENABLE_DSR_HYBRID */\n", "    return !ipv6_addrcmp ((union v6addr *) &ip6->saddr, addr);\n", "}\n"], "called_function_list": ["ipv6_hdrlen", "ipv6_addrcmp", "nodeport_uses_dsr"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "nodeport_nat_ipv6_fwd": [{"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 205, "endLine": 221, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "funcName": "nodeport_nat_ipv6_fwd", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " const union v6addr *addr"], "output": "static__always_inlineint", "helper": ["CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["static __always_inline int nodeport_nat_ipv6_fwd (struct  __ctx_buff *ctx, const union v6addr *addr)\n", "{\n", "    struct ipv6_nat_target target = {\n", "        .min_port = NODEPORT_PORT_MIN_NAT,\n", "        .max_port = NODEPORT_PORT_MAX_NAT,}\n", "    ;\n", "    int ret;\n", "    ipv6_addr_copy (&target.addr, addr);\n", "    ret = snat_v6_needed (ctx, addr) ? snat_v6_process (ctx, NAT_DIR_EGRESS, &target) : CTX_ACT_OK;\n", "    if (ret == NAT_PUNT_TO_STACK)\n", "        ret = CTX_ACT_OK;\n", "    return ret;\n", "}\n"], "called_function_list": ["snat_v6_needed", "snat_v6_process", "ipv6_addr_copy"], "call_depth": 3, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "rss_gen_src6": [{"capabilities": [], "helperCallParams": {}, "startLine": 225, "endLine": 252, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "funcName": "rss_gen_src6", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["union v6addr *src", " const union v6addr *client", " __be32 l4_hint"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void rss_gen_src6 (union v6addr *src, const union v6addr *client, __be32 l4_hint)\n", "{\n", "    __u32 bits = 128 - IPV6_RSS_PREFIX_BITS;\n", "    *src = (union v6addr) IPV6_RSS_PREFIX;\n", "    if (bits) {\n", "        __u32 todo;\n", "        if (bits > 96) {\n", "            todo = bits - 96;\n", "            src->p1 |= bpf_htonl (hash_32 (client->p1 ^ l4_hint, todo));\n", "            bits -= todo;\n", "        }\n", "        if (bits > 64) {\n", "            todo = bits - 64;\n", "            src->p2 |= bpf_htonl (hash_32 (client->p2 ^ l4_hint, todo));\n", "            bits -= todo;\n", "        }\n", "        if (bits > 32) {\n", "            todo = bits - 32;\n", "            src->p3 |= bpf_htonl (hash_32 (client->p3 ^ l4_hint, todo));\n", "            bits -= todo;\n", "        }\n", "        src->p4 |= bpf_htonl (hash_32 (client->p4 ^ l4_hint, bits));\n", "    }\n", "}\n"], "called_function_list": ["hash_32"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "dsr_set_ipip6": [{"capabilities": [], "helperCallParams": {}, "startLine": 254, "endLine": 292, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "funcName": "dsr_set_ipip6", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " const struct ipv6hdr *ip6", " const union v6addr *backend_addr", " __be32 l4_hint", " int *ohead"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int dsr_set_ipip6 (struct  __ctx_buff *ctx, const struct ipv6hdr *ip6, const union v6addr *backend_addr, __be32 l4_hint, int *ohead)\n", "{\n", "    __u16 payload_len = bpf_ntohs (ip6->payload_len) + sizeof (*ip6);\n", "    const int l3_off = ETH_HLEN;\n", "    union v6addr saddr;\n", "    struct {\n", "        __be16 payload_len;\n", "        __u8 nexthdr;\n", "        __u8 hop_limit;\n", "    } tp_new = {\n", "        .payload_len = bpf_htons (payload_len),\n", "        .nexthdr = IPPROTO_IPV6,\n", "        .hop_limit = IPDEFTTL,};\n", "\n", "    if (dsr_is_too_big (ctx, payload_len + sizeof (*ip6))) {\n", "        *ohead = sizeof (*ip6);\n", "        return DROP_FRAG_NEEDED;\n", "    }\n", "    rss_gen_src6 (&saddr, (union v6addr *) &ip6->saddr, l4_hint);\n", "    if (ctx_adjust_hroom (ctx, sizeof (*ip6), BPF_ADJ_ROOM_NET, ctx_adjust_hroom_dsr_flags ()))\n", "        return DROP_INVALID;\n", "    if (ctx_store_bytes (ctx, l3_off + offsetof (struct ipv6hdr, payload_len), &tp_new.payload_len, 4, 0) < 0)\n", "        return DROP_WRITE_ERROR;\n", "    if (ctx_store_bytes (ctx, l3_off + offsetof (struct ipv6hdr, daddr), backend_addr, sizeof (ip6->daddr), 0) < 0)\n", "        return DROP_WRITE_ERROR;\n", "    if (ctx_store_bytes (ctx, l3_off + offsetof (struct ipv6hdr, saddr), &saddr, sizeof (ip6->saddr), 0) < 0)\n", "        return DROP_WRITE_ERROR;\n", "    return 0;\n", "}\n"], "called_function_list": ["dsr_is_too_big", "rss_gen_src6", "ctx_adjust_hroom_dsr_flags", "ctx_adjust_hroom"], "call_depth": 3, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "dsr_set_ext6": [{"capabilities": [], "helperCallParams": {}, "startLine": 294, "endLine": 327, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "funcName": "dsr_set_ext6", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " struct ipv6hdr *ip6", " const union v6addr *svc_addr", " __be16 svc_port", " int *ohead"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int dsr_set_ext6 (struct  __ctx_buff *ctx, struct ipv6hdr *ip6, const union v6addr *svc_addr, __be16 svc_port, int *ohead)\n", "{\n", "    struct dsr_opt_v6 opt __align_stack_8 = {}\n", "    ;\n", "    __u16 payload_len = bpf_ntohs (ip6->payload_len) + sizeof (opt);\n", "    build_bug_on ((sizeof (struct dsr_opt_v6) % 8) != 0);\n", "    if (dsr_is_too_big (ctx, payload_len)) {\n", "        *ohead = sizeof (opt);\n", "        return DROP_FRAG_NEEDED;\n", "    }\n", "    opt.nexthdr = ip6->nexthdr;\n", "    ip6->nexthdr = NEXTHDR_DEST;\n", "    ip6->payload_len = bpf_htons (payload_len);\n", "    opt.len = DSR_IPV6_EXT_LEN;\n", "    opt.opt_type = DSR_IPV6_OPT_TYPE;\n", "    opt.opt_len = DSR_IPV6_OPT_LEN;\n", "    ipv6_addr_copy (&opt.addr, svc_addr);\n", "    opt.port = svc_port;\n", "    if (ctx_adjust_hroom (ctx, sizeof (opt), BPF_ADJ_ROOM_NET, ctx_adjust_hroom_dsr_flags ()))\n", "        return DROP_INVALID;\n", "    if (ctx_store_bytes (ctx, ETH_HLEN + sizeof (*ip6), &opt, sizeof (opt), 0) < 0)\n", "        return DROP_INVALID;\n", "    return 0;\n", "}\n"], "called_function_list": ["dsr_is_too_big", "ipv6_addr_copy", "ctx_adjust_hroom_dsr_flags", "ctx_adjust_hroom"], "call_depth": 3, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "find_dsr_v6": [{"capabilities": [], "helperCallParams": {}, "startLine": 330, "endLine": 378, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "funcName": "find_dsr_v6", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " __u8 nexthdr", " struct dsr_opt_v6 *dsr_opt", " bool *found"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int find_dsr_v6 (struct  __ctx_buff *ctx, __u8 nexthdr, struct dsr_opt_v6 *dsr_opt, bool *found)\n", "{\n", "    struct ipv6_opt_hdr opthdr __align_stack_8;\n", "    int i, len = sizeof (struct ipv6hdr);\n", "    __u8 nh = nexthdr;\n", "\n", "#pragma unroll\n", "    for (i = 0; i < IPV6_MAX_HEADERS; i++) {\n", "        switch (nh) {\n", "        case NEXTHDR_NONE :\n", "            return DROP_INVALID_EXTHDR;\n", "        case NEXTHDR_FRAGMENT :\n", "            return DROP_FRAG_NOSUPPORT;\n", "        case NEXTHDR_HOP :\n", "        case NEXTHDR_ROUTING :\n", "        case NEXTHDR_AUTH :\n", "        case NEXTHDR_DEST :\n", "            if (ctx_load_bytes (ctx, ETH_HLEN + len, &opthdr, sizeof (opthdr)) < 0)\n", "                return DROP_INVALID;\n", "            if (nh == NEXTHDR_DEST && opthdr.hdrlen == DSR_IPV6_EXT_LEN) {\n", "                if (ctx_load_bytes (ctx, ETH_HLEN + len, dsr_opt, sizeof (*dsr_opt)) < 0)\n", "                    return DROP_INVALID;\n", "                if (dsr_opt->opt_type == DSR_IPV6_OPT_TYPE && dsr_opt->opt_len == DSR_IPV6_OPT_LEN) {\n", "                    *found = true;\n", "                    return 0;\n", "                }\n", "            }\n", "            nh = opthdr.nexthdr;\n", "            if (nh == NEXTHDR_AUTH)\n", "                len += ipv6_authlen (&opthdr);\n", "            else\n", "                len += ipv6_optlen (&opthdr);\n", "            break;\n", "        default :\n", "            return 0;\n", "        }\n", "    }\n", "    return DROP_INVALID_EXTHDR;\n", "}\n"], "called_function_list": ["ipv6_optlen", "ipv6_authlen"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "handle_dsr_v6": [{"capabilities": [], "helperCallParams": {}, "startLine": 380, "endLine": 400, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "funcName": "handle_dsr_v6", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " bool *dsr"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int handle_dsr_v6 (struct  __ctx_buff *ctx, bool *dsr)\n", "{\n", "    struct dsr_opt_v6 opt __align_stack_8 = {}\n", "    ;\n", "    void *data, *data_end;\n", "    struct ipv6hdr *ip6;\n", "    int ret;\n", "    if (!revalidate_data (ctx, &data, &data_end, &ip6))\n", "        return DROP_INVALID;\n", "    ret = find_dsr_v6 (ctx, ip6 -> nexthdr, & opt, dsr);\n", "    if (ret != 0)\n", "        return ret;\n", "    if (*dsr) {\n", "        if (snat_v6_create_dsr (ctx, &opt.addr, opt.port) < 0)\n", "            return DROP_INVALID;\n", "    }\n", "    return 0;\n", "}\n"], "called_function_list": ["snat_v6_create_dsr", "find_dsr_v6"], "call_depth": 3, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "xlate_dsr_v6": [{"capabilities": [], "helperCallParams": {}, "startLine": 402, "endLine": 418, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "funcName": "xlate_dsr_v6", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " const struct ipv6_ct_tuple *tuple", " int l4_off"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int xlate_dsr_v6 (struct  __ctx_buff *ctx, const struct ipv6_ct_tuple *tuple, int l4_off)\n", "{\n", "    struct ipv6_ct_tuple nat_tup = *tuple;\n", "    struct ipv6_nat_entry *entry;\n", "    int ret = 0;\n", "    nat_tup.flags = NAT_DIR_EGRESS;\n", "    nat_tup.sport = tuple->dport;\n", "    nat_tup.dport = tuple->sport;\n", "    entry = snat_v6_lookup (& nat_tup);\n", "    if (entry)\n", "        ret = snat_v6_rewrite_egress (ctx, &nat_tup, entry, l4_off);\n", "    return ret;\n", "}\n"], "called_function_list": ["snat_v6_rewrite_egress", "snat_v6_lookup"], "call_depth": 3, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "dsr_reply_icmp6": [{"capabilities": [{"capability": "read_skb", "read_skb": [{"Project": "cilium", "Return Type": "s64", "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ", "Return": " The checksum result, or a negative error code in case of failure.", "Function Name": "csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp", "lwt_in", "lwt_out", "lwt_xmit", "lwt_seg6local"], "capabilities": ["read_skb"]}]}], "helperCallParams": {}, "startLine": 420, "endLine": 492, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "funcName": "dsr_reply_icmp6", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " const struct ipv6hdr * ip6 __maybe_unused", " int code", " int ohead __maybe_unused"], "output": "static__always_inlineint", "helper": ["csum_diff"], "compatibleHookpoints": ["sched_cls", "lwt_xmit", "xdp", "lwt_in", "sched_act", "lwt_out", "lwt_seg6local"], "source": ["static __always_inline int dsr_reply_icmp6 (struct  __ctx_buff *ctx, const struct ipv6hdr * ip6 __maybe_unused, int code, int ohead __maybe_unused)\n", "{\n", "\n", "#ifdef ENABLE_DSR_ICMP_ERRORS\n", "    const __s32 orig_dgram = 64, off = ETH_HLEN;\n", "    const __u32 l3_max = sizeof (*ip6) + orig_dgram;\n", "    __be16 type = bpf_htons (ETH_P_IPV6);\n", "    __u64 len_new = off + sizeof (*ip6) + orig_dgram;\n", "    __u64 len_old = ctx_full_len (ctx);\n", "    void *data_end = ctx_data_end (ctx);\n", "    void *data = ctx_data (ctx);\n", "    __u8 reason = (__u8) -code;\n", "    __wsum wsum;\n", "    union macaddr smac, dmac;\n", "    struct icmp6hdr icmp __align_stack_8 = {\n", "        .icmp6_type = ICMPV6_PKT_TOOBIG,\n", "        .icmp6_mtu = bpf_htonl (THIS_MTU - ohead),}\n", "    ;\n", "    __u64 payload_len = sizeof (*ip6) + sizeof (icmp) + orig_dgram;\n", "    struct ipv6hdr ip __align_stack_8 = {\n", "        .version = 6,\n", "        .priority = ip6->priority,\n", "        .flow_lbl [0] = ip6->flow_lbl[0],\n", "        .flow_lbl [1] = ip6->flow_lbl[1],\n", "        .flow_lbl [2] = ip6->flow_lbl[2],\n", "        .nexthdr = IPPROTO_ICMPV6,\n", "        .hop_limit = IPDEFTTL,\n", "        .saddr = ip6->daddr,\n", "        .daddr = ip6->saddr,\n", "        .payload_len = bpf_htons ((__u16) payload_len),}\n", "    ;\n", "    update_metrics (ctx_full_len (ctx), METRIC_EGRESS, reason);\n", "    if (eth_load_saddr (ctx, smac.addr, 0) < 0)\n", "        goto drop_err;\n", "    if (eth_load_daddr (ctx, dmac.addr, 0) < 0)\n", "        goto drop_err;\n", "    if (unlikely (data + len_new > data_end))\n", "        goto drop_err;\n", "    wsum = ipv6_pseudohdr_checksum (& ip, IPPROTO_ICMPV6, bpf_ntohs (ip.payload_len), 0);\n", "    icmp.icmp6_cksum = csum_fold (csum_diff (NULL, 0, data + off, l3_max, csum_diff (NULL, 0, &icmp, sizeof (icmp), wsum)));\n", "    if (ctx_adjust_troom (ctx, -(len_old - len_new)) < 0)\n", "        goto drop_err;\n", "    if (ctx_adjust_hroom (ctx, sizeof (ip) + sizeof (icmp), BPF_ADJ_ROOM_NET, ctx_adjust_hroom_dsr_flags ()) < 0)\n", "        goto drop_err;\n", "    if (eth_store_daddr (ctx, smac.addr, 0) < 0)\n", "        goto drop_err;\n", "    if (eth_store_saddr (ctx, dmac.addr, 0) < 0)\n", "        goto drop_err;\n", "    if (ctx_store_bytes (ctx, ETH_ALEN * 2, &type, sizeof (type), 0) < 0)\n", "        goto drop_err;\n", "    if (ctx_store_bytes (ctx, off, &ip, sizeof (ip), 0) < 0)\n", "        goto drop_err;\n", "    if (ctx_store_bytes (ctx, off + sizeof (ip), &icmp, sizeof (icmp), 0) < 0)\n", "        goto drop_err;\n", "    return ctx_redirect (ctx, ctx_get_ifindex (ctx), 0);\n", "drop_err :\n", "\n", "#endif\n", "    return send_drop_notify_error (ctx, 0, code, CTX_ACT_DROP, METRIC_EGRESS);\n", "}\n"], "called_function_list": ["eth_store_daddr", "ctx_full_len", "ctx_redirect", "ctx_adjust_hroom_dsr_flags", "ctx_data", "ctx_data_end", "update_metrics", "eth_load_daddr", "ctx_adjust_hroom", "ctx_adjust_troom", "eth_store_saddr", "eth_load_saddr", "csum_fold", "ipv6_pseudohdr_checksum", "ctx_get_ifindex"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "tail_nodeport_ipv6_dsr": [{"capabilities": [{"capability": "read_sys_info", "read_sys_info": [{"Project": "libbpf", "Return Type": "int", "Description": "Do FIB lookup in kernel tables using parameters in params. If lookup is successful and result shows packet is to be forwarded , the neighbor tables are searched for the nexthop. If successful (ie. , FIB lookup shows forwarding and nexthop is resolved) , the nexthop address is returned in ipv4_dst or ipv6_dst based on family , smac is set to mac address of egress device , dmac is set to nexthop mac address , rt_metric is set to metric from route (IPv4/IPv6 only) , and ifindex is set to the device index of the nexthop from the FIB lookup. <[ plen ]>(IP: 2) argument is the size of the passed in struct. <[ flags ]>(IP: 3) argument can be a combination of one or more of the following values: BPF_FIB_LOOKUP_DIRECT Do a direct table lookup vs full lookup using FIB rules. BPF_FIB_LOOKUP_OUTPUT Perform lookup from an egress perspective (default is ingress). <[ ctx ]>(IP: 0) is either struct xdp_md for XDP programs or struct sk_buff tc cls_act programs. Return \u00b7 < 0 if any input argument is invalid \u00b7 0 on success (packet is forwarded , nexthop neighbor exists) \u00b7 > 0 one of BPF_FIB_LKUP_RET_ codes explaining why the packet is not forwarded or needs assist from full stack ", "Function Name": "bpf_fib_lookup", "Input Params": ["{Type: void ,Var: *ctx}", "{Type:  struct bpf_fib_lookup ,Var: *params}", "{Type:  int ,Var: plen}", "{Type:  u32 ,Var: flags}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp"], "capabilities": ["read_sys_info"]}, {"Project": "cilium", "Return Type": "int", "Description": "Do FIB lookup in kernel tables using parameters in params. If lookup is successful and result shows packet is to be forwarded , the neighbor tables are searched for the nexthop. If successful (ie. , FIB lookup shows forwarding and nexthop is resolved) , the nexthop address is returned in ipv4_dst or ipv6_dst based on family , smac is set to mac address of egress device , dmac is set to nexthop mac address , rt_metric is set to metric from route (IPv4/IPv6 only) , and ifindex is set to the device index of the nexthop from the FIB lookup. <[ plen ]>(IP: 2) argument is the size of the passed in struct. <[ flags ]>(IP: 3) argument can be a combination of one or more of the following values: BPF_FIB_LOOKUP_DIRECT Do a direct table lookup vs full lookup using FIB rules. BPF_FIB_LOOKUP_OUTPUT Perform lookup from an egress perspective (default is ingress). <[ ctx ]>(IP: 0) is either struct xdp_md for XDP programs or struct sk_buff tc cls_act programs. Return \u00b7 < 0 if any input argument is invalid \u00b7 0 on success (packet is forwarded , nexthop neighbor exists) \u00b7 > 0 one of BPF_FIB_LKUP_RET_ codes explaining why the packet is not forwarded or needs assist from full stack ", "Function Name": "fib_lookup", "Input Params": ["{Type: void ,Var: *ctx}", "{Type:  struct fib_lookup ,Var: *params}", "{Type:  int ,Var: plen}", "{Type:  u32 ,Var: flags}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp"], "capabilities": ["read_sys_info"]}]}], "helperCallParams": {}, "startLine": 495, "endLine": 571, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "funcName": "tail_nodeport_ipv6_dsr", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx"], "output": "int", "helper": ["bpf_fib_lookup", "fib_lookup"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["int tail_nodeport_ipv6_dsr (struct  __ctx_buff *ctx)\n", "{\n", "    struct bpf_fib_lookup_padded fib_params = {\n", "        .l = {\n", "            .family = AF_INET6,\n", "            .ifindex = ctx_get_ifindex (ctx),},}\n", "    ;\n", "    __u16 port __maybe_unused;\n", "    void *data, *data_end;\n", "    struct ipv6hdr *ip6;\n", "    union v6addr addr;\n", "    int ret, ohead = 0;\n", "    int ext_err = 0;\n", "    bool l2_hdr_required = true;\n", "    if (!revalidate_data (ctx, &data, &data_end, &ip6)) {\n", "        ret = DROP_INVALID;\n", "        goto drop_err;\n", "    }\n", "    addr.p1 = ctx_load_meta (ctx, CB_ADDR_V6_1);\n", "    addr.p2 = ctx_load_meta (ctx, CB_ADDR_V6_2);\n", "    addr.p3 = ctx_load_meta (ctx, CB_ADDR_V6_3);\n", "    addr.p4 = ctx_load_meta (ctx, CB_ADDR_V6_4);\n", "\n", "#if DSR_ENCAP_MODE == DSR_ENCAP_IPIP\n", "    ret = dsr_set_ipip6 (ctx, ip6, & addr, ctx_load_meta (ctx, CB_HINT), & ohead);\n", "\n", "#elif DSR_ENCAP_MODE == DSR_ENCAP_NONE\n", "    port = (__u16) ctx_load_meta (ctx, CB_PORT);\n", "    ret = dsr_set_ext6 (ctx, ip6, & addr, port, & ohead);\n", "\n", "#else\n", "\n", "# error \"Invalid load balancer DSR encapsulation mode!\"\n", "\n", "#endif\n", "    if (unlikely (ret)) {\n", "        if (dsr_fail_needs_reply (ret))\n", "            return dsr_reply_icmp6 (ctx, ip6, ret, ohead);\n", "        goto drop_err;\n", "    }\n", "    if (!revalidate_data (ctx, &data, &data_end, &ip6)) {\n", "        ret = DROP_INVALID;\n", "        goto drop_err;\n", "    }\n", "    ipv6_addr_copy ((union v6addr *) &fib_params.l.ipv6_src, (union v6addr *) &ip6->saddr);\n", "    ipv6_addr_copy ((union v6addr *) &fib_params.l.ipv6_dst, (union v6addr *) &ip6->daddr);\n", "    ret = fib_lookup (ctx, & fib_params.l, sizeof (fib_params), 0);\n", "    if (ret != 0) {\n", "        ext_err = ret;\n", "        ret = DROP_NO_FIB;\n", "        goto drop_err;\n", "    }\n", "    ret = maybe_add_l2_hdr (ctx, fib_params.l.ifindex, & l2_hdr_required);\n", "    if (ret != 0)\n", "        goto drop_err;\n", "    if (!l2_hdr_required)\n", "        goto out_send;\n", "    if (eth_store_daddr (ctx, fib_params.l.dmac, 0) < 0) {\n", "        ret = DROP_WRITE_ERROR;\n", "        goto drop_err;\n", "    }\n", "    if (eth_store_saddr (ctx, fib_params.l.smac, 0) < 0) {\n", "        ret = DROP_WRITE_ERROR;\n", "        goto drop_err;\n", "    }\n", "out_send :\n", "    cilium_capture_out (ctx);\n", "    return ctx_redirect (ctx, fib_params.l.ifindex, 0);\n", "drop_err :\n", "    return send_drop_notify_error_ext (ctx, 0, ret, ext_err, CTX_ACT_DROP, METRIC_EGRESS);\n", "}\n"], "called_function_list": ["dsr_fail_needs_reply", "ctx_get_ifindex", "cilium_capture_out", "eth_store_daddr", "eth_store_saddr", "maybe_add_l2_hdr", "ctx_load_meta", "dsr_set_ext6", "dsr_reply_icmp6", "ipv6_addr_copy", "ctx_redirect", "dsr_set_ipip6"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "tail_nodeport_nat_ipv6": [{"capabilities": [{"capability": "read_sys_info", "read_sys_info": [{"Project": "libbpf", "Return Type": "int", "Description": "Do FIB lookup in kernel tables using parameters in params. If lookup is successful and result shows packet is to be forwarded , the neighbor tables are searched for the nexthop. If successful (ie. , FIB lookup shows forwarding and nexthop is resolved) , the nexthop address is returned in ipv4_dst or ipv6_dst based on family , smac is set to mac address of egress device , dmac is set to nexthop mac address , rt_metric is set to metric from route (IPv4/IPv6 only) , and ifindex is set to the device index of the nexthop from the FIB lookup. <[ plen ]>(IP: 2) argument is the size of the passed in struct. <[ flags ]>(IP: 3) argument can be a combination of one or more of the following values: BPF_FIB_LOOKUP_DIRECT Do a direct table lookup vs full lookup using FIB rules. BPF_FIB_LOOKUP_OUTPUT Perform lookup from an egress perspective (default is ingress). <[ ctx ]>(IP: 0) is either struct xdp_md for XDP programs or struct sk_buff tc cls_act programs. Return \u00b7 < 0 if any input argument is invalid \u00b7 0 on success (packet is forwarded , nexthop neighbor exists) \u00b7 > 0 one of BPF_FIB_LKUP_RET_ codes explaining why the packet is not forwarded or needs assist from full stack ", "Function Name": "bpf_fib_lookup", "Input Params": ["{Type: void ,Var: *ctx}", "{Type:  struct bpf_fib_lookup ,Var: *params}", "{Type:  int ,Var: plen}", "{Type:  u32 ,Var: flags}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp"], "capabilities": ["read_sys_info"]}, {"Project": "cilium", "Return Type": "int", "Description": "Do FIB lookup in kernel tables using parameters in params. If lookup is successful and result shows packet is to be forwarded , the neighbor tables are searched for the nexthop. If successful (ie. , FIB lookup shows forwarding and nexthop is resolved) , the nexthop address is returned in ipv4_dst or ipv6_dst based on family , smac is set to mac address of egress device , dmac is set to nexthop mac address , rt_metric is set to metric from route (IPv4/IPv6 only) , and ifindex is set to the device index of the nexthop from the FIB lookup. <[ plen ]>(IP: 2) argument is the size of the passed in struct. <[ flags ]>(IP: 3) argument can be a combination of one or more of the following values: BPF_FIB_LOOKUP_DIRECT Do a direct table lookup vs full lookup using FIB rules. BPF_FIB_LOOKUP_OUTPUT Perform lookup from an egress perspective (default is ingress). <[ ctx ]>(IP: 0) is either struct xdp_md for XDP programs or struct sk_buff tc cls_act programs. Return \u00b7 < 0 if any input argument is invalid \u00b7 0 on success (packet is forwarded , nexthop neighbor exists) \u00b7 > 0 one of BPF_FIB_LKUP_RET_ codes explaining why the packet is not forwarded or needs assist from full stack ", "Function Name": "fib_lookup", "Input Params": ["{Type: void ,Var: *ctx}", "{Type:  struct fib_lookup ,Var: *params}", "{Type:  int ,Var: plen}", "{Type:  u32 ,Var: flags}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp"], "capabilities": ["read_sys_info"]}]}], "helperCallParams": {}, "startLine": 575, "endLine": 715, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "funcName": "tail_nodeport_nat_ipv6", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx"], "output": "int", "helper": ["bpf_fib_lookup", "fib_lookup"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["int tail_nodeport_nat_ipv6 (struct  __ctx_buff *ctx)\n", "{\n", "    enum nat_dir dir = (enum nat_dir) ctx_load_meta (ctx, CB_NAT);\n", "    const bool nat_46x64 = ctx_load_meta (ctx, CB_NAT_46X64);\n", "    union v6addr tmp = IPV6_DIRECT_ROUTING;\n", "    struct bpf_fib_lookup_padded fib_params = {\n", "        .l = {\n", "            .family = AF_INET6,\n", "            .ifindex = ctx_get_ifindex (ctx),},}\n", "    ;\n", "    struct ipv6_nat_target target = {\n", "        .min_port = NODEPORT_PORT_MIN_NAT,\n", "        .max_port = NODEPORT_PORT_MAX_NAT,\n", "        .src_from_world = true,}\n", "    ;\n", "    bool l2_hdr_required = true;\n", "    void *data, *data_end;\n", "    struct ipv6hdr *ip6;\n", "    int ret, ext_err = 0;\n", "    if (nat_46x64)\n", "        build_v4_in_v6 (&tmp, IPV4_DIRECT_ROUTING);\n", "    target.addr = tmp;\n", "\n", "#ifdef TUNNEL_MODE\n", "    if (dir == NAT_DIR_EGRESS) {\n", "        struct remote_endpoint_info *info;\n", "        union v6addr *dst;\n", "        if (!revalidate_data (ctx, &data, &data_end, &ip6)) {\n", "            ret = DROP_INVALID;\n", "            goto drop_err;\n", "        }\n", "        dst = (union v6addr *) &ip6->daddr;\n", "        info = ipcache_lookup6 (& IPCACHE_MAP, dst, V6_CACHE_KEY_LEN);\n", "        if (info != NULL && info->tunnel_endpoint != 0) {\n", "            ret = __encap_with_nodeid (ctx, info -> tunnel_endpoint, WORLD_ID, NOT_VTEP_DST, (enum trace_reason) CT_NEW, TRACE_PAYLOAD_LEN);\n", "            if (ret)\n", "                goto drop_err;\n", "            BPF_V6 (target.addr, ROUTER_IP);\n", "            fib_params.l.ifindex = ENCAP_IFINDEX;\n", "            if (eth_store_daddr (ctx, fib_params.l.dmac, 0) < 0) {\n", "                ret = DROP_WRITE_ERROR;\n", "                goto drop_err;\n", "            }\n", "            if (eth_store_saddr (ctx, fib_params.l.smac, 0) < 0) {\n", "                ret = DROP_WRITE_ERROR;\n", "                goto drop_err;\n", "            }\n", "        }\n", "    }\n", "\n", "#endif\n", "    ret = snat_v6_process (ctx, dir, & target);\n", "    if (IS_ERR (ret)) {\n", "        if (dir == NAT_DIR_INGRESS) {\n", "            bpf_skip_nodeport_set (ctx);\n", "            ep_tail_call (ctx, CILIUM_CALL_IPV6_FROM_NETDEV);\n", "            ret = DROP_MISSED_TAIL_CALL;\n", "            goto drop_err;\n", "        }\n", "        if (ret != NAT_PUNT_TO_STACK)\n", "            goto drop_err;\n", "    }\n", "    bpf_mark_snat_done (ctx);\n", "    if (dir == NAT_DIR_INGRESS) {\n", "        ep_tail_call (ctx, CILIUM_CALL_IPV6_NODEPORT_REVNAT);\n", "        ret = DROP_MISSED_TAIL_CALL;\n", "        goto drop_err;\n", "    }\n", "\n", "#ifdef TUNNEL_MODE\n", "    if (fib_params.l.ifindex == ENCAP_IFINDEX)\n", "        goto out_send;\n", "\n", "#endif\n", "    if (!revalidate_data (ctx, &data, &data_end, &ip6)) {\n", "        ret = DROP_INVALID;\n", "        goto drop_err;\n", "    }\n", "    if (nat_46x64) {\n", "        struct iphdr *ip4;\n", "        ret = lb6_to_lb4 (ctx, ip6);\n", "        if (ret < 0)\n", "            goto drop_err;\n", "        if (!revalidate_data (ctx, &data, &data_end, &ip4)) {\n", "            ret = DROP_INVALID;\n", "            goto drop_err;\n", "        }\n", "        fib_params.l.ipv4_src = ip4->saddr;\n", "        fib_params.l.ipv4_dst = ip4->daddr;\n", "        fib_params.l.family = AF_INET;\n", "    }\n", "    else {\n", "        ipv6_addr_copy ((union v6addr *) &fib_params.l.ipv6_src, (union v6addr *) &ip6->saddr);\n", "        ipv6_addr_copy ((union v6addr *) &fib_params.l.ipv6_dst, (union v6addr *) &ip6->daddr);\n", "    }\n", "    ret = fib_lookup (ctx, & fib_params.l, sizeof (fib_params), 0);\n", "    if (ret != 0) {\n", "        ext_err = ret;\n", "        ret = DROP_NO_FIB;\n", "        goto drop_err;\n", "    }\n", "    ret = maybe_add_l2_hdr (ctx, fib_params.l.ifindex, & l2_hdr_required);\n", "    if (ret != 0)\n", "        goto drop_err;\n", "    if (!l2_hdr_required)\n", "        goto out_send;\n", "    if (eth_store_daddr (ctx, fib_params.l.dmac, 0) < 0) {\n", "        ret = DROP_WRITE_ERROR;\n", "        goto drop_err;\n", "    }\n", "    if (eth_store_saddr (ctx, fib_params.l.smac, 0) < 0) {\n", "        ret = DROP_WRITE_ERROR;\n", "        goto drop_err;\n", "    }\n", "out_send :\n", "    cilium_capture_out (ctx);\n", "    return ctx_redirect (ctx, fib_params.l.ifindex, 0);\n", "drop_err :\n", "    return send_drop_notify_error_ext (ctx, 0, ret, ext_err, CTX_ACT_DROP, dir == NAT_DIR_INGRESS ? METRIC_INGRESS : METRIC_EGRESS);\n", "}\n"], "called_function_list": ["snat_v6_process", "cilium_capture_out", "ep_tail_call", "eth_store_daddr", "maybe_add_l2_hdr", "__encap_with_nodeid", "ctx_redirect", "bpf_skip_nodeport_set", "ipcache_lookup6", "lb6_to_lb4", "build_v4_in_v6", "eth_store_saddr", "bpf_mark_snat_done", "ctx_get_ifindex", "ctx_load_meta", "ipv6_addr_copy"], "call_depth": 3, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "nodeport_lb6": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}, {"capability": "map_update", "map_update": [{"Project": "cilium", "Return Type": "int", "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "map_update_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}", "{Type:  const void ,Var: *value}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_update"]}]}, {"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 718, "endLine": 881, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "funcName": "nodeport_lb6", "developer_inline_comments": [], "updateMaps": ["  NODEPORT_NEIGH6"], "readMaps": ["  NODEPORT_NEIGH6"], "input": ["struct  __ctx_buff *ctx", " __u32 src_identity"], "output": "static__always_inlineint", "helper": ["map_lookup_elem", "map_update_elem", "CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["static __always_inline int nodeport_lb6 (struct  __ctx_buff *ctx, __u32 src_identity)\n", "{\n", "    int ret, l3_off = ETH_HLEN, l4_off, hdrlen;\n", "    struct ipv6_ct_tuple tuple = {}\n", "    ;\n", "    void *data, *data_end;\n", "    struct ipv6hdr *ip6;\n", "    struct csum_offset csum_off = {}\n", "    ;\n", "    struct lb6_service *svc;\n", "    struct lb6_key key = {}\n", "    ;\n", "    struct ct_state ct_state_new = {}\n", "    ;\n", "    union macaddr smac, *mac;\n", "    bool backend_local;\n", "    __u32 monitor = 0;\n", "    cilium_capture_in (ctx);\n", "    if (!revalidate_data (ctx, &data, &data_end, &ip6))\n", "        return DROP_INVALID;\n", "    tuple.nexthdr = ip6->nexthdr;\n", "    ipv6_addr_copy (&tuple.daddr, (union v6addr *) &ip6->daddr);\n", "    ipv6_addr_copy (&tuple.saddr, (union v6addr *) &ip6->saddr);\n", "    hdrlen = ipv6_hdrlen (ctx, & tuple.nexthdr);\n", "    if (hdrlen < 0)\n", "        return hdrlen;\n", "    l4_off = l3_off + hdrlen;\n", "    ret = lb6_extract_key (ctx, & tuple, l4_off, & key, & csum_off, CT_EGRESS);\n", "    if (IS_ERR (ret)) {\n", "        if (ret == DROP_NO_SERVICE)\n", "            goto skip_service_lookup;\n", "        else if (ret == DROP_UNKNOWN_L4)\n", "            return CTX_ACT_OK;\n", "        else\n", "            return ret;\n", "    }\n", "    svc = lb6_lookup_service (& key, false);\n", "    if (svc) {\n", "        const bool skip_l3_xlate = DSR_ENCAP_MODE == DSR_ENCAP_IPIP;\n", "        if (!lb6_src_range_ok (svc, (union v6addr *) &ip6->saddr))\n", "            return DROP_NOT_IN_SRC_RANGE;\n", "\n", "#if defined(ENABLE_L7_LB)\n", "        if (lb6_svc_is_l7loadbalancer (svc) && svc->l7_lb_proxy_port > 0) {\n", "            send_trace_notify (ctx, TRACE_TO_PROXY, src_identity, 0, bpf_ntohs ((__u16) svc->l7_lb_proxy_port), 0, TRACE_REASON_POLICY, monitor);\n", "            return ctx_redirect_to_proxy_hairpin_ipv6 (ctx, (__be16) svc->l7_lb_proxy_port);\n", "        }\n", "\n", "#endif\n", "        ret = lb6_local (get_ct_map6 (& tuple), ctx, l3_off, l4_off, & csum_off, & key, & tuple, svc, & ct_state_new, skip_l3_xlate);\n", "        if (IS_ERR (ret))\n", "            return ret;\n", "    }\n", "    if (!svc || !lb6_svc_is_routable (svc)) {\n", "        if (svc)\n", "            return DROP_IS_CLUSTER_IP;\n", "    skip_service_lookup :\n", "        ctx_set_xfer (ctx, XFER_PKT_NO_SVC);\n", "        if (nodeport_uses_dsr6 (&tuple))\n", "            return CTX_ACT_OK;\n", "        ctx_store_meta (ctx, CB_NAT, NAT_DIR_INGRESS);\n", "        ctx_store_meta (ctx, CB_NAT_46X64, 0);\n", "        ctx_store_meta (ctx, CB_SRC_IDENTITY, src_identity);\n", "        ep_tail_call (ctx, CILIUM_CALL_IPV6_NODEPORT_NAT);\n", "        return DROP_MISSED_TAIL_CALL;\n", "    }\n", "    backend_local = __lookup_ip6_endpoint (& tuple.daddr);\n", "    if (!backend_local && lb6_svc_is_hostport (svc))\n", "        return DROP_INVALID;\n", "    if (backend_local || !nodeport_uses_dsr6 (&tuple)) {\n", "        struct ct_state ct_state = {}\n", "        ;\n", "        ret = ct_lookup6 (get_ct_map6 (& tuple), & tuple, ctx, l4_off, CT_EGRESS, & ct_state, & monitor);\n", "        switch (ret) {\n", "        case CT_NEW :\n", "        redo :\n", "            ct_state_new.src_sec_id = WORLD_ID;\n", "            ct_state_new.node_port = 1;\n", "            ct_state_new.ifindex = (__u16) NATIVE_DEV_IFINDEX;\n", "            ret = ct_create6 (get_ct_map6 (& tuple), NULL, & tuple, ctx, CT_EGRESS, & ct_state_new, false, false);\n", "            if (IS_ERR (ret))\n", "                return ret;\n", "            break;\n", "        case CT_REOPENED :\n", "        case CT_ESTABLISHED :\n", "        case CT_REPLY :\n", "            if (unlikely (ct_state.rev_nat_index != svc->rev_nat_index))\n", "                goto redo;\n", "            break;\n", "        default :\n", "            return DROP_UNKNOWN_CT;\n", "        }\n", "        if (!revalidate_data (ctx, &data, &data_end, &ip6))\n", "            return DROP_INVALID;\n", "        if (eth_load_saddr (ctx, smac.addr, 0) < 0)\n", "            return DROP_INVALID;\n", "        mac = map_lookup_elem (& NODEPORT_NEIGH6, & ip6 -> saddr);\n", "        if (!mac || eth_addrcmp (mac, &smac)) {\n", "            ret = map_update_elem (& NODEPORT_NEIGH6, & ip6 -> saddr, & smac, 0);\n", "            if (ret < 0)\n", "                return ret;\n", "        }\n", "    }\n", "    if (!backend_local) {\n", "        edt_set_aggregate (ctx, 0);\n", "        if (nodeport_uses_dsr6 (&tuple)) {\n", "\n", "#if DSR_ENCAP_MODE == DSR_ENCAP_IPIP\n", "            ctx_store_meta (ctx, CB_HINT, ((__u32) tuple.sport << 16) | tuple.dport);\n", "            ctx_store_meta (ctx, CB_ADDR_V6_1, tuple.daddr.p1);\n", "            ctx_store_meta (ctx, CB_ADDR_V6_2, tuple.daddr.p2);\n", "            ctx_store_meta (ctx, CB_ADDR_V6_3, tuple.daddr.p3);\n", "            ctx_store_meta (ctx, CB_ADDR_V6_4, tuple.daddr.p4);\n", "\n", "#elif DSR_ENCAP_MODE == DSR_ENCAP_NONE\n", "            ctx_store_meta (ctx, CB_PORT, key.dport);\n", "            ctx_store_meta (ctx, CB_ADDR_V6_1, key.address.p1);\n", "            ctx_store_meta (ctx, CB_ADDR_V6_2, key.address.p2);\n", "            ctx_store_meta (ctx, CB_ADDR_V6_3, key.address.p3);\n", "            ctx_store_meta (ctx, CB_ADDR_V6_4, key.address.p4);\n", "\n", "#endif /* DSR_ENCAP_MODE */\n", "            ep_tail_call (ctx, CILIUM_CALL_IPV6_NODEPORT_DSR);\n", "        }\n", "        else {\n", "            ctx_store_meta (ctx, CB_NAT, NAT_DIR_EGRESS);\n", "            ctx_store_meta (ctx, CB_NAT_46X64, !is_v4_in_v6 (&key.address) && lb6_to_lb4_service (svc));\n", "            ep_tail_call (ctx, CILIUM_CALL_IPV6_NODEPORT_NAT);\n", "        }\n", "        return DROP_MISSED_TAIL_CALL;\n", "    }\n", "    ctx_set_xfer (ctx, XFER_PKT_NO_SVC);\n", "    return CTX_ACT_OK;\n", "}\n"], "called_function_list": ["get_ct_map6", "ep_tail_call", "ctx_redirect_to_proxy_hairpin_ipv6", "ctx_set_xfer", "lb6_extract_key", "lb6_to_lb4_service", "lb6_local", "lb6_lookup_service", "is_v4_in_v6", "lb6_svc_is_l7loadbalancer", "lb6_svc_is_hostport", "ct_lookup6", "eth_addrcmp", "ipv6_hdrlen", "nodeport_uses_dsr6", "cilium_capture_in", "eth_load_saddr", "__lookup_ip6_endpoint", "send_trace_notify", "edt_set_aggregate", "lb6_src_range_ok", "ct_create6", "lb6_svc_is_routable", "ctx_store_meta", "ipv6_addr_copy"], "call_depth": 3, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "rev_nodeport_lb6": [{"capabilities": [{"capability": "read_sys_info", "read_sys_info": [{"Project": "libbpf", "Return Type": "int", "Description": "Do FIB lookup in kernel tables using parameters in params. If lookup is successful and result shows packet is to be forwarded , the neighbor tables are searched for the nexthop. If successful (ie. , FIB lookup shows forwarding and nexthop is resolved) , the nexthop address is returned in ipv4_dst or ipv6_dst based on family , smac is set to mac address of egress device , dmac is set to nexthop mac address , rt_metric is set to metric from route (IPv4/IPv6 only) , and ifindex is set to the device index of the nexthop from the FIB lookup. <[ plen ]>(IP: 2) argument is the size of the passed in struct. <[ flags ]>(IP: 3) argument can be a combination of one or more of the following values: BPF_FIB_LOOKUP_DIRECT Do a direct table lookup vs full lookup using FIB rules. BPF_FIB_LOOKUP_OUTPUT Perform lookup from an egress perspective (default is ingress). <[ ctx ]>(IP: 0) is either struct xdp_md for XDP programs or struct sk_buff tc cls_act programs. Return \u00b7 < 0 if any input argument is invalid \u00b7 0 on success (packet is forwarded , nexthop neighbor exists) \u00b7 > 0 one of BPF_FIB_LKUP_RET_ codes explaining why the packet is not forwarded or needs assist from full stack ", "Function Name": "bpf_fib_lookup", "Input Params": ["{Type: void ,Var: *ctx}", "{Type:  struct bpf_fib_lookup ,Var: *params}", "{Type:  int ,Var: plen}", "{Type:  u32 ,Var: flags}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp"], "capabilities": ["read_sys_info"]}, {"Project": "cilium", "Return Type": "int", "Description": "Do FIB lookup in kernel tables using parameters in params. If lookup is successful and result shows packet is to be forwarded , the neighbor tables are searched for the nexthop. If successful (ie. , FIB lookup shows forwarding and nexthop is resolved) , the nexthop address is returned in ipv4_dst or ipv6_dst based on family , smac is set to mac address of egress device , dmac is set to nexthop mac address , rt_metric is set to metric from route (IPv4/IPv6 only) , and ifindex is set to the device index of the nexthop from the FIB lookup. <[ plen ]>(IP: 2) argument is the size of the passed in struct. <[ flags ]>(IP: 3) argument can be a combination of one or more of the following values: BPF_FIB_LOOKUP_DIRECT Do a direct table lookup vs full lookup using FIB rules. BPF_FIB_LOOKUP_OUTPUT Perform lookup from an egress perspective (default is ingress). <[ ctx ]>(IP: 0) is either struct xdp_md for XDP programs or struct sk_buff tc cls_act programs. Return \u00b7 < 0 if any input argument is invalid \u00b7 0 on success (packet is forwarded , nexthop neighbor exists) \u00b7 > 0 one of BPF_FIB_LKUP_RET_ codes explaining why the packet is not forwarded or needs assist from full stack ", "Function Name": "fib_lookup", "Input Params": ["{Type: void ,Var: *ctx}", "{Type:  struct fib_lookup ,Var: *params}", "{Type:  int ,Var: plen}", "{Type:  u32 ,Var: flags}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp"], "capabilities": ["read_sys_info"]}]}, {"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}, {"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 884, "endLine": 1006, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "funcName": "rev_nodeport_lb6", "developer_inline_comments": [], "updateMaps": [], "readMaps": ["  NODEPORT_NEIGH6"], "input": ["struct  __ctx_buff *ctx", " int *ifindex", " int *ext_err"], "output": "static__always_inlineint", "helper": ["bpf_fib_lookup", "map_lookup_elem", "CTX_ACT_OK", "fib_lookup"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["static __always_inline int rev_nodeport_lb6 (struct  __ctx_buff *ctx, int *ifindex, int *ext_err)\n", "{\n", "    int ret, fib_ret, ret2, l3_off = ETH_HLEN, l4_off, hdrlen;\n", "    struct ipv6_ct_tuple tuple = {}\n", "    ;\n", "    void *data, *data_end;\n", "    struct ipv6hdr *ip6;\n", "    struct csum_offset csum_off = {}\n", "    ;\n", "    struct ct_state ct_state = {}\n", "    ;\n", "    struct bpf_fib_lookup fib_params = {}\n", "    ;\n", "    __u32 monitor = 0;\n", "    bool l2_hdr_required = true;\n", "    if (!revalidate_data (ctx, &data, &data_end, &ip6))\n", "        return DROP_INVALID;\n", "    tuple.nexthdr = ip6->nexthdr;\n", "    ipv6_addr_copy (&tuple.daddr, (union v6addr *) &ip6->daddr);\n", "    ipv6_addr_copy (&tuple.saddr, (union v6addr *) &ip6->saddr);\n", "    hdrlen = ipv6_hdrlen (ctx, & tuple.nexthdr);\n", "    if (hdrlen < 0)\n", "        return hdrlen;\n", "    l4_off = l3_off + hdrlen;\n", "    csum_l4_offset_and_flags (tuple.nexthdr, &csum_off);\n", "    ret = ct_lookup6 (get_ct_map6 (& tuple), & tuple, ctx, l4_off, CT_INGRESS, & ct_state, & monitor);\n", "    if (ret == CT_REPLY && ct_state.node_port == 1 && ct_state.rev_nat_index != 0) {\n", "        ret2 = lb6_rev_nat (ctx, l4_off, & csum_off, ct_state.rev_nat_index, & tuple, REV_NAT_F_TUPLE_SADDR);\n", "        if (IS_ERR (ret2))\n", "            return ret2;\n", "        if (!revalidate_data (ctx, &data, &data_end, &ip6))\n", "            return DROP_INVALID;\n", "        bpf_mark_snat_done (ctx);\n", "        *ifindex = ct_state.ifindex;\n", "\n", "#ifdef TUNNEL_MODE\n", "        {\n", "            union v6addr *dst = (union v6addr *) &ip6->daddr;\n", "            struct remote_endpoint_info *info;\n", "            info = ipcache_lookup6 (& IPCACHE_MAP, dst, V6_CACHE_KEY_LEN);\n", "            if (info != NULL && info->tunnel_endpoint != 0) {\n", "                ret = __encap_with_nodeid (ctx, info -> tunnel_endpoint, SECLABEL, NOT_VTEP_DST, TRACE_REASON_CT_REPLY, TRACE_PAYLOAD_LEN);\n", "                if (ret)\n", "                    return ret;\n", "                *ifindex = ENCAP_IFINDEX;\n", "                if (eth_store_daddr (ctx, fib_params.dmac, 0) < 0)\n", "                    return DROP_WRITE_ERROR;\n", "                if (eth_store_saddr (ctx, fib_params.smac, 0) < 0)\n", "                    return DROP_WRITE_ERROR;\n", "                return CTX_ACT_OK;\n", "            }\n", "        }\n", "\n", "#endif\n", "        fib_params.family = AF_INET6;\n", "        fib_params.ifindex = ctx_get_ifindex (ctx);\n", "        ipv6_addr_copy ((union v6addr *) &fib_params.ipv6_src, &tuple.saddr);\n", "        ipv6_addr_copy ((union v6addr *) &fib_params.ipv6_dst, &tuple.daddr);\n", "        fib_ret = fib_lookup (ctx, & fib_params, sizeof (fib_params), 0);\n", "        if (fib_ret == 0)\n", "            *ifindex = fib_params.ifindex;\n", "        ret = maybe_add_l2_hdr (ctx, * ifindex, & l2_hdr_required);\n", "        if (ret != 0)\n", "            return ret;\n", "        if (!l2_hdr_required)\n", "            return CTX_ACT_OK;\n", "        if (fib_ret != 0) {\n", "            union macaddr smac = NATIVE_DEV_MAC_BY_IFINDEX (* ifindex);\n", "            union macaddr *dmac;\n", "            if (fib_ret != BPF_FIB_LKUP_RET_NO_NEIGH) {\n", "                *ext_err = fib_ret;\n", "                return DROP_NO_FIB;\n", "            }\n", "            dmac = map_lookup_elem (& NODEPORT_NEIGH6, & tuple.daddr);\n", "            if (unlikely (!dmac)) {\n", "                *ext_err = fib_ret;\n", "                return DROP_NO_FIB;\n", "            }\n", "            if (eth_store_daddr_aligned (ctx, dmac->addr, 0) < 0)\n", "                return DROP_WRITE_ERROR;\n", "            if (eth_store_saddr_aligned (ctx, smac.addr, 0) < 0)\n", "                return DROP_WRITE_ERROR;\n", "        }\n", "        else {\n", "            if (eth_store_daddr (ctx, fib_params.dmac, 0) < 0)\n", "                return DROP_WRITE_ERROR;\n", "            if (eth_store_saddr (ctx, fib_params.smac, 0) < 0)\n", "                return DROP_WRITE_ERROR;\n", "        }\n", "    }\n", "    else {\n", "        if (!bpf_skip_recirculation (ctx)) {\n", "            bpf_skip_nodeport_set (ctx);\n", "            ep_tail_call (ctx, CILIUM_CALL_IPV6_FROM_NETDEV);\n", "            return DROP_MISSED_TAIL_CALL;\n", "        }\n", "    }\n", "    return CTX_ACT_OK;\n", "}\n"], "called_function_list": ["get_ct_map6", "eth_store_daddr", "ep_tail_call", "maybe_add_l2_hdr", "__encap_with_nodeid", "bpf_skip_recirculation", "bpf_skip_nodeport_set", "eth_store_saddr_aligned", "lb6_rev_nat", "ipcache_lookup6", "eth_store_daddr_aligned", "ct_lookup6", "eth_store_saddr", "ipv6_hdrlen", "bpf_mark_snat_done", "ctx_get_ifindex", "ipv6_addr_copy", "csum_l4_offset_and_flags"], "call_depth": 3, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "tail_rev_nodeport_lb6": [{"capabilities": [], "helperCallParams": {}, "startLine": 1009, "endLine": 1052, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "funcName": "tail_rev_nodeport_lb6", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx"], "output": "int", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["int tail_rev_nodeport_lb6 (struct  __ctx_buff *ctx)\n", "{\n", "    int ifindex = 0, ret = 0;\n", "    void *data, *data_end;\n", "    struct ipv6hdr *ip6;\n", "    int ext_err = 0;\n", "\n", "#if defined(ENABLE_HOST_FIREWALL) && defined(IS_BPF_HOST)\n", "    struct trace_ctx __maybe_unused trace = {\n", "        .reason = TRACE_REASON_UNKNOWN,\n", "        .monitor = 0,}\n", "    ;\n", "    __u32 src_id = 0;\n", "    ret = ipv6_host_policy_ingress (ctx, & src_id, & trace);\n", "    if (IS_ERR (ret))\n", "        return send_drop_notify_error (ctx, src_id, ret, CTX_ACT_DROP, METRIC_INGRESS);\n", "    ctx_skip_host_fw_set (ctx);\n", "\n", "#endif\n", "    ret = rev_nodeport_lb6 (ctx, & ifindex, & ext_err);\n", "    if (IS_ERR (ret))\n", "        goto drop;\n", "    if (!revalidate_data (ctx, &data, &data_end, &ip6))\n", "        goto drop;\n", "    if (is_v4_in_v6 ((union v6addr *) &ip6->saddr)) {\n", "        ret = lb6_to_lb4 (ctx, ip6);\n", "        if (ret)\n", "            goto drop;\n", "    }\n", "    edt_set_aggregate (ctx, 0);\n", "    cilium_capture_out (ctx);\n", "    return ctx_redirect (ctx, ifindex, 0);\n", "drop :\n", "    return send_drop_notify_error_ext (ctx, 0, ret, ext_err, CTX_ACT_DROP, METRIC_EGRESS);\n", "}\n"], "called_function_list": ["ipv6_host_policy_ingress", "ctx_skip_host_fw_set", "edt_set_aggregate", "cilium_capture_out", "is_v4_in_v6", "ctx_redirect", "lb6_to_lb4", "rev_nodeport_lb6"], "call_depth": 3, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "tail_handle_nat_fwd_ipv6": [{"capabilities": [], "helperCallParams": {}, "startLine": 1059, "endLine": 1078, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "funcName": "tail_handle_nat_fwd_ipv6", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx"], "output": "int", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["int tail_handle_nat_fwd_ipv6 (struct  __ctx_buff *ctx)\n", "{\n", "    int ret;\n", "    enum trace_point obs_point;\n", "\n", "#if defined(TUNNEL_MODE) && defined(IS_BPF_OVERLAY)\n", "    union v6addr addr = {\n", "        .p1 = 0}\n", "    ;\n", "    BPF_V6 (addr, ROUTER_IP);\n", "    obs_point = TRACE_TO_OVERLAY;\n", "\n", "#else\n", "    union v6addr addr = IPV6_DIRECT_ROUTING;\n", "    obs_point = TRACE_TO_NETWORK;\n", "\n", "#endif\n", "    ret = nodeport_nat_ipv6_fwd (ctx, & addr);\n", "    if (IS_ERR (ret))\n", "        return send_drop_notify_error (ctx, 0, ret, CTX_ACT_DROP, METRIC_EGRESS);\n", "    send_trace_notify (ctx, obs_point, 0, 0, 0, 0, TRACE_REASON_UNKNOWN, 0);\n", "    return ret;\n", "}\n"], "called_function_list": ["send_trace_notify", "nodeport_nat_ipv6_fwd"], "call_depth": 4, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "nodeport_uses_dsr4": [{"capabilities": [], "helperCallParams": {}, "startLine": 1082, "endLine": 1085, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "funcName": "nodeport_uses_dsr4", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct ipv4_ct_tuple *tuple"], "output": "static__always_inlinebool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline bool nodeport_uses_dsr4 (const struct ipv4_ct_tuple *tuple)\n", "{\n", "    return nodeport_uses_dsr (tuple->nexthdr);\n", "}\n"], "called_function_list": ["nodeport_uses_dsr"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "snat_v4_needed": [{"capabilities": [], "helperCallParams": {}, "startLine": 1101, "endLine": 1259, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "funcName": "snat_v4_needed", "developer_inline_comments": [], "updateMaps": [], "readMaps": [" IP_MASQ_AGENT_IPV4"], "input": ["struct  __ctx_buff *ctx", " __be32 *addr", " bool * from_endpoint __maybe_unused"], "output": "static__always_inlinebool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline bool snat_v4_needed (struct  __ctx_buff *ctx, __be32 *addr, bool * from_endpoint __maybe_unused)\n", "{\n", "    void *data, *data_end;\n", "    struct iphdr *ip4;\n", "    struct endpoint_info * local_ep __maybe_unused;\n", "    struct remote_endpoint_info * remote_ep __maybe_unused;\n", "    struct egress_gw_policy_entry * egress_gw_policy __maybe_unused;\n", "    bool is_reply = false;\n", "    if (!revalidate_data (ctx, &data, &data_end, &ip4))\n", "        return false;\n", "\n", "#if defined(TUNNEL_MODE) && defined(IS_BPF_OVERLAY)\n", "    if (ip4->saddr == IPV4_GATEWAY) {\n", "        *addr = IPV4_GATEWAY;\n", "        return true;\n", "    }\n", "\n", "#else\n", "    if (DIRECT_ROUTING_DEV_IFINDEX == NATIVE_DEV_IFINDEX && ip4->saddr == IPV4_DIRECT_ROUTING) {\n", "        *addr = IPV4_DIRECT_ROUTING;\n", "        return true;\n", "    }\n", "\n", "# ifdef ENABLE_MASQUERADE\n", "    if (ip4->saddr == IPV4_MASQUERADE) {\n", "        *addr = IPV4_MASQUERADE;\n", "        return true;\n", "    }\n", "\n", "# endif\n", "\n", "#endif /* defined(TUNNEL_MODE) && defined(IS_BPF_OVERLAY) */\n", "    local_ep = __lookup_ip4_endpoint (ip4 -> saddr);\n", "    remote_ep = lookup_ip4_remote_endpoint (ip4 -> daddr);\n", "    if (local_ep) {\n", "        struct ipv4_ct_tuple tuple = {\n", "            .nexthdr = ip4->protocol,\n", "            .daddr = ip4->daddr,\n", "            .saddr = ip4->saddr}\n", "        ;\n", "        ct_is_reply4 (get_ct_map4 (&tuple), ctx, ETH_HLEN + ipv4_hdrlen (ip4), &tuple, &is_reply);\n", "    }\n", "\n", "#ifdef ENABLE_MASQUERADE /* SNAT local pod to world packets */\n", "\n", "# ifdef IS_BPF_OVERLAY\n", "    return false;\n", "\n", "# endif\n", "\n", "#if defined(ENABLE_EGRESS_GATEWAY)\n", "    if (remote_ep && identity_is_cluster (remote_ep->sec_label))\n", "        goto skip_egress_gateway;\n", "    if (is_reply)\n", "        goto skip_egress_gateway;\n", "    egress_gw_policy = lookup_ip4_egress_gw_policy (ip4 -> saddr, ip4 -> daddr);\n", "    if (!egress_gw_policy)\n", "        goto skip_egress_gateway;\n", "    *addr = egress_gw_policy->egress_ip;\n", "    *from_endpoint = true;\n", "    return true;\n", "skip_egress_gateway :\n", "\n", "#endif\n", "\n", "#ifdef IPV4_SNAT_EXCLUSION_DST_CIDR\n", "    if (ipv4_is_in_subnet (ip4->daddr, IPV4_SNAT_EXCLUSION_DST_CIDR, IPV4_SNAT_EXCLUSION_DST_CIDR_LEN))\n", "        return false;\n", "\n", "#endif\n", "    if (local_ep && (local_ep->flags & ENDPOINT_F_HOST))\n", "        return false;\n", "    if (remote_ep) {\n", "\n", "#ifdef ENABLE_IP_MASQ_AGENT\n", "        struct lpm_v4_key pfx;\n", "        pfx.lpm.prefixlen = 32;\n", "        memcpy (pfx.lpm.data, &ip4->daddr, sizeof (pfx.addr));\n", "        if (map_lookup_elem (&IP_MASQ_AGENT_IPV4, &pfx))\n", "            return false;\n", "\n", "#endif\n", "\n", "#ifndef TUNNEL_MODE\n", "        if (identity_is_remote_node (remote_ep->sec_label))\n", "            return false;\n", "\n", "#endif\n", "        if (!is_reply && local_ep) {\n", "            *from_endpoint = true;\n", "            *addr = IPV4_MASQUERADE;\n", "            return true;\n", "        }\n", "    }\n", "\n", "#endif /*ENABLE_MASQUERADE */\n", "    return false;\n", "}\n"], "called_function_list": ["identity_is_remote_node", "__lookup_ip4_endpoint", "memcpy", "ipv4_is_in_subnet", "get_ct_map4", "lookup_ip4_egress_gw_policy", "ipv4_hdrlen", "ct_is_reply4", "identity_is_cluster"], "call_depth": 8, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "nodeport_nat_ipv4_fwd": [{"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 1261, "endLine": 1278, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "funcName": "nodeport_nat_ipv4_fwd", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx"], "output": "static__always_inlineint", "helper": ["CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["static __always_inline int nodeport_nat_ipv4_fwd (struct  __ctx_buff *ctx)\n", "{\n", "    bool from_endpoint = false;\n", "    struct ipv4_nat_target target = {\n", "        .min_port = NODEPORT_PORT_MIN_NAT,\n", "        .max_port = NODEPORT_PORT_MAX_NAT,\n", "        .addr = 0,}\n", "    ;\n", "    int ret = CTX_ACT_OK;\n", "    if (snat_v4_needed (ctx, &target.addr, &from_endpoint))\n", "        ret = snat_v4_process (ctx, NAT_DIR_EGRESS, &target, from_endpoint);\n", "    if (ret == NAT_PUNT_TO_STACK)\n", "        ret = CTX_ACT_OK;\n", "    return ret;\n", "}\n"], "called_function_list": ["snat_v4_process", "snat_v4_needed"], "call_depth": 9, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "rss_gen_src4": [{"capabilities": [], "helperCallParams": {}, "startLine": 1282, "endLine": 1290, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "funcName": "rss_gen_src4", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["__be32 client", " __be32 l4_hint"], "output": "static__always_inline__be32", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __be32 rss_gen_src4 (__be32 client, __be32 l4_hint)\n", "{\n", "    const __u32 bits = 32 - IPV4_RSS_PREFIX_BITS;\n", "    __be32 src = IPV4_RSS_PREFIX;\n", "    if (bits)\n", "        src |= bpf_htonl (hash_32 (client ^ l4_hint, bits));\n", "    return src;\n", "}\n"], "called_function_list": ["hash_32"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "dsr_set_ipip4": [{"capabilities": [{"capability": "read_skb", "read_skb": [{"Project": "cilium", "Return Type": "s64", "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ", "Return": " The checksum result, or a negative error code in case of failure.", "Function Name": "csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp", "lwt_in", "lwt_out", "lwt_xmit", "lwt_seg6local"], "capabilities": ["read_skb"]}]}], "helperCallParams": {}, "startLine": 1298, "endLine": 1350, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "funcName": "dsr_set_ipip4", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " const struct iphdr *ip4", " __be32 backend_addr", " __be32 l4_hint", " __be16 *ohead"], "output": "static__always_inlineint", "helper": ["csum_diff"], "compatibleHookpoints": ["sched_cls", "lwt_xmit", "xdp", "lwt_in", "sched_act", "lwt_out", "lwt_seg6local"], "source": ["static __always_inline int dsr_set_ipip4 (struct  __ctx_buff *ctx, const struct iphdr *ip4, __be32 backend_addr, __be32 l4_hint, __be16 *ohead)\n", "{\n", "    __u16 tot_len = bpf_ntohs (ip4->tot_len) + sizeof (*ip4);\n", "    const int l3_off = ETH_HLEN;\n", "    __be32 sum;\n", "    struct {\n", "        __be16 tot_len;\n", "        __be16 id;\n", "        __be16 frag_off;\n", "        __u8 ttl;\n", "        __u8 protocol;\n", "        __be32 saddr;\n", "        __be32 daddr;\n", "    } tp_old = {\n", "        .tot_len = ip4->tot_len,\n", "        .ttl = ip4->ttl,\n", "        .protocol = ip4->protocol,\n", "        .saddr = ip4->saddr,\n", "        .daddr = ip4->daddr,}, tp_new = {\n", "        .tot_len = bpf_htons (tot_len),\n", "        .ttl = IPDEFTTL,\n", "        .protocol = IPPROTO_IPIP,\n", "        .saddr = rss_gen_src4 (ip4->saddr, l4_hint),\n", "        .daddr = backend_addr,};\n", "\n", "    if (dsr_is_too_big (ctx, tot_len)) {\n", "        *ohead = sizeof (*ip4);\n", "        return DROP_FRAG_NEEDED;\n", "    }\n", "    if (ctx_adjust_hroom (ctx, sizeof (*ip4), BPF_ADJ_ROOM_NET, ctx_adjust_hroom_dsr_flags ()))\n", "        return DROP_INVALID;\n", "    sum = csum_diff (& tp_old, 16, & tp_new, 16, 0);\n", "    if (ctx_store_bytes (ctx, l3_off + offsetof (struct iphdr, tot_len), &tp_new.tot_len, 2, 0) < 0)\n", "        return DROP_WRITE_ERROR;\n", "    if (ctx_store_bytes (ctx, l3_off + offsetof (struct iphdr, ttl), &tp_new.ttl, 2, 0) < 0)\n", "        return DROP_WRITE_ERROR;\n", "    if (ctx_store_bytes (ctx, l3_off + offsetof (struct iphdr, saddr), &tp_new.saddr, 8, 0) < 0)\n", "        return DROP_WRITE_ERROR;\n", "    if (l3_csum_replace (ctx, l3_off + offsetof (struct iphdr, check), 0, sum, 0) < 0)\n", "        return DROP_CSUM_L3;\n", "    return 0;\n", "}\n"], "called_function_list": ["rss_gen_src4", "dsr_is_too_big", "ctx_adjust_hroom_dsr_flags", "ctx_adjust_hroom"], "call_depth": 3, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "dsr_set_opt4": [{"capabilities": [{"capability": "read_skb", "read_skb": [{"Project": "cilium", "Return Type": "s64", "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ", "Return": " The checksum result, or a negative error code in case of failure.", "Function Name": "csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp", "lwt_in", "lwt_out", "lwt_xmit", "lwt_seg6local"], "capabilities": ["read_skb"]}]}], "helperCallParams": {}, "startLine": 1352, "endLine": 1404, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "funcName": "dsr_set_opt4", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " struct iphdr *ip4", " __be32 svc_addr", " __be32 svc_port", " __be16 *ohead"], "output": "static__always_inlineint", "helper": ["csum_diff"], "compatibleHookpoints": ["sched_cls", "lwt_xmit", "xdp", "lwt_in", "sched_act", "lwt_out", "lwt_seg6local"], "source": ["static __always_inline int dsr_set_opt4 (struct  __ctx_buff *ctx, struct iphdr *ip4, __be32 svc_addr, __be32 svc_port, __be16 *ohead)\n", "{\n", "    __u32 iph_old, iph_new, opt [2];\n", "    __u16 tot_len = bpf_ntohs (ip4->tot_len) + sizeof (opt);\n", "    __be32 sum;\n", "    if (ip4->protocol == IPPROTO_TCP) {\n", "        union tcp_flags tcp_flags = {\n", "            .value = 0}\n", "        ;\n", "        if (ctx_load_bytes (ctx, ETH_HLEN + sizeof (*ip4) + 12, &tcp_flags, 2) < 0)\n", "            return DROP_CT_INVALID_HDR;\n", "        if (!(tcp_flags.value & (TCP_FLAG_SYN)))\n", "            return 0;\n", "    }\n", "    if (dsr_is_too_big (ctx, tot_len)) {\n", "        *ohead = sizeof (opt);\n", "        return DROP_FRAG_NEEDED;\n", "    }\n", "    iph_old = *(__u32*) ip4;\n", "    ip4->ihl += sizeof (opt) >> 2;\n", "    ip4->tot_len = bpf_htons (tot_len);\n", "    iph_new = *(__u32*) ip4;\n", "    opt[0] = bpf_htonl (DSR_IPV4_OPT_32 | svc_port);\n", "    opt[1] = bpf_htonl (svc_addr);\n", "    sum = csum_diff (& iph_old, 4, & iph_new, 4, 0);\n", "    sum = csum_diff (NULL, 0, & opt, sizeof (opt), sum);\n", "    if (ctx_adjust_hroom (ctx, sizeof (opt), BPF_ADJ_ROOM_NET, ctx_adjust_hroom_dsr_flags ()))\n", "        return DROP_INVALID;\n", "    if (ctx_store_bytes (ctx, ETH_HLEN + sizeof (*ip4), &opt, sizeof (opt), 0) < 0)\n", "        return DROP_INVALID;\n", "    if (l3_csum_replace (ctx, ETH_HLEN + offsetof (struct iphdr, check), 0, sum, 0) < 0)\n", "        return DROP_CSUM_L3;\n", "    return 0;\n", "}\n"], "called_function_list": ["dsr_is_too_big", "ctx_adjust_hroom_dsr_flags", "ctx_adjust_hroom"], "call_depth": 3, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "handle_dsr_v4": [{"capabilities": [], "helperCallParams": {}, "startLine": 1407, "endLine": 1446, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "funcName": "handle_dsr_v4", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " bool *dsr"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int handle_dsr_v4 (struct  __ctx_buff *ctx, bool *dsr)\n", "{\n", "    void *data, *data_end;\n", "    struct iphdr *ip4;\n", "    if (!revalidate_data (ctx, &data, &data_end, &ip4))\n", "        return DROP_INVALID;\n", "    if (ip4->ihl == 0x7) {\n", "        __u32 opt1 = 0, opt2 = 0;\n", "        __be32 address;\n", "        __be16 dport;\n", "        if (ctx_load_bytes (ctx, ETH_HLEN + sizeof (struct iphdr), &opt1, sizeof (opt1)) < 0)\n", "            return DROP_INVALID;\n", "        opt1 = bpf_ntohl (opt1);\n", "        if ((opt1 & DSR_IPV4_OPT_MASK) == DSR_IPV4_OPT_32) {\n", "            if (ctx_load_bytes (ctx, ETH_HLEN + sizeof (struct iphdr) + sizeof (opt1), &opt2, sizeof (opt2)) < 0)\n", "                return DROP_INVALID;\n", "            opt2 = bpf_ntohl (opt2);\n", "            dport = opt1 & DSR_IPV4_DPORT_MASK;\n", "            address = opt2;\n", "            *dsr = true;\n", "            if (snat_v4_create_dsr (ctx, address, dport) < 0)\n", "                return DROP_INVALID;\n", "        }\n", "    }\n", "    return 0;\n", "}\n"], "called_function_list": ["snat_v4_create_dsr"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "xlate_dsr_v4": [{"capabilities": [], "helperCallParams": {}, "startLine": 1448, "endLine": 1464, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "funcName": "xlate_dsr_v4", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " const struct ipv4_ct_tuple *tuple", " int l4_off", " bool has_l4_header"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int xlate_dsr_v4 (struct  __ctx_buff *ctx, const struct ipv4_ct_tuple *tuple, int l4_off, bool has_l4_header)\n", "{\n", "    struct ipv4_ct_tuple nat_tup = *tuple;\n", "    struct ipv4_nat_entry *entry;\n", "    int ret = 0;\n", "    nat_tup.flags = NAT_DIR_EGRESS;\n", "    nat_tup.sport = tuple->dport;\n", "    nat_tup.dport = tuple->sport;\n", "    entry = snat_v4_lookup (& nat_tup);\n", "    if (entry)\n", "        ret = snat_v4_rewrite_egress (ctx, &nat_tup, entry, l4_off, has_l4_header);\n", "    return ret;\n", "}\n"], "called_function_list": ["snat_v4_rewrite_egress", "snat_v4_lookup"], "call_depth": 3, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "dsr_reply_icmp4": [{"capabilities": [{"capability": "read_skb", "read_skb": [{"Project": "cilium", "Return Type": "s64", "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ", "Return": " The checksum result, or a negative error code in case of failure.", "Function Name": "csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp", "lwt_in", "lwt_out", "lwt_xmit", "lwt_seg6local"], "capabilities": ["read_skb"]}]}], "helperCallParams": {}, "startLine": 1466, "endLine": 1549, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "funcName": "dsr_reply_icmp4", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " struct iphdr * ip4 __maybe_unused", " int code", " __be16 ohead __maybe_unused"], "output": "static__always_inlineint", "helper": ["csum_diff"], "compatibleHookpoints": ["sched_cls", "lwt_xmit", "xdp", "lwt_in", "sched_act", "lwt_out", "lwt_seg6local"], "source": ["static __always_inline int dsr_reply_icmp4 (struct  __ctx_buff *ctx, struct iphdr * ip4 __maybe_unused, int code, __be16 ohead __maybe_unused)\n", "{\n", "\n", "#ifdef ENABLE_DSR_ICMP_ERRORS\n", "    const __s32 orig_dgram = 8, off = ETH_HLEN;\n", "    const __u32 l3_max = MAX_IPOPTLEN + sizeof (*ip4) + orig_dgram;\n", "    __be16 type = bpf_htons (ETH_P_IP);\n", "    __s32 len_new = off + ipv4_hdrlen (ip4) + orig_dgram;\n", "    __s32 len_old = ctx_full_len (ctx);\n", "    __u8 reason = (__u8) -code;\n", "    __u8 tmp [l3_max];\n", "    union macaddr smac, dmac;\n", "    struct icmphdr icmp __align_stack_8 = {\n", "        .type = ICMP_DEST_UNREACH,\n", "        .code = ICMP_FRAG_NEEDED,\n", "        .un = {\n", "            .frag = {\n", "                .mtu = bpf_htons (THIS_MTU - ohead),},},}\n", "    ;\n", "    __u64 tot_len = sizeof (struct iphdr) + ipv4_hdrlen (ip4) + sizeof (icmp) + orig_dgram;\n", "    struct iphdr ip __align_stack_8 = {\n", "        .ihl = sizeof (ip) >> 2,\n", "        .version = IPVERSION,\n", "        .ttl = IPDEFTTL,\n", "        .tos = ip4->tos,\n", "        .id = ip4->id,\n", "        .protocol = IPPROTO_ICMP,\n", "        .saddr = ip4->daddr,\n", "        .daddr = ip4->saddr,\n", "        .frag_off = bpf_htons (IP_DF),\n", "        .tot_len = bpf_htons ((__u16) tot_len),}\n", "    ;\n", "    update_metrics (ctx_full_len (ctx), METRIC_EGRESS, reason);\n", "    if (eth_load_saddr (ctx, smac.addr, 0) < 0)\n", "        goto drop_err;\n", "    if (eth_load_daddr (ctx, dmac.addr, 0) < 0)\n", "        goto drop_err;\n", "    ip.check = csum_fold (csum_diff (NULL, 0, &ip, sizeof (ip), 0));\n", "    memset (tmp, 0, MAX_IPOPTLEN);\n", "    if (ctx_store_bytes (ctx, len_new, tmp, MAX_IPOPTLEN, 0) < 0)\n", "        goto drop_err;\n", "    if (ctx_load_bytes (ctx, off, tmp, sizeof (tmp)) < 0)\n", "        goto drop_err;\n", "    icmp.checksum = csum_fold (csum_diff (NULL, 0, tmp, sizeof (tmp), csum_diff (NULL, 0, &icmp, sizeof (icmp), 0)));\n", "    if (ctx_adjust_troom (ctx, -(len_old - len_new)) < 0)\n", "        goto drop_err;\n", "    if (ctx_adjust_hroom (ctx, sizeof (ip) + sizeof (icmp), BPF_ADJ_ROOM_NET, ctx_adjust_hroom_dsr_flags ()) < 0)\n", "        goto drop_err;\n", "    if (eth_store_daddr (ctx, smac.addr, 0) < 0)\n", "        goto drop_err;\n", "    if (eth_store_saddr (ctx, dmac.addr, 0) < 0)\n", "        goto drop_err;\n", "    if (ctx_store_bytes (ctx, ETH_ALEN * 2, &type, sizeof (type), 0) < 0)\n", "        goto drop_err;\n", "    if (ctx_store_bytes (ctx, off, &ip, sizeof (ip), 0) < 0)\n", "        goto drop_err;\n", "    if (ctx_store_bytes (ctx, off + sizeof (ip), &icmp, sizeof (icmp), 0) < 0)\n", "        goto drop_err;\n", "    return ctx_redirect (ctx, ctx_get_ifindex (ctx), 0);\n", "drop_err :\n", "\n", "#endif\n", "    return send_drop_notify_error (ctx, 0, code, CTX_ACT_DROP, METRIC_EGRESS);\n", "}\n"], "called_function_list": ["csum_fold", "update_metrics", "ctx_adjust_troom", "ctx_get_ifindex", "eth_store_daddr", "eth_store_saddr", "ctx_full_len", "ipv4_hdrlen", "ctx_adjust_hroom_dsr_flags", "ctx_adjust_hroom", "eth_load_daddr", "ctx_redirect", "memset", "eth_load_saddr"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "tail_nodeport_ipv4_dsr": [{"capabilities": [{"capability": "read_sys_info", "read_sys_info": [{"Project": "libbpf", "Return Type": "int", "Description": "Do FIB lookup in kernel tables using parameters in params. If lookup is successful and result shows packet is to be forwarded , the neighbor tables are searched for the nexthop. If successful (ie. , FIB lookup shows forwarding and nexthop is resolved) , the nexthop address is returned in ipv4_dst or ipv6_dst based on family , smac is set to mac address of egress device , dmac is set to nexthop mac address , rt_metric is set to metric from route (IPv4/IPv6 only) , and ifindex is set to the device index of the nexthop from the FIB lookup. <[ plen ]>(IP: 2) argument is the size of the passed in struct. <[ flags ]>(IP: 3) argument can be a combination of one or more of the following values: BPF_FIB_LOOKUP_DIRECT Do a direct table lookup vs full lookup using FIB rules. BPF_FIB_LOOKUP_OUTPUT Perform lookup from an egress perspective (default is ingress). <[ ctx ]>(IP: 0) is either struct xdp_md for XDP programs or struct sk_buff tc cls_act programs. Return \u00b7 < 0 if any input argument is invalid \u00b7 0 on success (packet is forwarded , nexthop neighbor exists) \u00b7 > 0 one of BPF_FIB_LKUP_RET_ codes explaining why the packet is not forwarded or needs assist from full stack ", "Function Name": "bpf_fib_lookup", "Input Params": ["{Type: void ,Var: *ctx}", "{Type:  struct bpf_fib_lookup ,Var: *params}", "{Type:  int ,Var: plen}", "{Type:  u32 ,Var: flags}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp"], "capabilities": ["read_sys_info"]}, {"Project": "cilium", "Return Type": "int", "Description": "Do FIB lookup in kernel tables using parameters in params. If lookup is successful and result shows packet is to be forwarded , the neighbor tables are searched for the nexthop. If successful (ie. , FIB lookup shows forwarding and nexthop is resolved) , the nexthop address is returned in ipv4_dst or ipv6_dst based on family , smac is set to mac address of egress device , dmac is set to nexthop mac address , rt_metric is set to metric from route (IPv4/IPv6 only) , and ifindex is set to the device index of the nexthop from the FIB lookup. <[ plen ]>(IP: 2) argument is the size of the passed in struct. <[ flags ]>(IP: 3) argument can be a combination of one or more of the following values: BPF_FIB_LOOKUP_DIRECT Do a direct table lookup vs full lookup using FIB rules. BPF_FIB_LOOKUP_OUTPUT Perform lookup from an egress perspective (default is ingress). <[ ctx ]>(IP: 0) is either struct xdp_md for XDP programs or struct sk_buff tc cls_act programs. Return \u00b7 < 0 if any input argument is invalid \u00b7 0 on success (packet is forwarded , nexthop neighbor exists) \u00b7 > 0 one of BPF_FIB_LKUP_RET_ codes explaining why the packet is not forwarded or needs assist from full stack ", "Function Name": "fib_lookup", "Input Params": ["{Type: void ,Var: *ctx}", "{Type:  struct fib_lookup ,Var: *params}", "{Type:  int ,Var: plen}", "{Type:  u32 ,Var: flags}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp"], "capabilities": ["read_sys_info"]}]}], "helperCallParams": {}, "startLine": 1552, "endLine": 1621, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "funcName": "tail_nodeport_ipv4_dsr", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx"], "output": "int", "helper": ["bpf_fib_lookup", "fib_lookup"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["int tail_nodeport_ipv4_dsr (struct  __ctx_buff *ctx)\n", "{\n", "    struct bpf_fib_lookup_padded fib_params = {\n", "        .l = {\n", "            .family = AF_INET,\n", "            .ifindex = ctx_get_ifindex (ctx),},}\n", "    ;\n", "    bool l2_hdr_required = true;\n", "    void *data, *data_end;\n", "    struct iphdr *ip4;\n", "    __be16 ohead = 0;\n", "    int ret, ext_err = 0;\n", "    if (!revalidate_data (ctx, &data, &data_end, &ip4)) {\n", "        ret = DROP_INVALID;\n", "        goto drop_err;\n", "    }\n", "\n", "#if DSR_ENCAP_MODE == DSR_ENCAP_IPIP\n", "    ret = dsr_set_ipip4 (ctx, ip4, ctx_load_meta (ctx, CB_ADDR_V4), ctx_load_meta (ctx, CB_HINT), & ohead);\n", "\n", "#elif DSR_ENCAP_MODE == DSR_ENCAP_NONE\n", "    ret = dsr_set_opt4 (ctx, ip4, ctx_load_meta (ctx, CB_ADDR_V4), ctx_load_meta (ctx, CB_PORT), & ohead);\n", "\n", "#else\n", "\n", "# error \"Invalid load balancer DSR encapsulation mode!\"\n", "\n", "#endif\n", "    if (unlikely (ret)) {\n", "        if (dsr_fail_needs_reply (ret))\n", "            return dsr_reply_icmp4 (ctx, ip4, ret, ohead);\n", "        goto drop_err;\n", "    }\n", "    if (!revalidate_data (ctx, &data, &data_end, &ip4)) {\n", "        ret = DROP_INVALID;\n", "        goto drop_err;\n", "    }\n", "    fib_params.l.ipv4_src = ip4->saddr;\n", "    fib_params.l.ipv4_dst = ip4->daddr;\n", "    ret = fib_lookup (ctx, & fib_params.l, sizeof (fib_params), 0);\n", "    if (ret != 0) {\n", "        ext_err = ret;\n", "        ret = DROP_NO_FIB;\n", "        goto drop_err;\n", "    }\n", "    ret = maybe_add_l2_hdr (ctx, fib_params.l.ifindex, & l2_hdr_required);\n", "    if (ret != 0)\n", "        goto drop_err;\n", "    if (!l2_hdr_required)\n", "        goto out_send;\n", "    if (eth_store_daddr (ctx, fib_params.l.dmac, 0) < 0) {\n", "        ret = DROP_WRITE_ERROR;\n", "        goto drop_err;\n", "    }\n", "    if (eth_store_saddr (ctx, fib_params.l.smac, 0) < 0) {\n", "        ret = DROP_WRITE_ERROR;\n", "        goto drop_err;\n", "    }\n", "out_send :\n", "    cilium_capture_out (ctx);\n", "    return ctx_redirect (ctx, fib_params.l.ifindex, 0);\n", "drop_err :\n", "    return send_drop_notify_error_ext (ctx, 0, ret, ext_err, CTX_ACT_DROP, METRIC_EGRESS);\n", "}\n"], "called_function_list": ["dsr_reply_icmp4", "dsr_fail_needs_reply", "ctx_get_ifindex", "cilium_capture_out", "eth_store_daddr", "eth_store_saddr", "maybe_add_l2_hdr", "dsr_set_ipip4", "ctx_load_meta", "dsr_set_opt4", "ctx_redirect"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "tail_nodeport_nat_ipv4": [{"capabilities": [{"capability": "read_sys_info", "read_sys_info": [{"Project": "libbpf", "Return Type": "int", "Description": "Do FIB lookup in kernel tables using parameters in params. If lookup is successful and result shows packet is to be forwarded , the neighbor tables are searched for the nexthop. If successful (ie. , FIB lookup shows forwarding and nexthop is resolved) , the nexthop address is returned in ipv4_dst or ipv6_dst based on family , smac is set to mac address of egress device , dmac is set to nexthop mac address , rt_metric is set to metric from route (IPv4/IPv6 only) , and ifindex is set to the device index of the nexthop from the FIB lookup. <[ plen ]>(IP: 2) argument is the size of the passed in struct. <[ flags ]>(IP: 3) argument can be a combination of one or more of the following values: BPF_FIB_LOOKUP_DIRECT Do a direct table lookup vs full lookup using FIB rules. BPF_FIB_LOOKUP_OUTPUT Perform lookup from an egress perspective (default is ingress). <[ ctx ]>(IP: 0) is either struct xdp_md for XDP programs or struct sk_buff tc cls_act programs. Return \u00b7 < 0 if any input argument is invalid \u00b7 0 on success (packet is forwarded , nexthop neighbor exists) \u00b7 > 0 one of BPF_FIB_LKUP_RET_ codes explaining why the packet is not forwarded or needs assist from full stack ", "Function Name": "bpf_fib_lookup", "Input Params": ["{Type: void ,Var: *ctx}", "{Type:  struct bpf_fib_lookup ,Var: *params}", "{Type:  int ,Var: plen}", "{Type:  u32 ,Var: flags}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp"], "capabilities": ["read_sys_info"]}, {"Project": "cilium", "Return Type": "int", "Description": "Do FIB lookup in kernel tables using parameters in params. If lookup is successful and result shows packet is to be forwarded , the neighbor tables are searched for the nexthop. If successful (ie. , FIB lookup shows forwarding and nexthop is resolved) , the nexthop address is returned in ipv4_dst or ipv6_dst based on family , smac is set to mac address of egress device , dmac is set to nexthop mac address , rt_metric is set to metric from route (IPv4/IPv6 only) , and ifindex is set to the device index of the nexthop from the FIB lookup. <[ plen ]>(IP: 2) argument is the size of the passed in struct. <[ flags ]>(IP: 3) argument can be a combination of one or more of the following values: BPF_FIB_LOOKUP_DIRECT Do a direct table lookup vs full lookup using FIB rules. BPF_FIB_LOOKUP_OUTPUT Perform lookup from an egress perspective (default is ingress). <[ ctx ]>(IP: 0) is either struct xdp_md for XDP programs or struct sk_buff tc cls_act programs. Return \u00b7 < 0 if any input argument is invalid \u00b7 0 on success (packet is forwarded , nexthop neighbor exists) \u00b7 > 0 one of BPF_FIB_LKUP_RET_ codes explaining why the packet is not forwarded or needs assist from full stack ", "Function Name": "fib_lookup", "Input Params": ["{Type: void ,Var: *ctx}", "{Type:  struct fib_lookup ,Var: *params}", "{Type:  int ,Var: plen}", "{Type:  u32 ,Var: flags}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp"], "capabilities": ["read_sys_info"]}]}], "helperCallParams": {}, "startLine": 1625, "endLine": 1767, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "funcName": "tail_nodeport_nat_ipv4", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx"], "output": "int", "helper": ["bpf_fib_lookup", "fib_lookup"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["int tail_nodeport_nat_ipv4 (struct  __ctx_buff *ctx)\n", "{\n", "    enum nat_dir dir = (enum nat_dir) ctx_load_meta (ctx, CB_NAT);\n", "    struct bpf_fib_lookup_padded fib_params = {\n", "        .l = {\n", "            .family = AF_INET,\n", "            .ifindex = ctx_get_ifindex (ctx),},}\n", "    ;\n", "    struct ipv4_nat_target target = {\n", "        .min_port = NODEPORT_PORT_MIN_NAT,\n", "        .max_port = NODEPORT_PORT_MAX_NAT,\n", "        .src_from_world = true,}\n", "    ;\n", "    void *data, *data_end;\n", "    struct iphdr *ip4;\n", "    bool l2_hdr_required = true;\n", "    int ret, ext_err = 0;\n", "    target.addr = IPV4_DIRECT_ROUTING;\n", "\n", "#ifdef TUNNEL_MODE\n", "    if (dir == NAT_DIR_EGRESS) {\n", "        struct remote_endpoint_info *info;\n", "        if (!revalidate_data (ctx, &data, &data_end, &ip4)) {\n", "            ret = DROP_INVALID;\n", "            goto drop_err;\n", "        }\n", "        info = ipcache_lookup4 (& IPCACHE_MAP, ip4 -> daddr, V4_CACHE_KEY_LEN);\n", "        if (info != NULL && info->tunnel_endpoint != 0) {\n", "            ret = __encap_with_nodeid (ctx, info -> tunnel_endpoint, WORLD_ID, NOT_VTEP_DST, (enum trace_reason) CT_NEW, TRACE_PAYLOAD_LEN);\n", "            if (ret)\n", "                goto drop_err;\n", "            target.addr = IPV4_GATEWAY;\n", "            fib_params.l.ifindex = ENCAP_IFINDEX;\n", "            if (eth_store_daddr (ctx, fib_params.l.dmac, 0) < 0) {\n", "                ret = DROP_WRITE_ERROR;\n", "                goto drop_err;\n", "            }\n", "            if (eth_store_saddr (ctx, fib_params.l.smac, 0) < 0) {\n", "                ret = DROP_WRITE_ERROR;\n", "                goto drop_err;\n", "            }\n", "        }\n", "    }\n", "\n", "#endif\n", "    ret = snat_v4_process (ctx, dir, & target, false);\n", "    if (IS_ERR (ret)) {\n", "        if (dir == NAT_DIR_INGRESS) {\n", "            bpf_skip_nodeport_set (ctx);\n", "            ep_tail_call (ctx, CILIUM_CALL_IPV4_FROM_NETDEV);\n", "            ret = DROP_MISSED_TAIL_CALL;\n", "            goto drop_err;\n", "        }\n", "        if (ret != NAT_PUNT_TO_STACK)\n", "            goto drop_err;\n", "    }\n", "    bpf_mark_snat_done (ctx);\n", "    if (dir == NAT_DIR_INGRESS) {\n", "        ep_tail_call (ctx, CILIUM_CALL_IPV4_NODEPORT_REVNAT);\n", "        ret = DROP_MISSED_TAIL_CALL;\n", "        goto drop_err;\n", "    }\n", "\n", "#ifdef TUNNEL_MODE\n", "    if (fib_params.l.ifindex == ENCAP_IFINDEX)\n", "        goto out_send;\n", "\n", "#endif\n", "    if (!revalidate_data (ctx, &data, &data_end, &ip4)) {\n", "        ret = DROP_INVALID;\n", "        goto drop_err;\n", "    }\n", "    fib_params.l.ipv4_src = ip4->saddr;\n", "    fib_params.l.ipv4_dst = ip4->daddr;\n", "    ret = fib_lookup (ctx, & fib_params.l, sizeof (fib_params), 0);\n", "    if (ret != 0) {\n", "        ext_err = ret;\n", "        ret = DROP_NO_FIB;\n", "        goto drop_err;\n", "    }\n", "    ret = maybe_add_l2_hdr (ctx, fib_params.l.ifindex, & l2_hdr_required);\n", "    if (ret != 0)\n", "        goto drop_err;\n", "    if (!l2_hdr_required)\n", "        goto out_send;\n", "    if (eth_store_daddr (ctx, fib_params.l.dmac, 0) < 0) {\n", "        ret = DROP_WRITE_ERROR;\n", "        goto drop_err;\n", "    }\n", "    if (eth_store_saddr (ctx, fib_params.l.smac, 0) < 0) {\n", "        ret = DROP_WRITE_ERROR;\n", "        goto drop_err;\n", "    }\n", "out_send :\n", "    cilium_capture_out (ctx);\n", "    return ctx_redirect (ctx, fib_params.l.ifindex, 0);\n", "drop_err :\n", "    return send_drop_notify_error_ext (ctx, 0, ret, ext_err, CTX_ACT_DROP, dir == NAT_DIR_INGRESS ? METRIC_INGRESS : METRIC_EGRESS);\n", "}\n"], "called_function_list": ["ctx_get_ifindex", "bpf_mark_snat_done", "ep_tail_call", "eth_store_daddr", "eth_store_saddr", "maybe_add_l2_hdr", "ctx_load_meta", "__encap_with_nodeid", "cilium_capture_out", "ctx_redirect", "ipcache_lookup4", "bpf_skip_nodeport_set", "snat_v4_process"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "nodeport_lb4": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}, {"capability": "map_update", "map_update": [{"Project": "cilium", "Return Type": "int", "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "map_update_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}", "{Type:  const void ,Var: *value}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_update"]}]}, {"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 1773, "endLine": 1943, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "funcName": "nodeport_lb4", "developer_inline_comments": [], "updateMaps": ["  NODEPORT_NEIGH4"], "readMaps": ["  NODEPORT_NEIGH4"], "input": ["struct  __ctx_buff *ctx", " __u32 src_identity"], "output": "static__always_inlineint", "helper": ["map_lookup_elem", "map_update_elem", "CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["static __always_inline int nodeport_lb4 (struct  __ctx_buff *ctx, __u32 src_identity)\n", "{\n", "    struct ipv4_ct_tuple tuple = {}\n", "    ;\n", "    void *data, *data_end;\n", "    struct iphdr *ip4;\n", "    int ret, l3_off = ETH_HLEN, l4_off;\n", "    struct csum_offset csum_off = {}\n", "    ;\n", "    struct lb4_service *svc;\n", "    struct lb4_key key = {}\n", "    ;\n", "    struct ct_state ct_state_new = {}\n", "    ;\n", "    union macaddr smac, *mac;\n", "    bool backend_local;\n", "    __u32 monitor = 0;\n", "    cilium_capture_in (ctx);\n", "    if (!revalidate_data (ctx, &data, &data_end, &ip4))\n", "        return DROP_INVALID;\n", "    tuple.nexthdr = ip4->protocol;\n", "    tuple.daddr = ip4->daddr;\n", "    tuple.saddr = ip4->saddr;\n", "    l4_off = l3_off + ipv4_hdrlen (ip4);\n", "    ret = lb4_extract_key (ctx, ip4, l4_off, & key, & csum_off, CT_EGRESS);\n", "    if (IS_ERR (ret)) {\n", "        if (ret == DROP_NO_SERVICE)\n", "            goto skip_service_lookup;\n", "        else if (ret == DROP_UNKNOWN_L4)\n", "            return CTX_ACT_OK;\n", "        else\n", "            return ret;\n", "    }\n", "    svc = lb4_lookup_service (& key, false);\n", "    if (svc) {\n", "        const bool skip_l3_xlate = DSR_ENCAP_MODE == DSR_ENCAP_IPIP;\n", "        if (!lb4_src_range_ok (svc, ip4->saddr))\n", "            return DROP_NOT_IN_SRC_RANGE;\n", "\n", "#if defined(ENABLE_L7_LB)\n", "        if (lb4_svc_is_l7loadbalancer (svc) && svc->l7_lb_proxy_port > 0) {\n", "            send_trace_notify (ctx, TRACE_TO_PROXY, src_identity, 0, bpf_ntohs ((__u16) svc->l7_lb_proxy_port), 0, TRACE_REASON_POLICY, monitor);\n", "            return ctx_redirect_to_proxy_hairpin_ipv4 (ctx, (__be16) svc->l7_lb_proxy_port);\n", "        }\n", "\n", "#endif\n", "        if (lb4_to_lb6_service (svc)) {\n", "            ret = lb4_to_lb6 (ctx, ip4, l3_off);\n", "            if (!ret)\n", "                return NAT_46X64_RECIRC;\n", "        }\n", "        else {\n", "            ret = lb4_local (get_ct_map4 (& tuple), ctx, l3_off, l4_off, & csum_off, & key, & tuple, svc, & ct_state_new, ip4 -> saddr, ipv4_has_l4_header (ip4), skip_l3_xlate);\n", "        }\n", "        if (IS_ERR (ret))\n", "            return ret;\n", "    }\n", "    if (!svc || !lb4_svc_is_routable (svc)) {\n", "        if (svc)\n", "            return DROP_IS_CLUSTER_IP;\n", "    skip_service_lookup :\n", "        ctx_set_xfer (ctx, XFER_PKT_NO_SVC);\n", "\n", "#ifndef ENABLE_MASQUERADE\n", "        if (nodeport_uses_dsr4 (&tuple))\n", "            return CTX_ACT_OK;\n", "\n", "#endif\n", "        ctx_store_meta (ctx, CB_NAT, NAT_DIR_INGRESS);\n", "        ctx_store_meta (ctx, CB_SRC_IDENTITY, src_identity);\n", "        if (!lb4_populate_ports (ctx, &tuple, l4_off) && snat_v6_has_v4_match (&tuple)) {\n", "            ret = lb4_to_lb6 (ctx, ip4, l3_off);\n", "            if (ret)\n", "                return ret;\n", "            ep_tail_call (ctx, CILIUM_CALL_IPV6_NODEPORT_NAT);\n", "        }\n", "        else {\n", "            ep_tail_call (ctx, CILIUM_CALL_IPV4_NODEPORT_NAT);\n", "        }\n", "        return DROP_MISSED_TAIL_CALL;\n", "    }\n", "    backend_local = __lookup_ip4_endpoint (tuple.daddr);\n", "    if (!backend_local && lb4_svc_is_hostport (svc))\n", "        return DROP_INVALID;\n", "    if (backend_local || !nodeport_uses_dsr4 (&tuple)) {\n", "        struct ct_state ct_state = {}\n", "        ;\n", "        ret = ct_lookup4 (get_ct_map4 (& tuple), & tuple, ctx, l4_off, CT_EGRESS, & ct_state, & monitor);\n", "        switch (ret) {\n", "        case CT_NEW :\n", "        redo :\n", "            ct_state_new.src_sec_id = WORLD_ID;\n", "            ct_state_new.node_port = 1;\n", "            ct_state_new.ifindex = (__u16) NATIVE_DEV_IFINDEX;\n", "            ret = ct_create4 (get_ct_map4 (& tuple), NULL, & tuple, ctx, CT_EGRESS, & ct_state_new, false, false);\n", "            if (IS_ERR (ret))\n", "                return ret;\n", "            break;\n", "        case CT_REOPENED :\n", "        case CT_ESTABLISHED :\n", "        case CT_REPLY :\n", "            if (unlikely (ct_state.rev_nat_index != svc->rev_nat_index))\n", "                goto redo;\n", "            break;\n", "        default :\n", "            return DROP_UNKNOWN_CT;\n", "        }\n", "        if (!revalidate_data (ctx, &data, &data_end, &ip4))\n", "            return DROP_INVALID;\n", "        if (eth_load_saddr (ctx, smac.addr, 0) < 0)\n", "            return DROP_INVALID;\n", "        mac = map_lookup_elem (& NODEPORT_NEIGH4, & ip4 -> saddr);\n", "        if (!mac || eth_addrcmp (mac, &smac)) {\n", "            ret = map_update_elem (& NODEPORT_NEIGH4, & ip4 -> saddr, & smac, 0);\n", "            if (ret < 0)\n", "                return ret;\n", "        }\n", "    }\n", "    if (!backend_local) {\n", "        edt_set_aggregate (ctx, 0);\n", "        if (nodeport_uses_dsr4 (&tuple)) {\n", "\n", "#if DSR_ENCAP_MODE == DSR_ENCAP_IPIP\n", "            ctx_store_meta (ctx, CB_HINT, ((__u32) tuple.sport << 16) | tuple.dport);\n", "            ctx_store_meta (ctx, CB_ADDR_V4, tuple.daddr);\n", "\n", "#elif DSR_ENCAP_MODE == DSR_ENCAP_NONE\n", "            ctx_store_meta (ctx, CB_PORT, key.dport);\n", "            ctx_store_meta (ctx, CB_ADDR_V4, key.address);\n", "\n", "#endif /* DSR_ENCAP_MODE */\n", "            ep_tail_call (ctx, CILIUM_CALL_IPV4_NODEPORT_DSR);\n", "        }\n", "        else {\n", "            ctx_store_meta (ctx, CB_NAT, NAT_DIR_EGRESS);\n", "            ep_tail_call (ctx, CILIUM_CALL_IPV4_NODEPORT_NAT);\n", "        }\n", "        return DROP_MISSED_TAIL_CALL;\n", "    }\n", "    ctx_set_xfer (ctx, XFER_PKT_NO_SVC);\n", "    return CTX_ACT_OK;\n", "}\n"], "called_function_list": ["lb4_extract_key", "snat_v6_has_v4_match", "ct_lookup4", "ep_tail_call", "lb4_to_lb6", "ct_create4", "ctx_set_xfer", "lb4_local", "lb4_svc_is_routable", "lb4_svc_is_hostport", "get_ct_map4", "lb4_src_range_ok", "ipv4_hdrlen", "lb4_svc_is_l7loadbalancer", "ctx_redirect_to_proxy_hairpin_ipv4", "__lookup_ip4_endpoint", "eth_addrcmp", "cilium_capture_in", "lb4_to_lb6_service", "eth_load_saddr", "send_trace_notify", "edt_set_aggregate", "lb4_lookup_service", "ctx_store_meta", "ipv4_has_l4_header", "lb4_populate_ports", "nodeport_uses_dsr4"], "call_depth": 5, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "rev_nodeport_lb4": [{"capabilities": [{"capability": "read_sys_info", "read_sys_info": [{"Project": "libbpf", "Return Type": "int", "Description": "Do FIB lookup in kernel tables using parameters in params. If lookup is successful and result shows packet is to be forwarded , the neighbor tables are searched for the nexthop. If successful (ie. , FIB lookup shows forwarding and nexthop is resolved) , the nexthop address is returned in ipv4_dst or ipv6_dst based on family , smac is set to mac address of egress device , dmac is set to nexthop mac address , rt_metric is set to metric from route (IPv4/IPv6 only) , and ifindex is set to the device index of the nexthop from the FIB lookup. <[ plen ]>(IP: 2) argument is the size of the passed in struct. <[ flags ]>(IP: 3) argument can be a combination of one or more of the following values: BPF_FIB_LOOKUP_DIRECT Do a direct table lookup vs full lookup using FIB rules. BPF_FIB_LOOKUP_OUTPUT Perform lookup from an egress perspective (default is ingress). <[ ctx ]>(IP: 0) is either struct xdp_md for XDP programs or struct sk_buff tc cls_act programs. Return \u00b7 < 0 if any input argument is invalid \u00b7 0 on success (packet is forwarded , nexthop neighbor exists) \u00b7 > 0 one of BPF_FIB_LKUP_RET_ codes explaining why the packet is not forwarded or needs assist from full stack ", "Function Name": "bpf_fib_lookup", "Input Params": ["{Type: void ,Var: *ctx}", "{Type:  struct bpf_fib_lookup ,Var: *params}", "{Type:  int ,Var: plen}", "{Type:  u32 ,Var: flags}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp"], "capabilities": ["read_sys_info"]}, {"Project": "cilium", "Return Type": "int", "Description": "Do FIB lookup in kernel tables using parameters in params. If lookup is successful and result shows packet is to be forwarded , the neighbor tables are searched for the nexthop. If successful (ie. , FIB lookup shows forwarding and nexthop is resolved) , the nexthop address is returned in ipv4_dst or ipv6_dst based on family , smac is set to mac address of egress device , dmac is set to nexthop mac address , rt_metric is set to metric from route (IPv4/IPv6 only) , and ifindex is set to the device index of the nexthop from the FIB lookup. <[ plen ]>(IP: 2) argument is the size of the passed in struct. <[ flags ]>(IP: 3) argument can be a combination of one or more of the following values: BPF_FIB_LOOKUP_DIRECT Do a direct table lookup vs full lookup using FIB rules. BPF_FIB_LOOKUP_OUTPUT Perform lookup from an egress perspective (default is ingress). <[ ctx ]>(IP: 0) is either struct xdp_md for XDP programs or struct sk_buff tc cls_act programs. Return \u00b7 < 0 if any input argument is invalid \u00b7 0 on success (packet is forwarded , nexthop neighbor exists) \u00b7 > 0 one of BPF_FIB_LKUP_RET_ codes explaining why the packet is not forwarded or needs assist from full stack ", "Function Name": "fib_lookup", "Input Params": ["{Type: void ,Var: *ctx}", "{Type:  struct fib_lookup ,Var: *params}", "{Type:  int ,Var: plen}", "{Type:  u32 ,Var: flags}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp"], "capabilities": ["read_sys_info"]}]}, {"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}, {"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 1955, "endLine": 2126, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "funcName": "rev_nodeport_lb4", "developer_inline_comments": [], "updateMaps": [], "readMaps": ["  NODEPORT_NEIGH4"], "input": ["struct  __ctx_buff *ctx", " int *ifindex", " int *ext_err"], "output": "static__always_inlineint", "helper": ["bpf_fib_lookup", "map_lookup_elem", "CTX_ACT_OK", "fib_lookup"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["static __always_inline int rev_nodeport_lb4 (struct  __ctx_buff *ctx, int *ifindex, int *ext_err)\n", "{\n", "    struct ipv4_ct_tuple tuple = {}\n", "    ;\n", "    void *data, *data_end;\n", "    struct iphdr *ip4;\n", "    struct csum_offset csum_off = {}\n", "    ;\n", "    int ret, fib_ret, ret2, l3_off = ETH_HLEN, l4_off;\n", "    struct ct_state ct_state = {}\n", "    ;\n", "    struct bpf_fib_lookup fib_params = {}\n", "    ;\n", "    enum trace_reason __maybe_unused reason = TRACE_REASON_UNKNOWN;\n", "    __u32 monitor = TRACE_PAYLOAD_LEN;\n", "    bool l2_hdr_required = true;\n", "    __u32 tunnel_endpoint __maybe_unused = 0;\n", "    if (!revalidate_data (ctx, &data, &data_end, &ip4))\n", "        return DROP_INVALID;\n", "    tuple.nexthdr = ip4->protocol;\n", "    tuple.daddr = ip4->daddr;\n", "    tuple.saddr = ip4->saddr;\n", "    l4_off = l3_off + ipv4_hdrlen (ip4);\n", "    csum_l4_offset_and_flags (tuple.nexthdr, &csum_off);\n", "\n", "#if defined(ENABLE_EGRESS_GATEWAY) && !defined(TUNNEL_MODE) && \\\n", "\t__ctx_is != __ctx_xdp\n", "    {\n", "        struct egress_gw_policy_entry *egress_policy;\n", "        egress_policy = lookup_ip4_egress_gw_policy (ip4 -> daddr, ip4 -> saddr);\n", "        if (egress_policy) {\n", "            struct remote_endpoint_info *info;\n", "            info = ipcache_lookup4 (& IPCACHE_MAP, ip4 -> daddr, V4_CACHE_KEY_LEN);\n", "            if (info && info->tunnel_endpoint != 0) {\n", "                tunnel_endpoint = info->tunnel_endpoint;\n", "                goto encap_redirect;\n", "            }\n", "        }\n", "    }\n", "\n", "#endif /* ENABLE_EGRESS_GATEWAY */\n", "    ret = ct_lookup4 (get_ct_map4 (& tuple), & tuple, ctx, l4_off, CT_INGRESS, & ct_state, & monitor);\n", "    if (ret == CT_REPLY && ct_state.node_port == 1 && ct_state.rev_nat_index != 0) {\n", "        reason = TRACE_REASON_CT_REPLY;\n", "        ret2 = lb4_rev_nat (ctx, l3_off, l4_off, & csum_off, & ct_state, & tuple, REV_NAT_F_TUPLE_SADDR, ipv4_has_l4_header (ip4));\n", "        if (IS_ERR (ret2))\n", "            return ret2;\n", "        if (!revalidate_data (ctx, &data, &data_end, &ip4))\n", "            return DROP_INVALID;\n", "        bpf_mark_snat_done (ctx);\n", "        *ifindex = ct_state.ifindex;\n", "\n", "#if defined(TUNNEL_MODE) && __ctx_is != __ctx_xdp\n", "        {\n", "            struct remote_endpoint_info *info;\n", "            info = ipcache_lookup4 (& IPCACHE_MAP, ip4 -> daddr, V4_CACHE_KEY_LEN);\n", "            if (info != NULL && info->tunnel_endpoint != 0) {\n", "                tunnel_endpoint = info->tunnel_endpoint;\n", "                goto encap_redirect;\n", "            }\n", "        }\n", "\n", "#endif\n", "        fib_params.family = AF_INET;\n", "        fib_params.ifindex = ctx_get_ifindex (ctx);\n", "        fib_params.ipv4_src = ip4->saddr;\n", "        fib_params.ipv4_dst = ip4->daddr;\n", "        fib_ret = fib_lookup (ctx, & fib_params, sizeof (fib_params), 0);\n", "        if (fib_ret == 0)\n", "            *ifindex = fib_params.ifindex;\n", "        ret = maybe_add_l2_hdr (ctx, * ifindex, & l2_hdr_required);\n", "        if (ret != 0)\n", "            return ret;\n", "        if (!l2_hdr_required)\n", "            return CTX_ACT_OK;\n", "        if (fib_ret != 0) {\n", "            union macaddr smac = NATIVE_DEV_MAC_BY_IFINDEX (* ifindex);\n", "            union macaddr *dmac;\n", "            if (fib_ret != BPF_FIB_LKUP_RET_NO_NEIGH) {\n", "                *ext_err = fib_ret;\n", "                return DROP_NO_FIB;\n", "            }\n", "            dmac = map_lookup_elem (& NODEPORT_NEIGH4, & tuple.daddr);\n", "            if (unlikely (!dmac)) {\n", "                *ext_err = fib_ret;\n", "                return DROP_NO_FIB;\n", "            }\n", "            if (eth_store_daddr_aligned (ctx, dmac->addr, 0) < 0)\n", "                return DROP_WRITE_ERROR;\n", "            if (eth_store_saddr_aligned (ctx, smac.addr, 0) < 0)\n", "                return DROP_WRITE_ERROR;\n", "        }\n", "        else {\n", "            if (eth_store_daddr (ctx, fib_params.dmac, 0) < 0)\n", "                return DROP_WRITE_ERROR;\n", "            if (eth_store_saddr (ctx, fib_params.smac, 0) < 0)\n", "                return DROP_WRITE_ERROR;\n", "        }\n", "    }\n", "    else {\n", "        if (!bpf_skip_recirculation (ctx)) {\n", "            bpf_skip_nodeport_set (ctx);\n", "            ep_tail_call (ctx, CILIUM_CALL_IPV4_FROM_NETDEV);\n", "            return DROP_MISSED_TAIL_CALL;\n", "        }\n", "    }\n", "    return CTX_ACT_OK;\n", "\n", "#if (defined(ENABLE_EGRESS_GATEWAY) || defined(TUNNEL_MODE)) && \\\n", "\t__ctx_is != __ctx_xdp\n", "encap_redirect :\n", "    ret = __encap_with_nodeid (ctx, tunnel_endpoint, SECLABEL, NOT_VTEP_DST, reason, monitor);\n", "    if (ret)\n", "        return ret;\n", "    *ifindex = ENCAP_IFINDEX;\n", "    if (eth_store_daddr (ctx, fib_params.dmac, 0) < 0)\n", "        return DROP_WRITE_ERROR;\n", "    if (eth_store_saddr (ctx, fib_params.smac, 0) < 0)\n", "        return DROP_WRITE_ERROR;\n", "    return CTX_ACT_OK;\n", "\n", "#endif\n", "}\n"], "called_function_list": ["ct_lookup4", "eth_store_daddr", "ep_tail_call", "maybe_add_l2_hdr", "lb4_rev_nat", "bpf_skip_recirculation", "__encap_with_nodeid", "bpf_skip_nodeport_set", "eth_store_saddr_aligned", "get_ct_map4", "ipv4_hdrlen", "eth_store_daddr_aligned", "eth_store_saddr", "bpf_mark_snat_done", "ctx_get_ifindex", "lookup_ip4_egress_gw_policy", "ipv4_has_l4_header", "csum_l4_offset_and_flags", "ipcache_lookup4"], "call_depth": 3, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "tail_rev_nodeport_lb4": [{"capabilities": [], "helperCallParams": {}, "startLine": 2129, "endLine": 2162, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "funcName": "tail_rev_nodeport_lb4", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx"], "output": "int", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["int tail_rev_nodeport_lb4 (struct  __ctx_buff *ctx)\n", "{\n", "    int ifindex = 0;\n", "    int ext_err = 0;\n", "    int ret = 0;\n", "\n", "#if defined(ENABLE_HOST_FIREWALL) && defined(IS_BPF_HOST)\n", "    struct trace_ctx __maybe_unused trace = {\n", "        .reason = TRACE_REASON_UNKNOWN,\n", "        .monitor = 0,}\n", "    ;\n", "    __u32 src_id = 0;\n", "    ret = ipv4_host_policy_ingress (ctx, & src_id, & trace);\n", "    if (IS_ERR (ret))\n", "        return send_drop_notify_error (ctx, src_id, ret, CTX_ACT_DROP, METRIC_INGRESS);\n", "    ctx_skip_host_fw_set (ctx);\n", "\n", "#endif\n", "    ret = rev_nodeport_lb4 (ctx, & ifindex, & ext_err);\n", "    if (IS_ERR (ret))\n", "        return send_drop_notify_error_ext (ctx, 0, ret, ext_err, CTX_ACT_DROP, METRIC_EGRESS);\n", "    edt_set_aggregate (ctx, 0);\n", "    cilium_capture_out (ctx);\n", "    return ctx_redirect (ctx, ifindex, 0);\n", "}\n"], "called_function_list": ["ctx_skip_host_fw_set", "edt_set_aggregate", "cilium_capture_out", "ctx_redirect", "ipv4_host_policy_ingress", "rev_nodeport_lb4"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "tail_handle_nat_fwd_ipv4": [{"capabilities": [], "helperCallParams": {}, "startLine": 2170, "endLine": 2188, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "funcName": "tail_handle_nat_fwd_ipv4", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx"], "output": "int", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["int tail_handle_nat_fwd_ipv4 (struct  __ctx_buff *ctx)\n", "{\n", "    int ret;\n", "    enum trace_point obs_point;\n", "\n", "#if defined(TUNNEL_MODE) && defined(IS_BPF_OVERLAY)\n", "    obs_point = TRACE_TO_OVERLAY;\n", "\n", "#else\n", "    obs_point = TRACE_TO_NETWORK;\n", "\n", "#endif\n", "    ret = nodeport_nat_ipv4_fwd (ctx);\n", "    if (IS_ERR (ret))\n", "        return send_drop_notify_error (ctx, 0, ret, CTX_ACT_DROP, METRIC_EGRESS);\n", "    send_trace_notify (ctx, obs_point, 0, 0, 0, 0, TRACE_REASON_UNKNOWN, 0);\n", "    return ret;\n", "}\n"], "called_function_list": ["send_trace_notify", "nodeport_nat_ipv4_fwd"], "call_depth": 10, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "health_encap_v4": [{"capabilities": [], "helperCallParams": {}, "startLine": 2192, "endLine": 2211, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "funcName": "health_encap_v4", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " __u32 tunnel_ep", " __u32 seclabel"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int health_encap_v4 (struct  __ctx_buff *ctx, __u32 tunnel_ep, __u32 seclabel)\n", "{\n", "    struct bpf_tunnel_key key;\n", "    memset (&key, 0, sizeof (key));\n", "    key.tunnel_id = seclabel == HOST_ID ? LOCAL_NODE_ID : seclabel;\n", "    key.remote_ipv4 = bpf_htonl (tunnel_ep);\n", "    key.tunnel_ttl = 64;\n", "    if (unlikely (ctx_set_tunnel_key (ctx, &key, sizeof (key), BPF_F_ZERO_CSUM_TX) < 0))\n", "        return DROP_WRITE_ERROR;\n", "    return 0;\n", "}\n"], "called_function_list": ["memset"], "call_depth": 3, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "health_encap_v6": [{"capabilities": [], "helperCallParams": {}, "startLine": 2213, "endLine": 2232, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "funcName": "health_encap_v6", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " const union v6addr *tunnel_ep", " __u32 seclabel"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int health_encap_v6 (struct  __ctx_buff *ctx, const union v6addr *tunnel_ep, __u32 seclabel)\n", "{\n", "    struct bpf_tunnel_key key;\n", "    memset (&key, 0, sizeof (key));\n", "    key.tunnel_id = seclabel == HOST_ID ? LOCAL_NODE_ID : seclabel;\n", "    key.remote_ipv6[0] = tunnel_ep->p1;\n", "    key.remote_ipv6[1] = tunnel_ep->p2;\n", "    key.remote_ipv6[2] = tunnel_ep->p3;\n", "    key.remote_ipv6[3] = tunnel_ep->p4;\n", "    key.tunnel_ttl = 64;\n", "    if (unlikely (ctx_set_tunnel_key (ctx, &key, sizeof (key), BPF_F_ZERO_CSUM_TX | BPF_F_TUNINFO_IPV6) < 0))\n", "        return DROP_WRITE_ERROR;\n", "    return 0;\n", "}\n"], "called_function_list": ["memset"], "call_depth": 3, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "lb_handle_health": [{"capabilities": [{"capability": "read_sys_info", "read_sys_info": [{"Project": "cilium", "Return Type": "u64", "Description": "Equivalent to get_socket_cookie() helper that accepts skb , but gets socket from struct sock_ops context. ", "Return": " A 8-byte long non-decreasing number.", "Function Name": "get_socket_cookie", "Input Params": ["{Type: struct sock_ops ,Var: *ctx}"], "compatible_hookpoints": ["socket_filter", "sched_cls", "sched_act", "cgroup_skb", "sock_ops", "sk_skb", "cgroup_sock_addr"], "capabilities": ["read_sys_info"]}]}, {"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}, {"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 2234, "endLine": 2280, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "funcName": "lb_handle_health", "developer_inline_comments": [], "updateMaps": [], "readMaps": ["  LB4_HEALTH_MAP", "  LB6_HEALTH_MAP"], "input": ["struct  __ctx_buff * ctx __maybe_unused"], "output": "static__always_inlineint", "helper": ["get_socket_cookie", "map_lookup_elem", "CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "sched_act"], "source": ["static __always_inline int lb_handle_health (struct  __ctx_buff * ctx __maybe_unused)\n", "{\n", "    void * data __maybe_unused, * data_end __maybe_unused;\n", "    __sock_cookie key __maybe_unused;\n", "    int ret __maybe_unused;\n", "    __u16 proto = 0;\n", "    if ((ctx->mark & MARK_MAGIC_HEALTH_IPIP_DONE) == MARK_MAGIC_HEALTH_IPIP_DONE)\n", "        return CTX_ACT_OK;\n", "    validate_ethertype (ctx, &proto);\n", "    switch (proto) {\n", "\n", "#if defined(ENABLE_IPV4) && DSR_ENCAP_MODE == DSR_ENCAP_IPIP\n", "    case bpf_htons (ETH_P_IP) :\n", "        {\n", "            struct lb4_health *val;\n", "            key = get_socket_cookie (ctx);\n", "            val = map_lookup_elem (& LB4_HEALTH_MAP, & key);\n", "            if (!val)\n", "                return CTX_ACT_OK;\n", "            ret = health_encap_v4 (ctx, val -> peer.address, 0);\n", "            if (ret != 0)\n", "                return ret;\n", "            ctx->mark |= MARK_MAGIC_HEALTH_IPIP_DONE;\n", "            return ctx_redirect (ctx, ENCAP4_IFINDEX, 0);\n", "        }\n", "\n", "#endif\n", "\n", "#if defined(ENABLE_IPV6) && DSR_ENCAP_MODE == DSR_ENCAP_IPIP\n", "    case bpf_htons (ETH_P_IPV6) :\n", "        {\n", "            struct lb6_health *val;\n", "            key = get_socket_cookie (ctx);\n", "            val = map_lookup_elem (& LB6_HEALTH_MAP, & key);\n", "            if (!val)\n", "                return CTX_ACT_OK;\n", "            ret = health_encap_v6 (ctx, & val -> peer.address, 0);\n", "            if (ret != 0)\n", "                return ret;\n", "            ctx->mark |= MARK_MAGIC_HEALTH_IPIP_DONE;\n", "            return ctx_redirect (ctx, ENCAP6_IFINDEX, 0);\n", "        }\n", "\n", "#endif\n", "    default :\n", "        return CTX_ACT_OK;\n", "    }\n", "}\n"], "called_function_list": ["health_encap_v6", "health_encap_v4", "validate_ethertype", "ctx_redirect"], "call_depth": 4, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "handle_nat_fwd": [{"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 2283, "endLine": 2319, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "funcName": "handle_nat_fwd", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx"], "output": "static__always_inlineint", "helper": ["CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["static __always_inline int handle_nat_fwd (struct  __ctx_buff *ctx)\n", "{\n", "    int ret = CTX_ACT_OK;\n", "    __u16 proto;\n", "    if (!validate_ethertype (ctx, &proto))\n", "        return CTX_ACT_OK;\n", "    switch (proto) {\n", "\n", "#ifdef ENABLE_IPV4\n", "    case bpf_htons (ETH_P_IP) :\n", "        invoke_tailcall_if (__or3 (__and (is_defined (ENABLE_IPV4), is_defined (ENABLE_IPV6)), __and (is_defined (ENABLE_HOST_FIREWALL), is_defined (IS_BPF_HOST)), is_defined (ENABLE_EGRESS_GATEWAY)), CILIUM_CALL_IPV4_ENCAP_NODEPORT_NAT, tail_handle_nat_fwd_ipv4);\n", "        break;\n", "\n", "#endif /* ENABLE_IPV4 */\n", "\n", "#ifdef ENABLE_IPV6\n", "    case bpf_htons (ETH_P_IPV6) :\n", "        invoke_tailcall_if (__or (__and (is_defined (ENABLE_IPV4), is_defined (ENABLE_IPV6)), __and (is_defined (ENABLE_HOST_FIREWALL), is_defined (IS_BPF_HOST))), CILIUM_CALL_IPV6_ENCAP_NODEPORT_NAT, tail_handle_nat_fwd_ipv6);\n", "        break;\n", "\n", "#endif /* ENABLE_IPV6 */\n", "    default :\n", "        build_bug_on (!(NODEPORT_PORT_MIN_NAT < NODEPORT_PORT_MAX_NAT));\n", "        build_bug_on (!(NODEPORT_PORT_MIN < NODEPORT_PORT_MAX));\n", "        build_bug_on (!(NODEPORT_PORT_MAX < NODEPORT_PORT_MIN_NAT));\n", "        break;\n", "    }\n", "    return ret;\n", "}\n"], "called_function_list": ["validate_ethertype"], "call_depth": 3, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "identity_in_range": [{"capabilities": [], "helperCallParams": {}, "startLine": 9, "endLine": 12, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/identity.h", "funcName": "identity_in_range", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["__u32 identity", " __u32 range_start", " __u32 range_end"], "output": "static__always_inlinebool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline bool identity_in_range (__u32 identity, __u32 range_start, __u32 range_end)\n", "{\n", "    return range_start <= identity && identity <= range_end;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "identity_is_remote_node": [{"capabilities": [], "helperCallParams": {}, "startLine": 14, "endLine": 32, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/identity.h", "funcName": "identity_is_remote_node", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["__u32 identity"], "output": "static__always_inlinebool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline bool identity_is_remote_node (__u32 identity)\n", "{\n", "    return identity == REMOTE_NODE_ID || identity == KUBE_APISERVER_NODE_ID;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "identity_is_node": [{"capabilities": [], "helperCallParams": {}, "startLine": 34, "endLine": 37, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/identity.h", "funcName": "identity_is_node", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["__u32 identity"], "output": "static__always_inlinebool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline bool identity_is_node (__u32 identity)\n", "{\n", "    return identity == HOST_ID || identity_is_remote_node (identity);\n", "}\n"], "called_function_list": ["identity_is_remote_node"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "identity_is_reserved": [{"capabilities": [], "helperCallParams": {}, "startLine": 57, "endLine": 60, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/identity.h", "funcName": "identity_is_reserved", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["__u32 identity"], "output": "static__always_inlinebool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline bool identity_is_reserved (__u32 identity)\n", "{\n", "    return identity < UNMANAGED_ID || identity_is_remote_node (identity);\n", "}\n"], "called_function_list": ["identity_is_remote_node"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "identity_is_cluster": [{"capabilities": [], "helperCallParams": {}, "startLine": 80, "endLine": 90, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/identity.h", "funcName": "identity_is_cluster", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["__u32 identity"], "output": "static__always_inlinebool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline bool identity_is_cluster (__u32 identity)\n", "{\n", "    if (identity == WORLD_ID)\n", "        return false;\n", "    if (identity_in_range (identity, CIDR_IDENTITY_RANGE_START, CIDR_IDENTITY_RANGE_END))\n", "        return false;\n", "    return true;\n", "}\n"], "called_function_list": ["identity_in_range"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "inherit_identity_from_host": [{"capabilities": [], "helperCallParams": {}, "startLine": 93, "endLine": 137, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/identity.h", "funcName": "inherit_identity_from_host", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " __u32 *identity"], "output": "static__always_inline__u32", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __u32 inherit_identity_from_host (struct  __ctx_buff *ctx, __u32 *identity)\n", "{\n", "    __u32 magic = ctx->mark & MARK_MAGIC_HOST_MASK;\n", "    if (magic == MARK_MAGIC_PROXY_INGRESS) {\n", "        *identity = get_identity (ctx);\n", "        ctx->tc_index |= TC_INDEX_F_SKIP_INGRESS_PROXY;\n", "    }\n", "    else if (magic == MARK_MAGIC_PROXY_EGRESS) {\n", "        *identity = get_identity (ctx);\n", "        ctx->tc_index |= TC_INDEX_F_SKIP_EGRESS_PROXY;\n", "    }\n", "    else if (magic == MARK_MAGIC_IDENTITY) {\n", "        *identity = get_identity (ctx);\n", "    }\n", "    else if (magic == MARK_MAGIC_HOST) {\n", "        *identity = HOST_ID;\n", "    }\n", "    else if (magic == MARK_MAGIC_ENCRYPT) {\n", "        *identity = get_identity (ctx);\n", "\n", "#if defined(ENABLE_L7_LB)\n", "    }\n", "    else if (magic == MARK_MAGIC_PROXY_EGRESS_EPID) {\n", "        *identity = get_epid (ctx);\n", "\n", "#endif\n", "    }\n", "    else {\n", "        *identity = WORLD_ID;\n", "    }\n", "    ctx->mark = 0;\n", "\n", "#if defined(ENABLE_L7_LB)\n", "    if (magic != MARK_MAGIC_PROXY_EGRESS_EPID)\n", "\n", "#endif\n", "        cilium_dbg (ctx, DBG_INHERIT_IDENTITY, *identity, 0);\n", "    return magic;\n", "}\n"], "called_function_list": ["get_identity", "cilium_dbg", "get_epid"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ipv4_load_daddr": [{"capabilities": [], "helperCallParams": {}, "startLine": 35, "endLine": 39, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv4.h", "funcName": "ipv4_load_daddr", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " int off", " __u32 *dst"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int ipv4_load_daddr (struct  __ctx_buff *ctx, int off, __u32 *dst)\n", "{\n", "    return ctx_load_bytes (ctx, off + offsetof (struct iphdr, daddr), dst, 4);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ipv4_dec_ttl": [{"capabilities": [], "helperCallParams": {}, "startLine": 41, "endLine": 55, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv4.h", "funcName": "ipv4_dec_ttl", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " int off", " const struct iphdr *ip4"], "output": "static__always_inlineint", "helper": ["l3_csum_replace"], "compatibleHookpoints": ["lwt_xmit", "sched_cls", "sched_act"], "source": ["static __always_inline int ipv4_dec_ttl (struct  __ctx_buff *ctx, int off, const struct iphdr *ip4)\n", "{\n", "    __u8 new_ttl, ttl = ip4->ttl;\n", "    if (ttl <= 1)\n", "        return 1;\n", "    new_ttl = ttl - 1;\n", "    l3_csum_replace (ctx, off + offsetof (struct iphdr, check), ttl, new_ttl, 2);\n", "    ctx_store_bytes (ctx, off + offsetof (struct iphdr, ttl), &new_ttl, sizeof (new_ttl), 0);\n", "    return 0;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ipv4_hdrlen": [{"capabilities": [], "helperCallParams": {}, "startLine": 57, "endLine": 60, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv4.h", "funcName": "ipv4_hdrlen", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct iphdr *ip4"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int ipv4_hdrlen (const struct iphdr *ip4)\n", "{\n", "    return ip4->ihl * 4;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ipv4_is_fragment": [{"capabilities": [], "helperCallParams": {}, "startLine": 62, "endLine": 74, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv4.h", "funcName": "ipv4_is_fragment", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct iphdr *ip4"], "output": "static__always_inlinebool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline bool ipv4_is_fragment (const struct iphdr *ip4)\n", "{\n", "    return ip4->frag_off & bpf_htons (0x3FFF);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ipv4_is_not_first_fragment": [{"capabilities": [], "helperCallParams": {}, "startLine": 76, "endLine": 80, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv4.h", "funcName": "ipv4_is_not_first_fragment", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct iphdr *ip4"], "output": "static__always_inlinebool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline bool ipv4_is_not_first_fragment (const struct iphdr *ip4)\n", "{\n", "    return ip4->frag_off & bpf_htons (0x1FFF);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ipv4_has_l4_header": [{"capabilities": [], "helperCallParams": {}, "startLine": 83, "endLine": 86, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv4.h", "funcName": "ipv4_has_l4_header", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct iphdr *ip4"], "output": "static__always_inlinebool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline bool ipv4_has_l4_header (const struct iphdr *ip4)\n", "{\n", "    return !ipv4_is_not_first_fragment (ip4);\n", "}\n"], "called_function_list": ["ipv4_is_not_first_fragment"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ipv4_is_in_subnet": [{"capabilities": [], "helperCallParams": {}, "startLine": 88, "endLine": 92, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv4.h", "funcName": "ipv4_is_in_subnet", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["__be32 addr", " __be32 subnet", " int prefixlen"], "output": "static__always_inlinebool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline bool ipv4_is_in_subnet (__be32 addr, __be32 subnet, int prefixlen)\n", "{\n", "    return (addr & bpf_htonl (~((1 << (32 - prefixlen)) - 1))) == subnet;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ipv4_frag_get_l4ports": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 95, "endLine": 108, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv4.h", "funcName": "ipv4_frag_get_l4ports", "developer_inline_comments": [], "updateMaps": [], "readMaps": ["  IPV4_FRAG_DATAGRAMS_MAP"], "input": ["const struct ipv4_frag_id *frag_id", " struct ipv4_frag_l4ports *ports"], "output": "static__always_inlineint", "helper": ["map_lookup_elem"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int ipv4_frag_get_l4ports (const struct ipv4_frag_id *frag_id, struct ipv4_frag_l4ports *ports)\n", "{\n", "    struct ipv4_frag_l4ports *tmp;\n", "    tmp = map_lookup_elem (& IPV4_FRAG_DATAGRAMS_MAP, frag_id);\n", "    if (!tmp)\n", "        return DROP_FRAG_NOT_FOUND;\n", "    memcpy (ports, tmp, sizeof (*ports));\n", "    return 0;\n", "}\n"], "called_function_list": ["memcpy"], "call_depth": 3, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ipv4_handle_fragmentation": [{"capabilities": [], "helperCallParams": {}, "startLine": 110, "endLine": 161, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv4.h", "funcName": "ipv4_handle_fragmentation", "developer_inline_comments": [], "updateMaps": [" IPV4_FRAG_DATAGRAMS_MAP"], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " const struct iphdr *ip4", " int l4_off", " enum ct_dir ct_dir", " struct ipv4_frag_l4ports *ports", " bool *has_l4_header"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int ipv4_handle_fragmentation (struct  __ctx_buff *ctx, const struct iphdr *ip4, int l4_off, enum ct_dir ct_dir, struct ipv4_frag_l4ports *ports, bool *has_l4_header)\n", "{\n", "    bool is_fragment, not_first_fragment;\n", "    enum metric_dir dir;\n", "    int ret;\n", "    struct ipv4_frag_id frag_id = {\n", "        .daddr = ip4->daddr,\n", "        .saddr = ip4->saddr,\n", "        .id = ip4->id,\n", "        .proto = ip4->protocol,\n", "        .pad = 0,}\n", "    ;\n", "    is_fragment = ipv4_is_fragment (ip4);\n", "    dir = ct_to_metrics_dir (ct_dir);\n", "    if (unlikely (is_fragment)) {\n", "        update_metrics (ctx_full_len (ctx), dir, REASON_FRAG_PACKET);\n", "        not_first_fragment = ipv4_is_not_first_fragment (ip4);\n", "        if (has_l4_header)\n", "            *has_l4_header = !not_first_fragment;\n", "        if (likely (not_first_fragment))\n", "            return ipv4_frag_get_l4ports (&frag_id, ports);\n", "    }\n", "    ret = ctx_load_bytes (ctx, l4_off, ports, 4);\n", "    if (ret < 0)\n", "        return ret;\n", "    if (unlikely (is_fragment)) {\n", "        if (map_update_elem (&IPV4_FRAG_DATAGRAMS_MAP, &frag_id, ports, BPF_ANY))\n", "            update_metrics (ctx_full_len (ctx), dir, REASON_FRAG_PACKET_UPDATE);\n", "    }\n", "    return 0;\n", "}\n"], "called_function_list": ["ipv4_is_fragment", "update_metrics", "ipv4_is_not_first_fragment", "ctx_full_len", "ipv4_frag_get_l4ports", "ct_to_metrics_dir"], "call_depth": 4, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ipv6_optlen": [{"capabilities": [], "helperCallParams": {}, "startLine": 38, "endLine": 41, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv6.h", "funcName": "ipv6_optlen", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct ipv6_opt_hdr *opthdr"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int ipv6_optlen (const struct ipv6_opt_hdr *opthdr)\n", "{\n", "    return (opthdr->hdrlen + 1) << 3;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ipv6_authlen": [{"capabilities": [], "helperCallParams": {}, "startLine": 43, "endLine": 46, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv6.h", "funcName": "ipv6_authlen", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct ipv6_opt_hdr *opthdr"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int ipv6_authlen (const struct ipv6_opt_hdr *opthdr)\n", "{\n", "    return (opthdr->hdrlen + 2) << 2;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ipv6_hdrlen": [{"capabilities": [], "helperCallParams": {}, "startLine": 48, "endLine": 85, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv6.h", "funcName": "ipv6_hdrlen", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " __u8 *nexthdr"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int ipv6_hdrlen (struct  __ctx_buff *ctx, __u8 *nexthdr)\n", "{\n", "    int i, len = sizeof (struct ipv6hdr);\n", "    struct ipv6_opt_hdr opthdr __align_stack_8;\n", "    __u8 nh = *nexthdr;\n", "\n", "#pragma unroll\n", "    for (i = 0; i < IPV6_MAX_HEADERS; i++) {\n", "        switch (nh) {\n", "        case NEXTHDR_NONE :\n", "            return DROP_INVALID_EXTHDR;\n", "        case NEXTHDR_FRAGMENT :\n", "            return DROP_FRAG_NOSUPPORT;\n", "        case NEXTHDR_HOP :\n", "        case NEXTHDR_ROUTING :\n", "        case NEXTHDR_AUTH :\n", "        case NEXTHDR_DEST :\n", "            if (ctx_load_bytes (ctx, ETH_HLEN + len, &opthdr, sizeof (opthdr)) < 0)\n", "                return DROP_INVALID;\n", "            nh = opthdr.nexthdr;\n", "            if (nh == NEXTHDR_AUTH)\n", "                len += ipv6_authlen (&opthdr);\n", "            else\n", "                len += ipv6_optlen (&opthdr);\n", "            break;\n", "        default :\n", "            *nexthdr = nh;\n", "            return len;\n", "        }\n", "    }\n", "    return DROP_INVALID_EXTHDR;\n", "}\n"], "called_function_list": ["ipv6_optlen", "ipv6_authlen"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ipv6_addr_copy": [{"capabilities": [], "helperCallParams": {}, "startLine": 87, "endLine": 92, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv6.h", "funcName": "ipv6_addr_copy", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["union v6addr *dst", " const union v6addr *src"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void ipv6_addr_copy (union v6addr *dst, const union v6addr *src)\n", "{\n", "    dst->d1 = src->d1;\n", "    dst->d2 = src->d2;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ipv6_addrcmp": [{"capabilities": [], "helperCallParams": {}, "startLine": 94, "endLine": 103, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv6.h", "funcName": "ipv6_addrcmp", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const union v6addr *a", " const union v6addr *b"], "output": "static__always_inline__u64", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __u64 ipv6_addrcmp (const union v6addr *a, const union v6addr *b)\n", "{\n", "    __u64 tmp;\n", "    tmp = a->d1 - b->d1;\n", "    if (!tmp)\n", "        tmp = a->d2 - b->d2;\n", "    return tmp;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ipv6_addr_in_net": [{"capabilities": [], "helperCallParams": {}, "startLine": 106, "endLine": 116, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv6.h", "funcName": "ipv6_addr_in_net", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const union v6addr *addr", " const union v6addr *net", " const union v6addr *mask"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int ipv6_addr_in_net (const union v6addr *addr, const union v6addr *net, const union v6addr *mask)\n", "{\n", "    return ((addr->p1 & mask->p1) == net->p1) && (!mask->p2 || (((addr->p2 & mask->p2) == net->p2) && (!mask->p3 || (((addr->p3 & mask->p3) == net->p3) && (!mask->p4 || ((addr->p4 & mask->p4) == net->p4))))));\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ipv6_addr_clear_suffix": [{"capabilities": [], "helperCallParams": {}, "startLine": 122, "endLine": 132, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv6.h", "funcName": "ipv6_addr_clear_suffix", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["union v6addr *addr", " int prefix"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void ipv6_addr_clear_suffix (union v6addr *addr, int prefix)\n", "{\n", "    addr->p1 &= GET_PREFIX (prefix);\n", "    prefix -= 32;\n", "    addr->p2 &= GET_PREFIX (prefix);\n", "    prefix -= 32;\n", "    addr->p3 &= GET_PREFIX (prefix);\n", "    prefix -= 32;\n", "    addr->p4 &= GET_PREFIX (prefix);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ipv6_match_prefix_64": [{"capabilities": [], "helperCallParams": {}, "startLine": 134, "endLine": 144, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv6.h", "funcName": "ipv6_match_prefix_64", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const union v6addr *addr", " const union v6addr *prefix"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int ipv6_match_prefix_64 (const union v6addr *addr, const union v6addr *prefix)\n", "{\n", "    int tmp;\n", "    tmp = addr->p1 - prefix->p1;\n", "    if (!tmp)\n", "        tmp = addr->p2 - prefix->p2;\n", "    return !tmp;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ipv6_dec_hoplimit": [{"capabilities": [], "helperCallParams": {}, "startLine": 146, "endLine": 161, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv6.h", "funcName": "ipv6_dec_hoplimit", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " int off"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int ipv6_dec_hoplimit (struct  __ctx_buff *ctx, int off)\n", "{\n", "    __u8 hl;\n", "    if (ctx_load_bytes (ctx, off + offsetof (struct ipv6hdr, hop_limit), &hl, sizeof (hl)) < 0)\n", "        return DROP_INVALID;\n", "    if (hl <= 1)\n", "        return 1;\n", "    hl--;\n", "    if (ctx_store_bytes (ctx, off + offsetof (struct ipv6hdr, hop_limit), &hl, sizeof (hl), BPF_F_RECOMPUTE_CSUM) < 0)\n", "        return DROP_WRITE_ERROR;\n", "    return 0;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ipv6_load_saddr": [{"capabilities": [], "helperCallParams": {}, "startLine": 163, "endLine": 168, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv6.h", "funcName": "ipv6_load_saddr", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " int off", " union v6addr *dst"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int ipv6_load_saddr (struct  __ctx_buff *ctx, int off, union v6addr *dst)\n", "{\n", "    return ctx_load_bytes (ctx, off + offsetof (struct ipv6hdr, saddr), dst->addr, sizeof (((struct ipv6hdr *) NULL)->saddr));\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ipv6_store_saddr": [{"capabilities": [], "helperCallParams": {}, "startLine": 171, "endLine": 175, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv6.h", "funcName": "ipv6_store_saddr", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " __u8 *addr", " int off"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int ipv6_store_saddr (struct  __ctx_buff *ctx, __u8 *addr, int off)\n", "{\n", "    return ctx_store_bytes (ctx, off + offsetof (struct ipv6hdr, saddr), addr, 16, 0);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ipv6_load_daddr": [{"capabilities": [], "helperCallParams": {}, "startLine": 177, "endLine": 182, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv6.h", "funcName": "ipv6_load_daddr", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " int off", " union v6addr *dst"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int ipv6_load_daddr (struct  __ctx_buff *ctx, int off, union v6addr *dst)\n", "{\n", "    return ctx_load_bytes (ctx, off + offsetof (struct ipv6hdr, daddr), dst->addr, sizeof (((struct ipv6hdr *) NULL)->daddr));\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ipv6_store_daddr": [{"capabilities": [], "helperCallParams": {}, "startLine": 185, "endLine": 189, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv6.h", "funcName": "ipv6_store_daddr", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " const __u8 *addr", " int off"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int ipv6_store_daddr (struct  __ctx_buff *ctx, const __u8 *addr, int off)\n", "{\n", "    return ctx_store_bytes (ctx, off + offsetof (struct ipv6hdr, daddr), addr, 16, 0);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ipv6_load_nexthdr": [{"capabilities": [], "helperCallParams": {}, "startLine": 191, "endLine": 196, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv6.h", "funcName": "ipv6_load_nexthdr", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " int off", " __u8 *nexthdr"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int ipv6_load_nexthdr (struct  __ctx_buff *ctx, int off, __u8 *nexthdr)\n", "{\n", "    return ctx_load_bytes (ctx, off + offsetof (struct ipv6hdr, nexthdr), nexthdr, sizeof (__u8));\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ipv6_store_nexthdr": [{"capabilities": [], "helperCallParams": {}, "startLine": 199, "endLine": 204, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv6.h", "funcName": "ipv6_store_nexthdr", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " __u8 *nexthdr", " int off"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int ipv6_store_nexthdr (struct  __ctx_buff *ctx, __u8 *nexthdr, int off)\n", "{\n", "    return ctx_store_bytes (ctx, off + offsetof (struct ipv6hdr, nexthdr), nexthdr, sizeof (__u8), 0);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ipv6_load_paylen": [{"capabilities": [], "helperCallParams": {}, "startLine": 206, "endLine": 211, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv6.h", "funcName": "ipv6_load_paylen", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " int off", " __be16 *len"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int ipv6_load_paylen (struct  __ctx_buff *ctx, int off, __be16 *len)\n", "{\n", "    return ctx_load_bytes (ctx, off + offsetof (struct ipv6hdr, payload_len), len, sizeof (*len));\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ipv6_store_paylen": [{"capabilities": [], "helperCallParams": {}, "startLine": 214, "endLine": 219, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv6.h", "funcName": "ipv6_store_paylen", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " int off", " __be16 *len"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int ipv6_store_paylen (struct  __ctx_buff *ctx, int off, __be16 *len)\n", "{\n", "    return ctx_store_bytes (ctx, off + offsetof (struct ipv6hdr, payload_len), len, sizeof (*len), 0);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ipv6_store_flowlabel": [{"capabilities": [], "helperCallParams": {}, "startLine": 221, "endLine": 237, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv6.h", "funcName": "ipv6_store_flowlabel", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " int off", " __be32 label"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int ipv6_store_flowlabel (struct  __ctx_buff *ctx, int off, __be32 label)\n", "{\n", "    __be32 old;\n", "    if (ctx_load_bytes (ctx, off, &old, 4) < 0)\n", "        return DROP_INVALID;\n", "    old &= IPV6_TCLASS_MASK;\n", "    old = bpf_htonl (0x60000000) | label | old;\n", "    if (ctx_store_bytes (ctx, off, &old, 4, BPF_F_RECOMPUTE_CSUM) < 0)\n", "        return DROP_WRITE_ERROR;\n", "    return 0;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ipv6_pseudohdr_checksum": [{"capabilities": [{"capability": "read_skb", "read_skb": [{"Project": "cilium", "Return Type": "s64", "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ", "Return": " The checksum result, or a negative error code in case of failure.", "Function Name": "csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp", "lwt_in", "lwt_out", "lwt_xmit", "lwt_seg6local"], "capabilities": ["read_skb"]}]}], "helperCallParams": {}, "startLine": 239, "endLine": 252, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv6.h", "funcName": "ipv6_pseudohdr_checksum", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct ipv6hdr *hdr", " __u8 next_hdr", " __u16 payload_len", " __be32 sum"], "output": "static__always_inline__be32", "helper": ["csum_diff"], "compatibleHookpoints": ["sched_cls", "lwt_xmit", "xdp", "lwt_in", "sched_act", "lwt_out", "lwt_seg6local"], "source": ["static __always_inline __be32 ipv6_pseudohdr_checksum (struct ipv6hdr *hdr, __u8 next_hdr, __u16 payload_len, __be32 sum)\n", "{\n", "    __be32 len = bpf_htonl ((__u32) payload_len);\n", "    __be32 nexthdr = bpf_htonl ((__u32) next_hdr);\n", "    sum = csum_diff (NULL, 0, & hdr -> saddr, sizeof (struct in6_addr), sum);\n", "    sum = csum_diff (NULL, 0, & hdr -> daddr, sizeof (struct in6_addr), sum);\n", "    sum = csum_diff (NULL, 0, & len, sizeof (len), sum);\n", "    sum = csum_diff (NULL, 0, & nexthdr, sizeof (nexthdr), sum);\n", "    return sum;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ipv6_addr_is_mapped": [{"capabilities": [], "helperCallParams": {}, "startLine": 257, "endLine": 260, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv6.h", "funcName": "ipv6_addr_is_mapped", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const union v6addr *addr"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int ipv6_addr_is_mapped (const union v6addr *addr)\n", "{\n", "    return addr->p1 == 0 && addr->p2 == 0 && addr->p3 == 0xFFFF0000;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "reset_queue_mapping": [{"capabilities": [], "helperCallParams": {}, "startLine": 9, "endLine": 22, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/qm.h", "funcName": "reset_queue_mapping", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff * ctx __maybe_unused"], "output": "staticinlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static inline void reset_queue_mapping (struct  __ctx_buff * ctx __maybe_unused)\n", "{\n", "\n", "#if defined(RESET_QUEUES) && __ctx_is == __ctx_skb\n", "    ctx->queue_mapping = 0;\n", "\n", "#endif\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ctx_redirect_to_proxy_hairpin": [{"capabilities": [], "helperCallParams": {}, "startLine": 22, "endLine": 63, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/proxy_hairpin.h", "funcName": "ctx_redirect_to_proxy_hairpin", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " __be16 proxy_port", " const bool is_ipv6"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int ctx_redirect_to_proxy_hairpin (struct  __ctx_buff *ctx, __be16 proxy_port, const bool is_ipv6)\n", "{\n", "\n", "#if defined(ENABLE_IPV4) || defined(ENABLE_IPV6)\n", "    union macaddr host_mac = HOST_IFINDEX_MAC;\n", "    union macaddr router_mac = NODE_MAC;\n", "\n", "#endif\n", "    void *data_end = (void *) (long) ctx->data_end;\n", "    void *data = (void *) (long) ctx->data;\n", "    struct iphdr *ip4;\n", "    int ret = 0;\n", "    ctx_store_meta (ctx, CB_PROXY_MAGIC, MARK_MAGIC_TO_PROXY | (proxy_port << 16));\n", "    bpf_barrier ();\n", "    if (!revalidate_data (ctx, &data, &data_end, &ip4))\n", "        return DROP_INVALID;\n", "    if (is_ipv6) {\n", "\n", "#ifdef ENABLE_IPV6\n", "        ret = ipv6_l3 (ctx, ETH_HLEN, (__u8 *) & router_mac, (__u8 *) & host_mac, METRIC_EGRESS);\n", "\n", "#endif\n", "    }\n", "    else {\n", "\n", "#ifdef ENABLE_IPV4\n", "        ret = ipv4_l3 (ctx, ETH_HLEN, (__u8 *) & router_mac, (__u8 *) & host_mac, ip4);\n", "\n", "#endif\n", "    }\n", "    if (IS_ERR (ret))\n", "        return ret;\n", "    cilium_dbg (ctx, DBG_CAPTURE_PROXY_PRE, proxy_port, 0);\n", "    return ctx_redirect (ctx, HOST_IFINDEX, 0);\n", "}\n"], "called_function_list": ["ipv4_l3", "ipv6_l3", "ctx_store_meta", "ctx_redirect", "bpf_barrier", "cilium_dbg"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ctx_redirect_to_proxy_hairpin_ipv4": [{"capabilities": [], "helperCallParams": {}, "startLine": 66, "endLine": 70, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/proxy_hairpin.h", "funcName": "ctx_redirect_to_proxy_hairpin_ipv4", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " __be16 proxy_port"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int ctx_redirect_to_proxy_hairpin_ipv4 (struct  __ctx_buff *ctx, __be16 proxy_port)\n", "{\n", "    return ctx_redirect_to_proxy_hairpin (ctx, proxy_port, false);\n", "}\n"], "called_function_list": ["ctx_redirect_to_proxy_hairpin"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ctx_redirect_to_proxy_hairpin_ipv6": [{"capabilities": [], "helperCallParams": {}, "startLine": 74, "endLine": 78, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/proxy_hairpin.h", "funcName": "ctx_redirect_to_proxy_hairpin_ipv6", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " __be16 proxy_port"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int ctx_redirect_to_proxy_hairpin_ipv6 (struct  __ctx_buff *ctx, __be16 proxy_port)\n", "{\n", "    return ctx_redirect_to_proxy_hairpin (ctx, proxy_port, true);\n", "}\n"], "called_function_list": ["ctx_redirect_to_proxy_hairpin"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "edt_set_aggregate": [{"capabilities": [], "helperCallParams": {}, "startLine": 17, "endLine": 22, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/edt.h", "funcName": "edt_set_aggregate", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " __u32 aggregate"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void edt_set_aggregate (struct  __ctx_buff *ctx, __u32 aggregate)\n", "{\n", "    ctx->queue_mapping = aggregate;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 79, "endLine": 83, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/edt.h", "funcName": "edt_set_aggregate", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff * ctx __maybe_unused", " __u32 aggregate __maybe_unused"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void edt_set_aggregate (struct  __ctx_buff * ctx __maybe_unused, __u32 aggregate __maybe_unused)\n", "{\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "edt_get_aggregate": [{"capabilities": [], "helperCallParams": {}, "startLine": 24, "endLine": 34, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/edt.h", "funcName": "edt_get_aggregate", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx"], "output": "static__always_inline__u32", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __u32 edt_get_aggregate (struct  __ctx_buff *ctx)\n", "{\n", "    __u32 aggregate = ctx->queue_mapping;\n", "    ctx->queue_mapping = 0;\n", "    return aggregate;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "edt_sched_departure": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}, {"capability": "read_sys_info", "read_sys_info": [{"Project": "cilium", "Return Type": "u64", "Description": "Return the time elapsed since system boot , in nanoseconds. ", "Return": " Current ktime.", "Function Name": "ktime_get_ns", "Input Params": ["{Type: voi ,Var: void}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "raw_tracepoint_writable"], "capabilities": ["read_sys_info"]}]}, {"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 36, "endLine": 77, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/edt.h", "funcName": "edt_sched_departure", "developer_inline_comments": [], "updateMaps": [], "readMaps": ["  THROTTLE_MAP"], "input": ["struct  __ctx_buff *ctx"], "output": "static__always_inlineint", "helper": ["map_lookup_elem", "ktime_get_ns", "CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["static __always_inline int edt_sched_departure (struct  __ctx_buff *ctx)\n", "{\n", "    __u64 delay, now, t, t_next;\n", "    struct edt_id aggregate;\n", "    struct edt_info *info;\n", "    __u16 proto;\n", "    if (!validate_ethertype (ctx, &proto))\n", "        return CTX_ACT_OK;\n", "    if (proto != bpf_htons (ETH_P_IP) && proto != bpf_htons (ETH_P_IPV6))\n", "        return CTX_ACT_OK;\n", "    aggregate.id = edt_get_aggregate (ctx);\n", "    if (!aggregate.id)\n", "        return CTX_ACT_OK;\n", "    info = map_lookup_elem (& THROTTLE_MAP, & aggregate);\n", "    if (!info)\n", "        return CTX_ACT_OK;\n", "    now = ktime_get_ns ();\n", "    t = ctx->tstamp;\n", "    if (t < now)\n", "        t = now;\n", "    delay = ((__u64) ctx_wire_len (ctx)) * NSEC_PER_SEC / info->bps;\n", "    t_next = READ_ONCE (info->t_last) + delay;\n", "    if (t_next <= t) {\n", "        WRITE_ONCE (info->t_last, t);\n", "        return CTX_ACT_OK;\n", "    }\n", "    if (t_next - now >= info->t_horizon_drop)\n", "        return CTX_ACT_DROP;\n", "    WRITE_ONCE (info->t_last, t_next);\n", "    ctx->tstamp = t_next;\n", "    return CTX_ACT_OK;\n", "}\n"], "called_function_list": ["ctx_wire_len", "validate_ethertype", "edt_get_aggregate"], "call_depth": 3, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "policy_sk_egress": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}, {"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 15, "endLine": 79, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/policy.h", "funcName": "policy_sk_egress", "developer_inline_comments": [], "updateMaps": [], "readMaps": [" map"], "input": ["__u32 identity", " __u32 ip", " __u16 dport"], "output": "static__always_inlineint", "helper": ["map_lookup_elem", "CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["static __always_inline int policy_sk_egress (__u32 identity, __u32 ip, __u16 dport)\n", "{\n", "    void *map = lookup_ip4_endpoint_policy_map (ip);\n", "    int dir = CT_EGRESS;\n", "    __u8 proto = IPPROTO_TCP;\n", "    struct policy_entry *policy;\n", "    struct policy_key key = {\n", "        .sec_label = identity,\n", "        .dport = dport,\n", "        .protocol = proto,\n", "        .egress = !dir,\n", "        .pad = 0,}\n", "    ;\n", "    if (!map)\n", "        return CTX_ACT_OK;\n", "    policy = map_lookup_elem (map, & key);\n", "    if (likely (policy)) {\n", "        __sync_fetch_and_add (&policy->packets, 1);\n", "        if (unlikely (policy->deny))\n", "            return DROP_POLICY_DENY;\n", "        return policy->proxy_port;\n", "    }\n", "    key.sec_label = 0;\n", "    policy = map_lookup_elem (map, & key);\n", "    if (likely (policy)) {\n", "        __sync_fetch_and_add (&policy->packets, 1);\n", "        if (unlikely (policy->deny))\n", "            return DROP_POLICY_DENY;\n", "        return policy->proxy_port;\n", "    }\n", "    key.sec_label = identity;\n", "    key.dport = 0;\n", "    key.protocol = 0;\n", "    policy = map_lookup_elem (map, & key);\n", "    if (likely (policy)) {\n", "        __sync_fetch_and_add (&policy->packets, 1);\n", "        if (unlikely (policy->deny))\n", "            return DROP_POLICY_DENY;\n", "        return CTX_ACT_OK;\n", "    }\n", "    key.sec_label = 0;\n", "    policy = map_lookup_elem (map, & key);\n", "    if (likely (policy)) {\n", "        __sync_fetch_and_add (&policy->packets, 1);\n", "        if (unlikely (policy->deny))\n", "            return DROP_POLICY_DENY;\n", "        return CTX_ACT_OK;\n", "    }\n", "    return DROP_POLICY;\n", "}\n"], "called_function_list": ["lookup_ip4_endpoint_policy_map"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "account": [{"capabilities": [], "helperCallParams": {}, "startLine": 81, "endLine": 87, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/policy.h", "funcName": "account", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " struct policy_entry *policy"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void account (struct  __ctx_buff *ctx, struct policy_entry *policy)\n", "{\n", "    __sync_fetch_and_add (&policy->packets, 1);\n", "    __sync_fetch_and_add (&policy->bytes, ctx_full_len (ctx));\n", "}\n"], "called_function_list": ["ctx_full_len"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__policy_can_access": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}, {"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 89, "endLine": 222, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/policy.h", "funcName": "__policy_can_access", "developer_inline_comments": [], "updateMaps": [], "readMaps": [" map"], "input": ["const void *map", " struct  __ctx_buff *ctx", " __u32 local_id", " __u32 remote_id", " __u16 dport", " __u8 proto", " int dir", " bool is_untracked_fragment", " __u8 *match_type"], "output": "static__always_inlineint", "helper": ["map_lookup_elem", "CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["static __always_inline int __policy_can_access (const void *map, struct  __ctx_buff *ctx, __u32 local_id, __u32 remote_id, __u16 dport, __u8 proto, int dir, bool is_untracked_fragment, __u8 *match_type)\n", "{\n", "    struct policy_entry *policy;\n", "    struct policy_key key = {\n", "        .sec_label = remote_id,\n", "        .dport = dport,\n", "        .protocol = proto,\n", "        .egress = !dir,\n", "        .pad = 0,}\n", "    ;\n", "\n", "#ifdef ALLOW_ICMP_FRAG_NEEDED\n", "    if (proto == IPPROTO_ICMP) {\n", "        void *data, *data_end;\n", "        struct icmphdr icmphdr __align_stack_8;\n", "        struct iphdr *ip4;\n", "        __u32 off;\n", "        if (!revalidate_data (ctx, &data, &data_end, &ip4))\n", "            return DROP_INVALID;\n", "        off = ((void *) ip4 - data) + ipv4_hdrlen (ip4);\n", "        if (ctx_load_bytes (ctx, off, &icmphdr, sizeof (icmphdr)) < 0)\n", "            return DROP_INVALID;\n", "        if (icmphdr.type == ICMP_DEST_UNREACH && icmphdr.code == ICMP_FRAG_NEEDED)\n", "            return CTX_ACT_OK;\n", "    }\n", "\n", "#endif /* ALLOW_ICMP_FRAG_NEEDED */\n", "\n", "#ifdef ENABLE_ICMP_RULE\n", "    if (proto == IPPROTO_ICMP) {\n", "        void *data, *data_end;\n", "        struct iphdr *ip4;\n", "        struct icmphdr icmphdr __align_stack_8;\n", "        __u32 off;\n", "        if (!revalidate_data (ctx, &data, &data_end, &ip4))\n", "            return DROP_INVALID;\n", "        off = ((void *) ip4 - data) + ipv4_hdrlen (ip4);\n", "        if (ctx_load_bytes (ctx, off, &icmphdr, sizeof (icmphdr)) < 0)\n", "            return DROP_INVALID;\n", "        key.dport = (__u16) (icmphdr.type << 8);\n", "    }\n", "    else if (proto == IPPROTO_ICMPV6) {\n", "        void *data, *data_end;\n", "        struct ipv6hdr *ip6;\n", "        __u32 off;\n", "        __u8 icmp_type;\n", "        if (!revalidate_data (ctx, &data, &data_end, &ip6))\n", "            return DROP_INVALID;\n", "        off = ((void *) ip6 - data) + ipv6_hdrlen (ctx, &ip6->nexthdr);\n", "        if (ctx_load_bytes (ctx, off, &icmp_type, sizeof (icmp_type)) < 0)\n", "            return DROP_INVALID;\n", "        key.dport = (__u16) (icmp_type << 8);\n", "    }\n", "\n", "#endif /* ENABLE_ICMP_RULE */\n", "    if (!is_untracked_fragment) {\n", "        policy = map_lookup_elem (map, & key);\n", "        if (likely (policy)) {\n", "            cilium_dbg3 (ctx, DBG_L4_CREATE, remote_id, local_id, dport << 16 | proto);\n", "            account (ctx, policy);\n", "            *match_type = POLICY_MATCH_L3_L4;\n", "            if (unlikely (policy->deny))\n", "                return DROP_POLICY_DENY;\n", "            return policy->proxy_port;\n", "        }\n", "        key.sec_label = 0;\n", "        policy = map_lookup_elem (map, & key);\n", "        if (likely (policy)) {\n", "            account (ctx, policy);\n", "            *match_type = POLICY_MATCH_L4_ONLY;\n", "            if (unlikely (policy->deny))\n", "                return DROP_POLICY_DENY;\n", "            return policy->proxy_port;\n", "        }\n", "        key.sec_label = remote_id;\n", "    }\n", "    key.dport = 0;\n", "    key.protocol = 0;\n", "    policy = map_lookup_elem (map, & key);\n", "    if (likely (policy)) {\n", "        account (ctx, policy);\n", "        *match_type = POLICY_MATCH_L3_ONLY;\n", "        if (unlikely (policy->deny))\n", "            return DROP_POLICY_DENY;\n", "        return CTX_ACT_OK;\n", "    }\n", "    key.sec_label = 0;\n", "    policy = map_lookup_elem (map, & key);\n", "    if (policy) {\n", "        account (ctx, policy);\n", "        *match_type = POLICY_MATCH_ALL;\n", "        if (unlikely (policy->deny))\n", "            return DROP_POLICY_DENY;\n", "        return CTX_ACT_OK;\n", "    }\n", "    if (ctx_load_meta (ctx, CB_POLICY))\n", "        return CTX_ACT_OK;\n", "    if (is_untracked_fragment)\n", "        return DROP_FRAG_NOSUPPORT;\n", "    return DROP_POLICY;\n", "}\n"], "called_function_list": ["account", "cilium_dbg3", "ctx_load_meta", "ipv6_hdrlen", "ipv4_hdrlen"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "policy_can_access_ingress": [{"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 240, "endLine": 264, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/policy.h", "funcName": "policy_can_access_ingress", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " __u32 src_id", " __u32 dst_id", " __u16 dport", " __u8 proto", " bool is_untracked_fragment", " __u8 *match_type", " __u8 *audited"], "output": "static__always_inlineint", "helper": ["CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["static __always_inline int policy_can_access_ingress (struct  __ctx_buff *ctx, __u32 src_id, __u32 dst_id, __u16 dport, __u8 proto, bool is_untracked_fragment, __u8 *match_type, __u8 *audited)\n", "{\n", "    int ret;\n", "    ret = __policy_can_access (& POLICY_MAP, ctx, dst_id, src_id, dport, proto, CT_INGRESS, is_untracked_fragment, match_type);\n", "    if (ret >= CTX_ACT_OK)\n", "        return ret;\n", "    cilium_dbg (ctx, DBG_POLICY_DENIED, src_id, dst_id);\n", "    *audited = 0;\n", "\n", "#ifdef POLICY_AUDIT_MODE\n", "    if (IS_ERR (ret)) {\n", "        ret = CTX_ACT_OK;\n", "        *audited = 1;\n", "    }\n", "\n", "#endif\n", "    return ret;\n", "}\n"], "called_function_list": ["__policy_can_access", "cilium_dbg"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "is_encap": [{"capabilities": [], "helperCallParams": {}, "startLine": 267, "endLine": 270, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/policy.h", "funcName": "is_encap", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["__u16 dport", " __u8 proto"], "output": "static__always_inlinebool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline bool is_encap (__u16 dport, __u8 proto)\n", "{\n", "    return proto == IPPROTO_UDP && dport == bpf_htons (TUNNEL_PORT);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "policy_can_egress": [{"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 273, "endLine": 296, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/policy.h", "funcName": "policy_can_egress", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " __u32 src_id", " __u32 dst_id", " __u16 dport", " __u8 proto", " __u8 *match_type", " __u8 *audited"], "output": "static__always_inlineint", "helper": ["CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["static __always_inline int policy_can_egress (struct  __ctx_buff *ctx, __u32 src_id, __u32 dst_id, __u16 dport, __u8 proto, __u8 *match_type, __u8 *audited)\n", "{\n", "    int ret;\n", "\n", "#ifdef ENCAP_IFINDEX\n", "    if (src_id != HOST_ID && is_encap (dport, proto))\n", "        return DROP_ENCAP_PROHIBITED;\n", "\n", "#endif\n", "    ret = __policy_can_access (& POLICY_MAP, ctx, src_id, dst_id, dport, proto, CT_EGRESS, false, match_type);\n", "    if (ret >= 0)\n", "        return ret;\n", "    cilium_dbg (ctx, DBG_POLICY_DENIED, src_id, dst_id);\n", "    *audited = 0;\n", "\n", "#ifdef POLICY_AUDIT_MODE\n", "    if (IS_ERR (ret)) {\n", "        ret = CTX_ACT_OK;\n", "        *audited = 1;\n", "    }\n", "\n", "#endif\n", "    return ret;\n", "}\n"], "called_function_list": ["__policy_can_access", "is_encap", "cilium_dbg"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "policy_can_egress6": [{"capabilities": [], "helperCallParams": {}, "startLine": 298, "endLine": 305, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/policy.h", "funcName": "policy_can_egress6", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " const struct ipv6_ct_tuple *tuple", " __u32 src_id", " __u32 dst_id", " __u8 *match_type", " __u8 *audited"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int policy_can_egress6 (struct  __ctx_buff *ctx, const struct ipv6_ct_tuple *tuple, __u32 src_id, __u32 dst_id, __u8 *match_type, __u8 *audited)\n", "{\n", "    return policy_can_egress (ctx, src_id, dst_id, tuple->dport, tuple->nexthdr, match_type, audited);\n", "}\n"], "called_function_list": ["policy_can_egress"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "policy_can_egress4": [{"capabilities": [], "helperCallParams": {}, "startLine": 307, "endLine": 314, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/policy.h", "funcName": "policy_can_egress4", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " const struct ipv4_ct_tuple *tuple", " __u32 src_id", " __u32 dst_id", " __u8 *match_type", " __u8 *audited"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int policy_can_egress4 (struct  __ctx_buff *ctx, const struct ipv4_ct_tuple *tuple, __u32 src_id, __u32 dst_id, __u8 *match_type, __u8 *audited)\n", "{\n", "    return policy_can_egress (ctx, src_id, dst_id, tuple->dport, tuple->nexthdr, match_type, audited);\n", "}\n"], "called_function_list": ["policy_can_egress"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "policy_mark_skip": [{"capabilities": [], "helperCallParams": {}, "startLine": 323, "endLine": 326, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/policy.h", "funcName": "policy_mark_skip", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void policy_mark_skip (struct  __ctx_buff *ctx)\n", "{\n", "    ctx_store_meta (ctx, CB_POLICY, 1);\n", "}\n"], "called_function_list": ["ctx_store_meta"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "policy_clear_mark": [{"capabilities": [], "helperCallParams": {}, "startLine": 328, "endLine": 331, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/policy.h", "funcName": "policy_clear_mark", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void policy_clear_mark (struct  __ctx_buff *ctx)\n", "{\n", "    ctx_store_meta (ctx, CB_POLICY, 0);\n", "}\n"], "called_function_list": ["ctx_store_meta"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "validate_ethertype": [{"capabilities": [], "helperCallParams": {}, "startLine": 121, "endLine": 142, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/common.h", "funcName": "validate_ethertype", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " __u16 *proto"], "output": "static__always_inlinebool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline bool validate_ethertype (struct  __ctx_buff *ctx, __u16 *proto)\n", "{\n", "    void *data = ctx_data (ctx);\n", "    void *data_end = ctx_data_end (ctx);\n", "    struct ethhdr *eth = data;\n", "    if (ETH_HLEN == 0) {\n", "        *proto = ctx_get_protocol (ctx);\n", "        return true;\n", "    }\n", "    if (data + ETH_HLEN > data_end)\n", "        return false;\n", "    *proto = eth->h_proto;\n", "    if (bpf_ntohs (*proto) < ETH_P_802_3_MIN)\n", "        return false;\n", "    return true;\n", "}\n"], "called_function_list": ["ctx_data_end", "ctx_get_protocol", "ctx_data"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "____revalidate_data_pull": [{"capabilities": [], "helperCallParams": {}, "startLine": 144, "endLine": 167, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/common.h", "funcName": "____revalidate_data_pull", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " void **data_", " void **data_end_", " void **l3", " const __u32 l3_len", " const bool pull", " __u32 eth_hlen"], "output": "static__always_inline__maybe_unusedbool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused bool ____revalidate_data_pull (struct  __ctx_buff *ctx, void **data_, void **data_end_, void **l3, const __u32 l3_len, const bool pull, __u32 eth_hlen)\n", "{\n", "    const __u64 tot_len = eth_hlen + l3_len;\n", "    void *data_end;\n", "    void *data;\n", "    if (pull)\n", "        ctx_pull_data (ctx, tot_len);\n", "    data_end = ctx_data_end (ctx);\n", "    data = ctx_data (ctx);\n", "    if (data + tot_len > data_end)\n", "        return false;\n", "    *data_ = data;\n", "    *data_end_ = data_end;\n", "    *l3 = data + eth_hlen;\n", "    return true;\n", "}\n"], "called_function_list": ["ctx_data_end", "ctx_data"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__revalidate_data_pull": [{"capabilities": [], "helperCallParams": {}, "startLine": 169, "endLine": 175, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/common.h", "funcName": "__revalidate_data_pull", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " void **data", " void **data_end", " void **l3", " const __u32 l3_len", " const bool pull"], "output": "static__always_inline__maybe_unusedbool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused bool __revalidate_data_pull (struct  __ctx_buff *ctx, void **data, void **data_end, void **l3, const __u32 l3_len, const bool pull)\n", "{\n", "    return ____revalidate_data_pull (ctx, data, data_end, l3, l3_len, pull, ETH_HLEN);\n", "}\n"], "called_function_list": ["____revalidate_data_pull"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "or_encrypt_key": [{"capabilities": [], "helperCallParams": {}, "startLine": 605, "endLine": 608, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/common.h", "funcName": "or_encrypt_key", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["__u8 key"], "output": "static__always_inline__u32", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __u32 or_encrypt_key (__u8 key)\n", "{\n", "    return (((__u32) key & 0x0F) << 12) | MARK_MAGIC_ENCRYPT;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ct_state_is_from_l7lb": [{"capabilities": [], "helperCallParams": {}, "startLine": 958, "endLine": 965, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/common.h", "funcName": "ct_state_is_from_l7lb", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct ct_state * ct_state __maybe_unused"], "output": "static__always_inlinebool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline bool ct_state_is_from_l7lb (const struct ct_state * ct_state __maybe_unused)\n", "{\n", "\n", "#ifdef ENABLE_L7_LB\n", "    return ct_state->from_l7lb;\n", "\n", "#else\n", "    return false;\n", "\n", "#endif\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "redirect_ep": [{"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 984, "endLine": 1012, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/common.h", "funcName": "redirect_ep", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff * ctx __maybe_unused", " int ifindex __maybe_unused", " bool needs_backlog __maybe_unused"], "output": "static__always_inlineint", "helper": ["redirect", "CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["static __always_inline int redirect_ep (struct  __ctx_buff * ctx __maybe_unused, int ifindex __maybe_unused, bool needs_backlog __maybe_unused)\n", "{\n", "\n", "#ifdef ENABLE_HOST_REDIRECT\n", "    if (needs_backlog || !is_defined (ENABLE_HOST_ROUTING)) {\n", "        return ctx_redirect (ctx, ifindex, 0);\n", "    }\n", "    else {\n", "\n", "# ifdef ENCAP_IFINDEX\n", "        ctx_change_type (ctx, PACKET_HOST);\n", "\n", "# endif /* ENCAP_IFINDEX */\n", "        return ctx_redirect_peer (ctx, ifindex, 0);\n", "    }\n", "\n", "#else\n", "    return CTX_ACT_OK;\n", "\n", "#endif /* ENABLE_HOST_REDIRECT */\n", "}\n"], "called_function_list": ["ctx_redirect_peer", "ctx_redirect"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__send_drop_notify": [{"capabilities": [], "helperCallParams": {}, "startLine": 52, "endLine": 80, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/drop.h", "funcName": "__send_drop_notify", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx"], "output": "int", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["int __send_drop_notify (struct  __ctx_buff *ctx)\n", "{\n", "    __u32 error = ctx_load_meta (ctx, 2) & 0xFFFFFFFF;\n", "    __u64 ctx_len = ctx_full_len (ctx);\n", "    __u64 cap_len = min_t (__u64, TRACE_PAYLOAD_LEN, ctx_len);\n", "    __u32 meta4 = ctx_load_meta (ctx, 4);\n", "    __u16 line = (__u16) (meta4 >> 16);\n", "    __u8 file = (__u8) (meta4 >> 8);\n", "    __u8 exitcode = (__u8) meta4;\n", "    struct drop_notify msg;\n", "    msg = (typeof (msg)) {__notify_common_hdr (CILIUM_NOTIFY_DROP, (__u8) error), __notify_pktcap_hdr (ctx_len, (__u16) cap_len),\n", "        .src_label = ctx_load_meta (ctx, 0),\n", "        .dst_label = ctx_load_meta (ctx, 1),\n", "        .dst_id = ctx_load_meta (ctx, 3),\n", "        .line = line,\n", "        .file = file,\n", "        .ext_error = (__s8) (__u8) (error >> 8),};\n", "    ctx_event_output (ctx, &EVENTS_MAP, (cap_len << 32) | BPF_F_CURRENT_CPU, &msg, sizeof (msg));\n", "    return exitcode;\n", "}\n"], "called_function_list": ["ctx_load_meta", "ctx_full_len"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "_send_drop_notify": [{"capabilities": [], "helperCallParams": {}, "startLine": 95, "endLine": 116, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/drop.h", "funcName": "_send_drop_notify", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["__u8 file", " __u16 line", " struct  __ctx_buff *ctx", " __u32 src", " __u32 dst", " __u32 dst_id", " __u32 reason", " __u32 exitcode", " enum metric_dir direction"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int _send_drop_notify (__u8 file, __u16 line, struct  __ctx_buff *ctx, __u32 src, __u32 dst, __u32 dst_id, __u32 reason, __u32 exitcode, enum metric_dir direction)\n", "{\n", "    if (!__builtin_constant_p (exitcode) || exitcode > 0xff || !__builtin_constant_p (file) || file > 0xff || !__builtin_constant_p (line) || line > 0xffff)\n", "        __throw_build_bug ();\n", "    ctx_store_meta (ctx, 0, src);\n", "    ctx_store_meta (ctx, 1, dst);\n", "    ctx_store_meta (ctx, 2, reason);\n", "    ctx_store_meta (ctx, 3, dst_id);\n", "    ctx_store_meta (ctx, 4, exitcode | file << 8 | line << 16);\n", "    update_metrics (ctx_full_len (ctx), direction, (__u8) reason);\n", "    ep_tail_call (ctx, CILIUM_CALL_DROP_NOTIFY);\n", "    return exitcode;\n", "}\n"], "called_function_list": ["update_metrics", "ep_tail_call", "ctx_store_meta", "ctx_full_len"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 118, "endLine": 126, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/drop.h", "funcName": "_send_drop_notify", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["__u8 file __maybe_unused", " __u16 line __maybe_unused", " struct  __ctx_buff *ctx", " __u32 src __maybe_unused", " __u32 dst __maybe_unused", " __u32 dst_id __maybe_unused", " __u32 reason", " __u32 exitcode", " enum metric_dir direction"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int _send_drop_notify (__u8 file __maybe_unused, __u16 line __maybe_unused, struct  __ctx_buff *ctx, __u32 src __maybe_unused, __u32 dst __maybe_unused, __u32 dst_id __maybe_unused, __u32 reason, __u32 exitcode, enum metric_dir direction)\n", "{\n", "    update_metrics (ctx_full_len (ctx), direction, (__u8) reason);\n", "    return exitcode;\n", "}\n"], "called_function_list": ["update_metrics", "ep_tail_call", "ctx_store_meta", "ctx_full_len"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "cilium_dbg": [{"capabilities": [], "helperCallParams": {}, "startLine": 183, "endLine": 194, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/dbg.h", "funcName": "cilium_dbg", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " __u8 type", " __u32 arg1", " __u32 arg2"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void cilium_dbg (struct  __ctx_buff *ctx, __u8 type, __u32 arg1, __u32 arg2)\n", "{\n", "    struct debug_msg msg = {__notify_common_hdr (CILIUM_NOTIFY_DBG_MSG, type),\n", "        .arg1 = arg1,\n", "        .arg2 = arg2,}\n", "    ;\n", "    ctx_event_output (ctx, &EVENTS_MAP, BPF_F_CURRENT_CPU, &msg, sizeof (msg));\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 242, "endLine": 246, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/dbg.h", "funcName": "cilium_dbg", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff * ctx __maybe_unused", " __u8 type __maybe_unused", " __u32 arg1 __maybe_unused", " __u32 arg2 __maybe_unused"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void cilium_dbg (struct  __ctx_buff * ctx __maybe_unused, __u8 type __maybe_unused, __u32 arg1 __maybe_unused, __u32 arg2 __maybe_unused)\n", "{\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "cilium_dbg3": [{"capabilities": [], "helperCallParams": {}, "startLine": 196, "endLine": 208, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/dbg.h", "funcName": "cilium_dbg3", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " __u8 type", " __u32 arg1", " __u32 arg2", " __u32 arg3"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void cilium_dbg3 (struct  __ctx_buff *ctx, __u8 type, __u32 arg1, __u32 arg2, __u32 arg3)\n", "{\n", "    struct debug_msg msg = {__notify_common_hdr (CILIUM_NOTIFY_DBG_MSG, type),\n", "        .arg1 = arg1,\n", "        .arg2 = arg2,\n", "        .arg3 = arg3,}\n", "    ;\n", "    ctx_event_output (ctx, &EVENTS_MAP, BPF_F_CURRENT_CPU, &msg, sizeof (msg));\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 248, "endLine": 253, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/dbg.h", "funcName": "cilium_dbg3", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff * ctx __maybe_unused", " __u8 type __maybe_unused", " __u32 arg1 __maybe_unused", " __u32 arg2 __maybe_unused", " __u32 arg3 __maybe_unused"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void cilium_dbg3 (struct  __ctx_buff * ctx __maybe_unused, __u8 type __maybe_unused, __u32 arg1 __maybe_unused, __u32 arg2 __maybe_unused, __u32 arg3 __maybe_unused)\n", "{\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "cilium_dbg_capture2": [{"capabilities": [], "helperCallParams": {}, "startLine": 216, "endLine": 231, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/dbg.h", "funcName": "cilium_dbg_capture2", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " __u8 type", " __u32 arg1", " __u32 arg2"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void cilium_dbg_capture2 (struct  __ctx_buff *ctx, __u8 type, __u32 arg1, __u32 arg2)\n", "{\n", "    __u64 ctx_len = ctx_full_len (ctx);\n", "    __u64 cap_len = min_t (__u64, TRACE_PAYLOAD_LEN, ctx_len);\n", "    struct debug_capture_msg msg = {__notify_common_hdr (CILIUM_NOTIFY_DBG_CAPTURE, type), __notify_pktcap_hdr (ctx_len, (__u16) cap_len),\n", "        .arg1 = arg1,\n", "        .arg2 = arg2,}\n", "    ;\n", "    ctx_event_output (ctx, &EVENTS_MAP, (cap_len << 32) | BPF_F_CURRENT_CPU, &msg, sizeof (msg));\n", "}\n"], "called_function_list": ["ctx_full_len"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 261, "endLine": 266, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/dbg.h", "funcName": "cilium_dbg_capture2", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff * ctx __maybe_unused", " __u8 type __maybe_unused", " __u32 arg1 __maybe_unused", " __u32 arg2 __maybe_unused"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void cilium_dbg_capture2 (struct  __ctx_buff * ctx __maybe_unused, __u8 type __maybe_unused, __u32 arg1 __maybe_unused, __u32 arg2 __maybe_unused)\n", "{\n", "}\n"], "called_function_list": ["ctx_full_len"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "cilium_dbg_capture": [{"capabilities": [], "helperCallParams": {}, "startLine": 233, "endLine": 237, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/dbg.h", "funcName": "cilium_dbg_capture", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " __u8 type", " __u32 arg1"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void cilium_dbg_capture (struct  __ctx_buff *ctx, __u8 type, __u32 arg1)\n", "{\n", "    cilium_dbg_capture2 (ctx, type, arg1, 0);\n", "}\n"], "called_function_list": ["cilium_dbg_capture2"], "call_depth": 3, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 255, "endLine": 259, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/dbg.h", "funcName": "cilium_dbg_capture", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff * ctx __maybe_unused", " __u8 type __maybe_unused", " __u32 arg1 __maybe_unused"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void cilium_dbg_capture (struct  __ctx_buff * ctx __maybe_unused, __u8 type __maybe_unused, __u32 arg1 __maybe_unused)\n", "{\n", "}\n"], "called_function_list": ["cilium_dbg_capture2"], "call_depth": 3, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "do_decrypt": [{"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 15, "endLine": 75, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/encrypt.h", "funcName": "do_decrypt", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " __u16 proto"], "output": "static__always_inlineint", "helper": ["CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["static __always_inline int do_decrypt (struct  __ctx_buff *ctx, __u16 proto)\n", "{\n", "    void *data, *data_end;\n", "    __u8 protocol = 0;\n", "    bool decrypted;\n", "\n", "#ifdef ENABLE_IPV6\n", "    struct ipv6hdr *ip6;\n", "\n", "#endif\n", "\n", "#ifdef ENABLE_IPV4\n", "    struct iphdr *ip4;\n", "\n", "#endif\n", "    decrypted = ((ctx->mark & MARK_MAGIC_HOST_MASK) == MARK_MAGIC_DECRYPT);\n", "    switch (proto) {\n", "\n", "#ifdef ENABLE_IPV6\n", "    case bpf_htons (ETH_P_IPV6) :\n", "        if (!revalidate_data_pull (ctx, &data, &data_end, &ip6)) {\n", "            ctx->mark = 0;\n", "            return CTX_ACT_OK;\n", "        }\n", "        protocol = ip6->nexthdr;\n", "        break;\n", "\n", "#endif\n", "\n", "#ifdef ENABLE_IPV4\n", "    case bpf_htons (ETH_P_IP) :\n", "        if (!revalidate_data_pull (ctx, &data, &data_end, &ip4)) {\n", "            ctx->mark = 0;\n", "            return CTX_ACT_OK;\n", "        }\n", "        protocol = ip4->protocol;\n", "        break;\n", "\n", "#endif\n", "    default :\n", "        return CTX_ACT_OK;\n", "    }\n", "    if (!decrypted) {\n", "        if (protocol != IPPROTO_ESP)\n", "            return CTX_ACT_OK;\n", "        ctx->mark = MARK_MAGIC_DECRYPT;\n", "        ctx_change_type (ctx, PACKET_HOST);\n", "        return CTX_ACT_OK;\n", "    }\n", "    ctx->mark = 0;\n", "\n", "#ifdef ENABLE_ENDPOINT_ROUTES\n", "    return CTX_ACT_OK;\n", "\n", "#else\n", "    return ctx_redirect (ctx, CILIUM_IFINDEX, 0);\n", "\n", "#endif /* ENABLE_ROUTING */\n", "}\n"], "called_function_list": ["ctx_redirect"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 77, "endLine": 81, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/encrypt.h", "funcName": "do_decrypt", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff  __maybe_unused *ctx", " __u16 __maybe_unused proto"], "output": "static__always_inlineint", "helper": ["CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["static __always_inline int do_decrypt (struct  __ctx_buff  __maybe_unused *ctx, __u16 __maybe_unused proto)\n", "{\n", "    return CTX_ACT_OK;\n", "}\n"], "called_function_list": ["ctx_redirect"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "assign_socket_tcp": [{"capabilities": [{"capability": "read_sys_info", "read_sys_info": [{"Project": "cilium", "Return Type": "struct sock*", "Description": "Look for TCP socket matching <[ tuple ]>(IP: 1) , optionally in a child network namespace netns. The return value must be checked , and if non-NULL , released via sk_release(). This function is identical to sk_lookup_tcp() , except that it also returns timewait or request sockets. Use sk_fullsock() or tcp_sock() to access the full structure. This helper is available only if the kernel was compiled with CONFIG_NET configuration option. ", "Return": " Pointer  to  struct  sock, or NULL in case of failure.  For sockets with                     reuseport option, the struct  sock result is  from  reuse->socks[]  using                     the hash of the tuple.", "Function Name": "skc_lookup_tcp", "Input Params": ["{Type: void ,Var: *ctx}", "{Type:  struct sock_tuple ,Var: *tuple}", "{Type:  u32 ,Var: tuple_size}", "{Type:  u64 ,Var: netns}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp", "sk_skb", "cgroup_sock_addr"], "capabilities": ["read_sys_info"]}]}, {"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 14, "endLine": 42, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/proxy.h", "funcName": "assign_socket_tcp", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " struct bpf_sock_tuple *tuple", " __u32 len", " bool established"], "output": "static__always_inlineint", "helper": ["sk_release", "skc_lookup_tcp", "CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["static __always_inline int assign_socket_tcp (struct  __ctx_buff *ctx, struct bpf_sock_tuple *tuple, __u32 len, bool established)\n", "{\n", "    int result = DROP_PROXY_LOOKUP_FAILED;\n", "    struct bpf_sock *sk;\n", "    __u32 dbg_ctx;\n", "    sk = skc_lookup_tcp (ctx, tuple, len, BPF_F_CURRENT_NETNS, 0);\n", "    if (!sk)\n", "        goto out;\n", "    if (established && sk->state == BPF_TCP_TIME_WAIT)\n", "        goto release;\n", "    if (established && sk->state == BPF_TCP_LISTEN)\n", "        goto release;\n", "    dbg_ctx = sk->family << 16 | ctx->protocol;\n", "    result = sk_assign (ctx, sk, 0);\n", "    cilium_dbg (ctx, DBG_SK_ASSIGN, -result, dbg_ctx);\n", "    if (result == 0)\n", "        result = CTX_ACT_OK;\n", "    else\n", "        result = DROP_PROXY_SET_FAILED;\n", "release :\n", "    sk_release (sk);\n", "out :\n", "    return result;\n", "}\n"], "called_function_list": ["cilium_dbg"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "assign_socket_udp": [{"capabilities": [{"capability": "read_sys_info", "read_sys_info": [{"Project": "cilium", "Return Type": "struct sock*", "Description": "Look for UDP socket matching <[ tuple ]>(IP: 1) , optionally in a child network namespace netns. The return value must be checked , and if non-NULL , released via sk_release(). The <[ ctx ]>(IP: 0) should point to the context of the program , such as the skb or socket (depending on the hook in use). This is used to determine the base network namespace for the lookup. <[ tuple_size ]>(IP: 2) must be one of: sizeof(tuple->ipv4) Look for an IPv4 socket. sizeof(tuple->ipv6) Look for an IPv6 socket. If the <[ netns ]>(IP: 3) is a negative signed 32-bit integer , then the socket lookup table in the <[ netns ]>(IP: 3) associated with the <[ ctx ]>(IP: 0) will will be used. For the TC hooks , this is the <[ netns ]>(IP: 3) of the device in the skb. For socket hooks , this is the <[ netns ]>(IP: 3) of the socket. If <[ netns ]>(IP: 3) is any other signed 32-bit value greater than or equal to zero then it specifies the ID of the <[ netns ]>(IP: 3) relative to the <[ netns ]>(IP: 3) associated with the ctx. <[ netns ]>(IP: 3) values beyond the range of 32-bit integers are reserved for future use. All values for <[ flags ]>(IP: 4) are reserved for future usage , and must be left at zero. This helper is available only if the kernel was compiled with CONFIG_NET configuration option. ", "Return": " Pointer  to  struct  sock, or NULL in case of failure.  For sockets with                     reuseport option, the struct  sock result is  from  reuse->socks[]  using                     the hash of the tuple.", "Function Name": "sk_lookup_udp", "Input Params": ["{Type: void ,Var: *ctx}", "{Type:  struct sock_tuple ,Var: *tuple}", "{Type:  u32 ,Var: tuple_size}", "{Type:  u64 ,Var: netns}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp", "sk_skb", "cgroup_sock_addr"], "capabilities": ["read_sys_info"]}]}, {"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 44, "endLine": 67, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/proxy.h", "funcName": "assign_socket_udp", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " struct bpf_sock_tuple *tuple", " __u32 len", " bool established __maybe_unused"], "output": "static__always_inlineint", "helper": ["sk_lookup_udp", "CTX_ACT_OK", "sk_release"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["static __always_inline int assign_socket_udp (struct  __ctx_buff *ctx, struct bpf_sock_tuple *tuple, __u32 len, bool established __maybe_unused)\n", "{\n", "    int result = DROP_PROXY_LOOKUP_FAILED;\n", "    struct bpf_sock *sk;\n", "    __u32 dbg_ctx;\n", "    sk = sk_lookup_udp (ctx, tuple, len, BPF_F_CURRENT_NETNS, 0);\n", "    if (!sk)\n", "        goto out;\n", "    dbg_ctx = sk->family << 16 | ctx->protocol;\n", "    result = sk_assign (ctx, sk, 0);\n", "    cilium_dbg (ctx, DBG_SK_ASSIGN, -result, dbg_ctx);\n", "    if (result == 0)\n", "        result = CTX_ACT_OK;\n", "    else\n", "        result = DROP_PROXY_SET_FAILED;\n", "    sk_release (sk);\n", "out :\n", "    return result;\n", "}\n"], "called_function_list": ["cilium_dbg"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "assign_socket": [{"capabilities": [], "helperCallParams": {}, "startLine": 69, "endLine": 86, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/proxy.h", "funcName": "assign_socket", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " struct bpf_sock_tuple *tuple", " __u32 len", " __u8 nexthdr", " bool established"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int assign_socket (struct  __ctx_buff *ctx, struct bpf_sock_tuple *tuple, __u32 len, __u8 nexthdr, bool established)\n", "{\n", "    switch (nexthdr) {\n", "    case IPPROTO_TCP :\n", "        return assign_socket_tcp (ctx, tuple, len, established);\n", "    case IPPROTO_UDP :\n", "        return assign_socket_udp (ctx, tuple, len, established);\n", "    }\n", "    return DROP_PROXY_UNKNOWN_PROTO;\n", "}\n"], "called_function_list": ["assign_socket_udp", "assign_socket_tcp"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "combine_ports": [{"capabilities": [], "helperCallParams": {}, "startLine": 92, "endLine": 96, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/proxy.h", "funcName": "combine_ports", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["__u16 dport", " __u16 sport"], "output": "static__always_inline__u32", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __u32 combine_ports (__u16 dport, __u16 sport)\n", "{\n", "    return (bpf_ntohs (dport) << 16) | bpf_ntohs (sport);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__ctx_redirect_to_proxy": [{"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 190, "endLine": 220, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/proxy.h", "funcName": "__ctx_redirect_to_proxy", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " void * tuple __maybe_unused", " __be16 proxy_port", " bool from_host __maybe_unused", " bool ipv4 __maybe_unused"], "output": "static__always_inlineint", "helper": ["CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["static __always_inline int __ctx_redirect_to_proxy (struct  __ctx_buff *ctx, void * tuple __maybe_unused, __be16 proxy_port, bool from_host __maybe_unused, bool ipv4 __maybe_unused)\n", "{\n", "    int result __maybe_unused = CTX_ACT_OK;\n", "\n", "#ifdef ENABLE_TPROXY\n", "    if (!from_host)\n", "        ctx->mark |= MARK_MAGIC_TO_PROXY;\n", "    else\n", "\n", "#endif\n", "        ctx->mark = MARK_MAGIC_TO_PROXY | proxy_port << 16;\n", "    cilium_dbg (ctx, DBG_CAPTURE_PROXY_PRE, proxy_port, 0);\n", "\n", "#ifdef ENABLE_TPROXY\n", "    if (proxy_port && !from_host) {\n", "\n", "#ifdef ENABLE_IPV4\n", "        if (ipv4)\n", "            result = ctx_redirect_to_proxy_ingress4 (ctx, tuple, proxy_port);\n", "\n", "#endif /* ENABLE_IPV4 */\n", "\n", "#ifdef ENABLE_IPV6\n", "        if (!ipv4)\n", "            result = ctx_redirect_to_proxy_ingress6 (ctx, tuple, proxy_port);\n", "\n", "#endif /* ENABLE_IPV6 */\n", "    }\n", "\n", "#endif /* ENABLE_TPROXY */\n", "    ctx_change_type (ctx, PACKET_HOST);\n", "    return result;\n", "}\n"], "called_function_list": ["cilium_dbg"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ctx_redirect_to_proxy4": [{"capabilities": [], "helperCallParams": {}, "startLine": 223, "endLine": 228, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/proxy.h", "funcName": "ctx_redirect_to_proxy4", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " void * tuple __maybe_unused", " __be16 proxy_port", " bool from_host __maybe_unused"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int ctx_redirect_to_proxy4 (struct  __ctx_buff *ctx, void * tuple __maybe_unused, __be16 proxy_port, bool from_host __maybe_unused)\n", "{\n", "    return __ctx_redirect_to_proxy (ctx, tuple, proxy_port, from_host, true);\n", "}\n"], "called_function_list": ["__ctx_redirect_to_proxy"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ctx_redirect_to_proxy6": [{"capabilities": [], "helperCallParams": {}, "startLine": 232, "endLine": 237, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/proxy.h", "funcName": "ctx_redirect_to_proxy6", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " void * tuple __maybe_unused", " __be16 proxy_port", " bool from_host __maybe_unused"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int ctx_redirect_to_proxy6 (struct  __ctx_buff *ctx, void * tuple __maybe_unused, __be16 proxy_port, bool from_host __maybe_unused)\n", "{\n", "    return __ctx_redirect_to_proxy (ctx, tuple, proxy_port, from_host, false);\n", "}\n"], "called_function_list": ["__ctx_redirect_to_proxy"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ctx_redirect_to_proxy_first": [{"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 280, "endLine": 337, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/proxy.h", "funcName": "ctx_redirect_to_proxy_first", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " __be16 proxy_port"], "output": "static__always_inlineint", "helper": ["CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["static __always_inline int ctx_redirect_to_proxy_first (struct  __ctx_buff *ctx, __be16 proxy_port)\n", "{\n", "    int ret = CTX_ACT_OK;\n", "\n", "#if defined(ENABLE_TPROXY)\n", "    __u16 proto;\n", "    if (!proxy_port)\n", "        goto mark;\n", "    if (!validate_ethertype (ctx, &proto))\n", "        return DROP_UNSUPPORTED_L2;\n", "    ret = DROP_UNKNOWN_L3;\n", "    switch (proto) {\n", "\n", "#ifdef ENABLE_IPV6\n", "    case bpf_htons (ETH_P_IPV6) :\n", "        {\n", "            struct ipv6_ct_tuple tuple;\n", "            ret = extract_tuple6 (ctx, & tuple);\n", "            if (ret < 0)\n", "                return ret;\n", "            ret = ctx_redirect_to_proxy_ingress6 (ctx, & tuple, proxy_port);\n", "            break;\n", "        }\n", "\n", "#endif /* ENABLE_IPV6 */\n", "\n", "#ifdef ENABLE_IPV4\n", "    case bpf_htons (ETH_P_IP) :\n", "        {\n", "            struct ipv4_ct_tuple tuple;\n", "            ret = extract_tuple4 (ctx, & tuple);\n", "            if (ret < 0)\n", "                return ret;\n", "            ret = ctx_redirect_to_proxy_ingress4 (ctx, & tuple, proxy_port);\n", "            break;\n", "        }\n", "\n", "#endif /* ENABLE_IPV4 */\n", "    default :\n", "        goto out;\n", "    }\n", "\n", "#endif /* ENABLE_TPROXY */\n", "mark :\n", "    __maybe_unused cilium_dbg (ctx, DBG_CAPTURE_PROXY_POST, proxy_port, 0);\n", "    ctx->mark = MARK_MAGIC_TO_PROXY | (proxy_port << 16);\n", "    ctx_change_type (ctx, PACKET_HOST);\n", "out :\n", "    __maybe_unused\n", "    return ret;\n", "}\n"], "called_function_list": ["validate_ethertype", "cilium_dbg"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "tc_index_skip_ingress_proxy": [{"capabilities": [], "helperCallParams": {}, "startLine": 342, "endLine": 351, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/proxy.h", "funcName": "tc_index_skip_ingress_proxy", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx"], "output": "static__always_inlinebool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline bool tc_index_skip_ingress_proxy (struct  __ctx_buff *ctx)\n", "{\n", "    volatile __u32 tc_index = ctx->tc_index;\n", "\n", "#ifdef DEBUG\n", "    if (tc_index & TC_INDEX_F_SKIP_INGRESS_PROXY)\n", "        cilium_dbg (ctx, DBG_SKIP_PROXY, tc_index, 0);\n", "\n", "#endif\n", "    return tc_index & TC_INDEX_F_SKIP_INGRESS_PROXY;\n", "}\n"], "called_function_list": ["cilium_dbg"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "tc_index_skip_egress_proxy": [{"capabilities": [], "helperCallParams": {}, "startLine": 356, "endLine": 365, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/proxy.h", "funcName": "tc_index_skip_egress_proxy", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx"], "output": "static__always_inlinebool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline bool tc_index_skip_egress_proxy (struct  __ctx_buff *ctx)\n", "{\n", "    volatile __u32 tc_index = ctx->tc_index;\n", "\n", "#ifdef DEBUG\n", "    if (tc_index & TC_INDEX_F_SKIP_EGRESS_PROXY)\n", "        cilium_dbg (ctx, DBG_SKIP_PROXY, tc_index, 0);\n", "\n", "#endif\n", "    return tc_index & TC_INDEX_F_SKIP_EGRESS_PROXY;\n", "}\n"], "called_function_list": ["cilium_dbg"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "is_valid_lxc_src_ip": [{"capabilities": [], "helperCallParams": {}, "startLine": 22, "endLine": 34, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lxc.h", "funcName": "is_valid_lxc_src_ip", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct ipv6hdr * ip6 __maybe_unused"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int is_valid_lxc_src_ip (struct ipv6hdr * ip6 __maybe_unused)\n", "{\n", "\n", "#ifdef ENABLE_IPV6\n", "    union v6addr valid = {}\n", "    ;\n", "    BPF_V6 (valid, LXC_IP);\n", "    return !ipv6_addrcmp ((union v6addr *) &ip6->saddr, &valid);\n", "\n", "#else\n", "    return 0;\n", "\n", "#endif\n", "}\n"], "called_function_list": ["ipv6_addrcmp"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 47, "endLine": 51, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lxc.h", "funcName": "is_valid_lxc_src_ip", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct ipv6hdr * ip6 __maybe_unused"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int is_valid_lxc_src_ip (struct ipv6hdr * ip6 __maybe_unused)\n", "{\n", "    return 1;\n", "}\n"], "called_function_list": ["ipv6_addrcmp"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "is_valid_lxc_src_ipv4": [{"capabilities": [], "helperCallParams": {}, "startLine": 36, "endLine": 45, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lxc.h", "funcName": "is_valid_lxc_src_ipv4", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct iphdr * ip4 __maybe_unused"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int is_valid_lxc_src_ipv4 (const struct iphdr * ip4 __maybe_unused)\n", "{\n", "\n", "#ifdef ENABLE_IPV4\n", "    return ip4->saddr == LXC_IPV4;\n", "\n", "#else\n", "    return 0;\n", "\n", "#endif\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 53, "endLine": 57, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lxc.h", "funcName": "is_valid_lxc_src_ipv4", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct iphdr * ip4 __maybe_unused"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int is_valid_lxc_src_ipv4 (struct iphdr * ip4 __maybe_unused)\n", "{\n", "    return 1;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "redirect_direct_v6": [{"capabilities": [{"capability": "read_sys_info", "read_sys_info": [{"Project": "libbpf", "Return Type": "int", "Description": "Do FIB lookup in kernel tables using parameters in params. If lookup is successful and result shows packet is to be forwarded , the neighbor tables are searched for the nexthop. If successful (ie. , FIB lookup shows forwarding and nexthop is resolved) , the nexthop address is returned in ipv4_dst or ipv6_dst based on family , smac is set to mac address of egress device , dmac is set to nexthop mac address , rt_metric is set to metric from route (IPv4/IPv6 only) , and ifindex is set to the device index of the nexthop from the FIB lookup. <[ plen ]>(IP: 2) argument is the size of the passed in struct. <[ flags ]>(IP: 3) argument can be a combination of one or more of the following values: BPF_FIB_LOOKUP_DIRECT Do a direct table lookup vs full lookup using FIB rules. BPF_FIB_LOOKUP_OUTPUT Perform lookup from an egress perspective (default is ingress). <[ ctx ]>(IP: 0) is either struct xdp_md for XDP programs or struct sk_buff tc cls_act programs. Return \u00b7 < 0 if any input argument is invalid \u00b7 0 on success (packet is forwarded , nexthop neighbor exists) \u00b7 > 0 one of BPF_FIB_LKUP_RET_ codes explaining why the packet is not forwarded or needs assist from full stack ", "Function Name": "bpf_fib_lookup", "Input Params": ["{Type: void ,Var: *ctx}", "{Type:  struct bpf_fib_lookup ,Var: *params}", "{Type:  int ,Var: plen}", "{Type:  u32 ,Var: flags}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp"], "capabilities": ["read_sys_info"]}, {"Project": "cilium", "Return Type": "int", "Description": "Do FIB lookup in kernel tables using parameters in params. If lookup is successful and result shows packet is to be forwarded , the neighbor tables are searched for the nexthop. If successful (ie. , FIB lookup shows forwarding and nexthop is resolved) , the nexthop address is returned in ipv4_dst or ipv6_dst based on family , smac is set to mac address of egress device , dmac is set to nexthop mac address , rt_metric is set to metric from route (IPv4/IPv6 only) , and ifindex is set to the device index of the nexthop from the FIB lookup. <[ plen ]>(IP: 2) argument is the size of the passed in struct. <[ flags ]>(IP: 3) argument can be a combination of one or more of the following values: BPF_FIB_LOOKUP_DIRECT Do a direct table lookup vs full lookup using FIB rules. BPF_FIB_LOOKUP_OUTPUT Perform lookup from an egress perspective (default is ingress). <[ ctx ]>(IP: 0) is either struct xdp_md for XDP programs or struct sk_buff tc cls_act programs. Return \u00b7 < 0 if any input argument is invalid \u00b7 0 on success (packet is forwarded , nexthop neighbor exists) \u00b7 > 0 one of BPF_FIB_LKUP_RET_ codes explaining why the packet is not forwarded or needs assist from full stack ", "Function Name": "fib_lookup", "Input Params": ["{Type: void ,Var: *ctx}", "{Type:  struct fib_lookup ,Var: *params}", "{Type:  int ,Var: plen}", "{Type:  u32 ,Var: flags}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp"], "capabilities": ["read_sys_info"]}]}, {"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 14, "endLine": 66, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/fib.h", "funcName": "redirect_direct_v6", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff * ctx __maybe_unused", " int l3_off __maybe_unused", " struct ipv6hdr * ip6 __maybe_unused"], "output": "static__always_inlineint", "helper": ["redirect", "bpf_fib_lookup", "CTX_ACT_OK", "fib_lookup"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["static __always_inline int redirect_direct_v6 (struct  __ctx_buff * ctx __maybe_unused, int l3_off __maybe_unused, struct ipv6hdr * ip6 __maybe_unused)\n", "{\n", "    bool no_neigh = is_defined (ENABLE_SKIP_FIB);\n", "    int ret, oif = DIRECT_ROUTING_DEV_IFINDEX;\n", "    struct bpf_redir_neigh *nh = NULL;\n", "\n", "# ifndef ENABLE_SKIP_FIB\n", "    struct bpf_redir_neigh nh_params;\n", "    struct bpf_fib_lookup fib_params = {\n", "        .family = AF_INET6,\n", "        .ifindex = ctx->ingress_ifindex,}\n", "    ;\n", "    ipv6_addr_copy ((union v6addr *) &fib_params.ipv6_src, (union v6addr *) &ip6->saddr);\n", "    ipv6_addr_copy ((union v6addr *) &fib_params.ipv6_dst, (union v6addr *) &ip6->daddr);\n", "    ret = fib_lookup (ctx, & fib_params, sizeof (fib_params), BPF_FIB_LOOKUP_DIRECT);\n", "    switch (ret) {\n", "    case BPF_FIB_LKUP_RET_SUCCESS :\n", "        break;\n", "    case BPF_FIB_LKUP_RET_NO_NEIGH :\n", "        nh_params.nh_family = fib_params.family;\n", "        __bpf_memcpy_builtin (&nh_params.ipv6_nh, &fib_params.ipv6_dst, sizeof (nh_params.ipv6_nh));\n", "        no_neigh = true;\n", "        nh = &nh_params;\n", "        break;\n", "    default :\n", "        return CTX_ACT_DROP;\n", "    }\n", "    oif = fib_params.ifindex;\n", "\n", "# endif /* ENABLE_SKIP_FIB */\n", "    ret = ipv6_l3 (ctx, l3_off, NULL, NULL, METRIC_EGRESS);\n", "    if (unlikely (ret != CTX_ACT_OK))\n", "        return ret;\n", "    if (no_neigh)\n", "        return redirect_neigh (oif, nh, nh ? sizeof (*nh) : 0, 0);\n", "\n", "# ifndef ENABLE_SKIP_FIB\n", "    if (eth_store_daddr (ctx, fib_params.dmac, 0) < 0)\n", "        return CTX_ACT_DROP;\n", "    if (eth_store_saddr (ctx, fib_params.smac, 0) < 0)\n", "        return CTX_ACT_DROP;\n", "    return ctx_redirect (ctx, oif, 0);\n", "\n", "# endif /* ENABLE_SKIP_FIB */\n", "    return CTX_ACT_DROP;\n", "}\n"], "called_function_list": ["ipv6_l3", "eth_store_daddr", "eth_store_saddr", "ipv6_addr_copy", "ctx_redirect", "__bpf_memcpy_builtin"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "redirect_direct_v4": [{"capabilities": [{"capability": "read_sys_info", "read_sys_info": [{"Project": "libbpf", "Return Type": "int", "Description": "Do FIB lookup in kernel tables using parameters in params. If lookup is successful and result shows packet is to be forwarded , the neighbor tables are searched for the nexthop. If successful (ie. , FIB lookup shows forwarding and nexthop is resolved) , the nexthop address is returned in ipv4_dst or ipv6_dst based on family , smac is set to mac address of egress device , dmac is set to nexthop mac address , rt_metric is set to metric from route (IPv4/IPv6 only) , and ifindex is set to the device index of the nexthop from the FIB lookup. <[ plen ]>(IP: 2) argument is the size of the passed in struct. <[ flags ]>(IP: 3) argument can be a combination of one or more of the following values: BPF_FIB_LOOKUP_DIRECT Do a direct table lookup vs full lookup using FIB rules. BPF_FIB_LOOKUP_OUTPUT Perform lookup from an egress perspective (default is ingress). <[ ctx ]>(IP: 0) is either struct xdp_md for XDP programs or struct sk_buff tc cls_act programs. Return \u00b7 < 0 if any input argument is invalid \u00b7 0 on success (packet is forwarded , nexthop neighbor exists) \u00b7 > 0 one of BPF_FIB_LKUP_RET_ codes explaining why the packet is not forwarded or needs assist from full stack ", "Function Name": "bpf_fib_lookup", "Input Params": ["{Type: void ,Var: *ctx}", "{Type:  struct bpf_fib_lookup ,Var: *params}", "{Type:  int ,Var: plen}", "{Type:  u32 ,Var: flags}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp"], "capabilities": ["read_sys_info"]}, {"Project": "cilium", "Return Type": "int", "Description": "Do FIB lookup in kernel tables using parameters in params. If lookup is successful and result shows packet is to be forwarded , the neighbor tables are searched for the nexthop. If successful (ie. , FIB lookup shows forwarding and nexthop is resolved) , the nexthop address is returned in ipv4_dst or ipv6_dst based on family , smac is set to mac address of egress device , dmac is set to nexthop mac address , rt_metric is set to metric from route (IPv4/IPv6 only) , and ifindex is set to the device index of the nexthop from the FIB lookup. <[ plen ]>(IP: 2) argument is the size of the passed in struct. <[ flags ]>(IP: 3) argument can be a combination of one or more of the following values: BPF_FIB_LOOKUP_DIRECT Do a direct table lookup vs full lookup using FIB rules. BPF_FIB_LOOKUP_OUTPUT Perform lookup from an egress perspective (default is ingress). <[ ctx ]>(IP: 0) is either struct xdp_md for XDP programs or struct sk_buff tc cls_act programs. Return \u00b7 < 0 if any input argument is invalid \u00b7 0 on success (packet is forwarded , nexthop neighbor exists) \u00b7 > 0 one of BPF_FIB_LKUP_RET_ codes explaining why the packet is not forwarded or needs assist from full stack ", "Function Name": "fib_lookup", "Input Params": ["{Type: void ,Var: *ctx}", "{Type:  struct fib_lookup ,Var: *params}", "{Type:  int ,Var: plen}", "{Type:  u32 ,Var: flags}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp"], "capabilities": ["read_sys_info"]}]}, {"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 70, "endLine": 126, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/fib.h", "funcName": "redirect_direct_v4", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff * ctx __maybe_unused", " int l3_off __maybe_unused", " struct iphdr * ip4 __maybe_unused"], "output": "static__always_inlineint", "helper": ["redirect", "bpf_fib_lookup", "CTX_ACT_OK", "fib_lookup"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["static __always_inline int redirect_direct_v4 (struct  __ctx_buff * ctx __maybe_unused, int l3_off __maybe_unused, struct iphdr * ip4 __maybe_unused)\n", "{\n", "    bool no_neigh = is_defined (ENABLE_SKIP_FIB);\n", "    int ret, oif = DIRECT_ROUTING_DEV_IFINDEX;\n", "    struct bpf_redir_neigh *nh = NULL;\n", "\n", "# ifndef ENABLE_SKIP_FIB\n", "    struct bpf_redir_neigh nh_params;\n", "    struct bpf_fib_lookup fib_params = {\n", "        .family = AF_INET,\n", "        .ifindex = ctx->ingress_ifindex,\n", "        .ipv4_src = ip4->saddr,\n", "        .ipv4_dst = ip4->daddr,}\n", "    ;\n", "    ret = fib_lookup (ctx, & fib_params, sizeof (fib_params), BPF_FIB_LOOKUP_DIRECT);\n", "    switch (ret) {\n", "    case BPF_FIB_LKUP_RET_SUCCESS :\n", "        break;\n", "    case BPF_FIB_LKUP_RET_NO_NEIGH :\n", "        nh_params.nh_family = fib_params.family;\n", "        __bpf_memcpy_builtin (&nh_params.ipv6_nh, &fib_params.ipv6_dst, sizeof (nh_params.ipv6_nh));\n", "        no_neigh = true;\n", "        nh = &nh_params;\n", "        break;\n", "    default :\n", "        return CTX_ACT_DROP;\n", "    }\n", "    oif = fib_params.ifindex;\n", "\n", "# endif /* ENABLE_SKIP_FIB */\n", "    ret = ipv4_l3 (ctx, l3_off, NULL, NULL, ip4);\n", "    if (unlikely (ret != CTX_ACT_OK))\n", "        return ret;\n", "    if (no_neigh)\n", "        return redirect_neigh (oif, nh, nh ? sizeof (*nh) : 0, 0);\n", "\n", "# ifndef ENABLE_SKIP_FIB\n", "    if (eth_store_daddr (ctx, fib_params.dmac, 0) < 0)\n", "        return CTX_ACT_DROP;\n", "    if (eth_store_saddr (ctx, fib_params.smac, 0) < 0)\n", "        return CTX_ACT_DROP;\n", "    return ctx_redirect (ctx, oif, 0);\n", "\n", "# endif /* ENABLE_SKIP_FIB */\n", "    return CTX_ACT_DROP;\n", "}\n"], "called_function_list": ["ipv4_l3", "eth_store_daddr", "eth_store_saddr", "ctx_redirect", "__bpf_memcpy_builtin"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "encap_and_redirect_nomark_ipsec": [{"capabilities": [], "helperCallParams": {}, "startLine": 18, "endLine": 40, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/encap.h", "funcName": "encap_and_redirect_nomark_ipsec", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " __u32 tunnel_endpoint", " __u8 key", " __u32 seclabel"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int encap_and_redirect_nomark_ipsec (struct  __ctx_buff *ctx, __u32 tunnel_endpoint, __u8 key, __u32 seclabel)\n", "{\n", "    ctx_store_meta (ctx, CB_ENCRYPT_MAGIC, or_encrypt_key (key));\n", "    ctx_store_meta (ctx, CB_ENCRYPT_IDENTITY, seclabel);\n", "    ctx_store_meta (ctx, CB_ENCRYPT_DST, tunnel_endpoint);\n", "    return IPSEC_ENDPOINT;\n", "}\n"], "called_function_list": ["ctx_store_meta", "or_encrypt_key"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "encap_and_redirect_ipsec": [{"capabilities": [], "helperCallParams": {}, "startLine": 42, "endLine": 57, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/encap.h", "funcName": "encap_and_redirect_ipsec", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " __u32 tunnel_endpoint", " __u8 key", " __u32 seclabel"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int encap_and_redirect_ipsec (struct  __ctx_buff *ctx, __u32 tunnel_endpoint, __u8 key, __u32 seclabel)\n", "{\n", "    set_encrypt_key_mark (ctx, key);\n", "    set_identity_mark (ctx, seclabel);\n", "    ctx_store_meta (ctx, CB_ENCRYPT_DST, tunnel_endpoint);\n", "    return IPSEC_ENDPOINT;\n", "}\n"], "called_function_list": ["ctx_store_meta", "set_identity_mark", "set_encrypt_key_mark"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "encap_remap_v6_host_address": [{"capabilities": [{"capability": "read_skb", "read_skb": [{"Project": "cilium", "Return Type": "s64", "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ", "Return": " The checksum result, or a negative error code in case of failure.", "Function Name": "csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp", "lwt_in", "lwt_out", "lwt_xmit", "lwt_seg6local"], "capabilities": ["read_skb"]}]}], "helperCallParams": {}, "startLine": 60, "endLine": 117, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/encap.h", "funcName": "encap_remap_v6_host_address", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff * ctx __maybe_unused", " const bool egress __maybe_unused"], "output": "static__always_inlineint", "helper": ["csum_diff"], "compatibleHookpoints": ["sched_cls", "lwt_xmit", "xdp", "lwt_in", "sched_act", "lwt_out", "lwt_seg6local"], "source": ["static __always_inline int encap_remap_v6_host_address (struct  __ctx_buff * ctx __maybe_unused, const bool egress __maybe_unused)\n", "{\n", "\n", "#ifdef ENABLE_ENCAP_HOST_REMAP\n", "    struct csum_offset csum = {}\n", "    ;\n", "    union v6addr host_ip;\n", "    void *data, *data_end;\n", "    struct ipv6hdr *ip6;\n", "    union v6addr *which;\n", "    __u8 nexthdr;\n", "    __u16 proto;\n", "    __be32 sum;\n", "    __u32 noff;\n", "    __u64 off;\n", "    int ret;\n", "    validate_ethertype (ctx, &proto);\n", "    if (proto != bpf_htons (ETH_P_IPV6))\n", "        return 0;\n", "    if (!revalidate_data (ctx, &data, &data_end, &ip6))\n", "        return DROP_INVALID;\n", "    if (egress) {\n", "        BPF_V6 (host_ip, HOST_IP);\n", "        which = (union v6addr *) &ip6->saddr;\n", "    }\n", "    else {\n", "        BPF_V6 (host_ip, ROUTER_IP);\n", "        which = (union v6addr *) &ip6->daddr;\n", "    }\n", "    if (ipv6_addrcmp (which, &host_ip))\n", "        return 0;\n", "    nexthdr = ip6->nexthdr;\n", "    ret = ipv6_hdrlen (ctx, & nexthdr);\n", "    if (ret < 0)\n", "        return ret;\n", "    off = ((void *) ip6 - data) + ret;\n", "    if (egress) {\n", "        BPF_V6 (host_ip, ROUTER_IP);\n", "        noff = ETH_HLEN + offsetof (struct ipv6hdr, saddr);\n", "    }\n", "    else {\n", "        BPF_V6 (host_ip, HOST_IP);\n", "        noff = ETH_HLEN + offsetof (struct ipv6hdr, daddr);\n", "    }\n", "    sum = csum_diff (which, 16, & host_ip, 16, 0);\n", "    csum_l4_offset_and_flags (nexthdr, &csum);\n", "    if (ctx_store_bytes (ctx, noff, &host_ip, 16, 0) < 0)\n", "        return DROP_WRITE_ERROR;\n", "    if (csum.offset && csum_l4_replace (ctx, off, &csum, 0, sum, BPF_F_PSEUDO_HDR) < 0)\n", "        return DROP_CSUM_L4;\n", "\n", "#endif /* ENABLE_ENCAP_HOST_REMAP */\n", "    return 0;\n", "}\n"], "called_function_list": ["csum_l4_replace", "ipv6_hdrlen", "validate_ethertype", "ipv6_addrcmp", "csum_l4_offset_and_flags"], "call_depth": 3, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__encap_with_nodeid": [{"capabilities": [], "helperCallParams": {}, "startLine": 119, "endLine": 154, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/encap.h", "funcName": "__encap_with_nodeid", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " __u32 tunnel_endpoint", " __u32 seclabel", " __u32 vni __maybe_unused", " enum trace_reason ct_reason", " __u32 monitor"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int __encap_with_nodeid (struct  __ctx_buff *ctx, __u32 tunnel_endpoint, __u32 seclabel, __u32 vni __maybe_unused, enum trace_reason ct_reason, __u32 monitor)\n", "{\n", "    struct bpf_tunnel_key key = {}\n", "    ;\n", "    __u32 node_id;\n", "    int ret;\n", "    if (seclabel == HOST_ID)\n", "        seclabel = LOCAL_NODE_ID;\n", "    node_id = bpf_htonl (tunnel_endpoint);\n", "\n", "#ifdef ENABLE_VTEP\n", "    if (vni != NOT_VTEP_DST)\n", "        key.tunnel_id = vni;\n", "    else\n", "\n", "#endif /* ENABLE_VTEP */\n", "        key.tunnel_id = seclabel;\n", "    key.remote_ipv4 = node_id;\n", "    key.tunnel_ttl = 64;\n", "    cilium_dbg (ctx, DBG_ENCAP, node_id, seclabel);\n", "    ret = ctx_set_tunnel_key (ctx, & key, sizeof (key), BPF_F_ZERO_CSUM_TX);\n", "    if (unlikely (ret < 0))\n", "        return DROP_WRITE_ERROR;\n", "    send_trace_notify (ctx, TRACE_TO_OVERLAY, seclabel, 0, 0, ENCAP_IFINDEX, ct_reason, monitor);\n", "    return 0;\n", "}\n"], "called_function_list": ["send_trace_notify", "cilium_dbg"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__encap_and_redirect_with_nodeid": [{"capabilities": [], "helperCallParams": {}, "startLine": 156, "endLine": 167, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/encap.h", "funcName": "__encap_and_redirect_with_nodeid", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " __u32 tunnel_endpoint", " __u32 seclabel", " __u32 vni", " const struct trace_ctx *trace"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int __encap_and_redirect_with_nodeid (struct  __ctx_buff *ctx, __u32 tunnel_endpoint, __u32 seclabel, __u32 vni, const struct trace_ctx *trace)\n", "{\n", "    int ret = __encap_with_nodeid (ctx, tunnel_endpoint, seclabel, vni, trace -> reason, trace -> monitor);\n", "    if (ret != 0)\n", "        return ret;\n", "    return ctx_redirect (ctx, ENCAP_IFINDEX, 0);\n", "}\n"], "called_function_list": ["__encap_with_nodeid", "ctx_redirect"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "encap_and_redirect_with_nodeid": [{"capabilities": [], "helperCallParams": {}, "startLine": 174, "endLine": 185, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/encap.h", "funcName": "encap_and_redirect_with_nodeid", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " __u32 tunnel_endpoint", " __u8 key __maybe_unused", " __u32 seclabel", " const struct trace_ctx *trace"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int encap_and_redirect_with_nodeid (struct  __ctx_buff *ctx, __u32 tunnel_endpoint, __u8 key __maybe_unused, __u32 seclabel, const struct trace_ctx *trace)\n", "{\n", "\n", "#ifdef ENABLE_IPSEC\n", "    if (key)\n", "        return encap_and_redirect_nomark_ipsec (ctx, tunnel_endpoint, key, seclabel);\n", "\n", "#endif\n", "    return __encap_and_redirect_with_nodeid (ctx, tunnel_endpoint, seclabel, NOT_VTEP_DST, trace);\n", "}\n"], "called_function_list": ["encap_and_redirect_nomark_ipsec", "__encap_and_redirect_with_nodeid"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "encap_and_redirect_lxc": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 197, "endLine": 242, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/encap.h", "funcName": "encap_and_redirect_lxc", "developer_inline_comments": [], "updateMaps": [], "readMaps": ["  TUNNEL_MAP"], "input": ["struct  __ctx_buff *ctx", " __u32 tunnel_endpoint", " __u8 encrypt_key __maybe_unused", " struct endpoint_key *key", " __u32 seclabel", " const struct trace_ctx *trace"], "output": "static__always_inlineint", "helper": ["map_lookup_elem"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int encap_and_redirect_lxc (struct  __ctx_buff *ctx, __u32 tunnel_endpoint, __u8 encrypt_key __maybe_unused, struct endpoint_key *key, __u32 seclabel, const struct trace_ctx *trace)\n", "{\n", "    struct endpoint_key *tunnel;\n", "    if (tunnel_endpoint) {\n", "\n", "#ifdef ENABLE_IPSEC\n", "        if (encrypt_key)\n", "            return encap_and_redirect_ipsec (ctx, tunnel_endpoint, encrypt_key, seclabel);\n", "\n", "#endif\n", "\n", "#if !defined(ENABLE_NODEPORT) && (defined(ENABLE_IPSEC) || defined(ENABLE_HOST_FIREWALL))\n", "        return __encap_with_nodeid (ctx, tunnel_endpoint, seclabel, NOT_VTEP_DST, trace->reason, trace->monitor);\n", "\n", "#else\n", "        return __encap_and_redirect_with_nodeid (ctx, tunnel_endpoint, seclabel, NOT_VTEP_DST, trace);\n", "\n", "#endif /* !ENABLE_NODEPORT && (ENABLE_IPSEC || ENABLE_HOST_FIREWALL) */\n", "    }\n", "    tunnel = map_lookup_elem (& TUNNEL_MAP, key);\n", "    if (!tunnel)\n", "        return DROP_NO_TUNNEL_ENDPOINT;\n", "\n", "#ifdef ENABLE_IPSEC\n", "    if (tunnel->key) {\n", "        __u8 min_encrypt_key = get_min_encrypt_key (tunnel -> key);\n", "        return encap_and_redirect_ipsec (ctx, tunnel->ip4, min_encrypt_key, seclabel);\n", "    }\n", "\n", "#endif\n", "    return __encap_and_redirect_with_nodeid (ctx, tunnel->ip4, seclabel, NOT_VTEP_DST, trace);\n", "}\n"], "called_function_list": ["__encap_and_redirect_with_nodeid", "encap_and_redirect_ipsec", "get_min_encrypt_key", "__encap_with_nodeid"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "encap_and_redirect_netdev": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 244, "endLine": 264, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/encap.h", "funcName": "encap_and_redirect_netdev", "developer_inline_comments": [], "updateMaps": [], "readMaps": ["  TUNNEL_MAP"], "input": ["struct  __ctx_buff *ctx", " struct endpoint_key *k", " __u32 seclabel", " const struct trace_ctx *trace"], "output": "static__always_inlineint", "helper": ["map_lookup_elem"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int encap_and_redirect_netdev (struct  __ctx_buff *ctx, struct endpoint_key *k, __u32 seclabel, const struct trace_ctx *trace)\n", "{\n", "    struct endpoint_key *tunnel;\n", "    tunnel = map_lookup_elem (& TUNNEL_MAP, k);\n", "    if (!tunnel)\n", "        return DROP_NO_TUNNEL_ENDPOINT;\n", "\n", "#ifdef ENABLE_IPSEC\n", "    if (tunnel->key) {\n", "        __u8 key = get_min_encrypt_key (tunnel -> key);\n", "        return encap_and_redirect_nomark_ipsec (ctx, tunnel->ip4, key, seclabel);\n", "    }\n", "\n", "#endif\n", "    return __encap_and_redirect_with_nodeid (ctx, tunnel->ip4, seclabel, NOT_VTEP_DST, trace);\n", "}\n"], "called_function_list": ["encap_and_redirect_nomark_ipsec", "__encap_and_redirect_with_nodeid", "get_min_encrypt_key"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "icmp6_load_type": [{"capabilities": [], "helperCallParams": {}, "startLine": 43, "endLine": 49, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/icmp6.h", "funcName": "icmp6_load_type", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " int nh_off"], "output": "static__always_inline__u8", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __u8 icmp6_load_type (struct  __ctx_buff *ctx, int nh_off)\n", "{\n", "    __u8 type;\n", "    ctx_load_bytes (ctx, nh_off + ICMP6_TYPE_OFFSET, &type, sizeof (type));\n", "    return type;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "icmp6_send_reply": [{"capabilities": [{"capability": "read_skb", "read_skb": [{"Project": "cilium", "Return Type": "s64", "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ", "Return": " The checksum result, or a negative error code in case of failure.", "Function Name": "csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp", "lwt_in", "lwt_out", "lwt_xmit", "lwt_seg6local"], "capabilities": ["read_skb"]}]}], "helperCallParams": {}, "startLine": 51, "endLine": 90, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/icmp6.h", "funcName": "icmp6_send_reply", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " int nh_off"], "output": "static__always_inlineint", "helper": ["csum_diff", "redirect"], "compatibleHookpoints": ["lwt_xmit", "sched_cls", "xdp", "sched_act"], "source": ["static __always_inline int icmp6_send_reply (struct  __ctx_buff *ctx, int nh_off)\n", "{\n", "    union macaddr smac, dmac = NODE_MAC;\n", "    const int csum_off = nh_off + ICMP6_CSUM_OFFSET;\n", "    union v6addr sip, dip, router_ip;\n", "    __be32 sum;\n", "    if (ipv6_load_saddr (ctx, nh_off, &sip) < 0 || ipv6_load_daddr (ctx, nh_off, &dip) < 0)\n", "        return DROP_INVALID;\n", "    BPF_V6 (router_ip, ROUTER_IP);\n", "    if (ipv6_store_saddr (ctx, router_ip.addr, nh_off) < 0)\n", "        return DROP_WRITE_ERROR;\n", "    if (ipv6_store_daddr (ctx, sip.addr, nh_off) < 0)\n", "        return DROP_WRITE_ERROR;\n", "    sum = csum_diff (sip.addr, 16, router_ip.addr, 16, 0);\n", "    if (l4_csum_replace (ctx, csum_off, 0, sum, BPF_F_PSEUDO_HDR) < 0)\n", "        return DROP_CSUM_L4;\n", "    sum = csum_diff (dip.addr, 16, sip.addr, 16, 0);\n", "    if (l4_csum_replace (ctx, csum_off, 0, sum, BPF_F_PSEUDO_HDR) < 0)\n", "        return DROP_CSUM_L4;\n", "    if (eth_load_saddr (ctx, smac.addr, 0) < 0)\n", "        return DROP_INVALID;\n", "    if (eth_store_daddr (ctx, smac.addr, 0) < 0 || eth_store_saddr (ctx, dmac.addr, 0) < 0)\n", "        return DROP_WRITE_ERROR;\n", "    cilium_dbg_capture (ctx, DBG_CAPTURE_DELIVERY, ctx_get_ifindex (ctx));\n", "    return redirect_self (ctx);\n", "}\n"], "called_function_list": ["ipv6_load_daddr", "ctx_get_ifindex", "eth_store_daddr", "eth_store_saddr", "ipv6_store_daddr", "ipv6_load_saddr", "cilium_dbg_capture", "ipv6_store_saddr", "eth_load_saddr", "redirect_self"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__icmp6_send_echo_reply": [{"capabilities": [{"capability": "read_skb", "read_skb": [{"Project": "cilium", "Return Type": "s64", "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ", "Return": " The checksum result, or a negative error code in case of failure.", "Function Name": "csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp", "lwt_in", "lwt_out", "lwt_xmit", "lwt_seg6local"], "capabilities": ["read_skb"]}]}], "helperCallParams": {}, "startLine": 92, "endLine": 125, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/icmp6.h", "funcName": "__icmp6_send_echo_reply", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " int nh_off"], "output": "static__always_inlineint", "helper": ["csum_diff"], "compatibleHookpoints": ["sched_cls", "lwt_xmit", "xdp", "lwt_in", "sched_act", "lwt_out", "lwt_seg6local"], "source": ["static __always_inline int __icmp6_send_echo_reply (struct  __ctx_buff *ctx, int nh_off)\n", "{\n", "    struct icmp6hdr icmp6hdr __align_stack_8 = {}, icmp6hdr_old  __align_stack_8;\n", "    int csum_off = nh_off + ICMP6_CSUM_OFFSET;\n", "    __be32 sum;\n", "    cilium_dbg (ctx, DBG_ICMP6_REQUEST, nh_off, 0);\n", "    if (ctx_load_bytes (ctx, nh_off + sizeof (struct ipv6hdr), &icmp6hdr_old, sizeof (icmp6hdr_old)) < 0)\n", "        return DROP_INVALID;\n", "    icmp6hdr.icmp6_type = 129;\n", "    icmp6hdr.icmp6_code = 0;\n", "    icmp6hdr.icmp6_cksum = icmp6hdr_old.icmp6_cksum;\n", "    icmp6hdr.icmp6_dataun.un_data32[0] = 0;\n", "    icmp6hdr.icmp6_identifier = icmp6hdr_old.icmp6_identifier;\n", "    icmp6hdr.icmp6_sequence = icmp6hdr_old.icmp6_sequence;\n", "    if (ctx_store_bytes (ctx, nh_off + sizeof (struct ipv6hdr), &icmp6hdr, sizeof (icmp6hdr), 0) < 0)\n", "        return DROP_WRITE_ERROR;\n", "    sum = csum_diff (& icmp6hdr_old, sizeof (icmp6hdr_old), & icmp6hdr, sizeof (icmp6hdr), 0);\n", "    if (l4_csum_replace (ctx, csum_off, 0, sum, BPF_F_PSEUDO_HDR) < 0)\n", "        return DROP_CSUM_L4;\n", "    return icmp6_send_reply (ctx, nh_off);\n", "}\n"], "called_function_list": ["cilium_dbg", "icmp6_send_reply"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "tail_icmp6_send_echo_reply": [{"capabilities": [], "helperCallParams": {}, "startLine": 129, "endLine": 139, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/icmp6.h", "funcName": "tail_icmp6_send_echo_reply", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx"], "output": "int", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["int tail_icmp6_send_echo_reply (struct  __ctx_buff *ctx)\n", "{\n", "    int ret, nh_off = ctx_load_meta (ctx, 0);\n", "    enum metric_dir direction = (enum metric_dir) ctx_load_meta (ctx, 1);\n", "    ctx_store_meta (ctx, 0, 0);\n", "    ret = __icmp6_send_echo_reply (ctx, nh_off);\n", "    if (IS_ERR (ret))\n", "        return send_drop_notify_error (ctx, 0, ret, CTX_ACT_DROP, direction);\n", "    return ret;\n", "}\n"], "called_function_list": ["__icmp6_send_echo_reply", "ctx_store_meta", "ctx_load_meta"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "icmp6_send_echo_reply": [{"capabilities": [], "helperCallParams": {}, "startLine": 151, "endLine": 160, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/icmp6.h", "funcName": "icmp6_send_echo_reply", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " int nh_off", " enum metric_dir direction"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int icmp6_send_echo_reply (struct  __ctx_buff *ctx, int nh_off, enum metric_dir direction)\n", "{\n", "    ctx_store_meta (ctx, 0, nh_off);\n", "    ctx_store_meta (ctx, 1, direction);\n", "    ep_tail_call (ctx, CILIUM_CALL_SEND_ICMP6_ECHO_REPLY);\n", "    return DROP_MISSED_TAIL_CALL;\n", "}\n"], "called_function_list": ["ctx_store_meta", "ep_tail_call"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "send_icmp6_ndisc_adv": [{"capabilities": [{"capability": "read_skb", "read_skb": [{"Project": "cilium", "Return Type": "s64", "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ", "Return": " The checksum result, or a negative error code in case of failure.", "Function Name": "csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp", "lwt_in", "lwt_out", "lwt_xmit", "lwt_seg6local"], "capabilities": ["read_skb"]}]}], "helperCallParams": {}, "startLine": 171, "endLine": 232, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/icmp6.h", "funcName": "send_icmp6_ndisc_adv", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " int nh_off", " union macaddr *mac", " bool to_router"], "output": "static__always_inlineint", "helper": ["csum_diff"], "compatibleHookpoints": ["sched_cls", "lwt_xmit", "xdp", "lwt_in", "sched_act", "lwt_out", "lwt_seg6local"], "source": ["static __always_inline int send_icmp6_ndisc_adv (struct  __ctx_buff *ctx, int nh_off, union macaddr *mac, bool to_router)\n", "{\n", "    struct icmp6hdr icmp6hdr __align_stack_8 = {}, icmp6hdr_old  __align_stack_8;\n", "    __u8 opts [8], opts_old [8];\n", "    const int csum_off = nh_off + ICMP6_CSUM_OFFSET;\n", "    __be32 sum;\n", "    if (ctx_load_bytes (ctx, nh_off + sizeof (struct ipv6hdr), &icmp6hdr_old, sizeof (icmp6hdr_old)) < 0)\n", "        return DROP_INVALID;\n", "    icmp6hdr.icmp6_type = 136;\n", "    icmp6hdr.icmp6_code = 0;\n", "    icmp6hdr.icmp6_cksum = icmp6hdr_old.icmp6_cksum;\n", "    icmp6hdr.icmp6_dataun.un_data32[0] = 0;\n", "    if (to_router) {\n", "        icmp6hdr.icmp6_router = 1;\n", "        icmp6hdr.icmp6_solicited = 1;\n", "        icmp6hdr.icmp6_override = 0;\n", "    }\n", "    else {\n", "        icmp6hdr.icmp6_router = 0;\n", "        icmp6hdr.icmp6_solicited = 1;\n", "        icmp6hdr.icmp6_override = 1;\n", "    }\n", "    if (ctx_store_bytes (ctx, nh_off + sizeof (struct ipv6hdr), &icmp6hdr, sizeof (icmp6hdr), 0) < 0)\n", "        return DROP_WRITE_ERROR;\n", "    sum = csum_diff (& icmp6hdr_old, sizeof (icmp6hdr_old), & icmp6hdr, sizeof (icmp6hdr), 0);\n", "    if (l4_csum_replace (ctx, csum_off, 0, sum, BPF_F_PSEUDO_HDR) < 0)\n", "        return DROP_CSUM_L4;\n", "    if (ctx_load_bytes (ctx, nh_off + ICMP6_ND_OPTS, opts_old, sizeof (opts_old)) < 0)\n", "        return DROP_INVALID;\n", "    opts[0] = 2;\n", "    opts[1] = 1;\n", "    opts[2] = mac->addr[0];\n", "    opts[3] = mac->addr[1];\n", "    opts[4] = mac->addr[2];\n", "    opts[5] = mac->addr[3];\n", "    opts[6] = mac->addr[4];\n", "    opts[7] = mac->addr[5];\n", "    if (ctx_store_bytes (ctx, nh_off + ICMP6_ND_OPTS, opts, sizeof (opts), 0) < 0)\n", "        return DROP_WRITE_ERROR;\n", "    sum = csum_diff (opts_old, sizeof (opts_old), opts, sizeof (opts), 0);\n", "    if (l4_csum_replace (ctx, csum_off, 0, sum, BPF_F_PSEUDO_HDR) < 0)\n", "        return DROP_CSUM_L4;\n", "    return icmp6_send_reply (ctx, nh_off);\n", "}\n"], "called_function_list": ["icmp6_send_reply"], "call_depth": 3, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "compute_icmp6_csum": [{"capabilities": [{"capability": "read_skb", "read_skb": [{"Project": "cilium", "Return Type": "s64", "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ", "Return": " The checksum result, or a negative error code in case of failure.", "Function Name": "csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp", "lwt_in", "lwt_out", "lwt_xmit", "lwt_seg6local"], "capabilities": ["read_skb"]}]}], "helperCallParams": {}, "startLine": 234, "endLine": 244, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/icmp6.h", "funcName": "compute_icmp6_csum", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["char data [80]", " __u16 payload_len", " struct ipv6hdr *ipv6hdr"], "output": "static__always_inline__be32", "helper": ["csum_diff"], "compatibleHookpoints": ["sched_cls", "lwt_xmit", "xdp", "lwt_in", "sched_act", "lwt_out", "lwt_seg6local"], "source": ["static __always_inline __be32 compute_icmp6_csum (char data [80], __u16 payload_len, struct ipv6hdr *ipv6hdr)\n", "{\n", "    __be32 sum;\n", "    sum = csum_diff (NULL, 0, data, payload_len, 0);\n", "    sum = ipv6_pseudohdr_checksum (ipv6hdr, IPPROTO_ICMPV6, payload_len, sum);\n", "    return sum;\n", "}\n"], "called_function_list": ["ipv6_pseudohdr_checksum"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__icmp6_send_time_exceeded": [{"capabilities": [], "helperCallParams": {}, "startLine": 247, "endLine": 327, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/icmp6.h", "funcName": "__icmp6_send_time_exceeded", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " int nh_off"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int __icmp6_send_time_exceeded (struct  __ctx_buff *ctx, int nh_off)\n", "{\n", "    char data [80] = {};\n", "    struct icmp6hdr *icmp6hoplim;\n", "    struct ipv6hdr *ipv6hdr;\n", "    char *upper;\n", "    const int csum_off = nh_off + ICMP6_CSUM_OFFSET;\n", "    __be32 sum = 0;\n", "    __u16 payload_len = 0;\n", "    __u8 icmp6_nexthdr = IPPROTO_ICMPV6;\n", "    int trimlen;\n", "    icmp6hoplim = (struct icmp6hdr *) data;\n", "    ipv6hdr = (struct ipv6hdr *) (data + 8);\n", "    upper = (data + 48);\n", "    icmp6hoplim->icmp6_type = 3;\n", "    icmp6hoplim->icmp6_code = 0;\n", "    icmp6hoplim->icmp6_cksum = 0;\n", "    icmp6hoplim->icmp6_dataun.un_data32[0] = 0;\n", "    cilium_dbg (ctx, DBG_ICMP6_TIME_EXCEEDED, 0, 0);\n", "    if (ctx_load_bytes (ctx, nh_off, ipv6hdr, sizeof (*ipv6hdr)) < 0)\n", "        return DROP_INVALID;\n", "    if (ipv6_store_nexthdr (ctx, &icmp6_nexthdr, nh_off) < 0)\n", "        return DROP_WRITE_ERROR;\n", "    switch (ipv6hdr->nexthdr) {\n", "    case IPPROTO_ICMPV6 :\n", "    case IPPROTO_UDP :\n", "        if (ctx_load_bytes (ctx, nh_off + sizeof (struct ipv6hdr), upper, 8) < 0)\n", "            return DROP_INVALID;\n", "        sum = compute_icmp6_csum (data, 56, ipv6hdr);\n", "        payload_len = bpf_htons (56);\n", "        trimlen = 56 - bpf_ntohs (ipv6hdr->payload_len);\n", "        if (ctx_change_tail (ctx, ctx_full_len (ctx) + trimlen, 0) < 0)\n", "            return DROP_WRITE_ERROR;\n", "        if (ctx_store_bytes (ctx, nh_off + sizeof (struct ipv6hdr), data, 56, 0) < 0)\n", "            return DROP_WRITE_ERROR;\n", "        if (ipv6_store_paylen (ctx, nh_off, &payload_len) < 0)\n", "            return DROP_WRITE_ERROR;\n", "        break;\n", "    case IPPROTO_TCP :\n", "        if (ctx_load_bytes (ctx, nh_off + sizeof (struct ipv6hdr), upper, 20) < 0)\n", "            return DROP_INVALID;\n", "        sum = compute_icmp6_csum (data, 68, ipv6hdr);\n", "        payload_len = bpf_htons (68);\n", "        trimlen = 68 - bpf_ntohs (ipv6hdr->payload_len);\n", "        if (ctx_change_tail (ctx, ctx_full_len (ctx) + trimlen, 0) < 0)\n", "            return DROP_WRITE_ERROR;\n", "        if (ctx_store_bytes (ctx, nh_off + sizeof (struct ipv6hdr), data, 68, 0) < 0)\n", "            return DROP_WRITE_ERROR;\n", "        if (ipv6_store_paylen (ctx, nh_off, &payload_len) < 0)\n", "            return DROP_WRITE_ERROR;\n", "        break;\n", "    default :\n", "        return DROP_UNKNOWN_L4;\n", "    }\n", "    if (l4_csum_replace (ctx, csum_off, 0, sum, BPF_F_PSEUDO_HDR) < 0)\n", "        return DROP_CSUM_L4;\n", "    return icmp6_send_reply (ctx, nh_off);\n", "}\n"], "called_function_list": ["icmp6_send_reply", "ipv6_store_nexthdr", "ctx_full_len", "ipv6_store_paylen", "compute_icmp6_csum", "cilium_dbg"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "tail_icmp6_send_time_exceeded": [{"capabilities": [], "helperCallParams": {}, "startLine": 332, "endLine": 347, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/icmp6.h", "funcName": "tail_icmp6_send_time_exceeded", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff * ctx __maybe_unused"], "output": "int", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["int tail_icmp6_send_time_exceeded (struct  __ctx_buff * ctx __maybe_unused)\n", "{\n", "\n", "# ifdef BPF_HAVE_CHANGE_TAIL\n", "    int ret, nh_off = ctx_load_meta (ctx, 0);\n", "    enum metric_dir direction = (enum metric_dir) ctx_load_meta (ctx, 1);\n", "    ctx_store_meta (ctx, 0, 0);\n", "    ret = __icmp6_send_time_exceeded (ctx, nh_off);\n", "    if (IS_ERR (ret))\n", "        return send_drop_notify_error (ctx, 0, ret, CTX_ACT_DROP, direction);\n", "    return ret;\n", "\n", "# else\n", "    return 0;\n", "\n", "# endif\n", "}\n"], "called_function_list": ["__icmp6_send_time_exceeded", "ctx_store_meta", "ctx_load_meta"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "icmp6_send_time_exceeded": [{"capabilities": [], "helperCallParams": {}, "startLine": 359, "endLine": 368, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/icmp6.h", "funcName": "icmp6_send_time_exceeded", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " int nh_off", " enum metric_dir direction"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int icmp6_send_time_exceeded (struct  __ctx_buff *ctx, int nh_off, enum metric_dir direction)\n", "{\n", "    ctx_store_meta (ctx, 0, nh_off);\n", "    ctx_store_meta (ctx, 1, direction);\n", "    ep_tail_call (ctx, CILIUM_CALL_SEND_ICMP6_TIME_EXCEEDED);\n", "    return DROP_MISSED_TAIL_CALL;\n", "}\n"], "called_function_list": ["ctx_store_meta", "ep_tail_call"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__icmp6_handle_ns": [{"capabilities": [], "helperCallParams": {}, "startLine": 370, "endLine": 398, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/icmp6.h", "funcName": "__icmp6_handle_ns", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " int nh_off"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int __icmp6_handle_ns (struct  __ctx_buff *ctx, int nh_off)\n", "{\n", "    union v6addr target, router;\n", "    struct endpoint_info *ep;\n", "    if (ctx_load_bytes (ctx, nh_off + ICMP6_ND_TARGET_OFFSET, target.addr, sizeof (((struct ipv6hdr *) NULL)->saddr)) < 0)\n", "        return DROP_INVALID;\n", "    cilium_dbg (ctx, DBG_ICMP6_NS, target.p3, target.p4);\n", "    BPF_V6 (router, ROUTER_IP);\n", "    if (ipv6_addrcmp (&target, &router) == 0) {\n", "        union macaddr router_mac = NODE_MAC;\n", "        return send_icmp6_ndisc_adv (ctx, nh_off, &router_mac, true);\n", "    }\n", "    ep = __lookup_ip6_endpoint (& target);\n", "    if (ep) {\n", "        union macaddr router_mac = NODE_MAC;\n", "        return send_icmp6_ndisc_adv (ctx, nh_off, &router_mac, false);\n", "    }\n", "    return ACTION_UNKNOWN_ICMP6_NS;\n", "}\n"], "called_function_list": ["send_icmp6_ndisc_adv", "ipv6_addrcmp", "cilium_dbg", "__lookup_ip6_endpoint"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "tail_icmp6_handle_ns": [{"capabilities": [], "helperCallParams": {}, "startLine": 402, "endLine": 412, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/icmp6.h", "funcName": "tail_icmp6_handle_ns", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx"], "output": "int", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["int tail_icmp6_handle_ns (struct  __ctx_buff *ctx)\n", "{\n", "    int ret, nh_off = ctx_load_meta (ctx, 0);\n", "    enum metric_dir direction = (enum metric_dir) ctx_load_meta (ctx, 1);\n", "    ctx_store_meta (ctx, 0, 0);\n", "    ret = __icmp6_handle_ns (ctx, nh_off);\n", "    if (IS_ERR (ret))\n", "        return send_drop_notify_error (ctx, 0, ret, CTX_ACT_DROP, direction);\n", "    return ret;\n", "}\n"], "called_function_list": ["ctx_store_meta", "ctx_load_meta", "__icmp6_handle_ns"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "icmp6_handle_ns": [{"capabilities": [], "helperCallParams": {}, "startLine": 425, "endLine": 434, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/icmp6.h", "funcName": "icmp6_handle_ns", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " int nh_off", " enum metric_dir direction"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int icmp6_handle_ns (struct  __ctx_buff *ctx, int nh_off, enum metric_dir direction)\n", "{\n", "    ctx_store_meta (ctx, 0, nh_off);\n", "    ctx_store_meta (ctx, 1, direction);\n", "    ep_tail_call (ctx, CILIUM_CALL_HANDLE_ICMP6_NS);\n", "    return DROP_MISSED_TAIL_CALL;\n", "}\n"], "called_function_list": ["ctx_store_meta", "ep_tail_call"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "icmp6_handle": [{"capabilities": [], "helperCallParams": {}, "startLine": 436, "endLine": 458, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/icmp6.h", "funcName": "icmp6_handle", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " int nh_off", " struct ipv6hdr *ip6", " enum metric_dir direction"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int icmp6_handle (struct  __ctx_buff *ctx, int nh_off, struct ipv6hdr *ip6, enum metric_dir direction)\n", "{\n", "    union v6addr router_ip;\n", "    __u8 type = icmp6_load_type (ctx, nh_off);\n", "    cilium_dbg (ctx, DBG_ICMP6_HANDLE, type, 0);\n", "    BPF_V6 (router_ip, ROUTER_IP);\n", "    switch (type) {\n", "    case ICMP6_NS_MSG_TYPE :\n", "        return icmp6_handle_ns (ctx, nh_off, direction);\n", "    case ICMPV6_ECHO_REQUEST :\n", "        if (!ipv6_addrcmp ((union v6addr *) &ip6->daddr, &router_ip))\n", "            return icmp6_send_echo_reply (ctx, nh_off, direction);\n", "        break;\n", "    }\n", "    return 0;\n", "}\n"], "called_function_list": ["icmp6_handle_ns", "icmp6_send_echo_reply", "icmp6_load_type", "ipv6_addrcmp", "cilium_dbg"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "icmp6_host_handle": [{"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 460, "endLine": 531, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/icmp6.h", "funcName": "icmp6_host_handle", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff * ctx __maybe_unused"], "output": "static__always_inlineint", "helper": ["CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["static __always_inline int icmp6_host_handle (struct  __ctx_buff * ctx __maybe_unused)\n", "{\n", "    __u8 type __maybe_unused;\n", "    type = icmp6_load_type (ctx, ETH_HLEN);\n", "    if (type == ICMP6_NS_MSG_TYPE)\n", "        return icmp6_handle_ns (ctx, ETH_HLEN, METRIC_INGRESS);\n", "\n", "#ifdef ENABLE_HOST_FIREWALL\n", "    if (type == ICMP6_ECHO_REQUEST_MSG_TYPE || type == ICMP6_ECHO_REPLY_MSG_TYPE)\n", "        return CTX_ACT_OK;\n", "    if ((ICMP6_UNREACH_MSG_TYPE <= type && type <= ICMP6_PARAM_ERR_MSG_TYPE) || (ICMP6_MULT_LIST_QUERY_TYPE <= type && type <= ICMP6_NA_MSG_TYPE) || (ICMP6_INV_NS_MSG_TYPE <= type && type <= ICMP6_MULT_LIST_REPORT_V2_TYPE) || (ICMP6_SEND_NS_MSG_TYPE <= type && type <= ICMP6_SEND_NA_MSG_TYPE) || (ICMP6_MULT_RA_MSG_TYPE <= type && type <= ICMP6_MULT_RT_MSG_TYPE))\n", "        return SKIP_HOST_FIREWALL;\n", "    return DROP_FORBIDDEN_ICMP6;\n", "\n", "#else\n", "    return CTX_ACT_OK;\n", "\n", "#endif /* ENABLE_HOST_FIREWALL */\n", "}\n"], "called_function_list": ["icmp6_handle_ns", "icmp6_load_type"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "lb4_svc_is_loadbalancer": [{"capabilities": [], "helperCallParams": {}, "startLine": 192, "endLine": 196, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "lb4_svc_is_loadbalancer", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct lb4_service * svc __maybe_unused"], "output": "static__always_inlinebool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline bool lb4_svc_is_loadbalancer (const struct lb4_service * svc __maybe_unused)\n", "{\n", "    return svc->flags & SVC_FLAG_LOADBALANCER;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "lb6_svc_is_loadbalancer": [{"capabilities": [], "helperCallParams": {}, "startLine": 198, "endLine": 202, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "lb6_svc_is_loadbalancer", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct lb6_service * svc __maybe_unused"], "output": "static__always_inlinebool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline bool lb6_svc_is_loadbalancer (const struct lb6_service * svc __maybe_unused)\n", "{\n", "    return svc->flags & SVC_FLAG_LOADBALANCER;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "lb4_svc_is_nodeport": [{"capabilities": [], "helperCallParams": {}, "startLine": 204, "endLine": 212, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "lb4_svc_is_nodeport", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct lb4_service * svc __maybe_unused"], "output": "static__always_inlinebool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline bool lb4_svc_is_nodeport (const struct lb4_service * svc __maybe_unused)\n", "{\n", "\n", "#ifdef ENABLE_NODEPORT\n", "    return svc->flags & SVC_FLAG_NODEPORT;\n", "\n", "#else\n", "    return false;\n", "\n", "#endif /* ENABLE_NODEPORT */\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "lb6_svc_is_nodeport": [{"capabilities": [], "helperCallParams": {}, "startLine": 214, "endLine": 222, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "lb6_svc_is_nodeport", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct lb6_service * svc __maybe_unused"], "output": "static__always_inlinebool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline bool lb6_svc_is_nodeport (const struct lb6_service * svc __maybe_unused)\n", "{\n", "\n", "#ifdef ENABLE_NODEPORT\n", "    return svc->flags & SVC_FLAG_NODEPORT;\n", "\n", "#else\n", "    return false;\n", "\n", "#endif /* ENABLE_NODEPORT */\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "lb4_svc_is_external_ip": [{"capabilities": [], "helperCallParams": {}, "startLine": 224, "endLine": 228, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "lb4_svc_is_external_ip", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct lb4_service * svc __maybe_unused"], "output": "static__always_inlinebool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline bool lb4_svc_is_external_ip (const struct lb4_service * svc __maybe_unused)\n", "{\n", "    return svc->flags & SVC_FLAG_EXTERNAL_IP;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "lb6_svc_is_external_ip": [{"capabilities": [], "helperCallParams": {}, "startLine": 230, "endLine": 234, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "lb6_svc_is_external_ip", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct lb6_service * svc __maybe_unused"], "output": "static__always_inlinebool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline bool lb6_svc_is_external_ip (const struct lb6_service * svc __maybe_unused)\n", "{\n", "    return svc->flags & SVC_FLAG_EXTERNAL_IP;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "lb4_svc_is_hostport": [{"capabilities": [], "helperCallParams": {}, "startLine": 236, "endLine": 240, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "lb4_svc_is_hostport", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct lb4_service * svc __maybe_unused"], "output": "static__always_inlinebool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline bool lb4_svc_is_hostport (const struct lb4_service * svc __maybe_unused)\n", "{\n", "    return svc->flags & SVC_FLAG_HOSTPORT;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "lb6_svc_is_hostport": [{"capabilities": [], "helperCallParams": {}, "startLine": 242, "endLine": 246, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "lb6_svc_is_hostport", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct lb6_service * svc __maybe_unused"], "output": "static__always_inlinebool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline bool lb6_svc_is_hostport (const struct lb6_service * svc __maybe_unused)\n", "{\n", "    return svc->flags & SVC_FLAG_HOSTPORT;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "lb4_svc_has_src_range_check": [{"capabilities": [], "helperCallParams": {}, "startLine": 248, "endLine": 256, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "lb4_svc_has_src_range_check", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct lb4_service * svc __maybe_unused"], "output": "static__always_inlinebool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline bool lb4_svc_has_src_range_check (const struct lb4_service * svc __maybe_unused)\n", "{\n", "\n", "#ifdef ENABLE_SRC_RANGE_CHECK\n", "    return svc->flags & SVC_FLAG_SOURCE_RANGE;\n", "\n", "#else\n", "    return false;\n", "\n", "#endif /* ENABLE_SRC_RANGE_CHECK */\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "lb6_svc_has_src_range_check": [{"capabilities": [], "helperCallParams": {}, "startLine": 258, "endLine": 266, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "lb6_svc_has_src_range_check", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct lb6_service * svc __maybe_unused"], "output": "static__always_inlinebool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline bool lb6_svc_has_src_range_check (const struct lb6_service * svc __maybe_unused)\n", "{\n", "\n", "#ifdef ENABLE_SRC_RANGE_CHECK\n", "    return svc->flags & SVC_FLAG_SOURCE_RANGE;\n", "\n", "#else\n", "    return false;\n", "\n", "#endif /* ENABLE_SRC_RANGE_CHECK */\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "lb_skip_l4_dnat": [{"capabilities": [], "helperCallParams": {}, "startLine": 268, "endLine": 271, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "lb_skip_l4_dnat", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["void"], "output": "static__always_inlinebool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline bool lb_skip_l4_dnat (void)\n", "{\n", "    return DSR_XLATE_MODE == DSR_XLATE_FRONTEND;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "lb4_svc_is_local_scope": [{"capabilities": [], "helperCallParams": {}, "startLine": 273, "endLine": 277, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "lb4_svc_is_local_scope", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct lb4_service *svc"], "output": "static__always_inlinebool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline bool lb4_svc_is_local_scope (const struct lb4_service *svc)\n", "{\n", "    return svc->flags & SVC_FLAG_LOCAL_SCOPE;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "lb6_svc_is_local_scope": [{"capabilities": [], "helperCallParams": {}, "startLine": 279, "endLine": 283, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "lb6_svc_is_local_scope", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct lb6_service *svc"], "output": "static__always_inlinebool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline bool lb6_svc_is_local_scope (const struct lb6_service *svc)\n", "{\n", "    return svc->flags & SVC_FLAG_LOCAL_SCOPE;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "lb4_svc_is_affinity": [{"capabilities": [], "helperCallParams": {}, "startLine": 285, "endLine": 289, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "lb4_svc_is_affinity", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct lb4_service *svc"], "output": "static__always_inlinebool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline bool lb4_svc_is_affinity (const struct lb4_service *svc)\n", "{\n", "    return svc->flags & SVC_FLAG_AFFINITY;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "lb6_svc_is_affinity": [{"capabilities": [], "helperCallParams": {}, "startLine": 291, "endLine": 295, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "lb6_svc_is_affinity", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct lb6_service *svc"], "output": "static__always_inlinebool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline bool lb6_svc_is_affinity (const struct lb6_service *svc)\n", "{\n", "    return svc->flags & SVC_FLAG_AFFINITY;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__lb_svc_is_routable": [{"capabilities": [], "helperCallParams": {}, "startLine": 297, "endLine": 300, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "__lb_svc_is_routable", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["__u8 flags"], "output": "static__always_inlinebool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline bool __lb_svc_is_routable (__u8 flags)\n", "{\n", "    return (flags & SVC_FLAG_ROUTABLE) != 0;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "lb4_svc_is_routable": [{"capabilities": [], "helperCallParams": {}, "startLine": 302, "endLine": 306, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "lb4_svc_is_routable", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct lb4_service *svc"], "output": "static__always_inlinebool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline bool lb4_svc_is_routable (const struct lb4_service *svc)\n", "{\n", "    return __lb_svc_is_routable (svc->flags);\n", "}\n"], "called_function_list": ["__lb_svc_is_routable"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "lb6_svc_is_routable": [{"capabilities": [], "helperCallParams": {}, "startLine": 308, "endLine": 312, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "lb6_svc_is_routable", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct lb6_service *svc"], "output": "static__always_inlinebool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline bool lb6_svc_is_routable (const struct lb6_service *svc)\n", "{\n", "    return __lb_svc_is_routable (svc->flags);\n", "}\n"], "called_function_list": ["__lb_svc_is_routable"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "lb4_svc_is_localredirect": [{"capabilities": [], "helperCallParams": {}, "startLine": 314, "endLine": 318, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "lb4_svc_is_localredirect", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct lb4_service *svc"], "output": "static__always_inlinebool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline bool lb4_svc_is_localredirect (const struct lb4_service *svc)\n", "{\n", "    return svc->flags2 & SVC_FLAG_LOCALREDIRECT;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "lb4_svc_is_l7loadbalancer": [{"capabilities": [], "helperCallParams": {}, "startLine": 320, "endLine": 328, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "lb4_svc_is_l7loadbalancer", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct lb4_service * svc __maybe_unused"], "output": "static__always_inlinebool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline bool lb4_svc_is_l7loadbalancer (const struct lb4_service * svc __maybe_unused)\n", "{\n", "\n", "#ifdef ENABLE_L7_LB\n", "    return svc->flags2 & SVC_FLAG_L7LOADBALANCER;\n", "\n", "#else\n", "    return false;\n", "\n", "#endif\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "lb6_svc_is_l7loadbalancer": [{"capabilities": [], "helperCallParams": {}, "startLine": 330, "endLine": 338, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "lb6_svc_is_l7loadbalancer", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct lb6_service * svc __maybe_unused"], "output": "static__always_inlinebool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline bool lb6_svc_is_l7loadbalancer (const struct lb6_service * svc __maybe_unused)\n", "{\n", "\n", "#ifdef ENABLE_L7_LB\n", "    return svc->flags2 & SVC_FLAG_L7LOADBALANCER;\n", "\n", "#else\n", "    return false;\n", "\n", "#endif\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "extract_l4_port": [{"capabilities": [], "helperCallParams": {}, "startLine": 340, "endLine": 380, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "extract_l4_port", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " __u8 nexthdr", " int l4_off", " enum ct_dir dir __maybe_unused", " __be16 *port", " __maybe_unused struct iphdr *ip4"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int extract_l4_port (struct  __ctx_buff *ctx, __u8 nexthdr, int l4_off, enum ct_dir dir __maybe_unused, __be16 *port, __maybe_unused struct iphdr *ip4)\n", "{\n", "    int ret;\n", "    switch (nexthdr) {\n", "    case IPPROTO_TCP :\n", "    case IPPROTO_UDP :\n", "\n", "#ifdef ENABLE_IPV4_FRAGMENTS\n", "        if (ip4) {\n", "            struct ipv4_frag_l4ports ports = {}\n", "            ;\n", "            ret = ipv4_handle_fragmentation (ctx, ip4, l4_off, dir, & ports, NULL);\n", "            if (IS_ERR (ret))\n", "                return ret;\n", "            *port = ports.dport;\n", "            break;\n", "        }\n", "\n", "#endif\n", "        ret = l4_load_port (ctx, l4_off + TCP_DPORT_OFF, port);\n", "        if (IS_ERR (ret))\n", "            return ret;\n", "        break;\n", "    case IPPROTO_ICMPV6 :\n", "    case IPPROTO_ICMP :\n", "        return DROP_NO_SERVICE;\n", "    default :\n", "        return DROP_UNKNOWN_L4;\n", "    }\n", "    return 0;\n", "}\n"], "called_function_list": ["ipv4_handle_fragmentation", "l4_load_port"], "call_depth": 5, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "reverse_map_l4_port": [{"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 382, "endLine": 416, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "reverse_map_l4_port", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " __u8 nexthdr", " __be16 port", " int l4_off", " struct csum_offset *csum_off"], "output": "static__always_inlineint", "helper": ["CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["static __always_inline int reverse_map_l4_port (struct  __ctx_buff *ctx, __u8 nexthdr, __be16 port, int l4_off, struct csum_offset *csum_off)\n", "{\n", "    switch (nexthdr) {\n", "    case IPPROTO_TCP :\n", "    case IPPROTO_UDP :\n", "        if (port) {\n", "            __be16 old_port;\n", "            int ret;\n", "            ret = l4_load_port (ctx, l4_off + TCP_SPORT_OFF, & old_port);\n", "            if (IS_ERR (ret))\n", "                return ret;\n", "            if (port != old_port) {\n", "                ret = l4_modify_port (ctx, l4_off, TCP_SPORT_OFF, csum_off, port, old_port);\n", "                if (IS_ERR (ret))\n", "                    return ret;\n", "            }\n", "        }\n", "        break;\n", "    case IPPROTO_ICMPV6 :\n", "    case IPPROTO_ICMP :\n", "        return CTX_ACT_OK;\n", "    default :\n", "        return DROP_UNKNOWN_L4;\n", "    }\n", "    return 0;\n", "}\n"], "called_function_list": ["l4_modify_port", "l4_load_port"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__lb6_rev_nat": [{"capabilities": [{"capability": "read_skb", "read_skb": [{"Project": "cilium", "Return Type": "s64", "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ", "Return": " The checksum result, or a negative error code in case of failure.", "Function Name": "csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp", "lwt_in", "lwt_out", "lwt_xmit", "lwt_seg6local"], "capabilities": ["read_skb"]}]}], "helperCallParams": {}, "startLine": 419, "endLine": 459, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "__lb6_rev_nat", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " int l4_off", " struct csum_offset *csum_off", " struct ipv6_ct_tuple *tuple", " int flags", " struct lb6_reverse_nat *nat"], "output": "static__always_inlineint", "helper": ["csum_diff"], "compatibleHookpoints": ["sched_cls", "lwt_xmit", "xdp", "lwt_in", "sched_act", "lwt_out", "lwt_seg6local"], "source": ["static __always_inline int __lb6_rev_nat (struct  __ctx_buff *ctx, int l4_off, struct csum_offset *csum_off, struct ipv6_ct_tuple *tuple, int flags, struct lb6_reverse_nat *nat)\n", "{\n", "    union v6addr old_saddr;\n", "    union v6addr tmp;\n", "    __u8 *new_saddr;\n", "    __be32 sum;\n", "    int ret;\n", "    cilium_dbg_lb (ctx, DBG_LB6_REVERSE_NAT, nat->address.p4, nat->port);\n", "    if (nat->port) {\n", "        ret = reverse_map_l4_port (ctx, tuple -> nexthdr, nat -> port, l4_off, csum_off);\n", "        if (IS_ERR (ret))\n", "            return ret;\n", "    }\n", "    if (flags & REV_NAT_F_TUPLE_SADDR) {\n", "        ipv6_addr_copy (&old_saddr, &tuple->saddr);\n", "        ipv6_addr_copy (&tuple->saddr, &nat->address);\n", "        new_saddr = tuple->saddr.addr;\n", "    }\n", "    else {\n", "        if (ipv6_load_saddr (ctx, ETH_HLEN, &old_saddr) < 0)\n", "            return DROP_INVALID;\n", "        ipv6_addr_copy (&tmp, &nat->address);\n", "        new_saddr = tmp.addr;\n", "    }\n", "    ret = ipv6_store_saddr (ctx, new_saddr, ETH_HLEN);\n", "    if (IS_ERR (ret))\n", "        return DROP_WRITE_ERROR;\n", "    sum = csum_diff (old_saddr.addr, 16, new_saddr, 16, 0);\n", "    if (csum_l4_replace (ctx, l4_off, csum_off, 0, sum, BPF_F_PSEUDO_HDR) < 0)\n", "        return DROP_CSUM_L4;\n", "    return 0;\n", "}\n"], "called_function_list": ["ipv6_load_saddr", "ipv6_addr_copy", "csum_l4_replace", "ipv6_store_saddr", "reverse_map_l4_port"], "call_depth": 3, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "lb6_rev_nat": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 470, "endLine": 482, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "lb6_rev_nat", "developer_inline_comments": [], "updateMaps": [], "readMaps": ["  LB6_REVERSE_NAT_MAP"], "input": ["struct  __ctx_buff *ctx", " int l4_off", " struct csum_offset *csum_off", " __u16 index", " struct ipv6_ct_tuple *tuple", " int flags"], "output": "static__always_inlineint", "helper": ["map_lookup_elem"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int lb6_rev_nat (struct  __ctx_buff *ctx, int l4_off, struct csum_offset *csum_off, __u16 index, struct ipv6_ct_tuple *tuple, int flags)\n", "{\n", "    struct lb6_reverse_nat *nat;\n", "    cilium_dbg_lb (ctx, DBG_LB6_REVERSE_NAT_LOOKUP, index, 0);\n", "    nat = map_lookup_elem (& LB6_REVERSE_NAT_MAP, & index);\n", "    if (nat == NULL)\n", "        return 0;\n", "    return __lb6_rev_nat (ctx, l4_off, csum_off, tuple, flags, nat);\n", "}\n"], "called_function_list": ["__lb6_rev_nat"], "call_depth": 4, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "lb6_extract_key": [{"capabilities": [], "helperCallParams": {}, "startLine": 500, "endLine": 516, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "lb6_extract_key", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff * ctx __maybe_unused", " struct ipv6_ct_tuple *tuple", " int l4_off __maybe_unused", " struct lb6_key *key", " struct csum_offset *csum_off", " enum ct_dir dir"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int lb6_extract_key (struct  __ctx_buff * ctx __maybe_unused, struct ipv6_ct_tuple *tuple, int l4_off __maybe_unused, struct lb6_key *key, struct csum_offset *csum_off, enum ct_dir dir)\n", "{\n", "    union v6addr *addr;\n", "    key->proto = 0;\n", "    addr = (dir == CT_INGRESS) ? &tuple->saddr : &tuple->daddr;\n", "    ipv6_addr_copy (&key->address, addr);\n", "    csum_l4_offset_and_flags (tuple->nexthdr, csum_off);\n", "    return extract_l4_port (ctx, tuple->nexthdr, l4_off, dir, &key->dport, NULL);\n", "}\n"], "called_function_list": ["extract_l4_port", "ipv6_addr_copy", "csum_l4_offset_and_flags"], "call_depth": 6, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "lb6_src_range_ok": [{"capabilities": [], "helperCallParams": {}, "startLine": 518, "endLine": 541, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "lb6_src_range_ok", "developer_inline_comments": [], "updateMaps": [], "readMaps": [" LB6_SRC_RANGE_MAP"], "input": ["const struct lb6_service * svc __maybe_unused", " const union v6addr * saddr __maybe_unused"], "output": "static__always_inlinebool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline bool lb6_src_range_ok (const struct lb6_service * svc __maybe_unused, const union v6addr * saddr __maybe_unused)\n", "{\n", "\n", "#ifdef ENABLE_SRC_RANGE_CHECK\n", "    struct lb6_src_range_key key;\n", "    if (!lb6_svc_has_src_range_check (svc))\n", "        return true;\n", "    key = (typeof (key)) {\n", "        .lpm_key = {SRC_RANGE_STATIC_PREFIX (key),\n", "            {}},\n", "        .rev_nat_id = svc->rev_nat_index,\n", "        .addr = *saddr,};\n", "    if (map_lookup_elem (&LB6_SRC_RANGE_MAP, &key))\n", "        return true;\n", "    return false;\n", "\n", "#else\n", "    return true;\n", "\n", "#endif /* ENABLE_SRC_RANGE_CHECK */\n", "}\n"], "called_function_list": ["lb6_svc_has_src_range_check"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "lb6_to_lb4_service": [{"capabilities": [], "helperCallParams": {}, "startLine": 543, "endLine": 551, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "lb6_to_lb4_service", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct lb6_service * svc __maybe_unused"], "output": "static__always_inlinebool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline bool lb6_to_lb4_service (const struct lb6_service * svc __maybe_unused)\n", "{\n", "\n", "#ifdef ENABLE_NAT_46X64\n", "    return svc->flags2 & SVC_FLAG_NAT_46X64;\n", "\n", "#else\n", "    return false;\n", "\n", "#endif\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 991, "endLine": 995, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "lb6_to_lb4_service", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct lb6_service * svc __maybe_unused"], "output": "static__always_inlinebool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline bool lb6_to_lb4_service (const struct lb6_service * svc __maybe_unused)\n", "{\n", "    return false;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "lb6_lookup_service": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 553, "endLine": 573, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "lb6_lookup_service", "developer_inline_comments": [], "updateMaps": [], "readMaps": ["  LB6_SERVICES_MAP_V2"], "input": ["struct lb6_key *key", " const bool scope_switch"], "output": "static__always_inlinestructlb6_service", "helper": ["map_lookup_elem"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline struct lb6_service *lb6_lookup_service (struct lb6_key *key, const bool scope_switch)\n", "{\n", "    struct lb6_service *svc;\n", "    key->scope = LB_LOOKUP_SCOPE_EXT;\n", "    key->backend_slot = 0;\n", "    svc = map_lookup_elem (& LB6_SERVICES_MAP_V2, key);\n", "    if (svc) {\n", "        if (!scope_switch || !lb6_svc_is_local_scope (svc))\n", "            return (svc->count || lb6_svc_is_l7loadbalancer (svc)) ? svc : NULL;\n", "        key->scope = LB_LOOKUP_SCOPE_INT;\n", "        svc = map_lookup_elem (& LB6_SERVICES_MAP_V2, key);\n", "        if (svc && (svc->count || lb6_svc_is_l7loadbalancer (svc)))\n", "            return svc;\n", "    }\n", "    return NULL;\n", "}\n"], "called_function_list": ["lb6_svc_is_local_scope", "lb6_svc_is_l7loadbalancer"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 972, "endLine": 977, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "lb6_lookup_service", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct lb6_key * key __maybe_unused", " const bool scope_switch __maybe_unused"], "output": "static__always_inlinestructlb6_service", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline struct lb6_service *lb6_lookup_service (struct lb6_key * key __maybe_unused, const bool scope_switch __maybe_unused)\n", "{\n", "    return NULL;\n", "}\n"], "called_function_list": ["lb6_svc_is_local_scope", "lb6_svc_is_l7loadbalancer"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__lb6_lookup_backend": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 575, "endLine": 578, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "__lb6_lookup_backend", "developer_inline_comments": [], "updateMaps": [], "readMaps": [" LB6_BACKEND_MAP_V2"], "input": ["__u32 backend_id"], "output": "static__always_inlinestructlb6_backend", "helper": ["map_lookup_elem"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline struct lb6_backend *__lb6_lookup_backend (__u32 backend_id)\n", "{\n", "    return map_lookup_elem (&LB6_BACKEND_MAP_V2, &backend_id);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 985, "endLine": 989, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "__lb6_lookup_backend", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["__u16 backend_id __maybe_unused"], "output": "static__always_inlinestructlb6_backend", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline struct lb6_backend *__lb6_lookup_backend (__u16 backend_id __maybe_unused)\n", "{\n", "    return NULL;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "lb6_lookup_backend": [{"capabilities": [], "helperCallParams": {}, "startLine": 580, "endLine": 590, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "lb6_lookup_backend", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff * ctx __maybe_unused", " __u32 backend_id"], "output": "static__always_inlinestructlb6_backend", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline struct lb6_backend *lb6_lookup_backend (struct  __ctx_buff * ctx __maybe_unused, __u32 backend_id)\n", "{\n", "    struct lb6_backend *backend;\n", "    backend = __lb6_lookup_backend (backend_id);\n", "    if (!backend)\n", "        cilium_dbg_lb (ctx, DBG_LB6_LOOKUP_BACKEND_FAIL, backend_id, 0);\n", "    return backend;\n", "}\n"], "called_function_list": ["__lb6_lookup_backend"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__lb6_lookup_backend_slot": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 592, "endLine": 596, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "__lb6_lookup_backend_slot", "developer_inline_comments": [], "updateMaps": [], "readMaps": [" LB6_SERVICES_MAP_V2"], "input": ["struct lb6_key *key"], "output": "static__always_inlinestructlb6_service", "helper": ["map_lookup_elem"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline struct lb6_service *__lb6_lookup_backend_slot (struct lb6_key *key)\n", "{\n", "    return map_lookup_elem (&LB6_SERVICES_MAP_V2, key);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 979, "endLine": 983, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "__lb6_lookup_backend_slot", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct lb6_key * key __maybe_unused"], "output": "static__always_inlinestructlb6_service", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline struct lb6_service *__lb6_lookup_backend_slot (struct lb6_key * key __maybe_unused)\n", "{\n", "    return NULL;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "lb6_lookup_backend_slot": [{"capabilities": [], "helperCallParams": {}, "startLine": 598, "endLine": 613, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "lb6_lookup_backend_slot", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff * ctx __maybe_unused", " struct lb6_key *key", " __u16 slot"], "output": "static__always_inlinestructlb6_service", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline struct lb6_service *lb6_lookup_backend_slot (struct  __ctx_buff * ctx __maybe_unused, struct lb6_key *key, __u16 slot)\n", "{\n", "    struct lb6_service *svc;\n", "    key->backend_slot = slot;\n", "    cilium_dbg_lb (ctx, DBG_LB6_LOOKUP_BACKEND_SLOT, key->backend_slot, key->dport);\n", "    svc = __lb6_lookup_backend_slot (key);\n", "    if (svc)\n", "        return svc;\n", "    cilium_dbg_lb (ctx, DBG_LB6_LOOKUP_BACKEND_SLOT_V2_FAIL, key->backend_slot, key->dport);\n", "    return NULL;\n", "}\n"], "called_function_list": ["__lb6_lookup_backend_slot"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "lb6_select_backend_id": [{"capabilities": [], "helperCallParams": {}, "startLine": 617, "endLine": 627, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "lb6_select_backend_id", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " struct lb6_key *key", " const struct ipv6_ct_tuple * tuple __maybe_unused", " const struct lb6_service *svc"], "output": "static__always_inline__u32", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __u32 lb6_select_backend_id (struct  __ctx_buff *ctx, struct lb6_key *key, const struct ipv6_ct_tuple * tuple __maybe_unused, const struct lb6_service *svc)\n", "{\n", "    __u16 slot = (get_prandom_u32 () % svc->count) + 1;\n", "    struct lb6_service *be = lb6_lookup_backend_slot (ctx, key, slot);\n", "    return be ? be->backend_id : 0;\n", "}\n"], "called_function_list": ["lb6_lookup_backend_slot", "hash_from_tuple_v6", "map_array_get_32"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 629, "endLine": 649, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "lb6_select_backend_id", "developer_inline_comments": [], "updateMaps": [], "readMaps": [" maglev_lut", "  LB6_MAGLEV_MAP_OUTER"], "input": ["struct  __ctx_buff * ctx __maybe_unused", " struct lb6_key * key __maybe_unused", " const struct ipv6_ct_tuple *tuple", " const struct lb6_service *svc"], "output": "static__always_inline__u32", "helper": ["map_lookup_elem"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __u32 lb6_select_backend_id (struct  __ctx_buff * ctx __maybe_unused, struct lb6_key * key __maybe_unused, const struct ipv6_ct_tuple *tuple, const struct lb6_service *svc)\n", "{\n", "    __u32 zero = 0, index = svc->rev_nat_index;\n", "    __u32 *backend_ids;\n", "    void *maglev_lut;\n", "    maglev_lut = map_lookup_elem (& LB6_MAGLEV_MAP_OUTER, & index);\n", "    if (unlikely (!maglev_lut))\n", "        return 0;\n", "    backend_ids = map_lookup_elem (maglev_lut, & zero);\n", "    if (unlikely (!backend_ids))\n", "        return 0;\n", "    index = hash_from_tuple_v6 (tuple) % LB_MAGLEV_LUT_SIZE;\n", "    return map_array_get_32 (backend_ids, index, (LB_MAGLEV_LUT_SIZE - 1) << 2);\n", "}\n"], "called_function_list": ["lb6_lookup_backend_slot", "hash_from_tuple_v6", "map_array_get_32"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "lb6_xlate": [{"capabilities": [{"capability": "read_skb", "read_skb": [{"Project": "cilium", "Return Type": "s64", "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ", "Return": " The checksum result, or a negative error code in case of failure.", "Function Name": "csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp", "lwt_in", "lwt_out", "lwt_xmit", "lwt_seg6local"], "capabilities": ["read_skb"]}]}, {"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 654, "endLine": 689, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "lb6_xlate", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " const union v6addr *new_dst", " __u8 nexthdr", " int l3_off", " int l4_off", " struct csum_offset *csum_off", " const struct lb6_key *key", " const struct lb6_backend *backend", " const bool skip_l3_xlate"], "output": "static__always_inlineint", "helper": ["csum_diff", "CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["static __always_inline int lb6_xlate (struct  __ctx_buff *ctx, const union v6addr *new_dst, __u8 nexthdr, int l3_off, int l4_off, struct csum_offset *csum_off, const struct lb6_key *key, const struct lb6_backend *backend, const bool skip_l3_xlate)\n", "{\n", "    if (skip_l3_xlate)\n", "        goto l4_xlate;\n", "    ipv6_store_daddr (ctx, new_dst->addr, l3_off);\n", "    if (csum_off) {\n", "        __be32 sum = csum_diff (key -> address.addr, 16, new_dst -> addr, 16, 0);\n", "        if (csum_l4_replace (ctx, l4_off, csum_off, 0, sum, BPF_F_PSEUDO_HDR) < 0)\n", "            return DROP_CSUM_L4;\n", "    }\n", "l4_xlate :\n", "    if (likely (backend->port) && key->dport != backend->port && (nexthdr == IPPROTO_TCP || nexthdr == IPPROTO_UDP)) {\n", "        __be16 tmp = backend->port;\n", "        int ret;\n", "        ret = l4_modify_port (ctx, l4_off, TCP_DPORT_OFF, csum_off, tmp, key -> dport);\n", "        if (IS_ERR (ret))\n", "            return ret;\n", "    }\n", "    return CTX_ACT_OK;\n", "}\n"], "called_function_list": ["l4_modify_port", "ipv6_store_daddr", "csum_l4_replace"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__lb6_affinity_backend_id": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 692, "endLine": 728, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "__lb6_affinity_backend_id", "developer_inline_comments": [], "updateMaps": [" LB6_AFFINITY_MAP"], "readMaps": ["  LB6_AFFINITY_MAP", " LB_AFFINITY_MATCH_MAP"], "input": ["const struct lb6_service *svc", " bool netns_cookie", " union lb6_affinity_client_id *id"], "output": "static__always_inline__u32", "helper": ["map_delete_elem", "map_lookup_elem"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __u32 __lb6_affinity_backend_id (const struct lb6_service *svc, bool netns_cookie, union lb6_affinity_client_id *id)\n", "{\n", "    struct lb6_affinity_key key = {\n", "        .rev_nat_id = svc->rev_nat_index,\n", "        .netns_cookie = netns_cookie,}\n", "    ;\n", "    struct lb_affinity_val *val;\n", "    ipv6_addr_copy (&key.client_id.client_ip, &id->client_ip);\n", "    val = map_lookup_elem (& LB6_AFFINITY_MAP, & key);\n", "    if (val != NULL) {\n", "        __u32 now = bpf_mono_now ();\n", "        struct lb_affinity_match match = {\n", "            .rev_nat_id = svc->rev_nat_index,\n", "            .backend_id = val->backend_id,}\n", "        ;\n", "        if (READ_ONCE (val->last_used) + bpf_sec_to_mono (svc->affinity_timeout) <= now) {\n", "            map_delete_elem (&LB6_AFFINITY_MAP, &key);\n", "            return 0;\n", "        }\n", "        if (!map_lookup_elem (&LB_AFFINITY_MATCH_MAP, &match)) {\n", "            map_delete_elem (&LB6_AFFINITY_MAP, &key);\n", "            return 0;\n", "        }\n", "        WRITE_ONCE (val->last_used, now);\n", "        return val->backend_id;\n", "    }\n", "    return 0;\n", "}\n"], "called_function_list": ["ipv6_addr_copy"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "lb6_affinity_backend_id_by_addr": [{"capabilities": [], "helperCallParams": {}, "startLine": 730, "endLine": 735, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "lb6_affinity_backend_id_by_addr", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct lb6_service *svc", " union lb6_affinity_client_id *id"], "output": "static__always_inline__u32", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __u32 lb6_affinity_backend_id_by_addr (const struct lb6_service *svc, union lb6_affinity_client_id *id)\n", "{\n", "    return __lb6_affinity_backend_id (svc, false, id);\n", "}\n"], "called_function_list": ["__lb6_affinity_backend_id"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__lb6_update_affinity": [{"capabilities": [], "helperCallParams": {}, "startLine": 737, "endLine": 754, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "__lb6_update_affinity", "developer_inline_comments": [], "updateMaps": [" LB6_AFFINITY_MAP"], "readMaps": [], "input": ["const struct lb6_service *svc", " bool netns_cookie", " union lb6_affinity_client_id *id", " __u32 backend_id"], "output": "static__always_inlinevoid", "helper": ["map_update_elem"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void __lb6_update_affinity (const struct lb6_service *svc, bool netns_cookie, union lb6_affinity_client_id *id, __u32 backend_id)\n", "{\n", "    __u32 now = bpf_mono_now ();\n", "    struct lb6_affinity_key key = {\n", "        .rev_nat_id = svc->rev_nat_index,\n", "        .netns_cookie = netns_cookie,}\n", "    ;\n", "    struct lb_affinity_val val = {\n", "        .backend_id = backend_id,\n", "        .last_used = now,}\n", "    ;\n", "    ipv6_addr_copy (&key.client_id.client_ip, &id->client_ip);\n", "    map_update_elem (&LB6_AFFINITY_MAP, &key, &val, 0);\n", "}\n"], "called_function_list": ["ipv6_addr_copy"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "lb6_update_affinity_by_addr": [{"capabilities": [], "helperCallParams": {}, "startLine": 756, "endLine": 761, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "lb6_update_affinity_by_addr", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct lb6_service *svc", " union lb6_affinity_client_id *id", " __u32 backend_id"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void lb6_update_affinity_by_addr (const struct lb6_service *svc, union lb6_affinity_client_id *id, __u32 backend_id)\n", "{\n", "    __lb6_update_affinity (svc, false, id, backend_id);\n", "}\n"], "called_function_list": ["__lb6_update_affinity"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "lb6_affinity_backend_id_by_netns": [{"capabilities": [], "helperCallParams": {}, "startLine": 764, "endLine": 773, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "lb6_affinity_backend_id_by_netns", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct lb6_service * svc __maybe_unused", " union lb6_affinity_client_id * id __maybe_unused"], "output": "static__always_inline__u32", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __u32 lb6_affinity_backend_id_by_netns (const struct lb6_service * svc __maybe_unused, union lb6_affinity_client_id * id __maybe_unused)\n", "{\n", "\n", "#if defined(ENABLE_SESSION_AFFINITY)\n", "    return __lb6_affinity_backend_id (svc, true, id);\n", "\n", "#else\n", "    return 0;\n", "\n", "#endif\n", "}\n"], "called_function_list": ["__lb6_affinity_backend_id"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "lb6_update_affinity_by_netns": [{"capabilities": [], "helperCallParams": {}, "startLine": 775, "endLine": 783, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "lb6_update_affinity_by_netns", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct lb6_service * svc __maybe_unused", " union lb6_affinity_client_id * id __maybe_unused", " __u32 backend_id __maybe_unused"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void lb6_update_affinity_by_netns (const struct lb6_service * svc __maybe_unused, union lb6_affinity_client_id * id __maybe_unused, __u32 backend_id __maybe_unused)\n", "{\n", "\n", "#if defined(ENABLE_SESSION_AFFINITY)\n", "    __lb6_update_affinity (svc, true, id, backend_id);\n", "\n", "#endif\n", "}\n"], "called_function_list": ["__lb6_update_affinity"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "lb6_to_lb4": [{"capabilities": [], "helperCallParams": {}, "startLine": 785, "endLine": 799, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "lb6_to_lb4", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff * ctx __maybe_unused", " const struct ipv6hdr * ip6 __maybe_unused"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int lb6_to_lb4 (struct  __ctx_buff * ctx __maybe_unused, const struct ipv6hdr * ip6 __maybe_unused)\n", "{\n", "\n", "#ifdef ENABLE_NAT_46X64\n", "    __be32 src4, dst4;\n", "    build_v4_from_v6 ((const union v6addr *) &ip6->saddr, &src4);\n", "    build_v4_from_v6 ((const union v6addr *) &ip6->daddr, &dst4);\n", "    return ipv6_to_ipv4 (ctx, src4, dst4);\n", "\n", "#else\n", "    return DROP_NAT_46X64_DISABLED;\n", "\n", "#endif\n", "}\n"], "called_function_list": ["ipv6_to_ipv4", "build_v4_from_v6"], "call_depth": 4, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "lb6_local": [{"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 801, "endLine": 926, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "lb6_local", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const void *map", " struct  __ctx_buff *ctx", " int l3_off", " int l4_off", " struct csum_offset *csum_off", " struct lb6_key *key", " struct ipv6_ct_tuple *tuple", " const struct lb6_service *svc", " struct ct_state *state", " const bool skip_l3_xlate"], "output": "static__always_inlineint", "helper": ["CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["static __always_inline int lb6_local (const void *map, struct  __ctx_buff *ctx, int l3_off, int l4_off, struct csum_offset *csum_off, struct lb6_key *key, struct ipv6_ct_tuple *tuple, const struct lb6_service *svc, struct ct_state *state, const bool skip_l3_xlate)\n", "{\n", "    __u32 monitor;\n", "    union v6addr *addr;\n", "    __u8 flags = tuple->flags;\n", "    struct lb6_backend *backend;\n", "    __u32 backend_id = 0;\n", "    int ret;\n", "\n", "#ifdef ENABLE_SESSION_AFFINITY\n", "    union lb6_affinity_client_id client_id;\n", "    ipv6_addr_copy (&client_id.client_ip, &tuple->saddr);\n", "\n", "#endif\n", "    ret = ct_lookup6 (map, tuple, ctx, l4_off, CT_SERVICE, state, & monitor);\n", "    switch (ret) {\n", "    case CT_NEW :\n", "\n", "#ifdef ENABLE_SESSION_AFFINITY\n", "        if (lb6_svc_is_affinity (svc)) {\n", "            backend_id = lb6_affinity_backend_id_by_addr (svc, & client_id);\n", "            if (backend_id != 0) {\n", "                backend = lb6_lookup_backend (ctx, backend_id);\n", "                if (backend == NULL)\n", "                    backend_id = 0;\n", "            }\n", "        }\n", "\n", "#endif\n", "        if (backend_id == 0) {\n", "            backend_id = lb6_select_backend_id (ctx, key, tuple, svc);\n", "            backend = lb6_lookup_backend (ctx, backend_id);\n", "            if (backend == NULL)\n", "                goto drop_no_service;\n", "        }\n", "        state->backend_id = backend_id;\n", "        state->rev_nat_index = svc->rev_nat_index;\n", "        ret = ct_create6 (map, NULL, tuple, ctx, CT_SERVICE, state, false, false);\n", "        if (IS_ERR (ret))\n", "            goto drop_no_service;\n", "        goto update_state;\n", "    case CT_REOPENED :\n", "    case CT_ESTABLISHED :\n", "    case CT_RELATED :\n", "    case CT_REPLY :\n", "        if (state->rev_nat_index == 0) {\n", "            state->rev_nat_index = svc->rev_nat_index;\n", "            ct_update6_rev_nat_index (map, tuple, state);\n", "        }\n", "        break;\n", "    default :\n", "        goto drop_no_service;\n", "    }\n", "    if (state->rev_nat_index != svc->rev_nat_index) {\n", "\n", "#ifdef ENABLE_SESSION_AFFINITY\n", "        if (lb6_svc_is_affinity (svc))\n", "            backend_id = lb6_affinity_backend_id_by_addr (svc, &client_id);\n", "\n", "#endif\n", "        if (!backend_id) {\n", "            backend_id = lb6_select_backend_id (ctx, key, tuple, svc);\n", "            if (!backend_id)\n", "                goto drop_no_service;\n", "        }\n", "        state->backend_id = backend_id;\n", "        ct_update6_backend_id (map, tuple, state);\n", "        state->rev_nat_index = svc->rev_nat_index;\n", "        ct_update6_rev_nat_index (map, tuple, state);\n", "    }\n", "    backend = lb6_lookup_backend (ctx, state -> backend_id);\n", "    if (unlikely (!backend || backend->flags != BE_STATE_ACTIVE)) {\n", "        if (backend && !state->syn)\n", "            goto update_state;\n", "        key->backend_slot = 0;\n", "        svc = lb6_lookup_service (key, false);\n", "        if (!svc)\n", "            goto drop_no_service;\n", "        backend_id = lb6_select_backend_id (ctx, key, tuple, svc);\n", "        backend = lb6_lookup_backend (ctx, backend_id);\n", "        if (!backend)\n", "            goto drop_no_service;\n", "        state->backend_id = backend_id;\n", "        ct_update6_backend_id (map, tuple, state);\n", "    }\n", "update_state :\n", "    tuple->flags = flags;\n", "    ipv6_addr_copy (&tuple->daddr, &backend->address);\n", "    addr = &tuple->daddr;\n", "    state->rev_nat_index = svc->rev_nat_index;\n", "\n", "#ifdef ENABLE_SESSION_AFFINITY\n", "    if (lb6_svc_is_affinity (svc))\n", "        lb6_update_affinity_by_addr (svc, &client_id, state->backend_id);\n", "\n", "#endif\n", "    return lb_skip_l4_dnat () ? CTX_ACT_OK : lb6_xlate (ctx, addr, tuple->nexthdr, l3_off, l4_off, csum_off, key, backend, skip_l3_xlate);\n", "drop_no_service :\n", "    tuple->flags = flags;\n", "    return DROP_NO_SERVICE;\n", "}\n"], "called_function_list": ["lb6_update_affinity_by_addr", "lb6_lookup_service", "ct_create6", "ct_lookup6", "lb6_lookup_backend", "lb6_affinity_backend_id_by_addr", "lb_skip_l4_dnat", "ct_update6_backend_id", "lb6_xlate", "ct_update6_rev_nat_index", "ipv6_addr_copy", "lb6_svc_is_affinity", "lb6_select_backend_id"], "call_depth": 3, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "lb6_ctx_store_state": [{"capabilities": [], "helperCallParams": {}, "startLine": 935, "endLine": 942, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "lb6_ctx_store_state", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " const struct ct_state *state", " __u16 proxy_port"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void lb6_ctx_store_state (struct  __ctx_buff *ctx, const struct ct_state *state, __u16 proxy_port)\n", "{\n", "    ctx_store_meta (ctx, CB_PROXY_MAGIC, (__u32) proxy_port << 16);\n", "    ctx_store_meta (ctx, CB_BACKEND_ID, state->backend_id);\n", "    ctx_store_meta (ctx, CB_CT_STATE, (__u32) state->rev_nat_index);\n", "}\n"], "called_function_list": ["ctx_store_meta"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "lb6_ctx_restore_state": [{"capabilities": [], "helperCallParams": {}, "startLine": 949, "endLine": 965, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "lb6_ctx_restore_state", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " struct ct_state *state", " __u16 *proxy_port"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void lb6_ctx_restore_state (struct  __ctx_buff *ctx, struct ct_state *state, __u16 *proxy_port)\n", "{\n", "    state->rev_nat_index = (__u16) ctx_load_meta (ctx, CB_CT_STATE);\n", "    ctx_store_meta (ctx, CB_CT_STATE, 0);\n", "    state->backend_id = ctx_load_meta (ctx, CB_BACKEND_ID);\n", "    ctx_store_meta (ctx, CB_BACKEND_ID, 0);\n", "    *proxy_port = ctx_load_meta (ctx, CB_PROXY_MAGIC) >> 16;\n", "    ctx_store_meta (ctx, CB_PROXY_MAGIC, 0);\n", "}\n"], "called_function_list": ["ctx_store_meta", "ctx_load_meta"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__lb4_rev_nat": [{"capabilities": [{"capability": "read_skb", "read_skb": [{"Project": "cilium", "Return Type": "s64", "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ", "Return": " The checksum result, or a negative error code in case of failure.", "Function Name": "csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp", "lwt_in", "lwt_out", "lwt_xmit", "lwt_seg6local"], "capabilities": ["read_skb"]}]}], "helperCallParams": {}, "startLine": 999, "endLine": 1066, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "__lb4_rev_nat", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " int l3_off", " int l4_off", " struct csum_offset *csum_off", " struct ipv4_ct_tuple *tuple", " int flags", " const struct lb4_reverse_nat *nat", " const struct ct_state *ct_state", " bool has_l4_header"], "output": "static__always_inlineint", "helper": ["csum_diff"], "compatibleHookpoints": ["sched_cls", "lwt_xmit", "xdp", "lwt_in", "sched_act", "lwt_out", "lwt_seg6local"], "source": ["static __always_inline int __lb4_rev_nat (struct  __ctx_buff *ctx, int l3_off, int l4_off, struct csum_offset *csum_off, struct ipv4_ct_tuple *tuple, int flags, const struct lb4_reverse_nat *nat, const struct ct_state *ct_state, bool has_l4_header)\n", "{\n", "    __be32 old_sip, new_sip, sum = 0;\n", "    int ret;\n", "    cilium_dbg_lb (ctx, DBG_LB4_REVERSE_NAT, nat->address, nat->port);\n", "    if (nat->port && has_l4_header) {\n", "        ret = reverse_map_l4_port (ctx, tuple -> nexthdr, nat -> port, l4_off, csum_off);\n", "        if (IS_ERR (ret))\n", "            return ret;\n", "    }\n", "    if (flags & REV_NAT_F_TUPLE_SADDR) {\n", "        old_sip = tuple->saddr;\n", "        tuple->saddr = new_sip = nat->address;\n", "    }\n", "    else {\n", "        ret = ctx_load_bytes (ctx, l3_off + offsetof (struct iphdr, saddr), & old_sip, 4);\n", "        if (IS_ERR (ret))\n", "            return ret;\n", "        new_sip = nat->address;\n", "    }\n", "    if (ct_state->loopback) {\n", "        __be32 old_dip;\n", "        ret = ctx_load_bytes (ctx, l3_off + offsetof (struct iphdr, daddr), & old_dip, 4);\n", "        if (IS_ERR (ret))\n", "            return ret;\n", "        cilium_dbg_lb (ctx, DBG_LB4_LOOPBACK_SNAT_REV, old_dip, old_sip);\n", "        ret = ctx_store_bytes (ctx, l3_off + offsetof (struct iphdr, daddr), & old_sip, 4, 0);\n", "        if (IS_ERR (ret))\n", "            return DROP_WRITE_ERROR;\n", "        sum = csum_diff (& old_dip, 4, & old_sip, 4, 0);\n", "        tuple->saddr = old_sip;\n", "    }\n", "    ret = ctx_store_bytes (ctx, l3_off + offsetof (struct iphdr, saddr), & new_sip, 4, 0);\n", "    if (IS_ERR (ret))\n", "        return DROP_WRITE_ERROR;\n", "    sum = csum_diff (& old_sip, 4, & new_sip, 4, sum);\n", "    if (l3_csum_replace (ctx, l3_off + offsetof (struct iphdr, check), 0, sum, 0) < 0)\n", "        return DROP_CSUM_L3;\n", "    if (csum_off->offset && csum_l4_replace (ctx, l4_off, csum_off, 0, sum, BPF_F_PSEUDO_HDR) < 0)\n", "        return DROP_CSUM_L4;\n", "    return 0;\n", "}\n"], "called_function_list": ["csum_l4_replace", "reverse_map_l4_port"], "call_depth": 3, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "lb4_rev_nat": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 1078, "endLine": 1092, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "lb4_rev_nat", "developer_inline_comments": [], "updateMaps": [], "readMaps": ["  LB4_REVERSE_NAT_MAP"], "input": ["struct  __ctx_buff *ctx", " int l3_off", " int l4_off", " struct csum_offset *csum_off", " struct ct_state *ct_state", " struct ipv4_ct_tuple *tuple", " int flags", " bool has_l4_header"], "output": "static__always_inlineint", "helper": ["map_lookup_elem"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int lb4_rev_nat (struct  __ctx_buff *ctx, int l3_off, int l4_off, struct csum_offset *csum_off, struct ct_state *ct_state, struct ipv4_ct_tuple *tuple, int flags, bool has_l4_header)\n", "{\n", "    struct lb4_reverse_nat *nat;\n", "    cilium_dbg_lb (ctx, DBG_LB4_REVERSE_NAT_LOOKUP, ct_state->rev_nat_index, 0);\n", "    nat = map_lookup_elem (& LB4_REVERSE_NAT_MAP, & ct_state -> rev_nat_index);\n", "    if (nat == NULL)\n", "        return 0;\n", "    return __lb4_rev_nat (ctx, l3_off, l4_off, csum_off, tuple, flags, nat, ct_state, has_l4_header);\n", "}\n"], "called_function_list": ["__lb4_rev_nat"], "call_depth": 4, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "lb4_extract_key": [{"capabilities": [], "helperCallParams": {}, "startLine": 1107, "endLine": 1121, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "lb4_extract_key", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff * ctx __maybe_unused", " struct iphdr *ip4", " int l4_off __maybe_unused", " struct lb4_key *key", " struct csum_offset *csum_off", " enum ct_dir dir"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int lb4_extract_key (struct  __ctx_buff * ctx __maybe_unused, struct iphdr *ip4, int l4_off __maybe_unused, struct lb4_key *key, struct csum_offset *csum_off, enum ct_dir dir)\n", "{\n", "    key->proto = 0;\n", "    key->address = (dir == CT_INGRESS) ? ip4->saddr : ip4->daddr;\n", "    if (ipv4_has_l4_header (ip4))\n", "        csum_l4_offset_and_flags (ip4->protocol, csum_off);\n", "    return extract_l4_port (ctx, ip4->protocol, l4_off, dir, &key->dport, ip4);\n", "}\n"], "called_function_list": ["ipv4_has_l4_header", "extract_l4_port", "csum_l4_offset_and_flags"], "call_depth": 6, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "lb4_src_range_ok": [{"capabilities": [], "helperCallParams": {}, "startLine": 1123, "endLine": 1146, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "lb4_src_range_ok", "developer_inline_comments": [], "updateMaps": [], "readMaps": [" LB4_SRC_RANGE_MAP"], "input": ["const struct lb4_service * svc __maybe_unused", " __u32 saddr __maybe_unused"], "output": "static__always_inlinebool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline bool lb4_src_range_ok (const struct lb4_service * svc __maybe_unused, __u32 saddr __maybe_unused)\n", "{\n", "\n", "#ifdef ENABLE_SRC_RANGE_CHECK\n", "    struct lb4_src_range_key key;\n", "    if (!lb4_svc_has_src_range_check (svc))\n", "        return true;\n", "    key = (typeof (key)) {\n", "        .lpm_key = {SRC_RANGE_STATIC_PREFIX (key),\n", "            {}},\n", "        .rev_nat_id = svc->rev_nat_index,\n", "        .addr = saddr,};\n", "    if (map_lookup_elem (&LB4_SRC_RANGE_MAP, &key))\n", "        return true;\n", "    return false;\n", "\n", "#else\n", "    return true;\n", "\n", "#endif /* ENABLE_SRC_RANGE_CHECK */\n", "}\n"], "called_function_list": ["lb4_svc_has_src_range_check"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "lb4_populate_ports": [{"capabilities": [], "helperCallParams": {}, "startLine": 1148, "endLine": 1164, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "lb4_populate_ports", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " struct ipv4_ct_tuple *tuple", " int off"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int lb4_populate_ports (struct  __ctx_buff *ctx, struct ipv4_ct_tuple *tuple, int off)\n", "{\n", "    if (tuple->nexthdr == IPPROTO_TCP || tuple->nexthdr == IPPROTO_UDP) {\n", "        struct {\n", "            __be16 sport;\n", "            __be16 dport;\n", "        } l4hdr;\n", "\n", "        if (ctx_load_bytes (ctx, off, &l4hdr, sizeof (l4hdr)) < 0)\n", "            return -EFAULT;\n", "        tuple->sport = l4hdr.sport;\n", "        tuple->dport = l4hdr.dport;\n", "        return 0;\n", "    }\n", "    return -ENOTSUP;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "lb4_to_lb6_service": [{"capabilities": [], "helperCallParams": {}, "startLine": 1166, "endLine": 1174, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "lb4_to_lb6_service", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct lb4_service * svc __maybe_unused"], "output": "static__always_inlinebool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline bool lb4_to_lb6_service (const struct lb4_service * svc __maybe_unused)\n", "{\n", "\n", "#ifdef ENABLE_NAT_46X64\n", "    return svc->flags2 & SVC_FLAG_NAT_46X64;\n", "\n", "#else\n", "    return false;\n", "\n", "#endif\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "lb4_lookup_service": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 1176, "endLine": 1197, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "lb4_lookup_service", "developer_inline_comments": [], "updateMaps": [], "readMaps": ["  LB4_SERVICES_MAP_V2"], "input": ["struct lb4_key *key", " const bool scope_switch"], "output": "static__always_inlinestructlb4_service", "helper": ["map_lookup_elem"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline struct lb4_service *lb4_lookup_service (struct lb4_key *key, const bool scope_switch)\n", "{\n", "    struct lb4_service *svc;\n", "    key->scope = LB_LOOKUP_SCOPE_EXT;\n", "    key->backend_slot = 0;\n", "    svc = map_lookup_elem (& LB4_SERVICES_MAP_V2, key);\n", "    if (svc) {\n", "        if (!scope_switch || !lb4_svc_is_local_scope (svc))\n", "            return (svc->count || lb4_to_lb6_service (svc) || lb4_svc_is_l7loadbalancer (svc)) ? svc : NULL;\n", "        key->scope = LB_LOOKUP_SCOPE_INT;\n", "        svc = map_lookup_elem (& LB4_SERVICES_MAP_V2, key);\n", "        if (svc && (svc->count || lb4_svc_is_l7loadbalancer (svc)))\n", "            return svc;\n", "    }\n", "    return NULL;\n", "}\n"], "called_function_list": ["lb4_svc_is_l7loadbalancer", "lb4_to_lb6_service", "lb4_svc_is_local_scope"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__lb4_lookup_backend": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 1199, "endLine": 1202, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "__lb4_lookup_backend", "developer_inline_comments": [], "updateMaps": [], "readMaps": [" LB4_BACKEND_MAP_V2"], "input": ["__u32 backend_id"], "output": "static__always_inlinestructlb4_backend", "helper": ["map_lookup_elem"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline struct lb4_backend *__lb4_lookup_backend (__u32 backend_id)\n", "{\n", "    return map_lookup_elem (&LB4_BACKEND_MAP_V2, &backend_id);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "lb4_lookup_backend": [{"capabilities": [], "helperCallParams": {}, "startLine": 1204, "endLine": 1214, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "lb4_lookup_backend", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff * ctx __maybe_unused", " __u32 backend_id"], "output": "static__always_inlinestructlb4_backend", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline struct lb4_backend *lb4_lookup_backend (struct  __ctx_buff * ctx __maybe_unused, __u32 backend_id)\n", "{\n", "    struct lb4_backend *backend;\n", "    backend = __lb4_lookup_backend (backend_id);\n", "    if (!backend)\n", "        cilium_dbg_lb (ctx, DBG_LB4_LOOKUP_BACKEND_FAIL, backend_id, 0);\n", "    return backend;\n", "}\n"], "called_function_list": ["__lb4_lookup_backend"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__lb4_lookup_backend_slot": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 1216, "endLine": 1220, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "__lb4_lookup_backend_slot", "developer_inline_comments": [], "updateMaps": [], "readMaps": [" LB4_SERVICES_MAP_V2"], "input": ["struct lb4_key *key"], "output": "static__always_inlinestructlb4_service", "helper": ["map_lookup_elem"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline struct lb4_service *__lb4_lookup_backend_slot (struct lb4_key *key)\n", "{\n", "    return map_lookup_elem (&LB4_SERVICES_MAP_V2, key);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "lb4_lookup_backend_slot": [{"capabilities": [], "helperCallParams": {}, "startLine": 1222, "endLine": 1237, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "lb4_lookup_backend_slot", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff * ctx __maybe_unused", " struct lb4_key *key", " __u16 slot"], "output": "static__always_inlinestructlb4_service", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline struct lb4_service *lb4_lookup_backend_slot (struct  __ctx_buff * ctx __maybe_unused, struct lb4_key *key, __u16 slot)\n", "{\n", "    struct lb4_service *svc;\n", "    key->backend_slot = slot;\n", "    cilium_dbg_lb (ctx, DBG_LB4_LOOKUP_BACKEND_SLOT, key->backend_slot, key->dport);\n", "    svc = __lb4_lookup_backend_slot (key);\n", "    if (svc)\n", "        return svc;\n", "    cilium_dbg_lb (ctx, DBG_LB4_LOOKUP_BACKEND_SLOT_V2_FAIL, key->backend_slot, key->dport);\n", "    return NULL;\n", "}\n"], "called_function_list": ["__lb4_lookup_backend_slot"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "lb4_select_backend_id": [{"capabilities": [], "helperCallParams": {}, "startLine": 1241, "endLine": 1251, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "lb4_select_backend_id", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " struct lb4_key *key", " const struct ipv4_ct_tuple * tuple __maybe_unused", " const struct lb4_service *svc"], "output": "static__always_inline__u32", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __u32 lb4_select_backend_id (struct  __ctx_buff *ctx, struct lb4_key *key, const struct ipv4_ct_tuple * tuple __maybe_unused, const struct lb4_service *svc)\n", "{\n", "    __u16 slot = (get_prandom_u32 () % svc->count) + 1;\n", "    struct lb4_service *be = lb4_lookup_backend_slot (ctx, key, slot);\n", "    return be ? be->backend_id : 0;\n", "}\n"], "called_function_list": ["lb4_lookup_backend_slot", "map_array_get_32", "hash_from_tuple_v4"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 1253, "endLine": 1273, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "lb4_select_backend_id", "developer_inline_comments": [], "updateMaps": [], "readMaps": ["  LB4_MAGLEV_MAP_OUTER", " maglev_lut"], "input": ["struct  __ctx_buff * ctx __maybe_unused", " struct lb4_key * key __maybe_unused", " const struct ipv4_ct_tuple *tuple", " const struct lb4_service *svc"], "output": "static__always_inline__u32", "helper": ["map_lookup_elem"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __u32 lb4_select_backend_id (struct  __ctx_buff * ctx __maybe_unused, struct lb4_key * key __maybe_unused, const struct ipv4_ct_tuple *tuple, const struct lb4_service *svc)\n", "{\n", "    __u32 zero = 0, index = svc->rev_nat_index;\n", "    __u32 *backend_ids;\n", "    void *maglev_lut;\n", "    maglev_lut = map_lookup_elem (& LB4_MAGLEV_MAP_OUTER, & index);\n", "    if (unlikely (!maglev_lut))\n", "        return 0;\n", "    backend_ids = map_lookup_elem (maglev_lut, & zero);\n", "    if (unlikely (!backend_ids))\n", "        return 0;\n", "    index = hash_from_tuple_v4 (tuple) % LB_MAGLEV_LUT_SIZE;\n", "    return map_array_get_32 (backend_ids, index, (LB_MAGLEV_LUT_SIZE - 1) << 2);\n", "}\n"], "called_function_list": ["lb4_lookup_backend_slot", "map_array_get_32", "hash_from_tuple_v4"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "lb4_xlate": [{"capabilities": [{"capability": "read_skb", "read_skb": [{"Project": "cilium", "Return Type": "s64", "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ", "Return": " The checksum result, or a negative error code in case of failure.", "Function Name": "csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp", "lwt_in", "lwt_out", "lwt_xmit", "lwt_seg6local"], "capabilities": ["read_skb"]}]}, {"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 1278, "endLine": 1332, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "lb4_xlate", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " __be32 *new_daddr", " __be32 * new_saddr __maybe_unused", " __be32 * old_saddr __maybe_unused", " __u8 nexthdr __maybe_unused", " int l3_off", " int l4_off", " struct csum_offset *csum_off", " struct lb4_key *key", " const struct lb4_backend * backend __maybe_unused", " bool has_l4_header", " const bool skip_l3_xlate"], "output": "static__always_inlineint", "helper": ["csum_diff", "CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["static __always_inline int lb4_xlate (struct  __ctx_buff *ctx, __be32 *new_daddr, __be32 * new_saddr __maybe_unused, __be32 * old_saddr __maybe_unused, __u8 nexthdr __maybe_unused, int l3_off, int l4_off, struct csum_offset *csum_off, struct lb4_key *key, const struct lb4_backend * backend __maybe_unused, bool has_l4_header, const bool skip_l3_xlate)\n", "{\n", "    __be32 sum;\n", "    int ret;\n", "    if (skip_l3_xlate)\n", "        goto l4_xlate;\n", "    ret = ctx_store_bytes (ctx, l3_off + offsetof (struct iphdr, daddr), new_daddr, 4, 0);\n", "    if (ret < 0)\n", "        return DROP_WRITE_ERROR;\n", "    sum = csum_diff (& key -> address, 4, new_daddr, 4, 0);\n", "\n", "#ifndef DISABLE_LOOPBACK_LB\n", "    if (new_saddr && *new_saddr) {\n", "        cilium_dbg_lb (ctx, DBG_LB4_LOOPBACK_SNAT, *old_saddr, *new_saddr);\n", "        ret = ctx_store_bytes (ctx, l3_off + offsetof (struct iphdr, saddr), new_saddr, 4, 0);\n", "        if (ret < 0)\n", "            return DROP_WRITE_ERROR;\n", "        sum = csum_diff (old_saddr, 4, new_saddr, 4, sum);\n", "    }\n", "\n", "#endif /* DISABLE_LOOPBACK_LB */\n", "    if (l3_csum_replace (ctx, l3_off + offsetof (struct iphdr, check), 0, sum, 0) < 0)\n", "        return DROP_CSUM_L3;\n", "    if (csum_off->offset) {\n", "        if (csum_l4_replace (ctx, l4_off, csum_off, 0, sum, BPF_F_PSEUDO_HDR) < 0)\n", "            return DROP_CSUM_L4;\n", "    }\n", "l4_xlate :\n", "    if (likely (backend->port) && key->dport != backend->port && (nexthdr == IPPROTO_TCP || nexthdr == IPPROTO_UDP) && has_l4_header) {\n", "        __be16 tmp = backend->port;\n", "        ret = l4_modify_port (ctx, l4_off, TCP_DPORT_OFF, csum_off, tmp, key -> dport);\n", "        if (IS_ERR (ret))\n", "            return ret;\n", "    }\n", "    return CTX_ACT_OK;\n", "}\n"], "called_function_list": ["csum_l4_replace", "l4_modify_port"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__lb4_affinity_backend_id": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 1335, "endLine": 1375, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "__lb4_affinity_backend_id", "developer_inline_comments": [], "updateMaps": [" LB4_AFFINITY_MAP"], "readMaps": ["  LB4_AFFINITY_MAP", " LB_AFFINITY_MATCH_MAP"], "input": ["const struct lb4_service *svc", " bool netns_cookie", " const union lb4_affinity_client_id *id"], "output": "static__always_inline__u32", "helper": ["map_delete_elem", "map_lookup_elem"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __u32 __lb4_affinity_backend_id (const struct lb4_service *svc, bool netns_cookie, const union lb4_affinity_client_id *id)\n", "{\n", "    struct lb4_affinity_key key = {\n", "        .rev_nat_id = svc->rev_nat_index,\n", "        .netns_cookie = netns_cookie,\n", "        .client_id = *id,}\n", "    ;\n", "    struct lb_affinity_val *val;\n", "    val = map_lookup_elem (& LB4_AFFINITY_MAP, & key);\n", "    if (val != NULL) {\n", "        __u32 now = bpf_mono_now ();\n", "        struct lb_affinity_match match = {\n", "            .rev_nat_id = svc->rev_nat_index,\n", "            .backend_id = val->backend_id,}\n", "        ;\n", "        if (READ_ONCE (val->last_used) + bpf_sec_to_mono (svc->affinity_timeout) <= now) {\n", "            map_delete_elem (&LB4_AFFINITY_MAP, &key);\n", "            return 0;\n", "        }\n", "        if (!map_lookup_elem (&LB_AFFINITY_MATCH_MAP, &match)) {\n", "            map_delete_elem (&LB4_AFFINITY_MAP, &key);\n", "            return 0;\n", "        }\n", "        WRITE_ONCE (val->last_used, now);\n", "        return val->backend_id;\n", "    }\n", "    return 0;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "lb4_affinity_backend_id_by_addr": [{"capabilities": [], "helperCallParams": {}, "startLine": 1377, "endLine": 1382, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "lb4_affinity_backend_id_by_addr", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct lb4_service *svc", " union lb4_affinity_client_id *id"], "output": "static__always_inline__u32", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __u32 lb4_affinity_backend_id_by_addr (const struct lb4_service *svc, union lb4_affinity_client_id *id)\n", "{\n", "    return __lb4_affinity_backend_id (svc, false, id);\n", "}\n"], "called_function_list": ["__lb4_affinity_backend_id"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__lb4_update_affinity": [{"capabilities": [], "helperCallParams": {}, "startLine": 1384, "endLine": 1401, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "__lb4_update_affinity", "developer_inline_comments": [], "updateMaps": [" LB4_AFFINITY_MAP"], "readMaps": [], "input": ["const struct lb4_service *svc", " bool netns_cookie", " const union lb4_affinity_client_id *id", " __u32 backend_id"], "output": "static__always_inlinevoid", "helper": ["map_update_elem"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void __lb4_update_affinity (const struct lb4_service *svc, bool netns_cookie, const union lb4_affinity_client_id *id, __u32 backend_id)\n", "{\n", "    __u32 now = bpf_mono_now ();\n", "    struct lb4_affinity_key key = {\n", "        .rev_nat_id = svc->rev_nat_index,\n", "        .netns_cookie = netns_cookie,\n", "        .client_id = *id,}\n", "    ;\n", "    struct lb_affinity_val val = {\n", "        .backend_id = backend_id,\n", "        .last_used = now,}\n", "    ;\n", "    map_update_elem (&LB4_AFFINITY_MAP, &key, &val, 0);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "lb4_update_affinity_by_addr": [{"capabilities": [], "helperCallParams": {}, "startLine": 1403, "endLine": 1408, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "lb4_update_affinity_by_addr", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct lb4_service *svc", " union lb4_affinity_client_id *id", " __u32 backend_id"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void lb4_update_affinity_by_addr (const struct lb4_service *svc, union lb4_affinity_client_id *id, __u32 backend_id)\n", "{\n", "    __lb4_update_affinity (svc, false, id, backend_id);\n", "}\n"], "called_function_list": ["__lb4_update_affinity"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "lb4_affinity_backend_id_by_netns": [{"capabilities": [], "helperCallParams": {}, "startLine": 1411, "endLine": 1420, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "lb4_affinity_backend_id_by_netns", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct lb4_service * svc __maybe_unused", " union lb4_affinity_client_id * id __maybe_unused"], "output": "static__always_inline__u32", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __u32 lb4_affinity_backend_id_by_netns (const struct lb4_service * svc __maybe_unused, union lb4_affinity_client_id * id __maybe_unused)\n", "{\n", "\n", "#if defined(ENABLE_SESSION_AFFINITY)\n", "    return __lb4_affinity_backend_id (svc, true, id);\n", "\n", "#else\n", "    return 0;\n", "\n", "#endif\n", "}\n"], "called_function_list": ["__lb4_affinity_backend_id"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "lb4_update_affinity_by_netns": [{"capabilities": [], "helperCallParams": {}, "startLine": 1422, "endLine": 1430, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "lb4_update_affinity_by_netns", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct lb4_service * svc __maybe_unused", " union lb4_affinity_client_id * id __maybe_unused", " __u32 backend_id __maybe_unused"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void lb4_update_affinity_by_netns (const struct lb4_service * svc __maybe_unused, union lb4_affinity_client_id * id __maybe_unused, __u32 backend_id __maybe_unused)\n", "{\n", "\n", "#if defined(ENABLE_SESSION_AFFINITY)\n", "    __lb4_update_affinity (svc, true, id, backend_id);\n", "\n", "#endif\n", "}\n"], "called_function_list": ["__lb4_update_affinity"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "lb4_to_lb6": [{"capabilities": [], "helperCallParams": {}, "startLine": 1432, "endLine": 1447, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "lb4_to_lb6", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff * ctx __maybe_unused", " const struct iphdr * ip4 __maybe_unused", " int l3_off __maybe_unused"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int lb4_to_lb6 (struct  __ctx_buff * ctx __maybe_unused, const struct iphdr * ip4 __maybe_unused, int l3_off __maybe_unused)\n", "{\n", "\n", "#ifdef ENABLE_NAT_46X64\n", "    union v6addr src6, dst6;\n", "    build_v4_in_v6 (&src6, ip4->saddr);\n", "    build_v4_in_v6 (&dst6, ip4->daddr);\n", "    return ipv4_to_ipv6 (ctx, l3_off, &src6, &dst6);\n", "\n", "#else\n", "    return DROP_NAT_46X64_DISABLED;\n", "\n", "#endif\n", "}\n"], "called_function_list": ["build_v4_in_v6", "ipv4_to_ipv6"], "call_depth": 4, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "lb4_local": [{"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 1449, "endLine": 1604, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "lb4_local", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const void *map", " struct  __ctx_buff *ctx", " int l3_off", " int l4_off", " struct csum_offset *csum_off", " struct lb4_key *key", " struct ipv4_ct_tuple *tuple", " const struct lb4_service *svc", " struct ct_state *state", " __be32 saddr", " bool has_l4_header", " const bool skip_l3_xlate"], "output": "static__always_inlineint", "helper": ["CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["static __always_inline int lb4_local (const void *map, struct  __ctx_buff *ctx, int l3_off, int l4_off, struct csum_offset *csum_off, struct lb4_key *key, struct ipv4_ct_tuple *tuple, const struct lb4_service *svc, struct ct_state *state, __be32 saddr, bool has_l4_header, const bool skip_l3_xlate)\n", "{\n", "    __u32 monitor;\n", "    __be32 new_saddr = 0, new_daddr;\n", "    __u8 flags = tuple->flags;\n", "    struct lb4_backend *backend;\n", "    __u32 backend_id = 0;\n", "    int ret;\n", "\n", "#ifdef ENABLE_SESSION_AFFINITY\n", "    union lb4_affinity_client_id client_id = {\n", "        .client_ip = saddr,}\n", "    ;\n", "\n", "#endif\n", "    ret = ct_lookup4 (map, tuple, ctx, l4_off, CT_SERVICE, state, & monitor);\n", "    switch (ret) {\n", "    case CT_NEW :\n", "\n", "#ifdef ENABLE_SESSION_AFFINITY\n", "        if (lb4_svc_is_affinity (svc)) {\n", "            backend_id = lb4_affinity_backend_id_by_addr (svc, & client_id);\n", "            if (backend_id != 0) {\n", "                backend = lb4_lookup_backend (ctx, backend_id);\n", "                if (backend == NULL)\n", "                    backend_id = 0;\n", "            }\n", "        }\n", "\n", "#endif\n", "        if (backend_id == 0) {\n", "            backend_id = lb4_select_backend_id (ctx, key, tuple, svc);\n", "            backend = lb4_lookup_backend (ctx, backend_id);\n", "            if (backend == NULL)\n", "                goto drop_no_service;\n", "        }\n", "        state->backend_id = backend_id;\n", "        state->rev_nat_index = svc->rev_nat_index;\n", "        ret = ct_create4 (map, NULL, tuple, ctx, CT_SERVICE, state, false, false);\n", "        if (IS_ERR (ret))\n", "            goto drop_no_service;\n", "        goto update_state;\n", "    case CT_REOPENED :\n", "    case CT_ESTABLISHED :\n", "    case CT_RELATED :\n", "    case CT_REPLY :\n", "        if (unlikely (state->rev_nat_index == 0)) {\n", "            state->rev_nat_index = svc->rev_nat_index;\n", "            ct_update4_rev_nat_index (map, tuple, state);\n", "        }\n", "        break;\n", "    default :\n", "        goto drop_no_service;\n", "    }\n", "    if (state->rev_nat_index != svc->rev_nat_index) {\n", "\n", "#ifdef ENABLE_SESSION_AFFINITY\n", "        if (lb4_svc_is_affinity (svc))\n", "            backend_id = lb4_affinity_backend_id_by_addr (svc, &client_id);\n", "\n", "#endif\n", "        if (!backend_id) {\n", "            backend_id = lb4_select_backend_id (ctx, key, tuple, svc);\n", "            if (!backend_id)\n", "                goto drop_no_service;\n", "        }\n", "        state->backend_id = backend_id;\n", "        ct_update4_backend_id (map, tuple, state);\n", "        state->rev_nat_index = svc->rev_nat_index;\n", "        ct_update4_rev_nat_index (map, tuple, state);\n", "    }\n", "    backend = lb4_lookup_backend (ctx, state -> backend_id);\n", "    if (unlikely (!backend || backend->flags != BE_STATE_ACTIVE)) {\n", "        if (backend && !state->syn)\n", "            goto update_state;\n", "        key->backend_slot = 0;\n", "        svc = lb4_lookup_service (key, false);\n", "        if (!svc)\n", "            goto drop_no_service;\n", "        backend_id = lb4_select_backend_id (ctx, key, tuple, svc);\n", "        backend = lb4_lookup_backend (ctx, backend_id);\n", "        if (!backend)\n", "            goto drop_no_service;\n", "        state->backend_id = backend_id;\n", "        ct_update4_backend_id (map, tuple, state);\n", "    }\n", "update_state :\n", "    tuple->flags = flags;\n", "    state->rev_nat_index = svc->rev_nat_index;\n", "    state->addr = new_daddr = backend->address;\n", "\n", "#ifdef ENABLE_SESSION_AFFINITY\n", "    if (lb4_svc_is_affinity (svc))\n", "        lb4_update_affinity_by_addr (svc, &client_id, state->backend_id);\n", "\n", "#endif\n", "\n", "#ifndef DISABLE_LOOPBACK_LB\n", "    if (saddr == backend->address) {\n", "        new_saddr = IPV4_LOOPBACK;\n", "        state->loopback = 1;\n", "        state->addr = new_saddr;\n", "        state->svc_addr = saddr;\n", "    }\n", "    if (!state->loopback)\n", "\n", "#endif\n", "        tuple->daddr = backend->address;\n", "    return lb_skip_l4_dnat () ? CTX_ACT_OK : lb4_xlate (ctx, &new_daddr, &new_saddr, &saddr, tuple->nexthdr, l3_off, l4_off, csum_off, key, backend, has_l4_header, skip_l3_xlate);\n", "drop_no_service :\n", "    tuple->flags = flags;\n", "    return DROP_NO_SERVICE;\n", "}\n"], "called_function_list": ["lb4_svc_is_affinity", "lb4_lookup_backend", "lb4_lookup_service", "lb4_select_backend_id", "ct_lookup4", "lb4_xlate", "lb_skip_l4_dnat", "lb4_affinity_backend_id_by_addr", "lb4_update_affinity_by_addr", "ct_create4", "ct_update4_rev_nat_index", "ct_update4_backend_id"], "call_depth": 3, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "lb4_ctx_store_state": [{"capabilities": [], "helperCallParams": {}, "startLine": 1613, "endLine": 1621, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "lb4_ctx_store_state", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " const struct ct_state *state", " __u16 proxy_port"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void lb4_ctx_store_state (struct  __ctx_buff *ctx, const struct ct_state *state, __u16 proxy_port)\n", "{\n", "    ctx_store_meta (ctx, CB_PROXY_MAGIC, (__u32) proxy_port << 16);\n", "    ctx_store_meta (ctx, CB_BACKEND_ID, state->backend_id);\n", "    ctx_store_meta (ctx, CB_CT_STATE, (__u32) state->rev_nat_index << 16 | state->loopback);\n", "}\n"], "called_function_list": ["ctx_store_meta"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "lb4_ctx_restore_state": [{"capabilities": [], "helperCallParams": {}, "startLine": 1628, "endLine": 1651, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "funcName": "lb4_ctx_restore_state", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " struct ct_state *state", " __u32 daddr __maybe_unused", " __u16 *proxy_port"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void lb4_ctx_restore_state (struct  __ctx_buff *ctx, struct ct_state *state, __u32 daddr __maybe_unused, __u16 *proxy_port)\n", "{\n", "    __u32 meta = ctx_load_meta (ctx, CB_CT_STATE);\n", "\n", "#ifndef DISABLE_LOOPBACK_LB\n", "    if (meta & 1) {\n", "        state->loopback = 1;\n", "        state->addr = IPV4_LOOPBACK;\n", "        state->svc_addr = daddr;\n", "    }\n", "\n", "#endif\n", "    state->rev_nat_index = meta >> 16;\n", "    ctx_store_meta (ctx, CB_CT_STATE, 0);\n", "    state->backend_id = ctx_load_meta (ctx, CB_BACKEND_ID);\n", "    ctx_store_meta (ctx, CB_BACKEND_ID, 0);\n", "    *proxy_port = ctx_load_meta (ctx, CB_PROXY_MAGIC) >> 16;\n", "    ctx_store_meta (ctx, CB_PROXY_MAGIC, 0);\n", "}\n"], "called_function_list": ["ctx_store_meta", "ctx_load_meta"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "arp_check": [{"capabilities": [], "helperCallParams": {}, "startLine": 21, "endLine": 30, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/arp.h", "funcName": "arp_check", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct ethhdr *eth", " const struct arphdr *arp", " union macaddr *mac"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int arp_check (struct ethhdr *eth, const struct arphdr *arp, union macaddr *mac)\n", "{\n", "    union macaddr *dmac = (union macaddr *) &eth->h_dest;\n", "    return arp->ar_op == bpf_htons (ARPOP_REQUEST) && arp->ar_hrd == bpf_htons (ARPHRD_ETHER) && (eth_is_bcast (dmac) || !eth_addrcmp (dmac, mac));\n", "}\n"], "called_function_list": ["eth_is_bcast", "eth_addrcmp"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "arp_prepare_response": [{"capabilities": [], "helperCallParams": {}, "startLine": 32, "endLine": 49, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/arp.h", "funcName": "arp_prepare_response", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " union macaddr *smac", " __be32 sip", " union macaddr *dmac", " __be32 tip"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int arp_prepare_response (struct  __ctx_buff *ctx, union macaddr *smac, __be32 sip, union macaddr *dmac, __be32 tip)\n", "{\n", "    __be16 arpop = bpf_htons (ARPOP_REPLY);\n", "    if (eth_store_saddr (ctx, smac->addr, 0) < 0 || eth_store_daddr (ctx, dmac->addr, 0) < 0 || ctx_store_bytes (ctx, 20, &arpop, sizeof (arpop), 0) < 0 || ctx_store_bytes (ctx, 22, smac, ETH_ALEN, 0) < 0 || ctx_store_bytes (ctx, 28, &sip, sizeof (sip), 0) < 0 || ctx_store_bytes (ctx, 32, dmac, ETH_ALEN, 0) < 0 || ctx_store_bytes (ctx, 38, &tip, sizeof (tip), 0) < 0)\n", "        return DROP_WRITE_ERROR;\n", "    return 0;\n", "}\n"], "called_function_list": ["eth_store_daddr", "eth_store_saddr"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "arp_validate": [{"capabilities": [], "helperCallParams": {}, "startLine": 51, "endLine": 73, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/arp.h", "funcName": "arp_validate", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct  __ctx_buff *ctx", " union macaddr *mac", " union macaddr *smac", " __be32 *sip", " __be32 *tip"], "output": "static__always_inlinebool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline bool arp_validate (const struct  __ctx_buff *ctx, union macaddr *mac, union macaddr *smac, __be32 *sip, __be32 *tip)\n", "{\n", "    void *data_end = (void *) (long) ctx->data_end;\n", "    void *data = (void *) (long) ctx->data;\n", "    struct arphdr *arp = data + ETH_HLEN;\n", "    struct ethhdr *eth = data;\n", "    struct arp_eth *arp_eth;\n", "    if (data + ETH_HLEN + sizeof (*arp) + sizeof (*arp_eth) > data_end)\n", "        return false;\n", "    if (!arp_check (eth, arp, mac))\n", "        return false;\n", "    arp_eth = data + ETH_HLEN + sizeof (*arp);\n", "    *smac = *(unionmacaddr*) &eth->h_source;\n", "    *sip = arp_eth->ar_sip;\n", "    *tip = arp_eth->ar_tip;\n", "    return true;\n", "}\n"], "called_function_list": ["arp_check"], "call_depth": 3, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "arp_respond": [{"capabilities": [], "helperCallParams": {}, "startLine": 75, "endLine": 90, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/arp.h", "funcName": "arp_respond", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " union macaddr *smac", " __be32 sip", " union macaddr *dmac", " __be32 tip", " int direction"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int arp_respond (struct  __ctx_buff *ctx, union macaddr *smac, __be32 sip, union macaddr *dmac, __be32 tip, int direction)\n", "{\n", "    int ret = arp_prepare_response (ctx, smac, sip, dmac, tip);\n", "    if (unlikely (ret != 0))\n", "        goto error;\n", "    cilium_dbg_capture (ctx, DBG_CAPTURE_DELIVERY, ctx_get_ifindex (ctx));\n", "    return ctx_redirect (ctx, ctx_get_ifindex (ctx), direction);\n", "error :\n", "    return send_drop_notify_error (ctx, 0, ret, CTX_ACT_DROP, METRIC_EGRESS);\n", "}\n"], "called_function_list": ["ctx_get_ifindex", "cilium_dbg_capture", "ctx_redirect", "arp_prepare_response"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "csum_l4_offset_and_flags": [{"capabilities": [], "helperCallParams": {}, "startLine": 29, "endLine": 49, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/csum.h", "funcName": "csum_l4_offset_and_flags", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["__u8 nexthdr", " struct csum_offset *off"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void csum_l4_offset_and_flags (__u8 nexthdr, struct csum_offset *off)\n", "{\n", "    switch (nexthdr) {\n", "    case IPPROTO_TCP :\n", "        off->offset = TCP_CSUM_OFF;\n", "        break;\n", "    case IPPROTO_UDP :\n", "        off->offset = UDP_CSUM_OFF;\n", "        off->flags = BPF_F_MARK_MANGLED_0;\n", "        break;\n", "    case IPPROTO_ICMPV6 :\n", "        off->offset = offsetof (struct icmp6hdr, icmp6_cksum);\n", "        break;\n", "    case IPPROTO_ICMP :\n", "        break;\n", "    }\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "csum_l4_replace": [{"capabilities": [{"capability": "update_pkt", "update_pkt": [{"Project": "cilium", "Return Type": "int", "Description": "Recompute the layer 4 (e. g. TCP , UDP or ICMP) checksum for the packet associated <[ to ]>(IP: 3) skb. Computation is incremental , so the helper must know the former value of the header field that was modified (from) , the new value of this field (to) , and the number of bytes (2 or 4) for this field , stored on the lowest four bits of flags. Alternatively , it is possible <[ to ]>(IP: 3) store the difference between the previous and the new values of the header field in <[ to ]>(IP: 3) , by setting <[ from ]>(IP: 2) and the four lowest bits of <[ flags ]>(IP: 4) <[ to ]>(IP: 3) 0. For both methods , <[ offset ]>(IP: 1) indicates the location of the IP checksum within the packet. In addition <[ to ]>(IP: 3) the size of the field , <[ flags ]>(IP: 4) can be added (bitwise OR) actual flags. With BPF_F_MARK_MANGLED_0 , a null checksum is left untouched (unless BPF_F_MARK_ENFORCE is added as well) , and for updates resulting in a null checksum the value is set <[ to ]>(IP: 3) CSUM_MANGLED_0 instead. Flag BPF_F_PSEUDO_HDR indicates the checksum is <[ to ]>(IP: 3) be computed against a pseudo-header. This helper works in combination with csum_diff() , which does not update the checksum in-place , but offers more flexibility and can handle sizes larger than 2 or 4 for the checksum <[ to ]>(IP: 3) update. A call <[ to ]>(IP: 3) this helper is susceptible <[ to ]>(IP: 3) change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "l4_csum_replace", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  u32 ,Var: offset}", "{Type:  u64 ,Var: from}", "{Type:  u64 ,Var: to}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["sched_cls", "sched_act", "lwt_xmit"], "capabilities": ["update_pkt"]}]}], "helperCallParams": {}, "startLine": 60, "endLine": 65, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/csum.h", "funcName": "csum_l4_replace", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " __u64 l4_off", " const struct csum_offset *csum", " __be32 from", " __be32 to", " int flags"], "output": "static__always_inlineint", "helper": ["l4_csum_replace"], "compatibleHookpoints": ["lwt_xmit", "sched_cls", "sched_act"], "source": ["static __always_inline int csum_l4_replace (struct  __ctx_buff *ctx, __u64 l4_off, const struct csum_offset *csum, __be32 from, __be32 to, int flags)\n", "{\n", "    return l4_csum_replace (ctx, l4_off + csum->offset, from, to, flags | csum->flags);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "policy_verdict_filter_allow": [{"capabilities": [], "helperCallParams": {}, "startLine": 39, "endLine": 47, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/policy_log.h", "funcName": "policy_verdict_filter_allow", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["__u32 filter", " __u8 dir"], "output": "static__always_inlinebool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline bool policy_verdict_filter_allow (__u32 filter, __u8 dir)\n", "{\n", "    volatile __u8 d = dir;\n", "    return ((filter & d) > 0);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "send_policy_verdict_notify": [{"capabilities": [], "helperCallParams": {}, "startLine": 49, "endLine": 77, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/policy_log.h", "funcName": "send_policy_verdict_notify", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " __u32 remote_label", " __u16 dst_port", " __u8 proto", " __u8 dir", " __u8 is_ipv6", " int verdict", " __u8 match_type", " __u8 is_audited"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void send_policy_verdict_notify (struct  __ctx_buff *ctx, __u32 remote_label, __u16 dst_port, __u8 proto, __u8 dir, __u8 is_ipv6, int verdict, __u8 match_type, __u8 is_audited)\n", "{\n", "    __u64 ctx_len = ctx_full_len (ctx);\n", "    __u64 cap_len = min_t (__u64, TRACE_PAYLOAD_LEN, ctx_len);\n", "    struct policy_verdict_notify msg;\n", "    if (!policy_verdict_filter_allow (POLICY_VERDICT_LOG_FILTER, dir))\n", "        return;\n", "    msg = (typeof (msg)) {__notify_common_hdr (CILIUM_NOTIFY_POLICY_VERDICT, 0), __notify_pktcap_hdr (ctx_len, (__u16) cap_len),\n", "        .remote_label = remote_label,\n", "        .verdict = verdict,\n", "        .dst_port = bpf_ntohs (dst_port),\n", "        .match_type = match_type,\n", "        .proto = proto,\n", "        .dir = dir,\n", "        .ipv6 = is_ipv6,\n", "        .audited = is_audited,};\n", "    ctx_event_output (ctx, &EVENTS_MAP, (cap_len << 32) | BPF_F_CURRENT_CPU, &msg, sizeof (msg));\n", "}\n"], "called_function_list": ["ctx_full_len", "policy_verdict_filter_allow"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 79, "endLine": 86, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/policy_log.h", "funcName": "send_policy_verdict_notify", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff * ctx __maybe_unused", " __u32 remote_label __maybe_unused", " __u16 dst_port __maybe_unused", " __u8 proto __maybe_unused", " __u8 dir __maybe_unused", " __u8 is_ipv6 __maybe_unused", " int verdict __maybe_unused", " __u8 match_type __maybe_unused", " __u8 is_audited __maybe_unused"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void send_policy_verdict_notify (struct  __ctx_buff * ctx __maybe_unused, __u32 remote_label __maybe_unused, __u16 dst_port __maybe_unused, __u8 proto __maybe_unused, __u8 dir __maybe_unused, __u8 is_ipv6 __maybe_unused, int verdict __maybe_unused, __u8 match_type __maybe_unused, __u8 is_audited __maybe_unused)\n", "{\n", "}\n"], "called_function_list": ["ctx_full_len", "policy_verdict_filter_allow"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "eth_addrcmp": [{"capabilities": [], "helperCallParams": {}, "startLine": 25, "endLine": 35, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/eth.h", "funcName": "eth_addrcmp", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const union macaddr *a", " const union macaddr *b"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int eth_addrcmp (const union macaddr *a, const union macaddr *b)\n", "{\n", "    int tmp;\n", "    tmp = a->p1 - b->p1;\n", "    if (!tmp)\n", "        tmp = a->p2 - b->p2;\n", "    return tmp;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "eth_is_bcast": [{"capabilities": [], "helperCallParams": {}, "startLine": 37, "endLine": 48, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/eth.h", "funcName": "eth_is_bcast", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const union macaddr *a"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int eth_is_bcast (const union macaddr *a)\n", "{\n", "    union macaddr bcast;\n", "    bcast.p1 = 0xffffffff;\n", "    bcast.p2 = 0xffff;\n", "    if (!eth_addrcmp (a, &bcast))\n", "        return 1;\n", "    else\n", "        return 0;\n", "}\n"], "called_function_list": ["eth_addrcmp"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "eth_load_saddr": [{"capabilities": [], "helperCallParams": {}, "startLine": 50, "endLine": 54, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/eth.h", "funcName": "eth_load_saddr", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " __u8 *mac", " int off"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int eth_load_saddr (struct  __ctx_buff *ctx, __u8 *mac, int off)\n", "{\n", "    return ctx_load_bytes (ctx, off + ETH_ALEN, mac, ETH_ALEN);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "eth_store_saddr_aligned": [{"capabilities": [], "helperCallParams": {}, "startLine": 56, "endLine": 60, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/eth.h", "funcName": "eth_store_saddr_aligned", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " const __u8 *mac", " int off"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int eth_store_saddr_aligned (struct  __ctx_buff *ctx, const __u8 *mac, int off)\n", "{\n", "    return ctx_store_bytes (ctx, off + ETH_ALEN, mac, ETH_ALEN, 0);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "eth_store_saddr": [{"capabilities": [], "helperCallParams": {}, "startLine": 62, "endLine": 79, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/eth.h", "funcName": "eth_store_saddr", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " const __u8 *mac", " int off"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int eth_store_saddr (struct  __ctx_buff *ctx, const __u8 *mac, int off)\n", "{\n", "\n", "#if !CTX_DIRECT_WRITE_OK\n", "    return eth_store_saddr_aligned (ctx, mac, off);\n", "\n", "#else\n", "    void *data_end = ctx_data_end (ctx);\n", "    void *data = ctx_data (ctx);\n", "    if (ctx_no_room (data + off + ETH_ALEN * 2, data_end))\n", "        return -EFAULT;\n", "    __bpf_memcpy_builtin (data + off + ETH_ALEN, mac, ETH_ALEN);\n", "    return 0;\n", "\n", "#endif\n", "}\n"], "called_function_list": ["ctx_data_end", "eth_store_saddr_aligned", "ctx_no_room", "ctx_data", "__bpf_memcpy_builtin"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "eth_load_daddr": [{"capabilities": [], "helperCallParams": {}, "startLine": 81, "endLine": 85, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/eth.h", "funcName": "eth_load_daddr", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " __u8 *mac", " int off"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int eth_load_daddr (struct  __ctx_buff *ctx, __u8 *mac, int off)\n", "{\n", "    return ctx_load_bytes (ctx, off, mac, ETH_ALEN);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "eth_store_daddr_aligned": [{"capabilities": [], "helperCallParams": {}, "startLine": 87, "endLine": 91, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/eth.h", "funcName": "eth_store_daddr_aligned", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " const __u8 *mac", " int off"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int eth_store_daddr_aligned (struct  __ctx_buff *ctx, const __u8 *mac, int off)\n", "{\n", "    return ctx_store_bytes (ctx, off, mac, ETH_ALEN, 0);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "eth_store_daddr": [{"capabilities": [], "helperCallParams": {}, "startLine": 93, "endLine": 110, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/eth.h", "funcName": "eth_store_daddr", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " const __u8 *mac", " int off"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int eth_store_daddr (struct  __ctx_buff *ctx, const __u8 *mac, int off)\n", "{\n", "\n", "#if !CTX_DIRECT_WRITE_OK\n", "    return eth_store_daddr_aligned (ctx, mac, off);\n", "\n", "#else\n", "    void *data_end = ctx_data_end (ctx);\n", "    void *data = ctx_data (ctx);\n", "    if (ctx_no_room (data + off + ETH_ALEN, data_end))\n", "        return -EFAULT;\n", "    __bpf_memcpy_builtin (data + off, mac, ETH_ALEN);\n", "    return 0;\n", "\n", "#endif\n", "}\n"], "called_function_list": ["ctx_data_end", "eth_store_daddr_aligned", "ctx_no_room", "ctx_data", "__bpf_memcpy_builtin"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "eth_store_proto": [{"capabilities": [], "helperCallParams": {}, "startLine": 112, "endLine": 117, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/eth.h", "funcName": "eth_store_proto", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " const __u16 proto", " int off"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int eth_store_proto (struct  __ctx_buff *ctx, const __u16 proto, int off)\n", "{\n", "    return ctx_store_bytes (ctx, off + ETH_ALEN + ETH_ALEN, &proto, sizeof (proto), 0);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "is_v4_in_v6": [{"capabilities": [], "helperCallParams": {}, "startLine": 22, "endLine": 35, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat_46x64.h", "funcName": "is_v4_in_v6", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const union v6addr *daddr"], "output": "static__always_inline__maybe_unusedbool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused bool is_v4_in_v6 (const union v6addr *daddr)\n", "{\n", "    union v6addr dprobe = {\n", "        .addr [10] = 0xff,\n", "        .addr [11] = 0xff,}\n", "    ;\n", "    union v6addr dmasked = {\n", "        .d1 = daddr->d1,}\n", "    ;\n", "    dmasked.p3 = daddr->p3;\n", "    return ipv6_addrcmp (&dprobe, &dmasked) == 0;\n", "}\n"], "called_function_list": ["ipv6_addrcmp"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "build_v4_in_v6": [{"capabilities": [], "helperCallParams": {}, "startLine": 37, "endLine": 44, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat_46x64.h", "funcName": "build_v4_in_v6", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["union v6addr *daddr", " __be32 v4"], "output": "static__always_inline__maybe_unusedvoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused void build_v4_in_v6 (union v6addr *daddr, __be32 v4)\n", "{\n", "    memset (daddr, 0, sizeof (*daddr));\n", "    daddr->addr[10] = 0xff;\n", "    daddr->addr[11] = 0xff;\n", "    daddr->p4 = v4;\n", "}\n"], "called_function_list": ["memset"], "call_depth": 3, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "build_v4_from_v6": [{"capabilities": [], "helperCallParams": {}, "startLine": 46, "endLine": 50, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat_46x64.h", "funcName": "build_v4_from_v6", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const union v6addr *v6", " __be32 *daddr"], "output": "static__always_inline__maybe_unusedvoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused void build_v4_from_v6 (const union v6addr *v6, __be32 *daddr)\n", "{\n", "    *daddr = v6->p4;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "get_csum_offset": [{"capabilities": [], "helperCallParams": {}, "startLine": 52, "endLine": 74, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat_46x64.h", "funcName": "get_csum_offset", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["__u8 protocol"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int get_csum_offset (__u8 protocol)\n", "{\n", "    int csum_off;\n", "    switch (protocol) {\n", "    case IPPROTO_TCP :\n", "        csum_off = TCP_CSUM_OFF;\n", "        break;\n", "    case IPPROTO_UDP :\n", "        csum_off = UDP_CSUM_OFF;\n", "        break;\n", "    case IPPROTO_ICMP :\n", "        csum_off = (offsetof (struct icmphdr, checksum));\n", "        break;\n", "    case IPPROTO_ICMPV6 :\n", "        csum_off = (offsetof (struct icmp6hdr, icmp6_cksum));\n", "        break;\n", "    default :\n", "        return DROP_UNKNOWN_L4;\n", "    }\n", "    return csum_off;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "icmp4_to_icmp6": [{"capabilities": [{"capability": "read_skb", "read_skb": [{"Project": "cilium", "Return Type": "s64", "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ", "Return": " The checksum result, or a negative error code in case of failure.", "Function Name": "csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp", "lwt_in", "lwt_out", "lwt_xmit", "lwt_seg6local"], "capabilities": ["read_skb"]}]}], "helperCallParams": {}, "startLine": 76, "endLine": 154, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat_46x64.h", "funcName": "icmp4_to_icmp6", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " int nh_off"], "output": "static__always_inlineint", "helper": ["csum_diff"], "compatibleHookpoints": ["sched_cls", "lwt_xmit", "xdp", "lwt_in", "sched_act", "lwt_out", "lwt_seg6local"], "source": ["static __always_inline int icmp4_to_icmp6 (struct  __ctx_buff *ctx, int nh_off)\n", "{\n", "    struct icmphdr icmp4 __align_stack_8;\n", "    struct icmp6hdr icmp6 __align_stack_8 = {}\n", "    ;\n", "    if (ctx_load_bytes (ctx, nh_off, &icmp4, sizeof (icmp4)) < 0)\n", "        return DROP_INVALID;\n", "    icmp6.icmp6_cksum = icmp4.checksum;\n", "    switch (icmp4.type) {\n", "    case ICMP_ECHO :\n", "        icmp6.icmp6_type = ICMPV6_ECHO_REQUEST;\n", "        icmp6.icmp6_identifier = icmp4.un.echo.id;\n", "        icmp6.icmp6_sequence = icmp4.un.echo.sequence;\n", "        break;\n", "    case ICMP_ECHOREPLY :\n", "        icmp6.icmp6_type = ICMPV6_ECHO_REPLY;\n", "        icmp6.icmp6_identifier = icmp4.un.echo.id;\n", "        icmp6.icmp6_sequence = icmp4.un.echo.sequence;\n", "        break;\n", "    case ICMP_DEST_UNREACH :\n", "        icmp6.icmp6_type = ICMPV6_DEST_UNREACH;\n", "        switch (icmp4.code) {\n", "        case ICMP_NET_UNREACH :\n", "        case ICMP_HOST_UNREACH :\n", "            icmp6.icmp6_code = ICMPV6_NOROUTE;\n", "            break;\n", "        case ICMP_PROT_UNREACH :\n", "            icmp6.icmp6_type = ICMPV6_PARAMPROB;\n", "            icmp6.icmp6_code = ICMPV6_UNK_NEXTHDR;\n", "            icmp6.icmp6_pointer = 6;\n", "            break;\n", "        case ICMP_PORT_UNREACH :\n", "            icmp6.icmp6_code = ICMPV6_PORT_UNREACH;\n", "            break;\n", "        case ICMP_FRAG_NEEDED :\n", "            icmp6.icmp6_type = ICMPV6_PKT_TOOBIG;\n", "            icmp6.icmp6_code = 0;\n", "            if (icmp4.un.frag.mtu)\n", "                icmp6.icmp6_mtu = bpf_htonl (bpf_ntohs (icmp4.un.frag.mtu));\n", "            else\n", "                icmp6.icmp6_mtu = bpf_htonl (1500);\n", "            break;\n", "        case ICMP_SR_FAILED :\n", "            icmp6.icmp6_code = ICMPV6_NOROUTE;\n", "            break;\n", "        case ICMP_NET_UNKNOWN :\n", "        case ICMP_HOST_UNKNOWN :\n", "        case ICMP_HOST_ISOLATED :\n", "        case ICMP_NET_UNR_TOS :\n", "        case ICMP_HOST_UNR_TOS :\n", "            icmp6.icmp6_code = 0;\n", "            break;\n", "        case ICMP_NET_ANO :\n", "        case ICMP_HOST_ANO :\n", "        case ICMP_PKT_FILTERED :\n", "            icmp6.icmp6_code = ICMPV6_ADM_PROHIBITED;\n", "            break;\n", "        default :\n", "            return DROP_UNKNOWN_ICMP_CODE;\n", "        }\n", "        break;\n", "    case ICMP_TIME_EXCEEDED :\n", "        icmp6.icmp6_type = ICMPV6_TIME_EXCEED;\n", "        break;\n", "    case ICMP_PARAMETERPROB :\n", "        icmp6.icmp6_type = ICMPV6_PARAMPROB;\n", "        icmp6.icmp6_pointer = 6;\n", "        break;\n", "    default :\n", "        return DROP_UNKNOWN_ICMP_TYPE;\n", "    }\n", "    if (ctx_store_bytes (ctx, nh_off, &icmp6, sizeof (icmp6), 0) < 0)\n", "        return DROP_WRITE_ERROR;\n", "    icmp4.checksum = 0;\n", "    icmp6.icmp6_cksum = 0;\n", "    return csum_diff (&icmp4, sizeof (icmp4), &icmp6, sizeof (icmp6), 0);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "icmp6_to_icmp4": [{"capabilities": [{"capability": "read_skb", "read_skb": [{"Project": "cilium", "Return Type": "s64", "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ", "Return": " The checksum result, or a negative error code in case of failure.", "Function Name": "csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp", "lwt_in", "lwt_out", "lwt_xmit", "lwt_seg6local"], "capabilities": ["read_skb"]}]}], "helperCallParams": {}, "startLine": 156, "endLine": 231, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat_46x64.h", "funcName": "icmp6_to_icmp4", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " int nh_off"], "output": "static__always_inlineint", "helper": ["csum_diff"], "compatibleHookpoints": ["sched_cls", "lwt_xmit", "xdp", "lwt_in", "sched_act", "lwt_out", "lwt_seg6local"], "source": ["static __always_inline int icmp6_to_icmp4 (struct  __ctx_buff *ctx, int nh_off)\n", "{\n", "    struct icmphdr icmp4 __align_stack_8 = {}\n", "    ;\n", "    struct icmp6hdr icmp6 __align_stack_8;\n", "    __u32 mtu;\n", "    if (ctx_load_bytes (ctx, nh_off, &icmp6, sizeof (icmp6)) < 0)\n", "        return DROP_INVALID;\n", "    icmp4.checksum = icmp6.icmp6_cksum;\n", "    switch (icmp6.icmp6_type) {\n", "    case ICMPV6_ECHO_REQUEST :\n", "        icmp4.type = ICMP_ECHO;\n", "        icmp4.un.echo.id = icmp6.icmp6_identifier;\n", "        icmp4.un.echo.sequence = icmp6.icmp6_sequence;\n", "        break;\n", "    case ICMPV6_ECHO_REPLY :\n", "        icmp4.type = ICMP_ECHOREPLY;\n", "        icmp4.un.echo.id = icmp6.icmp6_identifier;\n", "        icmp4.un.echo.sequence = icmp6.icmp6_sequence;\n", "        break;\n", "    case ICMPV6_DEST_UNREACH :\n", "        icmp4.type = ICMP_DEST_UNREACH;\n", "        switch (icmp6.icmp6_code) {\n", "        case ICMPV6_NOROUTE :\n", "        case ICMPV6_NOT_NEIGHBOUR :\n", "        case ICMPV6_ADDR_UNREACH :\n", "            icmp4.code = ICMP_HOST_UNREACH;\n", "            break;\n", "        case ICMPV6_ADM_PROHIBITED :\n", "            icmp4.code = ICMP_HOST_ANO;\n", "            break;\n", "        case ICMPV6_PORT_UNREACH :\n", "            icmp4.code = ICMP_PORT_UNREACH;\n", "            break;\n", "        default :\n", "            return DROP_UNKNOWN_ICMP6_CODE;\n", "        }\n", "        break;\n", "    case ICMPV6_PKT_TOOBIG :\n", "        icmp4.type = ICMP_DEST_UNREACH;\n", "        icmp4.code = ICMP_FRAG_NEEDED;\n", "        if (icmp6.icmp6_mtu) {\n", "            mtu = bpf_ntohl (icmp6.icmp6_mtu);\n", "            icmp4.un.frag.mtu = bpf_htons ((__u16) mtu);\n", "        }\n", "        else {\n", "            icmp4.un.frag.mtu = bpf_htons (1500);\n", "        }\n", "        break;\n", "    case ICMPV6_TIME_EXCEED :\n", "        icmp4.type = ICMP_TIME_EXCEEDED;\n", "        icmp4.code = icmp6.icmp6_code;\n", "        break;\n", "    case ICMPV6_PARAMPROB :\n", "        switch (icmp6.icmp6_code) {\n", "        case ICMPV6_HDR_FIELD :\n", "            icmp4.type = ICMP_PARAMETERPROB;\n", "            icmp4.code = 0;\n", "            break;\n", "        case ICMPV6_UNK_NEXTHDR :\n", "            icmp4.type = ICMP_DEST_UNREACH;\n", "            icmp4.code = ICMP_PROT_UNREACH;\n", "            break;\n", "        default :\n", "            return DROP_UNKNOWN_ICMP6_CODE;\n", "        }\n", "        break;\n", "    default :\n", "        return DROP_UNKNOWN_ICMP6_TYPE;\n", "    }\n", "    if (ctx_store_bytes (ctx, nh_off, &icmp4, sizeof (icmp4), 0) < 0)\n", "        return DROP_WRITE_ERROR;\n", "    icmp4.checksum = 0;\n", "    icmp6.icmp6_cksum = 0;\n", "    return csum_diff (&icmp6, sizeof (icmp6), &icmp4, sizeof (icmp4), 0);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ipv4_to_ipv6": [{"capabilities": [{"capability": "read_skb", "read_skb": [{"Project": "cilium", "Return Type": "s64", "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ", "Return": " The checksum result, or a negative error code in case of failure.", "Function Name": "csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp", "lwt_in", "lwt_out", "lwt_xmit", "lwt_seg6local"], "capabilities": ["read_skb"]}]}], "helperCallParams": {}, "startLine": 233, "endLine": 288, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat_46x64.h", "funcName": "ipv4_to_ipv6", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " int nh_off", " const union v6addr *src6", " const union v6addr *dst6"], "output": "static__always_inlineint", "helper": ["csum_diff"], "compatibleHookpoints": ["sched_cls", "lwt_xmit", "xdp", "lwt_in", "sched_act", "lwt_out", "lwt_seg6local"], "source": ["static __always_inline int ipv4_to_ipv6 (struct  __ctx_buff *ctx, int nh_off, const union v6addr *src6, const union v6addr *dst6)\n", "{\n", "    __be16 protocol = bpf_htons (ETH_P_IPV6);\n", "    __u64 csum_flags = BPF_F_PSEUDO_HDR;\n", "    struct ipv6hdr v6 = {}\n", "    ;\n", "    struct iphdr v4;\n", "    int csum_off;\n", "    __be32 csum;\n", "    __be16 v4hdr_len;\n", "    if (ctx_load_bytes (ctx, nh_off, &v4, sizeof (v4)) < 0)\n", "        return DROP_INVALID;\n", "    if (ipv4_hdrlen (&v4) != sizeof (v4))\n", "        return DROP_INVALID_EXTHDR;\n", "    v6.version = 0x6;\n", "    v6.saddr.in6_u.u6_addr32[0] = src6->p1;\n", "    v6.saddr.in6_u.u6_addr32[1] = src6->p2;\n", "    v6.saddr.in6_u.u6_addr32[2] = src6->p3;\n", "    v6.saddr.in6_u.u6_addr32[3] = src6->p4;\n", "    v6.daddr.in6_u.u6_addr32[0] = dst6->p1;\n", "    v6.daddr.in6_u.u6_addr32[1] = dst6->p2;\n", "    v6.daddr.in6_u.u6_addr32[2] = dst6->p3;\n", "    v6.daddr.in6_u.u6_addr32[3] = dst6->p4;\n", "    if (v4.protocol == IPPROTO_ICMP)\n", "        v6.nexthdr = IPPROTO_ICMPV6;\n", "    else\n", "        v6.nexthdr = v4.protocol;\n", "    v6.hop_limit = v4.ttl;\n", "    v4hdr_len = (__be16) (v4.ihl << 2);\n", "    v6.payload_len = bpf_htons (bpf_ntohs (v4.tot_len) - v4hdr_len);\n", "    if (ctx_change_proto (ctx, bpf_htons (ETH_P_IPV6), 0) < 0)\n", "        return DROP_WRITE_ERROR;\n", "    if (ctx_store_bytes (ctx, nh_off, &v6, sizeof (v6), 0) < 0 || ctx_store_bytes (ctx, nh_off - 2, &protocol, 2, 0) < 0)\n", "        return DROP_WRITE_ERROR;\n", "    if (v4.protocol == IPPROTO_ICMP) {\n", "        csum = icmp4_to_icmp6 (ctx, nh_off + sizeof (v6));\n", "        csum = ipv6_pseudohdr_checksum (& v6, IPPROTO_ICMPV6, bpf_ntohs (v6.payload_len), csum);\n", "    }\n", "    else {\n", "        csum = 0;\n", "        csum = csum_diff (& v4.saddr, 4, & v6.saddr, 16, csum);\n", "        csum = csum_diff (& v4.daddr, 4, & v6.daddr, 16, csum);\n", "        if (v4.protocol == IPPROTO_UDP)\n", "            csum_flags |= BPF_F_MARK_MANGLED_0;\n", "    }\n", "    csum_off = get_csum_offset (v6.nexthdr);\n", "    if (csum_off < 0)\n", "        return csum_off;\n", "    csum_off += sizeof (struct ipv6hdr);\n", "    if (l4_csum_replace (ctx, nh_off + csum_off, 0, csum, csum_flags) < 0)\n", "        return DROP_CSUM_L4;\n", "    return 0;\n", "}\n"], "called_function_list": ["ctx_change_proto", "get_csum_offset", "ipv6_pseudohdr_checksum", "ipv4_hdrlen", "icmp4_to_icmp6"], "call_depth": 3, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ipv6_to_ipv4": [{"capabilities": [{"capability": "read_skb", "read_skb": [{"Project": "cilium", "Return Type": "s64", "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ", "Return": " The checksum result, or a negative error code in case of failure.", "Function Name": "csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp", "lwt_in", "lwt_out", "lwt_xmit", "lwt_seg6local"], "capabilities": ["read_skb"]}]}], "helperCallParams": {}, "startLine": 290, "endLine": 345, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat_46x64.h", "funcName": "ipv6_to_ipv4", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " __be32 src4", " __be32 dst4"], "output": "static__always_inlineint", "helper": ["csum_diff"], "compatibleHookpoints": ["sched_cls", "lwt_xmit", "xdp", "lwt_in", "sched_act", "lwt_out", "lwt_seg6local"], "source": ["static __always_inline int ipv6_to_ipv4 (struct  __ctx_buff *ctx, __be32 src4, __be32 dst4)\n", "{\n", "    __be16 protocol = bpf_htons (ETH_P_IP);\n", "    __u64 csum_flags = BPF_F_PSEUDO_HDR;\n", "    int csum_off, nh_off = ETH_HLEN;\n", "    struct ipv6hdr v6;\n", "    struct iphdr v4 = {}\n", "    ;\n", "    __be32 csum = 0;\n", "    if (ctx_load_bytes (ctx, nh_off, &v6, sizeof (v6)) < 0)\n", "        return DROP_INVALID;\n", "    if (ipv6_hdrlen (ctx, &v6.nexthdr) != sizeof (v6))\n", "        return DROP_INVALID_EXTHDR;\n", "    v4.ihl = 0x5;\n", "    v4.version = 0x4;\n", "    v4.saddr = src4;\n", "    v4.daddr = dst4;\n", "    if (v6.nexthdr == IPPROTO_ICMPV6)\n", "        v4.protocol = IPPROTO_ICMP;\n", "    else\n", "        v4.protocol = v6.nexthdr;\n", "    v4.ttl = v6.hop_limit;\n", "    v4.tot_len = bpf_htons (bpf_ntohs (v6.payload_len) + sizeof (v4));\n", "    csum_off = offsetof (struct iphdr, check);\n", "    csum = csum_diff (NULL, 0, & v4, sizeof (v4), csum);\n", "    if (ctx_change_proto (ctx, bpf_htons (ETH_P_IP), 0) < 0)\n", "        return DROP_WRITE_ERROR;\n", "    if (ctx_store_bytes (ctx, nh_off, &v4, sizeof (v4), 0) < 0 || ctx_store_bytes (ctx, nh_off - 2, &protocol, 2, 0) < 0)\n", "        return DROP_WRITE_ERROR;\n", "    if (l3_csum_replace (ctx, nh_off + csum_off, 0, csum, 0) < 0)\n", "        return DROP_CSUM_L3;\n", "    if (v6.nexthdr == IPPROTO_ICMPV6) {\n", "        __be32 csum1 = 0;\n", "        csum = icmp6_to_icmp4 (ctx, nh_off + sizeof (v4));\n", "        csum1 = ipv6_pseudohdr_checksum (& v6, IPPROTO_ICMPV6, bpf_ntohs (v6.payload_len), 0);\n", "        csum = csum_sub (csum, csum1);\n", "    }\n", "    else {\n", "        csum = 0;\n", "        csum = csum_diff (& v6.saddr, 16, & v4.saddr, 4, csum);\n", "        csum = csum_diff (& v6.daddr, 16, & v4.daddr, 4, csum);\n", "        if (v4.protocol == IPPROTO_UDP)\n", "            csum_flags |= BPF_F_MARK_MANGLED_0;\n", "    }\n", "    csum_off = get_csum_offset (v4.protocol);\n", "    if (csum_off < 0)\n", "        return csum_off;\n", "    csum_off += sizeof (struct iphdr);\n", "    if (l4_csum_replace (ctx, nh_off + csum_off, 0, csum, csum_flags) < 0)\n", "        return DROP_CSUM_L4;\n", "    return 0;\n", "}\n"], "called_function_list": ["ctx_change_proto", "get_csum_offset", "csum_sub", "icmp6_to_icmp4", "ipv6_pseudohdr_checksum", "ipv6_hdrlen"], "call_depth": 3, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__snat_clamp_port_range": [{"capabilities": [], "helperCallParams": {}, "startLine": 51, "endLine": 55, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "funcName": "__snat_clamp_port_range", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["__u16 start", " __u16 end", " __u16 val"], "output": "static__always_inline__be16", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __be16 __snat_clamp_port_range (__u16 start, __u16 end, __u16 val)\n", "{\n", "    return (val % (__u16) (end - start)) + start;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__snat_try_keep_port": [{"capabilities": [], "helperCallParams": {}, "startLine": 57, "endLine": 62, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "funcName": "__snat_try_keep_port", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["__u16 start", " __u16 end", " __u16 val"], "output": "static__always_inline__maybe_unused__be16", "helper": ["get_prandom_u32"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused __be16 __snat_try_keep_port (__u16 start, __u16 end, __u16 val)\n", "{\n", "    return val >= start && val <= end ? val : __snat_clamp_port_range (start, end, (__u16) get_prandom_u32 ());\n", "}\n"], "called_function_list": ["__snat_clamp_port_range"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__snat_lookup": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 64, "endLine": 68, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "funcName": "__snat_lookup", "developer_inline_comments": [], "updateMaps": [], "readMaps": [" map"], "input": ["const void *map", " const void *tuple"], "output": "static__always_inline__maybe_unusedvoid", "helper": ["map_lookup_elem"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused void *__snat_lookup (const void *map, const void *tuple)\n", "{\n", "    return map_lookup_elem (map, tuple);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__snat_update": [{"capabilities": [{"capability": "map_update", "map_update": [{"Project": "cilium", "Return Type": "int", "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "map_update_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}", "{Type:  const void ,Var: *value}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_update"]}]}], "helperCallParams": {}, "startLine": 70, "endLine": 83, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "funcName": "__snat_update", "developer_inline_comments": [], "updateMaps": [" map"], "readMaps": [], "input": ["const void *map", " const void *otuple", " const void *ostate", " const void *rtuple", " const void *rstate"], "output": "static__always_inline__maybe_unusedint", "helper": ["map_delete_elem", "map_update_elem"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused int __snat_update (const void *map, const void *otuple, const void *ostate, const void *rtuple, const void *rstate)\n", "{\n", "    int ret;\n", "    ret = map_update_elem (map, rtuple, rstate, BPF_NOEXIST);\n", "    if (!ret) {\n", "        ret = map_update_elem (map, otuple, ostate, BPF_NOEXIST);\n", "        if (ret)\n", "            map_delete_elem (map, rtuple);\n", "    }\n", "    return ret;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__snat_delete": [{"capabilities": [], "helperCallParams": {}, "startLine": 85, "endLine": 90, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "funcName": "__snat_delete", "developer_inline_comments": [], "updateMaps": [" map"], "readMaps": [], "input": ["const void *map", " const void *otuple", " const void *rtuple"], "output": "static__always_inline__maybe_unusedvoid", "helper": ["map_delete_elem"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused void __snat_delete (const void *map, const void *otuple, const void *rtuple)\n", "{\n", "    map_delete_elem (map, otuple);\n", "    map_delete_elem (map, rtuple);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "snat_v4_lookup": [{"capabilities": [], "helperCallParams": {}, "startLine": 136, "endLine": 140, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "funcName": "snat_v4_lookup", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct ipv4_ct_tuple *tuple"], "output": "static__always_inlinestructipv4_nat_entry", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline struct ipv4_nat_entry *snat_v4_lookup (const struct ipv4_ct_tuple *tuple)\n", "{\n", "    return __snat_lookup (&SNAT_MAPPING_IPV4, tuple);\n", "}\n"], "called_function_list": ["__snat_lookup"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "snat_v4_update": [{"capabilities": [], "helperCallParams": {}, "startLine": 142, "endLine": 149, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "funcName": "snat_v4_update", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct ipv4_ct_tuple *otuple", " const struct ipv4_nat_entry *ostate", " const struct ipv4_ct_tuple *rtuple", " const struct ipv4_nat_entry *rstate"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int snat_v4_update (const struct ipv4_ct_tuple *otuple, const struct ipv4_nat_entry *ostate, const struct ipv4_ct_tuple *rtuple, const struct ipv4_nat_entry *rstate)\n", "{\n", "    return __snat_update (&SNAT_MAPPING_IPV4, otuple, ostate, rtuple, rstate);\n", "}\n"], "called_function_list": ["__snat_update"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "snat_v4_delete": [{"capabilities": [], "helperCallParams": {}, "startLine": 151, "endLine": 155, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "funcName": "snat_v4_delete", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct ipv4_ct_tuple *otuple", " const struct ipv4_ct_tuple *rtuple"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void snat_v4_delete (const struct ipv4_ct_tuple *otuple, const struct ipv4_ct_tuple *rtuple)\n", "{\n", "    __snat_delete (&SNAT_MAPPING_IPV4, otuple, rtuple);\n", "}\n"], "called_function_list": ["__snat_delete"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "snat_v4_swap_tuple": [{"capabilities": [], "helperCallParams": {}, "startLine": 157, "endLine": 168, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "funcName": "snat_v4_swap_tuple", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct ipv4_ct_tuple *otuple", " struct ipv4_ct_tuple *rtuple"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void snat_v4_swap_tuple (const struct ipv4_ct_tuple *otuple, struct ipv4_ct_tuple *rtuple)\n", "{\n", "    memset (rtuple, 0, sizeof (*rtuple));\n", "    rtuple->nexthdr = otuple->nexthdr;\n", "    rtuple->daddr = otuple->saddr;\n", "    rtuple->saddr = otuple->daddr;\n", "    rtuple->dport = otuple->sport;\n", "    rtuple->sport = otuple->dport;\n", "    rtuple->flags = otuple->flags == NAT_DIR_EGRESS ? NAT_DIR_INGRESS : NAT_DIR_EGRESS;\n", "}\n"], "called_function_list": ["memset"], "call_depth": 3, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "snat_v4_reverse_tuple": [{"capabilities": [], "helperCallParams": {}, "startLine": 170, "endLine": 183, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "funcName": "snat_v4_reverse_tuple", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct ipv4_ct_tuple *otuple", " struct ipv4_ct_tuple *rtuple"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int snat_v4_reverse_tuple (const struct ipv4_ct_tuple *otuple, struct ipv4_ct_tuple *rtuple)\n", "{\n", "    struct ipv4_nat_entry *ostate;\n", "    ostate = snat_v4_lookup (otuple);\n", "    if (ostate) {\n", "        snat_v4_swap_tuple (otuple, rtuple);\n", "        rtuple->daddr = ostate->to_saddr;\n", "        rtuple->dport = ostate->to_sport;\n", "    }\n", "    return ostate ? 0 : -1;\n", "}\n"], "called_function_list": ["snat_v4_swap_tuple", "snat_v4_lookup"], "call_depth": 4, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "snat_v4_ct_canonicalize": [{"capabilities": [], "helperCallParams": {}, "startLine": 185, "endLine": 193, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "funcName": "snat_v4_ct_canonicalize", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct ipv4_ct_tuple *otuple"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void snat_v4_ct_canonicalize (struct ipv4_ct_tuple *otuple)\n", "{\n", "    __be32 addr = otuple->saddr;\n", "    otuple->flags = NAT_DIR_EGRESS;\n", "    otuple->saddr = otuple->daddr;\n", "    otuple->daddr = addr;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "snat_v4_delete_tuples": [{"capabilities": [], "helperCallParams": {}, "startLine": 195, "endLine": 204, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "funcName": "snat_v4_delete_tuples", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct ipv4_ct_tuple *otuple"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void snat_v4_delete_tuples (struct ipv4_ct_tuple *otuple)\n", "{\n", "    struct ipv4_ct_tuple rtuple;\n", "    if (otuple->flags & TUPLE_F_IN)\n", "        return;\n", "    snat_v4_ct_canonicalize (otuple);\n", "    if (!snat_v4_reverse_tuple (otuple, &rtuple))\n", "        snat_v4_delete (otuple, &rtuple);\n", "}\n"], "called_function_list": ["snat_v4_ct_canonicalize", "snat_v4_reverse_tuple", "snat_v4_delete"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 583, "endLine": 586, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "funcName": "snat_v4_delete_tuples", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct ipv4_ct_tuple * tuple __maybe_unused"], "output": "static__always_inline__maybe_unusedvoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused void snat_v4_delete_tuples (struct ipv4_ct_tuple * tuple __maybe_unused)\n", "{\n", "}\n"], "called_function_list": ["snat_v4_ct_canonicalize", "snat_v4_reverse_tuple", "snat_v4_delete"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "snat_v4_new_mapping": [{"capabilities": [], "helperCallParams": {}, "startLine": 206, "endLine": 258, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "funcName": "snat_v4_new_mapping", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " struct ipv4_ct_tuple *otuple", " struct ipv4_nat_entry *ostate", " const struct ipv4_nat_target *target"], "output": "static__always_inlineint", "helper": ["send_signal", "get_prandom_u32"], "compatibleHookpoints": ["kprobe", "raw_tracepoint", "raw_tracepoint_writable", "perf_event", "tracepoint"], "source": ["static __always_inline int snat_v4_new_mapping (struct  __ctx_buff *ctx, struct ipv4_ct_tuple *otuple, struct ipv4_nat_entry *ostate, const struct ipv4_nat_target *target)\n", "{\n", "    int ret = DROP_NAT_NO_MAPPING, retries;\n", "    struct ipv4_nat_entry rstate;\n", "    struct ipv4_ct_tuple rtuple;\n", "    __u16 port;\n", "    memset (&rstate, 0, sizeof (rstate));\n", "    memset (ostate, 0, sizeof (*ostate));\n", "    rstate.to_daddr = otuple->saddr;\n", "    rstate.to_dport = otuple->sport;\n", "    ostate->to_saddr = target->addr;\n", "    snat_v4_swap_tuple (otuple, &rtuple);\n", "    port = __snat_try_keep_port (target -> min_port, target -> max_port, bpf_ntohs (otuple -> sport));\n", "    rtuple.dport = ostate->to_sport = bpf_htons (port);\n", "    rtuple.daddr = target->addr;\n", "    if (otuple->saddr == target->addr) {\n", "        ostate->common.host_local = 1;\n", "        rstate.common.host_local = ostate->common.host_local;\n", "    }\n", "\n", "#pragma unroll\n", "    for (retries = 0; retries < SNAT_COLLISION_RETRIES; retries++) {\n", "        if (!snat_v4_lookup (&rtuple)) {\n", "            ostate->common.created = bpf_mono_now ();\n", "            rstate.common.created = ostate->common.created;\n", "            ret = snat_v4_update (otuple, ostate, & rtuple, & rstate);\n", "            if (!ret)\n", "                break;\n", "        }\n", "        port = __snat_clamp_port_range (target -> min_port, target -> max_port, retries ? port + 1 : (__u16) get_prandom_u32 ());\n", "        rtuple.dport = ostate->to_sport = bpf_htons (port);\n", "    }\n", "    if (retries > SNAT_SIGNAL_THRES)\n", "        send_signal_nat_fill_up (ctx, SIGNAL_PROTO_V4);\n", "    return !ret ? 0 : DROP_NAT_NO_MAPPING;\n", "}\n"], "called_function_list": ["__snat_try_keep_port", "snat_v4_update", "snat_v4_swap_tuple", "send_signal_nat_fill_up", "snat_v4_lookup", "__snat_clamp_port_range", "memset"], "call_depth": 4, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "snat_v4_track_local": [{"capabilities": [], "helperCallParams": {}, "startLine": 260, "endLine": 299, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "funcName": "snat_v4_track_local", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " const struct ipv4_ct_tuple *tuple", " const struct ipv4_nat_entry *state", " enum nat_dir dir", " __u32 off", " const struct ipv4_nat_target *target"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int snat_v4_track_local (struct  __ctx_buff *ctx, const struct ipv4_ct_tuple *tuple, const struct ipv4_nat_entry *state, enum nat_dir dir, __u32 off, const struct ipv4_nat_target *target)\n", "{\n", "    struct ct_state ct_state;\n", "    struct ipv4_ct_tuple tmp;\n", "    bool needs_ct = false;\n", "    __u32 monitor = 0;\n", "    enum ct_dir where;\n", "    int ret;\n", "    if (state && state->common.host_local) {\n", "        needs_ct = true;\n", "    }\n", "    else if (!state && dir == NAT_DIR_EGRESS) {\n", "        if (tuple->saddr == target->addr)\n", "            needs_ct = true;\n", "    }\n", "    if (!needs_ct)\n", "        return 0;\n", "    memset (&ct_state, 0, sizeof (ct_state));\n", "    memcpy (&tmp, tuple, sizeof (tmp));\n", "    where = dir == NAT_DIR_INGRESS ? CT_INGRESS : CT_EGRESS;\n", "    ret = ct_lookup4 (get_ct_map4 (& tmp), & tmp, ctx, off, where, & ct_state, & monitor);\n", "    if (ret < 0) {\n", "        return ret;\n", "    }\n", "    else if (ret == CT_NEW) {\n", "        ret = ct_create4 (get_ct_map4 (& tmp), NULL, & tmp, ctx, where, & ct_state, false, false);\n", "        if (IS_ERR (ret))\n", "            return ret;\n", "    }\n", "    return 0;\n", "}\n"], "called_function_list": ["memcpy", "ct_lookup4", "get_ct_map4", "ct_create4", "memset"], "call_depth": 3, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "snat_v4_handle_mapping": [{"capabilities": [], "helperCallParams": {}, "startLine": 301, "endLine": 322, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "funcName": "snat_v4_handle_mapping", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " struct ipv4_ct_tuple *tuple", " struct ipv4_nat_entry **state", " struct ipv4_nat_entry *tmp", " enum nat_dir dir", " __u32 off", " const struct ipv4_nat_target *target"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int snat_v4_handle_mapping (struct  __ctx_buff *ctx, struct ipv4_ct_tuple *tuple, struct ipv4_nat_entry **state, struct ipv4_nat_entry *tmp, enum nat_dir dir, __u32 off, const struct ipv4_nat_target *target)\n", "{\n", "    int ret;\n", "    *state = snat_v4_lookup (tuple);\n", "    ret = snat_v4_track_local (ctx, tuple, * state, dir, off, target);\n", "    if (ret < 0)\n", "        return ret;\n", "    else if (*state)\n", "        return NAT_CONTINUE_XLATE;\n", "    else if (dir == NAT_DIR_INGRESS)\n", "        return tuple->nexthdr != IPPROTO_ICMP && bpf_ntohs (tuple->dport) < target->min_port ? NAT_PUNT_TO_STACK : DROP_NAT_NO_MAPPING;\n", "    else\n", "        return snat_v4_new_mapping (ctx, tuple, (*state = tmp), target);\n", "}\n"], "called_function_list": ["snat_v4_lookup", "snat_v4_track_local", "snat_v4_new_mapping"], "call_depth": 5, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "snat_v4_rewrite_egress": [{"capabilities": [{"capability": "read_skb", "read_skb": [{"Project": "cilium", "Return Type": "s64", "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ", "Return": " The checksum result, or a negative error code in case of failure.", "Function Name": "csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp", "lwt_in", "lwt_out", "lwt_xmit", "lwt_seg6local"], "capabilities": ["read_skb"]}]}], "helperCallParams": {}, "startLine": 324, "endLine": 380, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "funcName": "snat_v4_rewrite_egress", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " struct ipv4_ct_tuple *tuple", " struct ipv4_nat_entry *state", " __u32 off", " bool has_l4_header"], "output": "static__always_inlineint", "helper": ["csum_diff"], "compatibleHookpoints": ["sched_cls", "lwt_xmit", "xdp", "lwt_in", "sched_act", "lwt_out", "lwt_seg6local"], "source": ["static __always_inline int snat_v4_rewrite_egress (struct  __ctx_buff *ctx, struct ipv4_ct_tuple *tuple, struct ipv4_nat_entry *state, __u32 off, bool has_l4_header)\n", "{\n", "    int ret, flags = BPF_F_PSEUDO_HDR;\n", "    struct csum_offset csum = {}\n", "    ;\n", "    __be32 sum_l4 = 0, sum;\n", "    if (state->to_saddr == tuple->saddr && state->to_sport == tuple->sport)\n", "        return 0;\n", "    sum = csum_diff (& tuple -> saddr, 4, & state -> to_saddr, 4, 0);\n", "    if (has_l4_header) {\n", "        csum_l4_offset_and_flags (tuple->nexthdr, &csum);\n", "        if (state->to_sport != tuple->sport) {\n", "            switch (tuple->nexthdr) {\n", "            case IPPROTO_TCP :\n", "            case IPPROTO_UDP :\n", "                ret = l4_modify_port (ctx, off, offsetof (struct tcphdr, source), &csum, state->to_sport, tuple->sport);\n", "                if (ret < 0)\n", "                    return ret;\n", "                break;\n", "            case IPPROTO_ICMP :\n", "                {\n", "                    __be32 from, to;\n", "                    if (ctx_store_bytes (ctx, off + offsetof (struct icmphdr, un.echo.id), &state->to_sport, sizeof (state->to_sport), 0) < 0)\n", "                        return DROP_WRITE_ERROR;\n", "                    from = tuple->sport;\n", "                    to = state->to_sport;\n", "                    flags = 0;\n", "                    sum_l4 = csum_diff (& from, 4, & to, 4, 0);\n", "                    csum.offset = offsetof (struct icmphdr, checksum);\n", "                    break;\n", "                }\n", "            }\n", "        }\n", "    }\n", "    if (ctx_store_bytes (ctx, ETH_HLEN + offsetof (struct iphdr, saddr), &state->to_saddr, 4, 0) < 0)\n", "        return DROP_WRITE_ERROR;\n", "    if (l3_csum_replace (ctx, ETH_HLEN + offsetof (struct iphdr, check), 0, sum, 0) < 0)\n", "        return DROP_CSUM_L3;\n", "    if (tuple->nexthdr == IPPROTO_ICMP)\n", "        sum = sum_l4;\n", "    if (csum.offset && csum_l4_replace (ctx, off, &csum, 0, sum, flags) < 0)\n", "        return DROP_CSUM_L4;\n", "    return 0;\n", "}\n"], "called_function_list": ["l4_modify_port", "csum_l4_offset_and_flags", "csum_l4_replace"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "snat_v4_rewrite_ingress": [{"capabilities": [{"capability": "read_skb", "read_skb": [{"Project": "cilium", "Return Type": "s64", "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ", "Return": " The checksum result, or a negative error code in case of failure.", "Function Name": "csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp", "lwt_in", "lwt_out", "lwt_xmit", "lwt_seg6local"], "capabilities": ["read_skb"]}]}], "helperCallParams": {}, "startLine": 382, "endLine": 435, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "funcName": "snat_v4_rewrite_ingress", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " struct ipv4_ct_tuple *tuple", " struct ipv4_nat_entry *state", " __u32 off"], "output": "static__always_inlineint", "helper": ["csum_diff"], "compatibleHookpoints": ["sched_cls", "lwt_xmit", "xdp", "lwt_in", "sched_act", "lwt_out", "lwt_seg6local"], "source": ["static __always_inline int snat_v4_rewrite_ingress (struct  __ctx_buff *ctx, struct ipv4_ct_tuple *tuple, struct ipv4_nat_entry *state, __u32 off)\n", "{\n", "    int ret, flags = BPF_F_PSEUDO_HDR;\n", "    struct csum_offset csum = {}\n", "    ;\n", "    __be32 sum_l4 = 0, sum;\n", "    if (state->to_daddr == tuple->daddr && state->to_dport == tuple->dport)\n", "        return 0;\n", "    sum = csum_diff (& tuple -> daddr, 4, & state -> to_daddr, 4, 0);\n", "    csum_l4_offset_and_flags (tuple->nexthdr, &csum);\n", "    if (state->to_dport != tuple->dport) {\n", "        switch (tuple->nexthdr) {\n", "        case IPPROTO_TCP :\n", "        case IPPROTO_UDP :\n", "            ret = l4_modify_port (ctx, off, offsetof (struct tcphdr, dest), &csum, state->to_dport, tuple->dport);\n", "            if (ret < 0)\n", "                return ret;\n", "            break;\n", "        case IPPROTO_ICMP :\n", "            {\n", "                __be32 from, to;\n", "                if (ctx_store_bytes (ctx, off + offsetof (struct icmphdr, un.echo.id), &state->to_dport, sizeof (state->to_dport), 0) < 0)\n", "                    return DROP_WRITE_ERROR;\n", "                from = tuple->dport;\n", "                to = state->to_dport;\n", "                flags = 0;\n", "                sum_l4 = csum_diff (& from, 4, & to, 4, 0);\n", "                csum.offset = offsetof (struct icmphdr, checksum);\n", "                break;\n", "            }\n", "        }\n", "    }\n", "    if (ctx_store_bytes (ctx, ETH_HLEN + offsetof (struct iphdr, daddr), &state->to_daddr, 4, 0) < 0)\n", "        return DROP_WRITE_ERROR;\n", "    if (l3_csum_replace (ctx, ETH_HLEN + offsetof (struct iphdr, check), 0, sum, 0) < 0)\n", "        return DROP_CSUM_L3;\n", "    if (tuple->nexthdr == IPPROTO_ICMP)\n", "        sum = sum_l4;\n", "    if (csum.offset && csum_l4_replace (ctx, off, &csum, 0, sum, flags) < 0)\n", "        return DROP_CSUM_L4;\n", "    return 0;\n", "}\n"], "called_function_list": ["l4_modify_port", "csum_l4_offset_and_flags", "csum_l4_replace"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "snat_v4_can_skip": [{"capabilities": [], "helperCallParams": {}, "startLine": 437, "endLine": 452, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "funcName": "snat_v4_can_skip", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct ipv4_nat_target *target", " const struct ipv4_ct_tuple *tuple", " enum nat_dir dir", " bool from_endpoint", " bool icmp_echoreply"], "output": "static__always_inlinebool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline bool snat_v4_can_skip (const struct ipv4_nat_target *target, const struct ipv4_ct_tuple *tuple, enum nat_dir dir, bool from_endpoint, bool icmp_echoreply)\n", "{\n", "    __u16 dport = bpf_ntohs (tuple->dport), sport = bpf_ntohs (tuple->sport);\n", "    if (dir == NAT_DIR_EGRESS && ((!from_endpoint && !target->src_from_world && sport < NAT_MIN_EGRESS) || icmp_echoreply))\n", "        return true;\n", "    if (dir == NAT_DIR_INGRESS && (dport < target->min_port || dport > target->max_port))\n", "        return true;\n", "    return false;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "snat_v4_create_dsr": [{"capabilities": [{"capability": "map_update", "map_update": [{"Project": "cilium", "Return Type": "int", "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "map_update_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}", "{Type:  const void ,Var: *value}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_update"]}]}, {"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 454, "endLine": 505, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "funcName": "snat_v4_create_dsr", "developer_inline_comments": [], "updateMaps": ["  SNAT_MAPPING_IPV4"], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " __be32 to_saddr", " __be16 to_sport"], "output": "static__always_inline__maybe_unusedint", "helper": ["map_update_elem", "CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["static __always_inline __maybe_unused int snat_v4_create_dsr (struct  __ctx_buff *ctx, __be32 to_saddr, __be16 to_sport)\n", "{\n", "    void *data, *data_end;\n", "    struct ipv4_ct_tuple tuple = {}\n", "    ;\n", "    struct ipv4_nat_entry state = {}\n", "    ;\n", "    struct iphdr *ip4;\n", "    struct {\n", "        __be16 sport;\n", "        __be16 dport;\n", "    } l4hdr;\n", "\n", "    __u32 off;\n", "    int ret;\n", "    build_bug_on (sizeof (struct ipv4_nat_entry) > 64);\n", "    if (!revalidate_data (ctx, &data, &data_end, &ip4))\n", "        return DROP_INVALID;\n", "    tuple.nexthdr = ip4->protocol;\n", "    tuple.daddr = ip4->saddr;\n", "    tuple.saddr = ip4->daddr;\n", "    tuple.flags = NAT_DIR_EGRESS;\n", "    off = ((void *) ip4 - data) + ipv4_hdrlen (ip4);\n", "    switch (tuple.nexthdr) {\n", "    case IPPROTO_TCP :\n", "    case IPPROTO_UDP :\n", "        if (ctx_load_bytes (ctx, off, &l4hdr, sizeof (l4hdr)) < 0)\n", "            return DROP_INVALID;\n", "        tuple.dport = l4hdr.sport;\n", "        tuple.sport = l4hdr.dport;\n", "        break;\n", "    default :\n", "        return DROP_NAT_UNSUPP_PROTO;\n", "    }\n", "    state.common.created = bpf_mono_now ();\n", "    state.to_saddr = to_saddr;\n", "    state.to_sport = to_sport;\n", "    ret = map_update_elem (& SNAT_MAPPING_IPV4, & tuple, & state, 0);\n", "    if (ret)\n", "        return ret;\n", "    return CTX_ACT_OK;\n", "}\n"], "called_function_list": ["ipv4_hdrlen"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "snat_v4_process": [{"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 507, "endLine": 572, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "funcName": "snat_v4_process", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " enum nat_dir dir", " const struct ipv4_nat_target *target", " bool from_endpoint"], "output": "static__always_inline__maybe_unusedint", "helper": ["CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["static __always_inline __maybe_unused int snat_v4_process (struct  __ctx_buff *ctx, enum nat_dir dir, const struct ipv4_nat_target *target, bool from_endpoint)\n", "{\n", "    struct icmphdr icmphdr __align_stack_8;\n", "    struct ipv4_nat_entry *state, tmp;\n", "    struct ipv4_ct_tuple tuple = {}\n", "    ;\n", "    void *data, *data_end;\n", "    struct iphdr *ip4;\n", "    struct {\n", "        __be16 sport;\n", "        __be16 dport;\n", "    } l4hdr;\n", "\n", "    bool icmp_echoreply = false;\n", "    __u64 off;\n", "    int ret;\n", "    build_bug_on (sizeof (struct ipv4_nat_entry) > 64);\n", "    if (!revalidate_data (ctx, &data, &data_end, &ip4))\n", "        return DROP_INVALID;\n", "    tuple.nexthdr = ip4->protocol;\n", "    tuple.daddr = ip4->daddr;\n", "    tuple.saddr = ip4->saddr;\n", "    tuple.flags = dir;\n", "    off = ((void *) ip4 - data) + ipv4_hdrlen (ip4);\n", "    switch (tuple.nexthdr) {\n", "    case IPPROTO_TCP :\n", "    case IPPROTO_UDP :\n", "        if (ctx_load_bytes (ctx, off, &l4hdr, sizeof (l4hdr)) < 0)\n", "            return DROP_INVALID;\n", "        tuple.dport = l4hdr.dport;\n", "        tuple.sport = l4hdr.sport;\n", "        break;\n", "    case IPPROTO_ICMP :\n", "        if (ctx_load_bytes (ctx, off, &icmphdr, sizeof (icmphdr)) < 0)\n", "            return DROP_INVALID;\n", "        if (icmphdr.type != ICMP_ECHO && icmphdr.type != ICMP_ECHOREPLY)\n", "            return DROP_NAT_UNSUPP_PROTO;\n", "        if (icmphdr.type == ICMP_ECHO) {\n", "            tuple.dport = 0;\n", "            tuple.sport = icmphdr.un.echo.id;\n", "        }\n", "        else {\n", "            tuple.dport = icmphdr.un.echo.id;\n", "            tuple.sport = 0;\n", "            icmp_echoreply = true;\n", "        }\n", "        break;\n", "    default :\n", "        return NAT_PUNT_TO_STACK;\n", "    }\n", "    if (snat_v4_can_skip (target, &tuple, dir, from_endpoint, icmp_echoreply))\n", "        return NAT_PUNT_TO_STACK;\n", "    ret = snat_v4_handle_mapping (ctx, & tuple, & state, & tmp, dir, off, target);\n", "    if (ret > 0)\n", "        return CTX_ACT_OK;\n", "    if (ret < 0)\n", "        return ret;\n", "    return dir == NAT_DIR_EGRESS ? snat_v4_rewrite_egress (ctx, &tuple, state, off, ipv4_has_l4_header (ip4)) : snat_v4_rewrite_ingress (ctx, &tuple, state, off);\n", "}\n"], "called_function_list": ["snat_v4_handle_mapping", "snat_v4_rewrite_ingress", "ipv4_has_l4_header", "ipv4_hdrlen", "snat_v4_rewrite_egress", "snat_v4_can_skip"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 574, "endLine": 581, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "funcName": "snat_v4_process", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff * ctx __maybe_unused", " enum nat_dir dir __maybe_unused", " const struct ipv4_nat_target * target __maybe_unused", " bool from_endpoint __maybe_unused"], "output": "static__always_inline__maybe_unusedint", "helper": ["CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["static __always_inline __maybe_unused int snat_v4_process (struct  __ctx_buff * ctx __maybe_unused, enum nat_dir dir __maybe_unused, const struct ipv4_nat_target * target __maybe_unused, bool from_endpoint __maybe_unused)\n", "{\n", "    return CTX_ACT_OK;\n", "}\n"], "called_function_list": ["snat_v4_handle_mapping", "snat_v4_rewrite_ingress", "ipv4_has_l4_header", "ipv4_hdrlen", "snat_v4_rewrite_egress", "snat_v4_can_skip"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "snat_v6_lookup": [{"capabilities": [], "helperCallParams": {}, "startLine": 622, "endLine": 626, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "funcName": "snat_v6_lookup", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct ipv6_ct_tuple *tuple"], "output": "static__always_inlinestructipv6_nat_entry", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline struct ipv6_nat_entry *snat_v6_lookup (struct ipv6_ct_tuple *tuple)\n", "{\n", "    return __snat_lookup (&SNAT_MAPPING_IPV6, tuple);\n", "}\n"], "called_function_list": ["__snat_lookup"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "snat_v6_update": [{"capabilities": [], "helperCallParams": {}, "startLine": 628, "endLine": 635, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "funcName": "snat_v6_update", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct ipv6_ct_tuple *otuple", " struct ipv6_nat_entry *ostate", " struct ipv6_ct_tuple *rtuple", " struct ipv6_nat_entry *rstate"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int snat_v6_update (struct ipv6_ct_tuple *otuple, struct ipv6_nat_entry *ostate, struct ipv6_ct_tuple *rtuple, struct ipv6_nat_entry *rstate)\n", "{\n", "    return __snat_update (&SNAT_MAPPING_IPV6, otuple, ostate, rtuple, rstate);\n", "}\n"], "called_function_list": ["__snat_update"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "snat_v6_delete": [{"capabilities": [], "helperCallParams": {}, "startLine": 637, "endLine": 641, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "funcName": "snat_v6_delete", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct ipv6_ct_tuple *otuple", " const struct ipv6_ct_tuple *rtuple"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void snat_v6_delete (const struct ipv6_ct_tuple *otuple, const struct ipv6_ct_tuple *rtuple)\n", "{\n", "    __snat_delete (&SNAT_MAPPING_IPV6, otuple, rtuple);\n", "}\n"], "called_function_list": ["__snat_delete"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "snat_v6_swap_tuple": [{"capabilities": [], "helperCallParams": {}, "startLine": 643, "endLine": 654, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "funcName": "snat_v6_swap_tuple", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct ipv6_ct_tuple *otuple", " struct ipv6_ct_tuple *rtuple"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void snat_v6_swap_tuple (const struct ipv6_ct_tuple *otuple, struct ipv6_ct_tuple *rtuple)\n", "{\n", "    memset (rtuple, 0, sizeof (*rtuple));\n", "    rtuple->nexthdr = otuple->nexthdr;\n", "    rtuple->daddr = otuple->saddr;\n", "    rtuple->saddr = otuple->daddr;\n", "    rtuple->dport = otuple->sport;\n", "    rtuple->sport = otuple->dport;\n", "    rtuple->flags = otuple->flags == NAT_DIR_EGRESS ? NAT_DIR_INGRESS : NAT_DIR_EGRESS;\n", "}\n"], "called_function_list": ["memset"], "call_depth": 3, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "snat_v6_reverse_tuple": [{"capabilities": [], "helperCallParams": {}, "startLine": 656, "endLine": 669, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "funcName": "snat_v6_reverse_tuple", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct ipv6_ct_tuple *otuple", " struct ipv6_ct_tuple *rtuple"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int snat_v6_reverse_tuple (struct ipv6_ct_tuple *otuple, struct ipv6_ct_tuple *rtuple)\n", "{\n", "    struct ipv6_nat_entry *ostate;\n", "    ostate = snat_v6_lookup (otuple);\n", "    if (ostate) {\n", "        snat_v6_swap_tuple (otuple, rtuple);\n", "        rtuple->daddr = ostate->to_saddr;\n", "        rtuple->dport = ostate->to_sport;\n", "    }\n", "    return ostate ? 0 : -1;\n", "}\n"], "called_function_list": ["snat_v6_swap_tuple", "snat_v6_lookup"], "call_depth": 4, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "snat_v6_ct_canonicalize": [{"capabilities": [], "helperCallParams": {}, "startLine": 671, "endLine": 680, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "funcName": "snat_v6_ct_canonicalize", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct ipv6_ct_tuple *otuple"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void snat_v6_ct_canonicalize (struct ipv6_ct_tuple *otuple)\n", "{\n", "    union v6addr addr = {}\n", "    ;\n", "    otuple->flags = NAT_DIR_EGRESS;\n", "    ipv6_addr_copy (&addr, &otuple->saddr);\n", "    ipv6_addr_copy (&otuple->saddr, &otuple->daddr);\n", "    ipv6_addr_copy (&otuple->daddr, &addr);\n", "}\n"], "called_function_list": ["ipv6_addr_copy"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "snat_v6_delete_tuples": [{"capabilities": [], "helperCallParams": {}, "startLine": 682, "endLine": 691, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "funcName": "snat_v6_delete_tuples", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct ipv6_ct_tuple *otuple"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void snat_v6_delete_tuples (struct ipv6_ct_tuple *otuple)\n", "{\n", "    struct ipv6_ct_tuple rtuple;\n", "    if (otuple->flags & TUPLE_F_IN)\n", "        return;\n", "    snat_v6_ct_canonicalize (otuple);\n", "    if (!snat_v6_reverse_tuple (otuple, &rtuple))\n", "        snat_v6_delete (otuple, &rtuple);\n", "}\n"], "called_function_list": ["snat_v6_ct_canonicalize", "snat_v6_reverse_tuple", "snat_v6_delete"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 1064, "endLine": 1067, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "funcName": "snat_v6_delete_tuples", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct ipv6_ct_tuple * tuple __maybe_unused"], "output": "static__always_inline__maybe_unusedvoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused void snat_v6_delete_tuples (struct ipv6_ct_tuple * tuple __maybe_unused)\n", "{\n", "}\n"], "called_function_list": ["snat_v6_ct_canonicalize", "snat_v6_reverse_tuple", "snat_v6_delete"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "snat_v6_new_mapping": [{"capabilities": [], "helperCallParams": {}, "startLine": 693, "endLine": 745, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "funcName": "snat_v6_new_mapping", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " struct ipv6_ct_tuple *otuple", " struct ipv6_nat_entry *ostate", " const struct ipv6_nat_target *target"], "output": "static__always_inlineint", "helper": ["send_signal", "get_prandom_u32"], "compatibleHookpoints": ["kprobe", "raw_tracepoint", "raw_tracepoint_writable", "perf_event", "tracepoint"], "source": ["static __always_inline int snat_v6_new_mapping (struct  __ctx_buff *ctx, struct ipv6_ct_tuple *otuple, struct ipv6_nat_entry *ostate, const struct ipv6_nat_target *target)\n", "{\n", "    int ret = DROP_NAT_NO_MAPPING, retries;\n", "    struct ipv6_nat_entry rstate;\n", "    struct ipv6_ct_tuple rtuple;\n", "    __u16 port;\n", "    memset (&rstate, 0, sizeof (rstate));\n", "    memset (ostate, 0, sizeof (*ostate));\n", "    rstate.to_daddr = otuple->saddr;\n", "    rstate.to_dport = otuple->sport;\n", "    ostate->to_saddr = target->addr;\n", "    snat_v6_swap_tuple (otuple, &rtuple);\n", "    port = __snat_try_keep_port (target -> min_port, target -> max_port, bpf_ntohs (otuple -> sport));\n", "    rtuple.dport = ostate->to_sport = bpf_htons (port);\n", "    rtuple.daddr = target->addr;\n", "    if (!ipv6_addrcmp (&otuple->saddr, &rtuple.daddr)) {\n", "        ostate->common.host_local = 1;\n", "        rstate.common.host_local = ostate->common.host_local;\n", "    }\n", "\n", "#pragma unroll\n", "    for (retries = 0; retries < SNAT_COLLISION_RETRIES; retries++) {\n", "        if (!snat_v6_lookup (&rtuple)) {\n", "            ostate->common.created = bpf_mono_now ();\n", "            rstate.common.created = ostate->common.created;\n", "            ret = snat_v6_update (otuple, ostate, & rtuple, & rstate);\n", "            if (!ret)\n", "                break;\n", "        }\n", "        port = __snat_clamp_port_range (target -> min_port, target -> max_port, retries ? port + 1 : (__u16) get_prandom_u32 ());\n", "        rtuple.dport = ostate->to_sport = bpf_htons (port);\n", "    }\n", "    if (retries > SNAT_SIGNAL_THRES)\n", "        send_signal_nat_fill_up (ctx, SIGNAL_PROTO_V6);\n", "    return !ret ? 0 : DROP_NAT_NO_MAPPING;\n", "}\n"], "called_function_list": ["snat_v6_lookup", "__snat_try_keep_port", "snat_v6_update", "send_signal_nat_fill_up", "__snat_clamp_port_range", "ipv6_addrcmp", "snat_v6_swap_tuple", "memset"], "call_depth": 4, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "snat_v6_track_local": [{"capabilities": [], "helperCallParams": {}, "startLine": 747, "endLine": 785, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "funcName": "snat_v6_track_local", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " struct ipv6_ct_tuple *tuple", " const struct ipv6_nat_entry *state", " enum nat_dir dir", " __u32 off", " const struct ipv6_nat_target *target"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int snat_v6_track_local (struct  __ctx_buff *ctx, struct ipv6_ct_tuple *tuple, const struct ipv6_nat_entry *state, enum nat_dir dir, __u32 off, const struct ipv6_nat_target *target)\n", "{\n", "    struct ct_state ct_state;\n", "    struct ipv6_ct_tuple tmp;\n", "    bool needs_ct = false;\n", "    __u32 monitor = 0;\n", "    int ret, where;\n", "    if (state && state->common.host_local) {\n", "        needs_ct = true;\n", "    }\n", "    else if (!state && dir == NAT_DIR_EGRESS) {\n", "        if (!ipv6_addrcmp (&tuple->saddr, (void *) &target->addr))\n", "            needs_ct = true;\n", "    }\n", "    if (!needs_ct)\n", "        return 0;\n", "    memset (&ct_state, 0, sizeof (ct_state));\n", "    memcpy (&tmp, tuple, sizeof (tmp));\n", "    where = dir == NAT_DIR_INGRESS ? CT_INGRESS : CT_EGRESS;\n", "    ret = ct_lookup6 (get_ct_map6 (& tmp), & tmp, ctx, off, where, & ct_state, & monitor);\n", "    if (ret < 0) {\n", "        return ret;\n", "    }\n", "    else if (ret == CT_NEW) {\n", "        ret = ct_create6 (get_ct_map6 (& tmp), NULL, & tmp, ctx, where, & ct_state, false, false);\n", "        if (IS_ERR (ret))\n", "            return ret;\n", "    }\n", "    return 0;\n", "}\n"], "called_function_list": ["memcpy", "ct_create6", "ct_lookup6", "get_ct_map6", "ipv6_addrcmp", "memset"], "call_depth": 3, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "snat_v6_handle_mapping": [{"capabilities": [], "helperCallParams": {}, "startLine": 787, "endLine": 808, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "funcName": "snat_v6_handle_mapping", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " struct ipv6_ct_tuple *tuple", " struct ipv6_nat_entry **state", " struct ipv6_nat_entry *tmp", " enum nat_dir dir", " __u32 off", " const struct ipv6_nat_target *target"], "output": "static__always_inlineint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline int snat_v6_handle_mapping (struct  __ctx_buff *ctx, struct ipv6_ct_tuple *tuple, struct ipv6_nat_entry **state, struct ipv6_nat_entry *tmp, enum nat_dir dir, __u32 off, const struct ipv6_nat_target *target)\n", "{\n", "    int ret;\n", "    *state = snat_v6_lookup (tuple);\n", "    ret = snat_v6_track_local (ctx, tuple, * state, dir, off, target);\n", "    if (ret < 0)\n", "        return ret;\n", "    else if (*state)\n", "        return NAT_CONTINUE_XLATE;\n", "    else if (dir == NAT_DIR_INGRESS)\n", "        return tuple->nexthdr != IPPROTO_ICMPV6 && bpf_ntohs (tuple->dport) < target->min_port ? NAT_PUNT_TO_STACK : DROP_NAT_NO_MAPPING;\n", "    else\n", "        return snat_v6_new_mapping (ctx, tuple, (*state = tmp), target);\n", "}\n"], "called_function_list": ["snat_v6_lookup", "snat_v6_new_mapping", "snat_v6_track_local"], "call_depth": 5, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "snat_v6_rewrite_egress": [{"capabilities": [{"capability": "read_skb", "read_skb": [{"Project": "cilium", "Return Type": "s64", "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ", "Return": " The checksum result, or a negative error code in case of failure.", "Function Name": "csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp", "lwt_in", "lwt_out", "lwt_xmit", "lwt_seg6local"], "capabilities": ["read_skb"]}]}], "helperCallParams": {}, "startLine": 810, "endLine": 855, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "funcName": "snat_v6_rewrite_egress", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " struct ipv6_ct_tuple *tuple", " struct ipv6_nat_entry *state", " __u32 off"], "output": "static__always_inlineint", "helper": ["csum_diff"], "compatibleHookpoints": ["sched_cls", "lwt_xmit", "xdp", "lwt_in", "sched_act", "lwt_out", "lwt_seg6local"], "source": ["static __always_inline int snat_v6_rewrite_egress (struct  __ctx_buff *ctx, struct ipv6_ct_tuple *tuple, struct ipv6_nat_entry *state, __u32 off)\n", "{\n", "    struct csum_offset csum = {}\n", "    ;\n", "    __be32 sum;\n", "    int ret;\n", "    if (!ipv6_addrcmp (&state->to_saddr, &tuple->saddr) && state->to_sport == tuple->sport)\n", "        return 0;\n", "    sum = csum_diff (& tuple -> saddr, 16, & state -> to_saddr, 16, 0);\n", "    csum_l4_offset_and_flags (tuple->nexthdr, &csum);\n", "    if (state->to_sport != tuple->sport) {\n", "        switch (tuple->nexthdr) {\n", "        case IPPROTO_TCP :\n", "        case IPPROTO_UDP :\n", "            ret = l4_modify_port (ctx, off, offsetof (struct tcphdr, source), &csum, state->to_sport, tuple->sport);\n", "            if (ret < 0)\n", "                return ret;\n", "            break;\n", "        case IPPROTO_ICMPV6 :\n", "            {\n", "                __be32 from, to;\n", "                if (ctx_store_bytes (ctx, off + offsetof (struct icmp6hdr, icmp6_dataun.u_echo.identifier), &state->to_sport, sizeof (state->to_sport), 0) < 0)\n", "                    return DROP_WRITE_ERROR;\n", "                from = tuple->sport;\n", "                to = state->to_sport;\n", "                sum = csum_diff (& from, 4, & to, 4, sum);\n", "                break;\n", "            }\n", "        }\n", "    }\n", "    if (ctx_store_bytes (ctx, ETH_HLEN + offsetof (struct ipv6hdr, saddr), &state->to_saddr, 16, 0) < 0)\n", "        return DROP_WRITE_ERROR;\n", "    if (csum.offset && csum_l4_replace (ctx, off, &csum, 0, sum, BPF_F_PSEUDO_HDR) < 0)\n", "        return DROP_CSUM_L4;\n", "    return 0;\n", "}\n"], "called_function_list": ["l4_modify_port", "csum_l4_replace", "csum_l4_offset_and_flags", "ipv6_addrcmp"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "snat_v6_rewrite_ingress": [{"capabilities": [{"capability": "read_skb", "read_skb": [{"Project": "cilium", "Return Type": "s64", "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ", "Return": " The checksum result, or a negative error code in case of failure.", "Function Name": "csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp", "lwt_in", "lwt_out", "lwt_xmit", "lwt_seg6local"], "capabilities": ["read_skb"]}]}], "helperCallParams": {}, "startLine": 857, "endLine": 904, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "funcName": "snat_v6_rewrite_ingress", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " struct ipv6_ct_tuple *tuple", " struct ipv6_nat_entry *state", " __u32 off"], "output": "static__always_inlineint", "helper": ["csum_diff"], "compatibleHookpoints": ["sched_cls", "lwt_xmit", "xdp", "lwt_in", "sched_act", "lwt_out", "lwt_seg6local"], "source": ["static __always_inline int snat_v6_rewrite_ingress (struct  __ctx_buff *ctx, struct ipv6_ct_tuple *tuple, struct ipv6_nat_entry *state, __u32 off)\n", "{\n", "    struct csum_offset csum = {}\n", "    ;\n", "    __be32 sum;\n", "    int ret;\n", "    if (!ipv6_addrcmp (&state->to_daddr, &tuple->daddr) && state->to_dport == tuple->dport)\n", "        return 0;\n", "    sum = csum_diff (& tuple -> daddr, 16, & state -> to_daddr, 16, 0);\n", "    csum_l4_offset_and_flags (tuple->nexthdr, &csum);\n", "    if (state->to_dport != tuple->dport) {\n", "        switch (tuple->nexthdr) {\n", "        case IPPROTO_TCP :\n", "        case IPPROTO_UDP :\n", "            ret = l4_modify_port (ctx, off, offsetof (struct tcphdr, dest), &csum, state->to_dport, tuple->dport);\n", "            if (ret < 0)\n", "                return ret;\n", "            break;\n", "        case IPPROTO_ICMPV6 :\n", "            {\n", "                __be32 from, to;\n", "                if (ctx_store_bytes (ctx, off + offsetof (struct icmp6hdr, icmp6_dataun.u_echo.identifier), &state->to_dport, sizeof (state->to_dport), 0) < 0)\n", "                    return DROP_WRITE_ERROR;\n", "                from = tuple->dport;\n", "                to = state->to_dport;\n", "                sum = csum_diff (& from, 4, & to, 4, sum);\n", "                break;\n", "            }\n", "        }\n", "    }\n", "    if (ctx_store_bytes (ctx, ETH_HLEN + offsetof (struct ipv6hdr, daddr), &state->to_daddr, 16, 0) < 0)\n", "        return DROP_WRITE_ERROR;\n", "    if (csum.offset && csum_l4_replace (ctx, off, &csum, 0, sum, BPF_F_PSEUDO_HDR) < 0)\n", "        return DROP_CSUM_L4;\n", "    return 0;\n", "}\n"], "called_function_list": ["l4_modify_port", "csum_l4_replace", "csum_l4_offset_and_flags", "ipv6_addrcmp"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "snat_v6_can_skip": [{"capabilities": [], "helperCallParams": {}, "startLine": 906, "endLine": 920, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "funcName": "snat_v6_can_skip", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct ipv6_nat_target *target", " const struct ipv6_ct_tuple *tuple", " enum nat_dir dir", " bool icmp_echoreply"], "output": "static__always_inlinebool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline bool snat_v6_can_skip (const struct ipv6_nat_target *target, const struct ipv6_ct_tuple *tuple, enum nat_dir dir, bool icmp_echoreply)\n", "{\n", "    __u16 dport = bpf_ntohs (tuple->dport), sport = bpf_ntohs (tuple->sport);\n", "    if (dir == NAT_DIR_EGRESS && ((!target->src_from_world && sport < NAT_MIN_EGRESS) || icmp_echoreply))\n", "        return true;\n", "    if (dir == NAT_DIR_INGRESS && (dport < target->min_port || dport > target->max_port))\n", "        return true;\n", "    return false;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "snat_v6_create_dsr": [{"capabilities": [{"capability": "map_update", "map_update": [{"Project": "cilium", "Return Type": "int", "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "map_update_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}", "{Type:  const void ,Var: *value}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_update"]}]}, {"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 922, "endLine": 977, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "funcName": "snat_v6_create_dsr", "developer_inline_comments": [], "updateMaps": ["  SNAT_MAPPING_IPV6"], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " const union v6addr *to_saddr", " __be16 to_sport"], "output": "static__always_inline__maybe_unusedint", "helper": ["map_update_elem", "CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["static __always_inline __maybe_unused int snat_v6_create_dsr (struct  __ctx_buff *ctx, const union v6addr *to_saddr, __be16 to_sport)\n", "{\n", "    void *data, *data_end;\n", "    struct ipv6_ct_tuple tuple = {}\n", "    ;\n", "    struct ipv6_nat_entry state = {}\n", "    ;\n", "    struct ipv6hdr *ip6;\n", "    struct {\n", "        __be16 sport;\n", "        __be16 dport;\n", "    } l4hdr;\n", "\n", "    int ret, hdrlen;\n", "    __u32 off;\n", "    build_bug_on (sizeof (struct ipv6_nat_entry) > 64);\n", "    if (!revalidate_data (ctx, &data, &data_end, &ip6))\n", "        return DROP_INVALID;\n", "    tuple.nexthdr = ip6->nexthdr;\n", "    hdrlen = ipv6_hdrlen (ctx, & tuple.nexthdr);\n", "    if (hdrlen < 0)\n", "        return hdrlen;\n", "    ipv6_addr_copy (&tuple.daddr, (union v6addr *) &ip6->saddr);\n", "    ipv6_addr_copy (&tuple.saddr, (union v6addr *) &ip6->daddr);\n", "    tuple.flags = NAT_DIR_EGRESS;\n", "    off = ((void *) ip6 - data) + hdrlen;\n", "    switch (tuple.nexthdr) {\n", "    case IPPROTO_TCP :\n", "    case IPPROTO_UDP :\n", "        if (ctx_load_bytes (ctx, off, &l4hdr, sizeof (l4hdr)) < 0)\n", "            return DROP_INVALID;\n", "        tuple.dport = l4hdr.sport;\n", "        tuple.sport = l4hdr.dport;\n", "        break;\n", "    default :\n", "        return DROP_NAT_UNSUPP_PROTO;\n", "    }\n", "    state.common.created = bpf_mono_now ();\n", "    ipv6_addr_copy (&state.to_saddr, to_saddr);\n", "    state.to_sport = to_sport;\n", "    ret = map_update_elem (& SNAT_MAPPING_IPV6, & tuple, & state, 0);\n", "    if (ret)\n", "        return ret;\n", "    return CTX_ACT_OK;\n", "}\n"], "called_function_list": ["ipv6_hdrlen", "ipv6_addr_copy"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "snat_v6_process": [{"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 979, "endLine": 1054, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "funcName": "snat_v6_process", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " enum nat_dir dir", " const struct ipv6_nat_target *target"], "output": "static__always_inline__maybe_unusedint", "helper": ["CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["static __always_inline __maybe_unused int snat_v6_process (struct  __ctx_buff *ctx, enum nat_dir dir, const struct ipv6_nat_target *target)\n", "{\n", "    struct icmp6hdr icmp6hdr __align_stack_8;\n", "    struct ipv6_nat_entry *state, tmp;\n", "    struct ipv6_ct_tuple tuple = {}\n", "    ;\n", "    void *data, *data_end;\n", "    struct ipv6hdr *ip6;\n", "    int ret, hdrlen;\n", "    struct {\n", "        __be16 sport;\n", "        __be16 dport;\n", "    } l4hdr;\n", "\n", "    __u8 nexthdr;\n", "    __u32 off;\n", "    bool icmp_echoreply = false;\n", "    build_bug_on (sizeof (struct ipv6_nat_entry) > 64);\n", "    if (!revalidate_data (ctx, &data, &data_end, &ip6))\n", "        return DROP_INVALID;\n", "    nexthdr = ip6->nexthdr;\n", "    hdrlen = ipv6_hdrlen (ctx, & nexthdr);\n", "    if (hdrlen < 0)\n", "        return hdrlen;\n", "    tuple.nexthdr = nexthdr;\n", "    ipv6_addr_copy (&tuple.daddr, (union v6addr *) &ip6->daddr);\n", "    ipv6_addr_copy (&tuple.saddr, (union v6addr *) &ip6->saddr);\n", "    tuple.flags = dir;\n", "    off = ((void *) ip6 - data) + hdrlen;\n", "    switch (tuple.nexthdr) {\n", "    case IPPROTO_TCP :\n", "    case IPPROTO_UDP :\n", "        if (ctx_load_bytes (ctx, off, &l4hdr, sizeof (l4hdr)) < 0)\n", "            return DROP_INVALID;\n", "        tuple.dport = l4hdr.dport;\n", "        tuple.sport = l4hdr.sport;\n", "        break;\n", "    case IPPROTO_ICMPV6 :\n", "        if (ctx_load_bytes (ctx, off, &icmp6hdr, sizeof (icmp6hdr)) < 0)\n", "            return DROP_INVALID;\n", "        if (icmp6hdr.icmp6_type == ICMP6_NS_MSG_TYPE || icmp6hdr.icmp6_type == ICMP6_NA_MSG_TYPE)\n", "            return CTX_ACT_OK;\n", "        if (icmp6hdr.icmp6_type != ICMPV6_ECHO_REQUEST && icmp6hdr.icmp6_type != ICMPV6_ECHO_REPLY)\n", "            return DROP_NAT_UNSUPP_PROTO;\n", "        if (icmp6hdr.icmp6_type == ICMPV6_ECHO_REQUEST) {\n", "            tuple.dport = 0;\n", "            tuple.sport = icmp6hdr.icmp6_dataun.u_echo.identifier;\n", "        }\n", "        else {\n", "            tuple.dport = icmp6hdr.icmp6_dataun.u_echo.identifier;\n", "            tuple.sport = 0;\n", "            icmp_echoreply = true;\n", "        }\n", "        break;\n", "    default :\n", "        return NAT_PUNT_TO_STACK;\n", "    }\n", "    if (snat_v6_can_skip (target, &tuple, dir, icmp_echoreply))\n", "        return NAT_PUNT_TO_STACK;\n", "    ret = snat_v6_handle_mapping (ctx, & tuple, & state, & tmp, dir, off, target);\n", "    if (ret > 0)\n", "        return CTX_ACT_OK;\n", "    if (ret < 0)\n", "        return ret;\n", "    return dir == NAT_DIR_EGRESS ? snat_v6_rewrite_egress (ctx, &tuple, state, off) : snat_v6_rewrite_ingress (ctx, &tuple, state, off);\n", "}\n"], "called_function_list": ["snat_v6_rewrite_egress", "snat_v6_can_skip", "snat_v6_rewrite_ingress", "ipv6_hdrlen", "snat_v6_handle_mapping", "ipv6_addr_copy"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "cilium", "Return Type": "int", "Input Params": [], "Function Name": "TC_ACT_OK", "Return": 0, "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.", "compatible_hookpoints": ["xdp", "sched_cls", "sched_act"], "capabilities": ["pkt_go_to_next_module"]}]}], "helperCallParams": {}, "startLine": 1056, "endLine": 1062, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "funcName": "snat_v6_process", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff * ctx __maybe_unused", " enum nat_dir dir __maybe_unused", " const struct ipv6_nat_target * target __maybe_unused"], "output": "static__always_inline__maybe_unusedint", "helper": ["CTX_ACT_OK"], "compatibleHookpoints": ["sched_cls", "xdp", "sched_act"], "source": ["static __always_inline __maybe_unused int snat_v6_process (struct  __ctx_buff * ctx __maybe_unused, enum nat_dir dir __maybe_unused, const struct ipv6_nat_target * target __maybe_unused)\n", "{\n", "    return CTX_ACT_OK;\n", "}\n"], "called_function_list": ["snat_v6_rewrite_egress", "snat_v6_can_skip", "snat_v6_rewrite_ingress", "ipv6_hdrlen", "snat_v6_handle_mapping", "ipv6_addr_copy"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "snat_v6_has_v4_match": [{"capabilities": [], "helperCallParams": {}, "startLine": 1070, "endLine": 1088, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "funcName": "snat_v6_has_v4_match", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct ipv4_ct_tuple * tuple4 __maybe_unused"], "output": "static__always_inlinebool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline bool snat_v6_has_v4_match (const struct ipv4_ct_tuple * tuple4 __maybe_unused)\n", "{\n", "\n", "#if defined(ENABLE_IPV6) && defined(ENABLE_NODEPORT)\n", "    struct ipv6_ct_tuple tuple6;\n", "    memset (&tuple6, 0, sizeof (tuple6));\n", "    tuple6.nexthdr = tuple4->nexthdr;\n", "    build_v4_in_v6 (&tuple6.saddr, tuple4->saddr);\n", "    build_v4_in_v6 (&tuple6.daddr, tuple4->daddr);\n", "    tuple6.sport = tuple4->sport;\n", "    tuple6.dport = tuple4->dport;\n", "    tuple6.flags = NAT_DIR_INGRESS;\n", "    return snat_v6_lookup (&tuple6);\n", "\n", "#else\n", "    return false;\n", "\n", "#endif\n", "}\n"], "called_function_list": ["build_v4_in_v6", "snat_v6_lookup", "memset"], "call_depth": 4, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ct_delete4": [{"capabilities": [{"capability": "map_update", "map_update": [{"Project": "cilium", "Return Type": "int", "Description": "Delete entry with <[ key ]>(IP: 1) from map. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "map_delete_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_update"]}]}], "helperCallParams": {}, "startLine": 1090, "endLine": 1100, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "funcName": "ct_delete4", "developer_inline_comments": [], "updateMaps": ["", " map"], "readMaps": [], "input": ["const void *map", " struct ipv4_ct_tuple *tuple", " struct  __ctx_buff *ctx"], "output": "static__always_inline__maybe_unusedvoid", "helper": ["map_delete_elem"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused void ct_delete4 (const void *map, struct ipv4_ct_tuple *tuple, struct  __ctx_buff *ctx)\n", "{\n", "    int err;\n", "    err = map_delete_elem (map, tuple);\n", "    if (err < 0)\n", "        cilium_dbg (ctx, DBG_ERROR_RET, BPF_FUNC_map_delete_elem, err);\n", "    else\n", "        snat_v4_delete_tuples (tuple);\n", "}\n"], "called_function_list": ["cilium_dbg", "snat_v4_delete_tuples"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ct_delete6": [{"capabilities": [{"capability": "map_update", "map_update": [{"Project": "cilium", "Return Type": "int", "Description": "Delete entry with <[ key ]>(IP: 1) from map. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "map_delete_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_update"]}]}], "helperCallParams": {}, "startLine": 1102, "endLine": 1112, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "funcName": "ct_delete6", "developer_inline_comments": [], "updateMaps": ["", " map"], "readMaps": [], "input": ["const void *map", " struct ipv6_ct_tuple *tuple", " struct  __ctx_buff *ctx"], "output": "static__always_inline__maybe_unusedvoid", "helper": ["map_delete_elem"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused void ct_delete6 (const void *map, struct ipv6_ct_tuple *tuple, struct  __ctx_buff *ctx)\n", "{\n", "    int err;\n", "    err = map_delete_elem (map, tuple);\n", "    if (err < 0)\n", "        cilium_dbg (ctx, DBG_ERROR_RET, BPF_FUNC_map_delete_elem, err);\n", "    else\n", "        snat_v6_delete_tuples (tuple);\n", "}\n"], "called_function_list": ["cilium_dbg", "snat_v6_delete_tuples"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "hash_32": [{"capabilities": [], "helperCallParams": {}, "startLine": 31, "endLine": 35, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/ghash.h", "funcName": "hash_32", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["__u32 val", " __u32 bits"], "output": "static__always_inline__u32", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __u32 hash_32 (__u32 val, __u32 bits)\n", "{\n", "    return (val * GOLDEN_RATIO_32) >> (32 - bits);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "hash_64": [{"capabilities": [], "helperCallParams": {}, "startLine": 37, "endLine": 40, "File": "/home/sayandes/opened_extraction/examples/cilium/lib/ghash.h", "funcName": "hash_64", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["__u64 val", " __u32 bits"], "output": "static__always_inline__u32", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __u32 hash_64 (__u64 val, __u32 bits)\n", "{\n", "    return (val * GOLDEN_RATIO_64) >> (64 - bits);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "custom_prog": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 11, "endLine": 24, "File": "/home/sayandes/opened_extraction/examples/cilium/custom/bytecount.h", "funcName": "custom_prog", "developer_inline_comments": [], "updateMaps": [" bytecount_map"], "readMaps": ["  bytecount_map"], "input": ["const struct  __ctx_buff *ctx", " __u32 identity"], "output": "static__always_inlinevoid", "helper": ["map_lookup_elem", "map_update_elem"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void custom_prog (const struct  __ctx_buff *ctx, __u32 identity)\n", "{\n", "    __u64 len, *bytecount;\n", "    len = ctx_full_len (ctx);\n", "    bytecount = map_lookup_elem (& bytecount_map, & identity);\n", "    if (bytecount)\n", "        __sync_fetch_and_add (bytecount, len);\n", "    else\n", "        map_update_elem (&bytecount_map, &identity, &len, BPF_ANY);\n", "}\n"], "called_function_list": ["ctx_full_len"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__fswab16": [{"capabilities": [], "helperCallParams": {}, "startLine": 46, "endLine": 55, "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/swab.h", "funcName": "__fswab16", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["__u16 val"], "output": "static__inline____u16", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __inline__ __u16 __fswab16 (__u16 val)\n", "{\n", "\n", "#ifdef __HAVE_BUILTIN_BSWAP16__\n", "    return __builtin_bswap16 (val);\n", "\n", "#elif defined (__arch_swab16)\n", "    return __arch_swab16 (val);\n", "\n", "#else\n", "    return ___constant_swab16 (val);\n", "\n", "#endif\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__fswab32": [{"capabilities": [], "helperCallParams": {}, "startLine": 57, "endLine": 66, "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/swab.h", "funcName": "__fswab32", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["__u32 val"], "output": "static__inline____u32", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __inline__ __u32 __fswab32 (__u32 val)\n", "{\n", "\n", "#ifdef __HAVE_BUILTIN_BSWAP32__\n", "    return __builtin_bswap32 (val);\n", "\n", "#elif defined(__arch_swab32)\n", "    return __arch_swab32 (val);\n", "\n", "#else\n", "    return ___constant_swab32 (val);\n", "\n", "#endif\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__fswab64": [{"capabilities": [], "helperCallParams": {}, "startLine": 68, "endLine": 81, "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/swab.h", "funcName": "__fswab64", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["__u64 val"], "output": "static__inline____u64", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __inline__ __u64 __fswab64 (__u64 val)\n", "{\n", "\n", "#ifdef __HAVE_BUILTIN_BSWAP64__\n", "    return __builtin_bswap64 (val);\n", "\n", "#elif defined (__arch_swab64)\n", "    return __arch_swab64 (val);\n", "\n", "#elif defined(__SWAB_64_THRU_32__)\n", "    __u32 h = val >> 32;\n", "    __u32 l = val & ((1ULL << 32) - 1);\n", "    return (((__u64) __fswab32 (l)) << 32) | ((__u64) (__fswab32 (h)));\n", "\n", "#else\n", "    return ___constant_swab64 (val);\n", "\n", "#endif\n", "}\n"], "called_function_list": ["__fswab32"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__fswahw32": [{"capabilities": [], "helperCallParams": {}, "startLine": 83, "endLine": 90, "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/swab.h", "funcName": "__fswahw32", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["__u32 val"], "output": "static__inline____u32", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __inline__ __u32 __fswahw32 (__u32 val)\n", "{\n", "\n", "#ifdef __arch_swahw32\n", "    return __arch_swahw32 (val);\n", "\n", "#else\n", "    return ___constant_swahw32 (val);\n", "\n", "#endif\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__fswahb32": [{"capabilities": [], "helperCallParams": {}, "startLine": 92, "endLine": 99, "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/swab.h", "funcName": "__fswahb32", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["__u32 val"], "output": "static__inline____u32", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __inline__ __u32 __fswahb32 (__u32 val)\n", "{\n", "\n", "#ifdef __arch_swahb32\n", "    return __arch_swahb32 (val);\n", "\n", "#else\n", "    return ___constant_swahb32 (val);\n", "\n", "#endif\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__swab16p": [{"capabilities": [], "helperCallParams": {}, "startLine": 154, "endLine": 161, "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/swab.h", "funcName": "__swab16p", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const __u16 *p"], "output": "static__inline____u16", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __inline__ __u16 __swab16p (const __u16 *p)\n", "{\n", "\n", "#ifdef __arch_swab16p\n", "    return __arch_swab16p (p);\n", "\n", "#else\n", "    return __swab16 (*p);\n", "\n", "#endif\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__swab32p": [{"capabilities": [], "helperCallParams": {}, "startLine": 167, "endLine": 174, "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/swab.h", "funcName": "__swab32p", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const __u32 *p"], "output": "static__inline____u32", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __inline__ __u32 __swab32p (const __u32 *p)\n", "{\n", "\n", "#ifdef __arch_swab32p\n", "    return __arch_swab32p (p);\n", "\n", "#else\n", "    return __swab32 (*p);\n", "\n", "#endif\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__swab64p": [{"capabilities": [], "helperCallParams": {}, "startLine": 180, "endLine": 187, "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/swab.h", "funcName": "__swab64p", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const __u64 *p"], "output": "static__inline____u64", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __inline__ __u64 __swab64p (const __u64 *p)\n", "{\n", "\n", "#ifdef __arch_swab64p\n", "    return __arch_swab64p (p);\n", "\n", "#else\n", "    return __swab64 (*p);\n", "\n", "#endif\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__swahw32p": [{"capabilities": [], "helperCallParams": {}, "startLine": 195, "endLine": 202, "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/swab.h", "funcName": "__swahw32p", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const __u32 *p"], "output": "static__inline____u32", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __inline__ __u32 __swahw32p (const __u32 *p)\n", "{\n", "\n", "#ifdef __arch_swahw32p\n", "    return __arch_swahw32p (p);\n", "\n", "#else\n", "    return __swahw32 (*p);\n", "\n", "#endif\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__swahb32p": [{"capabilities": [], "helperCallParams": {}, "startLine": 210, "endLine": 217, "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/swab.h", "funcName": "__swahb32p", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const __u32 *p"], "output": "static__inline____u32", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __inline__ __u32 __swahb32p (const __u32 *p)\n", "{\n", "\n", "#ifdef __arch_swahb32p\n", "    return __arch_swahb32p (p);\n", "\n", "#else\n", "    return __swahb32 (*p);\n", "\n", "#endif\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__swab16s": [{"capabilities": [], "helperCallParams": {}, "startLine": 223, "endLine": 230, "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/swab.h", "funcName": "__swab16s", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["__u16 *p"], "output": "static__inline__void", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __inline__ void __swab16s (__u16 *p)\n", "{\n", "\n", "#ifdef __arch_swab16s\n", "    __arch_swab16s (p);\n", "\n", "#else\n", "    *p = __swab16p (p);\n", "\n", "#endif\n", "}\n"], "called_function_list": ["__swab16p"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__swab32s": [{"capabilities": [], "helperCallParams": {}, "startLine": 235, "endLine": 242, "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/swab.h", "funcName": "__swab32s", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["__u32 *p"], "output": "static__inline__void", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __inline__ void __swab32s (__u32 *p)\n", "{\n", "\n", "#ifdef __arch_swab32s\n", "    __arch_swab32s (p);\n", "\n", "#else\n", "    *p = __swab32p (p);\n", "\n", "#endif\n", "}\n"], "called_function_list": ["__swab32p"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__swab64s": [{"capabilities": [], "helperCallParams": {}, "startLine": 248, "endLine": 255, "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/swab.h", "funcName": "__swab64s", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["__u64 *p"], "output": "static__inline__void", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __inline__ void __swab64s (__u64 *p)\n", "{\n", "\n", "#ifdef __arch_swab64s\n", "    __arch_swab64s (p);\n", "\n", "#else\n", "    *p = __swab64p (p);\n", "\n", "#endif\n", "}\n"], "called_function_list": ["__swab64p"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__swahw32s": [{"capabilities": [], "helperCallParams": {}, "startLine": 263, "endLine": 270, "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/swab.h", "funcName": "__swahw32s", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["__u32 *p"], "output": "static__inline__void", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __inline__ void __swahw32s (__u32 *p)\n", "{\n", "\n", "#ifdef __arch_swahw32s\n", "    __arch_swahw32s (p);\n", "\n", "#else\n", "    *p = __swahw32p (p);\n", "\n", "#endif\n", "}\n"], "called_function_list": ["__swahw32p"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__swahb32s": [{"capabilities": [], "helperCallParams": {}, "startLine": 278, "endLine": 285, "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/swab.h", "funcName": "__swahb32s", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["__u32 *p"], "output": "static__inline__void", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __inline__ void __swahb32s (__u32 *p)\n", "{\n", "\n", "#ifdef __arch_swahb32s\n", "    __arch_swahb32s (p);\n", "\n", "#else\n", "    *p = __swahb32p (p);\n", "\n", "#endif\n", "}\n"], "called_function_list": ["__swahb32p"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__cpu_to_le64p": [{"capabilities": [], "helperCallParams": {}, "startLine": 45, "endLine": 48, "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/big_endian.h", "funcName": "__cpu_to_le64p", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const __u64 *p"], "output": "static__inline____le64", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __inline__ __le64 __cpu_to_le64p (const __u64 *p)\n", "{\n", "    return (__le64) __swab64p (p);\n", "}\n"], "called_function_list": ["__swab64p"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 45, "endLine": 48, "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/little_endian.h", "funcName": "__cpu_to_le64p", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const __u64 *p"], "output": "static__inline____le64", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __inline__ __le64 __cpu_to_le64p (const __u64 *p)\n", "{\n", "    return (__le64) *p;\n", "}\n"], "called_function_list": ["__swab64p"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__le64_to_cpup": [{"capabilities": [], "helperCallParams": {}, "startLine": 49, "endLine": 52, "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/big_endian.h", "funcName": "__le64_to_cpup", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const __le64 *p"], "output": "static__inline____u64", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __inline__ __u64 __le64_to_cpup (const __le64 *p)\n", "{\n", "    return __swab64p ((__u64 *) p);\n", "}\n"], "called_function_list": ["__swab64p"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 49, "endLine": 52, "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/little_endian.h", "funcName": "__le64_to_cpup", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const __le64 *p"], "output": "static__inline____u64", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __inline__ __u64 __le64_to_cpup (const __le64 *p)\n", "{\n", "    return (__u64) *p;\n", "}\n"], "called_function_list": ["__swab64p"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__cpu_to_le32p": [{"capabilities": [], "helperCallParams": {}, "startLine": 53, "endLine": 56, "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/big_endian.h", "funcName": "__cpu_to_le32p", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const __u32 *p"], "output": "static__inline____le32", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __inline__ __le32 __cpu_to_le32p (const __u32 *p)\n", "{\n", "    return (__le32) __swab32p (p);\n", "}\n"], "called_function_list": ["__swab32p"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 53, "endLine": 56, "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/little_endian.h", "funcName": "__cpu_to_le32p", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const __u32 *p"], "output": "static__inline____le32", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __inline__ __le32 __cpu_to_le32p (const __u32 *p)\n", "{\n", "    return (__le32) *p;\n", "}\n"], "called_function_list": ["__swab32p"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__le32_to_cpup": [{"capabilities": [], "helperCallParams": {}, "startLine": 57, "endLine": 60, "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/big_endian.h", "funcName": "__le32_to_cpup", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const __le32 *p"], "output": "static__inline____u32", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __inline__ __u32 __le32_to_cpup (const __le32 *p)\n", "{\n", "    return __swab32p ((__u32 *) p);\n", "}\n"], "called_function_list": ["__swab32p"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 57, "endLine": 60, "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/little_endian.h", "funcName": "__le32_to_cpup", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const __le32 *p"], "output": "static__inline____u32", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __inline__ __u32 __le32_to_cpup (const __le32 *p)\n", "{\n", "    return (__u32) *p;\n", "}\n"], "called_function_list": ["__swab32p"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__cpu_to_le16p": [{"capabilities": [], "helperCallParams": {}, "startLine": 61, "endLine": 64, "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/big_endian.h", "funcName": "__cpu_to_le16p", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const __u16 *p"], "output": "static__inline____le16", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __inline__ __le16 __cpu_to_le16p (const __u16 *p)\n", "{\n", "    return (__le16) __swab16p (p);\n", "}\n"], "called_function_list": ["__swab16p"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 61, "endLine": 64, "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/little_endian.h", "funcName": "__cpu_to_le16p", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const __u16 *p"], "output": "static__inline____le16", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __inline__ __le16 __cpu_to_le16p (const __u16 *p)\n", "{\n", "    return (__le16) *p;\n", "}\n"], "called_function_list": ["__swab16p"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__le16_to_cpup": [{"capabilities": [], "helperCallParams": {}, "startLine": 65, "endLine": 68, "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/big_endian.h", "funcName": "__le16_to_cpup", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const __le16 *p"], "output": "static__inline____u16", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __inline__ __u16 __le16_to_cpup (const __le16 *p)\n", "{\n", "    return __swab16p ((__u16 *) p);\n", "}\n"], "called_function_list": ["__swab16p"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 65, "endLine": 68, "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/little_endian.h", "funcName": "__le16_to_cpup", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const __le16 *p"], "output": "static__inline____u16", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __inline__ __u16 __le16_to_cpup (const __le16 *p)\n", "{\n", "    return (__u16) *p;\n", "}\n"], "called_function_list": ["__swab16p"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__cpu_to_be64p": [{"capabilities": [], "helperCallParams": {}, "startLine": 69, "endLine": 72, "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/big_endian.h", "funcName": "__cpu_to_be64p", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const __u64 *p"], "output": "static__inline____be64", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __inline__ __be64 __cpu_to_be64p (const __u64 *p)\n", "{\n", "    return (__be64) *p;\n", "}\n"], "called_function_list": ["__swab64p"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 69, "endLine": 72, "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/little_endian.h", "funcName": "__cpu_to_be64p", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const __u64 *p"], "output": "static__inline____be64", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __inline__ __be64 __cpu_to_be64p (const __u64 *p)\n", "{\n", "    return (__be64) __swab64p (p);\n", "}\n"], "called_function_list": ["__swab64p"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__be64_to_cpup": [{"capabilities": [], "helperCallParams": {}, "startLine": 73, "endLine": 76, "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/big_endian.h", "funcName": "__be64_to_cpup", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const __be64 *p"], "output": "static__inline____u64", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __inline__ __u64 __be64_to_cpup (const __be64 *p)\n", "{\n", "    return (__u64) *p;\n", "}\n"], "called_function_list": ["__swab64p"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 73, "endLine": 76, "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/little_endian.h", "funcName": "__be64_to_cpup", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const __be64 *p"], "output": "static__inline____u64", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __inline__ __u64 __be64_to_cpup (const __be64 *p)\n", "{\n", "    return __swab64p ((__u64 *) p);\n", "}\n"], "called_function_list": ["__swab64p"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__cpu_to_be32p": [{"capabilities": [], "helperCallParams": {}, "startLine": 77, "endLine": 80, "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/big_endian.h", "funcName": "__cpu_to_be32p", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const __u32 *p"], "output": "static__inline____be32", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __inline__ __be32 __cpu_to_be32p (const __u32 *p)\n", "{\n", "    return (__be32) *p;\n", "}\n"], "called_function_list": ["__swab32p"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 77, "endLine": 80, "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/little_endian.h", "funcName": "__cpu_to_be32p", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const __u32 *p"], "output": "static__inline____be32", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __inline__ __be32 __cpu_to_be32p (const __u32 *p)\n", "{\n", "    return (__be32) __swab32p (p);\n", "}\n"], "called_function_list": ["__swab32p"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__be32_to_cpup": [{"capabilities": [], "helperCallParams": {}, "startLine": 81, "endLine": 84, "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/big_endian.h", "funcName": "__be32_to_cpup", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const __be32 *p"], "output": "static__inline____u32", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __inline__ __u32 __be32_to_cpup (const __be32 *p)\n", "{\n", "    return (__u32) *p;\n", "}\n"], "called_function_list": ["__swab32p"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 81, "endLine": 84, "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/little_endian.h", "funcName": "__be32_to_cpup", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const __be32 *p"], "output": "static__inline____u32", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __inline__ __u32 __be32_to_cpup (const __be32 *p)\n", "{\n", "    return __swab32p ((__u32 *) p);\n", "}\n"], "called_function_list": ["__swab32p"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__cpu_to_be16p": [{"capabilities": [], "helperCallParams": {}, "startLine": 85, "endLine": 88, "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/big_endian.h", "funcName": "__cpu_to_be16p", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const __u16 *p"], "output": "static__inline____be16", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __inline__ __be16 __cpu_to_be16p (const __u16 *p)\n", "{\n", "    return (__be16) *p;\n", "}\n"], "called_function_list": ["__swab16p"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 85, "endLine": 88, "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/little_endian.h", "funcName": "__cpu_to_be16p", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const __u16 *p"], "output": "static__inline____be16", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __inline__ __be16 __cpu_to_be16p (const __u16 *p)\n", "{\n", "    return (__be16) __swab16p (p);\n", "}\n"], "called_function_list": ["__swab16p"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__be16_to_cpup": [{"capabilities": [], "helperCallParams": {}, "startLine": 89, "endLine": 92, "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/big_endian.h", "funcName": "__be16_to_cpup", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const __be16 *p"], "output": "static__inline____u16", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __inline__ __u16 __be16_to_cpup (const __be16 *p)\n", "{\n", "    return (__u16) *p;\n", "}\n"], "called_function_list": ["__swab16p"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 89, "endLine": 92, "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/little_endian.h", "funcName": "__be16_to_cpup", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const __be16 *p"], "output": "static__inline____u16", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __inline__ __u16 __be16_to_cpup (const __be16 *p)\n", "{\n", "    return __swab16p ((__u16 *) p);\n", "}\n"], "called_function_list": ["__swab16p"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__bpf_memset_builtin": [{"capabilities": [], "helperCallParams": {}, "startLine": 38, "endLine": 45, "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/builtins.h", "funcName": "__bpf_memset_builtin", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["void *d", " __u8 c", " __u64 len"], "output": "static__always_inline__maybe_unusedvoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused void __bpf_memset_builtin (void *d, __u8 c, __u64 len)\n", "{\n", "    __builtin_memset (d, c, len);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__bpf_memzero": [{"capabilities": [], "helperCallParams": {}, "startLine": 47, "endLine": 126, "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/builtins.h", "funcName": "__bpf_memzero", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["void *d", " __u64 len"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void __bpf_memzero (void *d, __u64 len)\n", "{\n", "\n", "#if __clang_major__ >= 10\n", "    if (!__builtin_constant_p (len))\n", "        __throw_build_bug ();\n", "    d += len;\n", "    switch (len) {\n", "    case 96 :\n", "        __it_set (d, 64);\n", "    case 88 :\n", "    jmp_88 :\n", "        __it_set (d, 64);\n", "    case 80 :\n", "    jmp_80 :\n", "        __it_set (d, 64);\n", "    case 72 :\n", "    jmp_72 :\n", "        __it_set (d, 64);\n", "    case 64 :\n", "    jmp_64 :\n", "        __it_set (d, 64);\n", "    case 56 :\n", "    jmp_56 :\n", "        __it_set (d, 64);\n", "    case 48 :\n", "    jmp_48 :\n", "        __it_set (d, 64);\n", "    case 40 :\n", "    jmp_40 :\n", "        __it_set (d, 64);\n", "    case 32 :\n", "    jmp_32 :\n", "        __it_set (d, 64);\n", "    case 24 :\n", "    jmp_24 :\n", "        __it_set (d, 64);\n", "    case 16 :\n", "    jmp_16 :\n", "        __it_set (d, 64);\n", "    case 8 :\n", "    jmp_8 :\n", "        __it_set (d, 64);\n", "        break;\n", "    case 94 :\n", "        __it_set (d, 16);\n", "        __it_set (d, 32);\n", "        goto jmp_88;\n", "    case 86 :\n", "        __it_set (d, 16);\n", "        __it_set (d, 32);\n", "        goto jmp_80;\n", "    case 78 :\n", "        __it_set (d, 16);\n", "        __it_set (d, 32);\n", "        goto jmp_72;\n", "    case 70 :\n", "        __it_set (d, 16);\n", "        __it_set (d, 32);\n", "        goto jmp_64;\n", "    case 62 :\n", "        __it_set (d, 16);\n", "        __it_set (d, 32);\n", "        goto jmp_56;\n", "    case 54 :\n", "        __it_set (d, 16);\n", "        __it_set (d, 32);\n", "        goto jmp_48;\n", "    case 46 :\n", "        __it_set (d, 16);\n", "        __it_set (d, 32);\n", "        goto jmp_40;\n", "    case 38 :\n", "        __it_set (d, 16);\n", "        __it_set (d, 32);\n", "        goto jmp_32;\n", "    case 30 :\n", "        __it_set (d, 16);\n", "        __it_set (d, 32);\n", "        goto jmp_24;\n", "    case 22 :\n", "        __it_set (d, 16);\n", "        __it_set (d, 32);\n", "        goto jmp_16;\n", "    case 14 :\n", "        __it_set (d, 16);\n", "        __it_set (d, 32);\n", "        goto jmp_8;\n", "    case 6 :\n", "        __it_set (d, 16);\n", "        __it_set (d, 32);\n", "        break;\n", "    case 92 :\n", "        __it_set (d, 32);\n", "        goto jmp_88;\n", "    case 84 :\n", "        __it_set (d, 32);\n", "        goto jmp_80;\n", "    case 76 :\n", "        __it_set (d, 32);\n", "        goto jmp_72;\n", "    case 68 :\n", "        __it_set (d, 32);\n", "        goto jmp_64;\n", "    case 60 :\n", "        __it_set (d, 32);\n", "        goto jmp_56;\n", "    case 52 :\n", "        __it_set (d, 32);\n", "        goto jmp_48;\n", "    case 44 :\n", "        __it_set (d, 32);\n", "        goto jmp_40;\n", "    case 36 :\n", "        __it_set (d, 32);\n", "        goto jmp_32;\n", "    case 28 :\n", "        __it_set (d, 32);\n", "        goto jmp_24;\n", "    case 20 :\n", "        __it_set (d, 32);\n", "        goto jmp_16;\n", "    case 12 :\n", "        __it_set (d, 32);\n", "        goto jmp_8;\n", "    case 4 :\n", "        __it_set (d, 32);\n", "        break;\n", "    case 90 :\n", "        __it_set (d, 16);\n", "        goto jmp_88;\n", "    case 82 :\n", "        __it_set (d, 16);\n", "        goto jmp_80;\n", "    case 74 :\n", "        __it_set (d, 16);\n", "        goto jmp_72;\n", "    case 66 :\n", "        __it_set (d, 16);\n", "        goto jmp_64;\n", "    case 58 :\n", "        __it_set (d, 16);\n", "        goto jmp_56;\n", "    case 50 :\n", "        __it_set (d, 16);\n", "        goto jmp_48;\n", "    case 42 :\n", "        __it_set (d, 16);\n", "        goto jmp_40;\n", "    case 34 :\n", "        __it_set (d, 16);\n", "        goto jmp_32;\n", "    case 26 :\n", "        __it_set (d, 16);\n", "        goto jmp_24;\n", "    case 18 :\n", "        __it_set (d, 16);\n", "        goto jmp_16;\n", "    case 10 :\n", "        __it_set (d, 16);\n", "        goto jmp_8;\n", "    case 2 :\n", "        __it_set (d, 16);\n", "        break;\n", "    case 1 :\n", "        __it_set (d, 8);\n", "        break;\n", "    default :\n", "        __throw_build_bug ();\n", "    }\n", "\n", "#else\n", "    __bpf_memset_builtin (d, 0, len);\n", "\n", "#endif\n", "}\n"], "called_function_list": ["__bpf_memset_builtin"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__bpf_no_builtin_memset": [{"capabilities": [], "helperCallParams": {}, "startLine": 128, "endLine": 133, "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/builtins.h", "funcName": "__bpf_no_builtin_memset", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["void * d __maybe_unused", " __u8 c __maybe_unused", " __u64 len __maybe_unused"], "output": "static__always_inline__maybe_unusedvoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused void __bpf_no_builtin_memset (void * d __maybe_unused, __u8 c __maybe_unused, __u64 len __maybe_unused)\n", "{\n", "    __throw_build_bug ();\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "memset": [{"capabilities": [], "helperCallParams": {}, "startLine": 138, "endLine": 145, "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/builtins.h", "funcName": "memset", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["void *d", " int c", " __u64 len"], "output": "\\memset\\)void", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline  __nobuiltin (\"memset\") void memset (void *d, int c, __u64 len)\n", "{\n", "    if (__builtin_constant_p (len) && __builtin_constant_p (c) && c == 0)\n", "        __bpf_memzero (d, len);\n", "    else\n", "        __bpf_memset_builtin (d, (__u8) c, len);\n", "}\n"], "called_function_list": ["__bpf_memset_builtin", "__bpf_memzero"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__bpf_memcpy_builtin": [{"capabilities": [], "helperCallParams": {}, "startLine": 147, "endLine": 152, "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/builtins.h", "funcName": "__bpf_memcpy_builtin", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["void *d", " const void *s", " __u64 len"], "output": "static__always_inline__maybe_unusedvoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused void __bpf_memcpy_builtin (void *d, const void *s, __u64 len)\n", "{\n", "    __builtin_memcpy (d, s, len);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__bpf_memcpy": [{"capabilities": [], "helperCallParams": {}, "startLine": 154, "endLine": 239, "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/builtins.h", "funcName": "__bpf_memcpy", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["void *d", " const void *s", " __u64 len"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void __bpf_memcpy (void *d, const void *s, __u64 len)\n", "{\n", "\n", "#if __clang_major__ >= 10\n", "    if (!__builtin_constant_p (len))\n", "        __throw_build_bug ();\n", "    d += len;\n", "    s += len;\n", "    if (len > 1 && len % 2 == 1) {\n", "        __it_mob (d, s, 8);\n", "        len -= 1;\n", "    }\n", "    switch (len) {\n", "    case 96 :\n", "        __it_mob (d, s, 64);\n", "    case 88 :\n", "    jmp_88 :\n", "        __it_mob (d, s, 64);\n", "    case 80 :\n", "    jmp_80 :\n", "        __it_mob (d, s, 64);\n", "    case 72 :\n", "    jmp_72 :\n", "        __it_mob (d, s, 64);\n", "    case 64 :\n", "    jmp_64 :\n", "        __it_mob (d, s, 64);\n", "    case 56 :\n", "    jmp_56 :\n", "        __it_mob (d, s, 64);\n", "    case 48 :\n", "    jmp_48 :\n", "        __it_mob (d, s, 64);\n", "    case 40 :\n", "    jmp_40 :\n", "        __it_mob (d, s, 64);\n", "    case 32 :\n", "    jmp_32 :\n", "        __it_mob (d, s, 64);\n", "    case 24 :\n", "    jmp_24 :\n", "        __it_mob (d, s, 64);\n", "    case 16 :\n", "    jmp_16 :\n", "        __it_mob (d, s, 64);\n", "    case 8 :\n", "    jmp_8 :\n", "        __it_mob (d, s, 64);\n", "        break;\n", "    case 94 :\n", "        __it_mob (d, s, 16);\n", "        __it_mob (d, s, 32);\n", "        goto jmp_88;\n", "    case 86 :\n", "        __it_mob (d, s, 16);\n", "        __it_mob (d, s, 32);\n", "        goto jmp_80;\n", "    case 78 :\n", "        __it_mob (d, s, 16);\n", "        __it_mob (d, s, 32);\n", "        goto jmp_72;\n", "    case 70 :\n", "        __it_mob (d, s, 16);\n", "        __it_mob (d, s, 32);\n", "        goto jmp_64;\n", "    case 62 :\n", "        __it_mob (d, s, 16);\n", "        __it_mob (d, s, 32);\n", "        goto jmp_56;\n", "    case 54 :\n", "        __it_mob (d, s, 16);\n", "        __it_mob (d, s, 32);\n", "        goto jmp_48;\n", "    case 46 :\n", "        __it_mob (d, s, 16);\n", "        __it_mob (d, s, 32);\n", "        goto jmp_40;\n", "    case 38 :\n", "        __it_mob (d, s, 16);\n", "        __it_mob (d, s, 32);\n", "        goto jmp_32;\n", "    case 30 :\n", "        __it_mob (d, s, 16);\n", "        __it_mob (d, s, 32);\n", "        goto jmp_24;\n", "    case 22 :\n", "        __it_mob (d, s, 16);\n", "        __it_mob (d, s, 32);\n", "        goto jmp_16;\n", "    case 14 :\n", "        __it_mob (d, s, 16);\n", "        __it_mob (d, s, 32);\n", "        goto jmp_8;\n", "    case 6 :\n", "        __it_mob (d, s, 16);\n", "        __it_mob (d, s, 32);\n", "        break;\n", "    case 92 :\n", "        __it_mob (d, s, 32);\n", "        goto jmp_88;\n", "    case 84 :\n", "        __it_mob (d, s, 32);\n", "        goto jmp_80;\n", "    case 76 :\n", "        __it_mob (d, s, 32);\n", "        goto jmp_72;\n", "    case 68 :\n", "        __it_mob (d, s, 32);\n", "        goto jmp_64;\n", "    case 60 :\n", "        __it_mob (d, s, 32);\n", "        goto jmp_56;\n", "    case 52 :\n", "        __it_mob (d, s, 32);\n", "        goto jmp_48;\n", "    case 44 :\n", "        __it_mob (d, s, 32);\n", "        goto jmp_40;\n", "    case 36 :\n", "        __it_mob (d, s, 32);\n", "        goto jmp_32;\n", "    case 28 :\n", "        __it_mob (d, s, 32);\n", "        goto jmp_24;\n", "    case 20 :\n", "        __it_mob (d, s, 32);\n", "        goto jmp_16;\n", "    case 12 :\n", "        __it_mob (d, s, 32);\n", "        goto jmp_8;\n", "    case 4 :\n", "        __it_mob (d, s, 32);\n", "        break;\n", "    case 90 :\n", "        __it_mob (d, s, 16);\n", "        goto jmp_88;\n", "    case 82 :\n", "        __it_mob (d, s, 16);\n", "        goto jmp_80;\n", "    case 74 :\n", "        __it_mob (d, s, 16);\n", "        goto jmp_72;\n", "    case 66 :\n", "        __it_mob (d, s, 16);\n", "        goto jmp_64;\n", "    case 58 :\n", "        __it_mob (d, s, 16);\n", "        goto jmp_56;\n", "    case 50 :\n", "        __it_mob (d, s, 16);\n", "        goto jmp_48;\n", "    case 42 :\n", "        __it_mob (d, s, 16);\n", "        goto jmp_40;\n", "    case 34 :\n", "        __it_mob (d, s, 16);\n", "        goto jmp_32;\n", "    case 26 :\n", "        __it_mob (d, s, 16);\n", "        goto jmp_24;\n", "    case 18 :\n", "        __it_mob (d, s, 16);\n", "        goto jmp_16;\n", "    case 10 :\n", "        __it_mob (d, s, 16);\n", "        goto jmp_8;\n", "    case 2 :\n", "        __it_mob (d, s, 16);\n", "        break;\n", "    case 1 :\n", "        __it_mob (d, s, 8);\n", "        break;\n", "    default :\n", "        __throw_build_bug ();\n", "    }\n", "\n", "#else\n", "    __bpf_memcpy_builtin (d, s, len);\n", "\n", "#endif\n", "}\n"], "called_function_list": ["__bpf_memcpy_builtin"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__bpf_no_builtin_memcpy": [{"capabilities": [], "helperCallParams": {}, "startLine": 241, "endLine": 246, "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/builtins.h", "funcName": "__bpf_no_builtin_memcpy", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["void * d __maybe_unused", " const void * s __maybe_unused", " __u64 len __maybe_unused"], "output": "static__always_inline__maybe_unusedvoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused void __bpf_no_builtin_memcpy (void * d __maybe_unused, const void * s __maybe_unused, __u64 len __maybe_unused)\n", "{\n", "    __throw_build_bug ();\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "memcpy": [{"capabilities": [], "helperCallParams": {}, "startLine": 251, "endLine": 255, "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/builtins.h", "funcName": "memcpy", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["void *d", " const void *s", " __u64 len"], "output": "\\memcpy\\)void", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline  __nobuiltin (\"memcpy\") void memcpy (void *d, const void *s, __u64 len)\n", "{\n", "    return __bpf_memcpy (d, s, len);\n", "}\n"], "called_function_list": ["__bpf_memcpy"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__bpf_memcmp_builtin": [{"capabilities": [], "helperCallParams": {}, "startLine": 257, "endLine": 270, "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/builtins.h", "funcName": "__bpf_memcmp_builtin", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const void *x", " const void *y", " __u64 len"], "output": "static__always_inline__maybe_unused__u64", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused __u64 __bpf_memcmp_builtin (const void *x, const void *y, __u64 len)\n", "{\n", "    return __builtin_bcmp (x, y, len);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__bpf_memcmp": [{"capabilities": [], "helperCallParams": {}, "startLine": 272, "endLine": 345, "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/builtins.h", "funcName": "__bpf_memcmp", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const void *x", " const void *y", " __u64 len"], "output": "static__always_inline__u64", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __u64 __bpf_memcmp (const void *x, const void *y, __u64 len)\n", "{\n", "\n", "#if __clang_major__ >= 10\n", "    __u64 r = 0;\n", "    if (!__builtin_constant_p (len))\n", "        __throw_build_bug ();\n", "    x += len;\n", "    y += len;\n", "    if (len > 1 && len % 2 == 1) {\n", "        __it_xor (x, y, r, 8);\n", "        len -= 1;\n", "    }\n", "    switch (len) {\n", "    case 72 :\n", "        __it_xor (x, y, r, 64);\n", "    case 64 :\n", "    jmp_64 :\n", "        __it_xor (x, y, r, 64);\n", "    case 56 :\n", "    jmp_56 :\n", "        __it_xor (x, y, r, 64);\n", "    case 48 :\n", "    jmp_48 :\n", "        __it_xor (x, y, r, 64);\n", "    case 40 :\n", "    jmp_40 :\n", "        __it_xor (x, y, r, 64);\n", "    case 32 :\n", "    jmp_32 :\n", "        __it_xor (x, y, r, 64);\n", "    case 24 :\n", "    jmp_24 :\n", "        __it_xor (x, y, r, 64);\n", "    case 16 :\n", "    jmp_16 :\n", "        __it_xor (x, y, r, 64);\n", "    case 8 :\n", "    jmp_8 :\n", "        __it_xor (x, y, r, 64);\n", "        break;\n", "    case 70 :\n", "        __it_xor (x, y, r, 16);\n", "        __it_xor (x, y, r, 32);\n", "        goto jmp_64;\n", "    case 62 :\n", "        __it_xor (x, y, r, 16);\n", "        __it_xor (x, y, r, 32);\n", "        goto jmp_56;\n", "    case 54 :\n", "        __it_xor (x, y, r, 16);\n", "        __it_xor (x, y, r, 32);\n", "        goto jmp_48;\n", "    case 46 :\n", "        __it_xor (x, y, r, 16);\n", "        __it_xor (x, y, r, 32);\n", "        goto jmp_40;\n", "    case 38 :\n", "        __it_xor (x, y, r, 16);\n", "        __it_xor (x, y, r, 32);\n", "        goto jmp_32;\n", "    case 30 :\n", "        __it_xor (x, y, r, 16);\n", "        __it_xor (x, y, r, 32);\n", "        goto jmp_24;\n", "    case 22 :\n", "        __it_xor (x, y, r, 16);\n", "        __it_xor (x, y, r, 32);\n", "        goto jmp_16;\n", "    case 14 :\n", "        __it_xor (x, y, r, 16);\n", "        __it_xor (x, y, r, 32);\n", "        goto jmp_8;\n", "    case 6 :\n", "        __it_xor (x, y, r, 16);\n", "        __it_xor (x, y, r, 32);\n", "        break;\n", "    case 68 :\n", "        __it_xor (x, y, r, 32);\n", "        goto jmp_64;\n", "    case 60 :\n", "        __it_xor (x, y, r, 32);\n", "        goto jmp_56;\n", "    case 52 :\n", "        __it_xor (x, y, r, 32);\n", "        goto jmp_48;\n", "    case 44 :\n", "        __it_xor (x, y, r, 32);\n", "        goto jmp_40;\n", "    case 36 :\n", "        __it_xor (x, y, r, 32);\n", "        goto jmp_32;\n", "    case 28 :\n", "        __it_xor (x, y, r, 32);\n", "        goto jmp_24;\n", "    case 20 :\n", "        __it_xor (x, y, r, 32);\n", "        goto jmp_16;\n", "    case 12 :\n", "        __it_xor (x, y, r, 32);\n", "        goto jmp_8;\n", "    case 4 :\n", "        __it_xor (x, y, r, 32);\n", "        break;\n", "    case 66 :\n", "        __it_xor (x, y, r, 16);\n", "        goto jmp_64;\n", "    case 58 :\n", "        __it_xor (x, y, r, 16);\n", "        goto jmp_56;\n", "    case 50 :\n", "        __it_xor (x, y, r, 16);\n", "        goto jmp_48;\n", "    case 42 :\n", "        __it_xor (x, y, r, 16);\n", "        goto jmp_40;\n", "    case 34 :\n", "        __it_xor (x, y, r, 16);\n", "        goto jmp_32;\n", "    case 26 :\n", "        __it_xor (x, y, r, 16);\n", "        goto jmp_24;\n", "    case 18 :\n", "        __it_xor (x, y, r, 16);\n", "        goto jmp_16;\n", "    case 10 :\n", "        __it_xor (x, y, r, 16);\n", "        goto jmp_8;\n", "    case 2 :\n", "        __it_xor (x, y, r, 16);\n", "        break;\n", "    case 1 :\n", "        __it_xor (x, y, r, 8);\n", "        break;\n", "    default :\n", "        __throw_build_bug ();\n", "    }\n", "    return r;\n", "\n", "#else\n", "    return __bpf_memcmp_builtin (x, y, len);\n", "\n", "#endif\n", "}\n"], "called_function_list": ["__bpf_memcmp_builtin"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__bpf_no_builtin_memcmp": [{"capabilities": [], "helperCallParams": {}, "startLine": 347, "endLine": 353, "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/builtins.h", "funcName": "__bpf_no_builtin_memcmp", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const void * x __maybe_unused", " const void * y __maybe_unused", " __u64 len __maybe_unused"], "output": "static__always_inline__maybe_unused__u64", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused __u64 __bpf_no_builtin_memcmp (const void * x __maybe_unused, const void * y __maybe_unused, __u64 len __maybe_unused)\n", "{\n", "    __throw_build_bug ();\n", "    return 0;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "memcmp": [{"capabilities": [], "helperCallParams": {}, "startLine": 361, "endLine": 366, "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/builtins.h", "funcName": "memcmp", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const void *x", " const void *y", " __u64 len"], "output": "\\memcmp\\)__u64", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline  __nobuiltin (\"memcmp\") __u64 memcmp (const void *x, const void *y, __u64 len)\n", "{\n", "    return __bpf_memcmp (x, y, len);\n", "}\n"], "called_function_list": ["__bpf_memcmp"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__bpf_memmove_builtin": [{"capabilities": [], "helperCallParams": {}, "startLine": 368, "endLine": 373, "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/builtins.h", "funcName": "__bpf_memmove_builtin", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["void *d", " const void *s", " __u64 len"], "output": "static__always_inline__maybe_unusedvoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused void __bpf_memmove_builtin (void *d, const void *s, __u64 len)\n", "{\n", "    __builtin_memmove (d, s, len);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__bpf_memmove_bwd": [{"capabilities": [], "helperCallParams": {}, "startLine": 375, "endLine": 379, "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/builtins.h", "funcName": "__bpf_memmove_bwd", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["void *d", " const void *s", " __u64 len"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void __bpf_memmove_bwd (void *d, const void *s, __u64 len)\n", "{\n", "    __bpf_memcpy (d, s, len);\n", "}\n"], "called_function_list": ["__bpf_memcpy"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__bpf_memmove_fwd": [{"capabilities": [], "helperCallParams": {}, "startLine": 381, "endLine": 458, "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/builtins.h", "funcName": "__bpf_memmove_fwd", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["void *d", " const void *s", " __u64 len"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void __bpf_memmove_fwd (void *d, const void *s, __u64 len)\n", "{\n", "\n", "#if __clang_major__ >= 10\n", "    if (!__builtin_constant_p (len))\n", "        __throw_build_bug ();\n", "    switch (len) {\n", "    case 96 :\n", "        __it_mof (d, s, 64);\n", "    case 88 :\n", "    jmp_88 :\n", "        __it_mof (d, s, 64);\n", "    case 80 :\n", "    jmp_80 :\n", "        __it_mof (d, s, 64);\n", "    case 72 :\n", "    jmp_72 :\n", "        __it_mof (d, s, 64);\n", "    case 64 :\n", "    jmp_64 :\n", "        __it_mof (d, s, 64);\n", "    case 56 :\n", "    jmp_56 :\n", "        __it_mof (d, s, 64);\n", "    case 48 :\n", "    jmp_48 :\n", "        __it_mof (d, s, 64);\n", "    case 40 :\n", "    jmp_40 :\n", "        __it_mof (d, s, 64);\n", "    case 32 :\n", "    jmp_32 :\n", "        __it_mof (d, s, 64);\n", "    case 24 :\n", "    jmp_24 :\n", "        __it_mof (d, s, 64);\n", "    case 16 :\n", "    jmp_16 :\n", "        __it_mof (d, s, 64);\n", "    case 8 :\n", "    jmp_8 :\n", "        __it_mof (d, s, 64);\n", "        break;\n", "    case 94 :\n", "        __it_mof (d, s, 16);\n", "        __it_mof (d, s, 32);\n", "        goto jmp_88;\n", "    case 86 :\n", "        __it_mof (d, s, 16);\n", "        __it_mof (d, s, 32);\n", "        goto jmp_80;\n", "    case 78 :\n", "        __it_mof (d, s, 16);\n", "        __it_mof (d, s, 32);\n", "        goto jmp_72;\n", "    case 70 :\n", "        __it_mof (d, s, 16);\n", "        __it_mof (d, s, 32);\n", "        goto jmp_64;\n", "    case 62 :\n", "        __it_mof (d, s, 16);\n", "        __it_mof (d, s, 32);\n", "        goto jmp_56;\n", "    case 54 :\n", "        __it_mof (d, s, 16);\n", "        __it_mof (d, s, 32);\n", "        goto jmp_48;\n", "    case 46 :\n", "        __it_mof (d, s, 16);\n", "        __it_mof (d, s, 32);\n", "        goto jmp_40;\n", "    case 38 :\n", "        __it_mof (d, s, 16);\n", "        __it_mof (d, s, 32);\n", "        goto jmp_32;\n", "    case 30 :\n", "        __it_mof (d, s, 16);\n", "        __it_mof (d, s, 32);\n", "        goto jmp_24;\n", "    case 22 :\n", "        __it_mof (d, s, 16);\n", "        __it_mof (d, s, 32);\n", "        goto jmp_16;\n", "    case 14 :\n", "        __it_mof (d, s, 16);\n", "        __it_mof (d, s, 32);\n", "        goto jmp_8;\n", "    case 6 :\n", "        __it_mof (d, s, 16);\n", "        __it_mof (d, s, 32);\n", "        break;\n", "    case 92 :\n", "        __it_mof (d, s, 32);\n", "        goto jmp_88;\n", "    case 84 :\n", "        __it_mof (d, s, 32);\n", "        goto jmp_80;\n", "    case 76 :\n", "        __it_mof (d, s, 32);\n", "        goto jmp_72;\n", "    case 68 :\n", "        __it_mof (d, s, 32);\n", "        goto jmp_64;\n", "    case 60 :\n", "        __it_mof (d, s, 32);\n", "        goto jmp_56;\n", "    case 52 :\n", "        __it_mof (d, s, 32);\n", "        goto jmp_48;\n", "    case 44 :\n", "        __it_mof (d, s, 32);\n", "        goto jmp_40;\n", "    case 36 :\n", "        __it_mof (d, s, 32);\n", "        goto jmp_32;\n", "    case 28 :\n", "        __it_mof (d, s, 32);\n", "        goto jmp_24;\n", "    case 20 :\n", "        __it_mof (d, s, 32);\n", "        goto jmp_16;\n", "    case 12 :\n", "        __it_mof (d, s, 32);\n", "        goto jmp_8;\n", "    case 4 :\n", "        __it_mof (d, s, 32);\n", "        break;\n", "    case 90 :\n", "        __it_mof (d, s, 16);\n", "        goto jmp_88;\n", "    case 82 :\n", "        __it_mof (d, s, 16);\n", "        goto jmp_80;\n", "    case 74 :\n", "        __it_mof (d, s, 16);\n", "        goto jmp_72;\n", "    case 66 :\n", "        __it_mof (d, s, 16);\n", "        goto jmp_64;\n", "    case 58 :\n", "        __it_mof (d, s, 16);\n", "        goto jmp_56;\n", "    case 50 :\n", "        __it_mof (d, s, 16);\n", "        goto jmp_48;\n", "    case 42 :\n", "        __it_mof (d, s, 16);\n", "        goto jmp_40;\n", "    case 34 :\n", "        __it_mof (d, s, 16);\n", "        goto jmp_32;\n", "    case 26 :\n", "        __it_mof (d, s, 16);\n", "        goto jmp_24;\n", "    case 18 :\n", "        __it_mof (d, s, 16);\n", "        goto jmp_16;\n", "    case 10 :\n", "        __it_mof (d, s, 16);\n", "        goto jmp_8;\n", "    case 2 :\n", "        __it_mof (d, s, 16);\n", "        break;\n", "    case 1 :\n", "        __it_mof (d, s, 8);\n", "        break;\n", "    default :\n", "        __throw_build_bug ();\n", "    }\n", "\n", "#else\n", "    __bpf_memmove_builtin (d, s, len);\n", "\n", "#endif\n", "}\n"], "called_function_list": ["__bpf_memmove_builtin"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__bpf_no_builtin_memmove": [{"capabilities": [], "helperCallParams": {}, "startLine": 460, "endLine": 465, "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/builtins.h", "funcName": "__bpf_no_builtin_memmove", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["void * d __maybe_unused", " const void * s __maybe_unused", " __u64 len __maybe_unused"], "output": "static__always_inline__maybe_unusedvoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused void __bpf_no_builtin_memmove (void * d __maybe_unused, const void * s __maybe_unused, __u64 len __maybe_unused)\n", "{\n", "    __throw_build_bug ();\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__bpf_memmove": [{"capabilities": [], "helperCallParams": {}, "startLine": 470, "endLine": 485, "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/builtins.h", "funcName": "__bpf_memmove", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["void *d", " const void *s", " __u64 len"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void __bpf_memmove (void *d, const void *s, __u64 len)\n", "{\n", "    if (d <= s)\n", "        return __bpf_memmove_fwd (d, s, len);\n", "    else\n", "        return __bpf_memmove_bwd (d, s, len);\n", "}\n"], "called_function_list": ["__bpf_memmove_bwd", "__bpf_memmove_fwd"], "call_depth": 3, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "memmove": [{"capabilities": [], "helperCallParams": {}, "startLine": 487, "endLine": 492, "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/builtins.h", "funcName": "memmove", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["void *d", " const void *s", " __u64 len"], "output": "\\memmove\\)void", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline  __nobuiltin (\"memmove\") void memmove (void *d, const void *s, __u64 len)\n", "{\n", "    return __bpf_memmove (d, s, len);\n", "}\n"], "called_function_list": ["__bpf_memmove"], "call_depth": 4, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "tail_call_static": [{"capabilities": [], "helperCallParams": {}, "startLine": 10, "endLine": 33, "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/tailcall.h", "funcName": "tail_call_static", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct  __ctx_buff *ctx", " const void *map", " const __u32 slot"], "output": "static__always_inline__maybe_unusedvoid", "helper": ["tail_call"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused void tail_call_static (const struct  __ctx_buff *ctx, const void *map, const __u32 slot)\n", "{\n", "    if (!__builtin_constant_p (slot))\n", "        __throw_build_bug ();\n", "    asm volatile (\"r1 = %[ctx]\\n\\t\"\n", "        \"r2 = %[map]\\n\\t\"\n", "        \"r3 = %[slot]\\n\\t\"\n", "        \"call 12\\n\\t\"\n", "        : : [ctx] \"r\"\n", "        (ctx), [map] \"r\"\n", "        (map), [slot] \"i\"\n", "        (slot) : \"r0\",\n", "        \"r1\",\n", "        \"r2\",\n", "        \"r3\",\n", "        \"r4\",\n", "        \"r5\"\n", "        );\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "tail_call_dynamic": [{"capabilities": [], "helperCallParams": {}, "startLine": 35, "endLine": 46, "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/tailcall.h", "funcName": "tail_call_dynamic", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __ctx_buff *ctx", " const void *map", " __u32 slot"], "output": "static__always_inline__maybe_unusedvoid", "helper": ["tail_call"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused void tail_call_dynamic (struct  __ctx_buff *ctx, const void *map, __u32 slot)\n", "{\n", "    if (__builtin_constant_p (slot))\n", "        __throw_build_bug ();\n", "    tail_call (ctx, map, slot);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "relax_verifier": [{"capabilities": [{"capability": "read_sys_info", "read_sys_info": [{"Project": "cilium", "Return Type": "u32", "Description": "Get the SMP (symmetric multiprocessing) processor id. Note that all programs run with preemption disabled , which means that the SMP processor id is stable during all the execution of the program. ", "Return": " The SMP id of the processor running the program.", "Function Name": "get_smp_processor_id", "Input Params": ["{Type: voi ,Var: void}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "raw_tracepoint_writable"], "capabilities": ["read_sys_info"]}]}], "helperCallParams": {}, "startLine": 13, "endLine": 18, "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/verifier.h", "funcName": "relax_verifier", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["void"], "output": "static__always_inlinevoid", "helper": ["get_smp_processor_id"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void relax_verifier (void)\n", "{\n", "\n", "#ifndef HAVE_LARGE_INSN_LIMIT\n", "    volatile int __maybe_unused id = get_smp_processor_id ();\n", "\n", "#endif\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "map_array_get_32": [{"capabilities": [], "helperCallParams": {}, "startLine": 10, "endLine": 33, "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/access.h", "funcName": "map_array_get_32", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const __u32 *array", " __u32 index", " const __u32 limit"], "output": "static__always_inline__maybe_unused__u32", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused __u32 map_array_get_32 (const __u32 *array, __u32 index, const __u32 limit)\n", "{\n", "    __u32 datum = 0;\n", "    if (__builtin_constant_p (index) || !__builtin_constant_p (limit))\n", "        __throw_build_bug ();\n", "    asm volatile (\"%[index] <<= 2\\n\\t\"\n", "        \"if %[index] > %[limit] goto +1\\n\\t\"\n", "        \"%[array] += %[index]\\n\\t\"\n", "        \"%[datum] = *(u32 *)(%[array] + 0)\\n\\t\"\n", "        : [datum] \"=r\"\n", "        (datum) : [limit] \"i\"\n", "        (limit), [array] \"r\"\n", "        (array), [index] \"r\"\n", "        (index) :);\n", "    return datum;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "csum_fold": [{"capabilities": [], "helperCallParams": {}, "startLine": 10, "endLine": 15, "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/csum.h", "funcName": "csum_fold", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["__wsum csum"], "output": "static__always_inline__sum16", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __sum16 csum_fold (__wsum csum)\n", "{\n", "    csum = (csum & 0xffff) + (csum >> 16);\n", "    csum = (csum & 0xffff) + (csum >> 16);\n", "    return (__sum16) ~csum;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "csum_unfold": [{"capabilities": [], "helperCallParams": {}, "startLine": 17, "endLine": 20, "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/csum.h", "funcName": "csum_unfold", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["__sum16 csum"], "output": "static__always_inline__wsum", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __wsum csum_unfold (__sum16 csum)\n", "{\n", "    return (__wsum) csum;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "csum_add": [{"capabilities": [], "helperCallParams": {}, "startLine": 22, "endLine": 26, "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/csum.h", "funcName": "csum_add", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["__wsum csum", " __wsum addend"], "output": "static__always_inline__wsum", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __wsum csum_add (__wsum csum, __wsum addend)\n", "{\n", "    csum += addend;\n", "    return csum + (csum < addend);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "csum_sub": [{"capabilities": [], "helperCallParams": {}, "startLine": 28, "endLine": 31, "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/csum.h", "funcName": "csum_sub", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["__wsum csum", " __wsum addend"], "output": "static__always_inline__wsum", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __wsum csum_sub (__wsum csum, __wsum addend)\n", "{\n", "    return csum_add (csum, ~addend);\n", "}\n"], "called_function_list": ["csum_add"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "csum_diff": [{"capabilities": [{"capability": "read_skb", "read_skb": [{"Project": "cilium", "Return Type": "s64", "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ", "Return": " The checksum result, or a negative error code in case of failure.", "Function Name": "csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"], "compatible_hookpoints": ["sched_cls", "sched_act", "xdp", "lwt_in", "lwt_out", "lwt_xmit", "lwt_seg6local"], "capabilities": ["read_skb"]}]}], "helperCallParams": {}, "startLine": 33, "endLine": 52, "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/csum.h", "funcName": "csum_diff", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const void *from", " __u32 size_from", " const void *to", " __u32 size_to", " __u32 seed"], "output": "static__always_inline__wsum", "helper": ["csum_diff"], "compatibleHookpoints": ["sched_cls", "lwt_xmit", "xdp", "lwt_in", "sched_act", "lwt_out", "lwt_seg6local"], "source": ["static __always_inline __wsum csum_diff (const void *from, __u32 size_from, const void *to, __u32 size_to, __u32 seed)\n", "{\n", "    if (__builtin_constant_p (size_from) && __builtin_constant_p (size_to)) {\n", "        if (size_from == 4 && size_to == 4 && __builtin_constant_p (seed) && seed == 0)\n", "            return csum_add (~(*(__u32*) from), *(__u32*) to);\n", "        if (size_from == 4 && size_to == 4)\n", "            return csum_add (seed, csum_add (~(*(__u32*) from), *(__u32*) to));\n", "    }\n", "    return csum_diff_external (from, size_from, to, size_to, seed);\n", "}\n"], "called_function_list": ["csum_add"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "bpf_barrier": [{"capabilities": [], "helperCallParams": {}, "startLine": 86, "endLine": 93, "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/compiler.h", "funcName": "bpf_barrier", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["void"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void bpf_barrier (void)\n", "{\n", "    barrier ();\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ctx_redirect": [{"capabilities": [], "helperCallParams": {}, "startLine": 60, "endLine": 64, "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/skb.h", "funcName": "ctx_redirect", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct  __sk_buff * ctx __maybe_unused", " int ifindex", " __u32 flags"], "output": "static__always_inline__maybe_unusedint", "helper": ["redirect"], "compatibleHookpoints": ["lwt_xmit", "sched_cls", "xdp", "sched_act"], "source": ["static __always_inline __maybe_unused int ctx_redirect (const struct  __sk_buff * ctx __maybe_unused, int ifindex, __u32 flags)\n", "{\n", "    return redirect (ifindex, flags);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [{"capability": "pkt_alter_or_redo_processing_or_interface", "pkt_alter_or_redo_processing_or_interface": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_TX", "Return": 3, "Description": "an efficient option to transmit the network packet out of the same NIC it just arrived on again. This is typically useful when few nodes are implementing, for example, firewalling with subsequent load balancing in a cluster and thus act as a hairpinned load balancer pushing the incoming packets back into the switch after rewriting them in XDP BPF.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_alter_or_redo_processing_or_interface"]}]}], "helperCallParams": {}, "startLine": 291, "endLine": 298, "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/xdp.h", "funcName": "ctx_redirect", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct xdp_md *ctx", " int ifindex", " const __u32 flags"], "output": "static__always_inline__maybe_unusedint", "helper": ["redirect", "XDP_TX"], "compatibleHookpoints": ["xdp"], "source": ["static __always_inline __maybe_unused int ctx_redirect (const struct xdp_md *ctx, int ifindex, const __u32 flags)\n", "{\n", "    if ((__u32) ifindex == ctx->ingress_ifindex)\n", "        return XDP_TX;\n", "    return redirect (ifindex, flags);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ctx_redirect_peer": [{"capabilities": [], "helperCallParams": {}, "startLine": 66, "endLine": 70, "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/skb.h", "funcName": "ctx_redirect_peer", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct  __sk_buff * ctx __maybe_unused", " int ifindex", " __u32 flags"], "output": "static__always_inline__maybe_unusedint", "helper": ["redirect"], "compatibleHookpoints": ["lwt_xmit", "sched_cls", "xdp", "sched_act"], "source": ["static __always_inline __maybe_unused int ctx_redirect_peer (const struct  __sk_buff * ctx __maybe_unused, int ifindex, __u32 flags)\n", "{\n", "    return redirect_peer (ifindex, flags);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 300, "endLine": 307, "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/xdp.h", "funcName": "ctx_redirect_peer", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct xdp_md * ctx __maybe_unused", " int ifindex __maybe_unused", " const __u32 flags __maybe_unused"], "output": "static__always_inline__maybe_unusedint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused int ctx_redirect_peer (const struct xdp_md * ctx __maybe_unused, int ifindex __maybe_unused, const __u32 flags __maybe_unused)\n", "{\n", "    return -ENOTSUP;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ctx_adjust_troom": [{"capabilities": [{"capability": "update_pkt", "update_pkt": [{"Project": "cilium", "Return Type": "int", "Description": "Resize (trim or grow) the packet associated to <[ skb ]>(IP: 0) to the new len. The <[ flags ]>(IP: 2) are reserved for future usage , and must be left at zero. The basic idea is that the helper performs the needed work to change the size of the packet , then the eBPF program rewrites the rest via helpers like skb_store_bytes() , l3_csum_replace() , l3_csum_replace() and others. This helper is a slow path utility intended for replies with control messages. And because it is targeted for slow path , the helper itself can afford to be slow: it implicitly linearizes , unclones and drops offloads from the skb. A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "skb_change_tail", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  u32 ,Var: len}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["sched_cls", "sched_act", "lwt_xmit", "sk_skb"], "capabilities": ["update_pkt"]}]}], "helperCallParams": {}, "startLine": 72, "endLine": 76, "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/skb.h", "funcName": "ctx_adjust_troom", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __sk_buff *ctx", " const __s32 len_diff"], "output": "static__always_inline__maybe_unusedint", "helper": ["skb_change_tail"], "compatibleHookpoints": ["lwt_xmit", "sched_cls", "sk_skb", "sched_act"], "source": ["static __always_inline __maybe_unused int ctx_adjust_troom (struct  __sk_buff *ctx, const __s32 len_diff)\n", "{\n", "    return skb_change_tail (ctx, ctx->len + len_diff, 0);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [{"capability": "update_pkt", "update_pkt": [{"Project": "cilium", "Return Type": "int", "Description": "Adjust (move) xdp_md->data_end by <[ delta ]>(IP: 1) bytes. It is only possible to shrink the packet as of this writing , therefore <[ delta ]>(IP: 1) must be a negative integer. A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "xdp_adjust_tail", "Input Params": ["{Type: struct xdp_buff ,Var: *xdp_md}", "{Type:  int ,Var: delta}"], "compatible_hookpoints": ["xdp"], "capabilities": ["update_pkt"]}]}], "helperCallParams": {}, "startLine": 236, "endLine": 240, "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/xdp.h", "funcName": "ctx_adjust_troom", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct xdp_md *ctx", " const __s32 len_diff"], "output": "static__always_inline__maybe_unusedint", "helper": ["xdp_adjust_tail"], "compatibleHookpoints": ["xdp"], "source": ["static __always_inline __maybe_unused int ctx_adjust_troom (struct xdp_md *ctx, const __s32 len_diff)\n", "{\n", "    return xdp_adjust_tail (ctx, len_diff);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ctx_full_len": [{"capabilities": [], "helperCallParams": {}, "startLine": 78, "endLine": 82, "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/skb.h", "funcName": "ctx_full_len", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct  __sk_buff *ctx"], "output": "static__always_inline__maybe_unused__u64", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused __u64 ctx_full_len (const struct  __sk_buff *ctx)\n", "{\n", "    return ctx->len;\n", "}\n"], "called_function_list": ["ctx_data_end", "ctx_data"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 309, "endLine": 314, "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/xdp.h", "funcName": "ctx_full_len", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct xdp_md *ctx"], "output": "static__always_inline__maybe_unused__u64", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused __u64 ctx_full_len (const struct xdp_md *ctx)\n", "{\n", "    return ctx_data_end (ctx) - ctx_data (ctx);\n", "}\n"], "called_function_list": ["ctx_data_end", "ctx_data"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ctx_wire_len": [{"capabilities": [], "helperCallParams": {}, "startLine": 84, "endLine": 88, "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/skb.h", "funcName": "ctx_wire_len", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct  __sk_buff *ctx"], "output": "static__always_inline__maybe_unused__u32", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused __u32 ctx_wire_len (const struct  __sk_buff *ctx)\n", "{\n", "    return ctx->wire_len;\n", "}\n"], "called_function_list": ["ctx_full_len"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 316, "endLine": 320, "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/xdp.h", "funcName": "ctx_wire_len", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct xdp_md *ctx"], "output": "static__always_inline__maybe_unused__u32", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused __u32 ctx_wire_len (const struct xdp_md *ctx)\n", "{\n", "    return ctx_full_len (ctx);\n", "}\n"], "called_function_list": ["ctx_full_len"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ctx_store_meta": [{"capabilities": [], "helperCallParams": {}, "startLine": 90, "endLine": 94, "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/skb.h", "funcName": "ctx_store_meta", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct  __sk_buff *ctx", " const __u32 off", " __u32 data"], "output": "static__always_inline__maybe_unusedvoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused void ctx_store_meta (struct  __sk_buff *ctx, const __u32 off, __u32 data)\n", "{\n", "    ctx->cb[off] = data;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 330, "endLine": 338, "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/xdp.h", "funcName": "ctx_store_meta", "developer_inline_comments": [], "updateMaps": [], "readMaps": [" cilium_xdp_scratch"], "input": ["struct xdp_md * ctx __maybe_unused", " const __u64 off", " __u32 datum"], "output": "static__always_inline__maybe_unusedvoid", "helper": ["map_lookup_elem"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused void ctx_store_meta (struct xdp_md * ctx __maybe_unused, const __u64 off, __u32 datum)\n", "{\n", "    __u32 zero = 0, *data_meta = map_lookup_elem (&cilium_xdp_scratch, &zero);\n", "    if (always_succeeds (data_meta))\n", "        data_meta[off] = datum;\n", "    build_bug_on ((off + 1) * sizeof (__u32) > META_PIVOT);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ctx_load_meta": [{"capabilities": [], "helperCallParams": {}, "startLine": 96, "endLine": 100, "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/skb.h", "funcName": "ctx_load_meta", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct  __sk_buff *ctx", " const __u32 off"], "output": "static__always_inline__maybe_unused__u32", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused __u32 ctx_load_meta (const struct  __sk_buff *ctx, const __u32 off)\n", "{\n", "    return ctx->cb[off];\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}], "helperCallParams": {}, "startLine": 340, "endLine": 349, "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/xdp.h", "funcName": "ctx_load_meta", "developer_inline_comments": [], "updateMaps": [], "readMaps": [" cilium_xdp_scratch"], "input": ["const struct xdp_md * ctx __maybe_unused", " const __u64 off"], "output": "static__always_inline__maybe_unused__u32", "helper": ["map_lookup_elem"], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused __u32 ctx_load_meta (const struct xdp_md * ctx __maybe_unused, const __u64 off)\n", "{\n", "    __u32 zero = 0, *data_meta = map_lookup_elem (&cilium_xdp_scratch, &zero);\n", "    if (always_succeeds (data_meta))\n", "        return data_meta[off];\n", "    build_bug_on ((off + 1) * sizeof (__u32) > META_PIVOT);\n", "    return 0;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ctx_get_protocol": [{"capabilities": [], "helperCallParams": {}, "startLine": 102, "endLine": 106, "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/skb.h", "funcName": "ctx_get_protocol", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct  __sk_buff *ctx"], "output": "static__always_inline__maybe_unused__u16", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused __u16 ctx_get_protocol (const struct  __sk_buff *ctx)\n", "{\n", "    return (__u16) ctx->protocol;\n", "}\n"], "called_function_list": ["ctx_data_end", "ctx_no_room", "ctx_data"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 351, "endLine": 361, "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/xdp.h", "funcName": "ctx_get_protocol", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct xdp_md *ctx"], "output": "static__always_inline__maybe_unused__u16", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused __u16 ctx_get_protocol (const struct xdp_md *ctx)\n", "{\n", "    void *data_end = ctx_data_end (ctx);\n", "    struct ethhdr *eth = ctx_data (ctx);\n", "    if (ctx_no_room (eth + 1, data_end))\n", "        return 0;\n", "    return eth->h_proto;\n", "}\n"], "called_function_list": ["ctx_data_end", "ctx_no_room", "ctx_data"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ctx_get_ifindex": [{"capabilities": [], "helperCallParams": {}, "startLine": 108, "endLine": 112, "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/skb.h", "funcName": "ctx_get_ifindex", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct  __sk_buff *ctx"], "output": "static__always_inline__maybe_unused__u32", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused __u32 ctx_get_ifindex (const struct  __sk_buff *ctx)\n", "{\n", "    return ctx->ifindex;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, {"capabilities": [], "helperCallParams": {}, "startLine": 363, "endLine": 367, "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/xdp.h", "funcName": "ctx_get_ifindex", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct xdp_md *ctx"], "output": "static__always_inline__maybe_unused__u32", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused __u32 ctx_get_ifindex (const struct xdp_md *ctx)\n", "{\n", "    return ctx->ingress_ifindex;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ctx_data": [{"capabilities": [], "helperCallParams": {}, "startLine": 16, "endLine": 19, "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/common.h", "funcName": "ctx_data", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct  __ctx_buff *ctx"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void *ctx_data (const struct  __ctx_buff *ctx)\n", "{\n", "    return (void *) (unsigned long) ctx->data;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ctx_data_meta": [{"capabilities": [], "helperCallParams": {}, "startLine": 21, "endLine": 24, "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/common.h", "funcName": "ctx_data_meta", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct  __ctx_buff *ctx"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void *ctx_data_meta (const struct  __ctx_buff *ctx)\n", "{\n", "    return (void *) (unsigned long) ctx->data_meta;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ctx_data_end": [{"capabilities": [], "helperCallParams": {}, "startLine": 26, "endLine": 29, "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/common.h", "funcName": "ctx_data_end", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct  __ctx_buff *ctx"], "output": "static__always_inlinevoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline void *ctx_data_end (const struct  __ctx_buff *ctx)\n", "{\n", "    return (void *) (unsigned long) ctx->data_end;\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ctx_no_room": [{"capabilities": [], "helperCallParams": {}, "startLine": 31, "endLine": 34, "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/common.h", "funcName": "ctx_no_room", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const void *needed", " const void *limit"], "output": "static__always_inlinebool", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline bool ctx_no_room (const void *needed, const void *limit)\n", "{\n", "    return unlikely (needed > limit);\n", "}\n"], "called_function_list": [], "call_depth": 0, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "xdp_load_bytes": [{"capabilities": [], "helperCallParams": {}, "startLine": 34, "endLine": 60, "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/xdp.h", "funcName": "xdp_load_bytes", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct xdp_md *ctx", " __u64 off", " void *to", " const __u64 len"], "output": "static__always_inline__maybe_unusedint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused int xdp_load_bytes (const struct xdp_md *ctx, __u64 off, void *to, const __u64 len)\n", "{\n", "    void *from;\n", "    int ret;\n", "    asm volatile (\"r1 = *(u32 *)(%[ctx] +0)\\n\\t\"\n", "        \"r2 = *(u32 *)(%[ctx] +4)\\n\\t\"\n", "        \"%[off] &= %[offmax]\\n\\t\"\n", "        \"r1 += %[off]\\n\\t\"\n", "        \"%[from] = r1\\n\\t\"\n", "        \"r1 += %[len]\\n\\t\"\n", "        \"if r1 > r2 goto +2\\n\\t\"\n", "        \"%[ret] = 0\\n\\t\"\n", "        \"goto +1\\n\\t\"\n", "        \"%[ret] = %[errno]\\n\\t\"\n", "        : [ret] \"=r\"\n", "        (ret), [from] \"=r\"\n", "        (from) : [ctx] \"r\"\n", "        (ctx), [off] \"r\"\n", "        (off), [len] \"ri\"\n", "        (len), [offmax] \"i\"\n", "        (__CTX_OFF_MAX), [errno] \"i\"\n", "        (- EINVAL) : \"r1\",\n", "        \"r2\"\n", "        );\n", "    if (!ret)\n", "        memcpy (to, from, len);\n", "    return ret;\n", "}\n"], "called_function_list": ["memcpy"], "call_depth": 3, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "xdp_store_bytes": [{"capabilities": [], "helperCallParams": {}, "startLine": 62, "endLine": 86, "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/xdp.h", "funcName": "xdp_store_bytes", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct xdp_md *ctx", " __u64 off", " const void *from", " const __u64 len", " __u64 flags __maybe_unused"], "output": "static__always_inline__maybe_unusedint", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused int xdp_store_bytes (const struct xdp_md *ctx, __u64 off, const void *from, const __u64 len, __u64 flags __maybe_unused)\n", "{\n", "    void *to;\n", "    int ret;\n", "    asm volatile (\"r1 = *(u32 *)(%[ctx] +0)\\n\\t\"\n", "        \"r2 = *(u32 *)(%[ctx] +4)\\n\\t\"\n", "        \"%[off] &= %[offmax]\\n\\t\"\n", "        \"r1 += %[off]\\n\\t\"\n", "        \"%[to] = r1\\n\\t\"\n", "        \"r1 += %[len]\\n\\t\"\n", "        \"if r1 > r2 goto +2\\n\\t\"\n", "        \"%[ret] = 0\\n\\t\"\n", "        \"goto +1\\n\\t\"\n", "        \"%[ret] = %[errno]\\n\\t\"\n", "        : [ret] \"=r\"\n", "        (ret), [to] \"=r\"\n", "        (to) : [ctx] \"r\"\n", "        (ctx), [off] \"r\"\n", "        (off), [len] \"ri\"\n", "        (len), [offmax] \"i\"\n", "        (__CTX_OFF_MAX), [errno] \"i\"\n", "        (- EINVAL) : \"r1\",\n", "        \"r2\"\n", "        );\n", "    if (!ret)\n", "        memcpy (to, from, len);\n", "    return ret;\n", "}\n"], "called_function_list": ["memcpy"], "call_depth": 3, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__csum_replace_by_diff": [{"capabilities": [], "helperCallParams": {}, "startLine": 110, "endLine": 114, "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/xdp.h", "funcName": "__csum_replace_by_diff", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["__sum16 *sum", " __wsum diff"], "output": "static__always_inline__maybe_unusedvoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused void __csum_replace_by_diff (__sum16 *sum, __wsum diff)\n", "{\n", "    *sum = csum_fold (csum_add (diff, ~csum_unfold (*sum)));\n", "}\n"], "called_function_list": ["csum_unfold", "csum_add", "csum_fold"], "call_depth": 1, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "__csum_replace_by_4": [{"capabilities": [], "helperCallParams": {}, "startLine": 116, "endLine": 120, "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/xdp.h", "funcName": "__csum_replace_by_4", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["__sum16 *sum", " __wsum from", " __wsum to"], "output": "static__always_inline__maybe_unusedvoid", "helper": [], "compatibleHookpoints": ["sched_cls", "cgroup_sock_addr", "cgroup_sysctl", "sk_msg", "xdp", "lwt_in", "flow_dissector", "sched_act", "tracepoint", "kprobe", "lwt_xmit", "sock_ops", "raw_tracepoint", "sk_reuseport", "raw_tracepoint_writable", "sk_skb", "lwt_out", "socket_filter", "cgroup_skb", "cgroup_device", "perf_event", "cgroup_sock", "lwt_seg6local"], "source": ["static __always_inline __maybe_unused void __csum_replace_by_4 (__sum16 *sum, __wsum from, __wsum to)\n", "{\n", "    __csum_replace_by_diff (sum, csum_add (~from, to));\n", "}\n"], "called_function_list": ["__csum_replace_by_diff", "csum_add"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "l3_csum_replace": [{"capabilities": [], "helperCallParams": {}, "startLine": 122, "endLine": 154, "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/xdp.h", "funcName": "l3_csum_replace", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct xdp_md *ctx", " __u64 off", " const __u32 from", " __u32 to", " __u32 flags"], "output": "static__always_inline__maybe_unusedint", "helper": ["l3_csum_replace"], "compatibleHookpoints": ["lwt_xmit", "sched_cls", "sched_act"], "source": ["static __always_inline __maybe_unused int l3_csum_replace (const struct xdp_md *ctx, __u64 off, const __u32 from, __u32 to, __u32 flags)\n", "{\n", "    __u32 size = flags & BPF_F_HDR_FIELD_MASK;\n", "    __sum16 *sum;\n", "    int ret;\n", "    if (unlikely (flags & ~(BPF_F_HDR_FIELD_MASK)))\n", "        return -EINVAL;\n", "    if (unlikely (size != 0 && size != 2))\n", "        return -EINVAL;\n", "    asm volatile (\"r1 = *(u32 *)(%[ctx] +0)\\n\\t\"\n", "        \"r2 = *(u32 *)(%[ctx] +4)\\n\\t\"\n", "        \"%[off] &= %[offmax]\\n\\t\"\n", "        \"r1 += %[off]\\n\\t\"\n", "        \"%[sum] = r1\\n\\t\"\n", "        \"r1 += 2\\n\\t\"\n", "        \"if r1 > r2 goto +2\\n\\t\"\n", "        \"%[ret] = 0\\n\\t\"\n", "        \"goto +1\\n\\t\"\n", "        \"%[ret] = %[errno]\\n\\t\"\n", "        : [ret] \"=r\"\n", "        (ret), [sum] \"=r\"\n", "        (sum) : [ctx] \"r\"\n", "        (ctx), [off] \"r\"\n", "        (off), [offmax] \"i\"\n", "        (__CTX_OFF_MAX), [errno] \"i\"\n", "        (- EINVAL) : \"r1\",\n", "        \"r2\"\n", "        );\n", "    if (!ret)\n", "        from ? __csum_replace_by_4 (sum, from, to) : __csum_replace_by_diff (sum, to);\n", "    return ret;\n", "}\n"], "called_function_list": ["__csum_replace_by_diff", "__csum_replace_by_4"], "call_depth": 3, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "l4_csum_replace": [{"capabilities": [], "helperCallParams": {}, "startLine": 158, "endLine": 196, "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/xdp.h", "funcName": "l4_csum_replace", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["const struct xdp_md *ctx", " __u64 off", " __u32 from", " __u32 to", " __u32 flags"], "output": "static__always_inline__maybe_unusedint", "helper": ["l4_csum_replace"], "compatibleHookpoints": ["lwt_xmit", "sched_cls", "sched_act"], "source": ["static __always_inline __maybe_unused int l4_csum_replace (const struct xdp_md *ctx, __u64 off, __u32 from, __u32 to, __u32 flags)\n", "{\n", "    bool is_mmzero = flags & BPF_F_MARK_MANGLED_0;\n", "    __u32 size = flags & BPF_F_HDR_FIELD_MASK;\n", "    __sum16 *sum;\n", "    int ret;\n", "    if (unlikely (flags & ~(BPF_F_MARK_MANGLED_0 | BPF_F_PSEUDO_HDR | BPF_F_HDR_FIELD_MASK)))\n", "        return -EINVAL;\n", "    if (unlikely (size != 0 && size != 2))\n", "        return -EINVAL;\n", "    asm volatile (\"r1 = *(u32 *)(%[ctx] +0)\\n\\t\"\n", "        \"r2 = *(u32 *)(%[ctx] +4)\\n\\t\"\n", "        \"%[off] &= %[offmax]\\n\\t\"\n", "        \"r1 += %[off]\\n\\t\"\n", "        \"%[sum] = r1\\n\\t\"\n", "        \"r1 += 2\\n\\t\"\n", "        \"if r1 > r2 goto +2\\n\\t\"\n", "        \"%[ret] = 0\\n\\t\"\n", "        \"goto +1\\n\\t\"\n", "        \"%[ret] = %[errno]\\n\\t\"\n", "        : [ret] \"=r\"\n", "        (ret), [sum] \"=r\"\n", "        (sum) : [ctx] \"r\"\n", "        (ctx), [off] \"r\"\n", "        (off), [offmax] \"i\"\n", "        (__CTX_OFF_MAX), [errno] \"i\"\n", "        (- EINVAL) : \"r1\",\n", "        \"r2\"\n", "        );\n", "    if (!ret) {\n", "        if (is_mmzero && !*sum)\n", "            return 0;\n", "        from ? __csum_replace_by_4 (sum, from, to) : __csum_replace_by_diff (sum, to);\n", "        if (is_mmzero && !*sum)\n", "            *sum = CSUM_MANGLED_0;\n", "    }\n", "    return ret;\n", "}\n"], "called_function_list": ["__csum_replace_by_diff", "__csum_replace_by_4"], "call_depth": 3, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ctx_change_proto": [{"capabilities": [{"capability": "update_pkt", "update_pkt": [{"Project": "cilium", "Return Type": "int", "Description": "Adjust (move) xdp_md->data by <[ delta ]>(IP: 1) bytes. Note that it is possible to use a negative value for delta. This helper can be used to prepare the packet for pushing or popping headers. A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "xdp_adjust_head", "Input Params": ["{Type: struct xdp_buff ,Var: *xdp_md}", "{Type:  int ,Var: delta}"], "compatible_hookpoints": ["xdp"], "capabilities": ["update_pkt"]}]}], "helperCallParams": {}, "startLine": 198, "endLine": 234, "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/xdp.h", "funcName": "ctx_change_proto", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct xdp_md * ctx __maybe_unused", " const __be16 proto __maybe_unused", " const __u64 flags __maybe_unused"], "output": "static__always_inline__maybe_unusedint", "helper": ["xdp_adjust_head"], "compatibleHookpoints": ["xdp"], "source": ["static __always_inline __maybe_unused int ctx_change_proto (struct xdp_md * ctx __maybe_unused, const __be16 proto __maybe_unused, const __u64 flags __maybe_unused)\n", "{\n", "    const __s32 len_diff = proto == __constant_htons (ETH_P_IPV6) ? 20 : -20;\n", "    const __u32 move_len = 14;\n", "    void *data, *data_end;\n", "    int ret;\n", "    build_bug_on (flags != 0);\n", "    build_bug_on (proto != __constant_htons (ETH_P_IPV6) && proto != __constant_htons (ETH_P_IP));\n", "    if (len_diff < 0) {\n", "        data_end = ctx_data_end (ctx);\n", "        data = ctx_data (ctx);\n", "        if (data + move_len + -len_diff <= data_end)\n", "            __bpf_memmove_fwd (data + -len_diff, data, move_len);\n", "        else\n", "            return -EFAULT;\n", "    }\n", "    ret = xdp_adjust_head (ctx, - len_diff);\n", "    if (!ret && len_diff > 0) {\n", "        data_end = ctx_data_end (ctx);\n", "        data = ctx_data (ctx);\n", "        if (data + move_len + len_diff <= data_end)\n", "            __bpf_memmove_fwd (data, data + len_diff, move_len);\n", "        else\n", "            return -EFAULT;\n", "    }\n", "    return ret;\n", "}\n"], "called_function_list": ["ctx_data_end", "__bpf_memmove_fwd", "ctx_data"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ctx_adjust_hroom": [{"capabilities": [{"capability": "update_pkt", "update_pkt": [{"Project": "cilium", "Return Type": "int", "Description": "Adjust (move) xdp_md->data by <[ delta ]>(IP: 1) bytes. Note that it is possible to use a negative value for delta. This helper can be used to prepare the packet for pushing or popping headers. A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "xdp_adjust_head", "Input Params": ["{Type: struct xdp_buff ,Var: *xdp_md}", "{Type:  int ,Var: delta}"], "compatible_hookpoints": ["xdp"], "capabilities": ["update_pkt"]}]}], "helperCallParams": {}, "startLine": 242, "endLine": 289, "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/xdp.h", "funcName": "ctx_adjust_hroom", "developer_inline_comments": [], "updateMaps": [], "readMaps": [], "input": ["struct xdp_md *ctx", " const __s32 len_diff", " const __u32 mode", " const __u64 flags __maybe_unused"], "output": "static__always_inline__maybe_unusedint", "helper": ["xdp_adjust_head"], "compatibleHookpoints": ["xdp"], "source": ["static __always_inline __maybe_unused int ctx_adjust_hroom (struct xdp_md *ctx, const __s32 len_diff, const __u32 mode, const __u64 flags __maybe_unused)\n", "{\n", "    const __u32 move_len_v4 = 14 + 20;\n", "    const __u32 move_len_v6 = 14 + 40;\n", "    void *data, *data_end;\n", "    int ret;\n", "    build_bug_on (len_diff <= 0 || len_diff >= 64);\n", "    build_bug_on (mode != BPF_ADJ_ROOM_NET);\n", "    ret = xdp_adjust_head (ctx, - len_diff);\n", "    if (!ret) {\n", "        data_end = ctx_data_end (ctx);\n", "        data = ctx_data (ctx);\n", "        switch (len_diff) {\n", "        case 28 :\n", "            break;\n", "        case 20 :\n", "        case 8 :\n", "            if (data + move_len_v4 + len_diff <= data_end)\n", "                __bpf_memmove_fwd (data, data + len_diff, move_len_v4);\n", "            else\n", "                ret = -EFAULT;\n", "            break;\n", "        case 48 :\n", "            break;\n", "        case 40 :\n", "        case 24 :\n", "            if (data + move_len_v6 + len_diff <= data_end)\n", "                __bpf_memmove_fwd (data, data + len_diff, move_len_v6);\n", "            else\n", "                ret = -EFAULT;\n", "            break;\n", "        default :\n", "            __throw_build_bug ();\n", "        }\n", "    }\n", "    return ret;\n", "}\n"], "called_function_list": ["ctx_data_end", "__bpf_memmove_fwd", "ctx_data"], "call_depth": 2, "humanFuncDescription": [null], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}]}