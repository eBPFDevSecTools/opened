{
  "main": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 44,
      "endLine": 99,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_alignchecker.c",
      "funcName": "main",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": "// SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)"
        },
        {
          "start_line": 2,
          "end_line": 2,
          "text": "/* Copyright Authors of Cilium */"
        },
        {
          "start_line": 4,
          "end_line": 4,
          "text": "/* Ensure declaration of notification event types */"
        },
        {
          "start_line": 29,
          "end_line": 34,
          "text": "/* DECLARE declares a unique usage of the union or struct 'x' on the stack.\n *\n * To prevent compiler from optimizing away the var, we pass a reference\n * to the var to a BPF helper function which accepts a reference as\n * an argument.\n */"
        },
        {
          "start_line": 41,
          "end_line": 43,
          "text": "/* This function is a placeholder for C struct definitions shared with Go,\n * it is never executed.\n */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void"
      ],
      "output": "int",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "int main (void)\n",
        "{\n",
        "    DECLARE (struct ipv4_ct_tuple);\n",
        "    DECLARE (struct ipv6_ct_tuple);\n",
        "    DECLARE (struct ct_entry);\n",
        "    DECLARE (struct ipcache_key);\n",
        "    DECLARE (struct remote_endpoint_info);\n",
        "    DECLARE (struct lb4_key);\n",
        "    DECLARE (struct lb4_service);\n",
        "    DECLARE (struct lb4_backend);\n",
        "    DECLARE (struct lb6_key);\n",
        "    DECLARE (struct lb6_service);\n",
        "    DECLARE (struct lb6_backend);\n",
        "    DECLARE (struct endpoint_key);\n",
        "    DECLARE (struct endpoint_info);\n",
        "    DECLARE (struct metrics_key);\n",
        "    DECLARE (struct metrics_value);\n",
        "    DECLARE (struct sock_key);\n",
        "    DECLARE (struct policy_key);\n",
        "    DECLARE (struct policy_entry);\n",
        "    DECLARE (struct ipv4_nat_entry);\n",
        "    DECLARE (struct ipv6_nat_entry);\n",
        "    DECLARE (struct trace_notify);\n",
        "    DECLARE (struct drop_notify);\n",
        "    DECLARE (struct policy_verdict_notify);\n",
        "    DECLARE (struct debug_msg);\n",
        "    DECLARE (struct debug_capture_msg);\n",
        "    DECLARE (struct ipv4_revnat_tuple);\n",
        "    DECLARE (struct ipv4_revnat_entry);\n",
        "    DECLARE (struct ipv6_revnat_tuple);\n",
        "    DECLARE (struct ipv6_revnat_entry);\n",
        "    DECLARE (struct ipv4_frag_id);\n",
        "    DECLARE (struct ipv4_frag_l4ports);\n",
        "    DECLARE (union macaddr);\n",
        "    DECLARE (struct lb4_affinity_key);\n",
        "    DECLARE (struct lb6_affinity_key);\n",
        "    DECLARE (struct lb_affinity_val);\n",
        "    DECLARE (struct lb_affinity_match);\n",
        "    DECLARE (struct lb4_src_range_key);\n",
        "    DECLARE (struct lb6_src_range_key);\n",
        "    DECLARE (struct edt_id);\n",
        "    DECLARE (struct edt_info);\n",
        "    DECLARE (struct egress_gw_policy_key);\n",
        "    DECLARE (struct egress_gw_policy_entry);\n",
        "    DECLARE (struct vtep_key);\n",
        "    DECLARE (struct vtep_value);\n",
        "    DECLARE (struct capture4_wcard);\n",
        "    DECLARE (struct capture6_wcard);\n",
        "    DECLARE (struct capture_rule);\n",
        "    DECLARE (struct srv6_vrf_key4);\n",
        "    DECLARE (struct srv6_vrf_key6);\n",
        "    DECLARE (struct srv6_policy_key4);\n",
        "    DECLARE (struct srv6_policy_key6);\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "fetch_kern_jiffies",
        "prep_kern_jiffies",
        "fix_priority",
        "dump_kern_jiffies",
        "pin_to_cpu"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": " Print and debug all the existing variables (especially fast path  sections that printk is not appropriate for) ",
          "author": "Shun Zhang",
          "authorEmail": "shunz@bu.edu",
          "date": "2023-02-24"
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 152,
      "endLine": 194,
      "File": "/home/sayandes/opened_extraction/examples/cilium/cilium-probe-kernel-hz.c",
      "funcName": "main",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "int argc",
        " char **argv"
      ],
      "output": "int",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "int main (int argc, char **argv)\n",
        "{\n",
        "    struct cpu_jiffies before, after;\n",
        "    struct timespec tv = {\n",
        "        .tv_sec = 1,\n",
        "        .tv_nsec = 0,}\n",
        "    ;\n",
        "    int opt, sig, ret, tries = 4;\n",
        "    bool macro = false;\n",
        "    while ((opt = getopt (argc, argv, \"m\")) != -1) {\n",
        "        switch (opt) {\n",
        "        case 'm' :\n",
        "            macro = true;\n",
        "            break;\n",
        "        default :\n",
        "            return -1;\n",
        "        }\n",
        "    }\n",
        "    if (pin_to_cpu (0)) {\n",
        "        fprintf (stderr, \"Cannot pin to CPU 0: %s\\n\", strerror (errno));\n",
        "        return -1;\n",
        "    }\n",
        "    if (fix_priority ()) {\n",
        "        fprintf (stderr, \"Cannot set priority: %s\\n\", strerror (errno));\n",
        "        return -1;\n",
        "    }\n",
        "    if (prep_kern_jiffies (&before, &after)) {\n",
        "        fprintf (stderr, \"Cannot prep jiffies: %s\\n\", strerror (errno));\n",
        "        return -1;\n",
        "    }\n",
        "    do {\n",
        "        ret = fetch_kern_jiffies (& before);\n",
        "        sig = nanosleep (& tv, NULL);\n",
        "        ret += fetch_kern_jiffies (&after);\n",
        "    }\n",
        "    while (!ret && sig && errno == EINTR && --tries >= 0);\n",
        "    if (!ret && !sig)\n",
        "        ret = dump_kern_jiffies (&before, &after, macro);\n",
        "    return ret;\n",
        "}\n"
      ],
      "called_function_list": [
        "fetch_kern_jiffies",
        "prep_kern_jiffies",
        "fix_priority",
        "dump_kern_jiffies",
        "pin_to_cpu"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": " Main function of above functions, initialize the cpu and deal with the  jiffies  accordingly  ",
          "author": "Shun Zhang",
          "authorEmail": "shunz@bu.edu",
          "date": "2023-02-24"
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "bpf_xdp_exit": [
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 96,
      "endLine": 117,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_xdp.c",
      "funcName": "bpf_xdp_exit",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": "// SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)"
        },
        {
          "start_line": 2,
          "end_line": 2,
          "text": "/* Copyright Authors of Cilium */"
        },
        {
          "start_line": 13,
          "end_line": 15,
          "text": "/* Controls the inclusion of the CILIUM_CALL_HANDLE_ICMP6_NS section in the\n * bpf_lxc object file.\n */"
        },
        {
          "start_line": 18,
          "end_line": 21,
          "text": "/* Controls the inclusion of the CILIUM_CALL_SEND_ICMP6_TIME_EXCEEDED section\n * in the bpf_lxc object file. This is needed for all callers of\n * ipv6_local_delivery, which calls into the IPv6 L3 handling.\n */"
        },
        {
          "start_line": 24,
          "end_line": 26,
          "text": "/* Controls the inclusion of the CILIUM_CALL_SEND_ICMP6_ECHO_REPLY section in\n * the bpf_lxc object file.\n */"
        },
        {
          "start_line": 29,
          "end_line": 30,
          "text": "/* Controls the inclusion of the CILIUM_CALL_SRV6 section in the object file.\n */"
        },
        {
          "start_line": 33,
          "end_line": 35,
          "text": "/* The XDP datapath does not take care of health probes from the local node,\n * thus do not compile it in.\n */"
        },
        {
          "start_line": 70,
          "end_line": 70,
          "text": "/* CIDR4_LPM_PREFILTER */"
        },
        {
          "start_line": 71,
          "end_line": 71,
          "text": "/* CIDR4_FILTER */"
        },
        {
          "start_line": 92,
          "end_line": 92,
          "text": "/* CIDR6_LPM_PREFILTER */"
        },
        {
          "start_line": 93,
          "end_line": 93,
          "text": "/* CIDR6_FILTER */"
        },
        {
          "start_line": 94,
          "end_line": 94,
          "text": "/* ENABLE_PREFILTER */"
        },
        {
          "start_line": 102,
          "end_line": 104,
          "text": "/* We transfer data from XFER_MARKER. This specifically\n\t\t * does not break packet trains in GRO.\n\t\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " const int verdict"
      ],
      "output": "static__always_inline__maybe_unusedint",
      "helper": [
        "CTX_ACT_OK"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "static __always_inline __maybe_unused int bpf_xdp_exit (struct  __ctx_buff *ctx, const int verdict)\n",
        "{\n",
        "    if (verdict == CTX_ACT_OK) {\n",
        "        __u32 meta_xfer = ctx_load_meta (ctx, XFER_MARKER);\n",
        "        if (meta_xfer) {\n",
        "            if (!ctx_adjust_meta (ctx, -(int) sizeof (meta_xfer))) {\n",
        "                __u32 *data_meta = ctx_data_meta (ctx);\n",
        "                __u32 *data = ctx_data (ctx);\n",
        "                if (!ctx_no_room (data_meta + 1, data))\n",
        "                    data_meta[0] = meta_xfer;\n",
        "            }\n",
        "        }\n",
        "    }\n",
        "    return verdict;\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_data_meta",
        "ctx_no_room",
        "ctx_data",
        "ctx_load_meta"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "tail_lb_ipv4": [
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 122,
      "endLine": 140,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_xdp.c",
      "funcName": "tail_lb_ipv4",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "int",
      "helper": [
        "CTX_ACT_OK"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "int tail_lb_ipv4 (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    int ret = CTX_ACT_OK;\n",
        "    if (!bpf_skip_nodeport (ctx)) {\n",
        "        ret = nodeport_lb4 (ctx, 0);\n",
        "        if (ret == NAT_46X64_RECIRC) {\n",
        "            ep_tail_call (ctx, CILIUM_CALL_IPV6_FROM_NETDEV);\n",
        "            return send_drop_notify_error (ctx, 0, DROP_MISSED_TAIL_CALL, CTX_ACT_DROP, METRIC_INGRESS);\n",
        "        }\n",
        "        else if (IS_ERR (ret)) {\n",
        "            return send_drop_notify_error (ctx, 0, ret, CTX_ACT_DROP, METRIC_INGRESS);\n",
        "        }\n",
        "    }\n",
        "    return bpf_xdp_exit (ctx, ret);\n",
        "}\n"
      ],
      "called_function_list": [
        "nodeport_lb4",
        "bpf_skip_nodeport",
        "ep_tail_call",
        "bpf_xdp_exit"
      ],
      "call_depth": 6,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "check_v4_lb": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 142,
      "endLine": 147,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_xdp.c",
      "funcName": "check_v4_lb",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int check_v4_lb (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    ep_tail_call (ctx, CILIUM_CALL_IPV4_FROM_NETDEV);\n",
        "    return send_drop_notify_error (ctx, 0, DROP_MISSED_TAIL_CALL, CTX_ACT_DROP, METRIC_INGRESS);\n",
        "}\n"
      ],
      "called_function_list": [
        "ep_tail_call"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 149,
      "endLine": 152,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_xdp.c",
      "funcName": "check_v4_lb",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff * ctx __maybe_unused"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "CTX_ACT_OK"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "static __always_inline int check_v4_lb (struct  __ctx_buff * ctx __maybe_unused)\n",
        "{\n",
        "    return CTX_ACT_OK;\n",
        "}\n"
      ],
      "called_function_list": [
        "ep_tail_call"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "check_v4": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 156,
      "endLine": 179,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_xdp.c",
      "funcName": "check_v4",
      "developer_inline_comments": [
        {
          "start_line": 173,
          "end_line": 173,
          "text": "/* CIDR4_LPM_PREFILTER */"
        },
        {
          "start_line": 178,
          "end_line": 178,
          "text": "/* CIDR4_FILTER */"
        }
      ],
      "updateMaps": [],
      "readMaps": [
        " CIDR4_HMAP_NAME",
        " CIDR4_LMAP_NAME"
      ],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int check_v4 (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    void *data_end = ctx_data_end (ctx);\n",
        "    void *data = ctx_data (ctx);\n",
        "    struct iphdr *ipv4_hdr = data + sizeof (struct ethhdr);\n",
        "    struct lpm_v4_key pfx __maybe_unused;\n",
        "    if (ctx_no_room (ipv4_hdr + 1, data_end))\n",
        "        return CTX_ACT_DROP;\n",
        "\n",
        "#ifdef CIDR4_FILTER\n",
        "    memcpy (pfx.lpm.data, &ipv4_hdr->saddr, sizeof (pfx.addr));\n",
        "    pfx.lpm.prefixlen = 32;\n",
        "\n",
        "#ifdef CIDR4_LPM_PREFILTER\n",
        "    if (map_lookup_elem (&CIDR4_LMAP_NAME, &pfx))\n",
        "        return CTX_ACT_DROP;\n",
        "\n",
        "#endif /* CIDR4_LPM_PREFILTER */\n",
        "    return map_lookup_elem (&CIDR4_HMAP_NAME, &pfx) ? CTX_ACT_DROP : check_v4_lb (ctx);\n",
        "\n",
        "#else\n",
        "    return check_v4_lb (ctx);\n",
        "\n",
        "#endif /* CIDR4_FILTER */\n",
        "}\n"
      ],
      "called_function_list": [
        "check_v4_lb",
        "memcpy",
        "ctx_no_room",
        "ctx_data_end",
        "ctx_data"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 181,
      "endLine": 184,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_xdp.c",
      "funcName": "check_v4",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int check_v4 (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    return check_v4_lb (ctx);\n",
        "}\n"
      ],
      "called_function_list": [
        "check_v4_lb",
        "memcpy",
        "ctx_no_room",
        "ctx_data_end",
        "ctx_data"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "tail_lb_ipv6": [
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 191,
      "endLine": 203,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_xdp.c",
      "funcName": "tail_lb_ipv6",
      "developer_inline_comments": [
        {
          "start_line": 186,
          "end_line": 186,
          "text": "/* ENABLE_IPV4 */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "int",
      "helper": [
        "CTX_ACT_OK"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "int tail_lb_ipv6 (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    int ret = CTX_ACT_OK;\n",
        "    if (!bpf_skip_nodeport (ctx)) {\n",
        "        ret = nodeport_lb6 (ctx, 0);\n",
        "        if (IS_ERR (ret))\n",
        "            return send_drop_notify_error (ctx, 0, ret, CTX_ACT_DROP, METRIC_INGRESS);\n",
        "    }\n",
        "    return bpf_xdp_exit (ctx, ret);\n",
        "}\n"
      ],
      "called_function_list": [
        "nodeport_lb6",
        "bpf_skip_nodeport",
        "bpf_xdp_exit"
      ],
      "call_depth": 4,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "check_v6_lb": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 205,
      "endLine": 210,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_xdp.c",
      "funcName": "check_v6_lb",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int check_v6_lb (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    ep_tail_call (ctx, CILIUM_CALL_IPV6_FROM_NETDEV);\n",
        "    return send_drop_notify_error (ctx, 0, DROP_MISSED_TAIL_CALL, CTX_ACT_DROP, METRIC_INGRESS);\n",
        "}\n"
      ],
      "called_function_list": [
        "ep_tail_call"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 212,
      "endLine": 215,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_xdp.c",
      "funcName": "check_v6_lb",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff * ctx __maybe_unused"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "CTX_ACT_OK"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "static __always_inline int check_v6_lb (struct  __ctx_buff * ctx __maybe_unused)\n",
        "{\n",
        "    return CTX_ACT_OK;\n",
        "}\n"
      ],
      "called_function_list": [
        "ep_tail_call"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "check_v6": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 219,
      "endLine": 242,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_xdp.c",
      "funcName": "check_v6",
      "developer_inline_comments": [
        {
          "start_line": 236,
          "end_line": 236,
          "text": "/* CIDR6_LPM_PREFILTER */"
        },
        {
          "start_line": 241,
          "end_line": 241,
          "text": "/* CIDR6_FILTER */"
        }
      ],
      "updateMaps": [],
      "readMaps": [
        " CIDR6_HMAP_NAME",
        " CIDR6_LMAP_NAME"
      ],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int check_v6 (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    void *data_end = ctx_data_end (ctx);\n",
        "    void *data = ctx_data (ctx);\n",
        "    struct ipv6hdr *ipv6_hdr = data + sizeof (struct ethhdr);\n",
        "    struct lpm_v6_key pfx __maybe_unused;\n",
        "    if (ctx_no_room (ipv6_hdr + 1, data_end))\n",
        "        return CTX_ACT_DROP;\n",
        "\n",
        "#ifdef CIDR6_FILTER\n",
        "    __bpf_memcpy_builtin (pfx.lpm.data, &ipv6_hdr->saddr, sizeof (pfx.addr));\n",
        "    pfx.lpm.prefixlen = 128;\n",
        "\n",
        "#ifdef CIDR6_LPM_PREFILTER\n",
        "    if (map_lookup_elem (&CIDR6_LMAP_NAME, &pfx))\n",
        "        return CTX_ACT_DROP;\n",
        "\n",
        "#endif /* CIDR6_LPM_PREFILTER */\n",
        "    return map_lookup_elem (&CIDR6_HMAP_NAME, &pfx) ? CTX_ACT_DROP : check_v6_lb (ctx);\n",
        "\n",
        "#else\n",
        "    return check_v6_lb (ctx);\n",
        "\n",
        "#endif /* CIDR6_FILTER */\n",
        "}\n"
      ],
      "called_function_list": [
        "check_v6_lb",
        "ctx_no_room",
        "ctx_data_end",
        "ctx_data",
        "__bpf_memcpy_builtin"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 244,
      "endLine": 247,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_xdp.c",
      "funcName": "check_v6",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int check_v6 (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    return check_v6_lb (ctx);\n",
        "}\n"
      ],
      "called_function_list": [
        "check_v6_lb",
        "ctx_no_room",
        "ctx_data_end",
        "ctx_data",
        "__bpf_memcpy_builtin"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "check_filters": [
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 251,
      "endLine": 278,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_xdp.c",
      "funcName": "check_filters",
      "developer_inline_comments": [
        {
          "start_line": 249,
          "end_line": 249,
          "text": "/* ENABLE_IPV6 */"
        },
        {
          "start_line": 267,
          "end_line": 267,
          "text": "/* ENABLE_IPV4 */"
        },
        {
          "start_line": 272,
          "end_line": 272,
          "text": "/* ENABLE_IPV6 */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "CTX_ACT_OK"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "static __always_inline int check_filters (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    int ret = CTX_ACT_OK;\n",
        "    __u16 proto;\n",
        "    if (!validate_ethertype (ctx, &proto))\n",
        "        return CTX_ACT_OK;\n",
        "    ctx_store_meta (ctx, XFER_MARKER, 0);\n",
        "    bpf_skip_nodeport_clear (ctx);\n",
        "    switch (proto) {\n",
        "\n",
        "#ifdef ENABLE_IPV4\n",
        "    case bpf_htons (ETH_P_IP) :\n",
        "        ret = check_v4 (ctx);\n",
        "        break;\n",
        "\n",
        "#endif /* ENABLE_IPV4 */\n",
        "\n",
        "#ifdef ENABLE_IPV6\n",
        "    case bpf_htons (ETH_P_IPV6) :\n",
        "        ret = check_v6 (ctx);\n",
        "        break;\n",
        "\n",
        "#endif /* ENABLE_IPV6 */\n",
        "    default :\n",
        "        break;\n",
        "    }\n",
        "    return bpf_xdp_exit (ctx, ret);\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_store_meta",
        "bpf_skip_nodeport_clear",
        "check_v6",
        "check_v4",
        "validate_ethertype",
        "bpf_xdp_exit"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "bpf_xdp_entry": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 281,
      "endLine": 284,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_xdp.c",
      "funcName": "bpf_xdp_entry",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "int",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "int bpf_xdp_entry (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    return check_filters (ctx);\n",
        "}\n"
      ],
      "called_function_list": [
        "check_filters"
      ],
      "call_depth": 4,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "from_network": [
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        },
        {
          "capability": "pkt_alter_or_redo_processing_or_interface",
          "pkt_alter_or_redo_processing_or_interface": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "CTX_ACT_REDIRECT",
              "Return": 7,
              "Description": "Cilium wrapper. This allows to redirect the skb to the same or another\u2019s device ingress or egress path together with the redirect() helper. Being able to inject the packet into another device\u2019s ingress or egress direction allows for full flexibility in packet forwarding with BPF. There are no requirements on the target networking device other than being a networking device itself, there is no need to run another instance of cls_bpf on the target device or other such restrictions.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_alter_or_redo_processing_or_interface"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 15,
      "endLine": 88,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_network.c",
      "funcName": "from_network",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": "// SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)"
        },
        {
          "start_line": 2,
          "end_line": 2,
          "text": "/* Copyright Authors of Cilium */"
        },
        {
          "start_line": 26,
          "end_line": 34,
          "text": "/* This program should be attached to the tc-ingress of\n\t * the network-facing device. Thus, as far as Cilium\n\t * knows, no one touches to the ctx->mark before this\n\t * program.\n\t *\n\t * One exception is the case the packets are re-insearted\n\t * from the stack by xfrm. In that case, the packets should\n\t * be marked with MARK_MAGIC_DECRYPT.\n\t */"
        },
        {
          "start_line": 39,
          "end_line": 39,
          "text": "/* Pass unknown protocols to the stack */"
        },
        {
          "start_line": 46,
          "end_line": 68,
          "text": "/* We need to handle following possible packets come to this program\n *\n * 1. ESP packets coming from network (encrypted and not marked)\n * 2. Non-ESP packets coming from network (plain and not marked)\n * 3. Non-ESP packets coming from stack re-inserted by xfrm (plain\n *    and marked with MARK_MAGIC_DECRYPT, IPSec mode only)\n *\n * 1. will be traced with TRACE_REASON_ENCRYPTED, because\n * do_decrypt marks them with MARK_MAGIC_DECRYPT.\n *\n * 2. will be traced without TRACE_REASON_ENCRYPTED, because\n * do_decrypt does't touch to mark.\n *\n * 3. will be traced without TRACE_REASON_ENCRYPTED, because\n * do_decrypt clears the mark.\n *\n * Note that 1. contains the ESP packets someone else generated.\n * In that case, we trace it as \"encrypted\", but it doesn't mean\n * \"encrypted by Cilium\".\n *\n * We won't use TRACE_REASON_ENCRYPTED even if the packets are ESP,\n * because it doesn't matter for the non-IPSec mode.\n */"
        },
        {
          "start_line": 73,
          "end_line": 75,
          "text": "/* Only possible redirect in here is the one in the do_decrypt\n\t * which redirects to cilium_host.\n\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "int",
      "helper": [
        "CTX_ACT_OK",
        "CTX_ACT_REDIRECT"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "int from_network (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    int ret = CTX_ACT_OK;\n",
        "    __u16 proto __maybe_unused;\n",
        "    enum trace_reason reason = TRACE_REASON_UNKNOWN;\n",
        "    enum trace_point obs_point_to = TRACE_TO_STACK;\n",
        "    enum trace_point obs_point_from = TRACE_FROM_NETWORK;\n",
        "    bpf_clear_meta (ctx);\n",
        "    if ((ctx->mark & MARK_MAGIC_HOST_MASK) == MARK_MAGIC_DECRYPT)\n",
        "        obs_point_from = TRACE_FROM_STACK;\n",
        "\n",
        "#ifdef ENABLE_IPSEC\n",
        "    if (!validate_ethertype (ctx, &proto))\n",
        "        goto out;\n",
        "    ret = do_decrypt (ctx, proto);\n",
        "\n",
        "#endif\n",
        "\n",
        "#ifdef ENABLE_IPSEC\n",
        "    if ((ctx->mark & MARK_MAGIC_HOST_MASK) == MARK_MAGIC_DECRYPT)\n",
        "        reason = TRACE_REASON_ENCRYPTED;\n",
        "    if (ret == CTX_ACT_REDIRECT)\n",
        "        obs_point_to = TRACE_TO_HOST;\n",
        "\n",
        "#endif\n",
        "out :\n",
        "    send_trace_notify (ctx, obs_point_from, 0, 0, 0, ctx->ingress_ifindex, reason, TRACE_PAYLOAD_LEN);\n",
        "    send_trace_notify (ctx, obs_point_to, 0, 0, 0, ctx->ingress_ifindex, reason, TRACE_PAYLOAD_LEN);\n",
        "    return ret;\n",
        "}\n"
      ],
      "called_function_list": [
        "send_trace_notify",
        "validate_ethertype",
        "do_decrypt",
        "bpf_clear_meta"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        {
          "description": " Initialize the ctx buffer, passing protocols to the stack according to the imput packets (ESP packets coming from network; Non-ESP packets coming from network; Non-ESP packets coming from stack re-inserted by xfrm) ",
          "author": "Shun Zhang",
          "authorEmail": "shunz@bu.edu",
          "date": "2023-02-24"
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "handle_ipv6": [
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 46,
      "endLine": 180,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_overlay.c",
      "funcName": "handle_ipv6",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": "// SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)"
        },
        {
          "start_line": 2,
          "end_line": 2,
          "text": "/* Copyright Authors of Cilium */"
        },
        {
          "start_line": 12,
          "end_line": 14,
          "text": "/* Controls the inclusion of the CILIUM_CALL_HANDLE_ICMP6_NS section in the\n * bpf_lxc object file.\n */"
        },
        {
          "start_line": 17,
          "end_line": 19,
          "text": "/* Controls the inclusion of the CILIUM_CALL_SEND_ICMP6_ECHO_REPLY section in\n * the bpf_lxc object file.\n */"
        },
        {
          "start_line": 22,
          "end_line": 23,
          "text": "/* Controls the inclusion of the CILIUM_CALL_SRV6 section in the object file.\n */"
        },
        {
          "start_line": 43,
          "end_line": 43,
          "text": "/* ENABLE_VTEP */"
        },
        {
          "start_line": 56,
          "end_line": 56,
          "text": "/* verifier workaround (dereference of modified ctx ptr) */"
        },
        {
          "start_line": 81,
          "end_line": 84,
          "text": "/* Any node encapsulating will map any HOST_ID source to be\n\t\t * presented as REMOTE_NODE_ID, therefore any attempt to signal\n\t\t * HOST_ID as source from a remote node can be dropped.\n\t\t */"
        },
        {
          "start_line": 88,
          "end_line": 91,
          "text": "/* Maybe overwrite the REMOTE_NODE_ID with\n\t\t * KUBE_APISERVER_NODE_ID to support upgrade. After v1.12,\n\t\t * this should be removed.\n\t\t */"
        },
        {
          "start_line": 95,
          "end_line": 97,
          "text": "/* Look up the ipcache for the src IP, it will give us\n\t\t\t * the real identity of that IP.\n\t\t\t */"
        },
        {
          "start_line": 110,
          "end_line": 112,
          "text": "/* IPSec is not currently enforce (feature coming soon)\n\t\t * so for now just handle normally\n\t\t */"
        },
        {
          "start_line": 119,
          "end_line": 119,
          "text": "/* Decrypt \"key\" is determined by SPI */"
        },
        {
          "start_line": 122,
          "end_line": 127,
          "text": "/* To IPSec stack on cilium_vxlan we are going to pass\n\t\t * this up the stack but eth_type_trans has already labeled\n\t\t * this as an OTHERHOST type packet. To avoid being dropped\n\t\t * by IP stack before IPSec can be processed mark as a HOST\n\t\t * packet.\n\t\t */"
        },
        {
          "start_line": 140,
          "end_line": 140,
          "text": "/* Lookup IPv6 address in list of local endpoints */"
        },
        {
          "start_line": 145,
          "end_line": 147,
          "text": "/* Let through packets to the node-ip so they are processed by\n\t\t * the local ip stack.\n\t\t */"
        },
        {
          "start_line": 160,
          "end_line": 162,
          "text": "/* A packet entering the node from the tunnel and not going to a local\n\t * endpoint has to be going to the local host.\n\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " __u32 *identity"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "CTX_ACT_OK"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "static __always_inline int handle_ipv6 (struct  __ctx_buff *ctx, __u32 *identity)\n",
        "{\n",
        "    int ret, l3_off = ETH_HLEN, hdrlen;\n",
        "    void *data_end, *data;\n",
        "    struct ipv6hdr *ip6;\n",
        "    struct bpf_tunnel_key key = {}\n",
        "    ;\n",
        "    struct endpoint_info *ep;\n",
        "    bool decrypted;\n",
        "    if (!revalidate_data_pull (ctx, &data, &data_end, &ip6))\n",
        "        return DROP_INVALID;\n",
        "\n",
        "#ifdef ENABLE_NODEPORT\n",
        "    if (!bpf_skip_nodeport (ctx)) {\n",
        "        ret = nodeport_lb6 (ctx, * identity);\n",
        "        if (ret < 0)\n",
        "            return ret;\n",
        "    }\n",
        "\n",
        "#endif\n",
        "    ret = encap_remap_v6_host_address (ctx, false);\n",
        "    if (unlikely (ret < 0))\n",
        "        return ret;\n",
        "    if (!revalidate_data (ctx, &data, &data_end, &ip6))\n",
        "        return DROP_INVALID;\n",
        "    decrypted = ((ctx->mark & MARK_MAGIC_HOST_MASK) == MARK_MAGIC_DECRYPT);\n",
        "    if (decrypted) {\n",
        "        *identity = key.tunnel_id = get_identity (ctx);\n",
        "    }\n",
        "    else {\n",
        "        if (unlikely (ctx_get_tunnel_key (ctx, &key, sizeof (key), 0) < 0))\n",
        "            return DROP_NO_TUNNEL_KEY;\n",
        "        *identity = key.tunnel_id;\n",
        "        if (*identity == HOST_ID)\n",
        "            return DROP_INVALID_IDENTITY;\n",
        "        if (identity_is_remote_node (*identity)) {\n",
        "            struct remote_endpoint_info *info;\n",
        "            info = ipcache_lookup6 (& IPCACHE_MAP, (union v6addr *) & ip6 -> saddr, V6_CACHE_KEY_LEN);\n",
        "            if (info)\n",
        "                *identity = info->sec_label;\n",
        "        }\n",
        "    }\n",
        "    cilium_dbg (ctx, DBG_DECAP, key.tunnel_id, key.tunnel_label);\n",
        "\n",
        "#ifdef ENABLE_IPSEC\n",
        "    if (!decrypted) {\n",
        "        if (ip6->nexthdr != IPPROTO_ESP) {\n",
        "            update_metrics (ctx_full_len (ctx), METRIC_INGRESS, REASON_PLAINTEXT);\n",
        "            goto not_esp;\n",
        "        }\n",
        "        ctx->mark = MARK_MAGIC_DECRYPT;\n",
        "        set_identity_mark (ctx, *identity);\n",
        "        ctx_change_type (ctx, PACKET_HOST);\n",
        "        send_trace_notify (ctx, TRACE_TO_STACK, 0, 0, 0, ctx->ingress_ifindex, TRACE_REASON_ENCRYPTED, TRACE_PAYLOAD_LEN);\n",
        "        return CTX_ACT_OK;\n",
        "    }\n",
        "    ctx->mark = 0;\n",
        "not_esp :\n",
        "\n",
        "#endif\n",
        "    ep = lookup_ip6_endpoint (ip6);\n",
        "    if (ep) {\n",
        "        __u8 nexthdr;\n",
        "        if (ep->flags & ENDPOINT_F_HOST)\n",
        "            goto to_host;\n",
        "        nexthdr = ip6->nexthdr;\n",
        "        hdrlen = ipv6_hdrlen (ctx, & nexthdr);\n",
        "        if (hdrlen < 0)\n",
        "            return hdrlen;\n",
        "        return ipv6_local_delivery (ctx, l3_off, *identity, ep, METRIC_INGRESS, false);\n",
        "    }\n",
        "to_host :\n",
        "\n",
        "#ifdef HOST_IFINDEX\n",
        "    if (1) {\n",
        "        union macaddr host_mac = HOST_IFINDEX_MAC;\n",
        "        union macaddr router_mac = NODE_MAC;\n",
        "        ret = ipv6_l3 (ctx, ETH_HLEN, (__u8 *) & router_mac.addr, (__u8 *) & host_mac.addr, METRIC_INGRESS);\n",
        "        if (ret != CTX_ACT_OK)\n",
        "            return ret;\n",
        "        cilium_dbg_capture (ctx, DBG_CAPTURE_DELIVERY, HOST_IFINDEX);\n",
        "        return ctx_redirect (ctx, HOST_IFINDEX, 0);\n",
        "    }\n",
        "\n",
        "#else\n",
        "    return CTX_ACT_OK;\n",
        "\n",
        "#endif\n",
        "}\n"
      ],
      "called_function_list": [
        "ipcache_lookup6",
        "ipv6_local_delivery",
        "ipv6_l3",
        "get_identity",
        "encap_and_redirect_with_nodeid",
        "set_identity_meta",
        "ctx_get_xfer",
        "cilium_dbg",
        "set_identity_mark",
        "cilium_dbg_capture",
        "rewrite_dmac_to_host",
        "bpf_skip_nodeport",
        "icmp6_host_handle",
        "ipv6_host_policy_egress",
        "identity_is_remote_node",
        "ctx_redirect",
        "encap_remap_v6_host_address",
        "srv6_lookup_sid",
        "update_metrics",
        "ctx_skip_host_fw",
        "ipv6_hdrlen",
        "encap_and_redirect_netdev",
        "ep_tail_call",
        "set_encrypt_key_meta",
        "send_trace_notify",
        "ipv6_host_policy_ingress",
        "get_min_encrypt_key",
        "nodeport_lb6",
        "is_srv6_packet",
        "lookup_ip6_endpoint",
        "set_encrypt_dip",
        "ctx_full_len"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": " The main goal of handle_ipv6 is to check the different condition including  if nodeport, IPSEC is enabled and if the pulling data or decrypting gets error.  Then make different action to handle according situatoins to convert the IPV6 to a virtual  network which points to overlay. The first step is to verify the background by  using revalidate_data_pull and the pointer ctx (maybe the starting point of a protocol?).  Ret should be the new address of this IPV6 sector. If nodeport is not activated,  ret is set by encap_remap_v6_host address.Then check if the net is decrypted by using mark. Identity is equal to identity of ctx if the net is decrypted, but tunnel id if not. Check if the ID is equal to host_ID since any node encapsulating will map any HOST_ID source to be presented as REMOTE_NODE_ID, therefore any attempt to signal HOST_ID as source from a remote node can be dropped.After that, check esp protocol,ESPis a member of the Internet Protocol Security set of protocols that encrypt and authenticate the packets of data between computers using a Virtual Private Network. If ESP is activated, we set mark for the ID and change the type of ctx to packet_host to pass it up.If Esp is not activated, we look up the IPV6 address in list of local endpoints. If the endpoints reach the host, we go to the host  and set the ret, else we find the next headerlength and return that. ",
          "author": "Yichen Wang",
          "authorEmail": "wyichen@bu.edu",
          "date": "2023-02-24"
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        },
        {
          "capability": "pkt_alter_or_redo_processing_or_interface",
          "pkt_alter_or_redo_processing_or_interface": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_REDIRECT",
              "Return": 7,
              "Description": "This allows to redirect the skb to the same or another\u2019s device ingress or egress path together with the bpf_redirect() helper. Being able to inject the packet into another device\u2019s ingress or egress direction allows for full flexibility in packet forwarding with BPF. There are no requirements on the target networking device other than being a networking device itself, there is no need to run another instance of cls_bpf on the target device or other such restrictions.",
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_alter_or_redo_processing_or_interface"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 178,
      "endLine": 351,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c",
      "funcName": "handle_ipv6",
      "developer_inline_comments": [
        {
          "start_line": 216,
          "end_line": 221,
          "text": "/* nodeport_lb6() returns with TC_ACT_REDIRECT for\n\t\t\t * traffic to L7 LB. Policy enforcement needs to take\n\t\t\t * place after L7 LB has processed the packet, so we\n\t\t\t * return to stack immediately here with\n\t\t\t * TC_ACT_REDIRECT.\n\t\t\t */"
        },
        {
          "start_line": 225,
          "end_line": 225,
          "text": "/* Verifier workaround: modified ctx access. */"
        },
        {
          "start_line": 229,
          "end_line": 229,
          "text": "/* ENABLE_NODEPORT */"
        },
        {
          "start_line": 232,
          "end_line": 232,
          "text": "/* See IPv4 case for NO_REDIRECT/ENABLE_HOST_ROUTING comments */"
        },
        {
          "start_line": 235,
          "end_line": 235,
          "text": "/* NO_REDIRECT && !ENABLE_HOST_ROUTING */"
        },
        {
          "start_line": 247,
          "end_line": 247,
          "text": "/* ENABLE_HOST_FIREWALL */"
        },
        {
          "start_line": 256,
          "end_line": 258,
          "text": "/* This packet is destined to an SID so we need to decapsulate it\n\t\t\t * and forward it.\n\t\t\t */"
        },
        {
          "start_line": 263,
          "end_line": 263,
          "text": "/* ENABLE_SRV6 */"
        },
        {
          "start_line": 266,
          "end_line": 268,
          "text": "/* If we are attached to cilium_host at egress, this will\n\t\t * rewrite the destination MAC address to the MAC of cilium_net.\n\t\t */"
        },
        {
          "start_line": 270,
          "end_line": 270,
          "text": "/* DIRECT PACKET READ INVALID */"
        },
        {
          "start_line": 278,
          "end_line": 278,
          "text": "/* Lookup IPv6 address in list of local endpoints */"
        },
        {
          "start_line": 281,
          "end_line": 283,
          "text": "/* Let through packets to the node-ip so they are\n\t\t * processed by the local ip stack.\n\t\t */"
        },
        {
          "start_line": 291,
          "end_line": 293,
          "text": "/* Below remainder is only relevant when traffic is pushed via cilium_host.\n\t * For traffic coming from external, we're done here.\n\t */"
        },
        {
          "start_line": 304,
          "end_line": 307,
          "text": "/* If IPSEC is needed recirc through ingress to use xfrm stack\n\t\t * and then result will routed back through bpf_netdev on egress\n\t\t * but with encrypt marks.\n\t\t */"
        },
        {
          "start_line": 315,
          "end_line": 315,
          "text": "/* IPv6 lookup key: daddr/96 */"
        },
        {
          "start_line": 334,
          "end_line": 334,
          "text": "/* See IPv4 comment. */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " __u32 secctx",
        " const bool from_host"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "CTX_ACT_OK",
        "TC_ACT_REDIRECT"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act"
      ],
      "source": [
        "static __always_inline int handle_ipv6 (struct  __ctx_buff *ctx, __u32 secctx, const bool from_host)\n",
        "{\n",
        "    struct trace_ctx __maybe_unused trace = {\n",
        "        .reason = TRACE_REASON_UNKNOWN,\n",
        "        .monitor = TRACE_PAYLOAD_LEN,}\n",
        "    ;\n",
        "    struct remote_endpoint_info *info = NULL;\n",
        "    void *data, *data_end;\n",
        "    struct ipv6hdr *ip6;\n",
        "    union v6addr *dst;\n",
        "    __u32 __maybe_unused remote_id = WORLD_ID;\n",
        "    int ret, l3_off = ETH_HLEN, hdrlen;\n",
        "    bool skip_redirect = false;\n",
        "    struct endpoint_info *ep;\n",
        "    __u8 nexthdr;\n",
        "    if (!revalidate_data (ctx, &data, &data_end, &ip6))\n",
        "        return DROP_INVALID;\n",
        "    nexthdr = ip6->nexthdr;\n",
        "    hdrlen = ipv6_hdrlen (ctx, & nexthdr);\n",
        "    if (hdrlen < 0)\n",
        "        return hdrlen;\n",
        "    if (likely (nexthdr == IPPROTO_ICMPV6)) {\n",
        "        ret = icmp6_host_handle (ctx);\n",
        "        if (ret == SKIP_HOST_FIREWALL)\n",
        "            goto skip_host_firewall;\n",
        "        if (IS_ERR (ret))\n",
        "            return ret;\n",
        "    }\n",
        "\n",
        "#ifdef ENABLE_NODEPORT\n",
        "    if (!from_host) {\n",
        "        if (ctx_get_xfer (ctx) != XFER_PKT_NO_SVC && !bpf_skip_nodeport (ctx)) {\n",
        "            ret = nodeport_lb6 (ctx, secctx);\n",
        "            if (ret < 0 || ret == TC_ACT_REDIRECT)\n",
        "                return ret;\n",
        "        }\n",
        "        if (!revalidate_data (ctx, &data, &data_end, &ip6))\n",
        "            return DROP_INVALID;\n",
        "    }\n",
        "\n",
        "#endif /* ENABLE_NODEPORT */\n",
        "\n",
        "#if defined(NO_REDIRECT) && !defined(ENABLE_HOST_ROUTING)\n",
        "    if (!from_host)\n",
        "        skip_redirect = true;\n",
        "\n",
        "#endif /* NO_REDIRECT && !ENABLE_HOST_ROUTING */\n",
        "\n",
        "#ifdef ENABLE_HOST_FIREWALL\n",
        "    if (from_host) {\n",
        "        ret = ipv6_host_policy_egress (ctx, secctx, & trace);\n",
        "        if (IS_ERR (ret))\n",
        "            return ret;\n",
        "    }\n",
        "    else if (!ctx_skip_host_fw (ctx)) {\n",
        "        ret = ipv6_host_policy_ingress (ctx, & remote_id, & trace);\n",
        "        if (IS_ERR (ret))\n",
        "            return ret;\n",
        "    }\n",
        "\n",
        "#endif /* ENABLE_HOST_FIREWALL */\n",
        "    if (skip_redirect)\n",
        "        return CTX_ACT_OK;\n",
        "skip_host_firewall :\n",
        "\n",
        "#ifdef ENABLE_SRV6\n",
        "    if (!from_host) {\n",
        "        if (is_srv6_packet (ip6) && srv6_lookup_sid (&ip6->daddr)) {\n",
        "            ep_tail_call (ctx, CILIUM_CALL_SRV6_DECAP);\n",
        "            return DROP_MISSED_TAIL_CALL;\n",
        "        }\n",
        "    }\n",
        "\n",
        "#endif /* ENABLE_SRV6 */\n",
        "    if (from_host) {\n",
        "        ret = rewrite_dmac_to_host (ctx, secctx);\n",
        "        if (IS_ERR (ret))\n",
        "            return ret;\n",
        "        if (!revalidate_data (ctx, &data, &data_end, &ip6))\n",
        "            return DROP_INVALID;\n",
        "    }\n",
        "    ep = lookup_ip6_endpoint (ip6);\n",
        "    if (ep) {\n",
        "        if (ep->flags & ENDPOINT_F_HOST)\n",
        "            return CTX_ACT_OK;\n",
        "        return ipv6_local_delivery (ctx, l3_off, secctx, ep, METRIC_INGRESS, from_host);\n",
        "    }\n",
        "    if (!from_host)\n",
        "        return CTX_ACT_OK;\n",
        "\n",
        "#ifdef TUNNEL_MODE\n",
        "    dst = (union v6addr *) &ip6->daddr;\n",
        "    info = ipcache_lookup6 (& IPCACHE_MAP, dst, V6_CACHE_KEY_LEN);\n",
        "    if (info != NULL && info->tunnel_endpoint != 0) {\n",
        "        ret = encap_and_redirect_with_nodeid (ctx, info -> tunnel_endpoint, info -> key, secctx, & trace);\n",
        "        if (ret == IPSEC_ENDPOINT)\n",
        "            return CTX_ACT_OK;\n",
        "        else\n",
        "            return ret;\n",
        "    }\n",
        "    else {\n",
        "        struct endpoint_key key = {}\n",
        "        ;\n",
        "        dst = (union v6addr *) &ip6->daddr;\n",
        "        key.ip6.p1 = dst->p1;\n",
        "        key.ip6.p2 = dst->p2;\n",
        "        key.ip6.p3 = dst->p3;\n",
        "        key.ip6.p4 = 0;\n",
        "        key.family = ENDPOINT_KEY_IPV6;\n",
        "        ret = encap_and_redirect_netdev (ctx, & key, secctx, & trace);\n",
        "        if (ret == IPSEC_ENDPOINT)\n",
        "            return CTX_ACT_OK;\n",
        "        else if (ret != DROP_NO_TUNNEL_ENDPOINT)\n",
        "            return ret;\n",
        "    }\n",
        "\n",
        "#endif\n",
        "    dst = (union v6addr *) &ip6->daddr;\n",
        "    info = ipcache_lookup6 (& IPCACHE_MAP, dst, V6_CACHE_KEY_LEN);\n",
        "    if (info == NULL || info->sec_label == WORLD_ID) {\n",
        "        return DROP_UNROUTABLE;\n",
        "    }\n",
        "\n",
        "#ifdef ENABLE_IPSEC\n",
        "    if (info && info->key && info->tunnel_endpoint) {\n",
        "        __u8 key = get_min_encrypt_key (info -> key);\n",
        "        set_encrypt_key_meta (ctx, key);\n",
        "\n",
        "#ifdef IP_POOLS\n",
        "        set_encrypt_dip (ctx, info->tunnel_endpoint);\n",
        "\n",
        "#else\n",
        "        set_identity_meta (ctx, secctx);\n",
        "\n",
        "#endif\n",
        "    }\n",
        "\n",
        "#endif\n",
        "    return CTX_ACT_OK;\n",
        "}\n"
      ],
      "called_function_list": [
        "ipcache_lookup6",
        "ipv6_local_delivery",
        "ipv6_l3",
        "get_identity",
        "encap_and_redirect_with_nodeid",
        "set_identity_meta",
        "ctx_get_xfer",
        "cilium_dbg",
        "set_identity_mark",
        "cilium_dbg_capture",
        "rewrite_dmac_to_host",
        "bpf_skip_nodeport",
        "icmp6_host_handle",
        "ipv6_host_policy_egress",
        "identity_is_remote_node",
        "ctx_redirect",
        "encap_remap_v6_host_address",
        "srv6_lookup_sid",
        "update_metrics",
        "ctx_skip_host_fw",
        "ipv6_hdrlen",
        "encap_and_redirect_netdev",
        "ep_tail_call",
        "set_encrypt_key_meta",
        "send_trace_notify",
        "ipv6_host_policy_ingress",
        "get_min_encrypt_key",
        "nodeport_lb6",
        "is_srv6_packet",
        "lookup_ip6_endpoint",
        "set_encrypt_dip",
        "ctx_full_len"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "tail_handle_ipv6": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 183,
      "endLine": 192,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_overlay.c",
      "funcName": "tail_handle_ipv6",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "int",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "int tail_handle_ipv6 (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    __u32 src_identity = 0;\n",
        "    int ret = handle_ipv6 (ctx, & src_identity);\n",
        "    if (IS_ERR (ret))\n",
        "        return send_drop_notify_error (ctx, src_identity, ret, CTX_ACT_DROP, METRIC_INGRESS);\n",
        "    return ret;\n",
        "}\n"
      ],
      "called_function_list": [
        "__tail_handle_ipv6",
        "ctx_store_meta",
        "ctx_load_meta",
        "handle_ipv6"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": " This function is to handle the tail of a protocol and check it it has any error for ipv6 ",
          "author": "Yichen Wang",
          "authorEmail": "wyichen@bu.edu",
          "date": "2023-02-24"
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 697,
      "endLine": 705,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_lxc.c",
      "funcName": "tail_handle_ipv6",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "int",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "int tail_handle_ipv6 (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    int ret = __tail_handle_ipv6 (ctx);\n",
        "    if (IS_ERR (ret))\n",
        "        return send_drop_notify_error (ctx, SECLABEL, ret, CTX_ACT_DROP, METRIC_EGRESS);\n",
        "    return ret;\n",
        "}\n"
      ],
      "called_function_list": [
        "__tail_handle_ipv6",
        "ctx_store_meta",
        "ctx_load_meta",
        "handle_ipv6"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": " Count ipv6 tail calls ",
          "author": "Yihe Bi",
          "authorEmail": "ybi@bu.edu",
          "date": "2023-02-24"
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 353,
      "endLine": 366,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c",
      "funcName": "tail_handle_ipv6",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " const bool from_host"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int tail_handle_ipv6 (struct  __ctx_buff *ctx, const bool from_host)\n",
        "{\n",
        "    __u32 proxy_identity = ctx_load_meta (ctx, CB_SRC_IDENTITY);\n",
        "    int ret;\n",
        "    ctx_store_meta (ctx, CB_SRC_IDENTITY, 0);\n",
        "    ret = handle_ipv6 (ctx, proxy_identity, from_host);\n",
        "    if (IS_ERR (ret))\n",
        "        return send_drop_notify_error (ctx, proxy_identity, ret, CTX_ACT_DROP, METRIC_INGRESS);\n",
        "    return ret;\n",
        "}\n"
      ],
      "called_function_list": [
        "__tail_handle_ipv6",
        "ctx_store_meta",
        "ctx_load_meta",
        "handle_ipv6"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "handle_ipv4": [
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        },
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 196,
      "endLine": 333,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_overlay.c",
      "funcName": "handle_ipv4",
      "developer_inline_comments": [
        {
          "start_line": 204,
          "end_line": 204,
          "text": "/* verifier workaround (dereference of modified ctx ptr) */"
        },
        {
          "start_line": 208,
          "end_line": 211,
          "text": "/* If IPv4 fragmentation is disabled\n * AND a IPv4 fragmented packet is received,\n * then drop the packet.\n */"
        },
        {
          "start_line": 229,
          "end_line": 229,
          "text": "/* If packets are decrypted the key has already been pushed into metadata. */"
        },
        {
          "start_line": 255,
          "end_line": 255,
          "text": "/* See comment at equivalent code in handle_ipv6() */"
        },
        {
          "start_line": 270,
          "end_line": 272,
          "text": "/* IPSec is not currently enforce (feature coming soon)\n\t\t * so for now just handle normally\n\t\t */"
        },
        {
          "start_line": 281,
          "end_line": 286,
          "text": "/* To IPSec stack on cilium_vxlan we are going to pass\n\t\t * this up the stack but eth_type_trans has already labeled\n\t\t * this as an OTHERHOST type packet. To avoid being dropped\n\t\t * by IP stack before IPSec can be processed mark as a HOST\n\t\t * packet.\n\t\t */"
        },
        {
          "start_line": 299,
          "end_line": 299,
          "text": "/* Lookup IPv4 address in list of local endpoints */"
        },
        {
          "start_line": 302,
          "end_line": 304,
          "text": "/* Let through packets to the node-ip so they are processed by\n\t\t * the local ip stack.\n\t\t */"
        },
        {
          "start_line": 312,
          "end_line": 314,
          "text": "/* A packet entering the node from the tunnel and not going to a local\n\t * endpoint has to be going to the local host.\n\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [
        "  VTEP_MAP"
      ],
      "input": [
        "struct  __ctx_buff *ctx",
        " __u32 *identity"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "CTX_ACT_OK",
        "map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "static __always_inline int handle_ipv4 (struct  __ctx_buff *ctx, __u32 *identity)\n",
        "{\n",
        "    void *data_end, *data;\n",
        "    struct iphdr *ip4;\n",
        "    struct endpoint_info *ep;\n",
        "    struct bpf_tunnel_key key = {}\n",
        "    ;\n",
        "    bool decrypted;\n",
        "    if (!revalidate_data_pull (ctx, &data, &data_end, &ip4))\n",
        "        return DROP_INVALID;\n",
        "\n",
        "#ifndef ENABLE_IPV4_FRAGMENTS\n",
        "    if (ipv4_is_fragment (ip4))\n",
        "        return DROP_FRAG_NOSUPPORT;\n",
        "\n",
        "#endif\n",
        "\n",
        "#ifdef ENABLE_NODEPORT\n",
        "    if (!bpf_skip_nodeport (ctx)) {\n",
        "        int ret = nodeport_lb4 (ctx, * identity);\n",
        "        if (ret < 0)\n",
        "            return ret;\n",
        "    }\n",
        "\n",
        "#endif\n",
        "    if (!revalidate_data (ctx, &data, &data_end, &ip4))\n",
        "        return DROP_INVALID;\n",
        "    decrypted = ((ctx->mark & MARK_MAGIC_HOST_MASK) == MARK_MAGIC_DECRYPT);\n",
        "    if (decrypted) {\n",
        "        *identity = key.tunnel_id = get_identity (ctx);\n",
        "    }\n",
        "    else {\n",
        "        if (unlikely (ctx_get_tunnel_key (ctx, &key, sizeof (key), 0) < 0))\n",
        "            return DROP_NO_TUNNEL_KEY;\n",
        "        *identity = key.tunnel_id;\n",
        "        if (*identity == HOST_ID)\n",
        "            return DROP_INVALID_IDENTITY;\n",
        "\n",
        "#ifdef ENABLE_VTEP\n",
        "        {\n",
        "            struct vtep_key vkey = {}\n",
        "            ;\n",
        "            struct vtep_value *info;\n",
        "            vkey.vtep_ip = ip4->saddr & VTEP_MASK;\n",
        "            info = map_lookup_elem (& VTEP_MAP, & vkey);\n",
        "            if (!info)\n",
        "                goto skip_vtep;\n",
        "            if (info->tunnel_endpoint) {\n",
        "                if (*identity != WORLD_ID)\n",
        "                    return DROP_INVALID_VNI;\n",
        "            }\n",
        "        }\n",
        "    skip_vtep :\n",
        "\n",
        "#endif\n",
        "        if (identity_is_remote_node (*identity)) {\n",
        "            struct remote_endpoint_info *info;\n",
        "            info = ipcache_lookup4 (& IPCACHE_MAP, ip4 -> saddr, V4_CACHE_KEY_LEN);\n",
        "            if (info)\n",
        "                *identity = info->sec_label;\n",
        "        }\n",
        "    }\n",
        "    cilium_dbg (ctx, DBG_DECAP, key.tunnel_id, key.tunnel_label);\n",
        "\n",
        "#ifdef ENABLE_IPSEC\n",
        "    if (!decrypted) {\n",
        "        if (ip4->protocol != IPPROTO_ESP) {\n",
        "            update_metrics (ctx_full_len (ctx), METRIC_INGRESS, REASON_PLAINTEXT);\n",
        "            goto not_esp;\n",
        "        }\n",
        "        ctx->mark = MARK_MAGIC_DECRYPT;\n",
        "        set_identity_mark (ctx, *identity);\n",
        "        ctx_change_type (ctx, PACKET_HOST);\n",
        "        send_trace_notify (ctx, TRACE_TO_STACK, 0, 0, 0, ctx->ingress_ifindex, TRACE_REASON_ENCRYPTED, TRACE_PAYLOAD_LEN);\n",
        "        return CTX_ACT_OK;\n",
        "    }\n",
        "    ctx->mark = 0;\n",
        "not_esp :\n",
        "\n",
        "#endif\n",
        "    ep = lookup_ip4_endpoint (ip4);\n",
        "    if (ep) {\n",
        "        if (ep->flags & ENDPOINT_F_HOST)\n",
        "            goto to_host;\n",
        "        return ipv4_local_delivery (ctx, ETH_HLEN, *identity, ip4, ep, METRIC_INGRESS, false);\n",
        "    }\n",
        "to_host :\n",
        "\n",
        "#ifdef HOST_IFINDEX\n",
        "    if (1) {\n",
        "        union macaddr host_mac = HOST_IFINDEX_MAC;\n",
        "        union macaddr router_mac = NODE_MAC;\n",
        "        int ret;\n",
        "        ret = ipv4_l3 (ctx, ETH_HLEN, (__u8 *) & router_mac.addr, (__u8 *) & host_mac.addr, ip4);\n",
        "        if (ret != CTX_ACT_OK)\n",
        "            return ret;\n",
        "        cilium_dbg_capture (ctx, DBG_CAPTURE_DELIVERY, HOST_IFINDEX);\n",
        "        return ctx_redirect (ctx, HOST_IFINDEX, 0);\n",
        "    }\n",
        "\n",
        "#else\n",
        "    return CTX_ACT_OK;\n",
        "\n",
        "#endif\n",
        "}\n"
      ],
      "called_function_list": [
        "ipv4_local_delivery",
        "ipv4_host_policy_egress",
        "encap_and_redirect_with_nodeid",
        "set_identity_meta",
        "get_identity",
        "ipv4_l3",
        "ctx_get_xfer",
        "cilium_dbg",
        "set_identity_mark",
        "ctx_store_meta",
        "cilium_dbg_capture",
        "rewrite_dmac_to_host",
        "bpf_skip_nodeport",
        "identity_is_remote_node",
        "ipv4_is_fragment",
        "ctx_redirect",
        "update_metrics",
        "ipv4_host_policy_ingress",
        "ctx_skip_host_fw",
        "encap_and_redirect_netdev",
        "nodeport_lb4",
        "ep_tail_call",
        "set_encrypt_key_meta",
        "eth_store_daddr",
        "send_trace_notify",
        "get_min_encrypt_key",
        "ipcache_lookup4",
        "lookup_ip4_endpoint",
        "set_encrypt_dip",
        "ctx_full_len",
        "__encap_and_redirect_with_nodeid"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": " This function is similar to handle_ipv6 to handle ipv4 packet. The main goal of it is to check the different condition including  if nodeport, IPSEC is enabled and if the pulling data or decrypting gets error.  Then make different action to handle according situatoins to convert the IPV6 to a virtual  network which points to overlay. IPV4 fragmentation check is added. ",
          "author": "Yichen Wang",
          "authorEmail": "wyichen@bu.edu",
          "date": "2023-02-24"
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        },
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        },
        {
          "capability": "pkt_alter_or_redo_processing_or_interface",
          "pkt_alter_or_redo_processing_or_interface": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_REDIRECT",
              "Return": 7,
              "Description": "This allows to redirect the skb to the same or another\u2019s device ingress or egress path together with the bpf_redirect() helper. Being able to inject the packet into another device\u2019s ingress or egress direction allows for full flexibility in packet forwarding with BPF. There are no requirements on the target networking device other than being a networking device itself, there is no need to run another instance of cls_bpf on the target device or other such restrictions.",
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_alter_or_redo_processing_or_interface"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 471,
      "endLine": 671,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c",
      "funcName": "handle_ipv4",
      "developer_inline_comments": [
        {
          "start_line": 491,
          "end_line": 494,
          "text": "/* If IPv4 fragmentation is disabled\n * AND a IPv4 fragmented packet is received,\n * then drop the packet.\n */"
        },
        {
          "start_line": 514,
          "end_line": 519,
          "text": "/* nodeport_lb4() returns with TC_ACT_REDIRECT for\n\t\t\t * traffic to L7 LB. Policy enforcement needs to take\n\t\t\t * place after L7 LB has processed the packet, so we\n\t\t\t * return to stack immediately here with\n\t\t\t * TC_ACT_REDIRECT.\n\t\t\t */"
        },
        {
          "start_line": 523,
          "end_line": 523,
          "text": "/* Verifier workaround: modified ctx access. */"
        },
        {
          "start_line": 527,
          "end_line": 527,
          "text": "/* ENABLE_NODEPORT */"
        },
        {
          "start_line": 530,
          "end_line": 538,
          "text": "/* Without bpf_redirect_neigh() helper, we cannot redirect a\n\t * packet to a local endpoint in the direct routing mode, as\n\t * the redirect bypasses nf_conntrack table. This makes a\n\t * second reply from the endpoint to be MASQUERADEd or to be\n\t * DROP-ed by k8s's \"--ctstate INVALID -j DROP\" depending via\n\t * which interface it was inputed. With bpf_redirect_neigh()\n\t * we bypass request and reply path in the host namespace and\n\t * do not run into this issue.\n\t */"
        },
        {
          "start_line": 541,
          "end_line": 541,
          "text": "/* NO_REDIRECT && !ENABLE_HOST_ROUTING */"
        },
        {
          "start_line": 545,
          "end_line": 545,
          "text": "/* We're on the egress path of cilium_host. */"
        },
        {
          "start_line": 551,
          "end_line": 551,
          "text": "/* We're on the ingress path of the native device. */"
        },
        {
          "start_line": 556,
          "end_line": 556,
          "text": "/* ENABLE_HOST_FIREWALL */"
        },
        {
          "start_line": 564,
          "end_line": 566,
          "text": "/* If we are attached to cilium_host at egress, this will\n\t\t * rewrite the destination MAC address to the MAC of cilium_net.\n\t\t */"
        },
        {
          "start_line": 568,
          "end_line": 568,
          "text": "/* DIRECT PACKET READ INVALID */"
        },
        {
          "start_line": 576,
          "end_line": 576,
          "text": "/* Lookup IPv4 address in list of local endpoints and host IPs */"
        },
        {
          "start_line": 579,
          "end_line": 581,
          "text": "/* Let through packets to the node-ip so they are processed by\n\t\t * the local ip stack.\n\t\t */"
        },
        {
          "start_line": 589,
          "end_line": 591,
          "text": "/* Below remainder is only relevant when traffic is pushed via cilium_host.\n\t * For traffic coming from external, we're done here.\n\t */"
        },
        {
          "start_line": 595,
          "end_line": 597,
          "text": "/* Handle VTEP integration in bpf_host to support pod L7 PROXY.\n\t * It requires route setup to VTEP CIDR via dev cilium_host scope link.\n\t */"
        },
        {
          "start_line": 629,
          "end_line": 629,
          "text": "/* IPv4 lookup key: daddr & IPV4_MASK */"
        },
        {
          "start_line": 646,
          "end_line": 654,
          "text": "/* We have received a packet for which no ipcache entry exists,\n\t\t * we do not know what to do with this packet, drop it.\n\t\t *\n\t\t * The info == NULL test is soley to satisfy verifier requirements\n\t\t * as in Cilium case we'll always hit the 0.0.0.0/32 catch-all\n\t\t * entry. Therefore we need to test for WORLD_ID. It is clearly\n\t\t * wrong to route a ctx to cilium_host for which we don't know\n\t\t * anything about it as otherwise we'll run into a routing loop.\n\t\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [
        "  VTEP_MAP"
      ],
      "input": [
        "struct  __ctx_buff *ctx",
        " __u32 secctx",
        " __u32 ipcache_srcid __maybe_unused",
        " const bool from_host"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "CTX_ACT_OK",
        "map_lookup_elem",
        "TC_ACT_REDIRECT"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act"
      ],
      "source": [
        "static __always_inline int handle_ipv4 (struct  __ctx_buff *ctx, __u32 secctx, __u32 ipcache_srcid __maybe_unused, const bool from_host)\n",
        "{\n",
        "    struct trace_ctx __maybe_unused trace = {\n",
        "        .reason = TRACE_REASON_UNKNOWN,\n",
        "        .monitor = TRACE_PAYLOAD_LEN,}\n",
        "    ;\n",
        "    struct remote_endpoint_info *info = NULL;\n",
        "    __u32 __maybe_unused remote_id = 0;\n",
        "    struct ipv4_ct_tuple tuple = {}\n",
        "    ;\n",
        "    bool skip_redirect = false;\n",
        "    struct endpoint_info *ep;\n",
        "    void *data, *data_end;\n",
        "    struct iphdr *ip4;\n",
        "    int ret;\n",
        "    if (!revalidate_data (ctx, &data, &data_end, &ip4))\n",
        "        return DROP_INVALID;\n",
        "\n",
        "#ifndef ENABLE_IPV4_FRAGMENTS\n",
        "    if (ipv4_is_fragment (ip4))\n",
        "        return DROP_FRAG_NOSUPPORT;\n",
        "\n",
        "#endif\n",
        "\n",
        "#ifdef ENABLE_NODEPORT\n",
        "    if (!from_host) {\n",
        "        if (ctx_get_xfer (ctx) != XFER_PKT_NO_SVC && !bpf_skip_nodeport (ctx)) {\n",
        "            ret = nodeport_lb4 (ctx, secctx);\n",
        "            if (ret == NAT_46X64_RECIRC) {\n",
        "                ctx_store_meta (ctx, CB_SRC_IDENTITY, secctx);\n",
        "                ep_tail_call (ctx, CILIUM_CALL_IPV6_FROM_NETDEV);\n",
        "                return send_drop_notify_error (ctx, secctx, DROP_MISSED_TAIL_CALL, CTX_ACT_DROP, METRIC_INGRESS);\n",
        "            }\n",
        "            if (ret < 0 || ret == TC_ACT_REDIRECT)\n",
        "                return ret;\n",
        "        }\n",
        "        if (!revalidate_data (ctx, &data, &data_end, &ip4))\n",
        "            return DROP_INVALID;\n",
        "    }\n",
        "\n",
        "#endif /* ENABLE_NODEPORT */\n",
        "\n",
        "#if defined(NO_REDIRECT) && !defined(ENABLE_HOST_ROUTING)\n",
        "    if (!from_host)\n",
        "        skip_redirect = true;\n",
        "\n",
        "#endif /* NO_REDIRECT && !ENABLE_HOST_ROUTING */\n",
        "\n",
        "#ifdef ENABLE_HOST_FIREWALL\n",
        "    if (from_host) {\n",
        "        ret = ipv4_host_policy_egress (ctx, secctx, ipcache_srcid, & trace);\n",
        "        if (IS_ERR (ret))\n",
        "            return ret;\n",
        "    }\n",
        "    else if (!ctx_skip_host_fw (ctx)) {\n",
        "        ret = ipv4_host_policy_ingress (ctx, & remote_id, & trace);\n",
        "        if (IS_ERR (ret))\n",
        "            return ret;\n",
        "    }\n",
        "\n",
        "#endif /* ENABLE_HOST_FIREWALL */\n",
        "    if (skip_redirect)\n",
        "        return CTX_ACT_OK;\n",
        "    tuple.nexthdr = ip4->protocol;\n",
        "    if (from_host) {\n",
        "        ret = rewrite_dmac_to_host (ctx, secctx);\n",
        "        if (IS_ERR (ret))\n",
        "            return ret;\n",
        "        if (!revalidate_data (ctx, &data, &data_end, &ip4))\n",
        "            return DROP_INVALID;\n",
        "    }\n",
        "    ep = lookup_ip4_endpoint (ip4);\n",
        "    if (ep) {\n",
        "        if (ep->flags & ENDPOINT_F_HOST)\n",
        "            return CTX_ACT_OK;\n",
        "        return ipv4_local_delivery (ctx, ETH_HLEN, secctx, ip4, ep, METRIC_INGRESS, from_host);\n",
        "    }\n",
        "    if (!from_host)\n",
        "        return CTX_ACT_OK;\n",
        "\n",
        "#ifdef ENABLE_VTEP\n",
        "    {\n",
        "        struct vtep_key vkey = {}\n",
        "        ;\n",
        "        struct vtep_value *vtep;\n",
        "        vkey.vtep_ip = ip4->daddr & VTEP_MASK;\n",
        "        vtep = map_lookup_elem (& VTEP_MAP, & vkey);\n",
        "        if (!vtep)\n",
        "            goto skip_vtep;\n",
        "        if (vtep->vtep_mac && vtep->tunnel_endpoint) {\n",
        "            if (eth_store_daddr (ctx, (__u8 *) &vtep->vtep_mac, 0) < 0)\n",
        "                return DROP_WRITE_ERROR;\n",
        "            return __encap_and_redirect_with_nodeid (ctx, vtep->tunnel_endpoint, secctx, WORLD_ID, &trace);\n",
        "        }\n",
        "    }\n",
        "skip_vtep :\n",
        "\n",
        "#endif\n",
        "\n",
        "#ifdef TUNNEL_MODE\n",
        "    info = ipcache_lookup4 (& IPCACHE_MAP, ip4 -> daddr, V4_CACHE_KEY_LEN);\n",
        "    if (info != NULL && info->tunnel_endpoint != 0) {\n",
        "        ret = encap_and_redirect_with_nodeid (ctx, info -> tunnel_endpoint, info -> key, secctx, & trace);\n",
        "        if (ret == IPSEC_ENDPOINT)\n",
        "            return CTX_ACT_OK;\n",
        "        else\n",
        "            return ret;\n",
        "    }\n",
        "    else {\n",
        "        struct endpoint_key key = {}\n",
        "        ;\n",
        "        key.ip4 = ip4->daddr & IPV4_MASK;\n",
        "        key.family = ENDPOINT_KEY_IPV4;\n",
        "        cilium_dbg (ctx, DBG_NETDEV_ENCAP4, key.ip4, secctx);\n",
        "        ret = encap_and_redirect_netdev (ctx, & key, secctx, & trace);\n",
        "        if (ret == IPSEC_ENDPOINT)\n",
        "            return CTX_ACT_OK;\n",
        "        else if (ret != DROP_NO_TUNNEL_ENDPOINT)\n",
        "            return ret;\n",
        "    }\n",
        "\n",
        "#endif\n",
        "    info = ipcache_lookup4 (& IPCACHE_MAP, ip4 -> daddr, V4_CACHE_KEY_LEN);\n",
        "    if (info == NULL || info->sec_label == WORLD_ID) {\n",
        "        return DROP_UNROUTABLE;\n",
        "    }\n",
        "\n",
        "#ifdef ENABLE_IPSEC\n",
        "    if (info && info->key && info->tunnel_endpoint) {\n",
        "        __u8 key = get_min_encrypt_key (info -> key);\n",
        "        set_encrypt_key_meta (ctx, key);\n",
        "\n",
        "#ifdef IP_POOLS\n",
        "        set_encrypt_dip (ctx, info->tunnel_endpoint);\n",
        "\n",
        "#else\n",
        "        set_identity_meta (ctx, secctx);\n",
        "\n",
        "#endif\n",
        "    }\n",
        "\n",
        "#endif\n",
        "    return CTX_ACT_OK;\n",
        "}\n"
      ],
      "called_function_list": [
        "ipv4_local_delivery",
        "ipv4_host_policy_egress",
        "encap_and_redirect_with_nodeid",
        "set_identity_meta",
        "get_identity",
        "ipv4_l3",
        "ctx_get_xfer",
        "cilium_dbg",
        "set_identity_mark",
        "ctx_store_meta",
        "cilium_dbg_capture",
        "rewrite_dmac_to_host",
        "bpf_skip_nodeport",
        "identity_is_remote_node",
        "ipv4_is_fragment",
        "ctx_redirect",
        "update_metrics",
        "ipv4_host_policy_ingress",
        "ctx_skip_host_fw",
        "encap_and_redirect_netdev",
        "nodeport_lb4",
        "ep_tail_call",
        "set_encrypt_key_meta",
        "eth_store_daddr",
        "send_trace_notify",
        "get_min_encrypt_key",
        "ipcache_lookup4",
        "lookup_ip4_endpoint",
        "set_encrypt_dip",
        "ctx_full_len",
        "__encap_and_redirect_with_nodeid"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "tail_handle_ipv4": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 336,
      "endLine": 345,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_overlay.c",
      "funcName": "tail_handle_ipv4",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "int",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "int tail_handle_ipv4 (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    __u32 src_identity = 0;\n",
        "    int ret = handle_ipv4 (ctx, & src_identity);\n",
        "    if (IS_ERR (ret))\n",
        "        return send_drop_notify_error (ctx, src_identity, ret, CTX_ACT_DROP, METRIC_INGRESS);\n",
        "    return ret;\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_store_meta",
        "ctx_load_meta",
        "__tail_handle_ipv4",
        "handle_ipv4"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": " check if there is error about the tail of ipv4 packet. ",
          "author": "Yichen Wang",
          "authorEmail": "wyichen@bu.edu",
          "date": "2023-02-24"
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1259,
      "endLine": 1267,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_lxc.c",
      "funcName": "tail_handle_ipv4",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "int",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "int tail_handle_ipv4 (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    int ret = __tail_handle_ipv4 (ctx);\n",
        "    if (IS_ERR (ret))\n",
        "        return send_drop_notify_error (ctx, SECLABEL, ret, CTX_ACT_DROP, METRIC_EGRESS);\n",
        "    return ret;\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_store_meta",
        "ctx_load_meta",
        "__tail_handle_ipv4",
        "handle_ipv4"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": " Count ipv4 tail call. Helper function for handling ipv4 traffic ",
          "author": "Yihe Bi",
          "authorEmail": "ybi@bu.edu",
          "date": "2023-02-24"
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 673,
      "endLine": 686,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c",
      "funcName": "tail_handle_ipv4",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " __u32 ipcache_srcid",
        " const bool from_host"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int tail_handle_ipv4 (struct  __ctx_buff *ctx, __u32 ipcache_srcid, const bool from_host)\n",
        "{\n",
        "    __u32 proxy_identity = ctx_load_meta (ctx, CB_SRC_IDENTITY);\n",
        "    int ret;\n",
        "    ctx_store_meta (ctx, CB_SRC_IDENTITY, 0);\n",
        "    ret = handle_ipv4 (ctx, proxy_identity, ipcache_srcid, from_host);\n",
        "    if (IS_ERR (ret))\n",
        "        return send_drop_notify_error (ctx, proxy_identity, ret, CTX_ACT_DROP, METRIC_INGRESS);\n",
        "    return ret;\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_store_meta",
        "ctx_load_meta",
        "__tail_handle_ipv4",
        "handle_ipv4"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "tail_handle_arp": [
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        },
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 353,
      "endLine": 395,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_overlay.c",
      "funcName": "tail_handle_arp",
      "developer_inline_comments": [
        {
          "start_line": 348,
          "end_line": 351,
          "text": "/*\n * ARP responder for ARP requests from VTEP\n * Respond to remote VTEP endpoint with cilium_vxlan MAC\n */"
        }
      ],
      "updateMaps": [],
      "readMaps": [
        "  VTEP_MAP"
      ],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "int",
      "helper": [
        "CTX_ACT_OK",
        "map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "int tail_handle_arp (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    union macaddr mac = NODE_MAC;\n",
        "    union macaddr smac;\n",
        "    struct trace_ctx trace = {\n",
        "        .reason = TRACE_REASON_CT_REPLY,\n",
        "        .monitor = TRACE_PAYLOAD_LEN,}\n",
        "    ;\n",
        "    __be32 sip;\n",
        "    __be32 tip;\n",
        "    int ret;\n",
        "    struct bpf_tunnel_key key = {}\n",
        "    ;\n",
        "    struct vtep_key vkey = {}\n",
        "    ;\n",
        "    struct vtep_value *info;\n",
        "    if (unlikely (ctx_get_tunnel_key (ctx, &key, sizeof (key), 0) < 0))\n",
        "        return send_drop_notify_error (ctx, 0, DROP_NO_TUNNEL_KEY, CTX_ACT_DROP, METRIC_INGRESS);\n",
        "    if (!arp_validate (ctx, &mac, &smac, &sip, &tip) || !__lookup_ip4_endpoint (tip))\n",
        "        goto pass_to_stack;\n",
        "    vkey.vtep_ip = sip & VTEP_MASK;\n",
        "    info = map_lookup_elem (& VTEP_MAP, & vkey);\n",
        "    if (!info)\n",
        "        goto pass_to_stack;\n",
        "    ret = arp_prepare_response (ctx, & mac, tip, & smac, sip);\n",
        "    if (unlikely (ret != 0))\n",
        "        return send_drop_notify_error (ctx, 0, ret, CTX_ACT_DROP, METRIC_EGRESS);\n",
        "    if (info->tunnel_endpoint)\n",
        "        return __encap_and_redirect_with_nodeid (ctx, info->tunnel_endpoint, SECLABEL, WORLD_ID, &trace);\n",
        "    return send_drop_notify_error (ctx, 0, DROP_UNKNOWN_L3, CTX_ACT_DROP, METRIC_EGRESS);\n",
        "pass_to_stack :\n",
        "    send_trace_notify (ctx, TRACE_TO_STACK, 0, 0, 0, ctx->ingress_ifindex, trace.reason, trace.monitor);\n",
        "    return CTX_ACT_OK;\n",
        "}\n"
      ],
      "called_function_list": [
        "arp_validate",
        "arp_respond",
        "__lookup_ip4_endpoint",
        "send_trace_notify",
        "arp_prepare_response",
        "__encap_and_redirect_with_nodeid"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        {
          "description": " Handle the tail for ARP requests from VTEP. Check different occasions including tunnel_key geting, arp validating, and if endpoint of tunnel is reached. ",
          "author": "Yichen Wang",
          "authorEmail": "wyichen@bu.edu",
          "date": "2023-02-24"
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 1275,
      "endLine": 1300,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_lxc.c",
      "funcName": "tail_handle_arp",
      "developer_inline_comments": [
        {
          "start_line": 1270,
          "end_line": 1273,
          "text": "/*\n * ARP responder for ARP requests from container\n * Respond to IPV4_GATEWAY with NODE_MAC\n */"
        },
        {
          "start_line": 1282,
          "end_line": 1282,
          "text": "/* Pass any unknown ARP requests to the Linux stack */"
        },
        {
          "start_line": 1286,
          "end_line": 1295,
          "text": "/*\n\t * The endpoint is expected to make ARP requests for its gateway IP.\n\t * Most of the time, the gateway IP configured on the endpoint is\n\t * IPV4_GATEWAY but it may not be the case if after cilium agent reload\n\t * a different gateway is chosen. In such a case, existing endpoints\n\t * will have an old gateway configured. Since we don't know the IP of\n\t * previous gateways, we answer requests for all IPs with the exception\n\t * of the LXC IP (to avoid specific problems, like IP duplicate address\n\t * detection checks that might run within the container).\n\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "int",
      "helper": [
        "CTX_ACT_OK"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "int tail_handle_arp (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    union macaddr mac = NODE_MAC;\n",
        "    union macaddr smac;\n",
        "    __be32 sip;\n",
        "    __be32 tip;\n",
        "    if (!arp_validate (ctx, &mac, &smac, &sip, &tip))\n",
        "        return CTX_ACT_OK;\n",
        "    if (tip == LXC_IPV4)\n",
        "        return CTX_ACT_OK;\n",
        "    return arp_respond (ctx, &mac, tip, &smac, sip, 0);\n",
        "}\n"
      ],
      "called_function_list": [
        "arp_validate",
        "arp_respond",
        "__lookup_ip4_endpoint",
        "send_trace_notify",
        "arp_prepare_response",
        "__encap_and_redirect_with_nodeid"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        {
          "description": " Validate ARP requests. Send unknown and LXC endpoint ARP requests to linux kernel stack.  Send response for all other ARP requests. ",
          "author": "Yihe Bi",
          "authorEmail": "ybi@bu.edu",
          "date": "2023-02-24"
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "is_esp": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 401,
      "endLine": 428,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_overlay.c",
      "funcName": "is_esp",
      "developer_inline_comments": [
        {
          "start_line": 398,
          "end_line": 398,
          "text": "/* ENABLE_IPV4 */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " __u16 proto"
      ],
      "output": "static__always_inlinebool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline bool is_esp (struct  __ctx_buff *ctx, __u16 proto)\n",
        "{\n",
        "    void *data, *data_end;\n",
        "    __u8 protocol = 0;\n",
        "    struct ipv6hdr * ip6 __maybe_unused;\n",
        "    struct iphdr * ip4 __maybe_unused;\n",
        "    switch (proto) {\n",
        "\n",
        "#ifdef ENABLE_IPV6\n",
        "    case bpf_htons (ETH_P_IPV6) :\n",
        "        if (!revalidate_data_pull (ctx, &data, &data_end, &ip6))\n",
        "            return false;\n",
        "        protocol = ip6->nexthdr;\n",
        "        break;\n",
        "\n",
        "#endif\n",
        "\n",
        "#ifdef ENABLE_IPV4\n",
        "    case bpf_htons (ETH_P_IP) :\n",
        "        if (!revalidate_data_pull (ctx, &data, &data_end, &ip4))\n",
        "            return false;\n",
        "        protocol = ip4->protocol;\n",
        "        break;\n",
        "\n",
        "#endif\n",
        "    default :\n",
        "        return false;\n",
        "    }\n",
        "    return protocol == IPPROTO_ESP;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": " The built in function to check if esp protocol is used and if pulling data have error. ",
          "author": "Yichen Wang",
          "authorEmail": "wyichen@bu.edu",
          "date": "2023-02-24"
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "from_overlay": [
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 435,
      "endLine": 527,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_overlay.c",
      "funcName": "from_overlay",
      "developer_inline_comments": [
        {
          "start_line": 431,
          "end_line": 433,
          "text": "/* Attached to the ingress of cilium_vxlan/cilium_geneve to execute on packets\n * entering the node via the tunnel.\n */"
        },
        {
          "start_line": 444,
          "end_line": 444,
          "text": "/* Pass unknown traffic to the stack */"
        },
        {
          "start_line": 449,
          "end_line": 468,
          "text": "/* We need to handle following possible packets come to this program\n *\n * 1. ESP packets coming from overlay (encrypted and not marked)\n * 2. Non-ESP packets coming from overlay (plain and not marked)\n * 3. Non-ESP packets coming from stack re-inserted by xfrm (plain\n *    and marked with MARK_MAGIC_DECRYPT and has an identity as\n *    well, IPSec mode only)\n *\n * 1. will be traced with TRACE_REASON_ENCRYPTED\n * 2. will be traced without TRACE_REASON_ENCRYPTED\n * 3. will be traced without TRACE_REASON_ENCRYPTED, and with identity\n *\n * Note that 1. contains the ESP packets someone else generated.\n * In that case, we trace it as \"encrypted\", but it doesn't mean\n * \"encrypted by Cilium\".\n *\n * When IPSec is disabled, we won't use TRACE_REASON_ENCRYPTED even\n * if the packets are ESP, because it doesn't matter for the\n * non-IPSec mode.\n */"
        },
        {
          "start_line": 480,
          "end_line": 482,
          "text": "/* Non-ESP packet marked with MARK_MAGIC_DECRYPT is a packet\n\t\t * re-inserted from the stack.\n\t\t */"
        },
        {
          "start_line": 520,
          "end_line": 520,
          "text": "/* Pass unknown traffic to the stack */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "int",
      "helper": [
        "CTX_ACT_OK"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "int from_overlay (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    __u16 proto;\n",
        "    int ret;\n",
        "    bpf_clear_meta (ctx);\n",
        "    bpf_skip_nodeport_clear (ctx);\n",
        "    if (!validate_ethertype (ctx, &proto)) {\n",
        "        ret = CTX_ACT_OK;\n",
        "        goto out;\n",
        "    }\n",
        "\n",
        "#ifdef ENABLE_IPSEC\n",
        "    if (is_esp (ctx, proto))\n",
        "        send_trace_notify (ctx, TRACE_FROM_OVERLAY, 0, 0, 0, ctx->ingress_ifindex, TRACE_REASON_ENCRYPTED, TRACE_PAYLOAD_LEN);\n",
        "    else\n",
        "\n",
        "#endif\n",
        "        {\n",
        "            __u32 identity = 0;\n",
        "            enum trace_point obs_point = TRACE_FROM_OVERLAY;\n",
        "            if ((ctx->mark & MARK_MAGIC_HOST_MASK) == MARK_MAGIC_DECRYPT) {\n",
        "                identity = get_identity (ctx);\n",
        "                obs_point = TRACE_FROM_STACK;\n",
        "            }\n",
        "            send_trace_notify (ctx, obs_point, identity, 0, 0, ctx->ingress_ifindex, TRACE_REASON_UNKNOWN, TRACE_PAYLOAD_LEN);\n",
        "        }\n",
        "    switch (proto) {\n",
        "    case bpf_htons (ETH_P_IPV6) :\n",
        "\n",
        "#ifdef ENABLE_IPV6\n",
        "        ep_tail_call (ctx, CILIUM_CALL_IPV6_FROM_OVERLAY);\n",
        "        ret = DROP_MISSED_TAIL_CALL;\n",
        "\n",
        "#else\n",
        "        ret = DROP_UNKNOWN_L3;\n",
        "\n",
        "#endif\n",
        "        break;\n",
        "    case bpf_htons (ETH_P_IP) :\n",
        "\n",
        "#ifdef ENABLE_IPV4\n",
        "        ep_tail_call (ctx, CILIUM_CALL_IPV4_FROM_OVERLAY);\n",
        "        ret = DROP_MISSED_TAIL_CALL;\n",
        "\n",
        "#else\n",
        "        ret = DROP_UNKNOWN_L3;\n",
        "\n",
        "#endif\n",
        "        break;\n",
        "\n",
        "#ifdef ENABLE_VTEP\n",
        "    case bpf_htons (ETH_P_ARP) :\n",
        "        ep_tail_call (ctx, CILIUM_CALL_ARP);\n",
        "        ret = DROP_MISSED_TAIL_CALL;\n",
        "        break;\n",
        "\n",
        "#endif\n",
        "    default :\n",
        "        ret = CTX_ACT_OK;\n",
        "    }\n",
        "out :\n",
        "    if (IS_ERR (ret))\n",
        "        return send_drop_notify_error (ctx, 0, ret, CTX_ACT_DROP, METRIC_INGRESS);\n",
        "    return ret;\n",
        "}\n"
      ],
      "called_function_list": [
        "bpf_clear_meta",
        "bpf_skip_nodeport_clear",
        "get_identity",
        "ep_tail_call",
        "send_trace_notify",
        "validate_ethertype",
        "is_esp"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        {
          "description": " handle different possible packets come to the program. First check if it is esp protocol, then check the decrypted or not and get the identity from the metadata.  ",
          "author": "Yichen Wang",
          "authorEmail": "wyichen@bu.edu",
          "date": "2023-02-24"
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "to_overlay": [
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 533,
      "endLine": 568,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_overlay.c",
      "funcName": "to_overlay",
      "developer_inline_comments": [
        {
          "start_line": 529,
          "end_line": 531,
          "text": "/* Attached to the egress of cilium_vxlan/cilium_geneve to execute on packets\n * leaving the node via the tunnel.\n */"
        },
        {
          "start_line": 542,
          "end_line": 547,
          "text": "/* In tunneling mode, we should do this as close as possible to the\n\t * phys dev where FQ runs, but the issue is that the aggregate state\n\t * (in queue_mapping) is overridden on tunnel xmit. Hence set the\n\t * timestamp already here. The tunnel dev has noqueue qdisc, so as\n\t * tradeoff it's close enough.\n\t */"
        },
        {
          "start_line": 549,
          "end_line": 549,
          "text": "/* No send_drop_notify_error() here given we're rate-limiting. */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "int",
      "helper": [
        "CTX_ACT_OK"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "int to_overlay (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    int ret;\n",
        "    ret = encap_remap_v6_host_address (ctx, true);\n",
        "    if (unlikely (ret < 0))\n",
        "        goto out;\n",
        "\n",
        "#ifdef ENABLE_BANDWIDTH_MANAGER\n",
        "    ret = edt_sched_departure (ctx);\n",
        "    if (ret == CTX_ACT_DROP) {\n",
        "        update_metrics (ctx_full_len (ctx), METRIC_EGRESS, -DROP_EDT_HORIZON);\n",
        "        return CTX_ACT_DROP;\n",
        "    }\n",
        "\n",
        "#endif\n",
        "\n",
        "#ifdef ENABLE_NODEPORT\n",
        "    if ((ctx->mark & MARK_MAGIC_SNAT_DONE) == MARK_MAGIC_SNAT_DONE) {\n",
        "        ret = CTX_ACT_OK;\n",
        "        goto out;\n",
        "    }\n",
        "    ret = handle_nat_fwd (ctx);\n",
        "\n",
        "#endif\n",
        "out :\n",
        "    if (IS_ERR (ret))\n",
        "        return send_drop_notify_error (ctx, 0, ret, CTX_ACT_DROP, METRIC_EGRESS);\n",
        "    return ret;\n",
        "}\n"
      ],
      "called_function_list": [
        "handle_nat_fwd",
        "edt_sched_departure",
        "ctx_full_len",
        "encap_remap_v6_host_address",
        "update_metrics"
      ],
      "call_depth": 4,
      "humanFuncDescription": [
        {
          "description": " TO BE ADDED  ",
          "author": "Yichen Wang",
          "authorEmail": "wyichen@bu.edu",
          "date": "2023-02-24"
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "redirect_to_proxy": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 157,
      "endLine": 162,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_lxc.c",
      "funcName": "redirect_to_proxy",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": "// SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)"
        },
        {
          "start_line": 2,
          "end_line": 2,
          "text": "/* Copyright Authors of Cilium */"
        },
        {
          "start_line": 14,
          "end_line": 15,
          "text": "/* Controls the inclusion of the CILIUM_CALL_SRV6 section in the object file.\n */"
        },
        {
          "start_line": 37,
          "end_line": 40,
          "text": "/* Override LB_SELECTION initially defined in node_config.h to force bpf_lxc to use the random backend selection\n * algorithm for in-cluster traffic. Otherwise, it will fail with the Maglev hash algorithm because Cilium doesn't provision\n * the Maglev table for ClusterIP unless bpf.lbExternalClusterIP is set to true.\n */"
        },
        {
          "start_line": 57,
          "end_line": 60,
          "text": "/* Per-packet LB is needed if all LB cases can not be handled in bpf_sock.\n * Most services with L7 LB flag can not be redirected to their proxy port\n * in bpf_sock, so we must check for those via per packet LB as well.\n */"
        },
        {
          "start_line": 71,
          "end_line": 76,
          "text": "/* Before upstream commit d71962f3e627 (4.18), map helpers were not\n * allowed to access map values directly. So for those older kernels,\n * we need to copy the data to the stack first.\n * We don't have a probe for that, but the bpf_fib_lookup helper was\n * introduced in the same release.\n */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "int verdict",
        " enum ct_status status"
      ],
      "output": "static__always_inlinebool",
      "helper": [
        "redirect"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp",
        "lwt_xmit"
      ],
      "source": [
        "static __always_inline bool redirect_to_proxy (int verdict, enum ct_status status)\n",
        "{\n",
        "    return is_defined (ENABLE_HOST_REDIRECT) && verdict > 0 && (status == CT_NEW || status == CT_ESTABLISHED || status == CT_REOPENED);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": " check if the proxy is able to be redirected, and redirect the proxy, store in status. Return true if successful. ",
          "author": "Yihe Bi",
          "authorEmail": "ybi@bu.edu",
          "date": "2023-02-24"
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 50,
      "endLine": 53,
      "File": "/home/sayandes/opened_extraction/examples/cilium/sockops/bpf_sockops.c",
      "funcName": "redirect_to_proxy",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "int verdict"
      ],
      "output": "static__always_inlinebool",
      "helper": [
        "redirect"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp",
        "lwt_xmit"
      ],
      "source": [
        "static __always_inline bool redirect_to_proxy (int verdict)\n",
        "{\n",
        "    return verdict > 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": " check if verdict is larger than 0  ",
          "author": "Shun Zhang",
          "authorEmail": "shunz@bu.edu",
          "date": "2023-02-24"
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "encode_custom_prog_meta": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 174,
      "endLine": 189,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_lxc.c",
      "funcName": "encode_custom_prog_meta",
      "developer_inline_comments": [
        {
          "start_line": 166,
          "end_line": 173,
          "text": "/* Encode return value and identity into cb buffer. This is used before\n * executing tail calls to custom programs. \"ret\" is the return value supposed\n * to be returned to the kernel, needed by the callee to preserve the datapath\n * logics. The \"identity\" is the security identity of the local endpoint: the\n * source of the packet on ingress path, or its destination on the egress path.\n * We encode it so that custom programs can retrieve it and use it at their\n * convenience.\n */"
        },
        {
          "start_line": 179,
          "end_line": 182,
          "text": "/* If we cannot encode return value on 8 bits, return an error so we can\n\t * skip the tail call entirely, as custom program has no way to return\n\t * expected value and datapath logics will break.\n\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " int ret",
        " __u32 identity"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int encode_custom_prog_meta (struct  __ctx_buff *ctx, int ret, __u32 identity)\n",
        "{\n",
        "    __u32 custom_meta = 0;\n",
        "    if ((ret & 0xff) != ret)\n",
        "        return -1;\n",
        "    custom_meta |= (__u32) (ret & 0xff) << 24;\n",
        "    custom_meta |= (identity & 0xffffff);\n",
        "    ctx_store_meta (ctx, CB_CUSTOM_CALLS, custom_meta);\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_store_meta"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": " encode meta data (return value and identity), and store it into ctx buffer ",
          "author": "Yihe Bi",
          "authorEmail": "ybi@bu.edu",
          "date": "2023-02-24"
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "handle_ipv6_from_lxc": [
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        },
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 214,
      "endLine": 581,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_lxc.c",
      "funcName": "handle_ipv6_from_lxc",
      "developer_inline_comments": [
        {
          "start_line": 207,
          "end_line": 213,
          "text": "/* Handle egress IPv6 traffic from a container after service translation has been done\n * either at the socket level or by the caller.\n * In the case of the caller doing the service translation it passes in state via CB,\n * which we take in with lb6_ctx_restore_state().\n *\n * Kernel 4.9 verifier is very finicky about the order of this code, modify with caution.\n */"
        },
        {
          "start_line": 232,
          "end_line": 232,
          "text": "/* endpoint wants to access itself via service IP */"
        },
        {
          "start_line": 243,
          "end_line": 247,
          "text": "/* Determine the destination category for policy fallback.  Service\n\t * translation of the destination address is done before this function,\n\t * so we can do this first. Also, verifier on kernel 4.9 insisted this\n\t * be done before the CT lookup below.\n\t */"
        },
        {
          "start_line": 261,
          "end_line": 261,
          "text": "/* ENABLE_WIREGUARD */"
        },
        {
          "start_line": 271,
          "end_line": 271,
          "text": "/* verifier workaround on kernel 4.9, not needed otherwise */"
        },
        {
          "start_line": 275,
          "end_line": 275,
          "text": "/* Restore ct_state from per packet lb handling in the previous tail call. */"
        },
        {
          "start_line": 277,
          "end_line": 277,
          "text": "/* No hairpin/loopback support for IPv6, see lb6_local(). */"
        },
        {
          "start_line": 278,
          "end_line": 278,
          "text": "/* ENABLE_PER_PACKET_LB */"
        },
        {
          "start_line": 284,
          "end_line": 284,
          "text": "/* The map value is zeroed so the map update didn't happen somehow. */"
        },
        {
          "start_line": 295,
          "end_line": 295,
          "text": "/* HAVE_DIRECT_ACCESS_TO_MAP_VALUES */"
        },
        {
          "start_line": 303,
          "end_line": 303,
          "text": "/* tuple addresses have been swapped by CT lookup */"
        },
        {
          "start_line": 310,
          "end_line": 310,
          "text": "/* ENABLE_L7_LB */"
        },
        {
          "start_line": 312,
          "end_line": 312,
          "text": "/* Check it this is return traffic to an ingress proxy. */"
        },
        {
          "start_line": 315,
          "end_line": 315,
          "text": "/* Stack will do a socket match and deliver locally. */"
        },
        {
          "start_line": 319,
          "end_line": 324,
          "text": "/* When an endpoint connects to itself via service clusterIP, we need\n\t * to skip the policy enforcement. If we didn't, the user would have to\n\t * define policy rules to allow pods to talk to themselves. We still\n\t * want to execute the conntrack logic so that replies can be correctly\n\t * matched.\n\t */"
        },
        {
          "start_line": 330,
          "end_line": 333,
          "text": "/* If the packet is in the establishing direction and it's destined\n\t * within the cluster, it must match policy or be dropped. If it's\n\t * bound for the host/outside, perform the CIDR policy check.\n\t */"
        },
        {
          "start_line": 355,
          "end_line": 359,
          "text": "/* New connection implies that rev_nat_index remains untouched\n\t\t * to the index provided by the loadbalancer (if it applied).\n\t\t * Create a CT entry which allows to track replies and to\n\t\t * reverse NAT.\n\t\t */"
        },
        {
          "start_line": 374,
          "end_line": 374,
          "text": "/* Did we end up at a stale non-service entry? Recreate if so. */"
        },
        {
          "start_line": 396,
          "end_line": 396,
          "text": "/* ENABLE_DSR */"
        },
        {
          "start_line": 397,
          "end_line": 397,
          "text": "/* See comment in handle_ipv4_from_lxc(). */"
        },
        {
          "start_line": 406,
          "end_line": 406,
          "text": "/* ENABLE_NODEPORT */"
        },
        {
          "start_line": 417,
          "end_line": 420,
          "text": "/* A reverse translate packet is always allowed except\n\t\t\t * for delivery on the local node in which case this\n\t\t\t * marking is cleared again.\n\t\t\t */"
        },
        {
          "start_line": 431,
          "end_line": 433,
          "text": "/* L7 LB does L7 policy enforcement, so we only redirect packets\n\t * NOT from L7 LB.\n\t */"
        },
        {
          "start_line": 436,
          "end_line": 436,
          "text": "/* Trace the packet before it is forwarded to proxy */"
        },
        {
          "start_line": 446,
          "end_line": 446,
          "text": "/* See handle_ipv4_from_lxc() re hairpin_flow */"
        },
        {
          "start_line": 450,
          "end_line": 455,
          "text": "/* Lookup IPv6 address, this will return a match if:\n\t\t *  - The destination IP address belongs to a local endpoint managed by\n\t\t *    cilium\n\t\t *  - The destination IP address is an IP address associated with the\n\t\t *    host itself.\n\t\t */"
        },
        {
          "start_line": 466,
          "end_line": 466,
          "text": "/* ENABLE_ROUTING */"
        },
        {
          "start_line": 468,
          "end_line": 468,
          "text": "/* If the packet is from L7 LB it is coming from the host */"
        },
        {
          "start_line": 475,
          "end_line": 477,
          "text": "/* If the destination is the local host and per-endpoint routes are\n\t * enabled, jump to the bpf_host program to enforce ingress host policies.\n\t */"
        },
        {
          "start_line": 483,
          "end_line": 483,
          "text": "/* ENABLE_HOST_FIREWALL && !ENABLE_ROUTING */"
        },
        {
          "start_line": 485,
          "end_line": 485,
          "text": "/* The packet goes to a peer not managed by this agent instance */"
        },
        {
          "start_line": 489,
          "end_line": 489,
          "text": "/* ENABLE_WIREGUARD */"
        },
        {
          "start_line": 494,
          "end_line": 500,
          "text": "/* Lookup the destination prefix in the list of known\n\t\t * destination prefixes. If there is a match, the packet will\n\t\t * be encapsulated to that node and then routed by the agent on\n\t\t * the remote node.\n\t\t *\n\t\t * IPv6 lookup key: daddr/96\n\t\t */"
        },
        {
          "start_line": 506,
          "end_line": 510,
          "text": "/* Three cases exist here either (a) the encap and redirect could\n\t\t * not find the tunnel so fallthrough to nat46 and stack, (b)\n\t\t * the packet needs IPSec encap so push ctx to stack for encap, or\n\t\t * (c) packet was redirected to tunnel device so return.\n\t\t */"
        },
        {
          "start_line": 553,
          "end_line": 553,
          "text": "/* IP_POOLS */"
        },
        {
          "start_line": 556,
          "end_line": 556,
          "text": "/* ENABLE_IDENTITY_MARK */"
        },
        {
          "start_line": 558,
          "end_line": 558,
          "text": "/* ENABLE_IPSEC */"
        },
        {
          "start_line": 559,
          "end_line": 559,
          "text": "/* ENABLE_WIREGUARD */"
        },
        {
          "start_line": 562,
          "end_line": 566,
          "text": "/* Always encode the source identity when passing to the stack.\n\t\t * If the stack hairpins the packet back to a local endpoint the\n\t\t * source identity can still be derived even if SNAT is\n\t\t * performed by a component such as portmap.\n\t\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [
        "  CT_TAIL_CALL_BUFFER6"
      ],
      "input": [
        "struct  __ctx_buff *ctx",
        " __u32 *dst_id"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "redirect",
        "tail_call",
        "CTX_ACT_OK",
        "map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "static __always_inline int handle_ipv6_from_lxc (struct  __ctx_buff *ctx, __u32 *dst_id)\n",
        "{\n",
        "    struct ct_state ct_state_on_stack __maybe_unused, *ct_state, ct_state_new = {};\n",
        "    struct ipv6_ct_tuple tuple_on_stack __maybe_unused, *tuple;\n",
        "\n",
        "#ifdef ENABLE_ROUTING\n",
        "    union macaddr router_mac = NODE_MAC;\n",
        "\n",
        "#endif\n",
        "    struct ct_buffer6 *ct_buffer;\n",
        "    void *data, *data_end;\n",
        "    struct ipv6hdr *ip6;\n",
        "    int ret, verdict = 0, l4_off, hdrlen, zero = 0;\n",
        "    struct trace_ctx trace = {\n",
        "        .reason = TRACE_REASON_UNKNOWN,\n",
        "        .monitor = 0,}\n",
        "    ;\n",
        "    __u32 __maybe_unused tunnel_endpoint = 0;\n",
        "    __u8 __maybe_unused encrypt_key = 0;\n",
        "    enum ct_status ct_status;\n",
        "    bool hairpin_flow = false;\n",
        "    __u8 policy_match_type = POLICY_MATCH_NONE;\n",
        "    __u8 audited = 0;\n",
        "    bool __maybe_unused dst_remote_ep = false;\n",
        "    __u16 proxy_port = 0;\n",
        "    bool from_l7lb = false;\n",
        "    bool emit_policy_verdict = true;\n",
        "    if (!revalidate_data (ctx, &data, &data_end, &ip6))\n",
        "        return DROP_INVALID;\n",
        "    if (1) {\n",
        "        const union v6addr *daddr = (union v6addr *) &ip6->daddr;\n",
        "        struct remote_endpoint_info *info;\n",
        "        info = lookup_ip6_remote_endpoint (daddr);\n",
        "        if (info && info->sec_label) {\n",
        "            *dst_id = info->sec_label;\n",
        "            tunnel_endpoint = info->tunnel_endpoint;\n",
        "            encrypt_key = get_min_encrypt_key (info -> key);\n",
        "\n",
        "#ifdef ENABLE_WIREGUARD\n",
        "            if (info->tunnel_endpoint != 0 && !identity_is_node (info->sec_label))\n",
        "                dst_remote_ep = true;\n",
        "\n",
        "#endif /* ENABLE_WIREGUARD */\n",
        "        }\n",
        "        else {\n",
        "            *dst_id = WORLD_ID;\n",
        "        }\n",
        "        cilium_dbg (ctx, info ? DBG_IP_ID_MAP_SUCCEED6 : DBG_IP_ID_MAP_FAILED6, daddr->p4, *dst_id);\n",
        "    }\n",
        "\n",
        "#ifdef ENABLE_PER_PACKET_LB\n",
        "\n",
        "#if !defined(DEBUG) && defined(TUNNEL_MODE)\n",
        "    if (!revalidate_data (ctx, &data, &data_end, &ip6))\n",
        "        return DROP_INVALID;\n",
        "\n",
        "#endif\n",
        "    lb6_ctx_restore_state (ctx, &ct_state_new, &proxy_port);\n",
        "\n",
        "#endif /* ENABLE_PER_PACKET_LB */\n",
        "    ct_buffer = map_lookup_elem (& CT_TAIL_CALL_BUFFER6, & zero);\n",
        "    if (!ct_buffer)\n",
        "        return DROP_INVALID_TC_BUFFER;\n",
        "    if (ct_buffer->tuple.saddr.d1 == 0 && ct_buffer->tuple.saddr.d2 == 0)\n",
        "        return DROP_INVALID_TC_BUFFER;\n",
        "\n",
        "#if HAVE_DIRECT_ACCESS_TO_MAP_VALUES\n",
        "    tuple = (struct ipv6_ct_tuple *) &ct_buffer->tuple;\n",
        "    ct_state = (struct ct_state *) &ct_buffer->ct_state;\n",
        "\n",
        "#else\n",
        "    memcpy (&tuple_on_stack, &ct_buffer->tuple, sizeof (tuple_on_stack));\n",
        "    tuple = &tuple_on_stack;\n",
        "    memcpy (&ct_state_on_stack, &ct_buffer->ct_state, sizeof (ct_state_on_stack));\n",
        "    ct_state = &ct_state_on_stack;\n",
        "\n",
        "#endif /* HAVE_DIRECT_ACCESS_TO_MAP_VALUES */\n",
        "    trace.monitor = ct_buffer->monitor;\n",
        "    ret = ct_buffer->ret;\n",
        "    ct_status = (enum ct_status) ret;\n",
        "    trace.reason = (enum trace_reason) ret;\n",
        "\n",
        "#if defined(ENABLE_L7_LB)\n",
        "    if (proxy_port > 0) {\n",
        "        cilium_dbg3 (ctx, DBG_L7_LB, tuple->daddr.p4, tuple->saddr.p4, bpf_ntohs (proxy_port));\n",
        "        verdict = proxy_port;\n",
        "        emit_policy_verdict = false;\n",
        "        goto skip_policy_enforcement;\n",
        "    }\n",
        "\n",
        "#endif /* ENABLE_L7_LB */\n",
        "    if ((ct_status == CT_REPLY || ct_status == CT_RELATED) && ct_state->proxy_redirect) {\n",
        "        return ctx_redirect_to_proxy6 (ctx, tuple, 0, false);\n",
        "    }\n",
        "    if (hairpin_flow) {\n",
        "        emit_policy_verdict = false;\n",
        "        goto skip_policy_enforcement;\n",
        "    }\n",
        "    verdict = policy_can_egress6 (ctx, tuple, SECLABEL, * dst_id, & policy_match_type, & audited);\n",
        "    if (ct_status != CT_REPLY && ct_status != CT_RELATED && verdict < 0) {\n",
        "        send_policy_verdict_notify (ctx, *dst_id, tuple->dport, tuple->nexthdr, POLICY_EGRESS, 1, verdict, policy_match_type, audited);\n",
        "        return verdict;\n",
        "    }\n",
        "skip_policy_enforcement :\n",
        "\n",
        "#if defined(ENABLE_L7_LB)\n",
        "    from_l7lb = ctx_load_meta (ctx, CB_FROM_HOST) == FROM_HOST_L7_LB;\n",
        "\n",
        "#endif\n",
        "    switch (ct_status) {\n",
        "    case CT_NEW :\n",
        "        if (emit_policy_verdict)\n",
        "            send_policy_verdict_notify (ctx, *dst_id, tuple->dport, tuple->nexthdr, POLICY_EGRESS, 1, verdict, policy_match_type, audited);\n",
        "    ct_recreate6 :\n",
        "        ct_state_new.src_sec_id = SECLABEL;\n",
        "        ret = ct_create6 (get_ct_map6 (tuple), & CT_MAP_ANY6, tuple, ctx, CT_EGRESS, & ct_state_new, verdict > 0, from_l7lb);\n",
        "        if (IS_ERR (ret))\n",
        "            return ret;\n",
        "        trace.monitor = TRACE_PAYLOAD_LEN;\n",
        "        break;\n",
        "    case CT_REOPENED :\n",
        "        if (emit_policy_verdict)\n",
        "            send_policy_verdict_notify (ctx, *dst_id, tuple->dport, tuple->nexthdr, POLICY_EGRESS, 1, verdict, policy_match_type, audited);\n",
        "    case CT_ESTABLISHED :\n",
        "        if (unlikely (ct_state->rev_nat_index != ct_state_new.rev_nat_index))\n",
        "            goto ct_recreate6;\n",
        "        break;\n",
        "    case CT_RELATED :\n",
        "    case CT_REPLY :\n",
        "        policy_mark_skip (ctx);\n",
        "        hdrlen = ipv6_hdrlen (ctx, & tuple -> nexthdr);\n",
        "        if (hdrlen < 0)\n",
        "            return hdrlen;\n",
        "        l4_off = ETH_HLEN + hdrlen;\n",
        "\n",
        "#ifdef ENABLE_NODEPORT\n",
        "\n",
        "# ifdef ENABLE_DSR\n",
        "        if (ct_state->dsr) {\n",
        "            ret = xlate_dsr_v6 (ctx, tuple, l4_off);\n",
        "            if (ret != 0)\n",
        "                return ret;\n",
        "        }\n",
        "        else\n",
        "\n",
        "# endif /* ENABLE_DSR */\n",
        "            if (ct_state->node_port) {\n",
        "                send_trace_notify (ctx, TRACE_TO_NETWORK, SECLABEL, *dst_id, 0, 0, trace.reason, trace.monitor);\n",
        "                ctx->tc_index |= TC_INDEX_F_SKIP_RECIRCULATION;\n",
        "                ep_tail_call (ctx, CILIUM_CALL_IPV6_NODEPORT_REVNAT);\n",
        "                return DROP_MISSED_TAIL_CALL;\n",
        "            }\n",
        "\n",
        "#endif /* ENABLE_NODEPORT */\n",
        "        if (ct_state->rev_nat_index) {\n",
        "            struct csum_offset csum_off = {}\n",
        "            ;\n",
        "            csum_l4_offset_and_flags (tuple->nexthdr, &csum_off);\n",
        "            ret = lb6_rev_nat (ctx, l4_off, & csum_off, ct_state -> rev_nat_index, tuple, 0);\n",
        "            if (IS_ERR (ret))\n",
        "                return ret;\n",
        "            policy_mark_skip (ctx);\n",
        "        }\n",
        "        break;\n",
        "    default :\n",
        "        return DROP_UNKNOWN_CT;\n",
        "    }\n",
        "    hairpin_flow |= ct_state->loopback;\n",
        "    if (!from_l7lb && redirect_to_proxy (verdict, ct_status)) {\n",
        "        proxy_port = (__u16) verdict;\n",
        "        send_trace_notify (ctx, TRACE_TO_PROXY, SECLABEL, 0, bpf_ntohs (proxy_port), 0, trace.reason, trace.monitor);\n",
        "        return ctx_redirect_to_proxy6 (ctx, tuple, proxy_port, false);\n",
        "    }\n",
        "    if (!revalidate_data (ctx, &data, &data_end, &ip6))\n",
        "        return DROP_INVALID;\n",
        "    if (is_defined (ENABLE_ROUTING) || hairpin_flow) {\n",
        "        struct endpoint_info *ep;\n",
        "        ep = lookup_ip6_endpoint (ip6);\n",
        "        if (ep) {\n",
        "\n",
        "#ifdef ENABLE_ROUTING\n",
        "            if (ep->flags & ENDPOINT_F_HOST) {\n",
        "\n",
        "#ifdef HOST_IFINDEX\n",
        "                goto to_host;\n",
        "\n",
        "#else\n",
        "                return DROP_HOST_UNREACHABLE;\n",
        "\n",
        "#endif\n",
        "            }\n",
        "\n",
        "#endif /* ENABLE_ROUTING */\n",
        "            policy_clear_mark (ctx);\n",
        "            return ipv6_local_delivery (ctx, ETH_HLEN, SECLABEL, ep, METRIC_EGRESS, from_l7lb);\n",
        "        }\n",
        "    }\n",
        "\n",
        "#if defined(ENABLE_HOST_FIREWALL) && !defined(ENABLE_ROUTING)\n",
        "    if (*dst_id == HOST_ID) {\n",
        "        ctx_store_meta (ctx, CB_FROM_HOST, 0);\n",
        "        tail_call_static (ctx, &POLICY_CALL_MAP, HOST_EP_ID);\n",
        "        return DROP_MISSED_TAIL_CALL;\n",
        "    }\n",
        "\n",
        "#endif /* ENABLE_HOST_FIREWALL && !ENABLE_ROUTING */\n",
        "\n",
        "#ifdef TUNNEL_MODE\n",
        "\n",
        "# ifdef ENABLE_WIREGUARD\n",
        "    if (!dst_remote_ep)\n",
        "\n",
        "# endif /* ENABLE_WIREGUARD */\n",
        "        {\n",
        "            struct endpoint_key key = {}\n",
        "            ;\n",
        "            union v6addr *daddr = (union v6addr *) &ip6->daddr;\n",
        "            key.ip6.p1 = daddr->p1;\n",
        "            key.ip6.p2 = daddr->p2;\n",
        "            key.ip6.p3 = daddr->p3;\n",
        "            key.family = ENDPOINT_KEY_IPV6;\n",
        "            ret = encap_and_redirect_lxc (ctx, tunnel_endpoint, encrypt_key, & key, SECLABEL, & trace);\n",
        "            if (ret == IPSEC_ENDPOINT)\n",
        "                goto encrypt_to_stack;\n",
        "            else if (ret != DROP_NO_TUNNEL_ENDPOINT)\n",
        "                return ret;\n",
        "        }\n",
        "\n",
        "#endif\n",
        "    if (is_defined (ENABLE_HOST_ROUTING))\n",
        "        return redirect_direct_v6 (ctx, ETH_HLEN, ip6);\n",
        "    goto pass_to_stack;\n",
        "\n",
        "#ifdef ENABLE_ROUTING\n",
        "to_host :\n",
        "    if (is_defined (ENABLE_HOST_FIREWALL) && *dst_id == HOST_ID) {\n",
        "        send_trace_notify (ctx, TRACE_TO_HOST, SECLABEL, HOST_ID, 0, HOST_IFINDEX, trace.reason, trace.monitor);\n",
        "        return ctx_redirect (ctx, HOST_IFINDEX, BPF_F_INGRESS);\n",
        "    }\n",
        "\n",
        "#endif\n",
        "pass_to_stack :\n",
        "\n",
        "#ifdef ENABLE_ROUTING\n",
        "    ret = ipv6_l3 (ctx, ETH_HLEN, NULL, (__u8 *) & router_mac.addr, METRIC_EGRESS);\n",
        "    if (unlikely (ret != CTX_ACT_OK))\n",
        "        return ret;\n",
        "\n",
        "#endif\n",
        "    if (ipv6_store_flowlabel (ctx, ETH_HLEN, SECLABEL_NB) < 0)\n",
        "        return DROP_WRITE_ERROR;\n",
        "\n",
        "#ifdef ENABLE_WIREGUARD\n",
        "    if (dst_remote_ep)\n",
        "        set_encrypt_mark (ctx);\n",
        "    else\n",
        "\n",
        "#elif !defined(TUNNEL_MODE)\n",
        "\n",
        "# ifdef ENABLE_IPSEC\n",
        "        if (encrypt_key && tunnel_endpoint) {\n",
        "            set_encrypt_key_mark (ctx, encrypt_key);\n",
        "\n",
        "#  ifdef IP_POOLS\n",
        "            set_encrypt_dip (ctx, tunnel_endpoint);\n",
        "\n",
        "#  endif /* IP_POOLS */\n",
        "\n",
        "#  ifdef ENABLE_IDENTITY_MARK\n",
        "            set_identity_mark (ctx, SECLABEL);\n",
        "\n",
        "#  endif /* ENABLE_IDENTITY_MARK */\n",
        "        }\n",
        "        else\n",
        "\n",
        "# endif /* ENABLE_IPSEC */\n",
        "\n",
        "#endif /* ENABLE_WIREGUARD */\n",
        "            {\n",
        "\n",
        "#ifdef ENABLE_IDENTITY_MARK\n",
        "                ctx->mark |= MARK_MAGIC_IDENTITY;\n",
        "                set_identity_mark (ctx, SECLABEL);\n",
        "\n",
        "#endif\n",
        "            }\n",
        "\n",
        "#ifdef TUNNEL_MODE\n",
        "encrypt_to_stack :\n",
        "\n",
        "#endif\n",
        "    send_trace_notify (ctx, TRACE_TO_STACK, SECLABEL, *dst_id, 0, 0, trace.reason, trace.monitor);\n",
        "    cilium_dbg_capture (ctx, DBG_CAPTURE_DELIVERY, 0);\n",
        "    return CTX_ACT_OK;\n",
        "}\n"
      ],
      "called_function_list": [
        "ipv6_local_delivery",
        "ipv6_l3",
        "identity_is_node",
        "ipv6_store_flowlabel",
        "set_encrypt_key_mark",
        "set_encrypt_mark",
        "cilium_dbg",
        "xlate_dsr_v6",
        "set_identity_mark",
        "ctx_store_meta",
        "send_policy_verdict_notify",
        "cilium_dbg_capture",
        "lb6_ctx_restore_state",
        "tail_call_static",
        "lb6_rev_nat",
        "ctx_redirect",
        "encap_and_redirect_lxc",
        "ctx_redirect_to_proxy6",
        "ipv6_hdrlen",
        "policy_can_egress6",
        "policy_mark_skip",
        "ep_tail_call",
        "send_trace_notify",
        "ct_create6",
        "get_ct_map6",
        "get_min_encrypt_key",
        "set_encrypt_dip",
        "memcpy",
        "redirect_direct_v6",
        "cilium_dbg3",
        "redirect_to_proxy",
        "lookup_ip6_endpoint",
        "policy_clear_mark",
        "ctx_load_meta",
        "csum_l4_offset_and_flags"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        {
          "description": " Handling egress ipv6 traffic by  a) lookup the destination_id. For encrypted and tunneled traffic b) tunnel endpoint, and c) encryption key as well. Also mark the traffic if it has a remote endpoint destination. Restore ct_state from per packet lb handling in the previous tail call. Enable the per pecket load balancer, swap the address by CT_lookup and establish the connection. ",
          "author": "Yihe Bi",
          "authorEmail": "ybi@bu.edu",
          "date": "2023-02-24"
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "tail_handle_ipv6_cont": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 584,
      "endLine": 603,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_lxc.c",
      "funcName": "tail_handle_ipv6_cont",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "int",
      "helper": [
        "tail_call"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "int tail_handle_ipv6_cont (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    __u32 dst_id = 0;\n",
        "    int ret = handle_ipv6_from_lxc (ctx, & dst_id);\n",
        "    if (IS_ERR (ret))\n",
        "        return send_drop_notify (ctx, SECLABEL, dst_id, 0, ret, CTX_ACT_DROP, METRIC_EGRESS);\n",
        "\n",
        "#ifdef ENABLE_CUSTOM_CALLS\n",
        "    if (!encode_custom_prog_meta (ctx, ret, dst_id)) {\n",
        "        tail_call_static (ctx, &CUSTOM_CALLS_MAP, CUSTOM_CALLS_IDX_IPV6_EGRESS);\n",
        "        update_metrics (ctx_full_len (ctx), METRIC_EGRESS, REASON_MISSED_CUSTOM_CALL);\n",
        "    }\n",
        "\n",
        "#endif\n",
        "    return ret;\n",
        "}\n"
      ],
      "called_function_list": [
        "encode_custom_prog_meta",
        "tail_call_static",
        "handle_ipv6_from_lxc",
        "ctx_full_len",
        "update_metrics"
      ],
      "call_depth": 4,
      "humanFuncDescription": [
        {
          "description": " Count ipv6 tail calls ",
          "author": "Yihe Bi",
          "authorEmail": "ybi@bu.edu",
          "date": "2023-02-24"
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__tail_handle_ipv6": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 609,
      "endLine": 694,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_lxc.c",
      "funcName": "__tail_handle_ipv6",
      "developer_inline_comments": [
        {
          "start_line": 618,
          "end_line": 621,
          "text": "/* Handle special ICMPv6 messages. This includes echo requests to the\n\t * logical router address, neighbour advertisements to the router.\n\t * All remaining packets are subjected to forwarding into the container.\n\t */"
        },
        {
          "start_line": 663,
          "end_line": 669,
          "text": "/*\n\t\t * Check if the destination address is among the address that should\n\t\t * be load balanced. This operation is performed before we go through\n\t\t * the connection tracker to allow storing the reverse nat index in\n\t\t * the CT entry for destination endpoints where we can't encode the\n\t\t * state in the address.\n\t\t */"
        },
        {
          "start_line": 677,
          "end_line": 677,
          "text": "/* ENABLE_L7_LB */"
        },
        {
          "start_line": 686,
          "end_line": 686,
          "text": "/* Store state to be picked up on the continuation tail call. */"
        },
        {
          "start_line": 689,
          "end_line": 689,
          "text": "/* ENABLE_PER_PACKET_LB */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int __tail_handle_ipv6 (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    void *data, *data_end;\n",
        "    struct ipv6hdr *ip6;\n",
        "    int ret;\n",
        "    if (!revalidate_data_pull (ctx, &data, &data_end, &ip6))\n",
        "        return DROP_INVALID;\n",
        "    if (unlikely (ip6->nexthdr == IPPROTO_ICMPV6)) {\n",
        "        if (data + sizeof (*ip6) + ETH_HLEN + sizeof (struct icmp6hdr) > data_end)\n",
        "            return DROP_INVALID;\n",
        "        ret = icmp6_handle (ctx, ETH_HLEN, ip6, METRIC_EGRESS);\n",
        "        if (IS_ERR (ret))\n",
        "            return ret;\n",
        "    }\n",
        "    if (unlikely (!is_valid_lxc_src_ip (ip6)))\n",
        "        return DROP_INVALID_SIP;\n",
        "\n",
        "#ifdef ENABLE_PER_PACKET_LB\n",
        "    {\n",
        "        struct ipv6_ct_tuple tuple = {}\n",
        "        ;\n",
        "        struct csum_offset csum_off = {}\n",
        "        ;\n",
        "        struct ct_state ct_state_new = {}\n",
        "        ;\n",
        "        struct lb6_service *svc;\n",
        "        struct lb6_key key = {}\n",
        "        ;\n",
        "        __u16 proxy_port = 0;\n",
        "        int l4_off, hdrlen;\n",
        "        tuple.nexthdr = ip6->nexthdr;\n",
        "        ipv6_addr_copy (&tuple.daddr, (union v6addr *) &ip6->daddr);\n",
        "        ipv6_addr_copy (&tuple.saddr, (union v6addr *) &ip6->saddr);\n",
        "        hdrlen = ipv6_hdrlen (ctx, & tuple.nexthdr);\n",
        "        if (hdrlen < 0)\n",
        "            return hdrlen;\n",
        "        l4_off = ETH_HLEN + hdrlen;\n",
        "        ret = lb6_extract_key (ctx, & tuple, l4_off, & key, & csum_off, CT_EGRESS);\n",
        "        if (IS_ERR (ret)) {\n",
        "            if (ret == DROP_NO_SERVICE || ret == DROP_UNKNOWN_L4)\n",
        "                goto skip_service_lookup;\n",
        "            else\n",
        "                return ret;\n",
        "        }\n",
        "        svc = lb6_lookup_service (& key, is_defined (ENABLE_NODEPORT));\n",
        "        if (svc) {\n",
        "\n",
        "#if defined(ENABLE_L7_LB)\n",
        "            if (lb6_svc_is_l7loadbalancer (svc)) {\n",
        "                proxy_port = (__u16) svc->l7_lb_proxy_port;\n",
        "                goto skip_service_lookup;\n",
        "            }\n",
        "\n",
        "#endif /* ENABLE_L7_LB */\n",
        "            ret = lb6_local (get_ct_map6 (& tuple), ctx, ETH_HLEN, l4_off, & csum_off, & key, & tuple, svc, & ct_state_new, false);\n",
        "            if (IS_ERR (ret))\n",
        "                return ret;\n",
        "        }\n",
        "    skip_service_lookup :\n",
        "        lb6_ctx_store_state (ctx, &ct_state_new, proxy_port);\n",
        "    }\n",
        "\n",
        "#endif /* ENABLE_PER_PACKET_LB */\n",
        "    invoke_tailcall_if (is_defined (ENABLE_PER_PACKET_LB), CILIUM_CALL_IPV6_CT_EGRESS, tail_ipv6_ct_egress);\n",
        "    return ret;\n",
        "}\n"
      ],
      "called_function_list": [
        "get_ct_map6",
        "ipv6_hdrlen",
        "lb6_extract_key",
        "lb6_lookup_service",
        "lb6_local",
        "is_valid_lxc_src_ip",
        "icmp6_handle",
        "lb6_ctx_store_state",
        "lb6_svc_is_l7loadbalancer",
        "ipv6_addr_copy"
      ],
      "call_depth": 7,
      "humanFuncDescription": [
        {
          "description": " Handle tail messages. Check if it is not special ICMPv6 messages such as echo requests, neighbour advertisement, then check if the destination address is among the address that should be  load balanced. Then store information to ctx for continuous tail call. ",
          "author": "Yihe Bi",
          "authorEmail": "ybi@bu.edu",
          "date": "2023-02-24"
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "handle_ipv4_from_lxc": [
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        },
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 728,
      "endLine": 1157,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_lxc.c",
      "funcName": "handle_ipv4_from_lxc",
      "developer_inline_comments": [
        {
          "start_line": 723,
          "end_line": 727,
          "text": "/* Handle egress IPv6 traffic from a container after service translation has been done\n * either at the socket level or by the caller.\n * In the case of the caller doing the service translation it passes in state via CB,\n * which we take in with lb4_ctx_restore_state().\n */"
        },
        {
          "start_line": 744,
          "end_line": 744,
          "text": "/* endpoint wants to access itself via service IP */"
        },
        {
          "start_line": 760,
          "end_line": 760,
          "text": "/* Determine the destination category for policy fallback. */"
        },
        {
          "start_line": 770,
          "end_line": 775,
          "text": "/* If we detect that the dst is a remote endpoint, we\n\t\t\t * need to mark the packet. The ip rule which matches\n\t\t\t * on the MARK_MAGIC_ENCRYPT mark will steer the packet\n\t\t\t * to the Wireguard tunnel. The marking happens lower\n\t\t\t * in the code in the same place where we handle IPSec.\n\t\t\t */"
        },
        {
          "start_line": 779,
          "end_line": 779,
          "text": "/* ENABLE_WIREGUARD */"
        },
        {
          "start_line": 789,
          "end_line": 789,
          "text": "/* Restore ct_state from per packet lb handling in the previous tail call. */"
        },
        {
          "start_line": 792,
          "end_line": 792,
          "text": "/* ENABLE_PER_PACKET_LB */"
        },
        {
          "start_line": 800,
          "end_line": 800,
          "text": "/* The map value is zeroed so the map update didn't happen somehow. */"
        },
        {
          "start_line": 811,
          "end_line": 811,
          "text": "/* HAVE_DIRECT_ACCESS_TO_MAP_VALUES */"
        },
        {
          "start_line": 819,
          "end_line": 819,
          "text": "/* tuple addresses have been swapped by CT lookup */"
        },
        {
          "start_line": 825,
          "end_line": 825,
          "text": "/* ENABLE_L7_LB */"
        },
        {
          "start_line": 827,
          "end_line": 827,
          "text": "/* Check it this is return traffic to an ingress proxy. */"
        },
        {
          "start_line": 829,
          "end_line": 829,
          "text": "/* Stack will do a socket match and deliver locally. */"
        },
        {
          "start_line": 833,
          "end_line": 838,
          "text": "/* When an endpoint connects to itself via service clusterIP, we need\n\t * to skip the policy enforcement. If we didn't, the user would have to\n\t * define policy rules to allow pods to talk to themselves. We still\n\t * want to execute the conntrack logic so that replies can be correctly\n\t * matched.\n\t */"
        },
        {
          "start_line": 844,
          "end_line": 847,
          "text": "/* If the packet is in the establishing direction and it's destined\n\t * within the cluster, it must match policy or be dropped. If it's\n\t * bound for the host/outside, perform the CIDR policy check.\n\t */"
        },
        {
          "start_line": 869,
          "end_line": 873,
          "text": "/* New connection implies that rev_nat_index remains untouched\n\t\t * to the index provided by the loadbalancer (if it applied).\n\t\t * Create a CT entry which allows to track replies and to\n\t\t * reverse NAT.\n\t\t */"
        },
        {
          "start_line": 875,
          "end_line": 877,
          "text": "/* We could avoid creating related entries for legacy ClusterIP\n\t\t * handling here, but turns out that verifier cannot handle it.\n\t\t */"
        },
        {
          "start_line": 890,
          "end_line": 890,
          "text": "/* Did we end up at a stale non-service entry? Recreate if so. */"
        },
        {
          "start_line": 906,
          "end_line": 906,
          "text": "/* ENABLE_DSR */"
        },
        {
          "start_line": 907,
          "end_line": 910,
          "text": "/* This handles reply traffic for the case where the nodeport EP\n\t\t * is local to the node. We'll do the tail call to perform\n\t\t * the reverse DNAT.\n\t\t */"
        },
        {
          "start_line": 920,
          "end_line": 920,
          "text": "/* ENABLE_NODEPORT */"
        },
        {
          "start_line": 939,
          "end_line": 941,
          "text": "/* L7 LB does L7 policy enforcement, so we only redirect packets\n\t * NOT from L7 LB.\n\t */"
        },
        {
          "start_line": 944,
          "end_line": 944,
          "text": "/* Trace the packet before it is forwarded to proxy */"
        },
        {
          "start_line": 951,
          "end_line": 951,
          "text": "/* After L4 write in port mapping: revalidate for direct packet access */"
        },
        {
          "start_line": 955,
          "end_line": 959,
          "text": "/* Allow a hairpin packet to be redirected even if ENABLE_ROUTING is\n\t * disabled. Otherwise, the packet will be dropped by the kernel if\n\t * it is going to be routed via an interface it came from after it has\n\t * been passed to the stack.\n\t */"
        },
        {
          "start_line": 963,
          "end_line": 969,
          "text": "/* Lookup IPv4 address, this will return a match if:\n\t\t *  - The destination IP address belongs to a local endpoint\n\t\t *    managed by cilium\n\t\t *  - The destination IP address is an IP address associated with the\n\t\t *    host itself\n\t\t *  - The destination IP address belongs to endpoint itself.\n\t\t */"
        },
        {
          "start_line": 980,
          "end_line": 980,
          "text": "/* ENABLE_ROUTING */"
        },
        {
          "start_line": 982,
          "end_line": 982,
          "text": "/* If the packet is from L7 LB it is coming from the host */"
        },
        {
          "start_line": 989,
          "end_line": 991,
          "text": "/* If the destination is the local host and per-endpoint routes are\n\t * enabled, jump to the bpf_host program to enforce ingress host policies.\n\t */"
        },
        {
          "start_line": 997,
          "end_line": 997,
          "text": "/* ENABLE_HOST_FIREWALL && !ENABLE_ROUTING */"
        },
        {
          "start_line": 1005,
          "end_line": 1009,
          "text": "/* If the packet is destined to an entity inside the cluster,\n\t\t * either EP or node, it should not be forwarded to an egress\n\t\t * gateway since only traffic leaving the cluster is supposed to\n\t\t * be masqueraded with an egress IP.\n\t\t */"
        },
        {
          "start_line": 1013,
          "end_line": 1017,
          "text": "/* If the packet is a reply or is related, it means that outside\n\t\t * has initiated the connection, and so we should skip egress\n\t\t * gateway, since an egress policy is only matching connections\n\t\t * originating from a pod.\n\t\t */"
        },
        {
          "start_line": 1025,
          "end_line": 1028,
          "text": "/* If the gateway node is the local node, then just let the\n\t\t * packet go through, as it will be SNATed later on by\n\t\t * handle_nat_fwd().\n\t\t */"
        },
        {
          "start_line": 1033,
          "end_line": 1035,
          "text": "/* Otherwise encap and redirect the packet to egress gateway\n\t\t * node through a tunnel.\n\t\t */"
        },
        {
          "start_line": 1046,
          "end_line": 1050,
          "text": "/* L7 proxy result in VTEP redirection in bpf_host, but when L7 proxy disabled\n\t * We want VTEP redirection handled earlier here to avoid packets passing to\n\t * stack to bpf_host for VTEP redirection. When L7 proxy enabled, but no\n\t * L7 policy applied to pod, VTEP redirection also happen here.\n\t */"
        },
        {
          "start_line": 1073,
          "end_line": 1075,
          "text": "/* In the tunnel mode we encapsulate pod2pod traffic only via Wireguard\n\t * device, i.e. we do not encapsulate twice.\n\t */"
        },
        {
          "start_line": 1077,
          "end_line": 1077,
          "text": "/* ENABLE_WIREGUARD */"
        },
        {
          "start_line": 1088,
          "end_line": 1090,
          "text": "/* If not redirected noteably due to IPSEC then pass up to stack\n\t\t * for further processing.\n\t\t */"
        },
        {
          "start_line": 1093,
          "end_line": 1095,
          "text": "/* This is either redirect by encap code or an error has\n\t\t * occurred either way return and stack will consume ctx.\n\t\t */"
        },
        {
          "start_line": 1099,
          "end_line": 1099,
          "text": "/* TUNNEL_MODE */"
        },
        {
          "start_line": 1124,
          "end_line": 1124,
          "text": "/* Wireguard and identity mark are mutually exclusive */"
        },
        {
          "start_line": 1131,
          "end_line": 1131,
          "text": "/* IP_POOLS */"
        },
        {
          "start_line": 1136,
          "end_line": 1136,
          "text": "/* ENABLE_IPSEC */"
        },
        {
          "start_line": 1137,
          "end_line": 1137,
          "text": "/* ENABLE_WIREGUARD */"
        },
        {
          "start_line": 1140,
          "end_line": 1144,
          "text": "/* Always encode the source identity when passing to the stack.\n\t\t * If the stack hairpins the packet back to a local endpoint the\n\t\t * source identity can still be derived even if SNAT is\n\t\t * performed by a component such as portmap.\n\t\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [
        "  VTEP_MAP",
        "  CT_TAIL_CALL_BUFFER4"
      ],
      "input": [
        "struct  __ctx_buff *ctx",
        " __u32 *dst_id"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "redirect",
        "tail_call",
        "CTX_ACT_OK",
        "map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "static __always_inline int handle_ipv4_from_lxc (struct  __ctx_buff *ctx, __u32 *dst_id)\n",
        "{\n",
        "    struct ct_state ct_state_on_stack __maybe_unused, *ct_state, ct_state_new = {};\n",
        "    struct ipv4_ct_tuple tuple_on_stack __maybe_unused, *tuple;\n",
        "\n",
        "#ifdef ENABLE_ROUTING\n",
        "    union macaddr router_mac = NODE_MAC;\n",
        "\n",
        "#endif\n",
        "    void *data, *data_end;\n",
        "    struct iphdr *ip4;\n",
        "    int ret, verdict = 0, l4_off;\n",
        "    struct trace_ctx trace = {\n",
        "        .reason = TRACE_REASON_UNKNOWN,\n",
        "        .monitor = 0,}\n",
        "    ;\n",
        "    __u32 __maybe_unused tunnel_endpoint = 0, zero = 0;\n",
        "    __u8 __maybe_unused encrypt_key = 0;\n",
        "    bool hairpin_flow = false;\n",
        "    __u8 policy_match_type = POLICY_MATCH_NONE;\n",
        "    struct ct_buffer4 *ct_buffer;\n",
        "    __u8 audited = 0;\n",
        "    bool has_l4_header = false;\n",
        "    bool __maybe_unused dst_remote_ep = false;\n",
        "    enum ct_status ct_status;\n",
        "    __u16 proxy_port = 0;\n",
        "    bool from_l7lb = false;\n",
        "    bool emit_policy_verdict = true;\n",
        "    if (!revalidate_data (ctx, &data, &data_end, &ip4))\n",
        "        return DROP_INVALID;\n",
        "    has_l4_header = ipv4_has_l4_header (ip4);\n",
        "    if (1) {\n",
        "        struct remote_endpoint_info *info;\n",
        "        info = lookup_ip4_remote_endpoint (ip4 -> daddr);\n",
        "        if (info && info->sec_label) {\n",
        "            *dst_id = info->sec_label;\n",
        "            tunnel_endpoint = info->tunnel_endpoint;\n",
        "            encrypt_key = get_min_encrypt_key (info -> key);\n",
        "\n",
        "#ifdef ENABLE_WIREGUARD\n",
        "            if (info->tunnel_endpoint != 0 && !identity_is_node (info->sec_label))\n",
        "                dst_remote_ep = true;\n",
        "\n",
        "#endif /* ENABLE_WIREGUARD */\n",
        "        }\n",
        "        else {\n",
        "            *dst_id = WORLD_ID;\n",
        "        }\n",
        "        cilium_dbg (ctx, info ? DBG_IP_ID_MAP_SUCCEED4 : DBG_IP_ID_MAP_FAILED4, ip4->daddr, *dst_id);\n",
        "    }\n",
        "\n",
        "#ifdef ENABLE_PER_PACKET_LB\n",
        "    lb4_ctx_restore_state (ctx, &ct_state_new, ip4->daddr, &proxy_port);\n",
        "    hairpin_flow = ct_state_new.loopback;\n",
        "\n",
        "#endif /* ENABLE_PER_PACKET_LB */\n",
        "    l4_off = ETH_HLEN + ipv4_hdrlen (ip4);\n",
        "    ct_buffer = map_lookup_elem (& CT_TAIL_CALL_BUFFER4, & zero);\n",
        "    if (!ct_buffer)\n",
        "        return DROP_INVALID_TC_BUFFER;\n",
        "    if (ct_buffer->tuple.saddr == 0)\n",
        "        return DROP_INVALID_TC_BUFFER;\n",
        "\n",
        "#if HAVE_DIRECT_ACCESS_TO_MAP_VALUES\n",
        "    tuple = (struct ipv4_ct_tuple *) &ct_buffer->tuple;\n",
        "    ct_state = (struct ct_state *) &ct_buffer->ct_state;\n",
        "\n",
        "#else\n",
        "    memcpy (&tuple_on_stack, &ct_buffer->tuple, sizeof (tuple_on_stack));\n",
        "    tuple = &tuple_on_stack;\n",
        "    memcpy (&ct_state_on_stack, &ct_buffer->ct_state, sizeof (ct_state_on_stack));\n",
        "    ct_state = &ct_state_on_stack;\n",
        "\n",
        "#endif /* HAVE_DIRECT_ACCESS_TO_MAP_VALUES */\n",
        "    trace.monitor = ct_buffer->monitor;\n",
        "    ret = ct_buffer->ret;\n",
        "    ct_status = (enum ct_status) ret;\n",
        "    trace.reason = (enum trace_reason) ret;\n",
        "\n",
        "#if defined(ENABLE_L7_LB)\n",
        "    if (proxy_port > 0) {\n",
        "        cilium_dbg3 (ctx, DBG_L7_LB, tuple->daddr, tuple->saddr, bpf_ntohs (proxy_port));\n",
        "        verdict = proxy_port;\n",
        "        emit_policy_verdict = false;\n",
        "        goto skip_policy_enforcement;\n",
        "    }\n",
        "\n",
        "#endif /* ENABLE_L7_LB */\n",
        "    if ((ct_status == CT_REPLY || ct_status == CT_RELATED) && ct_state->proxy_redirect) {\n",
        "        return ctx_redirect_to_proxy4 (ctx, tuple, 0, false);\n",
        "    }\n",
        "    if (hairpin_flow) {\n",
        "        emit_policy_verdict = false;\n",
        "        goto skip_policy_enforcement;\n",
        "    }\n",
        "    verdict = policy_can_egress4 (ctx, tuple, SECLABEL, * dst_id, & policy_match_type, & audited);\n",
        "    if (ct_status != CT_REPLY && ct_status != CT_RELATED && verdict < 0) {\n",
        "        send_policy_verdict_notify (ctx, *dst_id, tuple->dport, tuple->nexthdr, POLICY_EGRESS, 0, verdict, policy_match_type, audited);\n",
        "        return verdict;\n",
        "    }\n",
        "skip_policy_enforcement :\n",
        "\n",
        "#if defined(ENABLE_L7_LB)\n",
        "    from_l7lb = ctx_load_meta (ctx, CB_FROM_HOST) == FROM_HOST_L7_LB;\n",
        "\n",
        "#endif\n",
        "    switch (ct_status) {\n",
        "    case CT_NEW :\n",
        "        if (emit_policy_verdict)\n",
        "            send_policy_verdict_notify (ctx, *dst_id, tuple->dport, tuple->nexthdr, POLICY_EGRESS, 0, verdict, policy_match_type, audited);\n",
        "    ct_recreate4 :\n",
        "        ct_state_new.src_sec_id = SECLABEL;\n",
        "        ret = ct_create4 (get_ct_map4 (tuple), & CT_MAP_ANY4, tuple, ctx, CT_EGRESS, & ct_state_new, verdict > 0, from_l7lb);\n",
        "        if (IS_ERR (ret))\n",
        "            return ret;\n",
        "        break;\n",
        "    case CT_REOPENED :\n",
        "        if (emit_policy_verdict)\n",
        "            send_policy_verdict_notify (ctx, *dst_id, tuple->dport, tuple->nexthdr, POLICY_EGRESS, 0, verdict, policy_match_type, audited);\n",
        "    case CT_ESTABLISHED :\n",
        "        if (unlikely (ct_state->rev_nat_index != ct_state_new.rev_nat_index))\n",
        "            goto ct_recreate4;\n",
        "        break;\n",
        "    case CT_RELATED :\n",
        "    case CT_REPLY :\n",
        "        policy_mark_skip (ctx);\n",
        "\n",
        "#ifdef ENABLE_NODEPORT\n",
        "\n",
        "# ifdef ENABLE_DSR\n",
        "        if (ct_state->dsr) {\n",
        "            ret = xlate_dsr_v4 (ctx, tuple, l4_off, has_l4_header);\n",
        "            if (ret != 0)\n",
        "                return ret;\n",
        "        }\n",
        "        else\n",
        "\n",
        "# endif /* ENABLE_DSR */\n",
        "            if (ct_state->node_port) {\n",
        "                send_trace_notify (ctx, TRACE_TO_NETWORK, SECLABEL, *dst_id, 0, 0, trace.reason, trace.monitor);\n",
        "                ctx->tc_index |= TC_INDEX_F_SKIP_RECIRCULATION;\n",
        "                ep_tail_call (ctx, CILIUM_CALL_IPV4_NODEPORT_REVNAT);\n",
        "                return DROP_MISSED_TAIL_CALL;\n",
        "            }\n",
        "\n",
        "#endif /* ENABLE_NODEPORT */\n",
        "        if (ct_state->rev_nat_index) {\n",
        "            struct csum_offset csum_off = {}\n",
        "            ;\n",
        "            csum_l4_offset_and_flags (tuple->nexthdr, &csum_off);\n",
        "            ret = lb4_rev_nat (ctx, ETH_HLEN, l4_off, & csum_off, ct_state, tuple, 0, has_l4_header);\n",
        "            if (IS_ERR (ret))\n",
        "                return ret;\n",
        "        }\n",
        "        break;\n",
        "    default :\n",
        "        return DROP_UNKNOWN_CT;\n",
        "    }\n",
        "    hairpin_flow |= ct_state->loopback;\n",
        "    if (!from_l7lb && redirect_to_proxy (verdict, ct_status)) {\n",
        "        proxy_port = (__u16) verdict;\n",
        "        send_trace_notify (ctx, TRACE_TO_PROXY, SECLABEL, 0, bpf_ntohs (proxy_port), 0, trace.reason, trace.monitor);\n",
        "        return ctx_redirect_to_proxy4 (ctx, tuple, proxy_port, false);\n",
        "    }\n",
        "    if (!revalidate_data (ctx, &data, &data_end, &ip4))\n",
        "        return DROP_INVALID;\n",
        "    if (is_defined (ENABLE_ROUTING) || hairpin_flow) {\n",
        "        struct endpoint_info *ep;\n",
        "        ep = lookup_ip4_endpoint (ip4);\n",
        "        if (ep) {\n",
        "\n",
        "#ifdef ENABLE_ROUTING\n",
        "            if (ep->flags & ENDPOINT_F_HOST) {\n",
        "\n",
        "#ifdef HOST_IFINDEX\n",
        "                goto to_host;\n",
        "\n",
        "#else\n",
        "                return DROP_HOST_UNREACHABLE;\n",
        "\n",
        "#endif\n",
        "            }\n",
        "\n",
        "#endif /* ENABLE_ROUTING */\n",
        "            policy_clear_mark (ctx);\n",
        "            return ipv4_local_delivery (ctx, ETH_HLEN, SECLABEL, ip4, ep, METRIC_EGRESS, from_l7lb);\n",
        "        }\n",
        "    }\n",
        "\n",
        "#if defined(ENABLE_HOST_FIREWALL) && !defined(ENABLE_ROUTING)\n",
        "    if (*dst_id == HOST_ID) {\n",
        "        ctx_store_meta (ctx, CB_FROM_HOST, 0);\n",
        "        tail_call_static (ctx, &POLICY_CALL_MAP, HOST_EP_ID);\n",
        "        return DROP_MISSED_TAIL_CALL;\n",
        "    }\n",
        "\n",
        "#endif /* ENABLE_HOST_FIREWALL && !ENABLE_ROUTING */\n",
        "\n",
        "#ifdef ENABLE_EGRESS_GATEWAY\n",
        "    {\n",
        "        struct egress_gw_policy_entry *egress_gw_policy;\n",
        "        struct endpoint_info *gateway_node_ep;\n",
        "        struct endpoint_key key = {}\n",
        "        ;\n",
        "        if (identity_is_cluster (*dst_id))\n",
        "            goto skip_egress_gateway;\n",
        "        if (ct_status == CT_REPLY || ct_status == CT_RELATED)\n",
        "            goto skip_egress_gateway;\n",
        "        egress_gw_policy = lookup_ip4_egress_gw_policy (ip4 -> saddr, ip4 -> daddr);\n",
        "        if (!egress_gw_policy)\n",
        "            goto skip_egress_gateway;\n",
        "        gateway_node_ep = __lookup_ip4_endpoint (egress_gw_policy -> gateway_ip);\n",
        "        if (gateway_node_ep && (gateway_node_ep->flags & ENDPOINT_F_HOST))\n",
        "            goto skip_egress_gateway;\n",
        "        ret = encap_and_redirect_lxc (ctx, egress_gw_policy -> gateway_ip, encrypt_key, & key, SECLABEL, & trace);\n",
        "        if (ret == IPSEC_ENDPOINT)\n",
        "            goto encrypt_to_stack;\n",
        "        else\n",
        "            return ret;\n",
        "    }\n",
        "skip_egress_gateway :\n",
        "\n",
        "#endif\n",
        "\n",
        "#if defined(ENABLE_VTEP)\n",
        "    {\n",
        "        struct vtep_key vkey = {}\n",
        "        ;\n",
        "        struct vtep_value *vtep;\n",
        "        vkey.vtep_ip = ip4->daddr & VTEP_MASK;\n",
        "        vtep = map_lookup_elem (& VTEP_MAP, & vkey);\n",
        "        if (!vtep)\n",
        "            goto skip_vtep;\n",
        "        if (vtep->vtep_mac && vtep->tunnel_endpoint) {\n",
        "            if (eth_store_daddr (ctx, (__u8 *) &vtep->vtep_mac, 0) < 0)\n",
        "                return DROP_WRITE_ERROR;\n",
        "            return __encap_and_redirect_with_nodeid (ctx, vtep->tunnel_endpoint, SECLABEL, WORLD_ID, &trace);\n",
        "        }\n",
        "    }\n",
        "skip_vtep :\n",
        "\n",
        "#endif\n",
        "\n",
        "#ifdef TUNNEL_MODE\n",
        "\n",
        "# ifdef ENABLE_WIREGUARD\n",
        "    if (!dst_remote_ep)\n",
        "\n",
        "# endif /* ENABLE_WIREGUARD */\n",
        "        {\n",
        "            struct endpoint_key key = {}\n",
        "            ;\n",
        "            key.ip4 = ip4->daddr & IPV4_MASK;\n",
        "            key.family = ENDPOINT_KEY_IPV4;\n",
        "            ret = encap_and_redirect_lxc (ctx, tunnel_endpoint, encrypt_key, & key, SECLABEL, & trace);\n",
        "            if (ret == DROP_NO_TUNNEL_ENDPOINT)\n",
        "                goto pass_to_stack;\n",
        "            else if (ret == IPSEC_ENDPOINT)\n",
        "                goto encrypt_to_stack;\n",
        "            else\n",
        "                return ret;\n",
        "        }\n",
        "\n",
        "#endif /* TUNNEL_MODE */\n",
        "    if (is_defined (ENABLE_HOST_ROUTING))\n",
        "        return redirect_direct_v4 (ctx, ETH_HLEN, ip4);\n",
        "    goto pass_to_stack;\n",
        "\n",
        "#ifdef ENABLE_ROUTING\n",
        "to_host :\n",
        "    if (is_defined (ENABLE_HOST_FIREWALL) && *dst_id == HOST_ID) {\n",
        "        send_trace_notify (ctx, TRACE_TO_HOST, SECLABEL, HOST_ID, 0, HOST_IFINDEX, trace.reason, trace.monitor);\n",
        "        return ctx_redirect (ctx, HOST_IFINDEX, BPF_F_INGRESS);\n",
        "    }\n",
        "\n",
        "#endif\n",
        "pass_to_stack :\n",
        "\n",
        "#ifdef ENABLE_ROUTING\n",
        "    ret = ipv4_l3 (ctx, ETH_HLEN, NULL, (__u8 *) & router_mac.addr, ip4);\n",
        "    if (unlikely (ret != CTX_ACT_OK))\n",
        "        return ret;\n",
        "\n",
        "#endif\n",
        "\n",
        "#ifdef ENABLE_WIREGUARD\n",
        "    if (dst_remote_ep)\n",
        "        set_encrypt_mark (ctx);\n",
        "    else\n",
        "\n",
        "#elif !defined(TUNNEL_MODE)\n",
        "\n",
        "# ifdef ENABLE_IPSEC\n",
        "        if (encrypt_key && tunnel_endpoint) {\n",
        "            set_encrypt_key_mark (ctx, encrypt_key);\n",
        "\n",
        "#  ifdef IP_POOLS\n",
        "            set_encrypt_dip (ctx, tunnel_endpoint);\n",
        "\n",
        "#  endif /* IP_POOLS */\n",
        "\n",
        "#  ifdef ENABLE_IDENTITY_MARK\n",
        "            set_identity_mark (ctx, SECLABEL);\n",
        "\n",
        "#  endif\n",
        "        }\n",
        "        else\n",
        "\n",
        "# endif /* ENABLE_IPSEC */\n",
        "\n",
        "#endif /* ENABLE_WIREGUARD */\n",
        "            {\n",
        "\n",
        "#ifdef ENABLE_IDENTITY_MARK\n",
        "                ctx->mark |= MARK_MAGIC_IDENTITY;\n",
        "                set_identity_mark (ctx, SECLABEL);\n",
        "\n",
        "#endif\n",
        "            }\n",
        "\n",
        "#if defined(TUNNEL_MODE) || defined(ENABLE_EGRESS_GATEWAY)\n",
        "encrypt_to_stack :\n",
        "\n",
        "#endif\n",
        "    send_trace_notify (ctx, TRACE_TO_STACK, SECLABEL, *dst_id, 0, 0, trace.reason, trace.monitor);\n",
        "    cilium_dbg_capture (ctx, DBG_CAPTURE_DELIVERY, 0);\n",
        "    return CTX_ACT_OK;\n",
        "}\n"
      ],
      "called_function_list": [
        "identity_is_node",
        "ipv4_local_delivery",
        "ipv4_l3",
        "policy_can_egress4",
        "xlate_dsr_v4",
        "set_encrypt_key_mark",
        "set_encrypt_mark",
        "cilium_dbg",
        "set_identity_mark",
        "ctx_store_meta",
        "send_policy_verdict_notify",
        "ipv4_hdrlen",
        "cilium_dbg_capture",
        "tail_call_static",
        "identity_is_cluster",
        "ctx_redirect",
        "encap_and_redirect_lxc",
        "lb4_ctx_restore_state",
        "redirect_direct_v4",
        "ipv4_has_l4_header",
        "policy_mark_skip",
        "ct_create4",
        "ep_tail_call",
        "__lookup_ip4_endpoint",
        "eth_store_daddr",
        "send_trace_notify",
        "ctx_redirect_to_proxy4",
        "get_min_encrypt_key",
        "set_encrypt_dip",
        "memcpy",
        "cilium_dbg3",
        "lookup_ip4_egress_gw_policy",
        "redirect_to_proxy",
        "get_ct_map4",
        "lb4_rev_nat",
        "lookup_ip4_endpoint",
        "policy_clear_mark",
        "ctx_load_meta",
        "__encap_and_redirect_with_nodeid",
        "csum_l4_offset_and_flags"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        {
          "description": " Handling egress ipv4 traffic. Mark the traffic if it has a remote endpoint destination. Restore ct_state from per packet lb handling in the previous tail call. Enable the per pecket load balancer, swap the address by CT_lookup and establish the connection. ",
          "author": "Yihe Bi",
          "authorEmail": "ybi@bu.edu",
          "date": "2023-02-24"
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "tail_handle_ipv4_cont": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1160,
      "endLine": 1179,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_lxc.c",
      "funcName": "tail_handle_ipv4_cont",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "int",
      "helper": [
        "tail_call"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "int tail_handle_ipv4_cont (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    __u32 dst_id = 0;\n",
        "    int ret = handle_ipv4_from_lxc (ctx, & dst_id);\n",
        "    if (IS_ERR (ret))\n",
        "        return send_drop_notify (ctx, SECLABEL, dst_id, 0, ret, CTX_ACT_DROP, METRIC_EGRESS);\n",
        "\n",
        "#ifdef ENABLE_CUSTOM_CALLS\n",
        "    if (!encode_custom_prog_meta (ctx, ret, dst_id)) {\n",
        "        tail_call_static (ctx, &CUSTOM_CALLS_MAP, CUSTOM_CALLS_IDX_IPV4_EGRESS);\n",
        "        update_metrics (ctx_full_len (ctx), METRIC_EGRESS, REASON_MISSED_CUSTOM_CALL);\n",
        "    }\n",
        "\n",
        "#endif\n",
        "    return ret;\n",
        "}\n"
      ],
      "called_function_list": [
        "tail_call_static",
        "handle_ipv4_from_lxc",
        "encode_custom_prog_meta",
        "ctx_full_len",
        "update_metrics"
      ],
      "call_depth": 4,
      "humanFuncDescription": [
        {
          "description": " Count ipv4 tail call. Helper function for handling ipv4 traffic ",
          "author": "Yihe Bi",
          "authorEmail": "ybi@bu.edu",
          "date": "2023-02-24"
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__tail_handle_ipv4": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1185,
      "endLine": 1256,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_lxc.c",
      "funcName": "__tail_handle_ipv4",
      "developer_inline_comments": [
        {
          "start_line": 1194,
          "end_line": 1197,
          "text": "/* If IPv4 fragmentation is disabled\n * AND a IPv4 fragmented packet is received,\n * then drop the packet.\n */"
        },
        {
          "start_line": 1240,
          "end_line": 1240,
          "text": "/* ENABLE_L7_LB */"
        },
        {
          "start_line": 1248,
          "end_line": 1248,
          "text": "/* Store state to be picked up on the continuation tail call. */"
        },
        {
          "start_line": 1251,
          "end_line": 1251,
          "text": "/* ENABLE_PER_PACKET_LB */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int __tail_handle_ipv4 (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    void *data, *data_end;\n",
        "    struct iphdr *ip4;\n",
        "    int ret;\n",
        "    if (!revalidate_data_pull (ctx, &data, &data_end, &ip4))\n",
        "        return DROP_INVALID;\n",
        "\n",
        "#ifndef ENABLE_IPV4_FRAGMENTS\n",
        "    if (ipv4_is_fragment (ip4))\n",
        "        return DROP_FRAG_NOSUPPORT;\n",
        "\n",
        "#endif\n",
        "    if (unlikely (!is_valid_lxc_src_ipv4 (ip4)))\n",
        "        return DROP_INVALID_SIP;\n",
        "\n",
        "#ifdef ENABLE_PER_PACKET_LB\n",
        "    {\n",
        "        struct ipv4_ct_tuple tuple = {}\n",
        "        ;\n",
        "        struct csum_offset csum_off = {}\n",
        "        ;\n",
        "        struct ct_state ct_state_new = {}\n",
        "        ;\n",
        "        bool has_l4_header;\n",
        "        struct lb4_service *svc;\n",
        "        struct lb4_key key = {}\n",
        "        ;\n",
        "        __u16 proxy_port = 0;\n",
        "        int l4_off;\n",
        "        has_l4_header = ipv4_has_l4_header (ip4);\n",
        "        tuple.nexthdr = ip4->protocol;\n",
        "        tuple.daddr = ip4->daddr;\n",
        "        tuple.saddr = ip4->saddr;\n",
        "        l4_off = ETH_HLEN + ipv4_hdrlen (ip4);\n",
        "        ret = lb4_extract_key (ctx, ip4, l4_off, & key, & csum_off, CT_EGRESS);\n",
        "        if (IS_ERR (ret)) {\n",
        "            if (ret == DROP_NO_SERVICE || ret == DROP_UNKNOWN_L4)\n",
        "                goto skip_service_lookup;\n",
        "            else\n",
        "                return ret;\n",
        "        }\n",
        "        svc = lb4_lookup_service (& key, is_defined (ENABLE_NODEPORT));\n",
        "        if (svc) {\n",
        "\n",
        "#if defined(ENABLE_L7_LB)\n",
        "            if (lb4_svc_is_l7loadbalancer (svc)) {\n",
        "                proxy_port = (__u16) svc->l7_lb_proxy_port;\n",
        "                goto skip_service_lookup;\n",
        "            }\n",
        "\n",
        "#endif /* ENABLE_L7_LB */\n",
        "            ret = lb4_local (get_ct_map4 (& tuple), ctx, ETH_HLEN, l4_off, & csum_off, & key, & tuple, svc, & ct_state_new, ip4 -> saddr, has_l4_header, false);\n",
        "            if (IS_ERR (ret))\n",
        "                return ret;\n",
        "        }\n",
        "    skip_service_lookup :\n",
        "        lb4_ctx_store_state (ctx, &ct_state_new, proxy_port);\n",
        "    }\n",
        "\n",
        "#endif /* ENABLE_PER_PACKET_LB */\n",
        "    invoke_tailcall_if (is_defined (ENABLE_PER_PACKET_LB), CILIUM_CALL_IPV4_CT_EGRESS, tail_ipv4_ct_egress);\n",
        "    return ret;\n",
        "}\n"
      ],
      "called_function_list": [
        "lb4_local",
        "lb4_ctx_store_state",
        "ipv4_has_l4_header",
        "ipv4_hdrlen",
        "lb4_extract_key",
        "lb4_svc_is_l7loadbalancer",
        "get_ct_map4",
        "lb4_lookup_service",
        "ipv4_is_fragment",
        "is_valid_lxc_src_ipv4"
      ],
      "call_depth": 4,
      "humanFuncDescription": [
        {
          "description": " helper function to handle ipv4 tail call ",
          "author": "Yihe Bi",
          "authorEmail": "ybi@bu.edu",
          "date": "2023-02-24"
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "handle_xgress": [
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 1308,
      "endLine": 1358,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_lxc.c",
      "funcName": "handle_xgress",
      "developer_inline_comments": [
        {
          "start_line": 1302,
          "end_line": 1302,
          "text": "/* ENABLE_IPV4 */"
        },
        {
          "start_line": 1304,
          "end_line": 1306,
          "text": "/* Attachment/entry point is ingress for veth, egress for ipvlan.\n * It corresponds to packets leaving the container.\n */"
        },
        {
          "start_line": 1331,
          "end_line": 1331,
          "text": "/* ENABLE_IPV6 */"
        },
        {
          "start_line": 1347,
          "end_line": 1347,
          "text": "/* ENABLE_ARP_RESPONDER */"
        },
        {
          "start_line": 1348,
          "end_line": 1348,
          "text": "/* ENABLE_IPV4 */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "int",
      "helper": [
        "CTX_ACT_OK"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "int handle_xgress (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    __u16 proto;\n",
        "    int ret;\n",
        "    bpf_clear_meta (ctx);\n",
        "    reset_queue_mapping (ctx);\n",
        "    send_trace_notify (ctx, TRACE_FROM_LXC, SECLABEL, 0, 0, 0, TRACE_REASON_UNKNOWN, TRACE_PAYLOAD_LEN);\n",
        "    if (!validate_ethertype (ctx, &proto)) {\n",
        "        ret = DROP_UNSUPPORTED_L2;\n",
        "        goto out;\n",
        "    }\n",
        "    switch (proto) {\n",
        "\n",
        "#ifdef ENABLE_IPV6\n",
        "    case bpf_htons (ETH_P_IPV6) :\n",
        "        edt_set_aggregate (ctx, LXC_ID);\n",
        "        ep_tail_call (ctx, CILIUM_CALL_IPV6_FROM_LXC);\n",
        "        ret = DROP_MISSED_TAIL_CALL;\n",
        "        break;\n",
        "\n",
        "#endif /* ENABLE_IPV6 */\n",
        "\n",
        "#ifdef ENABLE_IPV4\n",
        "    case bpf_htons (ETH_P_IP) :\n",
        "        edt_set_aggregate (ctx, LXC_ID);\n",
        "        ep_tail_call (ctx, CILIUM_CALL_IPV4_FROM_LXC);\n",
        "        ret = DROP_MISSED_TAIL_CALL;\n",
        "        break;\n",
        "\n",
        "#ifdef ENABLE_ARP_PASSTHROUGH\n",
        "    case bpf_htons (ETH_P_ARP) :\n",
        "        ret = CTX_ACT_OK;\n",
        "        break;\n",
        "\n",
        "#elif defined(ENABLE_ARP_RESPONDER)\n",
        "    case bpf_htons (ETH_P_ARP) :\n",
        "        ep_tail_call (ctx, CILIUM_CALL_ARP);\n",
        "        ret = DROP_MISSED_TAIL_CALL;\n",
        "        break;\n",
        "\n",
        "#endif /* ENABLE_ARP_RESPONDER */\n",
        "\n",
        "#endif /* ENABLE_IPV4 */\n",
        "    default :\n",
        "        ret = DROP_UNKNOWN_L3;\n",
        "    }\n",
        "out :\n",
        "    if (IS_ERR (ret))\n",
        "        return send_drop_notify (ctx, SECLABEL, 0, 0, ret, CTX_ACT_DROP, METRIC_EGRESS);\n",
        "    return ret;\n",
        "}\n"
      ],
      "called_function_list": [
        "edt_set_aggregate",
        "bpf_clear_meta",
        "ep_tail_call",
        "send_trace_notify",
        "validate_ethertype",
        "reset_queue_mapping"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        {
          "description": " Use previous exgress ipv6/v4 traffic handler to handle exgress traffic. ",
          "author": "Yihe Bi",
          "authorEmail": "ybi@bu.edu",
          "date": "2023-02-24"
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ipv6_policy": [
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        },
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 1361,
      "endLine": 1536,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_lxc.c",
      "funcName": "ipv6_policy",
      "developer_inline_comments": [
        {
          "start_line": 1387,
          "end_line": 1389,
          "text": "/* If packet is coming from the ingress proxy we have to skip\n\t * redirection to the ingress proxy as we would loop forever.\n\t */"
        },
        {
          "start_line": 1396,
          "end_line": 1396,
          "text": "/* The map value is zeroed so the map update didn't happen somehow. */"
        },
        {
          "start_line": 1407,
          "end_line": 1407,
          "text": "/* HAVE_DIRECT_ACCESS_TO_MAP_VALUES */"
        },
        {
          "start_line": 1412,
          "end_line": 1415,
          "text": "/* Check it this is return traffic to an egress proxy.\n\t * Do not redirect again if the packet is coming from the egress proxy.\n\t * Always redirect connections that originated from L7 LB.\n\t */"
        },
        {
          "start_line": 1419,
          "end_line": 1421,
          "text": "/* This is a reply, the proxy port does not need to be embedded\n\t\t * into ctx->mark and *proxy_port can be left unset.\n\t\t */"
        },
        {
          "start_line": 1451,
          "end_line": 1453,
          "text": "/* Reply packets and related packets are allowed, all others must be\n\t * permitted by policy.\n\t */"
        },
        {
          "start_line": 1485,
          "end_line": 1485,
          "text": "/* ENABLE_DSR */"
        },
        {
          "start_line": 1498,
          "end_line": 1498,
          "text": "/* ENABLE_NODEPORT */"
        },
        {
          "start_line": 1507,
          "end_line": 1507,
          "text": "/* NOTE: tuple has been invalidated after this */"
        },
        {
          "start_line": 1522,
          "end_line": 1522,
          "text": "/* Not redirected to host / proxy. */"
        },
        {
          "start_line": 1527,
          "end_line": 1527,
          "text": "/* See comment in IPv4 path. */"
        },
        {
          "start_line": 1533,
          "end_line": 1533,
          "text": "/* !ENABLE_ROUTING && TUNNEL_MODE && !ENABLE_NODEPORT */"
        }
      ],
      "updateMaps": [],
      "readMaps": [
        "  CT_TAIL_CALL_BUFFER6"
      ],
      "input": [
        "struct  __ctx_buff *ctx",
        " int ifindex",
        " __u32 src_label",
        " enum ct_status *ct_status",
        " struct ipv6_ct_tuple *tuple_out",
        " __u16 *proxy_port",
        " bool from_host __maybe_unused"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "redirect",
        "CTX_ACT_OK",
        "map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "static __always_inline int ipv6_policy (struct  __ctx_buff *ctx, int ifindex, __u32 src_label, enum ct_status *ct_status, struct ipv6_ct_tuple *tuple_out, __u16 *proxy_port, bool from_host __maybe_unused)\n",
        "{\n",
        "    struct ct_state ct_state_on_stack __maybe_unused, *ct_state, ct_state_new = {};\n",
        "    struct ipv6_ct_tuple tuple_on_stack __maybe_unused, *tuple;\n",
        "    int ret, verdict, hdrlen, zero = 0;\n",
        "    struct ct_buffer6 *ct_buffer;\n",
        "    void *data, *data_end;\n",
        "    struct ipv6hdr *ip6;\n",
        "    bool skip_ingress_proxy = false;\n",
        "    enum trace_reason reason;\n",
        "    union v6addr orig_sip;\n",
        "    __u32 monitor = 0;\n",
        "    __u8 policy_match_type = POLICY_MATCH_NONE;\n",
        "    __u8 audited = 0;\n",
        "    bool emit_policy_verdict = true;\n",
        "    if (!revalidate_data (ctx, &data, &data_end, &ip6))\n",
        "        return DROP_INVALID;\n",
        "    policy_clear_mark (ctx);\n",
        "    ipv6_addr_copy (&orig_sip, (union v6addr *) &ip6->saddr);\n",
        "    skip_ingress_proxy = tc_index_skip_ingress_proxy (ctx);\n",
        "    ct_buffer = map_lookup_elem (& CT_TAIL_CALL_BUFFER6, & zero);\n",
        "    if (!ct_buffer)\n",
        "        return DROP_INVALID_TC_BUFFER;\n",
        "    if (ct_buffer->tuple.saddr.d1 == 0 && ct_buffer->tuple.saddr.d2 == 0)\n",
        "        return DROP_INVALID_TC_BUFFER;\n",
        "\n",
        "#if HAVE_DIRECT_ACCESS_TO_MAP_VALUES\n",
        "    tuple = (struct ipv6_ct_tuple *) &ct_buffer->tuple;\n",
        "    ct_state = (struct ct_state *) &ct_buffer->ct_state;\n",
        "\n",
        "#else\n",
        "    memcpy (&tuple_on_stack, &ct_buffer->tuple, sizeof (tuple_on_stack));\n",
        "    tuple = &tuple_on_stack;\n",
        "    memcpy (&ct_state_on_stack, &ct_buffer->ct_state, sizeof (ct_state_on_stack));\n",
        "    ct_state = &ct_state_on_stack;\n",
        "\n",
        "#endif /* HAVE_DIRECT_ACCESS_TO_MAP_VALUES */\n",
        "    monitor = ct_buffer->monitor;\n",
        "    ret = ct_buffer->ret;\n",
        "    *ct_status = (enum ct_status) ret;\n",
        "    if ((ret == CT_REPLY || ret == CT_RELATED) && (ct_state_is_from_l7lb (ct_state) || (ct_state->proxy_redirect && !tc_index_skip_egress_proxy (ctx)))) {\n",
        "        send_trace_notify6 (ctx, TRACE_TO_PROXY, src_label, SECLABEL, &orig_sip, 0, ifindex, (enum trace_reason) ret, monitor);\n",
        "        if (tuple_out)\n",
        "            memcpy (tuple_out, tuple, sizeof (*tuple));\n",
        "        return POLICY_ACT_PROXY_REDIRECT;\n",
        "    }\n",
        "    if (unlikely (ct_state->rev_nat_index)) {\n",
        "        struct csum_offset csum_off = {}\n",
        "        ;\n",
        "        int ret2, l4_off;\n",
        "        hdrlen = ipv6_hdrlen (ctx, & tuple -> nexthdr);\n",
        "        if (hdrlen < 0)\n",
        "            return hdrlen;\n",
        "        l4_off = ETH_HLEN + hdrlen;\n",
        "        csum_l4_offset_and_flags (tuple->nexthdr, &csum_off);\n",
        "        ret2 = lb6_rev_nat (ctx, l4_off, & csum_off, ct_state -> rev_nat_index, tuple, 0);\n",
        "        if (IS_ERR (ret2))\n",
        "            return ret2;\n",
        "    }\n",
        "    verdict = policy_can_access_ingress (ctx, src_label, SECLABEL, tuple -> dport, tuple -> nexthdr, false, & policy_match_type, & audited);\n",
        "    if (ret != CT_REPLY && ret != CT_RELATED && verdict < 0) {\n",
        "        send_policy_verdict_notify (ctx, src_label, tuple->dport, tuple->nexthdr, POLICY_INGRESS, 1, verdict, policy_match_type, audited);\n",
        "        return verdict;\n",
        "    }\n",
        "    if (skip_ingress_proxy) {\n",
        "        verdict = 0;\n",
        "        emit_policy_verdict = false;\n",
        "    }\n",
        "    if (emit_policy_verdict && (ret == CT_NEW || ret == CT_REOPENED)) {\n",
        "        send_policy_verdict_notify (ctx, src_label, tuple->dport, tuple->nexthdr, POLICY_INGRESS, 1, verdict, policy_match_type, audited);\n",
        "    }\n",
        "\n",
        "#ifdef ENABLE_NODEPORT\n",
        "    if (ret == CT_NEW || ret == CT_REOPENED) {\n",
        "        bool dsr = false;\n",
        "\n",
        "# ifdef ENABLE_DSR\n",
        "        int ret2;\n",
        "        ret2 = handle_dsr_v6 (ctx, & dsr);\n",
        "        if (ret2 != 0)\n",
        "            return ret2;\n",
        "        ct_state_new.dsr = dsr;\n",
        "        if (ret == CT_REOPENED && ct_state->dsr != dsr)\n",
        "            ct_update6_dsr (get_ct_map6 (tuple), tuple, dsr);\n",
        "\n",
        "# endif /* ENABLE_DSR */\n",
        "        if (!dsr) {\n",
        "            bool node_port = ct_has_nodeport_egress_entry6 (get_ct_map6 (tuple), tuple);\n",
        "            ct_state_new.node_port = node_port;\n",
        "            if (ret == CT_REOPENED && ct_state->node_port != node_port)\n",
        "                ct_update_nodeport (get_ct_map6 (tuple), tuple, node_port);\n",
        "        }\n",
        "    }\n",
        "\n",
        "#endif /* ENABLE_NODEPORT */\n",
        "    if (ret == CT_NEW) {\n",
        "        ct_state_new.src_sec_id = src_label;\n",
        "        ret = ct_create6 (get_ct_map6 (tuple), & CT_MAP_ANY6, tuple, ctx, CT_INGRESS, & ct_state_new, verdict > 0, false);\n",
        "        if (IS_ERR (ret))\n",
        "            return ret;\n",
        "    }\n",
        "    if (!revalidate_data (ctx, &data, &data_end, &ip6))\n",
        "        return DROP_INVALID;\n",
        "    reason = (enum trace_reason) *ct_status;\n",
        "    if (redirect_to_proxy (verdict, *ct_status)) {\n",
        "        *proxy_port = (__u16) verdict;\n",
        "        send_trace_notify6 (ctx, TRACE_TO_PROXY, src_label, SECLABEL, &orig_sip, bpf_ntohs (*proxy_port), ifindex, reason, monitor);\n",
        "        if (tuple_out)\n",
        "            memcpy (tuple_out, tuple, sizeof (*tuple));\n",
        "        return POLICY_ACT_PROXY_REDIRECT;\n",
        "    }\n",
        "    send_trace_notify6 (ctx, TRACE_TO_LXC, src_label, SECLABEL, &orig_sip, LXC_ID, ifindex, reason, monitor);\n",
        "\n",
        "#if !defined(ENABLE_ROUTING) && defined(TUNNEL_MODE) && !defined(ENABLE_NODEPORT)\n",
        "    ctx_change_type (ctx, PACKET_HOST);\n",
        "\n",
        "#else\n",
        "    ifindex = ctx_load_meta (ctx, CB_IFINDEX);\n",
        "    if (ifindex)\n",
        "        return redirect_ep (ctx, ifindex, from_host);\n",
        "\n",
        "#endif /* !ENABLE_ROUTING && TUNNEL_MODE && !ENABLE_NODEPORT */\n",
        "    return CTX_ACT_OK;\n",
        "}\n"
      ],
      "called_function_list": [
        "ct_update_nodeport",
        "tc_index_skip_egress_proxy",
        "ct_update6_dsr",
        "redirect_ep",
        "send_trace_notify6",
        "tc_index_skip_ingress_proxy",
        "send_policy_verdict_notify",
        "ct_state_is_from_l7lb",
        "policy_can_access_ingress",
        "lb6_rev_nat",
        "ipv6_addr_copy",
        "ipv6_hdrlen",
        "ct_has_nodeport_egress_entry6",
        "ct_create6",
        "get_ct_map6",
        "handle_dsr_v6",
        "memcpy",
        "redirect_to_proxy",
        "policy_clear_mark",
        "ctx_load_meta",
        "csum_l4_offset_and_flags"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        {
          "description": " Check if the packet is ingress or exgress traffic, redirect the traffic if necessary. ",
          "author": "Yihe Bi",
          "authorEmail": "ybi@bu.edu",
          "date": "2023-02-24"
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "tail_ipv6_policy": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1540,
      "endLine": 1581,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_lxc.c",
      "funcName": "tail_ipv6_policy",
      "developer_inline_comments": [
        {
          "start_line": 1563,
          "end_line": 1563,
          "text": "/* Store meta: essential for proxy ingress, see bpf_host.c */"
        },
        {
          "start_line": 1567,
          "end_line": 1571,
          "text": "/* Make sure we skip the tail call when the packet is being redirected\n\t * to a L7 proxy, to avoid running the custom program twice on the\n\t * incoming packet (before redirecting, and on the way back from the\n\t * proxy).\n\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "int",
      "helper": [
        "tail_call"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "int tail_ipv6_policy (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    struct ipv6_ct_tuple tuple = {}\n",
        "    ;\n",
        "    int ret, ifindex = ctx_load_meta (ctx, CB_IFINDEX);\n",
        "    __u32 src_label = ctx_load_meta (ctx, CB_SRC_LABEL);\n",
        "    bool from_host = ctx_load_meta (ctx, CB_FROM_HOST);\n",
        "    bool proxy_redirect __maybe_unused = false;\n",
        "    __u16 proxy_port = 0;\n",
        "    enum ct_status ct_status = 0;\n",
        "    ctx_store_meta (ctx, CB_SRC_LABEL, 0);\n",
        "    ctx_store_meta (ctx, CB_FROM_HOST, 0);\n",
        "    ret = ipv6_policy (ctx, ifindex, src_label, & ct_status, & tuple, & proxy_port, from_host);\n",
        "    if (ret == POLICY_ACT_PROXY_REDIRECT) {\n",
        "        ret = ctx_redirect_to_proxy6 (ctx, & tuple, proxy_port, from_host);\n",
        "        proxy_redirect = true;\n",
        "    }\n",
        "    if (IS_ERR (ret))\n",
        "        return send_drop_notify (ctx, src_label, SECLABEL, LXC_ID, ret, CTX_ACT_DROP, METRIC_INGRESS);\n",
        "    ctx_store_meta (ctx, CB_PROXY_MAGIC, ctx->mark);\n",
        "\n",
        "#ifdef ENABLE_CUSTOM_CALLS\n",
        "    if (!proxy_redirect && !encode_custom_prog_meta (ctx, ret, src_label)) {\n",
        "        tail_call_static (ctx, &CUSTOM_CALLS_MAP, CUSTOM_CALLS_IDX_IPV6_INGRESS);\n",
        "        update_metrics (ctx_full_len (ctx), METRIC_INGRESS, REASON_MISSED_CUSTOM_CALL);\n",
        "    }\n",
        "\n",
        "#endif\n",
        "    return ret;\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_redirect_to_proxy6",
        "ctx_store_meta",
        "ipv6_policy",
        "tail_call_static",
        "encode_custom_prog_meta",
        "ctx_load_meta",
        "ctx_full_len",
        "update_metrics"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        {
          "description": " Identify ipv6 tail call, store data to ctx. Skip tail call when packet is being redirected to a L7 proxy. ",
          "author": "Yihe Bi",
          "authorEmail": "ybi@bu.edu",
          "date": "2023-02-24"
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "tail_ipv6_to_endpoint": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1584,
      "endLine": 1659,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_lxc.c",
      "funcName": "tail_ipv6_to_endpoint",
      "developer_inline_comments": [
        {
          "start_line": 1599,
          "end_line": 1599,
          "text": "/* Packets from the proxy will already have a real identity. */"
        },
        {
          "start_line": 1609,
          "end_line": 1616,
          "text": "/* When SNAT is enabled on traffic ingressing\n\t\t\t\t * into Cilium, all traffic from the world will\n\t\t\t\t * have a source IP of the host. It will only\n\t\t\t\t * actually be from the host if \"src_identity\"\n\t\t\t\t * (passed into this function) reports the src\n\t\t\t\t * as the host. So we can ignore the ipcache\n\t\t\t\t * if it reports the source as HOST_ID.\n\t\t\t\t */"
        },
        {
          "start_line": 1644,
          "end_line": 1648,
          "text": "/* Make sure we skip the tail call when the packet is being redirected\n\t * to a L7 proxy, to avoid running the custom program twice on the\n\t * incoming packet (before redirecting, and on the way back from the\n\t * proxy).\n\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "int",
      "helper": [
        "tail_call"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "int tail_ipv6_to_endpoint (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    __u32 src_identity = ctx_load_meta (ctx, CB_SRC_LABEL);\n",
        "    bool proxy_redirect __maybe_unused = false;\n",
        "    void *data, *data_end;\n",
        "    struct ipv6hdr *ip6;\n",
        "    __u16 proxy_port = 0;\n",
        "    enum ct_status ct_status;\n",
        "    int ret;\n",
        "    if (!revalidate_data (ctx, &data, &data_end, &ip6)) {\n",
        "        ret = DROP_INVALID;\n",
        "        goto out;\n",
        "    }\n",
        "    if (identity_is_reserved (src_identity)) {\n",
        "        union v6addr *src = (union v6addr *) &ip6->saddr;\n",
        "        struct remote_endpoint_info *info;\n",
        "        info = lookup_ip6_remote_endpoint (src);\n",
        "        if (info != NULL) {\n",
        "            __u32 sec_label = info->sec_label;\n",
        "            if (sec_label) {\n",
        "                if (sec_label != HOST_ID)\n",
        "                    src_identity = sec_label;\n",
        "            }\n",
        "        }\n",
        "        cilium_dbg (ctx, info ? DBG_IP_ID_MAP_SUCCEED6 : DBG_IP_ID_MAP_FAILED6, ((__u32 *) src)[3], src_identity);\n",
        "    }\n",
        "    cilium_dbg (ctx, DBG_LOCAL_DELIVERY, LXC_ID, SECLABEL);\n",
        "\n",
        "#ifdef LOCAL_DELIVERY_METRICS\n",
        "    update_metrics (ctx_full_len (ctx), METRIC_INGRESS, REASON_FORWARDED);\n",
        "\n",
        "#endif\n",
        "    ctx_store_meta (ctx, CB_SRC_LABEL, 0);\n",
        "    ret = ipv6_policy (ctx, 0, src_identity, & ct_status, NULL, & proxy_port, true);\n",
        "    if (ret == POLICY_ACT_PROXY_REDIRECT) {\n",
        "        ret = ctx_redirect_to_proxy_hairpin_ipv6 (ctx, proxy_port);\n",
        "        proxy_redirect = true;\n",
        "    }\n",
        "out :\n",
        "    if (IS_ERR (ret))\n",
        "        return send_drop_notify (ctx, src_identity, SECLABEL, LXC_ID, ret, CTX_ACT_DROP, METRIC_INGRESS);\n",
        "\n",
        "#ifdef ENABLE_CUSTOM_CALLS\n",
        "    if (!proxy_redirect && !encode_custom_prog_meta (ctx, ret, src_identity)) {\n",
        "        tail_call_static (ctx, &CUSTOM_CALLS_MAP, CUSTOM_CALLS_IDX_IPV6_INGRESS);\n",
        "        update_metrics (ctx_full_len (ctx), METRIC_INGRESS, REASON_MISSED_CUSTOM_CALL);\n",
        "    }\n",
        "\n",
        "#endif\n",
        "    return ret;\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_store_meta",
        "ctx_redirect_to_proxy_hairpin_ipv6",
        "ipv6_policy",
        "tail_call_static",
        "identity_is_reserved",
        "encode_custom_prog_meta",
        "ctx_load_meta",
        "ctx_full_len",
        "cilium_dbg",
        "update_metrics"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        {
          "description": " delivery ipv6 tail call to endpoint, skip if it is send to L7 proxy ",
          "author": "Yihe Bi",
          "authorEmail": "ybi@bu.edu",
          "date": "2023-02-24"
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ipv4_policy": [
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        },
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 1671,
      "endLine": 1879,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_lxc.c",
      "funcName": "ipv4_policy",
      "developer_inline_comments": [
        {
          "start_line": 1668,
          "end_line": 1668,
          "text": "/* ENABLE_IPV6 */"
        },
        {
          "start_line": 1696,
          "end_line": 1698,
          "text": "/* If packet is coming from the ingress proxy we have to skip\n\t * redirection to the ingress proxy as we would loop forever.\n\t */"
        },
        {
          "start_line": 1704,
          "end_line": 1706,
          "text": "/* Indicate that this is a datagram fragment for which we cannot\n\t * retrieve L4 ports. Do not set flag if we support fragmentation.\n\t */"
        },
        {
          "start_line": 1714,
          "end_line": 1714,
          "text": "/* The map value is zeroed so the map update didn't happen somehow. */"
        },
        {
          "start_line": 1725,
          "end_line": 1725,
          "text": "/* HAVE_DIRECT_ACCESS_TO_MAP_VALUES */"
        },
        {
          "start_line": 1730,
          "end_line": 1733,
          "text": "/* Check it this is return traffic to an egress proxy.\n\t * Do not redirect again if the packet is coming from the egress proxy.\n\t * Always redirect connections that originated from L7 LB.\n\t */"
        },
        {
          "start_line": 1738,
          "end_line": 1740,
          "text": "/* This is a reply, the proxy port does not need to be embedded\n\t\t * into ctx->mark and *proxy_port can be left unset.\n\t\t */"
        },
        {
          "start_line": 1768,
          "end_line": 1773,
          "text": "/* When an endpoint connects to itself via service clusterIP, we need\n\t * to skip the policy enforcement. If we didn't, the user would have to\n\t * define policy rules to allow pods to talk to themselves. We still\n\t * want to execute the conntrack logic so that replies can be correctly\n\t * matched.\n\t */"
        },
        {
          "start_line": 1776,
          "end_line": 1776,
          "text": "/* ENABLE_PER_PACKET_LB && !DISABLE_LOOPBACK_LB */"
        },
        {
          "start_line": 1783,
          "end_line": 1785,
          "text": "/* Reply packets and related packets are allowed, all others must be\n\t * permitted by policy.\n\t */"
        },
        {
          "start_line": 1806,
          "end_line": 1806,
          "text": "/* ENABLE_PER_PACKET_LB && !DISABLE_LOOPBACK_LB */"
        },
        {
          "start_line": 1821,
          "end_line": 1821,
          "text": "/* ENABLE_DSR */"
        },
        {
          "start_line": 1834,
          "end_line": 1834,
          "text": "/* ENABLE_NODEPORT */"
        },
        {
          "start_line": 1843,
          "end_line": 1843,
          "text": "/* NOTE: tuple has been invalidated after this */"
        },
        {
          "start_line": 1858,
          "end_line": 1858,
          "text": "/* Not redirected to host / proxy. */"
        },
        {
          "start_line": 1863,
          "end_line": 1870,
          "text": "/* In tunneling mode, we execute this code to send the packet from\n\t * cilium_vxlan to lxc*. If we're using kube-proxy, we don't want to use\n\t * redirect() because that would bypass conntrack and the reverse DNAT.\n\t * Thus, we send packets to the stack, but since they have the wrong\n\t * Ethernet addresses, we need to mark them as PACKET_HOST or the kernel\n\t * will drop them.\n\t * See #14646 for details.\n\t */"
        },
        {
          "start_line": 1876,
          "end_line": 1876,
          "text": "/* !ENABLE_ROUTING && TUNNEL_MODE && !ENABLE_NODEPORT */"
        }
      ],
      "updateMaps": [],
      "readMaps": [
        "  CT_TAIL_CALL_BUFFER4"
      ],
      "input": [
        "struct  __ctx_buff *ctx",
        " int ifindex",
        " __u32 src_label",
        " enum ct_status *ct_status",
        " struct ipv4_ct_tuple *tuple_out",
        " __u16 *proxy_port",
        " bool from_host __maybe_unused"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "redirect",
        "CTX_ACT_OK",
        "map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "static __always_inline int ipv4_policy (struct  __ctx_buff *ctx, int ifindex, __u32 src_label, enum ct_status *ct_status, struct ipv4_ct_tuple *tuple_out, __u16 *proxy_port, bool from_host __maybe_unused)\n",
        "{\n",
        "    struct ct_state ct_state_on_stack __maybe_unused, *ct_state, ct_state_new = {};\n",
        "    struct ipv4_ct_tuple tuple_on_stack __maybe_unused, *tuple;\n",
        "    void *data, *data_end;\n",
        "    struct iphdr *ip4;\n",
        "    bool skip_ingress_proxy = false;\n",
        "    bool is_untracked_fragment = false;\n",
        "    struct ct_buffer4 *ct_buffer;\n",
        "    __u32 monitor = 0, zero = 0;\n",
        "    enum trace_reason reason;\n",
        "    int ret, verdict = 0;\n",
        "    __be32 orig_sip;\n",
        "    __u8 policy_match_type = POLICY_MATCH_NONE;\n",
        "    __u8 audited = 0;\n",
        "    bool emit_policy_verdict = true;\n",
        "    if (!revalidate_data (ctx, &data, &data_end, &ip4))\n",
        "        return DROP_INVALID;\n",
        "    policy_clear_mark (ctx);\n",
        "    skip_ingress_proxy = tc_index_skip_ingress_proxy (ctx);\n",
        "    orig_sip = ip4->saddr;\n",
        "\n",
        "#ifndef ENABLE_IPV4_FRAGMENTS\n",
        "    is_untracked_fragment = ipv4_is_fragment (ip4);\n",
        "\n",
        "#endif\n",
        "    ct_buffer = map_lookup_elem (& CT_TAIL_CALL_BUFFER4, & zero);\n",
        "    if (!ct_buffer)\n",
        "        return DROP_INVALID_TC_BUFFER;\n",
        "    if (ct_buffer->tuple.saddr == 0)\n",
        "        return DROP_INVALID_TC_BUFFER;\n",
        "\n",
        "#if HAVE_DIRECT_ACCESS_TO_MAP_VALUES\n",
        "    tuple = (struct ipv4_ct_tuple *) &ct_buffer->tuple;\n",
        "    ct_state = (struct ct_state *) &ct_buffer->ct_state;\n",
        "\n",
        "#else\n",
        "    memcpy (&tuple_on_stack, &ct_buffer->tuple, sizeof (tuple_on_stack));\n",
        "    tuple = &tuple_on_stack;\n",
        "    memcpy (&ct_state_on_stack, &ct_buffer->ct_state, sizeof (ct_state_on_stack));\n",
        "    ct_state = &ct_state_on_stack;\n",
        "\n",
        "#endif /* HAVE_DIRECT_ACCESS_TO_MAP_VALUES */\n",
        "    monitor = ct_buffer->monitor;\n",
        "    ret = ct_buffer->ret;\n",
        "    *ct_status = (enum ct_status) ret;\n",
        "    relax_verifier ();\n",
        "    if ((ret == CT_REPLY || ret == CT_RELATED) && (ct_state_is_from_l7lb (ct_state) || (ct_state->proxy_redirect && !tc_index_skip_egress_proxy (ctx)))) {\n",
        "        send_trace_notify4 (ctx, TRACE_TO_PROXY, src_label, SECLABEL, orig_sip, 0, ifindex, (enum trace_reason) ret, monitor);\n",
        "        if (tuple_out)\n",
        "            *tuple_out = *tuple;\n",
        "        return POLICY_ACT_PROXY_REDIRECT;\n",
        "    }\n",
        "    if (unlikely (ret == CT_REPLY && ct_state->rev_nat_index && !ct_state->loopback)) {\n",
        "        struct csum_offset csum_off = {}\n",
        "        ;\n",
        "        bool has_l4_header = false;\n",
        "        int ret2, l4_off;\n",
        "        l4_off = ETH_HLEN + ipv4_hdrlen (ip4);\n",
        "        has_l4_header = ipv4_has_l4_header (ip4);\n",
        "        if (has_l4_header)\n",
        "            csum_l4_offset_and_flags (tuple->nexthdr, &csum_off);\n",
        "        ret2 = lb4_rev_nat (ctx, ETH_HLEN, l4_off, & csum_off, ct_state, tuple, REV_NAT_F_TUPLE_SADDR, has_l4_header);\n",
        "        if (IS_ERR (ret2))\n",
        "            return ret2;\n",
        "    }\n",
        "\n",
        "#if defined(ENABLE_PER_PACKET_LB) && !defined(DISABLE_LOOPBACK_LB)\n",
        "    if (unlikely (ct_state->loopback))\n",
        "        goto skip_policy_enforcement;\n",
        "\n",
        "#endif /* ENABLE_PER_PACKET_LB && !DISABLE_LOOPBACK_LB */\n",
        "    verdict = policy_can_access_ingress (ctx, src_label, SECLABEL, tuple -> dport, tuple -> nexthdr, is_untracked_fragment, & policy_match_type, & audited);\n",
        "    if (ret != CT_REPLY && ret != CT_RELATED && verdict < 0) {\n",
        "        send_policy_verdict_notify (ctx, src_label, tuple->dport, tuple->nexthdr, POLICY_INGRESS, 0, verdict, policy_match_type, audited);\n",
        "        return verdict;\n",
        "    }\n",
        "    if (skip_ingress_proxy) {\n",
        "        verdict = 0;\n",
        "        emit_policy_verdict = false;\n",
        "    }\n",
        "    if (emit_policy_verdict && (ret == CT_NEW || ret == CT_REOPENED)) {\n",
        "        send_policy_verdict_notify (ctx, src_label, tuple->dport, tuple->nexthdr, POLICY_INGRESS, 0, verdict, policy_match_type, audited);\n",
        "    }\n",
        "\n",
        "#if defined(ENABLE_PER_PACKET_LB) && !defined(DISABLE_LOOPBACK_LB)\n",
        "skip_policy_enforcement :\n",
        "\n",
        "#endif /* ENABLE_PER_PACKET_LB && !DISABLE_LOOPBACK_LB */\n",
        "\n",
        "#ifdef ENABLE_NODEPORT\n",
        "    if (ret == CT_NEW || ret == CT_REOPENED) {\n",
        "        bool dsr = false;\n",
        "\n",
        "# ifdef ENABLE_DSR\n",
        "        int ret2;\n",
        "        ret2 = handle_dsr_v4 (ctx, & dsr);\n",
        "        if (ret2 != 0)\n",
        "            return ret2;\n",
        "        ct_state_new.dsr = dsr;\n",
        "        if (ret == CT_REOPENED && ct_state->dsr != dsr)\n",
        "            ct_update4_dsr (get_ct_map4 (tuple), tuple, dsr);\n",
        "\n",
        "# endif /* ENABLE_DSR */\n",
        "        if (!dsr) {\n",
        "            bool node_port = ct_has_nodeport_egress_entry4 (get_ct_map4 (tuple), tuple);\n",
        "            ct_state_new.node_port = node_port;\n",
        "            if (ret == CT_REOPENED && ct_state->node_port != node_port)\n",
        "                ct_update_nodeport (get_ct_map4 (tuple), tuple, node_port);\n",
        "        }\n",
        "    }\n",
        "\n",
        "#endif /* ENABLE_NODEPORT */\n",
        "    if (ret == CT_NEW) {\n",
        "        ct_state_new.src_sec_id = src_label;\n",
        "        ret = ct_create4 (get_ct_map4 (tuple), & CT_MAP_ANY4, tuple, ctx, CT_INGRESS, & ct_state_new, verdict > 0, false);\n",
        "        if (IS_ERR (ret))\n",
        "            return ret;\n",
        "    }\n",
        "    if (!revalidate_data (ctx, &data, &data_end, &ip4))\n",
        "        return DROP_INVALID;\n",
        "    reason = (enum trace_reason) *ct_status;\n",
        "    if (redirect_to_proxy (verdict, *ct_status)) {\n",
        "        *proxy_port = (__u16) verdict;\n",
        "        send_trace_notify4 (ctx, TRACE_TO_PROXY, src_label, SECLABEL, orig_sip, bpf_ntohs (*proxy_port), ifindex, reason, monitor);\n",
        "        if (tuple_out)\n",
        "            *tuple_out = *tuple;\n",
        "        return POLICY_ACT_PROXY_REDIRECT;\n",
        "    }\n",
        "    send_trace_notify4 (ctx, TRACE_TO_LXC, src_label, SECLABEL, orig_sip, LXC_ID, ifindex, reason, monitor);\n",
        "\n",
        "#if !defined(ENABLE_ROUTING) && defined(TUNNEL_MODE) && !defined(ENABLE_NODEPORT)\n",
        "    ctx_change_type (ctx, PACKET_HOST);\n",
        "\n",
        "#else\n",
        "    ifindex = ctx_load_meta (ctx, CB_IFINDEX);\n",
        "    if (ifindex)\n",
        "        return redirect_ep (ctx, ifindex, from_host);\n",
        "\n",
        "#endif /* !ENABLE_ROUTING && TUNNEL_MODE && !ENABLE_NODEPORT */\n",
        "    return CTX_ACT_OK;\n",
        "}\n"
      ],
      "called_function_list": [
        "send_trace_notify4",
        "ct_update_nodeport",
        "tc_index_skip_egress_proxy",
        "redirect_ep",
        "tc_index_skip_ingress_proxy",
        "handle_dsr_v4",
        "send_policy_verdict_notify",
        "ipv4_hdrlen",
        "ct_state_is_from_l7lb",
        "policy_can_access_ingress",
        "ipv4_is_fragment",
        "ipv4_has_l4_header",
        "ct_create4",
        "relax_verifier",
        "ct_has_nodeport_egress_entry4",
        "memcpy",
        "redirect_to_proxy",
        "lb4_rev_nat",
        "get_ct_map4",
        "ct_update4_dsr",
        "policy_clear_mark",
        "ctx_load_meta",
        "csum_l4_offset_and_flags"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        {
          "description": " Identify ipv4 message and store its meta data to ctx. ",
          "author": "Yihe Bi",
          "authorEmail": "ybi@bu.edu",
          "date": "2023-02-24"
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "tail_ipv4_policy": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1883,
      "endLine": 1924,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_lxc.c",
      "funcName": "tail_ipv4_policy",
      "developer_inline_comments": [
        {
          "start_line": 1906,
          "end_line": 1906,
          "text": "/* Store meta: essential for proxy ingress, see bpf_host.c */"
        },
        {
          "start_line": 1910,
          "end_line": 1914,
          "text": "/* Make sure we skip the tail call when the packet is being redirected\n\t * to a L7 proxy, to avoid running the custom program twice on the\n\t * incoming packet (before redirecting, and on the way back from the\n\t * proxy).\n\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "int",
      "helper": [
        "tail_call"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "int tail_ipv4_policy (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    struct ipv4_ct_tuple tuple = {}\n",
        "    ;\n",
        "    int ret, ifindex = ctx_load_meta (ctx, CB_IFINDEX);\n",
        "    __u32 src_label = ctx_load_meta (ctx, CB_SRC_LABEL);\n",
        "    bool from_host = ctx_load_meta (ctx, CB_FROM_HOST);\n",
        "    bool proxy_redirect __maybe_unused = false;\n",
        "    enum ct_status ct_status = 0;\n",
        "    __u16 proxy_port = 0;\n",
        "    ctx_store_meta (ctx, CB_SRC_LABEL, 0);\n",
        "    ctx_store_meta (ctx, CB_FROM_HOST, 0);\n",
        "    ret = ipv4_policy (ctx, ifindex, src_label, & ct_status, & tuple, & proxy_port, from_host);\n",
        "    if (ret == POLICY_ACT_PROXY_REDIRECT) {\n",
        "        ret = ctx_redirect_to_proxy4 (ctx, & tuple, proxy_port, from_host);\n",
        "        proxy_redirect = true;\n",
        "    }\n",
        "    if (IS_ERR (ret))\n",
        "        return send_drop_notify (ctx, src_label, SECLABEL, LXC_ID, ret, CTX_ACT_DROP, METRIC_INGRESS);\n",
        "    ctx_store_meta (ctx, CB_PROXY_MAGIC, ctx->mark);\n",
        "\n",
        "#ifdef ENABLE_CUSTOM_CALLS\n",
        "    if (!proxy_redirect && !encode_custom_prog_meta (ctx, ret, src_label)) {\n",
        "        tail_call_static (ctx, &CUSTOM_CALLS_MAP, CUSTOM_CALLS_IDX_IPV4_INGRESS);\n",
        "        update_metrics (ctx_full_len (ctx), METRIC_INGRESS, REASON_MISSED_CUSTOM_CALL);\n",
        "    }\n",
        "\n",
        "#endif\n",
        "    return ret;\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_store_meta",
        "tail_call_static",
        "ipv4_policy",
        "ctx_redirect_to_proxy4",
        "encode_custom_prog_meta",
        "ctx_load_meta",
        "ctx_full_len",
        "update_metrics"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        {
          "description": " Redirect ipv4 tail call, skip tail calls when packet is being redirected to L7 proxy. ",
          "author": "Yihe Bi",
          "authorEmail": "ybi@bu.edu",
          "date": "2023-02-24"
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "tail_ipv4_to_endpoint": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1927,
      "endLine": 2001,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_lxc.c",
      "funcName": "tail_ipv4_to_endpoint",
      "developer_inline_comments": [
        {
          "start_line": 1942,
          "end_line": 1942,
          "text": "/* Packets from the proxy will already have a real identity. */"
        },
        {
          "start_line": 1951,
          "end_line": 1958,
          "text": "/* When SNAT is enabled on traffic ingressing\n\t\t\t\t * into Cilium, all traffic from the world will\n\t\t\t\t * have a source IP of the host. It will only\n\t\t\t\t * actually be from the host if \"src_identity\"\n\t\t\t\t * (passed into this function) reports the src\n\t\t\t\t * as the host. So we can ignore the ipcache\n\t\t\t\t * if it reports the source as HOST_ID.\n\t\t\t\t */"
        },
        {
          "start_line": 1986,
          "end_line": 1990,
          "text": "/* Make sure we skip the tail call when the packet is being redirected\n\t * to a L7 proxy, to avoid running the custom program twice on the\n\t * incoming packet (before redirecting, and on the way back from the\n\t * proxy).\n\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "int",
      "helper": [
        "tail_call"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "int tail_ipv4_to_endpoint (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    __u32 src_identity = ctx_load_meta (ctx, CB_SRC_LABEL);\n",
        "    bool proxy_redirect __maybe_unused = false;\n",
        "    void *data, *data_end;\n",
        "    struct iphdr *ip4;\n",
        "    __u16 proxy_port = 0;\n",
        "    enum ct_status ct_status;\n",
        "    int ret;\n",
        "    if (!revalidate_data (ctx, &data, &data_end, &ip4)) {\n",
        "        ret = DROP_INVALID;\n",
        "        goto out;\n",
        "    }\n",
        "    if (identity_is_reserved (src_identity)) {\n",
        "        struct remote_endpoint_info *info;\n",
        "        info = lookup_ip4_remote_endpoint (ip4 -> saddr);\n",
        "        if (info != NULL) {\n",
        "            __u32 sec_label = info->sec_label;\n",
        "            if (sec_label) {\n",
        "                if (sec_label != HOST_ID)\n",
        "                    src_identity = sec_label;\n",
        "            }\n",
        "        }\n",
        "        cilium_dbg (ctx, info ? DBG_IP_ID_MAP_SUCCEED4 : DBG_IP_ID_MAP_FAILED4, ip4->saddr, src_identity);\n",
        "    }\n",
        "    cilium_dbg (ctx, DBG_LOCAL_DELIVERY, LXC_ID, SECLABEL);\n",
        "\n",
        "#ifdef LOCAL_DELIVERY_METRICS\n",
        "    update_metrics (ctx_full_len (ctx), METRIC_INGRESS, REASON_FORWARDED);\n",
        "\n",
        "#endif\n",
        "    ctx_store_meta (ctx, CB_SRC_LABEL, 0);\n",
        "    ret = ipv4_policy (ctx, 0, src_identity, & ct_status, NULL, & proxy_port, true);\n",
        "    if (ret == POLICY_ACT_PROXY_REDIRECT) {\n",
        "        ret = ctx_redirect_to_proxy_hairpin_ipv4 (ctx, proxy_port);\n",
        "        proxy_redirect = true;\n",
        "    }\n",
        "out :\n",
        "    if (IS_ERR (ret))\n",
        "        return send_drop_notify (ctx, src_identity, SECLABEL, LXC_ID, ret, CTX_ACT_DROP, METRIC_INGRESS);\n",
        "\n",
        "#ifdef ENABLE_CUSTOM_CALLS\n",
        "    if (!proxy_redirect && !encode_custom_prog_meta (ctx, ret, src_identity)) {\n",
        "        tail_call_static (ctx, &CUSTOM_CALLS_MAP, CUSTOM_CALLS_IDX_IPV4_INGRESS);\n",
        "        update_metrics (ctx_full_len (ctx), METRIC_INGRESS, REASON_MISSED_CUSTOM_CALL);\n",
        "    }\n",
        "\n",
        "#endif\n",
        "    return ret;\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_store_meta",
        "ctx_redirect_to_proxy_hairpin_ipv4",
        "tail_call_static",
        "ipv4_policy",
        "identity_is_reserved",
        "encode_custom_prog_meta",
        "ctx_load_meta",
        "ctx_full_len",
        "cilium_dbg",
        "update_metrics"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        {
          "description": " Send ipv4 tail call to its enpoint. ",
          "author": "Yihe Bi",
          "authorEmail": "ybi@bu.edu",
          "date": "2023-02-24"
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "handle_policy": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 2024,
      "endLine": 2061,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_lxc.c",
      "funcName": "handle_policy",
      "developer_inline_comments": [
        {
          "start_line": 2010,
          "end_line": 2010,
          "text": "/* ENABLE_IPV4 */"
        },
        {
          "start_line": 2012,
          "end_line": 2022,
          "text": "/* Handle policy decisions as the packet makes its way towards the endpoint.\n * Previously, the packet may have come from another local endpoint, another\n * endpoint in the cluster, or from the big blue room (as identified by the\n * contents of ctx / CB_SRC_LABEL. Determine whether the traffic may be\n * passed into the endpoint or if it needs further inspection by a userspace\n * proxy.\n *\n * This program will be tail called to in ipv{4,6}_local_delivery from either\n * bpf_host, bpf_overlay (if coming from the tunnel), or bpf_lxc (if coming\n * from another local pod).\n */"
        },
        {
          "start_line": 2042,
          "end_line": 2042,
          "text": "/* ENABLE_IPV6 */"
        },
        {
          "start_line": 2049,
          "end_line": 2049,
          "text": "/* ENABLE_IPV4 */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "int",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "int handle_policy (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    __u32 src_label = ctx_load_meta (ctx, CB_SRC_LABEL);\n",
        "    __u16 proto;\n",
        "    int ret;\n",
        "    if (!validate_ethertype (ctx, &proto)) {\n",
        "        ret = DROP_UNSUPPORTED_L2;\n",
        "        goto out;\n",
        "    }\n",
        "    switch (proto) {\n",
        "\n",
        "#ifdef ENABLE_IPV6\n",
        "    case bpf_htons (ETH_P_IPV6) :\n",
        "        invoke_tailcall_if (__and (is_defined (ENABLE_IPV4), is_defined (ENABLE_IPV6)), CILIUM_CALL_IPV6_CT_INGRESS_POLICY_ONLY, tail_ipv6_ct_ingress_policy_only);\n",
        "        break;\n",
        "\n",
        "#endif /* ENABLE_IPV6 */\n",
        "\n",
        "#ifdef ENABLE_IPV4\n",
        "    case bpf_htons (ETH_P_IP) :\n",
        "        invoke_tailcall_if (__and (is_defined (ENABLE_IPV4), is_defined (ENABLE_IPV6)), CILIUM_CALL_IPV4_CT_INGRESS_POLICY_ONLY, tail_ipv4_ct_ingress_policy_only);\n",
        "        break;\n",
        "\n",
        "#endif /* ENABLE_IPV4 */\n",
        "    default :\n",
        "        ret = DROP_UNKNOWN_L3;\n",
        "        break;\n",
        "    }\n",
        "out :\n",
        "    if (IS_ERR (ret))\n",
        "        return send_drop_notify (ctx, src_label, SECLABEL, LXC_ID, ret, CTX_ACT_DROP, METRIC_INGRESS);\n",
        "    return ret;\n",
        "}\n"
      ],
      "called_function_list": [
        "validate_ethertype",
        "ctx_load_meta"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": " Identify if the traffic is ipv6/v4, handle policy using previous helper function. ",
          "author": "Yihe Bi",
          "authorEmail": "ybi@bu.edu",
          "date": "2023-02-24"
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "handle_policy_egress": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 2072,
      "endLine": 2113,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_lxc.c",
      "funcName": "handle_policy_egress",
      "developer_inline_comments": [
        {
          "start_line": 2063,
          "end_line": 2069,
          "text": "/* Handle policy decisions as the packet makes its way from the\n * endpoint.  Previously, the packet has come from the same endpoint,\n * but was redirected to a L7 LB.\n *\n * This program will be tail called from bpf_host for packets sent by\n * a L7 LB.\n */"
        },
        {
          "start_line": 2084,
          "end_line": 2084,
          "text": "/* do not count this traffic again */"
        },
        {
          "start_line": 2086,
          "end_line": 2086,
          "text": "/*ifindex*/"
        },
        {
          "start_line": 2095,
          "end_line": 2095,
          "text": "/* ENABLE_IPV6 */"
        },
        {
          "start_line": 2101,
          "end_line": 2101,
          "text": "/* ENABLE_IPV4 */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "int",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "int handle_policy_egress (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    __u16 proto;\n",
        "    int ret;\n",
        "    if (!validate_ethertype (ctx, &proto)) {\n",
        "        ret = DROP_UNSUPPORTED_L2;\n",
        "        goto out;\n",
        "    }\n",
        "    ctx_store_meta (ctx, CB_FROM_HOST, FROM_HOST_L7_LB);\n",
        "    edt_set_aggregate (ctx, 0);\n",
        "    send_trace_notify (ctx, TRACE_FROM_PROXY, SECLABEL, 0, 0, 0, TRACE_REASON_UNKNOWN, TRACE_PAYLOAD_LEN);\n",
        "    switch (proto) {\n",
        "\n",
        "#ifdef ENABLE_IPV6\n",
        "    case bpf_htons (ETH_P_IPV6) :\n",
        "        ep_tail_call (ctx, CILIUM_CALL_IPV6_FROM_LXC);\n",
        "        ret = DROP_MISSED_TAIL_CALL;\n",
        "        break;\n",
        "\n",
        "#endif /* ENABLE_IPV6 */\n",
        "\n",
        "#ifdef ENABLE_IPV4\n",
        "    case bpf_htons (ETH_P_IP) :\n",
        "        ep_tail_call (ctx, CILIUM_CALL_IPV4_FROM_LXC);\n",
        "        ret = DROP_MISSED_TAIL_CALL;\n",
        "        break;\n",
        "\n",
        "#endif /* ENABLE_IPV4 */\n",
        "    default :\n",
        "        ret = DROP_UNKNOWN_L3;\n",
        "        break;\n",
        "    }\n",
        "out :\n",
        "    if (IS_ERR (ret))\n",
        "        return send_drop_notify (ctx, SECLABEL, 0, LXC_ID, ret, CTX_ACT_DROP, METRIC_EGRESS);\n",
        "    return ret;\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_store_meta",
        "edt_set_aggregate",
        "ep_tail_call",
        "send_trace_notify",
        "validate_ethertype"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        {
          "description": " Handle egress traffic  ",
          "author": "Yihe Bi",
          "authorEmail": "ybi@bu.edu",
          "date": "2023-02-24"
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "handle_to_container": [
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 2120,
      "endLine": 2195,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_lxc.c",
      "funcName": "handle_to_container",
      "developer_inline_comments": [
        {
          "start_line": 2116,
          "end_line": 2118,
          "text": "/* Attached to the lxc device on the way to the container, only if endpoint\n * routes are enabled.\n */"
        },
        {
          "start_line": 2148,
          "end_line": 2155,
          "text": "/* If the packet comes from the hostns and per-endpoint routes are enabled,\n\t * jump to bpf_host to enforce egress host policies before anything else.\n\t *\n\t * We will jump back to bpf_lxc once host policies are enforced. Whenever\n\t * we call inherit_identity_from_host, the packet mark is cleared. Thus,\n\t * when we jump back, the packet mark will have been cleared and the\n\t * identity won't match HOST_ID anymore.\n\t */"
        },
        {
          "start_line": 2162,
          "end_line": 2162,
          "text": "/* ENABLE_HOST_FIREWALL && !ENABLE_ROUTING */"
        },
        {
          "start_line": 2177,
          "end_line": 2177,
          "text": "/* ENABLE_IPV6 */"
        },
        {
          "start_line": 2183,
          "end_line": 2183,
          "text": "/* ENABLE_IPV4 */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "int",
      "helper": [
        "CTX_ACT_OK",
        "tail_call"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "int handle_to_container (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    enum trace_point trace = TRACE_FROM_STACK;\n",
        "    __u32 magic, identity = 0;\n",
        "    __u16 proto;\n",
        "    int ret;\n",
        "    if (!validate_ethertype (ctx, &proto)) {\n",
        "        ret = DROP_UNSUPPORTED_L2;\n",
        "        goto out;\n",
        "    }\n",
        "    bpf_clear_meta (ctx);\n",
        "    magic = inherit_identity_from_host (ctx, & identity);\n",
        "    if (magic == MARK_MAGIC_PROXY_INGRESS || magic == MARK_MAGIC_PROXY_EGRESS)\n",
        "        trace = TRACE_FROM_PROXY;\n",
        "\n",
        "#if defined(ENABLE_L7_LB)\n",
        "    else if (magic == MARK_MAGIC_PROXY_EGRESS_EPID) {\n",
        "        tail_call_dynamic (ctx, &POLICY_EGRESSCALL_MAP, identity);\n",
        "        return DROP_MISSED_TAIL_CALL;\n",
        "    }\n",
        "\n",
        "#endif\n",
        "    send_trace_notify (ctx, trace, identity, 0, 0, ctx->ingress_ifindex, TRACE_REASON_UNKNOWN, TRACE_PAYLOAD_LEN);\n",
        "\n",
        "#if defined(ENABLE_HOST_FIREWALL) && !defined(ENABLE_ROUTING)\n",
        "    if (identity == HOST_ID) {\n",
        "        ctx_store_meta (ctx, CB_FROM_HOST, 1);\n",
        "        ctx_store_meta (ctx, CB_DST_ENDPOINT_ID, LXC_ID);\n",
        "        tail_call_static (ctx, &POLICY_CALL_MAP, HOST_EP_ID);\n",
        "        return DROP_MISSED_TAIL_CALL;\n",
        "    }\n",
        "\n",
        "#endif /* ENABLE_HOST_FIREWALL && !ENABLE_ROUTING */\n",
        "    ctx_store_meta (ctx, CB_SRC_LABEL, identity);\n",
        "    switch (proto) {\n",
        "\n",
        "#if defined(ENABLE_ARP_PASSTHROUGH) || defined(ENABLE_ARP_RESPONDER)\n",
        "    case bpf_htons (ETH_P_ARP) :\n",
        "        ret = CTX_ACT_OK;\n",
        "        break;\n",
        "\n",
        "#endif\n",
        "\n",
        "#ifdef ENABLE_IPV6\n",
        "    case bpf_htons (ETH_P_IPV6) :\n",
        "        ep_tail_call (ctx, CILIUM_CALL_IPV6_CT_INGRESS);\n",
        "        ret = DROP_MISSED_TAIL_CALL;\n",
        "        break;\n",
        "\n",
        "#endif /* ENABLE_IPV6 */\n",
        "\n",
        "#ifdef ENABLE_IPV4\n",
        "    case bpf_htons (ETH_P_IP) :\n",
        "        ep_tail_call (ctx, CILIUM_CALL_IPV4_CT_INGRESS);\n",
        "        ret = DROP_MISSED_TAIL_CALL;\n",
        "        break;\n",
        "\n",
        "#endif /* ENABLE_IPV4 */\n",
        "    default :\n",
        "        ret = DROP_UNKNOWN_L3;\n",
        "        break;\n",
        "    }\n",
        "out :\n",
        "    if (IS_ERR (ret))\n",
        "        return send_drop_notify (ctx, identity, SECLABEL, LXC_ID, ret, CTX_ACT_DROP, METRIC_INGRESS);\n",
        "    return ret;\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_store_meta",
        "bpf_clear_meta",
        "tail_call_static",
        "ep_tail_call",
        "send_trace_notify",
        "validate_ethertype",
        "inherit_identity_from_host",
        "tail_call_dynamic"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        {
          "description": " handle ingress policy by checking it's source and destination stored in ctx buffer. Check identity and drop the unsupported and tail calls. ",
          "author": "Yihe Bi",
          "authorEmail": "ybi@bu.edu",
          "date": "2023-02-24"
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "is_v4_loopback": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 27,
      "endLine": 31,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c",
      "funcName": "is_v4_loopback",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": "// SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)"
        },
        {
          "start_line": 2,
          "end_line": 2,
          "text": "/* Copyright Authors of Cilium */"
        },
        {
          "start_line": 29,
          "end_line": 29,
          "text": "/* Check for 127.0.0.0/8 range, RFC3330. */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "__be32 daddr"
      ],
      "output": "static__always_inline__maybe_unusedbool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused bool is_v4_loopback (__be32 daddr)\n",
        "{\n",
        "    return (daddr & bpf_htonl (0x7f000000)) == bpf_htonl (0x7f000000);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "is_v6_loopback": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 33,
      "endLine": 39,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c",
      "funcName": "is_v6_loopback",
      "developer_inline_comments": [
        {
          "start_line": 35,
          "end_line": 35,
          "text": "/* Check for ::1/128, RFC4291. */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const union v6addr *daddr"
      ],
      "output": "static__always_inline__maybe_unusedbool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused bool is_v6_loopback (const union v6addr *daddr)\n",
        "{\n",
        "    union v6addr loopback = {\n",
        "        .addr [15] = 1,}\n",
        "    ;\n",
        "    return ipv6_addrcmp (&loopback, daddr) == 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "ipv6_addrcmp"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ctx_dst_port": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 42,
      "endLine": 48,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c",
      "funcName": "ctx_dst_port",
      "developer_inline_comments": [
        {
          "start_line": 41,
          "end_line": 41,
          "text": "/* Hack due to missing narrow ctx access. */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct bpf_sock_addr *ctx"
      ],
      "output": "static__always_inline__maybe_unused__be16",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused __be16 ctx_dst_port (const struct bpf_sock_addr *ctx)\n",
        "{\n",
        "    volatile __u32 dport = ctx->user_port;\n",
        "    return (__be16) dport;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ctx_src_port": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 50,
      "endLine": 56,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c",
      "funcName": "ctx_src_port",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct bpf_sock *ctx"
      ],
      "output": "static__always_inline__maybe_unused__be16",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused __be16 ctx_src_port (const struct bpf_sock *ctx)\n",
        "{\n",
        "    volatile __u16 sport = (__u16) ctx->src_port;\n",
        "    return (__be16) bpf_htons (sport);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ctx_set_port": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 58,
      "endLine": 62,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c",
      "funcName": "ctx_set_port",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct bpf_sock_addr *ctx",
        " __be16 dport"
      ],
      "output": "static__always_inline__maybe_unusedvoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused void ctx_set_port (struct bpf_sock_addr *ctx, __be16 dport)\n",
        "{\n",
        "    ctx->user_port = (__u32) dport;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "task_in_extended_hostns": [
    {
      "capabilities": [
        {
          "capability": "read_sys_info",
          "read_sys_info": [
            {
              "Project": "cilium",
              "Return Type": "u32",
              "Description": "Retrieve the classid for the current task , i. e. for the net_cls cgroup to which <[ skb ]>(IP: 0) belongs. This helper can be used on TC egress path , but not on ingress. The net_cls cgroup provides an interface to tag network packets based on a user-provided identifier for all traffic coming from the tasks belonging to the related cgroup. See also the related kernel documentation , available from the Linux sources in file Documentation/admin-guide/cgroup-v1/net_cls. rst. The Linux kernel has two versions for cgroups: there are cgroups v1 and cgroups v2. Both are available to users , who can use a mixture of them , but note that the net_cls cgroup is for cgroup v1 only. This makes it incompatible with BPF programs run on cgroups , which is a cgroup-v2-only feature (a socket can only hold data for one version of cgroups at a time). This helper is only available is the kernel was compiled with the CONFIG_CGROUP_NET_CLASSID configuration option set to \"y\" or to \"m\" ",
              "Return": " The classid, or 0 for the default unconfigured classid.",
              "Function Name": "get_cgroup_classid",
              "Input Params": [
                "{Type: struct sk_buff ,Var: *skb}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "lwt_seg6local"
              ],
              "capabilities": [
                "read_sys_info"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 64,
      "endLine": 72,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c",
      "funcName": "task_in_extended_hostns",
      "developer_inline_comments": [
        {
          "start_line": 67,
          "end_line": 67,
          "text": "/* Extension for non-Cilium managed containers on MKE. */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void"
      ],
      "output": "static__always_inline__maybe_unusedbool",
      "helper": [
        "get_cgroup_classid"
      ],
      "compatibleHookpoints": [
        "lwt_seg6local",
        "sched_act",
        "lwt_xmit",
        "sched_cls",
        "lwt_in",
        "lwt_out"
      ],
      "source": [
        "static __always_inline __maybe_unused bool task_in_extended_hostns (void)\n",
        "{\n",
        "\n",
        "#ifdef ENABLE_MKE\n",
        "    return get_cgroup_classid () == MKE_HOST;\n",
        "\n",
        "#else\n",
        "    return false;\n",
        "\n",
        "#endif\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ctx_in_hostns": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 74,
      "endLine": 89,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c",
      "funcName": "ctx_in_hostns",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void * ctx __maybe_unused",
        " __net_cookie *cookie"
      ],
      "output": "static__always_inline__maybe_unusedbool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused bool ctx_in_hostns (void * ctx __maybe_unused, __net_cookie *cookie)\n",
        "{\n",
        "\n",
        "#ifdef BPF_HAVE_NETNS_COOKIE\n",
        "    __net_cookie own_cookie = get_netns_cookie (ctx);\n",
        "    if (cookie)\n",
        "        *cookie = own_cookie;\n",
        "    return own_cookie == HOST_NETNS_COOKIE || task_in_extended_hostns ();\n",
        "\n",
        "#else\n",
        "    if (cookie)\n",
        "        *cookie = 0;\n",
        "    return true;\n",
        "\n",
        "#endif\n",
        "}\n"
      ],
      "called_function_list": [
        "task_in_extended_hostns"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "sock_local_cookie": [
    {
      "capabilities": [
        {
          "capability": "read_sys_info",
          "read_sys_info": [
            {
              "Project": "cilium",
              "Return Type": "u32",
              "Description": "Get a pseudo-random number. From a security point of view , this helper uses its own pseudo-random internal state , and cannot be used to infer the seed of other random functions in the kernel. However , it is essential to note that the generator used by the helper is not cryptographically secure. ",
              "Return": " A random 32-bit unsigned value.",
              "Function Name": "get_prandom_u32",
              "Input Params": [
                "{Type: voi ,Var: void}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "read_sys_info"
              ]
            },
            {
              "Project": "cilium",
              "Return Type": "u64",
              "Description": "Equivalent to get_socket_cookie() helper that accepts skb , but gets socket from struct sock_ops context. ",
              "Return": " A 8-byte long non-decreasing number.",
              "Function Name": "get_socket_cookie",
              "Input Params": [
                "{Type: struct sock_ops ,Var: *ctx}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "sched_cls",
                "sched_act",
                "cgroup_skb",
                "sock_ops",
                "sk_skb",
                "cgroup_sock_addr"
              ],
              "capabilities": [
                "read_sys_info"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 91,
      "endLine": 119,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c",
      "funcName": "sock_local_cookie",
      "developer_inline_comments": [
        {
          "start_line": 95,
          "end_line": 114,
          "text": "/* prandom() breaks down on UDP, hence preference is on\n\t * socket cookie as built-in selector. On older kernels,\n\t * get_socket_cookie() provides a unique per netns cookie\n\t * for the life-time of the socket. For newer kernels this\n\t * is fixed to be a unique system _global_ cookie. Older\n\t * kernels could have a cookie collision when two pods with\n\t * different netns talk to same service backend, but that\n\t * is fine since we always reverse translate to the same\n\t * service IP/port pair. The only case that could happen\n\t * for older kernels is that we have a cookie collision\n\t * where one pod talks to the service IP/port and the\n\t * other pod talks to that same specific backend IP/port\n\t * directly _w/o_ going over service IP/port. Then the\n\t * reverse sock addr is translated to the service IP/port.\n\t * With a global socket cookie this collision cannot take\n\t * place. There, only the even more unlikely case could\n\t * happen where the same UDP socket talks first to the\n\t * service and then to the same selected backend IP/port\n\t * directly which can be considered negligible.\n\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct bpf_sock_addr *ctx"
      ],
      "output": "static__always_inline__maybe_unused__sock_cookie",
      "helper": [
        "get_prandom_u32",
        "get_socket_cookie"
      ],
      "compatibleHookpoints": [
        "cgroup_skb",
        "cgroup_sock_addr",
        "socket_filter",
        "sched_act",
        "sk_skb",
        "sched_cls",
        "sock_ops"
      ],
      "source": [
        "static __always_inline __maybe_unused __sock_cookie sock_local_cookie (struct bpf_sock_addr *ctx)\n",
        "{\n",
        "\n",
        "#ifdef BPF_HAVE_SOCKET_COOKIE\n",
        "    return get_socket_cookie (ctx);\n",
        "\n",
        "#else\n",
        "    return ctx->protocol == IPPROTO_TCP ? get_prandom_u32 () : 0;\n",
        "\n",
        "#endif\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "sock_is_health_check": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 121,
      "endLine": 131,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c",
      "funcName": "sock_is_health_check",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct bpf_sock_addr * ctx __maybe_unused"
      ],
      "output": "static__always_inline__maybe_unusedbool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused bool sock_is_health_check (struct bpf_sock_addr * ctx __maybe_unused)\n",
        "{\n",
        "\n",
        "#ifdef ENABLE_HEALTH_CHECK\n",
        "    int val;\n",
        "    if (!get_socket_opt (ctx, SOL_SOCKET, SO_MARK, &val, sizeof (val)))\n",
        "        return val == MARK_MAGIC_HEALTH;\n",
        "\n",
        "#endif\n",
        "    return false;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "sock_select_slot": [
    {
      "capabilities": [
        {
          "capability": "read_sys_info",
          "read_sys_info": [
            {
              "Project": "cilium",
              "Return Type": "u32",
              "Description": "Get a pseudo-random number. From a security point of view , this helper uses its own pseudo-random internal state , and cannot be used to infer the seed of other random functions in the kernel. However , it is essential to note that the generator used by the helper is not cryptographically secure. ",
              "Return": " A random 32-bit unsigned value.",
              "Function Name": "get_prandom_u32",
              "Input Params": [
                "{Type: voi ,Var: void}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "read_sys_info"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 133,
      "endLine": 138,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c",
      "funcName": "sock_select_slot",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct bpf_sock_addr *ctx"
      ],
      "output": "static__always_inline__maybe_unused__u64",
      "helper": [
        "get_prandom_u32"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused __u64 sock_select_slot (struct bpf_sock_addr *ctx)\n",
        "{\n",
        "    return ctx->protocol == IPPROTO_TCP ? get_prandom_u32 () : sock_local_cookie (ctx);\n",
        "}\n"
      ],
      "called_function_list": [
        "sock_local_cookie"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "sock_proto_enabled": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 140,
      "endLine": 156,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c",
      "funcName": "sock_proto_enabled",
      "developer_inline_comments": [
        {
          "start_line": 147,
          "end_line": 147,
          "text": "/* ENABLE_SOCKET_LB_TCP */"
        },
        {
          "start_line": 152,
          "end_line": 152,
          "text": "/* ENABLE_SOCKET_LB_UDP */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "__u32 proto"
      ],
      "output": "static__always_inline__maybe_unusedbool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused bool sock_proto_enabled (__u32 proto)\n",
        "{\n",
        "    switch (proto) {\n",
        "\n",
        "#ifdef ENABLE_SOCKET_LB_TCP\n",
        "    case IPPROTO_TCP :\n",
        "        return true;\n",
        "\n",
        "#endif /* ENABLE_SOCKET_LB_TCP */\n",
        "\n",
        "#ifdef ENABLE_SOCKET_LB_UDP\n",
        "    case IPPROTO_UDPLITE :\n",
        "    case IPPROTO_UDP :\n",
        "        return true;\n",
        "\n",
        "#endif /* ENABLE_SOCKET_LB_UDP */\n",
        "    default :\n",
        "        return false;\n",
        "    }\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "sock4_update_revnat": [
    {
      "capabilities": [
        {
          "capability": "map_update",
          "map_update": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "map_update_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}",
                "{Type:  const void ,Var: *value}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_update"
              ]
            }
          ]
        },
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 168,
      "endLine": 190,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c",
      "funcName": "sock4_update_revnat",
      "developer_inline_comments": [],
      "updateMaps": [
        " LB4_REVERSE_NAT_SK_MAP"
      ],
      "readMaps": [
        "  LB4_REVERSE_NAT_SK_MAP"
      ],
      "input": [
        "struct bpf_sock_addr *ctx",
        " const struct lb4_backend *backend",
        " const struct lb4_key *orig_key",
        " __u16 rev_nat_id"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "map_update_elem",
        "map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int sock4_update_revnat (struct bpf_sock_addr *ctx, const struct lb4_backend *backend, const struct lb4_key *orig_key, __u16 rev_nat_id)\n",
        "{\n",
        "    struct ipv4_revnat_entry val = {}, *tmp;\n",
        "    struct ipv4_revnat_tuple key = {}\n",
        "    ;\n",
        "    int ret = 0;\n",
        "    key.cookie = sock_local_cookie (ctx);\n",
        "    key.address = backend->address;\n",
        "    key.port = backend->port;\n",
        "    val.address = orig_key->address;\n",
        "    val.port = orig_key->dport;\n",
        "    val.rev_nat_index = rev_nat_id;\n",
        "    tmp = map_lookup_elem (& LB4_REVERSE_NAT_SK_MAP, & key);\n",
        "    if (!tmp || memcmp (tmp, &val, sizeof (val)))\n",
        "        ret = map_update_elem (&LB4_REVERSE_NAT_SK_MAP, &key, &val, 0);\n",
        "    return ret;\n",
        "}\n"
      ],
      "called_function_list": [
        "sock_local_cookie",
        "memcmp"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 192,
      "endLine": 199,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c",
      "funcName": "sock4_update_revnat",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct bpf_sock_addr * ctx __maybe_unused",
        " struct lb4_backend * backend __maybe_unused",
        " struct lb4_key * orig_key __maybe_unused",
        " __u16 rev_nat_id __maybe_unused"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int sock4_update_revnat (struct bpf_sock_addr * ctx __maybe_unused, struct lb4_backend * backend __maybe_unused, struct lb4_key * orig_key __maybe_unused, __u16 rev_nat_id __maybe_unused)\n",
        "{\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "sock_local_cookie",
        "memcmp"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "sock4_skip_xlate": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 202,
      "endLine": 218,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c",
      "funcName": "sock4_skip_xlate",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct lb4_service *svc",
        " __be32 address"
      ],
      "output": "static__always_inlinebool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline bool sock4_skip_xlate (struct lb4_service *svc, __be32 address)\n",
        "{\n",
        "    if (lb4_to_lb6_service (svc))\n",
        "        return true;\n",
        "    if (lb4_svc_is_external_ip (svc) || (lb4_svc_is_hostport (svc) && !is_v4_loopback (address))) {\n",
        "        struct remote_endpoint_info *info;\n",
        "        info = ipcache_lookup4 (& IPCACHE_MAP, address, V4_CACHE_KEY_LEN);\n",
        "        if (info == NULL || info->sec_label != HOST_ID)\n",
        "            return true;\n",
        "    }\n",
        "    return false;\n",
        "}\n"
      ],
      "called_function_list": [
        "lb4_svc_is_external_ip",
        "ipcache_lookup4",
        "is_v4_loopback",
        "lb4_to_lb6_service",
        "lb4_svc_is_hostport"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "sock4_wildcard_lookup": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 221,
      "endLine": 251,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c",
      "funcName": "sock4_wildcard_lookup",
      "developer_inline_comments": [
        {
          "start_line": 235,
          "end_line": 238,
          "text": "/* When connecting to node port services in our cluster that\n\t * have either {REMOTE_NODE,HOST}_ID or loopback address, we\n\t * do a wild-card lookup with IP of 0.\n\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct lb4_key * key __maybe_unused",
        " const bool include_remote_hosts __maybe_unused",
        " const bool inv_match __maybe_unused",
        " const bool in_hostns __maybe_unused"
      ],
      "output": "static__always_inlinestructlb4_service",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline struct lb4_service *sock4_wildcard_lookup (struct lb4_key * key __maybe_unused, const bool include_remote_hosts __maybe_unused, const bool inv_match __maybe_unused, const bool in_hostns __maybe_unused)\n",
        "{\n",
        "    struct remote_endpoint_info *info;\n",
        "    __u16 service_port;\n",
        "    service_port = bpf_ntohs (key -> dport);\n",
        "    if ((service_port < NODEPORT_PORT_MIN || service_port > NODEPORT_PORT_MAX) ^ inv_match)\n",
        "        return NULL;\n",
        "    if (in_hostns && is_v4_loopback (key->address))\n",
        "        goto wildcard_lookup;\n",
        "    info = ipcache_lookup4 (& IPCACHE_MAP, key -> address, V4_CACHE_KEY_LEN);\n",
        "    if (info != NULL && (info->sec_label == HOST_ID || (include_remote_hosts && identity_is_remote_node (info->sec_label))))\n",
        "        goto wildcard_lookup;\n",
        "    return NULL;\n",
        "wildcard_lookup :\n",
        "    key->address = 0;\n",
        "    return lb4_lookup_service (key, true);\n",
        "}\n"
      ],
      "called_function_list": [
        "ipcache_lookup4",
        "is_v4_loopback",
        "lb4_lookup_service",
        "identity_is_remote_node"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "sock4_wildcard_lookup_full": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 254,
      "endLine": 272,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c",
      "funcName": "sock4_wildcard_lookup_full",
      "developer_inline_comments": [
        {
          "start_line": 270,
          "end_line": 270,
          "text": "/* ENABLE_NODEPORT */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct lb4_key * key __maybe_unused",
        " const bool in_hostns __maybe_unused"
      ],
      "output": "static__always_inlinestructlb4_service",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline struct lb4_service *sock4_wildcard_lookup_full (struct lb4_key * key __maybe_unused, const bool in_hostns __maybe_unused)\n",
        "{\n",
        "    struct lb4_service *svc = NULL;\n",
        "\n",
        "#ifdef ENABLE_NODEPORT\n",
        "    svc = sock4_wildcard_lookup (key, true, false, in_hostns);\n",
        "    if (svc && !lb4_svc_is_nodeport (svc))\n",
        "        svc = NULL;\n",
        "    if (!svc) {\n",
        "        svc = sock4_wildcard_lookup (key, false, true, in_hostns);\n",
        "        if (svc && !lb4_svc_is_hostport (svc))\n",
        "            svc = NULL;\n",
        "    }\n",
        "\n",
        "#endif /* ENABLE_NODEPORT */\n",
        "    return svc;\n",
        "}\n"
      ],
      "called_function_list": [
        "lb4_svc_is_hostport",
        "lb4_svc_is_nodeport",
        "sock4_wildcard_lookup"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "sock4_skip_xlate_if_same_netns": [
    {
      "capabilities": [
        {
          "capability": "read_sys_info",
          "read_sys_info": [
            {
              "Project": "cilium",
              "Return Type": "struct sock*",
              "Description": "Look for TCP socket matching <[ tuple ]>(IP: 1) , optionally in a child network namespace netns. The return value must be checked , and if non-NULL , released via sk_release(). The <[ ctx ]>(IP: 0) should point to the context of the program , such as the skb or socket (depending on the hook in use). This is used to determine the base network namespace for the lookup. <[ tuple_size ]>(IP: 2) must be one of: sizeof(tuple->ipv4) Look for an IPv4 socket. sizeof(tuple->ipv6) Look for an IPv6 socket. If the <[ netns ]>(IP: 3) is a negative signed 32-bit integer , then the socket lookup table in the <[ netns ]>(IP: 3) associated with the <[ ctx ]>(IP: 0) will will be used. For the TC hooks , this is the <[ netns ]>(IP: 3) of the device in the skb. For socket hooks , this is the <[ netns ]>(IP: 3) of the socket. If <[ netns ]>(IP: 3) is any other signed 32-bit value greater than or equal to zero then it specifies the ID of the <[ netns ]>(IP: 3) relative to the <[ netns ]>(IP: 3) associated with the ctx. <[ netns ]>(IP: 3) values beyond the range of 32-bit integers are reserved for future use. All values for <[ flags ]>(IP: 4) are reserved for future usage , and must be left at zero. This helper is available only if the kernel was compiled with CONFIG_NET configuration option. ",
              "Return": " Pointer to struct  sock, or NULL in case of failure.   For  sockets  with                     reuseport  option,  the  struct  sock result is from reuse->socks[] using                     the hash of the tuple.",
              "Function Name": "sk_lookup_tcp",
              "Input Params": [
                "{Type: void ,Var: *ctx}",
                "{Type:  struct sock_tuple ,Var: *tuple}",
                "{Type:  u32 ,Var: tuple_size}",
                "{Type:  u64 ,Var: netns}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "xdp",
                "sk_skb",
                "cgroup_sock_addr"
              ],
              "capabilities": [
                "read_sys_info"
              ]
            },
            {
              "Project": "cilium",
              "Return Type": "struct sock*",
              "Description": "Look for UDP socket matching <[ tuple ]>(IP: 1) , optionally in a child network namespace netns. The return value must be checked , and if non-NULL , released via sk_release(). The <[ ctx ]>(IP: 0) should point to the context of the program , such as the skb or socket (depending on the hook in use). This is used to determine the base network namespace for the lookup. <[ tuple_size ]>(IP: 2) must be one of: sizeof(tuple->ipv4) Look for an IPv4 socket. sizeof(tuple->ipv6) Look for an IPv6 socket. If the <[ netns ]>(IP: 3) is a negative signed 32-bit integer , then the socket lookup table in the <[ netns ]>(IP: 3) associated with the <[ ctx ]>(IP: 0) will will be used. For the TC hooks , this is the <[ netns ]>(IP: 3) of the device in the skb. For socket hooks , this is the <[ netns ]>(IP: 3) of the socket. If <[ netns ]>(IP: 3) is any other signed 32-bit value greater than or equal to zero then it specifies the ID of the <[ netns ]>(IP: 3) relative to the <[ netns ]>(IP: 3) associated with the ctx. <[ netns ]>(IP: 3) values beyond the range of 32-bit integers are reserved for future use. All values for <[ flags ]>(IP: 4) are reserved for future usage , and must be left at zero. This helper is available only if the kernel was compiled with CONFIG_NET configuration option. ",
              "Return": " Pointer  to  struct  sock, or NULL in case of failure.  For sockets with                     reuseport option, the struct  sock result is  from  reuse->socks[]  using                     the hash of the tuple.",
              "Function Name": "sk_lookup_udp",
              "Input Params": [
                "{Type: void ,Var: *ctx}",
                "{Type:  struct sock_tuple ,Var: *tuple}",
                "{Type:  u32 ,Var: tuple_size}",
                "{Type:  u64 ,Var: netns}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "xdp",
                "sk_skb",
                "cgroup_sock_addr"
              ],
              "capabilities": [
                "read_sys_info"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 293,
      "endLine": 321,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c",
      "funcName": "sock4_skip_xlate_if_same_netns",
      "developer_inline_comments": [
        {
          "start_line": 274,
          "end_line": 292,
          "text": "/* Service translation logic for a local-redirect service can cause packets to\n * be looped back to a service node-local backend after translation. This can\n * happen when the node-local backend itself tries to connect to the service\n * frontend for which it acts as a backend. There are cases where this can break\n * traffic flow if the backend needs to forward the redirected traffic to the\n * actual service frontend. Hence, allow service translation for pod traffic\n * getting redirected to backend (across network namespaces), but skip service\n * translation for backend to itself or another service backend within the same\n * namespace. Currently only v4 and v4-in-v6, but no plain v6 is supported.\n *\n * For example, in EKS cluster, a local-redirect service exists with the AWS\n * metadata IP, port as the frontend <169.254.169.254, 80> and kiam proxy as a\n * backend Pod. When traffic destined to the frontend originates from the kiam\n * Pod in namespace ns1 (host ns when the kiam proxy Pod is deployed in\n * hostNetwork mode or regular Pod ns) and the Pod is selected as a backend, the\n * traffic would get looped back to the proxy Pod. Identify such cases by doing\n * a socket lookup for the backend <ip, port> in its namespace, ns1, and skip\n * service translation.\n */"
        },
        {
          "start_line": 319,
          "end_line": 319,
          "text": "/* BPF_HAVE_SOCKET_LOOKUP */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct bpf_sock_addr * ctx __maybe_unused",
        " const struct lb4_backend * backend __maybe_unused"
      ],
      "output": "static__always_inlinebool",
      "helper": [
        "sk_lookup_tcp",
        "sk_lookup_udp",
        "sk_release"
      ],
      "compatibleHookpoints": [
        "cgroup_sock_addr",
        "sched_act",
        "xdp",
        "sk_skb",
        "sched_cls"
      ],
      "source": [
        "static __always_inline bool sock4_skip_xlate_if_same_netns (struct bpf_sock_addr * ctx __maybe_unused, const struct lb4_backend * backend __maybe_unused)\n",
        "{\n",
        "\n",
        "#ifdef BPF_HAVE_SOCKET_LOOKUP\n",
        "    struct bpf_sock_tuple tuple = {\n",
        "        .ipv4.daddr = backend->address,\n",
        "        .ipv4.dport = backend->port,}\n",
        "    ;\n",
        "    struct bpf_sock *sk = NULL;\n",
        "    switch (ctx->protocol) {\n",
        "    case IPPROTO_TCP :\n",
        "        sk = sk_lookup_tcp (ctx, &tuple, sizeof (tuple.ipv4), BPF_F_CURRENT_NETNS, 0);\n",
        "        break;\n",
        "    case IPPROTO_UDP :\n",
        "        sk = sk_lookup_udp (ctx, &tuple, sizeof (tuple.ipv4), BPF_F_CURRENT_NETNS, 0);\n",
        "        break;\n",
        "    }\n",
        "    if (sk) {\n",
        "        sk_release (sk);\n",
        "        return true;\n",
        "    }\n",
        "\n",
        "#endif /* BPF_HAVE_SOCKET_LOOKUP */\n",
        "    return false;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__sock4_xlate_fwd": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 323,
      "endLine": 458,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c",
      "funcName": "__sock4_xlate_fwd",
      "developer_inline_comments": [
        {
          "start_line": 348,
          "end_line": 351,
          "text": "/* In case a direct match fails, we try to look-up surrogate\n\t * service entries via wildcarded lookup for NodePort and\n\t * HostPort services.\n\t */"
        },
        {
          "start_line": 358,
          "end_line": 363,
          "text": "/* Do not perform service translation for external IPs\n\t * that are not a local address because we don't want\n\t * a k8s service to easily do MITM attacks for a public\n\t * IP address. But do the service translation if the IP\n\t * is from the host.\n\t */"
        },
        {
          "start_line": 368,
          "end_line": 372,
          "text": "/* Do not perform service translation at socker layer for\n\t * services with L7 load balancing as we need to postpone\n\t * policy enforcement to take place after l7 load balancer and\n\t * we can't currently do that from the socket layer.\n\t */"
        },
        {
          "start_line": 374,
          "end_line": 376,
          "text": "/* TC level eBPF datapath does not handle node local traffic,\n\t\t * but we need to redirect for L7 LB also in that case.\n\t\t */"
        },
        {
          "start_line": 378,
          "end_line": 383,
          "text": "/* Use the L7 LB proxy port as a backend. Normally this\n\t\t\t * would cause policy enforcement to be done before the\n\t\t\t * L7 LB (which should not be done), but in this case\n\t\t\t * (node-local nodeport) there is no policy enforcement\n\t\t\t * anyway.\n\t\t\t */"
        },
        {
          "start_line": 391,
          "end_line": 391,
          "text": "/* Let the TC level eBPF datapath redirect to L7 LB. */"
        },
        {
          "start_line": 394,
          "end_line": 394,
          "text": "/* ENABLE_L7_LB */"
        },
        {
          "start_line": 397,
          "end_line": 403,
          "text": "/* Note, for newly created affinity entries there is a\n\t\t * small race window. Two processes on two different\n\t\t * CPUs but the same netns may select different backends\n\t\t * for the same service:port. lb4_update_affinity_by_netns()\n\t\t * below would then override the first created one if it\n\t\t * didn't make it into the lookup yet for the other CPU.\n\t\t */"
        },
        {
          "start_line": 410,
          "end_line": 415,
          "text": "/* Backend from the session affinity no longer\n\t\t\t\t * exists, thus select a new one. Also, remove\n\t\t\t\t * the affinity, so that if the svc doesn't have\n\t\t\t\t * any backend, a subsequent request to the svc\n\t\t\t\t * doesn't hit the reselection again.\n\t\t\t\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct bpf_sock_addr *ctx",
        " struct bpf_sock_addr *ctx_full",
        " const bool udp_only"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int __sock4_xlate_fwd (struct bpf_sock_addr *ctx, struct bpf_sock_addr *ctx_full, const bool udp_only)\n",
        "{\n",
        "    union lb4_affinity_client_id id;\n",
        "    const bool in_hostns = ctx_in_hostns (ctx_full, & id.client_cookie);\n",
        "    struct lb4_backend *backend;\n",
        "    struct lb4_service *svc;\n",
        "    struct lb4_key key = {\n",
        "        .address = ctx->user_ip4,\n",
        "        .dport = ctx_dst_port (ctx),}, orig_key = key;\n",
        "    struct lb4_service *backend_slot;\n",
        "    bool backend_from_affinity = false;\n",
        "    __u32 backend_id = 0;\n",
        "\n",
        "#ifdef ENABLE_L7_LB\n",
        "    struct lb4_backend l7backend;\n",
        "\n",
        "#endif\n",
        "    if (is_defined (ENABLE_SOCKET_LB_HOST_ONLY) && !in_hostns)\n",
        "        return -ENXIO;\n",
        "    if (!udp_only && !sock_proto_enabled (ctx->protocol))\n",
        "        return -ENOTSUP;\n",
        "    svc = lb4_lookup_service (& key, true);\n",
        "    if (!svc)\n",
        "        svc = sock4_wildcard_lookup_full (&key, in_hostns);\n",
        "    if (!svc)\n",
        "        return -ENXIO;\n",
        "    if (sock4_skip_xlate (svc, orig_key.address))\n",
        "        return -EPERM;\n",
        "\n",
        "#ifdef ENABLE_L7_LB\n",
        "    if (lb4_svc_is_l7loadbalancer (svc)) {\n",
        "        if (is_defined (BPF_HAVE_NETNS_COOKIE) && in_hostns) {\n",
        "            l7backend.address = bpf_htonl (0x7f000001);\n",
        "            l7backend.port = (__be16) svc->l7_lb_proxy_port;\n",
        "            l7backend.proto = 0;\n",
        "            l7backend.flags = 0;\n",
        "            backend = &l7backend;\n",
        "            goto out;\n",
        "        }\n",
        "        return 0;\n",
        "    }\n",
        "\n",
        "#endif /* ENABLE_L7_LB */\n",
        "    if (lb4_svc_is_affinity (svc)) {\n",
        "        backend_id = lb4_affinity_backend_id_by_netns (svc, & id);\n",
        "        backend_from_affinity = true;\n",
        "        if (backend_id != 0) {\n",
        "            backend = __lb4_lookup_backend (backend_id);\n",
        "            if (!backend)\n",
        "                backend_id = 0;\n",
        "        }\n",
        "    }\n",
        "    if (backend_id == 0) {\n",
        "        backend_from_affinity = false;\n",
        "        key.backend_slot = (sock_select_slot (ctx_full) % svc->count) + 1;\n",
        "        backend_slot = __lb4_lookup_backend_slot (& key);\n",
        "        if (!backend_slot) {\n",
        "            update_metrics (0, METRIC_EGRESS, REASON_LB_NO_BACKEND_SLOT);\n",
        "            return -ENOENT;\n",
        "        }\n",
        "        backend_id = backend_slot->backend_id;\n",
        "        backend = __lb4_lookup_backend (backend_id);\n",
        "    }\n",
        "    if (!backend) {\n",
        "        update_metrics (0, METRIC_EGRESS, REASON_LB_NO_BACKEND);\n",
        "        return -ENOENT;\n",
        "    }\n",
        "    if (lb4_svc_is_localredirect (svc) && sock4_skip_xlate_if_same_netns (ctx_full, backend))\n",
        "        return -ENXIO;\n",
        "    if (lb4_svc_is_affinity (svc) && !backend_from_affinity)\n",
        "        lb4_update_affinity_by_netns (svc, &id, backend_id);\n",
        "\n",
        "#ifdef ENABLE_L7_LB\n",
        "out :\n",
        "\n",
        "#endif\n",
        "    if (sock4_update_revnat (ctx_full, backend, &orig_key, svc->rev_nat_index) < 0) {\n",
        "        update_metrics (0, METRIC_EGRESS, REASON_LB_REVNAT_UPDATE);\n",
        "        return -ENOMEM;\n",
        "    }\n",
        "    ctx->user_ip4 = backend->address;\n",
        "    ctx_set_port (ctx, backend->port);\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_dst_port",
        "__lb4_lookup_backend_slot",
        "lb4_svc_is_l7loadbalancer",
        "sock_select_slot",
        "lb4_update_affinity_by_netns",
        "lb4_lookup_service",
        "__lb4_lookup_backend",
        "sock4_skip_xlate_if_same_netns",
        "ctx_set_port",
        "lb4_svc_is_affinity",
        "ctx_in_hostns",
        "update_metrics",
        "sock4_wildcard_lookup_full",
        "sock_proto_enabled",
        "lb4_svc_is_localredirect",
        "lb4_affinity_backend_id_by_netns",
        "sock4_skip_xlate",
        "sock4_update_revnat"
      ],
      "call_depth": 4,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__sock4_health_fwd": [
    {
      "capabilities": [
        {
          "capability": "read_sys_info",
          "read_sys_info": [
            {
              "Project": "cilium",
              "Return Type": "u64",
              "Description": "Equivalent to get_socket_cookie() helper that accepts skb , but gets socket from struct sock_ops context. ",
              "Return": " A 8-byte long non-decreasing number.",
              "Function Name": "get_socket_cookie",
              "Input Params": [
                "{Type: struct sock_ops ,Var: *ctx}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "sched_cls",
                "sched_act",
                "cgroup_skb",
                "sock_ops",
                "sk_skb",
                "cgroup_sock_addr"
              ],
              "capabilities": [
                "read_sys_info"
              ]
            }
          ]
        },
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 460,
      "endLine": 476,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c",
      "funcName": "__sock4_health_fwd",
      "developer_inline_comments": [
        {
          "start_line": 474,
          "end_line": 474,
          "text": "/* ENABLE_HEALTH_CHECK */"
        }
      ],
      "updateMaps": [],
      "readMaps": [
        " LB4_HEALTH_MAP"
      ],
      "input": [
        "struct bpf_sock_addr * ctx __maybe_unused"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "get_socket_cookie",
        "map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "cgroup_skb",
        "cgroup_sock_addr",
        "socket_filter",
        "sched_act",
        "sk_skb",
        "sched_cls",
        "sock_ops"
      ],
      "source": [
        "static __always_inline int __sock4_health_fwd (struct bpf_sock_addr * ctx __maybe_unused)\n",
        "{\n",
        "    int ret = lb_skip_l4_dnat () ? SYS_PROCEED : SYS_REJECT;\n",
        "\n",
        "#ifdef ENABLE_HEALTH_CHECK\n",
        "    __sock_cookie key = get_socket_cookie (ctx);\n",
        "    struct lb4_health *val = NULL;\n",
        "    if (!lb_skip_l4_dnat ())\n",
        "        val = map_lookup_elem (&LB4_HEALTH_MAP, &key);\n",
        "    if (val) {\n",
        "        ctx_set_port (ctx, val->peer.port);\n",
        "        ret = SYS_PROCEED;\n",
        "    }\n",
        "\n",
        "#endif /* ENABLE_HEALTH_CHECK */\n",
        "    return ret;\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_set_port",
        "lb_skip_l4_dnat"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "sock4_connect": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 479,
      "endLine": 486,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c",
      "funcName": "sock4_connect",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct bpf_sock_addr *ctx"
      ],
      "output": "int",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "int sock4_connect (struct bpf_sock_addr *ctx)\n",
        "{\n",
        "    if (sock_is_health_check (ctx))\n",
        "        return __sock4_health_fwd (ctx);\n",
        "    __sock4_xlate_fwd (ctx, ctx, false);\n",
        "    return SYS_PROCEED;\n",
        "}\n"
      ],
      "called_function_list": [
        "__sock4_xlate_fwd",
        "sock_is_health_check",
        "__sock4_health_fwd"
      ],
      "call_depth": 5,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__sock4_post_bind": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 489,
      "endLine": 520,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c",
      "funcName": "__sock4_post_bind",
      "developer_inline_comments": [
        {
          "start_line": 504,
          "end_line": 507,
          "text": "/* Perform a wildcard lookup for the case where the caller\n\t\t * tries to bind to loopback or an address with host identity\n\t\t * (without remote hosts).\n\t\t */"
        },
        {
          "start_line": 510,
          "end_line": 513,
          "text": "/* If the sockaddr of this socket overlaps with a NodePort,\n\t * LoadBalancer or ExternalIP service. We must reject this\n\t * bind() call to avoid accidentally hijacking its traffic.\n\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct bpf_sock *ctx",
        " struct bpf_sock *ctx_full"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int __sock4_post_bind (struct bpf_sock *ctx, struct bpf_sock *ctx_full)\n",
        "{\n",
        "    struct lb4_service *svc;\n",
        "    struct lb4_key key = {\n",
        "        .address = ctx->src_ip4,\n",
        "        .dport = ctx_src_port (ctx),}\n",
        "    ;\n",
        "    if (!sock_proto_enabled (ctx->protocol) || !ctx_in_hostns (ctx_full, NULL))\n",
        "        return 0;\n",
        "    svc = lb4_lookup_service (& key, true);\n",
        "    if (!svc)\n",
        "        svc = sock4_wildcard_lookup (&key, false, false, true);\n",
        "    if (svc && (lb4_svc_is_nodeport (svc) || lb4_svc_is_external_ip (svc) || lb4_svc_is_loadbalancer (svc)))\n",
        "        return -EADDRINUSE;\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "lb4_svc_is_external_ip",
        "sock_proto_enabled",
        "ctx_src_port",
        "lb4_svc_is_nodeport",
        "sock4_wildcard_lookup",
        "lb4_lookup_service",
        "ctx_in_hostns",
        "lb4_svc_is_loadbalancer"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "sock4_post_bind": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 523,
      "endLine": 529,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c",
      "funcName": "sock4_post_bind",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct bpf_sock *ctx"
      ],
      "output": "int",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "int sock4_post_bind (struct bpf_sock *ctx)\n",
        "{\n",
        "    if (__sock4_post_bind (ctx, ctx) < 0)\n",
        "        return SYS_REJECT;\n",
        "    return SYS_PROCEED;\n",
        "}\n"
      ],
      "called_function_list": [
        "__sock4_post_bind"
      ],
      "call_depth": 4,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "sock4_auto_bind": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 533,
      "endLine": 537,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c",
      "funcName": "sock4_auto_bind",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct bpf_sock_addr *ctx"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void sock4_auto_bind (struct bpf_sock_addr *ctx)\n",
        "{\n",
        "    ctx->user_ip4 = 0;\n",
        "    ctx_set_port (ctx, 0);\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_set_port"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__sock4_pre_bind": [
    {
      "capabilities": [
        {
          "capability": "map_update",
          "map_update": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "map_update_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}",
                "{Type:  const void ,Var: *value}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_update"
              ]
            }
          ]
        },
        {
          "capability": "read_sys_info",
          "read_sys_info": [
            {
              "Project": "cilium",
              "Return Type": "u64",
              "Description": "Equivalent to get_socket_cookie() helper that accepts skb , but gets socket from struct sock_ops context. ",
              "Return": " A 8-byte long non-decreasing number.",
              "Function Name": "get_socket_cookie",
              "Input Params": [
                "{Type: struct sock_ops ,Var: *ctx}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "sched_cls",
                "sched_act",
                "cgroup_skb",
                "sock_ops",
                "sk_skb",
                "cgroup_sock_addr"
              ],
              "capabilities": [
                "read_sys_info"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 539,
      "endLine": 559,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c",
      "funcName": "__sock4_pre_bind",
      "developer_inline_comments": [
        {
          "start_line": 542,
          "end_line": 544,
          "text": "/* Code compiled in here guarantees that get_socket_cookie() is\n\t * available and unique on underlying kernel.\n\t */"
        }
      ],
      "updateMaps": [
        "  LB4_HEALTH_MAP"
      ],
      "readMaps": [],
      "input": [
        "struct bpf_sock_addr *ctx",
        " struct bpf_sock_addr *ctx_full"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "map_update_elem",
        "get_socket_cookie"
      ],
      "compatibleHookpoints": [
        "cgroup_skb",
        "cgroup_sock_addr",
        "socket_filter",
        "sched_act",
        "sk_skb",
        "sched_cls",
        "sock_ops"
      ],
      "source": [
        "static __always_inline int __sock4_pre_bind (struct bpf_sock_addr *ctx, struct bpf_sock_addr *ctx_full)\n",
        "{\n",
        "    __sock_cookie key = get_socket_cookie (ctx_full);\n",
        "    struct lb4_health val = {\n",
        "        .peer = {\n",
        "            .address = ctx->user_ip4,\n",
        "            .port = ctx_dst_port (ctx),\n",
        "            .proto = (__u8) ctx->protocol,},}\n",
        "    ;\n",
        "    int ret;\n",
        "    ret = map_update_elem (& LB4_HEALTH_MAP, & key, & val, 0);\n",
        "    if (!ret)\n",
        "        sock4_auto_bind (ctx);\n",
        "    return ret;\n",
        "}\n"
      ],
      "called_function_list": [
        "sock4_auto_bind",
        "ctx_dst_port"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "sock4_pre_bind": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 562,
      "endLine": 573,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c",
      "funcName": "sock4_pre_bind",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct bpf_sock_addr *ctx"
      ],
      "output": "int",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "int sock4_pre_bind (struct bpf_sock_addr *ctx)\n",
        "{\n",
        "    int ret = SYS_PROCEED;\n",
        "    if (!sock_proto_enabled (ctx->protocol) || !ctx_in_hostns (ctx, NULL))\n",
        "        return ret;\n",
        "    if (sock_is_health_check (ctx) && __sock4_pre_bind (ctx, ctx))\n",
        "        ret = SYS_REJECT;\n",
        "    return ret;\n",
        "}\n"
      ],
      "called_function_list": [
        "__sock4_pre_bind",
        "sock_proto_enabled",
        "sock_is_health_check",
        "ctx_in_hostns"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__sock4_xlate_rev": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 577,
      "endLine": 611,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c",
      "funcName": "__sock4_xlate_rev",
      "developer_inline_comments": [],
      "updateMaps": [
        " LB4_REVERSE_NAT_SK_MAP"
      ],
      "readMaps": [
        "  LB4_REVERSE_NAT_SK_MAP"
      ],
      "input": [
        "struct bpf_sock_addr *ctx",
        " struct bpf_sock_addr *ctx_full"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "map_delete_elem",
        "map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int __sock4_xlate_rev (struct bpf_sock_addr *ctx, struct bpf_sock_addr *ctx_full)\n",
        "{\n",
        "    struct ipv4_revnat_entry *val;\n",
        "    struct ipv4_revnat_tuple key = {\n",
        "        .cookie = sock_local_cookie (ctx_full),\n",
        "        .address = ctx->user_ip4,\n",
        "        .port = ctx_dst_port (ctx),}\n",
        "    ;\n",
        "    val = map_lookup_elem (& LB4_REVERSE_NAT_SK_MAP, & key);\n",
        "    if (val) {\n",
        "        struct lb4_service *svc;\n",
        "        struct lb4_key svc_key = {\n",
        "            .address = val->address,\n",
        "            .dport = val->port,}\n",
        "        ;\n",
        "        svc = lb4_lookup_service (& svc_key, true);\n",
        "        if (!svc)\n",
        "            svc = sock4_wildcard_lookup_full (&svc_key, ctx_in_hostns (ctx_full, NULL));\n",
        "        if (!svc || svc->rev_nat_index != val->rev_nat_index) {\n",
        "            map_delete_elem (&LB4_REVERSE_NAT_SK_MAP, &key);\n",
        "            update_metrics (0, METRIC_INGRESS, REASON_LB_REVNAT_STALE);\n",
        "            return -ENOENT;\n",
        "        }\n",
        "        ctx->user_ip4 = val->address;\n",
        "        ctx_set_port (ctx, val->port);\n",
        "        return 0;\n",
        "    }\n",
        "    return -ENXIO;\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_dst_port",
        "ctx_set_port",
        "lb4_lookup_service",
        "ctx_in_hostns",
        "sock_local_cookie",
        "update_metrics",
        "sock4_wildcard_lookup_full"
      ],
      "call_depth": 4,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "sock4_sendmsg": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 614,
      "endLine": 618,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c",
      "funcName": "sock4_sendmsg",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct bpf_sock_addr *ctx"
      ],
      "output": "int",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "int sock4_sendmsg (struct bpf_sock_addr *ctx)\n",
        "{\n",
        "    __sock4_xlate_fwd (ctx, ctx, true);\n",
        "    return SYS_PROCEED;\n",
        "}\n"
      ],
      "called_function_list": [
        "__sock4_xlate_fwd"
      ],
      "call_depth": 5,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "sock4_recvmsg": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 621,
      "endLine": 625,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c",
      "funcName": "sock4_recvmsg",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct bpf_sock_addr *ctx"
      ],
      "output": "int",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "int sock4_recvmsg (struct bpf_sock_addr *ctx)\n",
        "{\n",
        "    __sock4_xlate_rev (ctx, ctx);\n",
        "    return SYS_PROCEED;\n",
        "}\n"
      ],
      "called_function_list": [
        "__sock4_xlate_rev"
      ],
      "call_depth": 5,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "sock4_getpeername": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 628,
      "endLine": 632,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c",
      "funcName": "sock4_getpeername",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct bpf_sock_addr *ctx"
      ],
      "output": "int",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "int sock4_getpeername (struct bpf_sock_addr *ctx)\n",
        "{\n",
        "    __sock4_xlate_rev (ctx, ctx);\n",
        "    return SYS_PROCEED;\n",
        "}\n"
      ],
      "called_function_list": [
        "__sock4_xlate_rev"
      ],
      "call_depth": 5,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "sock6_update_revnat": [
    {
      "capabilities": [
        {
          "capability": "map_update",
          "map_update": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "map_update_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}",
                "{Type:  const void ,Var: *value}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_update"
              ]
            }
          ]
        },
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 647,
      "endLine": 669,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c",
      "funcName": "sock6_update_revnat",
      "developer_inline_comments": [
        {
          "start_line": 634,
          "end_line": 634,
          "text": "/* ENABLE_IPV4 */"
        }
      ],
      "updateMaps": [
        " LB6_REVERSE_NAT_SK_MAP"
      ],
      "readMaps": [
        "  LB6_REVERSE_NAT_SK_MAP"
      ],
      "input": [
        "struct bpf_sock_addr *ctx",
        " const struct lb6_backend *backend",
        " const struct lb6_key *orig_key",
        " __u16 rev_nat_index"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "map_update_elem",
        "map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int sock6_update_revnat (struct bpf_sock_addr *ctx, const struct lb6_backend *backend, const struct lb6_key *orig_key, __u16 rev_nat_index)\n",
        "{\n",
        "    struct ipv6_revnat_entry val = {}, *tmp;\n",
        "    struct ipv6_revnat_tuple key = {}\n",
        "    ;\n",
        "    int ret = 0;\n",
        "    key.cookie = sock_local_cookie (ctx);\n",
        "    key.address = backend->address;\n",
        "    key.port = backend->port;\n",
        "    val.address = orig_key->address;\n",
        "    val.port = orig_key->dport;\n",
        "    val.rev_nat_index = rev_nat_index;\n",
        "    tmp = map_lookup_elem (& LB6_REVERSE_NAT_SK_MAP, & key);\n",
        "    if (!tmp || memcmp (tmp, &val, sizeof (val)))\n",
        "        ret = map_update_elem (&LB6_REVERSE_NAT_SK_MAP, &key, &val, 0);\n",
        "    return ret;\n",
        "}\n"
      ],
      "called_function_list": [
        "sock_local_cookie",
        "memcmp"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 671,
      "endLine": 678,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c",
      "funcName": "sock6_update_revnat",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct bpf_sock_addr * ctx __maybe_unused",
        " struct lb6_backend * backend __maybe_unused",
        " struct lb6_key * orig_key __maybe_unused",
        " __u16 rev_nat_index __maybe_unused"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int sock6_update_revnat (struct bpf_sock_addr * ctx __maybe_unused, struct lb6_backend * backend __maybe_unused, struct lb6_key * orig_key __maybe_unused, __u16 rev_nat_index __maybe_unused)\n",
        "{\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "sock_local_cookie",
        "memcmp"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ctx_get_v6_address": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 682,
      "endLine": 693,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c",
      "funcName": "ctx_get_v6_address",
      "developer_inline_comments": [
        {
          "start_line": 680,
          "end_line": 680,
          "text": "/* ENABLE_IPV6 */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct bpf_sock_addr *ctx",
        " union v6addr *addr"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void ctx_get_v6_address (const struct bpf_sock_addr *ctx, union v6addr *addr)\n",
        "{\n",
        "    addr->p1 = ctx->user_ip6[0];\n",
        "    barrier ();\n",
        "    addr->p2 = ctx->user_ip6[1];\n",
        "    barrier ();\n",
        "    addr->p3 = ctx->user_ip6[2];\n",
        "    barrier ();\n",
        "    addr->p4 = ctx->user_ip6[3];\n",
        "    barrier ();\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ctx_get_v6_src_address": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 696,
      "endLine": 707,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c",
      "funcName": "ctx_get_v6_src_address",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct bpf_sock *ctx",
        " union v6addr *addr"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void ctx_get_v6_src_address (const struct bpf_sock *ctx, union v6addr *addr)\n",
        "{\n",
        "    addr->p1 = ctx->src_ip6[0];\n",
        "    barrier ();\n",
        "    addr->p2 = ctx->src_ip6[1];\n",
        "    barrier ();\n",
        "    addr->p3 = ctx->src_ip6[2];\n",
        "    barrier ();\n",
        "    addr->p4 = ctx->src_ip6[3];\n",
        "    barrier ();\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ctx_set_v6_address": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 710,
      "endLine": 721,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c",
      "funcName": "ctx_set_v6_address",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct bpf_sock_addr *ctx",
        " const union v6addr *addr"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void ctx_set_v6_address (struct bpf_sock_addr *ctx, const union v6addr *addr)\n",
        "{\n",
        "    ctx->user_ip6[0] = addr->p1;\n",
        "    barrier ();\n",
        "    ctx->user_ip6[1] = addr->p2;\n",
        "    barrier ();\n",
        "    ctx->user_ip6[2] = addr->p3;\n",
        "    barrier ();\n",
        "    ctx->user_ip6[3] = addr->p4;\n",
        "    barrier ();\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "sock6_skip_xlate": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 723,
      "endLine": 739,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c",
      "funcName": "sock6_skip_xlate",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct lb6_service *svc",
        " const union v6addr *address"
      ],
      "output": "static__always_inline__maybe_unusedbool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused bool sock6_skip_xlate (struct lb6_service *svc, const union v6addr *address)\n",
        "{\n",
        "    if (lb6_to_lb4_service (svc))\n",
        "        return true;\n",
        "    if (lb6_svc_is_external_ip (svc) || (lb6_svc_is_hostport (svc) && !is_v6_loopback (address))) {\n",
        "        struct remote_endpoint_info *info;\n",
        "        info = ipcache_lookup6 (& IPCACHE_MAP, address, V6_CACHE_KEY_LEN);\n",
        "        if (info == NULL || info->sec_label != HOST_ID)\n",
        "            return true;\n",
        "    }\n",
        "    return false;\n",
        "}\n"
      ],
      "called_function_list": [
        "ipcache_lookup6",
        "lb6_to_lb4_service",
        "lb6_svc_is_external_ip",
        "is_v6_loopback",
        "lb6_svc_is_hostport"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "sock6_wildcard_lookup": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 742,
      "endLine": 772,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c",
      "funcName": "sock6_wildcard_lookup",
      "developer_inline_comments": [
        {
          "start_line": 756,
          "end_line": 759,
          "text": "/* When connecting to node port services in our cluster that\n\t * have either {REMOTE_NODE,HOST}_ID or loopback address, we\n\t * do a wild-card lookup with IP of 0.\n\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct lb6_key * key __maybe_unused",
        " const bool include_remote_hosts __maybe_unused",
        " const bool inv_match __maybe_unused",
        " const bool in_hostns __maybe_unused"
      ],
      "output": "static__always_inline__maybe_unusedstructlb6_service",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused struct lb6_service *sock6_wildcard_lookup (struct lb6_key * key __maybe_unused, const bool include_remote_hosts __maybe_unused, const bool inv_match __maybe_unused, const bool in_hostns __maybe_unused)\n",
        "{\n",
        "    struct remote_endpoint_info *info;\n",
        "    __u16 service_port;\n",
        "    service_port = bpf_ntohs (key -> dport);\n",
        "    if ((service_port < NODEPORT_PORT_MIN || service_port > NODEPORT_PORT_MAX) ^ inv_match)\n",
        "        return NULL;\n",
        "    if (in_hostns && is_v6_loopback (&key->address))\n",
        "        goto wildcard_lookup;\n",
        "    info = ipcache_lookup6 (& IPCACHE_MAP, & key -> address, V6_CACHE_KEY_LEN);\n",
        "    if (info != NULL && (info->sec_label == HOST_ID || (include_remote_hosts && identity_is_remote_node (info->sec_label))))\n",
        "        goto wildcard_lookup;\n",
        "    return NULL;\n",
        "wildcard_lookup :\n",
        "    memset (&key->address, 0, sizeof (key->address));\n",
        "    return lb6_lookup_service (key, true);\n",
        "}\n"
      ],
      "called_function_list": [
        "memset",
        "ipcache_lookup6",
        "lb6_lookup_service",
        "is_v6_loopback",
        "identity_is_remote_node"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "sock6_wildcard_lookup_full": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 775,
      "endLine": 793,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c",
      "funcName": "sock6_wildcard_lookup_full",
      "developer_inline_comments": [
        {
          "start_line": 791,
          "end_line": 791,
          "text": "/* ENABLE_NODEPORT */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct lb6_key * key __maybe_unused",
        " const bool in_hostns __maybe_unused"
      ],
      "output": "static__always_inline__maybe_unusedstructlb6_service",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused struct lb6_service *sock6_wildcard_lookup_full (struct lb6_key * key __maybe_unused, const bool in_hostns __maybe_unused)\n",
        "{\n",
        "    struct lb6_service *svc = NULL;\n",
        "\n",
        "#ifdef ENABLE_NODEPORT\n",
        "    svc = sock6_wildcard_lookup (key, true, false, in_hostns);\n",
        "    if (svc && !lb6_svc_is_nodeport (svc))\n",
        "        svc = NULL;\n",
        "    if (!svc) {\n",
        "        svc = sock6_wildcard_lookup (key, false, true, in_hostns);\n",
        "        if (svc && !lb6_svc_is_hostport (svc))\n",
        "            svc = NULL;\n",
        "    }\n",
        "\n",
        "#endif /* ENABLE_NODEPORT */\n",
        "    return svc;\n",
        "}\n"
      ],
      "called_function_list": [
        "lb6_svc_is_hostport",
        "sock6_wildcard_lookup",
        "lb6_svc_is_nodeport"
      ],
      "call_depth": 4,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "sock6_xlate_v4_in_v6": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 795,
      "endLine": 824,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c",
      "funcName": "sock6_xlate_v4_in_v6",
      "developer_inline_comments": [
        {
          "start_line": 822,
          "end_line": 822,
          "text": "/* ENABLE_IPV4 */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct bpf_sock_addr * ctx __maybe_unused",
        " const bool udp_only __maybe_unused"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int sock6_xlate_v4_in_v6 (struct bpf_sock_addr * ctx __maybe_unused, const bool udp_only __maybe_unused)\n",
        "{\n",
        "\n",
        "#ifdef ENABLE_IPV4\n",
        "    struct bpf_sock_addr fake_ctx;\n",
        "    union v6addr addr6;\n",
        "    int ret;\n",
        "    ctx_get_v6_address (ctx, &addr6);\n",
        "    if (!is_v4_in_v6 (&addr6))\n",
        "        return -ENXIO;\n",
        "    memset (&fake_ctx, 0, sizeof (fake_ctx));\n",
        "    fake_ctx.protocol = ctx->protocol;\n",
        "    fake_ctx.user_ip4 = addr6.p4;\n",
        "    fake_ctx.user_port = ctx_dst_port (ctx);\n",
        "    ret = __sock4_xlate_fwd (& fake_ctx, ctx, udp_only);\n",
        "    if (ret < 0)\n",
        "        return ret;\n",
        "    build_v4_in_v6 (&addr6, fake_ctx.user_ip4);\n",
        "    ctx_set_v6_address (ctx, &addr6);\n",
        "    ctx_set_port (ctx, (__u16) fake_ctx.user_port);\n",
        "    return 0;\n",
        "\n",
        "#endif /* ENABLE_IPV4 */\n",
        "    return -ENXIO;\n",
        "}\n"
      ],
      "called_function_list": [
        "is_v4_in_v6",
        "memset",
        "ctx_dst_port",
        "ctx_set_port",
        "build_v4_in_v6",
        "ctx_get_v6_address",
        "__sock4_xlate_fwd",
        "ctx_set_v6_address"
      ],
      "call_depth": 5,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "sock6_post_bind_v4_in_v6": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 827,
      "endLine": 846,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c",
      "funcName": "sock6_post_bind_v4_in_v6",
      "developer_inline_comments": [
        {
          "start_line": 844,
          "end_line": 844,
          "text": "/* ENABLE_IPV4 */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct bpf_sock * ctx __maybe_unused"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int sock6_post_bind_v4_in_v6 (struct bpf_sock * ctx __maybe_unused)\n",
        "{\n",
        "\n",
        "#ifdef ENABLE_IPV4\n",
        "    struct bpf_sock fake_ctx;\n",
        "    union v6addr addr6;\n",
        "    ctx_get_v6_src_address (ctx, &addr6);\n",
        "    if (!is_v4_in_v6 (&addr6))\n",
        "        return 0;\n",
        "    memset (&fake_ctx, 0, sizeof (fake_ctx));\n",
        "    fake_ctx.protocol = ctx->protocol;\n",
        "    fake_ctx.src_ip4 = addr6.p4;\n",
        "    fake_ctx.src_port = ctx->src_port;\n",
        "    return __sock4_post_bind (&fake_ctx, ctx);\n",
        "\n",
        "#endif /* ENABLE_IPV4 */\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "is_v4_in_v6",
        "memset",
        "ctx_get_v6_src_address",
        "__sock4_post_bind"
      ],
      "call_depth": 4,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__sock6_post_bind": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 848,
      "endLine": 874,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c",
      "funcName": "__sock6_post_bind",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct bpf_sock *ctx"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int __sock6_post_bind (struct bpf_sock *ctx)\n",
        "{\n",
        "    struct lb6_service *svc;\n",
        "    struct lb6_key key = {\n",
        "        .dport = ctx_src_port (ctx),}\n",
        "    ;\n",
        "    if (!sock_proto_enabled (ctx->protocol) || !ctx_in_hostns (ctx, NULL))\n",
        "        return 0;\n",
        "    ctx_get_v6_src_address (ctx, &key.address);\n",
        "    svc = lb6_lookup_service (& key, true);\n",
        "    if (!svc) {\n",
        "        svc = sock6_wildcard_lookup (& key, false, false, true);\n",
        "        if (!svc)\n",
        "            return sock6_post_bind_v4_in_v6 (ctx);\n",
        "    }\n",
        "    if (svc && (lb6_svc_is_nodeport (svc) || lb6_svc_is_external_ip (svc) || lb6_svc_is_loadbalancer (svc)))\n",
        "        return -EADDRINUSE;\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "sock6_post_bind_v4_in_v6",
        "sock_proto_enabled",
        "lb6_svc_is_loadbalancer",
        "lb6_lookup_service",
        "ctx_src_port",
        "sock6_wildcard_lookup",
        "lb6_svc_is_nodeport",
        "lb6_svc_is_external_ip",
        "ctx_get_v6_src_address",
        "ctx_in_hostns"
      ],
      "call_depth": 5,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "sock6_post_bind": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 877,
      "endLine": 883,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c",
      "funcName": "sock6_post_bind",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct bpf_sock *ctx"
      ],
      "output": "int",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "int sock6_post_bind (struct bpf_sock *ctx)\n",
        "{\n",
        "    if (__sock6_post_bind (ctx) < 0)\n",
        "        return SYS_REJECT;\n",
        "    return SYS_PROCEED;\n",
        "}\n"
      ],
      "called_function_list": [
        "__sock6_post_bind"
      ],
      "call_depth": 6,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "sock6_pre_bind_v4_in_v6": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 887,
      "endLine": 911,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c",
      "funcName": "sock6_pre_bind_v4_in_v6",
      "developer_inline_comments": [
        {
          "start_line": 909,
          "end_line": 909,
          "text": "/* ENABLE_IPV4 */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct bpf_sock_addr * ctx __maybe_unused"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int sock6_pre_bind_v4_in_v6 (struct bpf_sock_addr * ctx __maybe_unused)\n",
        "{\n",
        "\n",
        "#ifdef ENABLE_IPV4\n",
        "    struct bpf_sock_addr fake_ctx;\n",
        "    union v6addr addr6;\n",
        "    int ret;\n",
        "    ctx_get_v6_address (ctx, &addr6);\n",
        "    memset (&fake_ctx, 0, sizeof (fake_ctx));\n",
        "    fake_ctx.protocol = ctx->protocol;\n",
        "    fake_ctx.user_ip4 = addr6.p4;\n",
        "    fake_ctx.user_port = ctx_dst_port (ctx);\n",
        "    ret = __sock4_pre_bind (& fake_ctx, ctx);\n",
        "    if (ret < 0)\n",
        "        return ret;\n",
        "    build_v4_in_v6 (&addr6, fake_ctx.user_ip4);\n",
        "    ctx_set_v6_address (ctx, &addr6);\n",
        "    ctx_set_port (ctx, (__u16) fake_ctx.user_port);\n",
        "\n",
        "#endif /* ENABLE_IPV4 */\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "__sock4_pre_bind",
        "memset",
        "ctx_dst_port",
        "ctx_set_port",
        "build_v4_in_v6",
        "ctx_get_v6_address",
        "ctx_set_v6_address"
      ],
      "call_depth": 4,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "sock6_auto_bind": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 914,
      "endLine": 920,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c",
      "funcName": "sock6_auto_bind",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct bpf_sock_addr *ctx"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void sock6_auto_bind (struct bpf_sock_addr *ctx)\n",
        "{\n",
        "    union v6addr zero = {}\n",
        "    ;\n",
        "    ctx_set_v6_address (ctx, &zero);\n",
        "    ctx_set_port (ctx, 0);\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_set_port",
        "ctx_set_v6_address"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__sock6_pre_bind": [
    {
      "capabilities": [
        {
          "capability": "map_update",
          "map_update": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "map_update_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}",
                "{Type:  const void ,Var: *value}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_update"
              ]
            }
          ]
        },
        {
          "capability": "read_sys_info",
          "read_sys_info": [
            {
              "Project": "cilium",
              "Return Type": "u64",
              "Description": "Equivalent to get_socket_cookie() helper that accepts skb , but gets socket from struct sock_ops context. ",
              "Return": " A 8-byte long non-decreasing number.",
              "Function Name": "get_socket_cookie",
              "Input Params": [
                "{Type: struct sock_ops ,Var: *ctx}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "sched_cls",
                "sched_act",
                "cgroup_skb",
                "sock_ops",
                "sk_skb",
                "cgroup_sock_addr"
              ],
              "capabilities": [
                "read_sys_info"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 923,
      "endLine": 944,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c",
      "funcName": "__sock6_pre_bind",
      "developer_inline_comments": [],
      "updateMaps": [
        "  LB6_HEALTH_MAP"
      ],
      "readMaps": [],
      "input": [
        "struct bpf_sock_addr *ctx"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "map_update_elem",
        "get_socket_cookie"
      ],
      "compatibleHookpoints": [
        "cgroup_skb",
        "cgroup_sock_addr",
        "socket_filter",
        "sched_act",
        "sk_skb",
        "sched_cls",
        "sock_ops"
      ],
      "source": [
        "static __always_inline int __sock6_pre_bind (struct bpf_sock_addr *ctx)\n",
        "{\n",
        "    __sock_cookie key __maybe_unused;\n",
        "    struct lb6_health val = {\n",
        "        .peer = {\n",
        "            .port = ctx_dst_port (ctx),\n",
        "            .proto = (__u8) ctx->protocol,},}\n",
        "    ;\n",
        "    int ret = 0;\n",
        "    ctx_get_v6_address (ctx, &val.peer.address);\n",
        "    if (is_v4_in_v6 (&val.peer.address))\n",
        "        return sock6_pre_bind_v4_in_v6 (ctx);\n",
        "\n",
        "#ifdef ENABLE_IPV6\n",
        "    key = get_socket_cookie (ctx);\n",
        "    ret = map_update_elem (& LB6_HEALTH_MAP, & key, & val, 0);\n",
        "    if (!ret)\n",
        "        sock6_auto_bind (ctx);\n",
        "\n",
        "#endif\n",
        "    return ret;\n",
        "}\n"
      ],
      "called_function_list": [
        "is_v4_in_v6",
        "ctx_dst_port",
        "sock6_auto_bind",
        "ctx_get_v6_address",
        "sock6_pre_bind_v4_in_v6"
      ],
      "call_depth": 5,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "sock6_pre_bind": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 947,
      "endLine": 958,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c",
      "funcName": "sock6_pre_bind",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct bpf_sock_addr *ctx"
      ],
      "output": "int",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "int sock6_pre_bind (struct bpf_sock_addr *ctx)\n",
        "{\n",
        "    int ret = SYS_PROCEED;\n",
        "    if (!sock_proto_enabled (ctx->protocol) || !ctx_in_hostns (ctx, NULL))\n",
        "        return ret;\n",
        "    if (sock_is_health_check (ctx) && __sock6_pre_bind (ctx))\n",
        "        ret = SYS_REJECT;\n",
        "    return ret;\n",
        "}\n"
      ],
      "called_function_list": [
        "__sock6_pre_bind",
        "sock_proto_enabled",
        "sock_is_health_check",
        "ctx_in_hostns"
      ],
      "call_depth": 6,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__sock6_xlate_fwd": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 961,
      "endLine": 1062,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c",
      "funcName": "__sock6_xlate_fwd",
      "developer_inline_comments": [
        {
          "start_line": 998,
          "end_line": 998,
          "text": "/* See __sock4_xlate_fwd for commentary. */"
        },
        {
          "start_line": 1012,
          "end_line": 1012,
          "text": "/* ENABLE_L7_LB */"
        },
        {
          "start_line": 1061,
          "end_line": 1061,
          "text": "/* ENABLE_IPV6 */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct bpf_sock_addr *ctx",
        " const bool udp_only"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int __sock6_xlate_fwd (struct bpf_sock_addr *ctx, const bool udp_only)\n",
        "{\n",
        "\n",
        "#ifdef ENABLE_IPV6\n",
        "    union lb6_affinity_client_id id;\n",
        "    const bool in_hostns = ctx_in_hostns (ctx, & id.client_cookie);\n",
        "    struct lb6_backend *backend;\n",
        "    struct lb6_service *svc;\n",
        "    struct lb6_key key = {\n",
        "        .dport = ctx_dst_port (ctx),}, orig_key;\n",
        "    struct lb6_service *backend_slot;\n",
        "    bool backend_from_affinity = false;\n",
        "    __u32 backend_id = 0;\n",
        "\n",
        "#ifdef ENABLE_L7_LB\n",
        "    struct lb6_backend l7backend;\n",
        "\n",
        "#endif\n",
        "    if (is_defined (ENABLE_SOCKET_LB_HOST_ONLY) && !in_hostns)\n",
        "        return -ENXIO;\n",
        "    if (!udp_only && !sock_proto_enabled (ctx->protocol))\n",
        "        return -ENOTSUP;\n",
        "    ctx_get_v6_address (ctx, &key.address);\n",
        "    memcpy (&orig_key, &key, sizeof (key));\n",
        "    svc = lb6_lookup_service (& key, true);\n",
        "    if (!svc)\n",
        "        svc = sock6_wildcard_lookup_full (&key, in_hostns);\n",
        "    if (!svc)\n",
        "        return sock6_xlate_v4_in_v6 (ctx, udp_only);\n",
        "    if (sock6_skip_xlate (svc, &orig_key.address))\n",
        "        return -EPERM;\n",
        "\n",
        "#ifdef ENABLE_L7_LB\n",
        "    if (lb6_svc_is_l7loadbalancer (svc)) {\n",
        "        if (is_defined (BPF_HAVE_NETNS_COOKIE) && in_hostns) {\n",
        "            union v6addr loopback = {\n",
        "                .addr [15] = 1,}\n",
        "            ;\n",
        "            l7backend.address = loopback;\n",
        "            l7backend.port = (__be16) svc->l7_lb_proxy_port;\n",
        "            l7backend.proto = 0;\n",
        "            l7backend.flags = 0;\n",
        "            backend = &l7backend;\n",
        "            goto out;\n",
        "        }\n",
        "        return 0;\n",
        "    }\n",
        "\n",
        "#endif /* ENABLE_L7_LB */\n",
        "    if (lb6_svc_is_affinity (svc)) {\n",
        "        backend_id = lb6_affinity_backend_id_by_netns (svc, & id);\n",
        "        backend_from_affinity = true;\n",
        "        if (backend_id != 0) {\n",
        "            backend = __lb6_lookup_backend (backend_id);\n",
        "            if (!backend)\n",
        "                backend_id = 0;\n",
        "        }\n",
        "    }\n",
        "    if (backend_id == 0) {\n",
        "        backend_from_affinity = false;\n",
        "        key.backend_slot = (sock_select_slot (ctx) % svc->count) + 1;\n",
        "        backend_slot = __lb6_lookup_backend_slot (& key);\n",
        "        if (!backend_slot) {\n",
        "            update_metrics (0, METRIC_EGRESS, REASON_LB_NO_BACKEND_SLOT);\n",
        "            return -ENOENT;\n",
        "        }\n",
        "        backend_id = backend_slot->backend_id;\n",
        "        backend = __lb6_lookup_backend (backend_id);\n",
        "    }\n",
        "    if (!backend) {\n",
        "        update_metrics (0, METRIC_EGRESS, REASON_LB_NO_BACKEND);\n",
        "        return -ENOENT;\n",
        "    }\n",
        "    if (lb6_svc_is_affinity (svc) && !backend_from_affinity)\n",
        "        lb6_update_affinity_by_netns (svc, &id, backend_id);\n",
        "\n",
        "#ifdef ENABLE_L7_LB\n",
        "out :\n",
        "\n",
        "#endif\n",
        "    if (sock6_update_revnat (ctx, backend, &orig_key, svc->rev_nat_index) < 0) {\n",
        "        update_metrics (0, METRIC_EGRESS, REASON_LB_REVNAT_UPDATE);\n",
        "        return -ENOMEM;\n",
        "    }\n",
        "    ctx_set_v6_address (ctx, &backend->address);\n",
        "    ctx_set_port (ctx, backend->port);\n",
        "    return 0;\n",
        "\n",
        "#else\n",
        "    return sock6_xlate_v4_in_v6 (ctx, udp_only);\n",
        "\n",
        "#endif /* ENABLE_IPV6 */\n",
        "}\n"
      ],
      "called_function_list": [
        "__lb6_lookup_backend_slot",
        "ctx_dst_port",
        "__lb6_lookup_backend",
        "sock_select_slot",
        "sock6_update_revnat",
        "lb6_lookup_service",
        "ctx_set_port",
        "lb6_affinity_backend_id_by_netns",
        "ctx_in_hostns",
        "ctx_get_v6_address",
        "update_metrics",
        "lb6_update_affinity_by_netns",
        "sock6_xlate_v4_in_v6",
        "lb6_svc_is_l7loadbalancer",
        "sock6_wildcard_lookup_full",
        "ctx_set_v6_address",
        "sock_proto_enabled",
        "memcpy",
        "lb6_svc_is_affinity",
        "sock6_skip_xlate"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__sock6_health_fwd": [
    {
      "capabilities": [
        {
          "capability": "read_sys_info",
          "read_sys_info": [
            {
              "Project": "cilium",
              "Return Type": "u64",
              "Description": "Equivalent to get_socket_cookie() helper that accepts skb , but gets socket from struct sock_ops context. ",
              "Return": " A 8-byte long non-decreasing number.",
              "Function Name": "get_socket_cookie",
              "Input Params": [
                "{Type: struct sock_ops ,Var: *ctx}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "sched_cls",
                "sched_act",
                "cgroup_skb",
                "sock_ops",
                "sk_skb",
                "cgroup_sock_addr"
              ],
              "capabilities": [
                "read_sys_info"
              ]
            }
          ]
        },
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 1064,
      "endLine": 1089,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c",
      "funcName": "__sock6_health_fwd",
      "developer_inline_comments": [
        {
          "start_line": 1085,
          "end_line": 1085,
          "text": "/* ENABLE_IPV6 */"
        },
        {
          "start_line": 1087,
          "end_line": 1087,
          "text": "/* ENABLE_HEALTH_CHECK */"
        }
      ],
      "updateMaps": [],
      "readMaps": [
        " LB6_HEALTH_MAP"
      ],
      "input": [
        "struct bpf_sock_addr * ctx __maybe_unused"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "get_socket_cookie",
        "map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "cgroup_skb",
        "cgroup_sock_addr",
        "socket_filter",
        "sched_act",
        "sk_skb",
        "sched_cls",
        "sock_ops"
      ],
      "source": [
        "static __always_inline int __sock6_health_fwd (struct bpf_sock_addr * ctx __maybe_unused)\n",
        "{\n",
        "    int ret = lb_skip_l4_dnat () ? SYS_PROCEED : SYS_REJECT;\n",
        "\n",
        "#ifdef ENABLE_HEALTH_CHECK\n",
        "    union v6addr addr6;\n",
        "    ctx_get_v6_address (ctx, &addr6);\n",
        "    if (is_v4_in_v6 (&addr6)) {\n",
        "        return __sock4_health_fwd (ctx);\n",
        "    }\n",
        "    else {\n",
        "\n",
        "#ifdef ENABLE_IPV6\n",
        "        __sock_cookie key = get_socket_cookie (ctx);\n",
        "        struct lb6_health *val = NULL;\n",
        "        if (!lb_skip_l4_dnat ())\n",
        "            val = map_lookup_elem (&LB6_HEALTH_MAP, &key);\n",
        "        if (val) {\n",
        "            ctx_set_port (ctx, val->peer.port);\n",
        "            ret = SYS_PROCEED;\n",
        "        }\n",
        "\n",
        "#endif /* ENABLE_IPV6 */\n",
        "    }\n",
        "\n",
        "#endif /* ENABLE_HEALTH_CHECK */\n",
        "    return ret;\n",
        "}\n"
      ],
      "called_function_list": [
        "is_v4_in_v6",
        "__sock4_health_fwd",
        "lb_skip_l4_dnat",
        "ctx_set_port",
        "ctx_get_v6_address"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "sock6_connect": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1092,
      "endLine": 1099,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c",
      "funcName": "sock6_connect",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct bpf_sock_addr *ctx"
      ],
      "output": "int",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "int sock6_connect (struct bpf_sock_addr *ctx)\n",
        "{\n",
        "    if (sock_is_health_check (ctx))\n",
        "        return __sock6_health_fwd (ctx);\n",
        "    __sock6_xlate_fwd (ctx, false);\n",
        "    return SYS_PROCEED;\n",
        "}\n"
      ],
      "called_function_list": [
        "__sock6_xlate_fwd",
        "__sock6_health_fwd",
        "sock_is_health_check"
      ],
      "call_depth": 4,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "sock6_xlate_rev_v4_in_v6": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1102,
      "endLine": 1130,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c",
      "funcName": "sock6_xlate_rev_v4_in_v6",
      "developer_inline_comments": [
        {
          "start_line": 1128,
          "end_line": 1128,
          "text": "/* ENABLE_IPV4 */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct bpf_sock_addr * ctx __maybe_unused"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int sock6_xlate_rev_v4_in_v6 (struct bpf_sock_addr * ctx __maybe_unused)\n",
        "{\n",
        "\n",
        "#ifdef ENABLE_IPV4\n",
        "    struct bpf_sock_addr fake_ctx;\n",
        "    union v6addr addr6;\n",
        "    int ret;\n",
        "    ctx_get_v6_address (ctx, &addr6);\n",
        "    if (!is_v4_in_v6 (&addr6))\n",
        "        return -ENXIO;\n",
        "    memset (&fake_ctx, 0, sizeof (fake_ctx));\n",
        "    fake_ctx.protocol = ctx->protocol;\n",
        "    fake_ctx.user_ip4 = addr6.p4;\n",
        "    fake_ctx.user_port = ctx_dst_port (ctx);\n",
        "    ret = __sock4_xlate_rev (& fake_ctx, ctx);\n",
        "    if (ret < 0)\n",
        "        return ret;\n",
        "    build_v4_in_v6 (&addr6, fake_ctx.user_ip4);\n",
        "    ctx_set_v6_address (ctx, &addr6);\n",
        "    ctx_set_port (ctx, (__u16) fake_ctx.user_port);\n",
        "    return 0;\n",
        "\n",
        "#endif /* ENABLE_IPV4 */\n",
        "    return -ENXIO;\n",
        "}\n"
      ],
      "called_function_list": [
        "is_v4_in_v6",
        "memset",
        "__sock4_xlate_rev",
        "ctx_dst_port",
        "ctx_set_port",
        "build_v4_in_v6",
        "ctx_get_v6_address",
        "ctx_set_v6_address"
      ],
      "call_depth": 5,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__sock6_xlate_rev": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 1132,
      "endLine": 1167,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c",
      "funcName": "__sock6_xlate_rev",
      "developer_inline_comments": [
        {
          "start_line": 1164,
          "end_line": 1164,
          "text": "/* ENABLE_IPV6 */"
        }
      ],
      "updateMaps": [
        " LB6_REVERSE_NAT_SK_MAP"
      ],
      "readMaps": [
        "  LB6_REVERSE_NAT_SK_MAP"
      ],
      "input": [
        "struct bpf_sock_addr *ctx"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "map_delete_elem",
        "map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int __sock6_xlate_rev (struct bpf_sock_addr *ctx)\n",
        "{\n",
        "\n",
        "#ifdef ENABLE_IPV6\n",
        "    struct ipv6_revnat_tuple key = {}\n",
        "    ;\n",
        "    struct ipv6_revnat_entry *val;\n",
        "    key.cookie = sock_local_cookie (ctx);\n",
        "    key.port = ctx_dst_port (ctx);\n",
        "    ctx_get_v6_address (ctx, &key.address);\n",
        "    val = map_lookup_elem (& LB6_REVERSE_NAT_SK_MAP, & key);\n",
        "    if (val) {\n",
        "        struct lb6_service *svc;\n",
        "        struct lb6_key svc_key = {\n",
        "            .address = val->address,\n",
        "            .dport = val->port,}\n",
        "        ;\n",
        "        svc = lb6_lookup_service (& svc_key, true);\n",
        "        if (!svc)\n",
        "            svc = sock6_wildcard_lookup_full (&svc_key, ctx_in_hostns (ctx, NULL));\n",
        "        if (!svc || svc->rev_nat_index != val->rev_nat_index) {\n",
        "            map_delete_elem (&LB6_REVERSE_NAT_SK_MAP, &key);\n",
        "            update_metrics (0, METRIC_INGRESS, REASON_LB_REVNAT_STALE);\n",
        "            return -ENOENT;\n",
        "        }\n",
        "        ctx_set_v6_address (ctx, &val->address);\n",
        "        ctx_set_port (ctx, val->port);\n",
        "        return 0;\n",
        "    }\n",
        "\n",
        "#endif /* ENABLE_IPV6 */\n",
        "    return sock6_xlate_rev_v4_in_v6 (ctx);\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_dst_port",
        "lb6_lookup_service",
        "sock6_xlate_rev_v4_in_v6",
        "ctx_set_port",
        "sock6_wildcard_lookup_full",
        "ctx_in_hostns",
        "ctx_get_v6_address",
        "sock_local_cookie",
        "ctx_set_v6_address",
        "update_metrics"
      ],
      "call_depth": 6,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "sock6_sendmsg": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1170,
      "endLine": 1174,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c",
      "funcName": "sock6_sendmsg",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct bpf_sock_addr *ctx"
      ],
      "output": "int",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "int sock6_sendmsg (struct bpf_sock_addr *ctx)\n",
        "{\n",
        "    __sock6_xlate_fwd (ctx, true);\n",
        "    return SYS_PROCEED;\n",
        "}\n"
      ],
      "called_function_list": [
        "__sock6_xlate_fwd"
      ],
      "call_depth": 4,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "sock6_recvmsg": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1177,
      "endLine": 1181,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c",
      "funcName": "sock6_recvmsg",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct bpf_sock_addr *ctx"
      ],
      "output": "int",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "int sock6_recvmsg (struct bpf_sock_addr *ctx)\n",
        "{\n",
        "    __sock6_xlate_rev (ctx);\n",
        "    return SYS_PROCEED;\n",
        "}\n"
      ],
      "called_function_list": [
        "__sock6_xlate_rev"
      ],
      "call_depth": 7,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "sock6_getpeername": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1184,
      "endLine": 1188,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c",
      "funcName": "sock6_getpeername",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct bpf_sock_addr *ctx"
      ],
      "output": "int",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "int sock6_getpeername (struct bpf_sock_addr *ctx)\n",
        "{\n",
        "    __sock6_xlate_rev (ctx);\n",
        "    return SYS_PROCEED;\n",
        "}\n"
      ],
      "called_function_list": [
        "__sock6_xlate_rev"
      ],
      "call_depth": 7,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "allow_vlan": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 62,
      "endLine": 64,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c",
      "funcName": "allow_vlan",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": "// SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)"
        },
        {
          "start_line": 2,
          "end_line": 2,
          "text": "/* Copyright Authors of Cilium */"
        },
        {
          "start_line": 14,
          "end_line": 16,
          "text": "/* Host endpoint ID for the template bpf_host object file. Will be replaced\n * at compile-time with the proper host endpoint ID.\n */"
        },
        {
          "start_line": 19,
          "end_line": 21,
          "text": "/* These are configuration options which have a default value in their\n * respective header files and must thus be defined beforehand:\n */"
        },
        {
          "start_line": 22,
          "end_line": 22,
          "text": "/* Pass unknown ICMPv6 NS to stack */"
        },
        {
          "start_line": 25,
          "end_line": 25,
          "text": "/* CB_PROXY_MAGIC overlaps with CB_ENCRYPT_MAGIC */"
        },
        {
          "start_line": 28,
          "end_line": 30,
          "text": "/* Controls the inclusion of the CILIUM_CALL_SEND_ICMP6_ECHO_REPLY section in\n * the bpf_lxc object file.\n */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "__u32 __maybe_unused ifindex",
        " __u32 __maybe_unused vlan_id"
      ],
      "output": "static__always_inlinebool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline bool allow_vlan (__u32 __maybe_unused ifindex, __u32 __maybe_unused vlan_id)\n",
        "{\n",
        "    VLAN_FILTER (ifindex, vlan_id);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "rewrite_dmac_to_host": [
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 67,
      "endLine": 82,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c",
      "funcName": "rewrite_dmac_to_host",
      "developer_inline_comments": [
        {
          "start_line": 70,
          "end_line": 73,
          "text": "/* When attached to cilium_host, we rewrite the DMAC to the mac of\n\t * cilium_host (peer) to ensure the packet is being considered to be\n\t * addressed to the host (PACKET_HOST).\n\t */"
        },
        {
          "start_line": 76,
          "end_line": 76,
          "text": "/* Rewrite to destination MAC of cilium_net (remote peer) */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " __u32 src_identity"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "CTX_ACT_OK"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "static __always_inline int rewrite_dmac_to_host (struct  __ctx_buff *ctx, __u32 src_identity)\n",
        "{\n",
        "    union macaddr cilium_net_mac = CILIUM_NET_MAC;\n",
        "    if (eth_store_daddr (ctx, (__u8 *) &cilium_net_mac.addr, 0) < 0)\n",
        "        return send_drop_notify_error (ctx, src_identity, DROP_WRITE_ERROR, CTX_ACT_OK, METRIC_INGRESS);\n",
        "    return CTX_ACT_OK;\n",
        "}\n"
      ],
      "called_function_list": [
        "eth_store_daddr"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "identity_from_ipcache_ok": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 89,
      "endLine": 92,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c",
      "funcName": "identity_from_ipcache_ok",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void"
      ],
      "output": "static__always_inlinebool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline bool identity_from_ipcache_ok (void)\n",
        "{\n",
        "    return SECCTX_FROM_IPCACHE == SECCTX_FROM_IPCACHE_OK;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "derive_src_id": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 96,
      "endLine": 112,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c",
      "funcName": "derive_src_id",
      "developer_inline_comments": [
        {
          "start_line": 100,
          "end_line": 100,
          "text": "/* Read initial 4 bytes of header and then extract flowlabel */"
        },
        {
          "start_line": 104,
          "end_line": 107,
          "text": "/* A remote node will map any HOST_ID source to be presented as\n\t\t * REMOTE_NODE_ID, therefore any attempt to signal HOST_ID as\n\t\t * source from a remote node can be dropped.\n\t\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const union v6addr *node_ip",
        " struct ipv6hdr *ip6",
        " __u32 *identity"
      ],
      "output": "static__always_inline__u32",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __u32 derive_src_id (const union v6addr *node_ip, struct ipv6hdr *ip6, __u32 *identity)\n",
        "{\n",
        "    if (ipv6_match_prefix_64 ((union v6addr *) &ip6->saddr, node_ip)) {\n",
        "        __u32 *tmp = (__u32 *) ip6;\n",
        "        *identity = bpf_ntohl (*tmp & IPV6_FLOWLABEL_MASK);\n",
        "        if (*identity == HOST_ID)\n",
        "            return DROP_INVALID_IDENTITY;\n",
        "    }\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "ipv6_match_prefix_64"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ipcache_lookup_srcid6": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 115,
      "endLine": 133,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c",
      "funcName": "ipcache_lookup_srcid6",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "static__always_inline__u32",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __u32 ipcache_lookup_srcid6 (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    struct remote_endpoint_info *info = NULL;\n",
        "    void *data, *data_end;\n",
        "    struct ipv6hdr *ip6;\n",
        "    __u32 srcid = 0;\n",
        "    if (!revalidate_data (ctx, &data, &data_end, &ip6))\n",
        "        return DROP_INVALID;\n",
        "    info = lookup_ip6_remote_endpoint ((union v6addr *) & ip6 -> saddr);\n",
        "    if (info != NULL)\n",
        "        srcid = info->sec_label;\n",
        "    cilium_dbg (ctx, info ? DBG_IP_ID_MAP_SUCCEED6 : DBG_IP_ID_MAP_FAILED6, ip6->saddr.s6_addr32[3], srcid);\n",
        "    return srcid;\n",
        "}\n"
      ],
      "called_function_list": [
        "cilium_dbg"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "resolve_srcid_ipv6": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 136,
      "endLine": 176,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c",
      "funcName": "resolve_srcid_ipv6",
      "developer_inline_comments": [
        {
          "start_line": 159,
          "end_line": 159,
          "text": "/* Packets from the proxy will already have a real identity. */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " __u32 srcid_from_proxy",
        " const bool from_host"
      ],
      "output": "static__always_inline__u32",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __u32 resolve_srcid_ipv6 (struct  __ctx_buff *ctx, __u32 srcid_from_proxy, const bool from_host)\n",
        "{\n",
        "    __u32 src_id = WORLD_ID, srcid_from_ipcache = srcid_from_proxy;\n",
        "    struct remote_endpoint_info *info = NULL;\n",
        "    void *data, *data_end;\n",
        "    struct ipv6hdr *ip6;\n",
        "    union v6addr *src;\n",
        "    int ret;\n",
        "    if (!revalidate_data_maybe_pull (ctx, &data, &data_end, &ip6, !from_host))\n",
        "        return DROP_INVALID;\n",
        "    if (!from_host) {\n",
        "        union v6addr node_ip = {}\n",
        "        ;\n",
        "        BPF_V6 (node_ip, ROUTER_IP);\n",
        "        ret = derive_src_id (& node_ip, ip6, & src_id);\n",
        "        if (IS_ERR (ret))\n",
        "            return ret;\n",
        "    }\n",
        "    if (identity_is_reserved (srcid_from_ipcache)) {\n",
        "        src = (union v6addr *) &ip6->saddr;\n",
        "        info = lookup_ip6_remote_endpoint (src);\n",
        "        if (info != NULL && info->sec_label)\n",
        "            srcid_from_ipcache = info->sec_label;\n",
        "        cilium_dbg (ctx, info ? DBG_IP_ID_MAP_SUCCEED6 : DBG_IP_ID_MAP_FAILED6, ((__u32 *) src)[3], srcid_from_ipcache);\n",
        "    }\n",
        "    if (from_host)\n",
        "        src_id = srcid_from_ipcache;\n",
        "    else if (src_id == WORLD_ID && identity_from_ipcache_ok () && !identity_is_reserved (srcid_from_ipcache))\n",
        "        src_id = srcid_from_ipcache;\n",
        "    return src_id;\n",
        "}\n"
      ],
      "called_function_list": [
        "identity_from_ipcache_ok",
        "derive_src_id",
        "identity_is_reserved",
        "cilium_dbg"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "tail_handle_ipv6_from_host": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 369,
      "endLine": 372,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c",
      "funcName": "tail_handle_ipv6_from_host",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff * ctx __maybe_unused"
      ],
      "output": "int",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "int tail_handle_ipv6_from_host (struct  __ctx_buff * ctx __maybe_unused)\n",
        "{\n",
        "    return tail_handle_ipv6 (ctx, true);\n",
        "}\n"
      ],
      "called_function_list": [
        "tail_handle_ipv6"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "tail_handle_ipv6_from_netdev": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 375,
      "endLine": 378,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c",
      "funcName": "tail_handle_ipv6_from_netdev",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "int",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "int tail_handle_ipv6_from_netdev (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    return tail_handle_ipv6 (ctx, false);\n",
        "}\n"
      ],
      "called_function_list": [
        "tail_handle_ipv6"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "handle_to_netdev_ipv6": [
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 381,
      "endLine": 409,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c",
      "funcName": "handle_to_netdev_ipv6",
      "developer_inline_comments": [
        {
          "start_line": 406,
          "end_line": 406,
          "text": "/* to-netdev is attached to the egress path of the native device. */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " struct trace_ctx *trace"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "CTX_ACT_OK"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "static __always_inline int handle_to_netdev_ipv6 (struct  __ctx_buff *ctx, struct trace_ctx *trace)\n",
        "{\n",
        "    void *data, *data_end;\n",
        "    struct ipv6hdr *ip6;\n",
        "    int hdrlen, ret;\n",
        "    __u32 src_id = 0;\n",
        "    __u8 nexthdr;\n",
        "    if (!revalidate_data_pull (ctx, &data, &data_end, &ip6))\n",
        "        return DROP_INVALID;\n",
        "    nexthdr = ip6->nexthdr;\n",
        "    hdrlen = ipv6_hdrlen (ctx, & nexthdr);\n",
        "    if (hdrlen < 0)\n",
        "        return hdrlen;\n",
        "    if (likely (nexthdr == IPPROTO_ICMPV6)) {\n",
        "        ret = icmp6_host_handle (ctx);\n",
        "        if (ret == SKIP_HOST_FIREWALL)\n",
        "            return CTX_ACT_OK;\n",
        "        if (IS_ERR (ret))\n",
        "            return ret;\n",
        "    }\n",
        "    src_id = ipcache_lookup_srcid6 (ctx);\n",
        "    return ipv6_host_policy_egress (ctx, src_id, trace);\n",
        "}\n"
      ],
      "called_function_list": [
        "ipv6_hdrlen",
        "icmp6_host_handle",
        "ipv6_host_policy_egress",
        "ipcache_lookup_srcid6"
      ],
      "call_depth": 4,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "resolve_srcid_ipv4": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 414,
      "endLine": 469,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c",
      "funcName": "resolve_srcid_ipv4",
      "developer_inline_comments": [
        {
          "start_line": 411,
          "end_line": 411,
          "text": "/* ENABLE_IPV6 */"
        },
        {
          "start_line": 423,
          "end_line": 427,
          "text": "/* This is the first time revalidate_data() is going to be called in\n\t * the \"to-netdev\" path. Make sure that we don't legitimately drop\n\t * the packet if the skb arrived with the header not being not in the\n\t * linear data.\n\t */"
        },
        {
          "start_line": 431,
          "end_line": 431,
          "text": "/* Packets from the proxy will already have a real identity. */"
        },
        {
          "start_line": 438,
          "end_line": 445,
          "text": "/* When SNAT is enabled on traffic ingressing\n\t\t\t\t * into Cilium, all traffic from the world will\n\t\t\t\t * have a source IP of the host. It will only\n\t\t\t\t * actually be from the host if \"srcid_from_proxy\"\n\t\t\t\t * (passed into this function) reports the src as\n\t\t\t\t * the host. So we can ignore the ipcache if it\n\t\t\t\t * reports the source as HOST_ID.\n\t\t\t\t */"
        },
        {
          "start_line": 453,
          "end_line": 453,
          "text": "/* ENABLE_EXTRA_HOST_DEV */"
        },
        {
          "start_line": 462,
          "end_line": 464,
          "text": "/* If we could not derive the secctx from the packet itself but\n\t * from the ipcache instead, then use the ipcache identity.\n\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " __u32 srcid_from_proxy",
        " __u32 *sec_label",
        " const bool from_host"
      ],
      "output": "static__always_inline__u32",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __u32 resolve_srcid_ipv4 (struct  __ctx_buff *ctx, __u32 srcid_from_proxy, __u32 *sec_label, const bool from_host)\n",
        "{\n",
        "    __u32 src_id = WORLD_ID, srcid_from_ipcache = srcid_from_proxy;\n",
        "    struct remote_endpoint_info *info = NULL;\n",
        "    void *data, *data_end;\n",
        "    struct iphdr *ip4;\n",
        "    if (!revalidate_data_maybe_pull (ctx, &data, &data_end, &ip4, !from_host))\n",
        "        return DROP_INVALID;\n",
        "    if (identity_is_reserved (srcid_from_ipcache)) {\n",
        "        info = lookup_ip4_remote_endpoint (ip4 -> saddr);\n",
        "        if (info != NULL) {\n",
        "            *sec_label = info->sec_label;\n",
        "            if (*sec_label) {\n",
        "\n",
        "#ifndef ENABLE_EXTRA_HOST_DEV\n",
        "                if (*sec_label != HOST_ID)\n",
        "                    srcid_from_ipcache = *sec_label;\n",
        "\n",
        "#else\n",
        "                if ((*sec_label != HOST_ID && !from_host) || from_host)\n",
        "                    srcid_from_ipcache = *sec_label;\n",
        "\n",
        "#endif /* ENABLE_EXTRA_HOST_DEV */\n",
        "            }\n",
        "        }\n",
        "        cilium_dbg (ctx, info ? DBG_IP_ID_MAP_SUCCEED4 : DBG_IP_ID_MAP_FAILED4, ip4->saddr, srcid_from_ipcache);\n",
        "    }\n",
        "    if (from_host)\n",
        "        src_id = srcid_from_ipcache;\n",
        "    else if (identity_from_ipcache_ok () && !identity_is_reserved (srcid_from_ipcache))\n",
        "        src_id = srcid_from_ipcache;\n",
        "    return src_id;\n",
        "}\n"
      ],
      "called_function_list": [
        "identity_from_ipcache_ok",
        "identity_is_reserved",
        "cilium_dbg"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "tail_handle_ipv4_from_host": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 689,
      "endLine": 699,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c",
      "funcName": "tail_handle_ipv4_from_host",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "int",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "int tail_handle_ipv4_from_host (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    __u32 ipcache_srcid = 0;\n",
        "\n",
        "#if defined(ENABLE_HOST_FIREWALL) && !defined(ENABLE_MASQUERADE)\n",
        "    ipcache_srcid = ctx_load_meta (ctx, CB_IPCACHE_SRC_LABEL);\n",
        "    ctx_store_meta (ctx, CB_IPCACHE_SRC_LABEL, 0);\n",
        "\n",
        "#endif\n",
        "    return tail_handle_ipv4 (ctx, ipcache_srcid, true);\n",
        "}\n"
      ],
      "called_function_list": [
        "tail_handle_ipv4",
        "ctx_load_meta",
        "ctx_store_meta"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "tail_handle_ipv4_from_netdev": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 702,
      "endLine": 705,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c",
      "funcName": "tail_handle_ipv4_from_netdev",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "int",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "int tail_handle_ipv4_from_netdev (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    return tail_handle_ipv4 (ctx, 0, false);\n",
        "}\n"
      ],
      "called_function_list": [
        "tail_handle_ipv4"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "handle_to_netdev_ipv4": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 708,
      "endLine": 727,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c",
      "funcName": "handle_to_netdev_ipv4",
      "developer_inline_comments": [
        {
          "start_line": 723,
          "end_line": 725,
          "text": "/* We need to pass the srcid from ipcache to host firewall. See\n\t * comment in ipv4_host_policy_egress() for details.\n\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " struct trace_ctx *trace"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int handle_to_netdev_ipv4 (struct  __ctx_buff *ctx, struct trace_ctx *trace)\n",
        "{\n",
        "    void *data, *data_end;\n",
        "    struct iphdr *ip4;\n",
        "    __u32 src_id = 0, ipcache_srcid = 0;\n",
        "    if ((ctx->mark & MARK_MAGIC_HOST_MASK) == MARK_MAGIC_HOST)\n",
        "        src_id = HOST_ID;\n",
        "    src_id = resolve_srcid_ipv4 (ctx, src_id, & ipcache_srcid, true);\n",
        "    if (!revalidate_data (ctx, &data, &data_end, &ip4))\n",
        "        return DROP_INVALID;\n",
        "    return ipv4_host_policy_egress (ctx, src_id, ipcache_srcid, trace);\n",
        "}\n"
      ],
      "called_function_list": [
        "resolve_srcid_ipv4",
        "ipv4_host_policy_egress"
      ],
      "call_depth": 4,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "do_netdev_encrypt_pools": [
    {
      "capabilities": [
        {
          "capability": "read_skb",
          "read_skb": [
            {
              "Project": "cilium",
              "Return Type": "s64",
              "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ",
              "Return": " The checksum result, or a negative error code in case of failure.",
              "Function Name": "csum_diff",
              "Input Params": [
                "{Type: __be32 ,Var: *from}",
                "{Type:  u32 ,Var: from_size}",
                "{Type:  __be32 ,Var: *to}",
                "{Type:  u32 ,Var: to_size}",
                "{Type:  __wsum ,Var: seed}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "xdp",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "lwt_seg6local"
              ],
              "capabilities": [
                "read_skb"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 733,
      "endLine": 788,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c",
      "funcName": "do_netdev_encrypt_pools",
      "developer_inline_comments": [
        {
          "start_line": 729,
          "end_line": 729,
          "text": "/* ENABLE_IPV4 */"
        },
        {
          "start_line": 752,
          "end_line": 756,
          "text": "/* When IP_POOLS is enabled ip addresses are not\n\t * assigned on a per node basis so lacking node\n\t * affinity we can not use IP address to assign the\n\t * destination IP. Instead rewrite it here from cb[].\n\t */"
        },
        {
          "start_line": 786,
          "end_line": 786,
          "text": "/* IP_POOLS */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff * ctx __maybe_unused"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "csum_diff"
      ],
      "compatibleHookpoints": [
        "lwt_seg6local",
        "sched_act",
        "xdp",
        "lwt_xmit",
        "sched_cls",
        "lwt_in",
        "lwt_out"
      ],
      "source": [
        "static __always_inline int do_netdev_encrypt_pools (struct  __ctx_buff * ctx __maybe_unused)\n",
        "{\n",
        "    int ret = 0;\n",
        "\n",
        "#ifdef IP_POOLS\n",
        "    __u32 tunnel_endpoint = 0;\n",
        "    void *data, *data_end;\n",
        "    __u32 tunnel_source = IPV4_ENCRYPT_IFACE;\n",
        "    struct iphdr *iphdr;\n",
        "    __be32 sum;\n",
        "    tunnel_endpoint = ctx_load_meta (ctx, CB_ENCRYPT_DST);\n",
        "    ctx->mark = 0;\n",
        "    if (!revalidate_data (ctx, &data, &data_end, &iphdr)) {\n",
        "        ret = DROP_INVALID;\n",
        "        goto drop_err;\n",
        "    }\n",
        "    sum = csum_diff (& iphdr -> daddr, 4, & tunnel_endpoint, 4, 0);\n",
        "    if (ctx_store_bytes (ctx, ETH_HLEN + offsetof (struct iphdr, daddr), &tunnel_endpoint, 4, 0) < 0) {\n",
        "        ret = DROP_WRITE_ERROR;\n",
        "        goto drop_err;\n",
        "    }\n",
        "    if (l3_csum_replace (ctx, ETH_HLEN + offsetof (struct iphdr, check), 0, sum, 0) < 0) {\n",
        "        ret = DROP_CSUM_L3;\n",
        "        goto drop_err;\n",
        "    }\n",
        "    if (!revalidate_data (ctx, &data, &data_end, &iphdr)) {\n",
        "        ret = DROP_INVALID;\n",
        "        goto drop_err;\n",
        "    }\n",
        "    sum = csum_diff (& iphdr -> saddr, 4, & tunnel_source, 4, 0);\n",
        "    if (ctx_store_bytes (ctx, ETH_HLEN + offsetof (struct iphdr, saddr), &tunnel_source, 4, 0) < 0) {\n",
        "        ret = DROP_WRITE_ERROR;\n",
        "        goto drop_err;\n",
        "    }\n",
        "    if (l3_csum_replace (ctx, ETH_HLEN + offsetof (struct iphdr, check), 0, sum, 0) < 0) {\n",
        "        ret = DROP_CSUM_L3;\n",
        "        goto drop_err;\n",
        "    }\n",
        "drop_err :\n",
        "\n",
        "#endif /* IP_POOLS */\n",
        "    return ret;\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_load_meta"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "do_netdev_encrypt_fib": [
    {
      "capabilities": [
        {
          "capability": "read_sys_info",
          "read_sys_info": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Description": "Do FIB lookup in kernel tables using parameters in params. If lookup is successful and result shows packet is to be forwarded , the neighbor tables are searched for the nexthop. If successful (ie. , FIB lookup shows forwarding and nexthop is resolved) , the nexthop address is returned in ipv4_dst or ipv6_dst based on family , smac is set to mac address of egress device , dmac is set to nexthop mac address , rt_metric is set to metric from route (IPv4/IPv6 only) , and ifindex is set to the device index of the nexthop from the FIB lookup. <[ plen ]>(IP: 2) argument is the size of the passed in struct. <[ flags ]>(IP: 3) argument can be a combination of one or more of the following values: BPF_FIB_LOOKUP_DIRECT Do a direct table lookup vs full lookup using FIB rules. BPF_FIB_LOOKUP_OUTPUT Perform lookup from an egress perspective (default is ingress). <[ ctx ]>(IP: 0) is either struct xdp_md for XDP programs or struct sk_buff tc cls_act programs. Return \u00b7 < 0 if any input argument is invalid \u00b7 0 on success (packet is forwarded , nexthop neighbor exists) \u00b7 > 0 one of BPF_FIB_LKUP_RET_ codes explaining why the packet is not forwarded or needs assist from full stack ",
              "Function Name": "fib_lookup",
              "Input Params": [
                "{Type: void ,Var: *ctx}",
                "{Type:  struct fib_lookup ,Var: *params}",
                "{Type:  int ,Var: plen}",
                "{Type:  u32 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "xdp"
              ],
              "capabilities": [
                "read_sys_info"
              ]
            },
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Do FIB lookup in kernel tables using parameters in params. If lookup is successful and result shows packet is to be forwarded , the neighbor tables are searched for the nexthop. If successful (ie. , FIB lookup shows forwarding and nexthop is resolved) , the nexthop address is returned in ipv4_dst or ipv6_dst based on family , smac is set to mac address of egress device , dmac is set to nexthop mac address , rt_metric is set to metric from route (IPv4/IPv6 only) , and ifindex is set to the device index of the nexthop from the FIB lookup. <[ plen ]>(IP: 2) argument is the size of the passed in struct. <[ flags ]>(IP: 3) argument can be a combination of one or more of the following values: BPF_FIB_LOOKUP_DIRECT Do a direct table lookup vs full lookup using FIB rules. BPF_FIB_LOOKUP_OUTPUT Perform lookup from an egress perspective (default is ingress). <[ ctx ]>(IP: 0) is either struct xdp_md for XDP programs or struct sk_buff tc cls_act programs. Return \u00b7 < 0 if any input argument is invalid \u00b7 0 on success (packet is forwarded , nexthop neighbor exists) \u00b7 > 0 one of BPF_FIB_LKUP_RET_ codes explaining why the packet is not forwarded or needs assist from full stack ",
              "Function Name": "bpf_fib_lookup",
              "Input Params": [
                "{Type: void ,Var: *ctx}",
                "{Type:  struct bpf_fib_lookup ,Var: *params}",
                "{Type:  int ,Var: plen}",
                "{Type:  u32 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "xdp"
              ],
              "capabilities": [
                "read_sys_info"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 790,
      "endLine": 853,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c",
      "funcName": "do_netdev_encrypt_fib",
      "developer_inline_comments": [
        {
          "start_line": 797,
          "end_line": 802,
          "text": "/* Only do FIB lookup if both the BPF helper is supported and we know\n\t * the egress ineterface. If we don't have an egress interface,\n\t * typically in an environment with many egress devs than we have\n\t * to let the stack decide how to egress the packet. EKS is the\n\t * example of an environment with multiple egress interfaces.\n\t */"
        },
        {
          "start_line": 851,
          "end_line": 851,
          "text": "/* BPF_HAVE_FIB_LOOKUP */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff * ctx __maybe_unused",
        " __u16 proto __maybe_unused",
        " int * encrypt_iface __maybe_unused",
        " int * ext_err __maybe_unused"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "fib_lookup",
        "bpf_fib_lookup"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "static __always_inline int do_netdev_encrypt_fib (struct  __ctx_buff * ctx __maybe_unused, __u16 proto __maybe_unused, int * encrypt_iface __maybe_unused, int * ext_err __maybe_unused)\n",
        "{\n",
        "    int ret = 0;\n",
        "\n",
        "#if defined(BPF_HAVE_FIB_LOOKUP) && defined(ENCRYPT_IFACE)\n",
        "    struct bpf_fib_lookup fib_params = {}\n",
        "    ;\n",
        "    void *data, *data_end;\n",
        "    int err;\n",
        "    if (proto == bpf_htons (ETH_P_IP)) {\n",
        "        struct iphdr *ip4;\n",
        "        if (!revalidate_data (ctx, &data, &data_end, &ip4)) {\n",
        "            ret = DROP_INVALID;\n",
        "            goto drop_err_fib;\n",
        "        }\n",
        "        fib_params.family = AF_INET;\n",
        "        fib_params.ipv4_src = ip4->saddr;\n",
        "        fib_params.ipv4_dst = ip4->daddr;\n",
        "    }\n",
        "    else {\n",
        "        struct ipv6hdr *ip6;\n",
        "        if (!revalidate_data (ctx, &data, &data_end, &ip6)) {\n",
        "            ret = DROP_INVALID;\n",
        "            goto drop_err_fib;\n",
        "        }\n",
        "        fib_params.family = AF_INET6;\n",
        "        ipv6_addr_copy ((union v6addr *) &fib_params.ipv6_src, (union v6addr *) &ip6->saddr);\n",
        "        ipv6_addr_copy ((union v6addr *) &fib_params.ipv6_dst, (union v6addr *) &ip6->daddr);\n",
        "    }\n",
        "    fib_params.ifindex = *encrypt_iface;\n",
        "    err = fib_lookup (ctx, & fib_params, sizeof (fib_params), BPF_FIB_LOOKUP_DIRECT | BPF_FIB_LOOKUP_OUTPUT);\n",
        "    if (err != 0) {\n",
        "        *ext_err = err;\n",
        "        ret = DROP_NO_FIB;\n",
        "        goto drop_err_fib;\n",
        "    }\n",
        "    if (eth_store_daddr (ctx, fib_params.dmac, 0) < 0) {\n",
        "        ret = DROP_WRITE_ERROR;\n",
        "        goto drop_err_fib;\n",
        "    }\n",
        "    if (eth_store_saddr (ctx, fib_params.smac, 0) < 0) {\n",
        "        ret = DROP_WRITE_ERROR;\n",
        "        goto drop_err_fib;\n",
        "    }\n",
        "    *encrypt_iface = fib_params.ifindex;\n",
        "drop_err_fib :\n",
        "\n",
        "#endif /* BPF_HAVE_FIB_LOOKUP */\n",
        "    return ret;\n",
        "}\n"
      ],
      "called_function_list": [
        "eth_store_daddr",
        "ipv6_addr_copy",
        "eth_store_saddr"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "do_netdev_encrypt": [
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 855,
      "endLine": 885,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c",
      "funcName": "do_netdev_encrypt",
      "developer_inline_comments": [
        {
          "start_line": 875,
          "end_line": 880,
          "text": "/* Redirect only works if we have a fib lookup to set the MAC\n\t * addresses. Otherwise let the stack do the routing and fib\n\t * Note, without FIB lookup implemented the packet may have\n\t * incorrect dmac leaving bpf_host so will need to mark as\n\t * PACKET_HOST or otherwise fixup MAC addresses.\n\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " __u16 proto",
        " __u32 src_id"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "CTX_ACT_OK"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "static __always_inline int do_netdev_encrypt (struct  __ctx_buff *ctx, __u16 proto, __u32 src_id)\n",
        "{\n",
        "    int encrypt_iface = 0;\n",
        "    int ext_err = 0;\n",
        "    int ret = 0;\n",
        "\n",
        "#if defined(ENCRYPT_IFACE) && defined(BPF_HAVE_FIB_LOOKUP)\n",
        "    encrypt_iface = ENCRYPT_IFACE;\n",
        "\n",
        "#endif\n",
        "    ret = do_netdev_encrypt_pools (ctx);\n",
        "    if (ret)\n",
        "        return send_drop_notify_error (ctx, src_id, ret, CTX_ACT_DROP, METRIC_INGRESS);\n",
        "    ret = do_netdev_encrypt_fib (ctx, proto, & encrypt_iface, & ext_err);\n",
        "    if (ret)\n",
        "        return send_drop_notify_error_ext (ctx, src_id, ret, ext_err, CTX_ACT_DROP, METRIC_INGRESS);\n",
        "    bpf_clear_meta (ctx);\n",
        "\n",
        "#ifdef BPF_HAVE_FIB_LOOKUP\n",
        "    if (encrypt_iface)\n",
        "        return ctx_redirect (ctx, encrypt_iface, 0);\n",
        "\n",
        "#endif\n",
        "    return CTX_ACT_OK;\n",
        "}\n"
      ],
      "called_function_list": [
        "do_netdev_encrypt_pools",
        "bpf_clear_meta",
        "do_netdev_encrypt_encap",
        "ctx_redirect",
        "do_netdev_encrypt_fib"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 904,
      "endLine": 908,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c",
      "funcName": "do_netdev_encrypt",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " __u16 proto __maybe_unused",
        " __u32 src_id"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int do_netdev_encrypt (struct  __ctx_buff *ctx, __u16 proto __maybe_unused, __u32 src_id)\n",
        "{\n",
        "    return do_netdev_encrypt_encap (ctx, src_id);\n",
        "}\n"
      ],
      "called_function_list": [
        "do_netdev_encrypt_pools",
        "bpf_clear_meta",
        "do_netdev_encrypt_encap",
        "ctx_redirect",
        "do_netdev_encrypt_fib"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "do_netdev_encrypt_encap": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 888,
      "endLine": 902,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c",
      "funcName": "do_netdev_encrypt_encap",
      "developer_inline_comments": [
        {
          "start_line": 887,
          "end_line": 887,
          "text": "/* TUNNEL_MODE */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " __u32 src_id"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int do_netdev_encrypt_encap (struct  __ctx_buff *ctx, __u32 src_id)\n",
        "{\n",
        "    struct trace_ctx trace = {\n",
        "        .reason = TRACE_REASON_ENCRYPTED,\n",
        "        .monitor = TRACE_PAYLOAD_LEN,}\n",
        "    ;\n",
        "    __u32 tunnel_endpoint = 0;\n",
        "    tunnel_endpoint = ctx_load_meta (ctx, CB_ENCRYPT_DST);\n",
        "    ctx->mark = 0;\n",
        "    bpf_clear_meta (ctx);\n",
        "    return __encap_and_redirect_with_nodeid (ctx, tunnel_endpoint, src_id, NOT_VTEP_DST, &trace);\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_load_meta",
        "__encap_and_redirect_with_nodeid",
        "bpf_clear_meta"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "do_netdev": [
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 912,
      "endLine": 1022,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c",
      "funcName": "do_netdev",
      "developer_inline_comments": [
        {
          "start_line": 910,
          "end_line": 910,
          "text": "/* ENABLE_IPSEC */"
        },
        {
          "start_line": 981,
          "end_line": 981,
          "text": "/* See comment below for IPv4. */"
        },
        {
          "start_line": 992,
          "end_line": 995,
          "text": "/* If we don't rely on BPF-based masquerading, we need\n\t\t\t * to pass the srcid from ipcache to host firewall. See\n\t\t\t * comment in ipv4_host_policy_egress() for details.\n\t\t\t */"
        },
        {
          "start_line": 1002,
          "end_line": 1007,
          "text": "/* We are not returning an error here to always allow traffic to\n\t\t * the stack in case maps have become unavailable.\n\t\t *\n\t\t * Note: Since drop notification requires a tail call as well,\n\t\t * this notification is unlikely to succeed.\n\t\t */"
        },
        {
          "start_line": 1016,
          "end_line": 1016,
          "text": "/* Pass unknown traffic to the stack */"
        },
        {
          "start_line": 1018,
          "end_line": 1018,
          "text": "/* ENABLE_HOST_FIREWALL */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " __u16 proto",
        " const bool from_host"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "CTX_ACT_OK",
        "tail_call"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "static __always_inline int do_netdev (struct  __ctx_buff *ctx, __u16 proto, const bool from_host)\n",
        "{\n",
        "    __u32 __maybe_unused identity = 0;\n",
        "    __u32 __maybe_unused ipcache_srcid = 0;\n",
        "    int ret;\n",
        "\n",
        "#if defined(ENABLE_L7_LB)\n",
        "    if (from_host) {\n",
        "        __u32 magic = ctx->mark & MARK_MAGIC_HOST_MASK;\n",
        "        if (magic == MARK_MAGIC_PROXY_EGRESS_EPID) {\n",
        "            __u32 lxc_id = get_epid (ctx);\n",
        "            ctx->mark = 0;\n",
        "            tail_call_dynamic (ctx, &POLICY_EGRESSCALL_MAP, lxc_id);\n",
        "            return DROP_MISSED_TAIL_CALL;\n",
        "        }\n",
        "    }\n",
        "\n",
        "#endif\n",
        "\n",
        "#ifdef ENABLE_IPSEC\n",
        "    if (!from_host && !do_decrypt (ctx, proto))\n",
        "        return CTX_ACT_OK;\n",
        "\n",
        "#endif\n",
        "    if (from_host) {\n",
        "        __u32 magic;\n",
        "        enum trace_point trace = TRACE_FROM_HOST;\n",
        "        magic = inherit_identity_from_host (ctx, & identity);\n",
        "        if (magic == MARK_MAGIC_PROXY_INGRESS || magic == MARK_MAGIC_PROXY_EGRESS)\n",
        "            trace = TRACE_FROM_PROXY;\n",
        "\n",
        "#ifdef ENABLE_IPSEC\n",
        "        if (magic == MARK_MAGIC_ENCRYPT) {\n",
        "            send_trace_notify (ctx, TRACE_FROM_STACK, identity, 0, 0, ctx->ingress_ifindex, TRACE_REASON_ENCRYPTED, TRACE_PAYLOAD_LEN);\n",
        "            return do_netdev_encrypt (ctx, proto, identity);\n",
        "        }\n",
        "\n",
        "#endif\n",
        "        send_trace_notify (ctx, trace, identity, 0, 0, ctx->ingress_ifindex, TRACE_REASON_UNKNOWN, TRACE_PAYLOAD_LEN);\n",
        "    }\n",
        "    else {\n",
        "        bpf_skip_nodeport_clear (ctx);\n",
        "        send_trace_notify (ctx, TRACE_FROM_NETWORK, 0, 0, 0, ctx->ingress_ifindex, TRACE_REASON_UNKNOWN, TRACE_PAYLOAD_LEN);\n",
        "    }\n",
        "    bpf_clear_meta (ctx);\n",
        "    switch (proto) {\n",
        "\n",
        "# if defined ENABLE_ARP_PASSTHROUGH || defined ENABLE_ARP_RESPONDER\n",
        "    case bpf_htons (ETH_P_ARP) :\n",
        "        ret = CTX_ACT_OK;\n",
        "        break;\n",
        "\n",
        "# endif\n",
        "\n",
        "#ifdef ENABLE_IPV6\n",
        "    case bpf_htons (ETH_P_IPV6) :\n",
        "        identity = resolve_srcid_ipv6 (ctx, identity, from_host);\n",
        "        ctx_store_meta (ctx, CB_SRC_IDENTITY, identity);\n",
        "        if (from_host)\n",
        "            ep_tail_call (ctx, CILIUM_CALL_IPV6_FROM_HOST);\n",
        "        else\n",
        "            ep_tail_call (ctx, CILIUM_CALL_IPV6_FROM_NETDEV);\n",
        "        return send_drop_notify_error (ctx, identity, DROP_MISSED_TAIL_CALL, CTX_ACT_OK, METRIC_INGRESS);\n",
        "\n",
        "#endif\n",
        "\n",
        "#ifdef ENABLE_IPV4\n",
        "    case bpf_htons (ETH_P_IP) :\n",
        "        identity = resolve_srcid_ipv4 (ctx, identity, &ipcache_srcid, from_host);\n",
        "        ctx_store_meta (ctx, CB_SRC_IDENTITY, identity);\n",
        "        if (from_host) {\n",
        "\n",
        "# if defined(ENABLE_HOST_FIREWALL) && !defined(ENABLE_MASQUERADE)\n",
        "            ctx_store_meta (ctx, CB_IPCACHE_SRC_LABEL, ipcache_srcid);\n",
        "\n",
        "# endif\n",
        "            ep_tail_call (ctx, CILIUM_CALL_IPV4_FROM_HOST);\n",
        "        }\n",
        "        else {\n",
        "            ep_tail_call (ctx, CILIUM_CALL_IPV4_FROM_NETDEV);\n",
        "        }\n",
        "        return send_drop_notify_error (ctx, identity, DROP_MISSED_TAIL_CALL, CTX_ACT_OK, METRIC_INGRESS);\n",
        "\n",
        "#endif\n",
        "    default :\n",
        "\n",
        "#ifdef ENABLE_HOST_FIREWALL\n",
        "        ret = send_drop_notify_error (ctx, identity, DROP_UNKNOWN_L3, CTX_ACT_DROP, METRIC_INGRESS);\n",
        "\n",
        "#else\n",
        "        ret = CTX_ACT_OK;\n",
        "\n",
        "#endif /* ENABLE_HOST_FIREWALL */\n",
        "    }\n",
        "    return ret;\n",
        "}\n"
      ],
      "called_function_list": [
        "resolve_srcid_ipv4",
        "ctx_store_meta",
        "bpf_clear_meta",
        "bpf_skip_nodeport_clear",
        "get_epid",
        "do_decrypt",
        "ep_tail_call",
        "send_trace_notify",
        "do_netdev_encrypt",
        "inherit_identity_from_host",
        "resolve_srcid_ipv6",
        "tail_call_dynamic"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "handle_netdev": [
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 1031,
      "endLine": 1051,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c",
      "funcName": "handle_netdev",
      "developer_inline_comments": [
        {
          "start_line": 1024,
          "end_line": 1030,
          "text": "/**\n * handle_netdev\n * @ctx\t\tThe packet context for this program\n * @from_host\tTrue if the packet is from the local host\n *\n * Handle netdev traffic coming towards the Cilium-managed network.\n */"
        },
        {
          "start_line": 1045,
          "end_line": 1045,
          "text": "/* Pass unknown traffic to the stack */"
        },
        {
          "start_line": 1047,
          "end_line": 1047,
          "text": "/* ENABLE_HOST_FIREWALL */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " const bool from_host"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "CTX_ACT_OK"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "static __always_inline int handle_netdev (struct  __ctx_buff *ctx, const bool from_host)\n",
        "{\n",
        "    __u16 proto;\n",
        "    if (!validate_ethertype (ctx, &proto)) {\n",
        "\n",
        "#ifdef ENABLE_HOST_FIREWALL\n",
        "        int ret = DROP_UNSUPPORTED_L2;\n",
        "        return send_drop_notify (ctx, SECLABEL, WORLD_ID, 0, ret, CTX_ACT_DROP, METRIC_EGRESS);\n",
        "\n",
        "#else\n",
        "        send_trace_notify (ctx, TRACE_TO_STACK, HOST_ID, 0, 0, 0, TRACE_REASON_UNKNOWN, 0);\n",
        "        return CTX_ACT_OK;\n",
        "\n",
        "#endif /* ENABLE_HOST_FIREWALL */\n",
        "    }\n",
        "    return do_netdev (ctx, proto, from_host);\n",
        "}\n"
      ],
      "called_function_list": [
        "do_netdev",
        "send_trace_notify",
        "validate_ethertype"
      ],
      "call_depth": 4,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "handle_srv6": [
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 1054,
      "endLine": 1142,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c",
      "funcName": "handle_srv6",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "static__always_inline",
      "helper": [
        "CTX_ACT_OK"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "static __always_inline handle_srv6 (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    __u32 *vrf_id, dst_id, tunnel_ep = 0;\n",
        "    struct srv6_ipv6_2tuple *outer_ips;\n",
        "    struct iphdr * ip4 __maybe_unused;\n",
        "    struct remote_endpoint_info *ep;\n",
        "    void *data, *data_end;\n",
        "    struct ipv6hdr *ip6;\n",
        "    union v6addr *sid;\n",
        "    __u16 proto;\n",
        "    if (!validate_ethertype (ctx, &proto))\n",
        "        return DROP_UNSUPPORTED_L2;\n",
        "    switch (proto) {\n",
        "    case bpf_htons (ETH_P_IPV6) :\n",
        "        if (!revalidate_data (ctx, &data, &data_end, &ip6))\n",
        "            return DROP_INVALID;\n",
        "        outer_ips = srv6_lookup_state_entry6 (ip6);\n",
        "        if (outer_ips) {\n",
        "            ep_tail_call (ctx, CILIUM_CALL_SRV6_REPLY);\n",
        "            return DROP_MISSED_TAIL_CALL;\n",
        "        }\n",
        "        ep = lookup_ip6_remote_endpoint ((union v6addr *) & ip6 -> daddr);\n",
        "        if (ep) {\n",
        "            tunnel_ep = ep->tunnel_endpoint;\n",
        "            dst_id = ep->sec_label;\n",
        "        }\n",
        "        else {\n",
        "            dst_id = WORLD_ID;\n",
        "        }\n",
        "        if (identity_is_cluster (dst_id))\n",
        "            return CTX_ACT_OK;\n",
        "        vrf_id = srv6_lookup_vrf6 (& ip6 -> saddr, & ip6 -> daddr);\n",
        "        if (!vrf_id)\n",
        "            return CTX_ACT_OK;\n",
        "        sid = srv6_lookup_policy6 (* vrf_id, & ip6 -> daddr);\n",
        "        if (!sid)\n",
        "            return CTX_ACT_OK;\n",
        "        srv6_store_meta_sid (ctx, sid);\n",
        "        ctx_store_meta (ctx, CB_SRV6_VRF_ID, *vrf_id);\n",
        "        ep_tail_call (ctx, CILIUM_CALL_SRV6_ENCAP);\n",
        "        return DROP_MISSED_TAIL_CALL;\n",
        "\n",
        "# ifdef ENABLE_IPV4\n",
        "    case bpf_htons (ETH_P_IP) :\n",
        "        if (!revalidate_data (ctx, &data, &data_end, &ip4))\n",
        "            return DROP_INVALID;\n",
        "        outer_ips = srv6_lookup_state_entry4 (ip4);\n",
        "        if (outer_ips) {\n",
        "            ep_tail_call (ctx, CILIUM_CALL_SRV6_REPLY);\n",
        "            return DROP_MISSED_TAIL_CALL;\n",
        "        }\n",
        "        ep = lookup_ip4_remote_endpoint (ip4 -> daddr);\n",
        "        if (ep) {\n",
        "            tunnel_ep = ep->tunnel_endpoint;\n",
        "            dst_id = ep->sec_label;\n",
        "        }\n",
        "        else {\n",
        "            dst_id = WORLD_ID;\n",
        "        }\n",
        "        if (identity_is_cluster (dst_id))\n",
        "            return CTX_ACT_OK;\n",
        "        vrf_id = srv6_lookup_vrf4 (ip4 -> saddr, ip4 -> daddr);\n",
        "        if (!vrf_id)\n",
        "            return CTX_ACT_OK;\n",
        "        sid = srv6_lookup_policy4 (* vrf_id, ip4 -> daddr);\n",
        "        if (!sid)\n",
        "            return CTX_ACT_OK;\n",
        "        srv6_store_meta_sid (ctx, sid);\n",
        "        ctx_store_meta (ctx, CB_SRV6_VRF_ID, *vrf_id);\n",
        "        ep_tail_call (ctx, CILIUM_CALL_SRV6_ENCAP);\n",
        "        return DROP_MISSED_TAIL_CALL;\n",
        "        break;\n",
        "\n",
        "# endif\n",
        "    }\n",
        "    return CTX_ACT_OK;\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_store_meta",
        "srv6_lookup_state_entry6",
        "srv6_lookup_vrf4",
        "ep_tail_call",
        "srv6_lookup_policy4",
        "validate_ethertype",
        "identity_is_cluster",
        "srv6_lookup_state_entry4",
        "srv6_lookup_policy6",
        "srv6_lookup_vrf6",
        "srv6_store_meta_sid"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "from_netdev": [
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 1152,
      "endLine": 1170,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c",
      "funcName": "from_netdev",
      "developer_inline_comments": [
        {
          "start_line": 1145,
          "end_line": 1150,
          "text": "/*\n * from-netdev is attached as a tc ingress filter to one or more physical devices\n * managed by Cilium (e.g., eth0). This program is only attached when:\n * - the host firewall is enabled, or\n * - BPF NodePort is enabled\n */"
        },
        {
          "start_line": 1156,
          "end_line": 1157,
          "text": "/* Filter allowed vlan id's and pass them back to kernel.\n\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "int",
      "helper": [
        "CTX_ACT_OK"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "int from_netdev (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    __u32 __maybe_unused vlan_id;\n",
        "    if (ctx->vlan_present) {\n",
        "        vlan_id = ctx->vlan_tci & 0xfff;\n",
        "        if (vlan_id) {\n",
        "            if (allow_vlan (ctx->ifindex, vlan_id))\n",
        "                return CTX_ACT_OK;\n",
        "            else\n",
        "                return send_drop_notify_error (ctx, 0, DROP_VLAN_FILTERED, CTX_ACT_DROP, METRIC_INGRESS);\n",
        "        }\n",
        "    }\n",
        "    return handle_netdev (ctx, false);\n",
        "}\n"
      ],
      "called_function_list": [
        "allow_vlan",
        "handle_netdev"
      ],
      "call_depth": 5,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "from_host": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1177,
      "endLine": 1184,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c",
      "funcName": "from_host",
      "developer_inline_comments": [
        {
          "start_line": 1172,
          "end_line": 1175,
          "text": "/*\n * from-host is attached as a tc egress filter to the node's 'cilium_host'\n * interface if present.\n */"
        },
        {
          "start_line": 1179,
          "end_line": 1181,
          "text": "/* Traffic from the host ns going through cilium_host device must\n\t * not be subject to EDT rate-limiting.\n\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "int",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "int from_host (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    edt_set_aggregate (ctx, 0);\n",
        "    return handle_netdev (ctx, true);\n",
        "}\n"
      ],
      "called_function_list": [
        "handle_netdev",
        "edt_set_aggregate"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "to_netdev": [
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 1193,
      "endLine": 1319,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c",
      "funcName": "to_netdev",
      "developer_inline_comments": [
        {
          "start_line": 1186,
          "end_line": 1191,
          "text": "/*\n * to-netdev is attached as a tc egress filter to one or more physical devices\n * managed by Cilium (e.g., eth0). This program is only attached when:\n * - the host firewall is enabled, or\n * - BPF NodePort is enabled\n */"
        },
        {
          "start_line": 1204,
          "end_line": 1205,
          "text": "/* Filter allowed vlan id's and pass them back to kernel.\n\t */"
        },
        {
          "start_line": 1264,
          "end_line": 1264,
          "text": "/* ENABLE_HOST_FIREWALL */"
        },
        {
          "start_line": 1268,
          "end_line": 1268,
          "text": "/* No send_drop_notify_error() here given we're rate-limiting. */"
        },
        {
          "start_line": 1281,
          "end_line": 1281,
          "text": "/* ENABLE_SRV6 */"
        },
        {
          "start_line": 1289,
          "end_line": 1292,
          "text": "/*\n\t\t * handle_nat_fwd tail calls in the majority of cases,\n\t\t * so control might never return to this program.\n\t\t */"
        },
        {
          "start_line": 1299,
          "end_line": 1304,
          "text": "/*\n\t\t * Depending on the condition, handle_nat_fwd may return\n\t\t * without tail calling. Since we have packet tracing inside\n\t\t * the handle_nat_fwd, we need to avoid tracing the packet\n\t\t * twice.\n\t\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff * ctx __maybe_unused"
      ],
      "output": "int",
      "helper": [
        "CTX_ACT_OK",
        "tail_call"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "int to_netdev (struct  __ctx_buff * ctx __maybe_unused)\n",
        "{\n",
        "    struct trace_ctx trace = {\n",
        "        .reason = TRACE_REASON_UNKNOWN,\n",
        "        .monitor = 0,}\n",
        "    ;\n",
        "    __u16 __maybe_unused proto = 0;\n",
        "    __u32 __maybe_unused vlan_id;\n",
        "    int ret = CTX_ACT_OK;\n",
        "    bool traced = false;\n",
        "    if (ctx->vlan_present) {\n",
        "        vlan_id = ctx->vlan_tci & 0xfff;\n",
        "        if (vlan_id) {\n",
        "            if (allow_vlan (ctx->ifindex, vlan_id))\n",
        "                return CTX_ACT_OK;\n",
        "            else\n",
        "                return send_drop_notify_error (ctx, 0, DROP_VLAN_FILTERED, CTX_ACT_DROP, METRIC_EGRESS);\n",
        "        }\n",
        "    }\n",
        "\n",
        "#if defined(ENABLE_L7_LB)\n",
        "    {\n",
        "        __u32 magic = ctx->mark & MARK_MAGIC_HOST_MASK;\n",
        "        if (magic == MARK_MAGIC_PROXY_EGRESS_EPID) {\n",
        "            __u32 lxc_id = get_epid (ctx);\n",
        "            ctx->mark = 0;\n",
        "            tail_call_dynamic (ctx, &POLICY_EGRESSCALL_MAP, lxc_id);\n",
        "            return DROP_MISSED_TAIL_CALL;\n",
        "        }\n",
        "    }\n",
        "\n",
        "#endif\n",
        "\n",
        "#ifdef ENABLE_HOST_FIREWALL\n",
        "    if (!proto && !validate_ethertype (ctx, &proto)) {\n",
        "        ret = DROP_UNSUPPORTED_L2;\n",
        "        goto out;\n",
        "    }\n",
        "    policy_clear_mark (ctx);\n",
        "    switch (proto) {\n",
        "\n",
        "# if defined ENABLE_ARP_PASSTHROUGH || defined ENABLE_ARP_RESPONDER\n",
        "    case bpf_htons (ETH_P_ARP) :\n",
        "        ret = CTX_ACT_OK;\n",
        "        break;\n",
        "\n",
        "# endif\n",
        "\n",
        "# ifdef ENABLE_IPV6\n",
        "    case bpf_htons (ETH_P_IPV6) :\n",
        "        ret = handle_to_netdev_ipv6 (ctx, &trace);\n",
        "        break;\n",
        "\n",
        "# endif\n",
        "\n",
        "# ifdef ENABLE_IPV4\n",
        "    case bpf_htons (ETH_P_IP) :\n",
        "        {\n",
        "            ret = handle_to_netdev_ipv4 (ctx, & trace);\n",
        "            break;\n",
        "        }\n",
        "\n",
        "# endif\n",
        "    default :\n",
        "        ret = DROP_UNKNOWN_L3;\n",
        "        break;\n",
        "    }\n",
        "out :\n",
        "    if (IS_ERR (ret))\n",
        "        return send_drop_notify_error (ctx, 0, ret, CTX_ACT_DROP, METRIC_EGRESS);\n",
        "\n",
        "#endif /* ENABLE_HOST_FIREWALL */\n",
        "\n",
        "#if defined(ENABLE_BANDWIDTH_MANAGER)\n",
        "    ret = edt_sched_departure (ctx);\n",
        "    if (ret == CTX_ACT_DROP) {\n",
        "        update_metrics (ctx_full_len (ctx), METRIC_EGRESS, -DROP_EDT_HORIZON);\n",
        "        return ret;\n",
        "    }\n",
        "\n",
        "#endif\n",
        "\n",
        "#ifdef ENABLE_SRV6\n",
        "    ret = handle_srv6 (ctx);\n",
        "    if (ret != CTX_ACT_OK)\n",
        "        return send_drop_notify_error (ctx, 0, ret, CTX_ACT_DROP, METRIC_EGRESS);\n",
        "\n",
        "#endif /* ENABLE_SRV6 */\n",
        "\n",
        "#if defined(ENABLE_NODEPORT) && \\\n",
        "\t(!defined(ENABLE_DSR) || \\\n",
        "\t (defined(ENABLE_DSR) && defined(ENABLE_DSR_HYBRID)) || \\\n",
        "\t defined(ENABLE_MASQUERADE) || \\\n",
        "\t defined(ENABLE_EGRESS_GATEWAY))\n",
        "    if ((ctx->mark & MARK_MAGIC_SNAT_DONE) != MARK_MAGIC_SNAT_DONE) {\n",
        "        ret = handle_nat_fwd (ctx);\n",
        "        if (IS_ERR (ret))\n",
        "            return send_drop_notify_error (ctx, 0, ret, CTX_ACT_DROP, METRIC_EGRESS);\n",
        "        traced = true;\n",
        "    }\n",
        "\n",
        "#endif\n",
        "\n",
        "#ifdef ENABLE_HEALTH_CHECK\n",
        "    ret = lb_handle_health (ctx);\n",
        "    if (IS_ERR (ret))\n",
        "        return send_drop_notify_error (ctx, 0, ret, CTX_ACT_DROP, METRIC_EGRESS);\n",
        "\n",
        "#endif\n",
        "    if (!traced)\n",
        "        send_trace_notify (ctx, TRACE_TO_NETWORK, 0, 0, 0, 0, trace.reason, trace.monitor);\n",
        "    return ret;\n",
        "}\n"
      ],
      "called_function_list": [
        "lb_handle_health",
        "handle_srv6",
        "allow_vlan",
        "get_epid",
        "handle_nat_fwd",
        "send_trace_notify",
        "validate_ethertype",
        "policy_clear_mark",
        "handle_to_netdev_ipv4",
        "edt_sched_departure",
        "handle_to_netdev_ipv6",
        "ctx_full_len",
        "tail_call_dynamic",
        "update_metrics"
      ],
      "call_depth": 5,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "to_host": [
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 1326,
      "endLine": 1406,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c",
      "funcName": "to_host",
      "developer_inline_comments": [
        {
          "start_line": 1321,
          "end_line": 1324,
          "text": "/*\n * to-host is attached as a tc ingress filter to both the 'cilium_host' and\n * 'cilium_net' devices if present.\n */"
        },
        {
          "start_line": 1339,
          "end_line": 1339,
          "text": "/* CB_ENCRYPT_MAGIC */"
        },
        {
          "start_line": 1343,
          "end_line": 1343,
          "text": "/* Upper 16 bits may carry proxy port number */"
        },
        {
          "start_line": 1350,
          "end_line": 1352,
          "text": "/* We already traced this in the previous prog with more\n\t\t * background context, skip trace here.\n\t\t */"
        },
        {
          "start_line": 1357,
          "end_line": 1361,
          "text": "/* Encryption stack needs this when IPSec headers are\n\t * rewritten without FIB helper because we do not yet\n\t * know correct MAC address which will cause the stack\n\t * to mark as PACKET_OTHERHOST and drop.\n\t */"
        },
        {
          "start_line": 1394,
          "end_line": 1394,
          "text": "/* ENABLE_HOST_FIREWALL */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "int",
      "helper": [
        "CTX_ACT_OK"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "int to_host (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    __u32 magic = ctx_load_meta (ctx, ENCRYPT_OR_PROXY_MAGIC);\n",
        "    __u16 __maybe_unused proto = 0;\n",
        "    struct trace_ctx trace = {\n",
        "        .reason = TRACE_REASON_UNKNOWN,\n",
        "        .monitor = 0,}\n",
        "    ;\n",
        "    int ret = CTX_ACT_OK;\n",
        "    bool traced = false;\n",
        "    __u32 src_id = 0;\n",
        "    if ((magic & MARK_MAGIC_HOST_MASK) == MARK_MAGIC_ENCRYPT) {\n",
        "        ctx->mark = magic;\n",
        "        src_id = ctx_load_meta (ctx, CB_ENCRYPT_IDENTITY);\n",
        "        set_identity_mark (ctx, src_id);\n",
        "    }\n",
        "    else if ((magic & 0xFFFF) == MARK_MAGIC_TO_PROXY) {\n",
        "        __be16 port = magic >> 16;\n",
        "        ctx_store_meta (ctx, CB_PROXY_MAGIC, 0);\n",
        "        ret = ctx_redirect_to_proxy_first (ctx, port);\n",
        "        if (IS_ERR (ret))\n",
        "            goto out;\n",
        "        traced = true;\n",
        "    }\n",
        "\n",
        "#ifdef ENABLE_IPSEC\n",
        "    ctx_change_type (ctx, PACKET_HOST);\n",
        "\n",
        "#endif\n",
        "\n",
        "#ifdef ENABLE_HOST_FIREWALL\n",
        "    if (!validate_ethertype (ctx, &proto)) {\n",
        "        ret = DROP_UNSUPPORTED_L2;\n",
        "        goto out;\n",
        "    }\n",
        "    policy_clear_mark (ctx);\n",
        "    switch (proto) {\n",
        "\n",
        "# if defined ENABLE_ARP_PASSTHROUGH || defined ENABLE_ARP_RESPONDER\n",
        "    case bpf_htons (ETH_P_ARP) :\n",
        "        ret = CTX_ACT_OK;\n",
        "        break;\n",
        "\n",
        "# endif\n",
        "\n",
        "# ifdef ENABLE_IPV6\n",
        "    case bpf_htons (ETH_P_IPV6) :\n",
        "        ret = ipv6_host_policy_ingress (ctx, &src_id, &trace);\n",
        "        break;\n",
        "\n",
        "# endif\n",
        "\n",
        "# ifdef ENABLE_IPV4\n",
        "    case bpf_htons (ETH_P_IP) :\n",
        "        ret = ipv4_host_policy_ingress (ctx, &src_id, &trace);\n",
        "        break;\n",
        "\n",
        "# endif\n",
        "    default :\n",
        "        ret = DROP_UNKNOWN_L3;\n",
        "        break;\n",
        "    }\n",
        "\n",
        "#else\n",
        "    ret = CTX_ACT_OK;\n",
        "\n",
        "#endif /* ENABLE_HOST_FIREWALL */\n",
        "out :\n",
        "    if (IS_ERR (ret))\n",
        "        return send_drop_notify_error (ctx, src_id, ret, CTX_ACT_DROP, METRIC_INGRESS);\n",
        "    if (!traced)\n",
        "        send_trace_notify (ctx, TRACE_TO_STACK, src_id, 0, 0, CILIUM_IFINDEX, trace.reason, trace.monitor);\n",
        "    return ret;\n",
        "}\n"
      ],
      "called_function_list": [
        "set_identity_mark",
        "ctx_store_meta",
        "send_trace_notify",
        "validate_ethertype",
        "ctx_redirect_to_proxy_first",
        "policy_clear_mark",
        "ipv4_host_policy_ingress",
        "ctx_load_meta",
        "ipv6_host_policy_ingress"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "tail_ipv6_host_policy_ingress": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1412,
      "endLine": 1426,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c",
      "funcName": "tail_ipv6_host_policy_ingress",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "int",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "int tail_ipv6_host_policy_ingress (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    struct trace_ctx __maybe_unused trace = {\n",
        "        .reason = TRACE_REASON_UNKNOWN,\n",
        "        .monitor = 0,}\n",
        "    ;\n",
        "    __u32 src_id = 0;\n",
        "    int ret;\n",
        "    ret = ipv6_host_policy_ingress (ctx, & src_id, & trace);\n",
        "    if (IS_ERR (ret))\n",
        "        return send_drop_notify_error (ctx, src_id, ret, CTX_ACT_DROP, METRIC_INGRESS);\n",
        "    return ret;\n",
        "}\n"
      ],
      "called_function_list": [
        "ipv6_host_policy_ingress"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "tail_ipv4_host_policy_ingress": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1432,
      "endLine": 1446,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c",
      "funcName": "tail_ipv4_host_policy_ingress",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "int",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "int tail_ipv4_host_policy_ingress (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    struct trace_ctx __maybe_unused trace = {\n",
        "        .reason = TRACE_REASON_UNKNOWN,\n",
        "        .monitor = TRACE_PAYLOAD_LEN,}\n",
        "    ;\n",
        "    __u32 src_id = 0;\n",
        "    int ret;\n",
        "    ret = ipv4_host_policy_ingress (ctx, & src_id, & trace);\n",
        "    if (IS_ERR (ret))\n",
        "        return send_drop_notify_error (ctx, src_id, ret, CTX_ACT_DROP, METRIC_INGRESS);\n",
        "    return ret;\n",
        "}\n"
      ],
      "called_function_list": [
        "ipv4_host_policy_ingress"
      ],
      "call_depth": 4,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "to_host_from_lxc": [
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 1449,
      "endLine": 1497,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c",
      "funcName": "to_host_from_lxc",
      "developer_inline_comments": [
        {
          "start_line": 1450,
          "end_line": 1452,
          "text": "/* Handles packet from a local endpoint entering the host namespace. Applies\n * ingress host policies.\n */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff * ctx __maybe_unused"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "CTX_ACT_OK"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "static __always_inline int to_host_from_lxc (struct  __ctx_buff * ctx __maybe_unused)\n",
        "{\n",
        "    int ret = CTX_ACT_OK;\n",
        "    __u16 proto = 0;\n",
        "    if (!validate_ethertype (ctx, &proto)) {\n",
        "        ret = DROP_UNSUPPORTED_L2;\n",
        "        goto out;\n",
        "    }\n",
        "    switch (proto) {\n",
        "\n",
        "# if defined ENABLE_ARP_PASSTHROUGH || defined ENABLE_ARP_RESPONDER\n",
        "    case bpf_htons (ETH_P_ARP) :\n",
        "        ret = CTX_ACT_OK;\n",
        "        break;\n",
        "\n",
        "# endif\n",
        "\n",
        "# ifdef ENABLE_IPV6\n",
        "    case bpf_htons (ETH_P_IPV6) :\n",
        "        invoke_tailcall_if (__or (__and (is_defined (ENABLE_IPV4), is_defined (ENABLE_IPV6)), is_defined (DEBUG)), CILIUM_CALL_IPV6_TO_HOST_POLICY_ONLY, tail_ipv6_host_policy_ingress);\n",
        "        break;\n",
        "\n",
        "# endif\n",
        "\n",
        "# ifdef ENABLE_IPV4\n",
        "    case bpf_htons (ETH_P_IP) :\n",
        "        invoke_tailcall_if (__or (__and (is_defined (ENABLE_IPV4), is_defined (ENABLE_IPV6)), is_defined (DEBUG)), CILIUM_CALL_IPV4_TO_HOST_POLICY_ONLY, tail_ipv4_host_policy_ingress);\n",
        "        break;\n",
        "\n",
        "# endif\n",
        "    default :\n",
        "        ret = DROP_UNKNOWN_L3;\n",
        "        break;\n",
        "    }\n",
        "out :\n",
        "    if (IS_ERR (ret))\n",
        "        return send_drop_notify_error (ctx, 0, ret, CTX_ACT_DROP, METRIC_INGRESS);\n",
        "    return ret;\n",
        "}\n"
      ],
      "called_function_list": [
        "validate_ethertype"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "from_host_to_lxc": [
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 1503,
      "endLine": 1545,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c",
      "funcName": "from_host_to_lxc",
      "developer_inline_comments": [
        {
          "start_line": 1499,
          "end_line": 1502,
          "text": "/* Handles packets that left the host namespace and will enter a local\n * endpoint's namespace. Applies egress host policies before handling\n * control back to bpf_lxc.\n */"
        },
        {
          "start_line": 1529,
          "end_line": 1535,
          "text": "/* The last parameter, ipcache_srcid, is only required when\n\t\t * the src_id is not HOST_ID. For details, see\n\t\t * whitelist_snated_egress_connections.\n\t\t * We only arrive here from bpf_lxc if we know the\n\t\t * src_id is HOST_ID. Therefore, we don't need to pass a value\n\t\t * for the last parameter. That avoids an ipcache lookup.\n\t\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "CTX_ACT_OK"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "static __always_inline int from_host_to_lxc (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    struct trace_ctx trace = {\n",
        "        .reason = TRACE_REASON_UNKNOWN,\n",
        "        .monitor = 0,}\n",
        "    ;\n",
        "    int ret = CTX_ACT_OK;\n",
        "    __u16 proto = 0;\n",
        "    if (!validate_ethertype (ctx, &proto))\n",
        "        return DROP_UNSUPPORTED_L2;\n",
        "    switch (proto) {\n",
        "\n",
        "# if defined ENABLE_ARP_PASSTHROUGH || defined ENABLE_ARP_RESPONDER\n",
        "    case bpf_htons (ETH_P_ARP) :\n",
        "        ret = CTX_ACT_OK;\n",
        "        break;\n",
        "\n",
        "# endif\n",
        "\n",
        "# ifdef ENABLE_IPV6\n",
        "    case bpf_htons (ETH_P_IPV6) :\n",
        "        ret = ipv6_host_policy_egress (ctx, HOST_ID, &trace);\n",
        "        break;\n",
        "\n",
        "# endif\n",
        "\n",
        "# ifdef ENABLE_IPV4\n",
        "    case bpf_htons (ETH_P_IP) :\n",
        "        ret = ipv4_host_policy_egress (ctx, HOST_ID, 0, &trace);\n",
        "        break;\n",
        "\n",
        "# endif\n",
        "    default :\n",
        "        ret = DROP_UNKNOWN_L3;\n",
        "        break;\n",
        "    }\n",
        "    return ret;\n",
        "}\n"
      ],
      "called_function_list": [
        "ipv6_host_policy_egress",
        "validate_ethertype",
        "ipv4_host_policy_egress"
      ],
      "call_depth": 4,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "handle_lxc_traffic": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1553,
      "endLine": 1572,
      "File": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c",
      "funcName": "handle_lxc_traffic",
      "developer_inline_comments": [
        {
          "start_line": 1547,
          "end_line": 1551,
          "text": "/* When per-endpoint routes are enabled, packets to and from local endpoints\n * will tail call into this program to enforce egress and ingress host policies.\n * Packets to the local endpoints will then tail call back to the original\n * bpf_lxc program.\n */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "int",
      "helper": [
        "tail_call"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "int handle_lxc_traffic (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    bool from_host = ctx_load_meta (ctx, CB_FROM_HOST);\n",
        "    __u32 lxc_id;\n",
        "    int ret;\n",
        "    if (from_host) {\n",
        "        ret = from_host_to_lxc (ctx);\n",
        "        if (IS_ERR (ret))\n",
        "            return send_drop_notify_error (ctx, HOST_ID, ret, CTX_ACT_DROP, METRIC_EGRESS);\n",
        "        lxc_id = ctx_load_meta (ctx, CB_DST_ENDPOINT_ID);\n",
        "        ctx_store_meta (ctx, CB_SRC_LABEL, HOST_ID);\n",
        "        tail_call_dynamic (ctx, &POLICY_CALL_MAP, lxc_id);\n",
        "        return DROP_MISSED_TAIL_CALL;\n",
        "    }\n",
        "    return to_host_from_lxc (ctx);\n",
        "}\n"
      ],
      "called_function_list": [
        "from_host_to_lxc",
        "ctx_store_meta",
        "to_host_from_lxc",
        "ctx_load_meta",
        "tail_call_dynamic"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "pin_to_cpu": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 30,
      "endLine": 38,
      "File": "/home/sayandes/opened_extraction/examples/cilium/cilium-probe-kernel-hz.c",
      "funcName": "pin_to_cpu",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": "// SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)"
        },
        {
          "start_line": 2,
          "end_line": 2,
          "text": "/* Copyright Authors of Cilium */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "int cpu"
      ],
      "output": "staticint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static int pin_to_cpu (int cpu)\n",
        "{\n",
        "    cpu_set_t set;\n",
        "    CPU_ZERO (&set);\n",
        "    CPU_SET (cpu, &set);\n",
        "    return sched_setaffinity (0, sizeof (set), &set);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": " clear CPU and reset a specific CPU in the set, then sets the CPU affinity mask of the thread ",
          "author": "Shun Zhang",
          "authorEmail": "shunz@bu.edu",
          "date": "2023-02-24"
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "fix_priority": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 40,
      "endLine": 47,
      "File": "/home/sayandes/opened_extraction/examples/cilium/cilium-probe-kernel-hz.c",
      "funcName": "fix_priority",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void"
      ],
      "output": "staticint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static int fix_priority (void)\n",
        "{\n",
        "    struct sched_param sp = {\n",
        "        .sched_priority = sched_get_priority_max (SCHED_FIFO),}\n",
        "    ;\n",
        "    return sched_setscheduler (0, SCHED_FIFO, &sp);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": " reset the maxmium for the scheduling policy specified by policy  ",
          "author": "Shun Zhang",
          "authorEmail": "shunz@bu.edu",
          "date": "2023-02-24"
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "timer_list_open": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 49,
      "endLine": 52,
      "File": "/home/sayandes/opened_extraction/examples/cilium/cilium-probe-kernel-hz.c",
      "funcName": "timer_list_open",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void"
      ],
      "output": "staticFILE",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static FILE *timer_list_open (void)\n",
        "{\n",
        "    return fopen (\"/proc/timer_list\", \"r\");\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": " read the timer_list file ",
          "author": "Shun Zhang",
          "authorEmail": "shunz@bu.edu",
          "date": "2023-02-24"
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "timer_list_close": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 54,
      "endLine": 57,
      "File": "/home/sayandes/opened_extraction/examples/cilium/cilium-probe-kernel-hz.c",
      "funcName": "timer_list_close",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "FILE *fp"
      ],
      "output": "staticvoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static void timer_list_close (FILE *fp)\n",
        "{\n",
        "    fclose (fp);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": " close file ",
          "author": "Shun Zhang",
          "authorEmail": "shunz@bu.edu",
          "date": "2023-02-24"
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "prep_kern_jiffies": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 59,
      "endLine": 92,
      "File": "/home/sayandes/opened_extraction/examples/cilium/cilium-probe-kernel-hz.c",
      "funcName": "prep_kern_jiffies",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct cpu_jiffies *before",
        " struct cpu_jiffies *after"
      ],
      "output": "staticint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static int prep_kern_jiffies (struct cpu_jiffies *before, struct cpu_jiffies *after)\n",
        "{\n",
        "    uint64_t jiffies = 0;\n",
        "    char buff [512];\n",
        "    int cpus = 0;\n",
        "    FILE *fp;\n",
        "    fp = timer_list_open ();\n",
        "    while (fp && fgets (buff, sizeof (buff), fp)) {\n",
        "        if (sscanf (buff, \"jiffies: %lu\\n\", &jiffies) == 1)\n",
        "            cpus++;\n",
        "    }\n",
        "    timer_list_close (fp);\n",
        "    if (!cpus) {\n",
        "        fprintf (stderr, \"No procfs support?\\n\");\n",
        "        return -EIO;\n",
        "    }\n",
        "    before->cpus = after->cpus = cpus;\n",
        "    before->jiffies = calloc (cpus, sizeof (*before->jiffies));\n",
        "    after->jiffies = calloc (cpus, sizeof (*before->jiffies));\n",
        "    if (!before->jiffies || !after->jiffies) {\n",
        "        free (before->jiffies);\n",
        "        free (after->jiffies);\n",
        "        fprintf (stderr, \"Error allocating per CPU jiffies: %s\\n\", strerror (errno));\n",
        "        return -EIO;\n",
        "    }\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "timer_list_close",
        "timer_list_open"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": " allocate the CPU jiffies with error check (*) ",
          "author": "Shun Zhang",
          "authorEmail": "shunz@bu.edu",
          "date": "2023-02-24"
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "fetch_kern_jiffies": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 94,
      "endLine": 113,
      "File": "/home/sayandes/opened_extraction/examples/cilium/cilium-probe-kernel-hz.c",
      "funcName": "fetch_kern_jiffies",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct cpu_jiffies *curr"
      ],
      "output": "staticint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static int fetch_kern_jiffies (const struct cpu_jiffies *curr)\n",
        "{\n",
        "    char buff [512];\n",
        "    int cpus = 0;\n",
        "    FILE *fp;\n",
        "    fp = timer_list_open ();\n",
        "    while (fp && fgets (buff, sizeof (buff), fp) && cpus < curr->cpus) {\n",
        "        if (sscanf (buff, \"jiffies: %lu\\n\", &curr->jiffies[cpus]) == 1)\n",
        "            cpus++;\n",
        "    }\n",
        "    timer_list_close (fp);\n",
        "    if (cpus != curr->cpus) {\n",
        "        fprintf (stderr, \"CPU mismatch when fetching jiffies\\n\");\n",
        "        return -EIO;\n",
        "    }\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "timer_list_close",
        "timer_list_open"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        {
          "description": " fetch the CPU jiffies to fit the cpus set in current cpu parameter ",
          "author": "Shun Zhang",
          "authorEmail": "shunz@bu.edu",
          "date": "2023-02-24"
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "dump_kern_jiffies": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 115,
      "endLine": 150,
      "File": "/home/sayandes/opened_extraction/examples/cilium/cilium-probe-kernel-hz.c",
      "funcName": "dump_kern_jiffies",
      "developer_inline_comments": [
        {
          "start_line": 142,
          "end_line": 142,
          "text": "/* warp: %lu jiffies */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct cpu_jiffies *fixed",
        " const struct cpu_jiffies *result",
        " bool macro"
      ],
      "output": "staticint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static int dump_kern_jiffies (const struct cpu_jiffies *fixed, const struct cpu_jiffies *result, bool macro)\n",
        "{\n",
        "    uint64_t delta, warp = 0;\n",
        "    int i, j, ret = -1;\n",
        "    int64_t x;\n",
        "    for (i = 0; i < result->cpus; i++) {\n",
        "        result->jiffies[i] -= fixed->jiffies[i];\n",
        "        for (j = 0, delta = ~0; j < ARRAY_SIZE (kernel_hz); j++) {\n",
        "            x = abs ((int64_t) (kernel_hz [j] - result -> jiffies [i]));\n",
        "            if (x < delta) {\n",
        "                delta = x;\n",
        "                fixed->jiffies[i] = kernel_hz[j];\n",
        "            }\n",
        "        }\n",
        "        if (delta > warp)\n",
        "            warp = delta;\n",
        "        if (fixed->jiffies[i] != fixed->jiffies[0]) {\n",
        "            fprintf (stderr, \"Probed jiffies mismatch: %lu vs %lu HZ\\n\", fixed->jiffies[i], fixed->jiffies[0]);\n",
        "            goto out;\n",
        "        }\n",
        "    }\n",
        "    if (macro)\n",
        "        printf (\"#define KERNEL_HZ %lu\\t/* warp: %lu jiffies */\\n\", fixed->jiffies[0], warp);\n",
        "    else\n",
        "        printf (\"%lu, %lu\\n\", fixed->jiffies[0], warp);\n",
        "    ret = 0;\n",
        "out :\n",
        "    free (fixed->jiffies);\n",
        "    free (result->jiffies);\n",
        "    return ret;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": " decrease the fixed jiffies from the result jiffies, reset fixed jiffies to the closest kernel_hz stop when any fixed_jiffies isn't constant with the first one. With a macro bool for debugging  ",
          "author": "Shun Zhang",
          "authorEmail": "shunz@bu.edu",
          "date": "2023-02-24"
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "sk_extract4_key": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 26,
      "endLine": 40,
      "File": "/home/sayandes/opened_extraction/examples/cilium/sockops/bpf_sockops.c",
      "funcName": "sk_extract4_key",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": "// SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)"
        },
        {
          "start_line": 2,
          "end_line": 2,
          "text": "/* Copyright Authors of Cilium */"
        },
        {
          "start_line": 34,
          "end_line": 38,
          "text": "/* clang-7.1 or higher seems to think it can do a 16-bit read here\n\t * which unfortunately most kernels (as of October 2019) do not\n\t * support, which leads to verifier failures. Insert a READ_ONCE\n\t * to make sure that a 32-bit read followed by shift is generated.\n\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct bpf_sock_ops *ops",
        " struct sock_key *key"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void sk_extract4_key (const struct bpf_sock_ops *ops, struct sock_key *key)\n",
        "{\n",
        "    key->dip4 = ops->remote_ip4;\n",
        "    key->sip4 = ops->local_ip4;\n",
        "    key->family = ENDPOINT_KEY_IPV4;\n",
        "    key->sport = (bpf_ntohl (ops->local_port) >> 16);\n",
        "    key->dport = READ_ONCE (ops->remote_port) >> 16;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": " set the sport and dport of the input key with 32 bits local port and remote port (ip4)  ",
          "author": "Shun Zhang",
          "authorEmail": "shunz@bu.edu",
          "date": "2023-02-24"
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "sk_lb4_key": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 42,
      "endLine": 48,
      "File": "/home/sayandes/opened_extraction/examples/cilium/sockops/bpf_sockops.c",
      "funcName": "sk_lb4_key",
      "developer_inline_comments": [
        {
          "start_line": 45,
          "end_line": 45,
          "text": "/* SK MSG is always egress, so use daddr */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct lb4_key *lb4",
        " const struct sock_key *key"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void sk_lb4_key (struct lb4_key *lb4, const struct sock_key *key)\n",
        "{\n",
        "    lb4->address = key->dip4;\n",
        "    lb4->dport = (__u16) key->dport;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": " copy address and dport of lb4 from socket key ",
          "author": "Shun Zhang",
          "authorEmail": "shunz@bu.edu",
          "date": "2023-02-24"
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "bpf_sock_ops_ipv4": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 55,
      "endLine": 118,
      "File": "/home/sayandes/opened_extraction/examples/cilium/sockops/bpf_sockops.c",
      "funcName": "bpf_sock_ops_ipv4",
      "developer_inline_comments": [
        {
          "start_line": 66,
          "end_line": 68,
          "text": "/* If endpoint a service use L4/L3 stack for now. These can be\n\t * pulled in as needed.\n\t */"
        },
        {
          "start_line": 74,
          "end_line": 74,
          "text": "/* Policy lookup required to learn proxy port */"
        },
        {
          "start_line": 98,
          "end_line": 105,
          "text": "/* Lookup IPv4 address, this will return a match if:\n\t * - The destination IP address belongs to the local endpoint manage\n\t *   by Cilium.\n\t * - The destination IP address is an IP address associated with the\n\t *   host itself.\n\t * Then because these are local IPs that have passed LB/Policy/NAT\n\t * blocks redirect directly to socket.\n\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct bpf_sock_ops *skops"
      ],
      "output": "staticinlinevoid",
      "helper": [
        "sock_hash_update"
      ],
      "compatibleHookpoints": [
        "sock_ops"
      ],
      "source": [
        "static inline void bpf_sock_ops_ipv4 (struct bpf_sock_ops *skops)\n",
        "{\n",
        "    struct lb4_key lb4_key = {}\n",
        "    ;\n",
        "    __u32 dip4, dport, dst_id = 0;\n",
        "    struct endpoint_info *exists;\n",
        "    struct lb4_service *svc;\n",
        "    struct sock_key key = {}\n",
        "    ;\n",
        "    int verdict;\n",
        "    sk_extract4_key (skops, &key);\n",
        "    sk_lb4_key (&lb4_key, &key);\n",
        "    svc = lb4_lookup_service (& lb4_key, true);\n",
        "    if (svc)\n",
        "        return;\n",
        "    if (1) {\n",
        "        struct remote_endpoint_info *info;\n",
        "        info = lookup_ip4_remote_endpoint (key.dip4);\n",
        "        if (info != NULL && info->sec_label)\n",
        "            dst_id = info->sec_label;\n",
        "        else\n",
        "            dst_id = WORLD_ID;\n",
        "    }\n",
        "    verdict = policy_sk_egress (dst_id, key.sip4, (__u16) key.dport);\n",
        "    if (redirect_to_proxy (verdict)) {\n",
        "        __be32 host_ip = IPV4_GATEWAY;\n",
        "        key.dip4 = key.sip4;\n",
        "        key.dport = key.sport;\n",
        "        key.sip4 = host_ip;\n",
        "        key.sport = verdict;\n",
        "        sock_hash_update (skops, &SOCK_OPS_MAP, &key, BPF_NOEXIST);\n",
        "        return;\n",
        "    }\n",
        "    exists = __lookup_ip4_endpoint (key.dip4);\n",
        "    if (!exists)\n",
        "        return;\n",
        "    dip4 = key.dip4;\n",
        "    dport = key.dport;\n",
        "    key.dip4 = key.sip4;\n",
        "    key.dport = key.sport;\n",
        "    key.sip4 = dip4;\n",
        "    key.sport = dport;\n",
        "    sock_hash_update (skops, &SOCK_OPS_MAP, &key, BPF_NOEXIST);\n",
        "}\n"
      ],
      "called_function_list": [
        "sk_lb4_key",
        "policy_sk_egress",
        "redirect_to_proxy",
        "__lookup_ip4_endpoint",
        "sk_extract4_key",
        "lb4_lookup_service"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        {
          "description": " update the destination and source port, ip to the skops with respect to whther  the packet is redirect to proxy port (or we say whether verdict is larger than 0) ",
          "author": "Shun Zhang",
          "authorEmail": "shunz@bu.edu",
          "date": "2023-02-24"
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "bpf_sock_ops_ipv6": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 122,
      "endLine": 126,
      "File": "/home/sayandes/opened_extraction/examples/cilium/sockops/bpf_sockops.c",
      "funcName": "bpf_sock_ops_ipv6",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct bpf_sock_ops *skops"
      ],
      "output": "staticinlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static inline void bpf_sock_ops_ipv6 (struct bpf_sock_ops *skops)\n",
        "{\n",
        "    if (skops->remote_ip4)\n",
        "        bpf_sock_ops_ipv4 (skops);\n",
        "}\n"
      ],
      "called_function_list": [
        "bpf_sock_ops_ipv4"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        {
          "description": " update the destination and source port, ip to the skops with respect to whther  the packet is redirect to proxy port (or we say whether verdict is larger than 0) same as bpf_sock_ops_ipv4 but adapt for ipv6 ",
          "author": "Shun Zhang",
          "authorEmail": "shunz@bu.edu",
          "date": "2023-02-24"
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "bpf_sockmap": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 130,
      "endLine": 154,
      "File": "/home/sayandes/opened_extraction/examples/cilium/sockops/bpf_sockops.c",
      "funcName": "bpf_sockmap",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct bpf_sock_ops *skops"
      ],
      "output": "int",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "int bpf_sockmap (struct bpf_sock_ops *skops)\n",
        "{\n",
        "    __u32 family, op;\n",
        "    family = skops->family;\n",
        "    op = skops->op;\n",
        "    switch (op) {\n",
        "    case BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB :\n",
        "    case BPF_SOCK_OPS_ACTIVE_ESTABLISHED_CB :\n",
        "\n",
        "#ifdef ENABLE_IPV6\n",
        "        if (family == AF_INET6)\n",
        "            bpf_sock_ops_ipv6 (skops);\n",
        "\n",
        "#endif\n",
        "\n",
        "#ifdef ENABLE_IPV4\n",
        "        if (family == AF_INET)\n",
        "            bpf_sock_ops_ipv4 (skops);\n",
        "\n",
        "#endif\n",
        "        break;\n",
        "    default :\n",
        "        break;\n",
        "    }\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "bpf_sock_ops_ipv4",
        "bpf_sock_ops_ipv6"
      ],
      "call_depth": 4,
      "humanFuncDescription": [
        {
          "description": " calling bpf_sock_ops_ipv4 or bpf_sock_ops_ipv6 according to the family ip version  ",
          "author": "Shun Zhang",
          "authorEmail": "shunz@bu.edu",
          "date": "2023-02-24"
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "sk_msg_extract4_key": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 25,
      "endLine": 39,
      "File": "/home/sayandes/opened_extraction/examples/cilium/sockops/bpf_redir.c",
      "funcName": "sk_msg_extract4_key",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": "// SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)"
        },
        {
          "start_line": 2,
          "end_line": 2,
          "text": "/* Copyright Authors of Cilium */"
        },
        {
          "start_line": 33,
          "end_line": 37,
          "text": "/* clang-7.1 or higher seems to think it can do a 16-bit read here\n\t * which unfortunately most kernels (as of October 2019) do not\n\t * support, which leads to verifier failures. Insert a READ_ONCE\n\t * to make sure that a 32-bit read followed by shift is generated.\n\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct sk_msg_md *msg",
        " struct sock_key *key"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void sk_msg_extract4_key (const struct sk_msg_md *msg, struct sock_key *key)\n",
        "{\n",
        "    key->dip4 = msg->remote_ip4;\n",
        "    key->sip4 = msg->local_ip4;\n",
        "    key->family = ENDPOINT_KEY_IPV4;\n",
        "    key->sport = (bpf_ntohl (msg->local_port) >> 16);\n",
        "    key->dport = READ_ONCE (msg->remote_port) >> 16;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        {
          "description": " set the sport and dport of the input key with 32 bits local port and remote port (ip4)  ",
          "author": "Shun Zhang",
          "authorEmail": "shunz@bu.edu",
          "date": "2023-02-24"
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "bpf_redir_proxy": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 42,
      "endLine": 67,
      "File": "/home/sayandes/opened_extraction/examples/cilium/sockops/bpf_redir.c",
      "funcName": "bpf_redir_proxy",
      "developer_inline_comments": [
        {
          "start_line": 52,
          "end_line": 56,
          "text": "/* Currently, pulling dstIP out of endpoint\n\t * tables. This can be simplified by caching this information with the\n\t * socket to avoid extra overhead. This would require the agent though\n\t * to flush the sock ops map on policy changes.\n\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct sk_msg_md *msg"
      ],
      "output": "int",
      "helper": [
        "msg_redirect_hash"
      ],
      "compatibleHookpoints": [
        "sk_msg"
      ],
      "source": [
        "int bpf_redir_proxy (struct sk_msg_md *msg)\n",
        "{\n",
        "    struct remote_endpoint_info *info;\n",
        "    __u64 flags = BPF_F_INGRESS;\n",
        "    struct sock_key key = {}\n",
        "    ;\n",
        "    __u32 dst_id = 0;\n",
        "    int verdict;\n",
        "    sk_msg_extract4_key (msg, &key);\n",
        "    info = lookup_ip4_remote_endpoint (key.dip4);\n",
        "    if (info != NULL && info->sec_label)\n",
        "        dst_id = info->sec_label;\n",
        "    else\n",
        "        dst_id = WORLD_ID;\n",
        "    verdict = policy_sk_egress (dst_id, key.sip4, (__u16) key.dport);\n",
        "    if (verdict >= 0)\n",
        "        msg_redirect_hash (msg, &SOCK_OPS_MAP, &key, flags);\n",
        "    return SK_PASS;\n",
        "}\n"
      ],
      "called_function_list": [
        "policy_sk_egress",
        "sk_msg_extract4_key"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        {
          "description": " Store infomations about destination id, dport and sport ip4 into message, flag set to be BPF_F_INGRESS ",
          "author": "Shun Zhang",
          "authorEmail": "shunz@bu.edu",
          "date": "2023-02-24"
        }
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "custom_hook": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 32,
      "endLine": 45,
      "File": "/home/sayandes/opened_extraction/examples/cilium/custom/bpf_custom.c",
      "funcName": "custom_hook",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": "// SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)"
        },
        {
          "start_line": 2,
          "end_line": 2,
          "text": "/* Copyright Authors of Cilium */"
        },
        {
          "start_line": 12,
          "end_line": 17,
          "text": "/* Use the macros below to set the name of the program and the name of the file\n * containing the implementation for custom_prog(). The values for these macros\n * should typically be passed to the Makefile, for example:\n *\n *     BPF_CUSTOM_PROG_FILE=bytecount.h make\n */"
        },
        {
          "start_line": 20,
          "end_line": 20,
          "text": "/* Default to bytecount.h for the included file */"
        },
        {
          "start_line": 25,
          "end_line": 25,
          "text": "/* Default to __section(\"custom\") for the program */"
        },
        {
          "start_line": 38,
          "end_line": 38,
          "text": "/* Call user-defined function from custom header file. */"
        },
        {
          "start_line": 41,
          "end_line": 43,
          "text": "/* Return action code selected from parent program, independently of\n\t * what the custom function does, to maintain datapath consistency.\n\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct  __ctx_buff *ctx"
      ],
      "output": "int",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "int custom_hook (const struct  __ctx_buff *ctx)\n",
        "{\n",
        "    __u32 custom_meta = ctx_load_meta (ctx, CB_CUSTOM_CALLS);\n",
        "    __u32 identity = custom_meta & 0xffffff;\n",
        "    int ret = (custom_meta >> 24) & 0xff;\n",
        "    custom_prog (ctx, identity);\n",
        "    return ret;\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_load_meta",
        "custom_prog"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "l4_modify_port": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 36,
      "endLine": 47,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/l4.h",
      "funcName": "l4_modify_port",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */"
        },
        {
          "start_line": 2,
          "end_line": 2,
          "text": "/* Copyright Authors of Cilium */"
        },
        {
          "start_line": 19,
          "end_line": 35,
          "text": "/**\n * Modify L4 port and correct checksum\n * @arg ctx:      packet\n * @arg l4_off:   offset to L4 header\n * @arg off:      offset from L4 header to source or destination port\n * @arg csum_off: offset from L4 header to 16bit checksum field in L4 header\n * @arg port:     new port value\n * @arg old_port: old port value (for checksum correction)\n *\n * Overwrites a TCP or UDP port with new value and fixes up the checksum\n * in the L4 header and of ctx->csum.\n *\n * NOTE: Calling this function will invalidate any pkt context offset\n * validation for direct packet access.\n *\n * Return 0 on success or a negative DROP_* reason\n */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " int l4_off",
        " int off",
        " struct csum_offset *csum_off",
        " __be16 port",
        " __be16 old_port"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int l4_modify_port (struct  __ctx_buff *ctx, int l4_off, int off, struct csum_offset *csum_off, __be16 port, __be16 old_port)\n",
        "{\n",
        "    if (csum_l4_replace (ctx, l4_off, csum_off, old_port, port, sizeof (port)) < 0)\n",
        "        return DROP_CSUM_L4;\n",
        "    if (ctx_store_bytes (ctx, l4_off + off, &port, sizeof (port), 0) < 0)\n",
        "        return DROP_WRITE_ERROR;\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "csum_l4_replace"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "l4_load_port": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 49,
      "endLine": 53,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/l4.h",
      "funcName": "l4_load_port",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " int off",
        " __be16 *port"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int l4_load_port (struct  __ctx_buff *ctx, int off, __be16 *port)\n",
        "{\n",
        "    return ctx_load_bytes (ctx, off, port, sizeof (__be16));\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "cilium_capture": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 48,
      "endLine": 75,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/pcap.h",
      "funcName": "cilium_capture",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */"
        },
        {
          "start_line": 2,
          "end_line": 2,
          "text": "/* Copyright Authors of Cilium */"
        },
        {
          "start_line": 26,
          "end_line": 29,
          "text": "/* User space needs to perform inline conversion from\n\t\t * boot offset to time of day before writing out to\n\t\t * an external file.\n\t\t */"
        },
        {
          "start_line": 38,
          "end_line": 40,
          "text": "/* The hash is reserved and always zero for allowing different\n\t * header extensions in future.\n\t */"
        },
        {
          "start_line": 42,
          "end_line": 44,
          "text": "/* The pcap hdr must be the last member so that the placement\n\t * inside the perf RB is linear: pcap hdr + packet payload.\n\t */"
        },
        {
          "start_line": 57,
          "end_line": 59,
          "text": "/* rule_id is the demuxer for the target pcap file when there are\n\t * multiple capturing rules present.\n\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " const __u8 subtype",
        " const __u16 rule_id",
        " const __u64 tstamp",
        " __u64  __cap_len"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void cilium_capture (struct  __ctx_buff *ctx, const __u8 subtype, const __u16 rule_id, const __u64 tstamp, __u64  __cap_len)\n",
        "{\n",
        "    __u64 ctx_len = ctx_full_len (ctx);\n",
        "    __u64 cap_len = (!__cap_len || ctx_len < __cap_len) ? ctx_len : __cap_len;\n",
        "    struct capture_msg msg = {\n",
        "        .type = CILIUM_NOTIFY_CAPTURE,\n",
        "        .subtype = subtype,\n",
        "        .source = rule_id,\n",
        "        .hdr = {\n",
        "            .to = {\n",
        "                .tv_boot = tstamp,},\n",
        "            .caplen = cap_len,\n",
        "            .len = ctx_len,},}\n",
        "    ;\n",
        "    ctx_event_output (ctx, &EVENTS_MAP, (cap_len << 32) | BPF_F_CURRENT_CPU, &msg, sizeof (msg));\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_full_len"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__cilium_capture_in": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 77,
      "endLine": 86,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/pcap.h",
      "funcName": "__cilium_capture_in",
      "developer_inline_comments": [
        {
          "start_line": 80,
          "end_line": 83,
          "text": "/* For later pcap file generation, we export boot time to the RB\n\t * such that user space can later reconstruct a real time of day\n\t * timestamp in-place.\n\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " __u16 rule_id",
        " __u32 cap_len"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void __cilium_capture_in (struct  __ctx_buff *ctx, __u16 rule_id, __u32 cap_len)\n",
        "{\n",
        "    cilium_capture (ctx, CAPTURE_INGRESS, rule_id, bpf_ktime_cache_set (boot_ns), cap_len);\n",
        "}\n"
      ],
      "called_function_list": [
        "cilium_capture"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__cilium_capture_out": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 88,
      "endLine": 93,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/pcap.h",
      "funcName": "__cilium_capture_out",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " __u16 rule_id",
        " __u32 cap_len"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void __cilium_capture_out (struct  __ctx_buff *ctx, __u16 rule_id, __u32 cap_len)\n",
        "{\n",
        "    cilium_capture (ctx, CAPTURE_EGRESS, rule_id, bpf_ktime_cache_get (), cap_len);\n",
        "}\n"
      ],
      "called_function_list": [
        "cilium_capture"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "cilium_capture4_masked_key": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 158,
      "endLine": 170,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/pcap.h",
      "funcName": "cilium_capture4_masked_key",
      "developer_inline_comments": [
        {
          "start_line": 95,
          "end_line": 99,
          "text": "/* The capture_enabled integer ({0,1}) is enabled/disabled via BPF based ELF\n * templating. Meaning, when disabled, the verifier's dead code elimination\n * will ensure that there is no overhead when the facility is not used. The\n * below is a fallback definition for when the templating var is not defined.\n */"
        },
        {
          "start_line": 102,
          "end_line": 102,
          "text": "/* capture_enabled */"
        },
        {
          "start_line": 124,
          "end_line": 124,
          "text": "/* 5-tuple wildcard key / mask. */"
        },
        {
          "start_line": 126,
          "end_line": 126,
          "text": "/* masking: prefix */"
        },
        {
          "start_line": 127,
          "end_line": 127,
          "text": "/* masking: prefix */"
        },
        {
          "start_line": 128,
          "end_line": 128,
          "text": "/* masking: 0 or 0xffff */"
        },
        {
          "start_line": 129,
          "end_line": 129,
          "text": "/* masking: 0 or 0xffff */"
        },
        {
          "start_line": 130,
          "end_line": 130,
          "text": "/* masking: 0 or 0xff */"
        },
        {
          "start_line": 131,
          "end_line": 131,
          "text": "/* prefix len: saddr */"
        },
        {
          "start_line": 132,
          "end_line": 132,
          "text": "/* prefix len: daddr */"
        },
        {
          "start_line": 133,
          "end_line": 133,
          "text": "/* reserved: 0 */"
        },
        {
          "start_line": 136,
          "end_line": 136,
          "text": "/* 5-tuple wildcard key / mask. */"
        },
        {
          "start_line": 138,
          "end_line": 138,
          "text": "/* masking: prefix */"
        },
        {
          "start_line": 139,
          "end_line": 139,
          "text": "/* masking: prefix */"
        },
        {
          "start_line": 140,
          "end_line": 140,
          "text": "/* masking: 0 or 0xffff */"
        },
        {
          "start_line": 141,
          "end_line": 141,
          "text": "/* masking: 0 or 0xffff */"
        },
        {
          "start_line": 142,
          "end_line": 142,
          "text": "/* masking: 0 or 0xff */"
        },
        {
          "start_line": 143,
          "end_line": 143,
          "text": "/* prefix len: saddr */"
        },
        {
          "start_line": 144,
          "end_line": 144,
          "text": "/* prefix len: daddr */"
        },
        {
          "start_line": 145,
          "end_line": 145,
          "text": "/* reserved: 0 */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct capture4_wcard *orig",
        " const struct capture4_wcard *mask",
        " struct capture4_wcard *out"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void cilium_capture4_masked_key (const struct capture4_wcard *orig, const struct capture4_wcard *mask, struct capture4_wcard *out)\n",
        "{\n",
        "    out->daddr = orig->daddr & mask->daddr;\n",
        "    out->saddr = orig->saddr & mask->saddr;\n",
        "    out->dport = orig->dport & mask->dport;\n",
        "    out->sport = orig->sport & mask->sport;\n",
        "    out->nexthdr = orig->nexthdr & mask->nexthdr;\n",
        "    out->dmask = mask->dmask;\n",
        "    out->smask = mask->smask;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "cilium_capture4_classify_wcard": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 217,
      "endLine": 257,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/pcap.h",
      "funcName": "cilium_capture4_classify_wcard",
      "developer_inline_comments": [
        {
          "start_line": 172,
          "end_line": 178,
          "text": "/* The agent is generating and emitting the PREFIX_MASKS4 and regenerating\n * if a mask was added or removed. The cilium_capture4_rules can have n\n * entries with m different PREFIX_MASKS4 where n >> m. Lookup performance\n * depends mainly on m. Below is a fallback / example definition mainly for\n * compile testing given agent typically emits this instead. Ordering of\n * masks from agent side can f.e. be based on # of 1s from high to low.\n */"
        },
        {
          "start_line": 182,
          "end_line": 184,
          "text": "/* rule_id 1:\t\t\t\t\\\n\t\t *  srcIP/32, dstIP/32, dport, nexthdr\t\\\n\t\t */"
        },
        {
          "start_line": 193,
          "end_line": 195,
          "text": "/* rule_id 2 (1st mask):\t\t\\\n\t\t *  srcIP/32 or dstIP/32\t\t\\\n\t\t */"
        },
        {
          "start_line": 204,
          "end_line": 206,
          "text": "/* rule_id 2 (2nd mask):\t\t\\\n\t\t *  srcIP/32 or dstIP/32\t\t\\\n\t\t */"
        },
        {
          "start_line": 215,
          "end_line": 215,
          "text": "/* PREFIX_MASKS4 */"
        }
      ],
      "updateMaps": [],
      "readMaps": [
        "  CAPTURE4_RULES"
      ],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "static__always_inlinestructcapture_rule",
      "helper": [
        "map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline struct capture_rule *cilium_capture4_classify_wcard (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    struct capture4_wcard prefix_masks [] = {PREFIX_MASKS4};\n",
        "    struct capture4_wcard okey, lkey;\n",
        "    struct capture_rule *match;\n",
        "    void *data, *data_end;\n",
        "    struct iphdr *ip4;\n",
        "    int i;\n",
        "    const int size = sizeof (prefix_masks) / sizeof (prefix_masks [0]);\n",
        "    if (!revalidate_data (ctx, &data, &data_end, &ip4))\n",
        "        return NULL;\n",
        "    okey.daddr = ip4->daddr;\n",
        "    okey.dmask = 32;\n",
        "    okey.saddr = ip4->saddr;\n",
        "    okey.smask = 32;\n",
        "    okey.nexthdr = ip4->protocol;\n",
        "    if (ip4->protocol != IPPROTO_TCP && ip4->protocol != IPPROTO_UDP)\n",
        "        return NULL;\n",
        "    if (ctx_load_bytes (ctx, ETH_HLEN + ipv4_hdrlen (ip4), &okey.sport, 4) < 0)\n",
        "        return NULL;\n",
        "    okey.flags = 0;\n",
        "    lkey.flags = 0;\n",
        "    _Pragma (\"unroll\")\n",
        "    for (i = 0; i < size; i++) {\n",
        "        cilium_capture4_masked_key (&okey, &prefix_masks[i], &lkey);\n",
        "        match = map_lookup_elem (& CAPTURE4_RULES, & lkey);\n",
        "        if (match)\n",
        "            return match;\n",
        "    }\n",
        "    return NULL;\n",
        "}\n"
      ],
      "called_function_list": [
        "cilium_capture4_masked_key",
        "ipv4_hdrlen"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "cilium_capture6_masked_key": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 270,
      "endLine": 284,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/pcap.h",
      "funcName": "cilium_capture6_masked_key",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct capture6_wcard *orig",
        " const struct capture6_wcard *mask",
        " struct capture6_wcard *out"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void cilium_capture6_masked_key (const struct capture6_wcard *orig, const struct capture6_wcard *mask, struct capture6_wcard *out)\n",
        "{\n",
        "    out->daddr.d1 = orig->daddr.d1 & mask->daddr.d1;\n",
        "    out->daddr.d2 = orig->daddr.d2 & mask->daddr.d2;\n",
        "    out->saddr.d1 = orig->saddr.d1 & mask->saddr.d1;\n",
        "    out->saddr.d2 = orig->saddr.d2 & mask->saddr.d2;\n",
        "    out->dport = orig->dport & mask->dport;\n",
        "    out->sport = orig->sport & mask->sport;\n",
        "    out->nexthdr = orig->nexthdr & mask->nexthdr;\n",
        "    out->dmask = mask->dmask;\n",
        "    out->smask = mask->smask;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "cilium_capture6_classify_wcard": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 339,
      "endLine": 382,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/pcap.h",
      "funcName": "cilium_capture6_classify_wcard",
      "developer_inline_comments": [
        {
          "start_line": 286,
          "end_line": 288,
          "text": "/* The agent is generating and emitting the PREFIX_MASKS6 and regenerating\n * if a mask was added or removed. Example for compile testing:\n */"
        },
        {
          "start_line": 292,
          "end_line": 294,
          "text": "/* rule_id 1:\t\t\t\t \\\n\t\t *  srcIP/128, dstIP/128, dport, nexthdr \\\n\t\t */"
        },
        {
          "start_line": 309,
          "end_line": 311,
          "text": "/* rule_id 2 (1st mask):\t\t \\\n\t\t *  srcIP/128 or dstIP/128\t\t \\\n\t\t */"
        },
        {
          "start_line": 323,
          "end_line": 325,
          "text": "/* rule_id 2 (2nd mask):\t\t \\\n\t\t *  srcIP/128 or dstIP/128\t\t \\\n\t\t */"
        },
        {
          "start_line": 337,
          "end_line": 337,
          "text": "/* PREFIX_MASKS6 */"
        }
      ],
      "updateMaps": [],
      "readMaps": [
        "  CAPTURE6_RULES"
      ],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "static__always_inlinestructcapture_rule",
      "helper": [
        "map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline struct capture_rule *cilium_capture6_classify_wcard (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    struct capture6_wcard prefix_masks [] = {PREFIX_MASKS6};\n",
        "    struct capture6_wcard okey, lkey;\n",
        "    struct capture_rule *match;\n",
        "    void *data, *data_end;\n",
        "    struct ipv6hdr *ip6;\n",
        "    int i, ret, l3_off = ETH_HLEN;\n",
        "    const int size = sizeof (prefix_masks) / sizeof (prefix_masks [0]);\n",
        "    if (!revalidate_data (ctx, &data, &data_end, &ip6))\n",
        "        return NULL;\n",
        "    ipv6_addr_copy (&okey.daddr, (union v6addr *) &ip6->daddr);\n",
        "    okey.dmask = 128;\n",
        "    ipv6_addr_copy (&okey.saddr, (union v6addr *) &ip6->saddr);\n",
        "    okey.smask = 128;\n",
        "    okey.nexthdr = ip6->nexthdr;\n",
        "    ret = ipv6_hdrlen (ctx, & okey.nexthdr);\n",
        "    if (ret < 0)\n",
        "        return NULL;\n",
        "    if (okey.nexthdr != IPPROTO_TCP && okey.nexthdr != IPPROTO_UDP)\n",
        "        return NULL;\n",
        "    if (ctx_load_bytes (ctx, l3_off + ret, &okey.sport, 4) < 0)\n",
        "        return NULL;\n",
        "    okey.flags = 0;\n",
        "    lkey.flags = 0;\n",
        "    _Pragma (\"unroll\")\n",
        "    for (i = 0; i < size; i++) {\n",
        "        cilium_capture6_masked_key (&okey, &prefix_masks[i], &lkey);\n",
        "        match = map_lookup_elem (& CAPTURE6_RULES, & lkey);\n",
        "        if (match)\n",
        "            return match;\n",
        "    }\n",
        "    return NULL;\n",
        "}\n"
      ],
      "called_function_list": [
        "ipv6_hdrlen",
        "cilium_capture6_masked_key",
        "ipv6_addr_copy"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "cilium_capture_classify_wcard": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 385,
      "endLine": 408,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/pcap.h",
      "funcName": "cilium_capture_classify_wcard",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "static__always_inlinestructcapture_rule",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline struct capture_rule *cilium_capture_classify_wcard (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    struct capture_rule *ret = NULL;\n",
        "    __u16 proto;\n",
        "    if (!validate_ethertype (ctx, &proto))\n",
        "        return ret;\n",
        "    switch (proto) {\n",
        "\n",
        "#ifdef ENABLE_IPV4\n",
        "    case bpf_htons (ETH_P_IP) :\n",
        "        ret = cilium_capture4_classify_wcard (ctx);\n",
        "        break;\n",
        "\n",
        "#endif\n",
        "\n",
        "#ifdef ENABLE_IPV6\n",
        "    case bpf_htons (ETH_P_IPV6) :\n",
        "        ret = cilium_capture6_classify_wcard (ctx);\n",
        "        break;\n",
        "\n",
        "#endif\n",
        "    default :\n",
        "        break;\n",
        "    }\n",
        "    return ret;\n",
        "}\n"
      ],
      "called_function_list": [
        "cilium_capture6_classify_wcard",
        "cilium_capture4_classify_wcard",
        "validate_ethertype"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "cilium_capture_candidate": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 410,
      "endLine": 432,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/pcap.h",
      "funcName": "cilium_capture_candidate",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [
        "  cilium_capture_cache"
      ],
      "input": [
        "struct  __ctx_buff * ctx __maybe_unused",
        " __u16 * rule_id __maybe_unused",
        " __u16 * cap_len __maybe_unused"
      ],
      "output": "static__always_inlinebool",
      "helper": [
        "map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline bool cilium_capture_candidate (struct  __ctx_buff * ctx __maybe_unused, __u16 * rule_id __maybe_unused, __u16 * cap_len __maybe_unused)\n",
        "{\n",
        "    if (capture_enabled) {\n",
        "        struct capture_cache *c;\n",
        "        struct capture_rule *r;\n",
        "        __u32 zero = 0;\n",
        "        c = map_lookup_elem (& cilium_capture_cache, & zero);\n",
        "        if (always_succeeds (c)) {\n",
        "            r = cilium_capture_classify_wcard (ctx);\n",
        "            c->rule_seen = r;\n",
        "            if (r) {\n",
        "                c->cap_len = *cap_len = (__u16) r->cap_len;\n",
        "                c->rule_id = *rule_id = r->rule_id;\n",
        "                return true;\n",
        "            }\n",
        "        }\n",
        "    }\n",
        "    return false;\n",
        "}\n"
      ],
      "called_function_list": [
        "cilium_capture_classify_wcard"
      ],
      "call_depth": 4,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "cilium_capture_cached": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 434,
      "endLine": 455,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/pcap.h",
      "funcName": "cilium_capture_cached",
      "developer_inline_comments": [
        {
          "start_line": 443,
          "end_line": 446,
          "text": "/* Avoid full classification a 2nd time due to i) overhead but\n\t\t * also since ii) we might have pushed an encap header in front\n\t\t * where we don't want to dissect everything again.\n\t\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [
        "  cilium_capture_cache"
      ],
      "input": [
        "struct  __ctx_buff * ctx __maybe_unused",
        " __u16 * rule_id __maybe_unused",
        " __u32 * cap_len __maybe_unused"
      ],
      "output": "static__always_inlinebool",
      "helper": [
        "map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline bool cilium_capture_cached (struct  __ctx_buff * ctx __maybe_unused, __u16 * rule_id __maybe_unused, __u32 * cap_len __maybe_unused)\n",
        "{\n",
        "    if (capture_enabled) {\n",
        "        struct capture_cache *c;\n",
        "        __u32 zero = 0;\n",
        "        c = map_lookup_elem (& cilium_capture_cache, & zero);\n",
        "        if (always_succeeds (c) && c->rule_seen) {\n",
        "            *cap_len = c->cap_len;\n",
        "            *rule_id = c->rule_id;\n",
        "            return true;\n",
        "        }\n",
        "    }\n",
        "    return false;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "cilium_capture_in": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 457,
      "endLine": 465,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/pcap.h",
      "funcName": "cilium_capture_in",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff * ctx __maybe_unused"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void cilium_capture_in (struct  __ctx_buff * ctx __maybe_unused)\n",
        "{\n",
        "    __u16 cap_len;\n",
        "    __u16 rule_id;\n",
        "    if (cilium_capture_candidate (ctx, &rule_id, &cap_len))\n",
        "        __cilium_capture_in (ctx, rule_id, cap_len);\n",
        "}\n"
      ],
      "called_function_list": [
        "__cilium_capture_in",
        "cilium_capture_candidate"
      ],
      "call_depth": 4,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 483,
      "endLine": 486,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/pcap.h",
      "funcName": "cilium_capture_in",
      "developer_inline_comments": [
        {
          "start_line": 481,
          "end_line": 481,
          "text": "/* ENABLE_CAPTURE */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff * ctx __maybe_unused"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void cilium_capture_in (struct  __ctx_buff * ctx __maybe_unused)\n",
        "{\n",
        "}\n"
      ],
      "called_function_list": [
        "__cilium_capture_in",
        "cilium_capture_candidate"
      ],
      "call_depth": 4,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "cilium_capture_out": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 467,
      "endLine": 479,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/pcap.h",
      "funcName": "cilium_capture_out",
      "developer_inline_comments": [
        {
          "start_line": 473,
          "end_line": 476,
          "text": "/* cilium_capture_out() is always paired with cilium_capture_in(), so\n\t * we can rely on previous cached result on whether to push the pkt\n\t * to the RB or not.\n\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff * ctx __maybe_unused"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void cilium_capture_out (struct  __ctx_buff * ctx __maybe_unused)\n",
        "{\n",
        "    __u32 cap_len;\n",
        "    __u16 rule_id;\n",
        "    if (cilium_capture_cached (ctx, &rule_id, &cap_len))\n",
        "        __cilium_capture_out (ctx, rule_id, cap_len);\n",
        "}\n"
      ],
      "called_function_list": [
        "__cilium_capture_out",
        "cilium_capture_cached"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 488,
      "endLine": 491,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/pcap.h",
      "funcName": "cilium_capture_out",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff * ctx __maybe_unused"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void cilium_capture_out (struct  __ctx_buff * ctx __maybe_unused)\n",
        "{\n",
        "}\n"
      ],
      "called_function_list": [
        "__cilium_capture_out",
        "cilium_capture_cached"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "hash_from_tuple_v4": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 13,
      "endLine": 18,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/hash.h",
      "funcName": "hash_from_tuple_v4",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */"
        },
        {
          "start_line": 2,
          "end_line": 2,
          "text": "/* Copyright Authors of Cilium */"
        },
        {
          "start_line": 10,
          "end_line": 12,
          "text": "/* The daddr is explicitly excluded from the hash here in order to allow for\n * backend selection to choose the same backend even on different service VIPs.\n */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct ipv4_ct_tuple *tuple"
      ],
      "output": "static__always_inline__u32",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __u32 hash_from_tuple_v4 (const struct ipv4_ct_tuple *tuple)\n",
        "{\n",
        "    return jhash_3words (tuple->saddr, ((__u32) tuple->dport << 16) | tuple->sport, tuple->nexthdr, HASH_INIT4_SEED);\n",
        "}\n"
      ],
      "called_function_list": [
        "jhash_3words"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "hash_from_tuple_v6": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 20,
      "endLine": 35,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/hash.h",
      "funcName": "hash_from_tuple_v6",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct ipv6_ct_tuple *tuple"
      ],
      "output": "static__always_inline__u32",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __u32 hash_from_tuple_v6 (const struct ipv6_ct_tuple *tuple)\n",
        "{\n",
        "    __u32 a, b, c;\n",
        "    a = tuple->saddr.p1;\n",
        "    b = tuple->saddr.p2;\n",
        "    c = tuple->saddr.p3;\n",
        "    __jhash_mix (a, b, c);\n",
        "    a += tuple->saddr.p4;\n",
        "    b += ((__u32) tuple->dport << 16) | tuple->sport;\n",
        "    c += tuple->nexthdr;\n",
        "    __jhash_mix (a, b, c);\n",
        "    a += HASH_INIT6_SEED;\n",
        "    __jhash_final (a, b, c);\n",
        "    return c;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "get_ct_map6": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 40,
      "endLine": 47,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack_map.h",
      "funcName": "get_ct_map6",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */"
        },
        {
          "start_line": 2,
          "end_line": 2,
          "text": "/* Copyright Authors of Cilium */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct ipv6_ct_tuple *tuple"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void *get_ct_map6 (const struct ipv6_ct_tuple *tuple)\n",
        "{\n",
        "    if (tuple->nexthdr == IPPROTO_TCP)\n",
        "        return &CT_MAP_TCP6;\n",
        "    return &CT_MAP_ANY6;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "get_ct_map4": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 73,
      "endLine": 80,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack_map.h",
      "funcName": "get_ct_map4",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct ipv4_ct_tuple *tuple"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void *get_ct_map4 (const struct ipv4_ct_tuple *tuple)\n",
        "{\n",
        "    if (tuple->nexthdr == IPPROTO_TCP)\n",
        "        return &CT_MAP_TCP4;\n",
        "    return &CT_MAP_ANY4;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "lookup_ip4_egress_gw_policy": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 20,
      "endLine": 29,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/egress_policies.h",
      "funcName": "lookup_ip4_egress_gw_policy",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */"
        },
        {
          "start_line": 2,
          "end_line": 2,
          "text": "/* Copyright Authors of Cilium */"
        },
        {
          "start_line": 13,
          "end_line": 15,
          "text": "/* EGRESS_STATIC_PREFIX represents the size in bits of the static prefix part of\n * an egress policy key (i.e. the source IP).\n */"
        }
      ],
      "updateMaps": [],
      "readMaps": [
        " EGRESS_POLICY_MAP"
      ],
      "input": [
        "__be32 saddr",
        " __be32 daddr"
      ],
      "output": "static__always_inlinestructegress_gw_policy_entry",
      "helper": [
        "map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline struct egress_gw_policy_entry *lookup_ip4_egress_gw_policy (__be32 saddr, __be32 daddr)\n",
        "{\n",
        "    struct egress_gw_policy_key key = {\n",
        "        .lpm_key = {EGRESS_IPV4_PREFIX,\n",
        "            {}},\n",
        "        .saddr = saddr,\n",
        "        .daddr = daddr,}\n",
        "    ;\n",
        "    return map_lookup_elem (&EGRESS_POLICY_MAP, &key);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "srv6_lookup_vrf4": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 44,
      "endLine": 53,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/egress_policies.h",
      "funcName": "srv6_lookup_vrf4",
      "developer_inline_comments": [
        {
          "start_line": 31,
          "end_line": 31,
          "text": "/* ENABLE_EGRESS_GATEWAY */"
        },
        {
          "start_line": 36,
          "end_line": 38,
          "text": "/* SRV6_VRF_STATIC_PREFIX4 gets sizeof non-IP, non-prefix part of\n * srv6_vrf_key4.\n */"
        }
      ],
      "updateMaps": [],
      "readMaps": [
        " SRV6_VRF_MAP4"
      ],
      "input": [
        "__be32 sip",
        " __be32 dip"
      ],
      "output": "static__always_inline__u32",
      "helper": [
        "map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __u32 *srv6_lookup_vrf4 (__be32 sip, __be32 dip)\n",
        "{\n",
        "    struct srv6_vrf_key4 key = {\n",
        "        .lpm = {SRV6_VRF_IPV4_PREFIX,\n",
        "            {}},\n",
        "        .src_ip = sip,\n",
        "        .dst_cidr = dip,}\n",
        "    ;\n",
        "    return map_lookup_elem (&SRV6_VRF_MAP4, &key);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "srv6_lookup_policy4": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 63,
      "endLine": 72,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/egress_policies.h",
      "funcName": "srv6_lookup_policy4",
      "developer_inline_comments": [
        {
          "start_line": 55,
          "end_line": 57,
          "text": "/* SRV6_POLICY_STATIC_PREFIX4 gets sizeof non-IP, non-prefix part of\n * srv6_policy_key4.\n */"
        }
      ],
      "updateMaps": [],
      "readMaps": [
        " SRV6_POLICY_MAP4"
      ],
      "input": [
        "__u32 vrf_id",
        " __be32 dip"
      ],
      "output": "static__always_inlineunionv6addr",
      "helper": [
        "map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline union v6addr *srv6_lookup_policy4 (__u32 vrf_id, __be32 dip)\n",
        "{\n",
        "    struct srv6_policy_key4 key = {\n",
        "        .lpm = {SRV6_POLICY_IPV4_PREFIX,\n",
        "            {}},\n",
        "        .vrf_id = vrf_id,\n",
        "        .dst_cidr = dip,}\n",
        "    ;\n",
        "    return map_lookup_elem (&SRV6_POLICY_MAP4, &key);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "srv6_lookup_vrf6": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 83,
      "endLine": 92,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/egress_policies.h",
      "funcName": "srv6_lookup_vrf6",
      "developer_inline_comments": [
        {
          "start_line": 75,
          "end_line": 77,
          "text": "/* SRV6_VRF_STATIC_PREFIX6 gets sizeof non-IP, non-prefix part of\n * srv6_vrf_key6.\n */"
        }
      ],
      "updateMaps": [],
      "readMaps": [
        " SRV6_VRF_MAP6"
      ],
      "input": [
        "const struct in6_addr *sip",
        " const struct in6_addr *dip"
      ],
      "output": "static__always_inline__u32",
      "helper": [
        "map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __u32 *srv6_lookup_vrf6 (const struct in6_addr *sip, const struct in6_addr *dip)\n",
        "{\n",
        "    struct srv6_vrf_key6 key = {\n",
        "        .lpm = {SRV6_VRF_IPV6_PREFIX,\n",
        "            {}},\n",
        "        .src_ip = *(unionv6addr*) sip,\n",
        "        .dst_cidr = *(unionv6addr*) dip,}\n",
        "    ;\n",
        "    return map_lookup_elem (&SRV6_VRF_MAP6, &key);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "srv6_lookup_policy6": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 103,
      "endLine": 112,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/egress_policies.h",
      "funcName": "srv6_lookup_policy6",
      "developer_inline_comments": [
        {
          "start_line": 94,
          "end_line": 96,
          "text": "/* SRV6_POLICY_STATIC_PREFIX6 gets sizeof non-IP, non-prefix part of\n * srv6_policy_key6.\n */"
        }
      ],
      "updateMaps": [],
      "readMaps": [
        " SRV6_POLICY_MAP6"
      ],
      "input": [
        "__u32 vrf_id",
        " const struct in6_addr *dip"
      ],
      "output": "static__always_inlineunionv6addr",
      "helper": [
        "map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline union v6addr *srv6_lookup_policy6 (__u32 vrf_id, const struct in6_addr *dip)\n",
        "{\n",
        "    struct srv6_policy_key6 key = {\n",
        "        .lpm = {SRV6_POLICY_IPV6_PREFIX,\n",
        "            {}},\n",
        "        .vrf_id = vrf_id,\n",
        "        .dst_cidr = *(unionv6addr*) dip,}\n",
        "    ;\n",
        "    return map_lookup_elem (&SRV6_POLICY_MAP6, &key);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "srv6_lookup_sid": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 114,
      "endLine": 123,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/egress_policies.h",
      "funcName": "srv6_lookup_sid",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [
        "  SRV6_SID_MAP"
      ],
      "input": [
        "const struct in6_addr *sid"
      ],
      "output": "static__always_inline__u32",
      "helper": [
        "map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __u32 srv6_lookup_sid (const struct in6_addr *sid)\n",
        "{\n",
        "    __u32 *vrf_id;\n",
        "    vrf_id = map_lookup_elem (& SRV6_SID_MAP, sid);\n",
        "    if (vrf_id)\n",
        "        return *vrf_id;\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "is_srv6_packet": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 125,
      "endLine": 134,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/egress_policies.h",
      "funcName": "is_srv6_packet",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct ipv6hdr *ip6"
      ],
      "output": "static__always_inlinebool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline bool is_srv6_packet (const struct ipv6hdr *ip6)\n",
        "{\n",
        "\n",
        "#ifndef ENABLE_SRV6_REDUCED_ENCAP\n",
        "    if (ip6->nexthdr == NEXTHDR_ROUTING)\n",
        "        return true;\n",
        "\n",
        "#endif\n",
        "    return ip6->nexthdr == IPPROTO_IPIP || ip6->nexthdr == IPPROTO_IPV6;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ctx_adjust_hroom_flags": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 137,
      "endLine": 144,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/egress_policies.h",
      "funcName": "ctx_adjust_hroom_flags",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void"
      ],
      "output": "static__always_inline__u64",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __u64 ctx_adjust_hroom_flags (void)\n",
        "{\n",
        "\n",
        "#ifdef BPF_HAVE_CSUM_LEVEL\n",
        "    return BPF_F_ADJ_ROOM_NO_CSUM_RESET;\n",
        "\n",
        "#else\n",
        "    return 0;\n",
        "\n",
        "#endif\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "srv6_encapsulation": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 146,
      "endLine": 171,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/egress_policies.h",
      "funcName": "srv6_encapsulation",
      "developer_inline_comments": [
        {
          "start_line": 158,
          "end_line": 158,
          "text": "/* Add room between Ethernet and network headers. */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " int growth",
        " __u16 new_payload_len",
        " __u8 nexthdr",
        " union v6addr *saddr",
        " struct in6_addr *sid"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int srv6_encapsulation (struct  __ctx_buff *ctx, int growth, __u16 new_payload_len, __u8 nexthdr, union v6addr *saddr, struct in6_addr *sid)\n",
        "{\n",
        "    __u32 len = sizeof (struct ipv6hdr) - 2 * sizeof (struct in6_addr);\n",
        "    struct ipv6hdr new_ip6 = {\n",
        "        .version = 0x6,\n",
        "        .payload_len = bpf_htons (new_payload_len),\n",
        "        .nexthdr = nexthdr,\n",
        "        .hop_limit = IPDEFTTL,}\n",
        "    ;\n",
        "    if (ctx_adjust_hroom (ctx, growth, BPF_ADJ_ROOM_MAC, ctx_adjust_hroom_flags ()))\n",
        "        return DROP_INVALID;\n",
        "    if (ctx_store_bytes (ctx, ETH_HLEN, &new_ip6, len, 0) < 0)\n",
        "        return DROP_WRITE_ERROR;\n",
        "    if (ctx_store_bytes (ctx, ETH_HLEN + offsetof (struct ipv6hdr, saddr), saddr, sizeof (union v6addr), 0) < 0)\n",
        "        return DROP_WRITE_ERROR;\n",
        "    if (ctx_store_bytes (ctx, ETH_HLEN + offsetof (struct ipv6hdr, daddr), sid, sizeof (struct in6_addr), 0) < 0)\n",
        "        return DROP_WRITE_ERROR;\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_adjust_hroom_flags",
        "ctx_adjust_hroom"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "srv6_decapsulation": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 173,
      "endLine": 210,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/egress_policies.h",
      "funcName": "srv6_decapsulation",
      "developer_inline_comments": [
        {
          "start_line": 191,
          "end_line": 195,
          "text": "/* ctx_change_proto above shrinks the packet from IPv6 header\n\t\t * length to IPv4 header length. It removes that space from the\n\t\t * same header we will later delete.\n\t\t * Thus, deduce this space from the next packet shrinking.\n\t\t */"
        },
        {
          "start_line": 205,
          "end_line": 205,
          "text": "/* Remove the outer IPv6 header. */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int srv6_decapsulation (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    __u16 new_proto = bpf_htons (ETH_P_IP);\n",
        "    void *data, *data_end;\n",
        "    struct ipv6hdr *ip6;\n",
        "    int shrink;\n",
        "    if (!revalidate_data (ctx, &data, &data_end, &ip6))\n",
        "        return DROP_INVALID;\n",
        "    switch (ip6->nexthdr) {\n",
        "    case IPPROTO_IPIP :\n",
        "        if (ctx_change_proto (ctx, new_proto, 0) < 0)\n",
        "            return DROP_WRITE_ERROR;\n",
        "        if (ctx_store_bytes (ctx, offsetof (struct ethhdr, h_proto), &new_proto, sizeof (new_proto), 0) < 0)\n",
        "            return DROP_WRITE_ERROR;\n",
        "        shrink = sizeof (struct iphdr);\n",
        "        break;\n",
        "    case IPPROTO_IPV6 :\n",
        "        shrink = sizeof (struct ipv6hdr);\n",
        "        break;\n",
        "    default :\n",
        "        return DROP_INVALID;\n",
        "    }\n",
        "    if (ctx_adjust_hroom (ctx, -shrink, BPF_ADJ_ROOM_MAC, ctx_adjust_hroom_flags ()))\n",
        "        return DROP_INVALID;\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_adjust_hroom_flags",
        "ctx_adjust_hroom",
        "ctx_change_proto"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "srv6_create_state_entry": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 212,
      "endLine": 252,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/egress_policies.h",
      "funcName": "srv6_create_state_entry",
      "developer_inline_comments": [
        {
          "start_line": 248,
          "end_line": 248,
          "text": "/* ENABLE_IPV4 */"
        }
      ],
      "updateMaps": [
        " SRV6_STATE_MAP6",
        " SRV6_STATE_MAP4"
      ],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int srv6_create_state_entry (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    struct srv6_ipv6_2tuple *outer_ips;\n",
        "    void *data, *data_end;\n",
        "    struct ipv6hdr *ip6;\n",
        "    if (!revalidate_data (ctx, &data, &data_end, &ip6))\n",
        "        return DROP_INVALID;\n",
        "    outer_ips = (struct srv6_ipv6_2tuple *) &ip6->saddr;\n",
        "    switch (ip6->nexthdr) {\n",
        "    case IPPROTO_IPV6 :\n",
        "        {\n",
        "            struct ipv6hdr *inner = ip6 + 1;\n",
        "            struct srv6_ipv6_2tuple *inner_ips;\n",
        "            if ((void *) inner + sizeof (*inner) > data_end)\n",
        "                return DROP_INVALID;\n",
        "            inner_ips = (struct srv6_ipv6_2tuple *) &inner->saddr;\n",
        "            if (map_update_elem (&SRV6_STATE_MAP6, inner_ips, outer_ips, 0) < 0)\n",
        "                return DROP_INVALID;\n",
        "        }\n",
        "\n",
        "#  ifdef ENABLE_IPV4\n",
        "    case IPPROTO_IPIP :\n",
        "        {\n",
        "            struct iphdr *inner = (struct iphdr *) (ip6 + 1);\n",
        "            struct srv6_ipv4_2tuple *inner_ips;\n",
        "            if ((void *) inner + sizeof (*inner) > data_end)\n",
        "                return DROP_INVALID;\n",
        "            inner_ips = (struct srv6_ipv4_2tuple *) &inner->saddr;\n",
        "            if (map_update_elem (&SRV6_STATE_MAP4, inner_ips, outer_ips, 0) < 0)\n",
        "                return DROP_INVALID;\n",
        "        }\n",
        "\n",
        "#  endif /* ENABLE_IPV4 */\n",
        "    }\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "srv6_lookup_state_entry4": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 255,
      "endLine": 260,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/egress_policies.h",
      "funcName": "srv6_lookup_state_entry4",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [
        " SRV6_STATE_MAP4"
      ],
      "input": [
        "struct iphdr *ip4"
      ],
      "output": "static__always_inlinestructsrv6_ipv6_2tuple",
      "helper": [
        "map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline struct srv6_ipv6_2tuple *srv6_lookup_state_entry4 (struct iphdr *ip4)\n",
        "{\n",
        "    return map_lookup_elem (&SRV6_STATE_MAP4, (struct srv6_ipv4_2tuple *) &ip4->saddr);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "srv6_lookup_state_entry6": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 263,
      "endLine": 268,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/egress_policies.h",
      "funcName": "srv6_lookup_state_entry6",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [
        " SRV6_STATE_MAP6"
      ],
      "input": [
        "struct ipv6hdr *ip6"
      ],
      "output": "static__always_inlinestructsrv6_ipv6_2tuple",
      "helper": [
        "map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline struct srv6_ipv6_2tuple *srv6_lookup_state_entry6 (struct ipv6hdr *ip6)\n",
        "{\n",
        "    return map_lookup_elem (&SRV6_STATE_MAP6, (struct srv6_ipv6_2tuple *) &ip6->saddr);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "srv6_handling4": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 270,
      "endLine": 310,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/egress_policies.h",
      "funcName": "srv6_handling4",
      "developer_inline_comments": [
        {
          "start_line": 280,
          "end_line": 280,
          "text": "/* Inner packet is IPv4. */"
        },
        {
          "start_line": 284,
          "end_line": 289,
          "text": "/* IPv4's tot_len fields has the size of the entire packet\n\t * including headers while IPv6's payload_len field has only\n\t * the size of the IPv6 payload. Therefore, without IPv6\n\t * extension headers (none here), the outer IPv6 payload_len\n\t * is equal to the inner IPv4 tot_len.\n\t */"
        },
        {
          "start_line": 292,
          "end_line": 294,
          "text": "/* We need to change skb->protocol and the corresponding packet\n\t * field because the L3 protocol will now be IPv6.\n\t */"
        },
        {
          "start_line": 300,
          "end_line": 305,
          "text": "/* ctx_change_proto above grows the packet from IPv4 header\n\t * length to IPv6 header length. It adds the additional space\n\t * before the inner L3 header, in the same place we will later\n\t * add the outer IPv6 header.\n\t * Thus, deduce this space from the next packet growth.\n\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " union v6addr *src_sid",
        " struct in6_addr *dst_sid"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int srv6_handling4 (struct  __ctx_buff *ctx, union v6addr *src_sid, struct in6_addr *dst_sid)\n",
        "{\n",
        "    __u16 new_payload_len, outer_proto = bpf_htons (ETH_P_IPV6);\n",
        "    void *data, *data_end;\n",
        "    struct iphdr *ip4;\n",
        "    __u8 nexthdr;\n",
        "    int growth;\n",
        "    if (!revalidate_data (ctx, &data, &data_end, &ip4))\n",
        "        return DROP_INVALID;\n",
        "    nexthdr = IPPROTO_IPIP;\n",
        "    new_payload_len = bpf_ntohs (ip4->tot_len) - (__u16) (ip4->ihl << 2) + sizeof (struct iphdr);\n",
        "    if (ctx_change_proto (ctx, outer_proto, 0) < 0)\n",
        "        return DROP_WRITE_ERROR;\n",
        "    if (ctx_store_bytes (ctx, offsetof (struct ethhdr, h_proto), &outer_proto, sizeof (outer_proto), 0) < 0)\n",
        "        return DROP_WRITE_ERROR;\n",
        "    growth = sizeof (struct iphdr);\n",
        "    return srv6_encapsulation (ctx, growth, new_payload_len, nexthdr, src_sid, dst_sid);\n",
        "}\n"
      ],
      "called_function_list": [
        "srv6_encapsulation",
        "ctx_change_proto"
      ],
      "call_depth": 4,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "srv6_handling6": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 312,
      "endLine": 331,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/egress_policies.h",
      "funcName": "srv6_handling6",
      "developer_inline_comments": [
        {
          "start_line": 322,
          "end_line": 322,
          "text": "/* Inner packet is IPv6. */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " union v6addr *src_sid",
        " struct in6_addr *dst_sid"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int srv6_handling6 (struct  __ctx_buff *ctx, union v6addr *src_sid, struct in6_addr *dst_sid)\n",
        "{\n",
        "    __u16 new_payload_len;\n",
        "    void *data, *data_end;\n",
        "    struct ipv6hdr *ip6;\n",
        "    __u8 nexthdr;\n",
        "    int growth;\n",
        "    if (!revalidate_data (ctx, &data, &data_end, &ip6))\n",
        "        return DROP_INVALID;\n",
        "    nexthdr = IPPROTO_IPV6;\n",
        "    new_payload_len = bpf_ntohs (ip6->payload_len) + sizeof (struct ipv6hdr);\n",
        "    growth = sizeof (struct ipv6hdr);\n",
        "    return srv6_encapsulation (ctx, growth, new_payload_len, nexthdr, src_sid, dst_sid);\n",
        "}\n"
      ],
      "called_function_list": [
        "srv6_encapsulation"
      ],
      "call_depth": 4,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "srv6_handling": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 333,
      "endLine": 373,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/egress_policies.h",
      "funcName": "srv6_handling",
      "developer_inline_comments": [
        {
          "start_line": 356,
          "end_line": 356,
          "text": "/* ENABLE_IPV6 */"
        },
        {
          "start_line": 369,
          "end_line": 369,
          "text": "/* ENABLE_IPV4 */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " __u32 vrf_id",
        " struct in6_addr *dst_sid"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int srv6_handling (struct  __ctx_buff *ctx, __u32 vrf_id, struct in6_addr *dst_sid)\n",
        "{\n",
        "    union v6addr *src_sid;\n",
        "    void *data, *data_end;\n",
        "    __u16 inner_proto;\n",
        "    if (!validate_ethertype (ctx, &inner_proto))\n",
        "        return DROP_UNSUPPORTED_L2;\n",
        "    switch (inner_proto) {\n",
        "\n",
        "#  ifdef ENABLE_IPV6\n",
        "    case bpf_htons (ETH_P_IPV6) :\n",
        "        {\n",
        "            struct ipv6hdr *ip6;\n",
        "            if (!revalidate_data (ctx, &data, &data_end, &ip6))\n",
        "                return DROP_INVALID;\n",
        "            src_sid = srv6_lookup_policy6 (vrf_id, & ip6 -> saddr);\n",
        "            if (!src_sid)\n",
        "                return DROP_NO_SID;\n",
        "            return srv6_handling6 (ctx, src_sid, dst_sid);\n",
        "        }\n",
        "\n",
        "#  endif /* ENABLE_IPV6 */\n",
        "\n",
        "#  ifdef ENABLE_IPV4\n",
        "    case bpf_htons (ETH_P_IP) :\n",
        "        {\n",
        "            struct iphdr *ip4;\n",
        "            if (!revalidate_data (ctx, &data, &data_end, &ip4))\n",
        "                return DROP_INVALID;\n",
        "            src_sid = srv6_lookup_policy4 (vrf_id, ip4 -> saddr);\n",
        "            if (!src_sid)\n",
        "                return DROP_NO_SID;\n",
        "            return srv6_handling4 (ctx, src_sid, dst_sid);\n",
        "        }\n",
        "\n",
        "#  endif /* ENABLE_IPV4 */\n",
        "    default :\n",
        "        return DROP_INVALID;\n",
        "    }\n",
        "}\n"
      ],
      "called_function_list": [
        "srv6_lookup_policy4",
        "validate_ethertype",
        "srv6_lookup_policy6",
        "srv6_handling4",
        "srv6_handling6"
      ],
      "call_depth": 5,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "srv6_reply": [
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 375,
      "endLine": 413,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/egress_policies.h",
      "funcName": "srv6_reply",
      "developer_inline_comments": [
        {
          "start_line": 409,
          "end_line": 409,
          "text": "/* ENABLE_IPV4 */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "CTX_ACT_OK"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "static __always_inline int srv6_reply (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    struct srv6_ipv6_2tuple *outer_ips;\n",
        "    struct iphdr * ip4 __maybe_unused;\n",
        "    void *data, *data_end;\n",
        "    struct ipv6hdr *ip6;\n",
        "    __u16 proto;\n",
        "    if (!validate_ethertype (ctx, &proto))\n",
        "        return DROP_UNSUPPORTED_L2;\n",
        "    switch (proto) {\n",
        "    case bpf_htons (ETH_P_IPV6) :\n",
        "        if (!revalidate_data (ctx, &data, &data_end, &ip6))\n",
        "            return DROP_INVALID;\n",
        "        outer_ips = srv6_lookup_state_entry6 (ip6);\n",
        "        if (!outer_ips)\n",
        "            return DROP_MISSING_SRV6_STATE;\n",
        "        return srv6_handling6 (ctx, &outer_ips->src, (struct in6_addr *) &outer_ips->dst);\n",
        "\n",
        "#  ifdef ENABLE_IPV4\n",
        "    case bpf_htons (ETH_P_IP) :\n",
        "        if (!revalidate_data (ctx, &data, &data_end, &ip4))\n",
        "            return DROP_INVALID;\n",
        "        outer_ips = srv6_lookup_state_entry4 (ip4);\n",
        "        if (!outer_ips)\n",
        "            return DROP_MISSING_SRV6_STATE;\n",
        "        return srv6_handling4 (ctx, &outer_ips->src, (struct in6_addr *) &outer_ips->dst);\n",
        "\n",
        "#  endif /* ENABLE_IPV4 */\n",
        "    }\n",
        "    return CTX_ACT_OK;\n",
        "}\n"
      ],
      "called_function_list": [
        "srv6_lookup_state_entry6",
        "validate_ethertype",
        "srv6_lookup_state_entry4",
        "srv6_handling4",
        "srv6_handling6"
      ],
      "call_depth": 5,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "srv6_load_meta_sid": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 415,
      "endLine": 422,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/egress_policies.h",
      "funcName": "srv6_load_meta_sid",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " struct in6_addr *sid"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void srv6_load_meta_sid (struct  __ctx_buff *ctx, struct in6_addr *sid)\n",
        "{\n",
        "    sid->s6_addr32[0] = ctx_load_meta (ctx, CB_SRV6_SID_1);\n",
        "    sid->s6_addr32[1] = ctx_load_meta (ctx, CB_SRV6_SID_2);\n",
        "    sid->s6_addr32[2] = ctx_load_meta (ctx, CB_SRV6_SID_3);\n",
        "    sid->s6_addr32[3] = ctx_load_meta (ctx, CB_SRV6_SID_4);\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_load_meta"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "srv6_store_meta_sid": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 424,
      "endLine": 431,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/egress_policies.h",
      "funcName": "srv6_store_meta_sid",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " const union v6addr *sid"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void srv6_store_meta_sid (struct  __ctx_buff *ctx, const union v6addr *sid)\n",
        "{\n",
        "    ctx_store_meta (ctx, CB_SRV6_SID_1, sid->p1);\n",
        "    ctx_store_meta (ctx, CB_SRV6_SID_2, sid->p2);\n",
        "    ctx_store_meta (ctx, CB_SRV6_SID_3, sid->p3);\n",
        "    ctx_store_meta (ctx, CB_SRV6_SID_4, sid->p4);\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_store_meta"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "tail_srv6_encap": [
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 434,
      "endLine": 452,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/egress_policies.h",
      "funcName": "tail_srv6_encap",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "int",
      "helper": [
        "CTX_ACT_OK"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "int tail_srv6_encap (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    struct in6_addr dst_sid;\n",
        "    __u32 vrf_id;\n",
        "    int ret = 0;\n",
        "    srv6_load_meta_sid (ctx, &dst_sid);\n",
        "    vrf_id = ctx_load_meta (ctx, CB_SRV6_VRF_ID);\n",
        "    ret = srv6_handling (ctx, vrf_id, & dst_sid);\n",
        "    if (ret < 0)\n",
        "        return send_drop_notify_error (ctx, SECLABEL, ret, CTX_ACT_DROP, METRIC_EGRESS);\n",
        "    send_trace_notify (ctx, TRACE_TO_STACK, SECLABEL, 0, 0, 0, TRACE_REASON_UNKNOWN, 0);\n",
        "    return CTX_ACT_OK;\n",
        "}\n"
      ],
      "called_function_list": [
        "srv6_load_meta_sid",
        "send_trace_notify",
        "srv6_handling",
        "ctx_load_meta"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "tail_srv6_decap": [
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 455,
      "endLine": 473,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/egress_policies.h",
      "funcName": "tail_srv6_decap",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "int",
      "helper": [
        "CTX_ACT_OK"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "int tail_srv6_decap (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    int ret = 0;\n",
        "    ret = srv6_create_state_entry (ctx);\n",
        "    if (ret < 0)\n",
        "        goto error_drop;\n",
        "    ret = srv6_decapsulation (ctx);\n",
        "    if (ret < 0)\n",
        "        goto error_drop;\n",
        "    send_trace_notify (ctx, TRACE_TO_STACK, SECLABEL, 0, 0, 0, TRACE_REASON_UNKNOWN, 0);\n",
        "    return CTX_ACT_OK;\n",
        "error_drop :\n",
        "    return send_drop_notify_error (ctx, SECLABEL, ret, CTX_ACT_DROP, METRIC_EGRESS);\n",
        "}\n"
      ],
      "called_function_list": [
        "send_trace_notify",
        "srv6_create_state_entry",
        "srv6_decapsulation"
      ],
      "call_depth": 4,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "tail_srv6_reply": [
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 476,
      "endLine": 485,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/egress_policies.h",
      "funcName": "tail_srv6_reply",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "int",
      "helper": [
        "CTX_ACT_OK"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "int tail_srv6_reply (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    int ret;\n",
        "    ret = srv6_reply (ctx);\n",
        "    if (ret < 0)\n",
        "        return send_drop_notify_error (ctx, SECLABEL, ret, CTX_ACT_DROP, METRIC_EGRESS);\n",
        "    return CTX_ACT_OK;\n",
        "}\n"
      ],
      "called_function_list": [
        "srv6_reply"
      ],
      "call_depth": 6,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "update_trace_metrics": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 80,
      "endLine": 124,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/trace.h",
      "funcName": "update_trace_metrics",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */"
        },
        {
          "start_line": 2,
          "end_line": 2,
          "text": "/* Copyright Authors of Cilium */"
        },
        {
          "start_line": 4,
          "end_line": 21,
          "text": "/*\n * Packet forwarding notification via perf event ring buffer.\n *\n * API:\n * void send_trace_notify(ctx, obs_point, src, dst, dst_id, ifindex, reason, monitor)\n *\n * @ctx:\tsocket buffer\n * @obs_point:\tobservation point (TRACE_*)\n * @src:\tsource identity\n * @dst:\tdestination identity\n * @dst_id:\tdestination endpoint id or proxy destination port\n * @ifindex:\tnetwork interface index\n * @reason:\treason for forwarding the packet (TRACE_REASON_*),\n *\t\te.g. return value of ct_lookup or TRACE_REASON_ENCRYPTED\n * @monitor:\tmonitor aggregation value, e.g. the 'monitor' output of ct_lookup\n *\n * If TRACE_NOTIFY is not defined, the API will be compiled in as a NOP.\n */"
        },
        {
          "start_line": 31,
          "end_line": 31,
          "text": "/* Available observation points. */"
        },
        {
          "start_line": 47,
          "end_line": 47,
          "text": "/* Reasons for forwarding a packet. */"
        },
        {
          "start_line": 55,
          "end_line": 57,
          "text": "/* Note: TRACE_REASON_ENCRYPTED is used as a mask. Beware if you add\n\t * new values below it, they would match with that mask.\n\t */"
        },
        {
          "start_line": 61,
          "end_line": 61,
          "text": "/* Trace aggregation levels. */"
        },
        {
          "start_line": 63,
          "end_line": 63,
          "text": "/* Trace every packet on rx & tx */"
        },
        {
          "start_line": 64,
          "end_line": 64,
          "text": "/* Hide trace on packet receive */"
        },
        {
          "start_line": 65,
          "end_line": 65,
          "text": "/* Ratelimit active connection traces */"
        },
        {
          "start_line": 72,
          "end_line": 79,
          "text": "/**\n * update_trace_metrics\n * @ctx:\tsocket buffer\n * @obs_point:\tobservation point (TRACE_*)\n * @reason:\treason for forwarding the packet (TRACE_REASON_*)\n *\n * Update metrics based on a trace event\n */"
        },
        {
          "start_line": 110,
          "end_line": 118,
          "text": "/* TRACE_FROM_LXC, i.e endpoint-to-endpoint delivery is handled\n\t * separately in ipv*_local_delivery() where we can bump an egress\n\t * forward. It could still be dropped but it would show up later as an\n\t * ingress drop, in that scenario.\n\t *\n\t * TRACE_{FROM,TO}_PROXY are not handled in datapath. This is because\n\t * we have separate L7 proxy \"forwarded\" and \"dropped\" (ingress/egress)\n\t * counters in the proxy layer to capture these metrics.\n\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " enum trace_point obs_point",
        " enum trace_reason reason"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void update_trace_metrics (struct  __ctx_buff *ctx, enum trace_point obs_point, enum trace_reason reason)\n",
        "{\n",
        "    __u8 encrypted;\n",
        "    switch (obs_point) {\n",
        "    case TRACE_TO_LXC :\n",
        "        update_metrics (ctx_full_len (ctx), METRIC_INGRESS, REASON_FORWARDED);\n",
        "        break;\n",
        "    case TRACE_TO_HOST :\n",
        "    case TRACE_TO_STACK :\n",
        "    case TRACE_TO_OVERLAY :\n",
        "    case TRACE_TO_NETWORK :\n",
        "        update_metrics (ctx_full_len (ctx), METRIC_EGRESS, REASON_FORWARDED);\n",
        "        break;\n",
        "    case TRACE_FROM_HOST :\n",
        "    case TRACE_FROM_STACK :\n",
        "    case TRACE_FROM_OVERLAY :\n",
        "    case TRACE_FROM_NETWORK :\n",
        "        encrypted = reason & TRACE_REASON_ENCRYPTED;\n",
        "        if (!encrypted)\n",
        "            update_metrics (ctx_full_len (ctx), METRIC_INGRESS, REASON_PLAINTEXT);\n",
        "        else\n",
        "            update_metrics (ctx_full_len (ctx), METRIC_INGRESS, REASON_DECRYPT);\n",
        "        break;\n",
        "    case TRACE_FROM_LXC :\n",
        "    case TRACE_FROM_PROXY :\n",
        "    case TRACE_TO_PROXY :\n",
        "        break;\n",
        "    }\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_full_len",
        "update_metrics"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "emit_trace_notify": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 154,
      "endLine": 182,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/trace.h",
      "funcName": "emit_trace_notify",
      "developer_inline_comments": [
        {
          "start_line": 128,
          "end_line": 130,
          "text": "/* Monitor length for number of bytes to forward in\n\t\t\t * trace message. 0 means do not monitor.\n\t\t\t */"
        },
        {
          "start_line": 171,
          "end_line": 177,
          "text": "/*\n\t * Ignore sample when aggregation is enabled and 'monitor' is set to 0.\n\t * Rate limiting (trace message aggregation) relies on connection tracking,\n\t * so if there is no CT information available at the observation point,\n\t * then 'monitor' will be set to 0 to avoid emitting trace notifications\n\t * when aggregation is enabled (the default).\n\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "enum trace_point obs_point",
        " __u32 monitor"
      ],
      "output": "static__always_inlinebool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline bool emit_trace_notify (enum trace_point obs_point, __u32 monitor)\n",
        "{\n",
        "    if (MONITOR_AGGREGATION >= TRACE_AGGREGATE_RX) {\n",
        "        switch (obs_point) {\n",
        "        case TRACE_FROM_LXC :\n",
        "        case TRACE_FROM_PROXY :\n",
        "        case TRACE_FROM_HOST :\n",
        "        case TRACE_FROM_STACK :\n",
        "        case TRACE_FROM_OVERLAY :\n",
        "        case TRACE_FROM_NETWORK :\n",
        "            return false;\n",
        "        default :\n",
        "            break;\n",
        "        }\n",
        "    }\n",
        "    if (MONITOR_AGGREGATION >= TRACE_AGGREGATE_ACTIVE_CT && !monitor)\n",
        "        return false;\n",
        "    return true;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "send_trace_notify": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 184,
      "endLine": 213,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/trace.h",
      "funcName": "send_trace_notify",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " enum trace_point obs_point",
        " __u32 src",
        " __u32 dst",
        " __u16 dst_id",
        " __u32 ifindex",
        " enum trace_reason reason",
        " __u32 monitor"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void send_trace_notify (struct  __ctx_buff *ctx, enum trace_point obs_point, __u32 src, __u32 dst, __u16 dst_id, __u32 ifindex, enum trace_reason reason, __u32 monitor)\n",
        "{\n",
        "    __u64 ctx_len = ctx_full_len (ctx);\n",
        "    __u64 cap_len = min_t (__u64, monitor ? : TRACE_PAYLOAD_LEN, ctx_len);\n",
        "    struct trace_notify msg __align_stack_8;\n",
        "    update_trace_metrics (ctx, obs_point, reason);\n",
        "    if (!emit_trace_notify (obs_point, monitor))\n",
        "        return;\n",
        "    msg = (typeof (msg)) {__notify_common_hdr (CILIUM_NOTIFY_TRACE, obs_point), __notify_pktcap_hdr (ctx_len, (__u16) cap_len),\n",
        "        .src_label = src,\n",
        "        .dst_label = dst,\n",
        "        .dst_id = dst_id,\n",
        "        .reason = reason,\n",
        "        .ifindex = ifindex,};\n",
        "    memset (&msg.orig_ip6, 0, sizeof (union v6addr));\n",
        "    ctx_event_output (ctx, &EVENTS_MAP, (cap_len << 32) | BPF_F_CURRENT_CPU, &msg, sizeof (msg));\n",
        "}\n"
      ],
      "called_function_list": [
        "emit_trace_notify",
        "ctx_full_len",
        "memset",
        "update_trace_metrics"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 281,
      "endLine": 288,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/trace.h",
      "funcName": "send_trace_notify",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " enum trace_point obs_point",
        " __u32 src __maybe_unused",
        " __u32 dst __maybe_unused",
        " __u16 dst_id __maybe_unused",
        " __u32 ifindex __maybe_unused",
        " enum trace_reason reason",
        " __u32 monitor __maybe_unused"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void send_trace_notify (struct  __ctx_buff *ctx, enum trace_point obs_point, __u32 src __maybe_unused, __u32 dst __maybe_unused, __u16 dst_id __maybe_unused, __u32 ifindex __maybe_unused, enum trace_reason reason, __u32 monitor __maybe_unused)\n",
        "{\n",
        "    update_trace_metrics (ctx, obs_point, reason);\n",
        "}\n"
      ],
      "called_function_list": [
        "emit_trace_notify",
        "ctx_full_len",
        "memset",
        "update_trace_metrics"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "send_trace_notify4": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 215,
      "endLine": 245,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/trace.h",
      "funcName": "send_trace_notify4",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " enum trace_point obs_point",
        " __u32 src",
        " __u32 dst",
        " __be32 orig_addr",
        " __u16 dst_id",
        " __u32 ifindex",
        " enum trace_reason reason",
        " __u32 monitor"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void send_trace_notify4 (struct  __ctx_buff *ctx, enum trace_point obs_point, __u32 src, __u32 dst, __be32 orig_addr, __u16 dst_id, __u32 ifindex, enum trace_reason reason, __u32 monitor)\n",
        "{\n",
        "    __u64 ctx_len = ctx_full_len (ctx);\n",
        "    __u64 cap_len = min_t (__u64, monitor ? : TRACE_PAYLOAD_LEN, ctx_len);\n",
        "    struct trace_notify msg;\n",
        "    update_trace_metrics (ctx, obs_point, reason);\n",
        "    if (!emit_trace_notify (obs_point, monitor))\n",
        "        return;\n",
        "    msg = (typeof (msg)) {__notify_common_hdr (CILIUM_NOTIFY_TRACE, obs_point), __notify_pktcap_hdr (ctx_len, (__u16) cap_len),\n",
        "        .src_label = src,\n",
        "        .dst_label = dst,\n",
        "        .dst_id = dst_id,\n",
        "        .reason = reason,\n",
        "        .ifindex = ifindex,\n",
        "        .ipv6 = 0,\n",
        "        .orig_ip4 = orig_addr,};\n",
        "    ctx_event_output (ctx, &EVENTS_MAP, (cap_len << 32) | BPF_F_CURRENT_CPU, &msg, sizeof (msg));\n",
        "}\n"
      ],
      "called_function_list": [
        "emit_trace_notify",
        "ctx_full_len",
        "update_trace_metrics"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 290,
      "endLine": 298,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/trace.h",
      "funcName": "send_trace_notify4",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " enum trace_point obs_point",
        " __u32 src __maybe_unused",
        " __u32 dst __maybe_unused",
        " __be32 orig_addr __maybe_unused",
        " __u16 dst_id __maybe_unused",
        " __u32 ifindex __maybe_unused",
        " enum trace_reason reason",
        " __u32 monitor __maybe_unused"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void send_trace_notify4 (struct  __ctx_buff *ctx, enum trace_point obs_point, __u32 src __maybe_unused, __u32 dst __maybe_unused, __be32 orig_addr __maybe_unused, __u16 dst_id __maybe_unused, __u32 ifindex __maybe_unused, enum trace_reason reason, __u32 monitor __maybe_unused)\n",
        "{\n",
        "    update_trace_metrics (ctx, obs_point, reason);\n",
        "}\n"
      ],
      "called_function_list": [
        "emit_trace_notify",
        "ctx_full_len",
        "update_trace_metrics"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "send_trace_notify6": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 247,
      "endLine": 279,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/trace.h",
      "funcName": "send_trace_notify6",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " enum trace_point obs_point",
        " __u32 src",
        " __u32 dst",
        " const union v6addr *orig_addr",
        " __u16 dst_id",
        " __u32 ifindex",
        " enum trace_reason reason",
        " __u32 monitor"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void send_trace_notify6 (struct  __ctx_buff *ctx, enum trace_point obs_point, __u32 src, __u32 dst, const union v6addr *orig_addr, __u16 dst_id, __u32 ifindex, enum trace_reason reason, __u32 monitor)\n",
        "{\n",
        "    __u64 ctx_len = ctx_full_len (ctx);\n",
        "    __u64 cap_len = min_t (__u64, monitor ? : TRACE_PAYLOAD_LEN, ctx_len);\n",
        "    struct trace_notify msg;\n",
        "    update_trace_metrics (ctx, obs_point, reason);\n",
        "    if (!emit_trace_notify (obs_point, monitor))\n",
        "        return;\n",
        "    msg = (typeof (msg)) {__notify_common_hdr (CILIUM_NOTIFY_TRACE, obs_point), __notify_pktcap_hdr (ctx_len, (__u16) cap_len),\n",
        "        .src_label = src,\n",
        "        .dst_label = dst,\n",
        "        .dst_id = dst_id,\n",
        "        .reason = reason,\n",
        "        .ifindex = ifindex,\n",
        "        .ipv6 = 1,};\n",
        "    ipv6_addr_copy (&msg.orig_ip6, orig_addr);\n",
        "    ctx_event_output (ctx, &EVENTS_MAP, (cap_len << 32) | BPF_F_CURRENT_CPU, &msg, sizeof (msg));\n",
        "}\n"
      ],
      "called_function_list": [
        "emit_trace_notify",
        "ctx_full_len",
        "update_trace_metrics",
        "ipv6_addr_copy"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 300,
      "endLine": 308,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/trace.h",
      "funcName": "send_trace_notify6",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " enum trace_point obs_point",
        " __u32 src __maybe_unused",
        " __u32 dst __maybe_unused",
        " union v6addr * orig_addr __maybe_unused",
        " __u16 dst_id __maybe_unused",
        " __u32 ifindex __maybe_unused",
        " enum trace_reason reason",
        " __u32 monitor __maybe_unused"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void send_trace_notify6 (struct  __ctx_buff *ctx, enum trace_point obs_point, __u32 src __maybe_unused, __u32 dst __maybe_unused, union v6addr * orig_addr __maybe_unused, __u16 dst_id __maybe_unused, __u32 ifindex __maybe_unused, enum trace_reason reason, __u32 monitor __maybe_unused)\n",
        "{\n",
        "    update_trace_metrics (ctx, obs_point, reason);\n",
        "}\n"
      ],
      "called_function_list": [
        "emit_trace_notify",
        "ctx_full_len",
        "update_trace_metrics",
        "ipv6_addr_copy"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "bpf_clear_meta": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 7,
      "endLine": 17,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_skb.h",
      "funcName": "bpf_clear_meta",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */"
        },
        {
          "start_line": 2,
          "end_line": 2,
          "text": "/* Copyright Authors of Cilium */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __sk_buff *ctx"
      ],
      "output": "static__always_inline__maybe_unusedvoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused void bpf_clear_meta (struct  __sk_buff *ctx)\n",
        "{\n",
        "    __u32 zero = 0;\n",
        "    WRITE_ONCE (ctx->cb[0], zero);\n",
        "    WRITE_ONCE (ctx->cb[1], zero);\n",
        "    WRITE_ONCE (ctx->cb[2], zero);\n",
        "    WRITE_ONCE (ctx->cb[3], zero);\n",
        "    WRITE_ONCE (ctx->cb[4], zero);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 7,
      "endLine": 10,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_xdp.h",
      "funcName": "bpf_clear_meta",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */"
        },
        {
          "start_line": 2,
          "end_line": 2,
          "text": "/* Copyright Authors of Cilium */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct xdp_md * ctx __maybe_unused"
      ],
      "output": "static__always_inline__maybe_unusedvoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused void bpf_clear_meta (struct xdp_md * ctx __maybe_unused)\n",
        "{\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "get_identity": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 22,
      "endLine": 26,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_skb.h",
      "funcName": "get_identity",
      "developer_inline_comments": [
        {
          "start_line": 19,
          "end_line": 21,
          "text": "/**\n * get_identity - returns source identity from the mark field\n */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct  __sk_buff *ctx"
      ],
      "output": "static__always_inline__maybe_unusedint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused int get_identity (const struct  __sk_buff *ctx)\n",
        "{\n",
        "    return ((ctx->mark & 0xFF) << 16) | ctx->mark >> 16;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 12,
      "endLine": 16,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_xdp.h",
      "funcName": "get_identity",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct xdp_md * ctx __maybe_unused"
      ],
      "output": "static__always_inline__maybe_unusedint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused int get_identity (struct xdp_md * ctx __maybe_unused)\n",
        "{\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "get_epid": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 31,
      "endLine": 35,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_skb.h",
      "funcName": "get_epid",
      "developer_inline_comments": [
        {
          "start_line": 28,
          "end_line": 30,
          "text": "/**\n * get_epid - returns source endpoint identity from the mark field\n */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct  __sk_buff *ctx"
      ],
      "output": "static__always_inline__maybe_unused__u32",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused __u32 get_epid (const struct  __sk_buff *ctx)\n",
        "{\n",
        "    return ctx->mark >> 16;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "set_encrypt_dip": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 37,
      "endLine": 41,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_skb.h",
      "funcName": "set_encrypt_dip",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __sk_buff *ctx",
        " __u32 ip_endpoint"
      ],
      "output": "static__always_inline__maybe_unusedvoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused void set_encrypt_dip (struct  __sk_buff *ctx, __u32 ip_endpoint)\n",
        "{\n",
        "    ctx->cb[4] = ip_endpoint;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 18,
      "endLine": 22,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_xdp.h",
      "funcName": "set_encrypt_dip",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct xdp_md * ctx __maybe_unused",
        " __u32 ip_endpoint __maybe_unused"
      ],
      "output": "static__always_inline__maybe_unusedvoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused void set_encrypt_dip (struct xdp_md * ctx __maybe_unused, __u32 ip_endpoint __maybe_unused)\n",
        "{\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "set_identity_mark": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 46,
      "endLine": 51,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_skb.h",
      "funcName": "set_identity_mark",
      "developer_inline_comments": [
        {
          "start_line": 43,
          "end_line": 45,
          "text": "/**\n * set_identity_mark - pushes 24 bit identity into ctx mark value.\n */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __sk_buff *ctx",
        " __u32 identity"
      ],
      "output": "static__always_inline__maybe_unusedvoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused void set_identity_mark (struct  __sk_buff *ctx, __u32 identity)\n",
        "{\n",
        "    ctx->mark = ctx->mark & MARK_MAGIC_KEY_MASK;\n",
        "    ctx->mark |= ((identity & 0xFFFF) << 16) | ((identity & 0xFF0000) >> 16);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 24,
      "endLine": 27,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_xdp.h",
      "funcName": "set_identity_mark",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct xdp_md * ctx __maybe_unused",
        " __u32 identity __maybe_unused"
      ],
      "output": "static__always_inline__maybe_unusedvoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused void set_identity_mark (struct xdp_md * ctx __maybe_unused, __u32 identity __maybe_unused)\n",
        "{\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "set_identity_meta": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 53,
      "endLine": 57,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_skb.h",
      "funcName": "set_identity_meta",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __sk_buff *ctx",
        " __u32 identity"
      ],
      "output": "static__always_inline__maybe_unusedvoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused void set_identity_meta (struct  __sk_buff *ctx, __u32 identity)\n",
        "{\n",
        "    ctx->cb[1] = identity;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 29,
      "endLine": 33,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_xdp.h",
      "funcName": "set_identity_meta",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct xdp_md * ctx __maybe_unused",
        " __u32 identity __maybe_unused"
      ],
      "output": "static__always_inline__maybe_unusedvoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused void set_identity_meta (struct xdp_md * ctx __maybe_unused, __u32 identity __maybe_unused)\n",
        "{\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "set_encrypt_key_mark": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 62,
      "endLine": 66,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_skb.h",
      "funcName": "set_encrypt_key_mark",
      "developer_inline_comments": [
        {
          "start_line": 59,
          "end_line": 61,
          "text": "/**\n * set_encrypt_key - pushes 8 bit key and encryption marker into ctx mark value.\n */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __sk_buff *ctx",
        " __u8 key"
      ],
      "output": "static__always_inline__maybe_unusedvoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused void set_encrypt_key_mark (struct  __sk_buff *ctx, __u8 key)\n",
        "{\n",
        "    ctx->mark = or_encrypt_key (key);\n",
        "}\n"
      ],
      "called_function_list": [
        "or_encrypt_key"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 35,
      "endLine": 38,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_xdp.h",
      "funcName": "set_encrypt_key_mark",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct xdp_md * ctx __maybe_unused",
        " __u8 key __maybe_unused"
      ],
      "output": "static__always_inline__maybe_unusedvoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused void set_encrypt_key_mark (struct xdp_md * ctx __maybe_unused, __u8 key __maybe_unused)\n",
        "{\n",
        "}\n"
      ],
      "called_function_list": [
        "or_encrypt_key"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "set_encrypt_key_meta": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 68,
      "endLine": 72,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_skb.h",
      "funcName": "set_encrypt_key_meta",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __sk_buff *ctx",
        " __u8 key"
      ],
      "output": "static__always_inline__maybe_unusedvoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused void set_encrypt_key_meta (struct  __sk_buff *ctx, __u8 key)\n",
        "{\n",
        "    ctx->cb[0] = or_encrypt_key (key);\n",
        "}\n"
      ],
      "called_function_list": [
        "or_encrypt_key"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 40,
      "endLine": 43,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_xdp.h",
      "funcName": "set_encrypt_key_meta",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct xdp_md * ctx __maybe_unused",
        " __u8 key __maybe_unused"
      ],
      "output": "static__always_inline__maybe_unusedvoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused void set_encrypt_key_meta (struct xdp_md * ctx __maybe_unused, __u8 key __maybe_unused)\n",
        "{\n",
        "}\n"
      ],
      "called_function_list": [
        "or_encrypt_key"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "set_encrypt_mark": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 79,
      "endLine": 83,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_skb.h",
      "funcName": "set_encrypt_mark",
      "developer_inline_comments": [
        {
          "start_line": 74,
          "end_line": 78,
          "text": "/**\n * set_encrypt_mark - sets the encryption mark to make skb to match ip rule\n * used to steer packet into Wireguard tunnel device (cilium_wg0) in order to\n * encrypt it.\n */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __sk_buff *ctx"
      ],
      "output": "static__always_inline__maybe_unusedvoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused void set_encrypt_mark (struct  __sk_buff *ctx)\n",
        "{\n",
        "    ctx->mark |= MARK_MAGIC_ENCRYPT;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "redirect_self": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 85,
      "endLine": 99,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_skb.h",
      "funcName": "redirect_self",
      "developer_inline_comments": [
        {
          "start_line": 88,
          "end_line": 93,
          "text": "/* Looping back the packet into the originating netns. In\n\t * case of veth, it's xmit'ing into the hosts' veth device\n\t * such that we end up on ingress in the peer. For ipvlan\n\t * slave it's redirect to ingress as we are attached on the\n\t * slave in netns already.\n\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct  __sk_buff *ctx"
      ],
      "output": "static__always_inline__maybe_unusedint",
      "helper": [
        "redirect"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp",
        "lwt_xmit"
      ],
      "source": [
        "static __always_inline __maybe_unused int redirect_self (const struct  __sk_buff *ctx)\n",
        "{\n",
        "\n",
        "#ifdef ENABLE_HOST_REDIRECT\n",
        "    return ctx_redirect (ctx, ctx->ifindex, 0);\n",
        "\n",
        "#else\n",
        "    return ctx_redirect (ctx, ctx->ifindex, BPF_F_INGRESS);\n",
        "\n",
        "#endif\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_redirect"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [
        {
          "capability": "pkt_alter_or_redo_processing_or_interface",
          "pkt_alter_or_redo_processing_or_interface": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "XDP_TX",
              "Return": 3,
              "Description": "an efficient option to transmit the network packet out of the same NIC it just arrived on again. This is typically useful when few nodes are implementing, for example, firewalling with subsequent load balancing in a cluster and thus act as a hairpinned load balancer pushing the incoming packets back into the switch after rewriting them in XDP BPF.",
              "compatible_hookpoints": [
                "xdp"
              ],
              "capabilities": [
                "pkt_alter_or_redo_processing_or_interface"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 45,
      "endLine": 53,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_xdp.h",
      "funcName": "redirect_self",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct xdp_md * ctx __maybe_unused"
      ],
      "output": "static__always_inline__maybe_unusedint",
      "helper": [
        "redirect",
        "XDP_TX"
      ],
      "compatibleHookpoints": [
        "xdp"
      ],
      "source": [
        "static __always_inline __maybe_unused int redirect_self (struct xdp_md * ctx __maybe_unused)\n",
        "{\n",
        "\n",
        "#ifdef ENABLE_HOST_REDIRECT\n",
        "    return XDP_TX;\n",
        "\n",
        "#else\n",
        "    return -ENOTSUP;\n",
        "\n",
        "#endif\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_redirect"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ctx_skip_nodeport_clear": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 101,
      "endLine": 107,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_skb.h",
      "funcName": "ctx_skip_nodeport_clear",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __sk_buff * ctx __maybe_unused"
      ],
      "output": "static__always_inline__maybe_unusedvoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused void ctx_skip_nodeport_clear (struct  __sk_buff * ctx __maybe_unused)\n",
        "{\n",
        "\n",
        "#ifdef ENABLE_NODEPORT\n",
        "    ctx->tc_index &= ~TC_INDEX_F_SKIP_NODEPORT;\n",
        "\n",
        "#endif\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_store_meta"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 58,
      "endLine": 64,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_xdp.h",
      "funcName": "ctx_skip_nodeport_clear",
      "developer_inline_comments": [
        {
          "start_line": 55,
          "end_line": 55,
          "text": "/* tail call recirculation */"
        },
        {
          "start_line": 56,
          "end_line": 56,
          "text": "/* xdp -> skb meta transfer */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct xdp_md * ctx __maybe_unused"
      ],
      "output": "static__always_inline__maybe_unusedvoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused void ctx_skip_nodeport_clear (struct xdp_md * ctx __maybe_unused)\n",
        "{\n",
        "\n",
        "#ifdef ENABLE_NODEPORT\n",
        "    ctx_store_meta (ctx, RECIRC_MARKER, 0);\n",
        "\n",
        "#endif\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_store_meta"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ctx_skip_nodeport_set": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 109,
      "endLine": 115,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_skb.h",
      "funcName": "ctx_skip_nodeport_set",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __sk_buff * ctx __maybe_unused"
      ],
      "output": "static__always_inline__maybe_unusedvoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused void ctx_skip_nodeport_set (struct  __sk_buff * ctx __maybe_unused)\n",
        "{\n",
        "\n",
        "#ifdef ENABLE_NODEPORT\n",
        "    ctx->tc_index |= TC_INDEX_F_SKIP_NODEPORT;\n",
        "\n",
        "#endif\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_store_meta"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 66,
      "endLine": 72,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_xdp.h",
      "funcName": "ctx_skip_nodeport_set",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct xdp_md * ctx __maybe_unused"
      ],
      "output": "static__always_inline__maybe_unusedvoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused void ctx_skip_nodeport_set (struct xdp_md * ctx __maybe_unused)\n",
        "{\n",
        "\n",
        "#ifdef ENABLE_NODEPORT\n",
        "    ctx_store_meta (ctx, RECIRC_MARKER, 1);\n",
        "\n",
        "#endif\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_store_meta"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ctx_skip_nodeport": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 117,
      "endLine": 127,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_skb.h",
      "funcName": "ctx_skip_nodeport",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __sk_buff * ctx __maybe_unused"
      ],
      "output": "static__always_inline__maybe_unusedbool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused bool ctx_skip_nodeport (struct  __sk_buff * ctx __maybe_unused)\n",
        "{\n",
        "\n",
        "#ifdef ENABLE_NODEPORT\n",
        "    volatile __u32 tc_index = ctx->tc_index;\n",
        "    ctx->tc_index &= ~TC_INDEX_F_SKIP_NODEPORT;\n",
        "    return tc_index & TC_INDEX_F_SKIP_NODEPORT;\n",
        "\n",
        "#else\n",
        "    return true;\n",
        "\n",
        "#endif\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_load_meta"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 74,
      "endLine": 82,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_xdp.h",
      "funcName": "ctx_skip_nodeport",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct xdp_md * ctx __maybe_unused"
      ],
      "output": "static__always_inline__maybe_unusedbool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused bool ctx_skip_nodeport (struct xdp_md * ctx __maybe_unused)\n",
        "{\n",
        "\n",
        "#ifdef ENABLE_NODEPORT\n",
        "    return ctx_load_meta (ctx, RECIRC_MARKER);\n",
        "\n",
        "#else\n",
        "    return true;\n",
        "\n",
        "#endif\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_load_meta"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ctx_skip_host_fw_set": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 130,
      "endLine": 134,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_skb.h",
      "funcName": "ctx_skip_host_fw_set",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __sk_buff *ctx"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void ctx_skip_host_fw_set (struct  __sk_buff *ctx)\n",
        "{\n",
        "    ctx->tc_index |= TC_INDEX_F_SKIP_HOST_FIREWALL;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ctx_skip_host_fw": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 136,
      "endLine": 143,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_skb.h",
      "funcName": "ctx_skip_host_fw",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __sk_buff *ctx"
      ],
      "output": "static__always_inlinebool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline bool ctx_skip_host_fw (struct  __sk_buff *ctx)\n",
        "{\n",
        "    volatile __u32 tc_index = ctx->tc_index;\n",
        "    ctx->tc_index &= ~TC_INDEX_F_SKIP_HOST_FIREWALL;\n",
        "    return tc_index & TC_INDEX_F_SKIP_HOST_FIREWALL;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ctx_get_xfer": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 146,
      "endLine": 152,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_skb.h",
      "funcName": "ctx_get_xfer",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __sk_buff *ctx"
      ],
      "output": "static__always_inline__maybe_unused__u32",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused __u32 ctx_get_xfer (struct  __sk_buff *ctx)\n",
        "{\n",
        "    __u32 *data_meta = ctx_data_meta (ctx);\n",
        "    void *data = ctx_data (ctx);\n",
        "    return !ctx_no_room (data_meta + 1, data) ? data_meta[0] : 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_data_meta",
        "ctx_data",
        "ctx_no_room"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 84,
      "endLine": 88,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_xdp.h",
      "funcName": "ctx_get_xfer",
      "developer_inline_comments": [
        {
          "start_line": 87,
          "end_line": 87,
          "text": "/* Only intended for SKB context. */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct xdp_md * ctx __maybe_unused"
      ],
      "output": "static__always_inline__maybe_unused__u32",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused __u32 ctx_get_xfer (struct xdp_md * ctx __maybe_unused)\n",
        "{\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_data_meta",
        "ctx_data",
        "ctx_no_room"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ctx_set_xfer": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 154,
      "endLine": 158,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_skb.h",
      "funcName": "ctx_set_xfer",
      "developer_inline_comments": [
        {
          "start_line": 157,
          "end_line": 157,
          "text": "/* Only possible from XDP -> SKB. */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __sk_buff * ctx __maybe_unused",
        " __u32 meta __maybe_unused"
      ],
      "output": "static__always_inline__maybe_unusedvoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused void ctx_set_xfer (struct  __sk_buff * ctx __maybe_unused, __u32 meta __maybe_unused)\n",
        "{\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_store_meta"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 90,
      "endLine": 94,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_xdp.h",
      "funcName": "ctx_set_xfer",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct xdp_md *ctx",
        " __u32 meta"
      ],
      "output": "static__always_inline__maybe_unusedvoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused void ctx_set_xfer (struct xdp_md *ctx, __u32 meta)\n",
        "{\n",
        "    ctx_store_meta (ctx, XFER_MARKER, meta);\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_store_meta"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ctx_change_head": [
    {
      "capabilities": [
        {
          "capability": "update_pkt",
          "update_pkt": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Description": "Grows headroom of packet associated to <[ skb ]>(IP: 0) and adjusts the offset of the MAC header accordingly , adding <[ len ]>(IP: 1) bytes of space. It automatically extends and reallocates memory as required. This helper can be used on a layer 3 <[ skb ]>(IP: 0) to push a MAC header for redirection into a layer 2 device. All values for <[ flags ]>(IP: 2) are reserved for future usage , and must be left at zero. A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "skb_change_head",
              "Input Params": [
                "{Type: struct sk_buff ,Var: *skb}",
                "{Type:  u32 ,Var: len}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "lwt_xmit",
                "sk_skb"
              ],
              "capabilities": [
                "update_pkt"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 160,
      "endLine": 164,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_skb.h",
      "funcName": "ctx_change_head",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __sk_buff *ctx",
        " __u32 head_room",
        " __u64 flags"
      ],
      "output": "static__always_inline__maybe_unusedint",
      "helper": [
        "skb_change_head"
      ],
      "compatibleHookpoints": [
        "sk_skb",
        "sched_cls",
        "sched_act",
        "lwt_xmit"
      ],
      "source": [
        "static __always_inline __maybe_unused int ctx_change_head (struct  __sk_buff *ctx, __u32 head_room, __u64 flags)\n",
        "{\n",
        "    return skb_change_head (ctx, head_room, flags);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 96,
      "endLine": 102,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_xdp.h",
      "funcName": "ctx_change_head",
      "developer_inline_comments": [
        {
          "start_line": 101,
          "end_line": 101,
          "text": "/* Only intended for SKB context. */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct xdp_md * ctx __maybe_unused",
        " __u32 head_room __maybe_unused",
        " __u64 flags __maybe_unused"
      ],
      "output": "static__always_inline__maybe_unusedint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused int ctx_change_head (struct xdp_md * ctx __maybe_unused, __u32 head_room __maybe_unused, __u64 flags __maybe_unused)\n",
        "{\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ipv6_host_policy_egress": [
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 17,
      "endLine": 100,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/host_firewall.h",
      "funcName": "ipv6_host_policy_egress",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */"
        },
        {
          "start_line": 2,
          "end_line": 2,
          "text": "/* Copyright Authors of Cilium */"
        },
        {
          "start_line": 7,
          "end_line": 9,
          "text": "/* Only compile in if host firewall is enabled and file is included from\n * bpf_host.\n */"
        },
        {
          "start_line": 32,
          "end_line": 32,
          "text": "/* Only enforce host policies for packets from host IPs. */"
        },
        {
          "start_line": 39,
          "end_line": 39,
          "text": "/* Lookup connection in conntrack map. */"
        },
        {
          "start_line": 55,
          "end_line": 55,
          "text": "/* Retrieve destination identity. */"
        },
        {
          "start_line": 62,
          "end_line": 62,
          "text": "/* Perform policy lookup. */"
        },
        {
          "start_line": 66,
          "end_line": 66,
          "text": "/* Reply traffic and related are allowed regardless of policy verdict. */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " __u32 src_id",
        " struct trace_ctx *trace"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "CTX_ACT_OK"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "static __always_inline int ipv6_host_policy_egress (struct  __ctx_buff *ctx, __u32 src_id, struct trace_ctx *trace)\n",
        "{\n",
        "    int ret, verdict, l3_off = ETH_HLEN, l4_off, hdrlen;\n",
        "    struct ct_state ct_state_new = {}, ct_state = {};\n",
        "    __u8 policy_match_type = POLICY_MATCH_NONE;\n",
        "    __u8 audited = 0;\n",
        "    struct remote_endpoint_info *info;\n",
        "    struct ipv6_ct_tuple tuple = {}\n",
        "    ;\n",
        "    __u32 dst_id = 0;\n",
        "    union v6addr orig_dip;\n",
        "    void *data, *data_end;\n",
        "    struct ipv6hdr *ip6;\n",
        "    if (src_id != HOST_ID)\n",
        "        return CTX_ACT_OK;\n",
        "    if (!revalidate_data (ctx, &data, &data_end, &ip6))\n",
        "        return DROP_INVALID;\n",
        "    tuple.nexthdr = ip6->nexthdr;\n",
        "    ipv6_addr_copy (&tuple.saddr, (union v6addr *) &ip6->saddr);\n",
        "    ipv6_addr_copy (&tuple.daddr, (union v6addr *) &ip6->daddr);\n",
        "    ipv6_addr_copy (&orig_dip, (union v6addr *) &ip6->daddr);\n",
        "    hdrlen = ipv6_hdrlen (ctx, & tuple.nexthdr);\n",
        "    if (hdrlen < 0)\n",
        "        return hdrlen;\n",
        "    l4_off = l3_off + hdrlen;\n",
        "    ret = ct_lookup6 (get_ct_map6 (& tuple), & tuple, ctx, l4_off, CT_EGRESS, & ct_state, & trace -> monitor);\n",
        "    if (ret < 0)\n",
        "        return ret;\n",
        "    trace->reason = (enum trace_reason) ret;\n",
        "    info = lookup_ip6_remote_endpoint (& orig_dip);\n",
        "    if (info && info->sec_label)\n",
        "        dst_id = info->sec_label;\n",
        "    cilium_dbg (ctx, info ? DBG_IP_ID_MAP_SUCCEED6 : DBG_IP_ID_MAP_FAILED6, orig_dip.p4, dst_id);\n",
        "    verdict = policy_can_egress6 (ctx, & tuple, src_id, dst_id, & policy_match_type, & audited);\n",
        "    if (ret != CT_REPLY && ret != CT_RELATED && verdict < 0) {\n",
        "        send_policy_verdict_notify (ctx, dst_id, tuple.dport, tuple.nexthdr, POLICY_EGRESS, 1, verdict, policy_match_type, audited);\n",
        "        return verdict;\n",
        "    }\n",
        "    switch (ret) {\n",
        "    case CT_NEW :\n",
        "        send_policy_verdict_notify (ctx, dst_id, tuple.dport, tuple.nexthdr, POLICY_EGRESS, 1, verdict, policy_match_type, audited);\n",
        "        ct_state_new.src_sec_id = HOST_ID;\n",
        "        ret = ct_create6 (get_ct_map6 (& tuple), & CT_MAP_ANY6, & tuple, ctx, CT_EGRESS, & ct_state_new, verdict > 0, false);\n",
        "        if (IS_ERR (ret))\n",
        "            return ret;\n",
        "        break;\n",
        "    case CT_REOPENED :\n",
        "        send_policy_verdict_notify (ctx, dst_id, tuple.dport, tuple.nexthdr, POLICY_EGRESS, 1, verdict, policy_match_type, audited);\n",
        "    case CT_ESTABLISHED :\n",
        "    case CT_RELATED :\n",
        "    case CT_REPLY :\n",
        "        break;\n",
        "    default :\n",
        "        return DROP_UNKNOWN_CT;\n",
        "    }\n",
        "    return CTX_ACT_OK;\n",
        "}\n"
      ],
      "called_function_list": [
        "get_ct_map6",
        "ipv6_hdrlen",
        "send_policy_verdict_notify",
        "policy_can_egress6",
        "ipv6_addr_copy",
        "ct_create6",
        "cilium_dbg",
        "ct_lookup6"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ipv6_host_policy_ingress": [
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 102,
      "endLine": 199,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/host_firewall.h",
      "funcName": "ipv6_host_policy_ingress",
      "developer_inline_comments": [
        {
          "start_line": 120,
          "end_line": 120,
          "text": "/* Retrieve destination identity. */"
        },
        {
          "start_line": 128,
          "end_line": 128,
          "text": "/* Only enforce host policies for packets to host IPs. */"
        },
        {
          "start_line": 132,
          "end_line": 132,
          "text": "/* Lookup connection in conntrack map. */"
        },
        {
          "start_line": 147,
          "end_line": 147,
          "text": "/* Retrieve source identity. */"
        },
        {
          "start_line": 154,
          "end_line": 154,
          "text": "/* Perform policy lookup */"
        },
        {
          "start_line": 159,
          "end_line": 159,
          "text": "/* Reply traffic and related are allowed regardless of policy verdict. */"
        },
        {
          "start_line": 173,
          "end_line": 173,
          "text": "/* Create new entry for connection in conntrack map. */"
        },
        {
          "start_line": 194,
          "end_line": 196,
          "text": "/* This change is necessary for packets redirected from the lxc device to\n\t * the host device.\n\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " __u32 *src_id",
        " struct trace_ctx *trace"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "CTX_ACT_OK"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "static __always_inline int ipv6_host_policy_ingress (struct  __ctx_buff *ctx, __u32 *src_id, struct trace_ctx *trace)\n",
        "{\n",
        "    struct ct_state ct_state_new = {}, ct_state = {};\n",
        "    __u8 policy_match_type = POLICY_MATCH_NONE;\n",
        "    __u8 audited = 0;\n",
        "    __u32 dst_id = WORLD_ID;\n",
        "    struct remote_endpoint_info *info;\n",
        "    int ret, verdict, l4_off, hdrlen;\n",
        "    struct ipv6_ct_tuple tuple = {}\n",
        "    ;\n",
        "    union v6addr orig_sip;\n",
        "    void *data, *data_end;\n",
        "    struct ipv6hdr *ip6;\n",
        "    if (!revalidate_data (ctx, &data, &data_end, &ip6))\n",
        "        return DROP_INVALID;\n",
        "    ipv6_addr_copy (&tuple.daddr, (union v6addr *) &ip6->daddr);\n",
        "    info = lookup_ip6_remote_endpoint (& tuple.daddr);\n",
        "    if (info && info->sec_label)\n",
        "        dst_id = info->sec_label;\n",
        "    cilium_dbg (ctx, info ? DBG_IP_ID_MAP_SUCCEED6 : DBG_IP_ID_MAP_FAILED6, tuple.daddr.p4, dst_id);\n",
        "    if (dst_id != HOST_ID)\n",
        "        return CTX_ACT_OK;\n",
        "    tuple.nexthdr = ip6->nexthdr;\n",
        "    ipv6_addr_copy (&tuple.saddr, (union v6addr *) &ip6->saddr);\n",
        "    ipv6_addr_copy (&orig_sip, (union v6addr *) &ip6->saddr);\n",
        "    hdrlen = ipv6_hdrlen (ctx, & tuple.nexthdr);\n",
        "    if (hdrlen < 0)\n",
        "        return hdrlen;\n",
        "    l4_off = ETH_HLEN + hdrlen;\n",
        "    ret = ct_lookup6 (get_ct_map6 (& tuple), & tuple, ctx, l4_off, CT_INGRESS, & ct_state, & trace -> monitor);\n",
        "    if (ret < 0)\n",
        "        return ret;\n",
        "    trace->reason = (enum trace_reason) ret;\n",
        "    info = lookup_ip6_remote_endpoint (& orig_sip);\n",
        "    if (info && info->sec_label)\n",
        "        *src_id = info->sec_label;\n",
        "    cilium_dbg (ctx, info ? DBG_IP_ID_MAP_SUCCEED6 : DBG_IP_ID_MAP_FAILED6, orig_sip.p4, *src_id);\n",
        "    verdict = policy_can_access_ingress (ctx, * src_id, dst_id, tuple.dport, tuple.nexthdr, false, & policy_match_type, & audited);\n",
        "    if (ret != CT_REPLY && ret != CT_RELATED && verdict < 0) {\n",
        "        send_policy_verdict_notify (ctx, *src_id, tuple.dport, tuple.nexthdr, POLICY_INGRESS, 1, verdict, policy_match_type, audited);\n",
        "        return verdict;\n",
        "    }\n",
        "    switch (ret) {\n",
        "    case CT_NEW :\n",
        "        send_policy_verdict_notify (ctx, *src_id, tuple.dport, tuple.nexthdr, POLICY_INGRESS, 1, verdict, policy_match_type, audited);\n",
        "        ct_state_new.src_sec_id = *src_id;\n",
        "        ct_state_new.node_port = ct_state.node_port;\n",
        "        ret = ct_create6 (get_ct_map6 (& tuple), & CT_MAP_ANY6, & tuple, ctx, CT_INGRESS, & ct_state_new, verdict > 0, false);\n",
        "        if (IS_ERR (ret))\n",
        "            return ret;\n",
        "    case CT_REOPENED :\n",
        "        send_policy_verdict_notify (ctx, *src_id, tuple.dport, tuple.nexthdr, POLICY_INGRESS, 1, verdict, policy_match_type, audited);\n",
        "    case CT_ESTABLISHED :\n",
        "    case CT_RELATED :\n",
        "    case CT_REPLY :\n",
        "        break;\n",
        "    default :\n",
        "        return DROP_UNKNOWN_CT;\n",
        "    }\n",
        "    ctx_change_type (ctx, PACKET_HOST);\n",
        "    return CTX_ACT_OK;\n",
        "}\n"
      ],
      "called_function_list": [
        "get_ct_map6",
        "ipv6_hdrlen",
        "send_policy_verdict_notify",
        "policy_can_access_ingress",
        "ipv6_addr_copy",
        "ct_create6",
        "cilium_dbg",
        "ct_lookup6"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "whitelist_snated_egress_connections": [
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 204,
      "endLine": 249,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/host_firewall.h",
      "funcName": "whitelist_snated_egress_connections",
      "developer_inline_comments": [
        {
          "start_line": 214,
          "end_line": 223,
          "text": "/* If kube-proxy is in use (no BPF-based masquerading), packets from\n\t * pods may be SNATed. The response packet will therefore have a host\n\t * IP as the destination IP.\n\t * To avoid enforcing host policies for response packets to pods, we\n\t * need to create a CT entry for the forward, SNATed packet from the\n\t * pod. Response packets will thus match this CT entry and bypass host\n\t * policies.\n\t * We know the packet is a SNATed packet if the srcid from ipcache is\n\t * HOST_ID, but the actual srcid (derived from the packet mark) isn't.\n\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " __u32 ipcache_srcid",
        " struct trace_ctx *trace"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "CTX_ACT_OK"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "static __always_inline int whitelist_snated_egress_connections (struct  __ctx_buff *ctx, __u32 ipcache_srcid, struct trace_ctx *trace)\n",
        "{\n",
        "    struct ct_state ct_state_new = {}, ct_state = {};\n",
        "    struct ipv4_ct_tuple tuple = {}\n",
        "    ;\n",
        "    void *data, *data_end;\n",
        "    struct iphdr *ip4;\n",
        "    int ret, l4_off;\n",
        "    if (ipcache_srcid == HOST_ID) {\n",
        "        if (!revalidate_data (ctx, &data, &data_end, &ip4))\n",
        "            return DROP_INVALID;\n",
        "        tuple.nexthdr = ip4->protocol;\n",
        "        tuple.daddr = ip4->daddr;\n",
        "        tuple.saddr = ip4->saddr;\n",
        "        l4_off = ETH_HLEN + ipv4_hdrlen (ip4);\n",
        "        ret = ct_lookup4 (get_ct_map4 (& tuple), & tuple, ctx, l4_off, CT_EGRESS, & ct_state, & trace -> monitor);\n",
        "        if (ret < 0)\n",
        "            return ret;\n",
        "        trace->reason = (enum trace_reason) ret;\n",
        "        if (ret == CT_NEW) {\n",
        "            ret = ct_create4 (get_ct_map4 (& tuple), & CT_MAP_ANY4, & tuple, ctx, CT_EGRESS, & ct_state_new, false, false);\n",
        "            if (IS_ERR (ret))\n",
        "                return ret;\n",
        "        }\n",
        "    }\n",
        "    return CTX_ACT_OK;\n",
        "}\n"
      ],
      "called_function_list": [
        "ipv4_hdrlen",
        "ct_create4",
        "get_ct_map4",
        "ct_lookup4"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ipv4_host_policy_egress": [
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 252,
      "endLine": 337,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/host_firewall.h",
      "funcName": "ipv4_host_policy_egress",
      "developer_inline_comments": [
        {
          "start_line": 272,
          "end_line": 272,
          "text": "/* Only enforce host policies for packets from host IPs. */"
        },
        {
          "start_line": 280,
          "end_line": 280,
          "text": "/* Lookup connection in conntrack map. */"
        },
        {
          "start_line": 292,
          "end_line": 292,
          "text": "/* Retrieve destination identity. */"
        },
        {
          "start_line": 299,
          "end_line": 299,
          "text": "/* Perform policy lookup. */"
        },
        {
          "start_line": 303,
          "end_line": 303,
          "text": "/* Reply traffic and related are allowed regardless of policy verdict. */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " __u32 src_id",
        " __u32 ipcache_srcid __maybe_unused",
        " struct trace_ctx *trace"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "CTX_ACT_OK"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "static __always_inline int ipv4_host_policy_egress (struct  __ctx_buff *ctx, __u32 src_id, __u32 ipcache_srcid __maybe_unused, struct trace_ctx *trace)\n",
        "{\n",
        "    struct ct_state ct_state_new = {}, ct_state = {};\n",
        "    int ret, verdict, l4_off, l3_off = ETH_HLEN;\n",
        "    __u8 policy_match_type = POLICY_MATCH_NONE;\n",
        "    __u8 audited = 0;\n",
        "    struct remote_endpoint_info *info;\n",
        "    struct ipv4_ct_tuple tuple = {}\n",
        "    ;\n",
        "    __u32 dst_id = 0;\n",
        "    void *data, *data_end;\n",
        "    struct iphdr *ip4;\n",
        "    if (src_id != HOST_ID) {\n",
        "\n",
        "#  ifndef ENABLE_MASQUERADE\n",
        "        return whitelist_snated_egress_connections (ctx, ipcache_srcid, trace);\n",
        "\n",
        "#  else\n",
        "        return CTX_ACT_OK;\n",
        "\n",
        "#  endif\n",
        "    }\n",
        "    if (!revalidate_data (ctx, &data, &data_end, &ip4))\n",
        "        return DROP_INVALID;\n",
        "    tuple.nexthdr = ip4->protocol;\n",
        "    tuple.daddr = ip4->daddr;\n",
        "    tuple.saddr = ip4->saddr;\n",
        "    l4_off = l3_off + ipv4_hdrlen (ip4);\n",
        "    ret = ct_lookup4 (get_ct_map4 (& tuple), & tuple, ctx, l4_off, CT_EGRESS, & ct_state, & trace -> monitor);\n",
        "    if (ret < 0)\n",
        "        return ret;\n",
        "    trace->reason = (enum trace_reason) ret;\n",
        "    info = lookup_ip4_remote_endpoint (ip4 -> daddr);\n",
        "    if (info && info->sec_label)\n",
        "        dst_id = info->sec_label;\n",
        "    cilium_dbg (ctx, info ? DBG_IP_ID_MAP_SUCCEED4 : DBG_IP_ID_MAP_FAILED4, ip4->daddr, dst_id);\n",
        "    verdict = policy_can_egress4 (ctx, & tuple, src_id, dst_id, & policy_match_type, & audited);\n",
        "    if (ret != CT_REPLY && ret != CT_RELATED && verdict < 0) {\n",
        "        send_policy_verdict_notify (ctx, dst_id, tuple.dport, tuple.nexthdr, POLICY_EGRESS, 0, verdict, policy_match_type, audited);\n",
        "        return verdict;\n",
        "    }\n",
        "    switch (ret) {\n",
        "    case CT_NEW :\n",
        "        send_policy_verdict_notify (ctx, dst_id, tuple.dport, tuple.nexthdr, POLICY_EGRESS, 0, verdict, policy_match_type, audited);\n",
        "        ct_state_new.src_sec_id = HOST_ID;\n",
        "        ret = ct_create4 (get_ct_map4 (& tuple), & CT_MAP_ANY4, & tuple, ctx, CT_EGRESS, & ct_state_new, verdict > 0, false);\n",
        "        if (IS_ERR (ret))\n",
        "            return ret;\n",
        "        break;\n",
        "    case CT_REOPENED :\n",
        "        send_policy_verdict_notify (ctx, dst_id, tuple.dport, tuple.nexthdr, POLICY_EGRESS, 0, verdict, policy_match_type, audited);\n",
        "    case CT_ESTABLISHED :\n",
        "    case CT_RELATED :\n",
        "    case CT_REPLY :\n",
        "        break;\n",
        "    default :\n",
        "        return DROP_UNKNOWN_CT;\n",
        "    }\n",
        "    return CTX_ACT_OK;\n",
        "}\n"
      ],
      "called_function_list": [
        "send_policy_verdict_notify",
        "ipv4_hdrlen",
        "ct_create4",
        "get_ct_map4",
        "policy_can_egress4",
        "ct_lookup4",
        "cilium_dbg",
        "whitelist_snated_egress_connections"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ipv4_host_policy_ingress": [
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 339,
      "endLine": 439,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/host_firewall.h",
      "funcName": "ipv4_host_policy_ingress",
      "developer_inline_comments": [
        {
          "start_line": 357,
          "end_line": 357,
          "text": "/* Retrieve destination identity. */"
        },
        {
          "start_line": 364,
          "end_line": 364,
          "text": "/* Only enforce host policies for packets to host IPs. */"
        },
        {
          "start_line": 368,
          "end_line": 368,
          "text": "/* Lookup connection in conntrack map. */"
        },
        {
          "start_line": 374,
          "end_line": 376,
          "text": "/* Indicate that this is a datagram fragment for which we cannot\n\t * retrieve L4 ports. Do not set flag if we support fragmentation.\n\t */"
        },
        {
          "start_line": 386,
          "end_line": 386,
          "text": "/* Retrieve source identity. */"
        },
        {
          "start_line": 393,
          "end_line": 393,
          "text": "/* Perform policy lookup */"
        },
        {
          "start_line": 399,
          "end_line": 399,
          "text": "/* Reply traffic and related are allowed regardless of policy verdict. */"
        },
        {
          "start_line": 413,
          "end_line": 413,
          "text": "/* Create new entry for connection in conntrack map. */"
        },
        {
          "start_line": 434,
          "end_line": 436,
          "text": "/* This change is necessary for packets redirected from the lxc device to\n\t * the host device.\n\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " __u32 *src_id",
        " struct trace_ctx *trace"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "CTX_ACT_OK"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "static __always_inline int ipv4_host_policy_ingress (struct  __ctx_buff *ctx, __u32 *src_id, struct trace_ctx *trace)\n",
        "{\n",
        "    struct ct_state ct_state_new = {}, ct_state = {};\n",
        "    int ret, verdict, l4_off, l3_off = ETH_HLEN;\n",
        "    __u8 policy_match_type = POLICY_MATCH_NONE;\n",
        "    __u8 audited = 0;\n",
        "    __u32 dst_id = WORLD_ID;\n",
        "    struct remote_endpoint_info *info;\n",
        "    struct ipv4_ct_tuple tuple = {}\n",
        "    ;\n",
        "    bool is_untracked_fragment = false;\n",
        "    void *data, *data_end;\n",
        "    struct iphdr *ip4;\n",
        "    if (!revalidate_data (ctx, &data, &data_end, &ip4))\n",
        "        return DROP_INVALID;\n",
        "    info = lookup_ip4_remote_endpoint (ip4 -> daddr);\n",
        "    if (info && info->sec_label)\n",
        "        dst_id = info->sec_label;\n",
        "    cilium_dbg (ctx, info ? DBG_IP_ID_MAP_SUCCEED4 : DBG_IP_ID_MAP_FAILED4, ip4->daddr, dst_id);\n",
        "    if (dst_id != HOST_ID)\n",
        "        return CTX_ACT_OK;\n",
        "    tuple.nexthdr = ip4->protocol;\n",
        "    tuple.daddr = ip4->daddr;\n",
        "    tuple.saddr = ip4->saddr;\n",
        "    l4_off = l3_off + ipv4_hdrlen (ip4);\n",
        "\n",
        "#  ifndef ENABLE_IPV4_FRAGMENTS\n",
        "    is_untracked_fragment = ipv4_is_fragment (ip4);\n",
        "\n",
        "#  endif\n",
        "    ret = ct_lookup4 (get_ct_map4 (& tuple), & tuple, ctx, l4_off, CT_INGRESS, & ct_state, & trace -> monitor);\n",
        "    if (ret < 0)\n",
        "        return ret;\n",
        "    trace->reason = (enum trace_reason) ret;\n",
        "    info = lookup_ip4_remote_endpoint (ip4 -> saddr);\n",
        "    if (info && info->sec_label)\n",
        "        *src_id = info->sec_label;\n",
        "    cilium_dbg (ctx, info ? DBG_IP_ID_MAP_SUCCEED4 : DBG_IP_ID_MAP_FAILED4, ip4->saddr, *src_id);\n",
        "    verdict = policy_can_access_ingress (ctx, * src_id, dst_id, tuple.dport, tuple.nexthdr, is_untracked_fragment, & policy_match_type, & audited);\n",
        "    if (ret != CT_REPLY && ret != CT_RELATED && verdict < 0) {\n",
        "        send_policy_verdict_notify (ctx, *src_id, tuple.dport, tuple.nexthdr, POLICY_INGRESS, 0, verdict, policy_match_type, audited);\n",
        "        return verdict;\n",
        "    }\n",
        "    switch (ret) {\n",
        "    case CT_NEW :\n",
        "        send_policy_verdict_notify (ctx, *src_id, tuple.dport, tuple.nexthdr, POLICY_INGRESS, 0, verdict, policy_match_type, audited);\n",
        "        ct_state_new.src_sec_id = *src_id;\n",
        "        ct_state_new.node_port = ct_state.node_port;\n",
        "        ret = ct_create4 (get_ct_map4 (& tuple), & CT_MAP_ANY4, & tuple, ctx, CT_INGRESS, & ct_state_new, verdict > 0, false);\n",
        "        if (IS_ERR (ret))\n",
        "            return ret;\n",
        "    case CT_REOPENED :\n",
        "        send_policy_verdict_notify (ctx, *src_id, tuple.dport, tuple.nexthdr, POLICY_INGRESS, 0, verdict, policy_match_type, audited);\n",
        "    case CT_ESTABLISHED :\n",
        "    case CT_RELATED :\n",
        "    case CT_REPLY :\n",
        "        break;\n",
        "    default :\n",
        "        return DROP_UNKNOWN_CT;\n",
        "    }\n",
        "    ctx_change_type (ctx, PACKET_HOST);\n",
        "    return CTX_ACT_OK;\n",
        "}\n"
      ],
      "called_function_list": [
        "send_policy_verdict_notify",
        "ipv4_hdrlen",
        "ct_create4",
        "get_ct_map4",
        "policy_can_access_ingress",
        "ipv4_is_fragment",
        "ct_lookup4",
        "cilium_dbg"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ipv6_l3": [
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 18,
      "endLine": 38,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/l3.h",
      "funcName": "ipv6_l3",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */"
        },
        {
          "start_line": 2,
          "end_line": 2,
          "text": "/* Copyright Authors of Cilium */"
        },
        {
          "start_line": 28,
          "end_line": 28,
          "text": "/* Hoplimit was reached */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " int l3_off",
        " const __u8 *smac",
        " const __u8 *dmac",
        " __u8 direction"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "CTX_ACT_OK"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "static __always_inline int ipv6_l3 (struct  __ctx_buff *ctx, int l3_off, const __u8 *smac, const __u8 *dmac, __u8 direction)\n",
        "{\n",
        "    int ret;\n",
        "    ret = ipv6_dec_hoplimit (ctx, l3_off);\n",
        "    if (IS_ERR (ret))\n",
        "        return ret;\n",
        "    if (ret > 0) {\n",
        "        return icmp6_send_time_exceeded (ctx, l3_off, direction);\n",
        "    }\n",
        "    if (smac && eth_store_saddr (ctx, smac, 0) < 0)\n",
        "        return DROP_WRITE_ERROR;\n",
        "    if (dmac && eth_store_daddr (ctx, dmac, 0) < 0)\n",
        "        return DROP_WRITE_ERROR;\n",
        "    return CTX_ACT_OK;\n",
        "}\n"
      ],
      "called_function_list": [
        "icmp6_send_time_exceeded",
        "eth_store_daddr",
        "ipv6_dec_hoplimit",
        "eth_store_saddr"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ipv4_l3": [
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 41,
      "endLine": 56,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/l3.h",
      "funcName": "ipv4_l3",
      "developer_inline_comments": [
        {
          "start_line": 46,
          "end_line": 46,
          "text": "/* FIXME: Send ICMP TTL */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " int l3_off",
        " const __u8 *smac",
        " const __u8 *dmac",
        " struct iphdr *ip4"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "CTX_ACT_OK"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "static __always_inline int ipv4_l3 (struct  __ctx_buff *ctx, int l3_off, const __u8 *smac, const __u8 *dmac, struct iphdr *ip4)\n",
        "{\n",
        "    if (ipv4_dec_ttl (ctx, l3_off, ip4)) {\n",
        "        return DROP_INVALID;\n",
        "    }\n",
        "    if (smac && eth_store_saddr (ctx, smac, 0) < 0)\n",
        "        return DROP_WRITE_ERROR;\n",
        "    if (dmac && eth_store_daddr (ctx, dmac, 0) < 0)\n",
        "        return DROP_WRITE_ERROR;\n",
        "    return CTX_ACT_OK;\n",
        "}\n"
      ],
      "called_function_list": [
        "ipv4_dec_ttl",
        "eth_store_saddr",
        "eth_store_daddr"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ipv6_local_delivery": [
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 65,
      "endLine": 106,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/l3.h",
      "funcName": "ipv6_local_delivery",
      "developer_inline_comments": [
        {
          "start_line": 60,
          "end_line": 64,
          "text": "/* Performs IPv6 L2/L3 handling and delivers the packet to the destination pod\n * on the same node, either via the stack or via a redirect call.\n * Depending on the configuration, it may also enforce ingress policies for the\n * destination pod via a tail call.\n */"
        },
        {
          "start_line": 77,
          "end_line": 77,
          "text": "/* This will invalidate the size check */"
        },
        {
          "start_line": 83,
          "end_line": 87,
          "text": "/*\n\t * Special LXC case for updating egress forwarding metrics.\n\t * Note that the packet could still be dropped but it would show up\n\t * as an ingress drop counter in metrics.\n\t */"
        },
        {
          "start_line": 98,
          "end_line": 98,
          "text": "/* Jumps to destination pod's BPF program to enforce ingress policies. */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " int l3_off",
        " __u32 seclabel",
        " const struct endpoint_info *ep",
        " __u8 direction",
        " bool from_host __maybe_unused"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "CTX_ACT_OK",
        "tail_call",
        "redirect"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "static __always_inline int ipv6_local_delivery (struct  __ctx_buff *ctx, int l3_off, __u32 seclabel, const struct endpoint_info *ep, __u8 direction, bool from_host __maybe_unused)\n",
        "{\n",
        "    mac_t router_mac = ep->node_mac;\n",
        "    mac_t lxc_mac = ep->mac;\n",
        "    int ret;\n",
        "    cilium_dbg (ctx, DBG_LOCAL_DELIVERY, ep->lxc_id, seclabel);\n",
        "    ret = ipv6_l3 (ctx, l3_off, (__u8 *) & router_mac, (__u8 *) & lxc_mac, direction);\n",
        "    if (ret != CTX_ACT_OK)\n",
        "        return ret;\n",
        "\n",
        "#ifdef LOCAL_DELIVERY_METRICS\n",
        "    update_metrics (ctx_full_len (ctx), direction, REASON_FORWARDED);\n",
        "\n",
        "#endif\n",
        "\n",
        "#if defined(USE_BPF_PROG_FOR_INGRESS_POLICY) && \\\n",
        "\t!defined(FORCE_LOCAL_POLICY_EVAL_AT_SOURCE)\n",
        "    ctx->mark |= MARK_MAGIC_IDENTITY;\n",
        "    set_identity_mark (ctx, seclabel);\n",
        "    return redirect_ep (ctx, ep->ifindex, from_host);\n",
        "\n",
        "#else\n",
        "    ctx_store_meta (ctx, CB_SRC_LABEL, seclabel);\n",
        "    ctx_store_meta (ctx, CB_IFINDEX, ep->ifindex);\n",
        "    ctx_store_meta (ctx, CB_FROM_HOST, from_host ? 1 : 0);\n",
        "    tail_call_dynamic (ctx, &POLICY_CALL_MAP, ep->lxc_id);\n",
        "    return DROP_MISSED_TAIL_CALL;\n",
        "\n",
        "#endif\n",
        "}\n"
      ],
      "called_function_list": [
        "set_identity_mark",
        "ctx_store_meta",
        "ipv6_l3",
        "tail_call_dynamic",
        "ctx_full_len",
        "redirect_ep",
        "cilium_dbg",
        "update_metrics"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ipv4_local_delivery": [
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 114,
      "endLine": 154,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/l3.h",
      "funcName": "ipv4_local_delivery",
      "developer_inline_comments": [
        {
          "start_line": 109,
          "end_line": 113,
          "text": "/* Performs IPv4 L2/L3 handling and delivers the packet to the destination pod\n * on the same node, either via the stack or via a redirect call.\n * Depending on the configuration, it may also enforce ingress policies for the\n * destination pod via a tail call.\n */"
        },
        {
          "start_line": 131,
          "end_line": 135,
          "text": "/*\n\t * Special LXC case for updating egress forwarding metrics.\n\t * Note that the packet could still be dropped but it would show up\n\t * as an ingress drop counter in metrics.\n\t */"
        },
        {
          "start_line": 146,
          "end_line": 146,
          "text": "/* Jumps to destination pod's BPF program to enforce ingress policies. */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " int l3_off",
        " __u32 seclabel",
        " struct iphdr *ip4",
        " const struct endpoint_info *ep",
        " __u8 direction __maybe_unused",
        " bool from_host __maybe_unused"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "CTX_ACT_OK",
        "tail_call",
        "redirect"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "static __always_inline int ipv4_local_delivery (struct  __ctx_buff *ctx, int l3_off, __u32 seclabel, struct iphdr *ip4, const struct endpoint_info *ep, __u8 direction __maybe_unused, bool from_host __maybe_unused)\n",
        "{\n",
        "    mac_t router_mac = ep->node_mac;\n",
        "    mac_t lxc_mac = ep->mac;\n",
        "    int ret;\n",
        "    cilium_dbg (ctx, DBG_LOCAL_DELIVERY, ep->lxc_id, seclabel);\n",
        "    ret = ipv4_l3 (ctx, l3_off, (__u8 *) & router_mac, (__u8 *) & lxc_mac, ip4);\n",
        "    if (ret != CTX_ACT_OK)\n",
        "        return ret;\n",
        "\n",
        "#ifdef LOCAL_DELIVERY_METRICS\n",
        "    update_metrics (ctx_full_len (ctx), direction, REASON_FORWARDED);\n",
        "\n",
        "#endif\n",
        "\n",
        "#if defined(USE_BPF_PROG_FOR_INGRESS_POLICY) && \\\n",
        "\t!defined(FORCE_LOCAL_POLICY_EVAL_AT_SOURCE)\n",
        "    ctx->mark |= MARK_MAGIC_IDENTITY;\n",
        "    set_identity_mark (ctx, seclabel);\n",
        "    return redirect_ep (ctx, ep->ifindex, from_host);\n",
        "\n",
        "#else\n",
        "    ctx_store_meta (ctx, CB_SRC_LABEL, seclabel);\n",
        "    ctx_store_meta (ctx, CB_IFINDEX, ep->ifindex);\n",
        "    ctx_store_meta (ctx, CB_FROM_HOST, from_host ? 1 : 0);\n",
        "    tail_call_dynamic (ctx, &POLICY_CALL_MAP, ep->lxc_id);\n",
        "    return DROP_MISSED_TAIL_CALL;\n",
        "\n",
        "#endif\n",
        "}\n"
      ],
      "called_function_list": [
        "set_identity_mark",
        "ctx_store_meta",
        "tail_call_dynamic",
        "ipv4_l3",
        "ctx_full_len",
        "redirect_ep",
        "cilium_dbg",
        "update_metrics"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "get_min_encrypt_key": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 157,
      "endLine": 185,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/l3.h",
      "funcName": "get_min_encrypt_key",
      "developer_inline_comments": [
        {
          "start_line": 165,
          "end_line": 165,
          "text": "/* Having no key info for a context is the same as no encryption */"
        },
        {
          "start_line": 169,
          "end_line": 176,
          "text": "/* If both ends can encrypt/decrypt use smaller of the two this\n\t * way both ends will have keys installed assuming key IDs are\n\t * always increasing. However, we have to handle roll-over case\n\t * and to do this safely we assume keys are no more than one ahead.\n\t * We expect user/control-place to accomplish this. Notice zero\n\t * will always be returned if either local or peer have the zero\n\t * key indicating no encryption.\n\t */"
        },
        {
          "start_line": 184,
          "end_line": 184,
          "text": "/* ENABLE_IPSEC */"
        }
      ],
      "updateMaps": [],
      "readMaps": [
        "  ENCRYPT_MAP"
      ],
      "input": [
        "__u8 peer_key __maybe_unused"
      ],
      "output": "static__always_inline__u8",
      "helper": [
        "map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __u8 get_min_encrypt_key (__u8 peer_key __maybe_unused)\n",
        "{\n",
        "\n",
        "#ifdef ENABLE_IPSEC\n",
        "    __u8 local_key = 0;\n",
        "    __u32 encrypt_key = 0;\n",
        "    struct encrypt_config *cfg;\n",
        "    cfg = map_lookup_elem (& ENCRYPT_MAP, & encrypt_key);\n",
        "    if (cfg)\n",
        "        local_key = cfg->encrypt_key;\n",
        "    if (peer_key == MAX_KEY_INDEX)\n",
        "        return local_key == 1 ? peer_key : local_key;\n",
        "    if (local_key == MAX_KEY_INDEX)\n",
        "        return peer_key == 1 ? local_key : peer_key;\n",
        "    return local_key < peer_key ? local_key : peer_key;\n",
        "\n",
        "#else\n",
        "    return 0;\n",
        "\n",
        "#endif /* ENABLE_IPSEC */\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "send_signal": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 36,
      "endLine": 41,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/signal.h",
      "funcName": "send_signal",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */"
        },
        {
          "start_line": 2,
          "end_line": 2,
          "text": "/* Copyright Authors of Cilium */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " struct signal_msg *msg"
      ],
      "output": "static__always_inlinevoid",
      "helper": [
        "send_signal"
      ],
      "compatibleHookpoints": [
        "perf_event",
        "raw_tracepoint_writable",
        "kprobe",
        "tracepoint",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void send_signal (struct  __ctx_buff *ctx, struct signal_msg *msg)\n",
        "{\n",
        "    ctx_event_output (ctx, &SIGNAL_MAP, BPF_F_CURRENT_CPU, msg, sizeof (*msg));\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "send_signal_nat_fill_up": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 43,
      "endLine": 52,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/signal.h",
      "funcName": "send_signal_nat_fill_up",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " __u32 proto"
      ],
      "output": "static__always_inlinevoid",
      "helper": [
        "send_signal"
      ],
      "compatibleHookpoints": [
        "perf_event",
        "raw_tracepoint_writable",
        "kprobe",
        "tracepoint",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void send_signal_nat_fill_up (struct  __ctx_buff *ctx, __u32 proto)\n",
        "{\n",
        "    struct signal_msg msg = {\n",
        "        .signal_nr = SIGNAL_NAT_FILL_UP,\n",
        "        .proto = proto,}\n",
        "    ;\n",
        "    send_signal (ctx, &msg);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "send_signal_ct_fill_up": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 54,
      "endLine": 63,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/signal.h",
      "funcName": "send_signal_ct_fill_up",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " __u32 proto"
      ],
      "output": "static__always_inlinevoid",
      "helper": [
        "send_signal"
      ],
      "compatibleHookpoints": [
        "perf_event",
        "raw_tracepoint_writable",
        "kprobe",
        "tracepoint",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void send_signal_ct_fill_up (struct  __ctx_buff *ctx, __u32 proto)\n",
        "{\n",
        "    struct signal_msg msg = {\n",
        "        .signal_nr = SIGNAL_CT_FILL_UP,\n",
        "        .proto = proto,}\n",
        "    ;\n",
        "    send_signal (ctx, &msg);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ct_entry_seen_both_syns": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 26,
      "endLine": 32,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h",
      "funcName": "ct_entry_seen_both_syns",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */"
        },
        {
          "start_line": 2,
          "end_line": 2,
          "text": "/* Copyright Authors of Cilium */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct ct_entry *entry"
      ],
      "output": "static__always_inlinebool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline bool ct_entry_seen_both_syns (const struct ct_entry *entry)\n",
        "{\n",
        "    bool rx_syn = entry->rx_flags_seen & TCP_FLAG_SYN;\n",
        "    bool tx_syn = entry->tx_flags_seen & TCP_FLAG_SYN;\n",
        "    return rx_syn && tx_syn;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__ct_update_timeout": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 62,
      "endLine": 126,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h",
      "funcName": "__ct_update_timeout",
      "developer_inline_comments": [
        {
          "start_line": 43,
          "end_line": 61,
          "text": "/**\n * Update the CT timeout and TCP flags for the specified entry.\n *\n * We track the OR'd accumulation of seen tcp flags in the entry, and the\n * last time that a notification was sent. Multiple CPUs may enter this\n * function with packets for the same connection, in which case it is possible\n * for the CPUs to race to update the entry. In such a case, the critical\n * update section may be entered in quick succession, leading to multiple\n * updates of the entry and returning true for each CPU. The BPF architecture\n * guarantees that entire 8-bit or 32-bit values will be set within the entry,\n * so although the CPUs may race, the worst result is that multiple executions\n * of this function return non-zero for the same connection within short\n * succession, leading to multiple trace notifications being sent when one\n * might otherwise expect such notifications to be aggregated.\n *\n * Returns how many bytes of the packet should be monitored:\n * - Zero if this flow was recently monitored.\n * - Non-zero if this flow has not been monitored recently.\n */"
        },
        {
          "start_line": 83,
          "end_line": 112,
          "text": "/* It's possible for multiple CPUs to execute the branch statement here\n\t * one after another, before the first CPU is able to execute the entry\n\t * modifications within this branch. This is somewhat unlikely because\n\t * packets for the same connection are typically steered towards the\n\t * same CPU, but is possible in theory.\n\t *\n\t * If the branch is taken by multiple CPUs because of '*last_report',\n\t * then this merely causes multiple notifications to be sent after\n\t * CT_REPORT_INTERVAL rather than a single notification. '*last_report'\n\t * will be updated by all CPUs and subsequent checks should not take\n\t * this branch until the next CT_REPORT_INTERVAL. As such, the trace\n\t * aggregation that uses the result of this function may reduce the\n\t * number of packets per interval to a small integer value (max N_CPUS)\n\t * rather than 1 notification per packet throughout the interval.\n\t *\n\t * Similar behaviour may happen with tcp_flags. The worst case race\n\t * here would be that two or more CPUs argue over which flags have been\n\t * seen and overwrite each other, with each CPU interleaving different\n\t * values for which flags were seen. In practice, realistic connections\n\t * are likely to progressively set SYN, ACK, then much later perhaps\n\t * FIN and/or RST. Furthermore, unless such a traffic pattern were\n\t * constantly received, this should self-correct as the stored\n\t * tcp_flags is an OR'd set of flags and each time the above code is\n\t * executed, it pulls the latest set of accumulated flags. Therefore\n\t * even in the worst case such a conflict is likely only to cause a\n\t * small number of additional notifications, which is still likely to\n\t * be significantly less under this MONITOR_AGGREGATION mode than would\n\t * otherwise be sent if the MONITOR_AGGREGATION level is set to none\n\t * (ie, sending a notification for every packet).\n\t */"
        },
        {
          "start_line": 115,
          "end_line": 115,
          "text": "/* verifier workaround: we don't use reference here. */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct ct_entry *entry",
        " __u32 lifetime",
        " int dir",
        " union tcp_flags flags",
        " __u8 report_mask"
      ],
      "output": "static__always_inline__u32",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __u32 __ct_update_timeout (struct ct_entry *entry, __u32 lifetime, int dir, union tcp_flags flags, __u8 report_mask)\n",
        "{\n",
        "    __u32 now = bpf_mono_now ();\n",
        "    __u8 accumulated_flags;\n",
        "    __u8 seen_flags = flags.lower_bits & report_mask;\n",
        "    __u32 last_report;\n",
        "    WRITE_ONCE (entry->lifetime, now + lifetime);\n",
        "    if (dir == CT_INGRESS) {\n",
        "        accumulated_flags = READ_ONCE (entry -> rx_flags_seen);\n",
        "        last_report = READ_ONCE (entry -> last_rx_report);\n",
        "    }\n",
        "    else {\n",
        "        accumulated_flags = READ_ONCE (entry -> tx_flags_seen);\n",
        "        last_report = READ_ONCE (entry -> last_tx_report);\n",
        "    }\n",
        "    seen_flags |= accumulated_flags;\n",
        "    if (last_report + bpf_sec_to_mono (CT_REPORT_INTERVAL) < now || accumulated_flags != seen_flags) {\n",
        "        if (dir == CT_INGRESS) {\n",
        "            WRITE_ONCE (entry->rx_flags_seen, seen_flags);\n",
        "            WRITE_ONCE (entry->last_rx_report, now);\n",
        "        }\n",
        "        else {\n",
        "            WRITE_ONCE (entry->tx_flags_seen, seen_flags);\n",
        "            WRITE_ONCE (entry->last_tx_report, now);\n",
        "        }\n",
        "        return TRACE_PAYLOAD_LEN;\n",
        "    }\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ct_update_timeout": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 134,
      "endLine": 156,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h",
      "funcName": "ct_update_timeout",
      "developer_inline_comments": [
        {
          "start_line": 128,
          "end_line": 133,
          "text": "/**\n * Update the CT timeouts for the specified entry.\n *\n * If CT_REPORT_INTERVAL has elapsed since the last update, updates the\n * last_updated timestamp and returns true. Otherwise returns false.\n */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct ct_entry *entry",
        " bool tcp",
        " int dir",
        " union tcp_flags seen_flags"
      ],
      "output": "static__always_inline__u32",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __u32 ct_update_timeout (struct ct_entry *entry, bool tcp, int dir, union tcp_flags seen_flags)\n",
        "{\n",
        "    __u32 lifetime = dir == CT_SERVICE ? bpf_sec_to_mono (CT_SERVICE_LIFETIME_NONTCP) : bpf_sec_to_mono (CT_CONNECTION_LIFETIME_NONTCP);\n",
        "    bool syn = seen_flags.value & TCP_FLAG_SYN;\n",
        "    if (tcp) {\n",
        "        entry->seen_non_syn |= !syn;\n",
        "        if (entry->seen_non_syn) {\n",
        "            lifetime = dir == CT_SERVICE ? bpf_sec_to_mono (CT_SERVICE_LIFETIME_TCP) : bpf_sec_to_mono (CT_CONNECTION_LIFETIME_TCP);\n",
        "        }\n",
        "        else {\n",
        "            lifetime = bpf_sec_to_mono (CT_SYN_TIMEOUT);\n",
        "        }\n",
        "    }\n",
        "    return __ct_update_timeout (entry, lifetime, dir, seen_flags, CT_REPORT_FLAGS);\n",
        "}\n"
      ],
      "called_function_list": [
        "__ct_update_timeout"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ct_reset_closing": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 158,
      "endLine": 162,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h",
      "funcName": "ct_reset_closing",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct ct_entry *entry"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void ct_reset_closing (struct ct_entry *entry)\n",
        "{\n",
        "    entry->rx_closing = 0;\n",
        "    entry->tx_closing = 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ct_entry_alive": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 164,
      "endLine": 167,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h",
      "funcName": "ct_entry_alive",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct ct_entry *entry"
      ],
      "output": "static__always_inlinebool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline bool ct_entry_alive (const struct ct_entry *entry)\n",
        "{\n",
        "    return !entry->rx_closing || !entry->tx_closing;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ct_entry_closing": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 169,
      "endLine": 172,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h",
      "funcName": "ct_entry_closing",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct ct_entry *entry"
      ],
      "output": "static__always_inlinebool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline bool ct_entry_closing (const struct ct_entry *entry)\n",
        "{\n",
        "    return entry->tx_closing || entry->rx_closing;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ct_entry_expired_rebalance": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 174,
      "endLine": 183,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h",
      "funcName": "ct_entry_expired_rebalance",
      "developer_inline_comments": [
        {
          "start_line": 179,
          "end_line": 181,
          "text": "/* This doesn't check last_rx_report because we don't see closing\n\t * in RX direction for CT_SERVICE.\n\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct ct_entry *entry"
      ],
      "output": "static__always_inlinebool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline bool ct_entry_expired_rebalance (const struct ct_entry *entry)\n",
        "{\n",
        "    __u32 wait_time = bpf_sec_to_mono (CT_SERVICE_CLOSE_REBALANCE);\n",
        "    return READ_ONCE (entry->last_tx_report) + wait_time <= bpf_mono_now ();\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__ct_lookup": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 185,
      "endLine": 273,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h",
      "funcName": "__ct_lookup",
      "developer_inline_comments": [
        {
          "start_line": 222,
          "end_line": 222,
          "text": "/* FIXME: This is slow, per-cpu counters? */"
        },
        {
          "start_line": 243,
          "end_line": 247,
          "text": "/* If we got an RST and have not seen both SYNs,\n\t\t\t * terminate the connection. (For CT_SERVICE, we do not\n\t\t\t * see both directions, so flags of established\n\t\t\t * connections would not include both SYNs.)\n\t\t\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [
        " map"
      ],
      "input": [
        "const void *map",
        " struct  __ctx_buff *ctx",
        " const void *tuple",
        " int action",
        " int dir",
        " struct ct_state *ct_state",
        " bool is_tcp",
        " union tcp_flags seen_flags",
        " __u32 *monitor"
      ],
      "output": "static__always_inline__u8",
      "helper": [
        "map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __u8 __ct_lookup (const void *map, struct  __ctx_buff *ctx, const void *tuple, int action, int dir, struct ct_state *ct_state, bool is_tcp, union tcp_flags seen_flags, __u32 *monitor)\n",
        "{\n",
        "    bool syn = seen_flags.value & TCP_FLAG_SYN;\n",
        "    struct ct_entry *entry;\n",
        "    int reopen;\n",
        "    relax_verifier ();\n",
        "    entry = map_lookup_elem (map, tuple);\n",
        "    if (entry) {\n",
        "        cilium_dbg (ctx, DBG_CT_MATCH, entry->lifetime, entry->rev_nat_index);\n",
        "\n",
        "#ifdef HAVE_LARGE_INSN_LIMIT\n",
        "        if (dir == CT_SERVICE && syn && ct_entry_closing (entry) && ct_entry_expired_rebalance (entry))\n",
        "            goto ct_new;\n",
        "\n",
        "#endif\n",
        "        if (ct_entry_alive (entry))\n",
        "            *monitor = ct_update_timeout (entry, is_tcp, dir, seen_flags);\n",
        "        if (ct_state) {\n",
        "            ct_state->rev_nat_index = entry->rev_nat_index;\n",
        "            ct_state->loopback = entry->lb_loopback;\n",
        "            ct_state->node_port = entry->node_port;\n",
        "            ct_state->ifindex = entry->ifindex;\n",
        "            ct_state->dsr = entry->dsr;\n",
        "            ct_state->proxy_redirect = entry->proxy_redirect;\n",
        "            ct_state->from_l7lb = entry->from_l7lb;\n",
        "            if (dir == CT_SERVICE) {\n",
        "                ct_state->backend_id = entry->backend_id;\n",
        "                ct_state->syn = syn;\n",
        "            }\n",
        "        }\n",
        "\n",
        "#ifdef CONNTRACK_ACCOUNTING\n",
        "        if (dir == CT_INGRESS) {\n",
        "            __sync_fetch_and_add (&entry->rx_packets, 1);\n",
        "            __sync_fetch_and_add (&entry->rx_bytes, ctx_full_len (ctx));\n",
        "        }\n",
        "        else if (dir == CT_EGRESS) {\n",
        "            __sync_fetch_and_add (&entry->tx_packets, 1);\n",
        "            __sync_fetch_and_add (&entry->tx_bytes, ctx_full_len (ctx));\n",
        "        }\n",
        "\n",
        "#endif\n",
        "        switch (action) {\n",
        "        case ACTION_CREATE :\n",
        "            reopen = entry->rx_closing | entry->tx_closing;\n",
        "            reopen |= seen_flags.value & TCP_FLAG_SYN;\n",
        "            if (unlikely (reopen == (TCP_FLAG_SYN | 0x1))) {\n",
        "                ct_reset_closing (entry);\n",
        "                *monitor = ct_update_timeout (entry, is_tcp, dir, seen_flags);\n",
        "                return CT_REOPENED;\n",
        "            }\n",
        "            break;\n",
        "        case ACTION_CLOSE :\n",
        "            if (!ct_entry_seen_both_syns (entry) && (seen_flags.value & TCP_FLAG_RST) && dir != CT_SERVICE) {\n",
        "                entry->rx_closing = 1;\n",
        "                entry->tx_closing = 1;\n",
        "            }\n",
        "            else if (dir == CT_INGRESS) {\n",
        "                entry->rx_closing = 1;\n",
        "            }\n",
        "            else {\n",
        "                entry->tx_closing = 1;\n",
        "            }\n",
        "            *monitor = TRACE_PAYLOAD_LEN;\n",
        "            if (ct_entry_alive (entry))\n",
        "                break;\n",
        "            __ct_update_timeout (entry, bpf_sec_to_mono (CT_CLOSE_TIMEOUT), dir, seen_flags, CT_REPORT_FLAGS);\n",
        "            break;\n",
        "        }\n",
        "        return CT_ESTABLISHED;\n",
        "    }\n",
        "ct_new :\n",
        "    __maybe_unused * monitor = TRACE_PAYLOAD_LEN;\n",
        "    return CT_NEW;\n",
        "}\n"
      ],
      "called_function_list": [
        "ct_entry_closing",
        "ct_entry_seen_both_syns",
        "ct_entry_expired_rebalance",
        "ct_reset_closing",
        "ct_update_timeout",
        "ct_entry_alive",
        "relax_verifier",
        "ctx_full_len",
        "cilium_dbg",
        "__ct_update_timeout"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ipv6_extract_tuple": [
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 275,
      "endLine": 303,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h",
      "funcName": "ipv6_extract_tuple",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " struct ipv6_ct_tuple *tuple",
        " int *l4_off"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "CTX_ACT_OK"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "static __always_inline int ipv6_extract_tuple (struct  __ctx_buff *ctx, struct ipv6_ct_tuple *tuple, int *l4_off)\n",
        "{\n",
        "    int ret, l3_off = ETH_HLEN;\n",
        "    void *data, *data_end;\n",
        "    struct ipv6hdr *ip6;\n",
        "    if (!revalidate_data (ctx, &data, &data_end, &ip6))\n",
        "        return DROP_INVALID;\n",
        "    tuple->nexthdr = ip6->nexthdr;\n",
        "    ipv6_addr_copy (&tuple->daddr, (union v6addr *) &ip6->daddr);\n",
        "    ipv6_addr_copy (&tuple->saddr, (union v6addr *) &ip6->saddr);\n",
        "    ret = ipv6_hdrlen (ctx, & tuple -> nexthdr);\n",
        "    if (ret < 0)\n",
        "        return ret;\n",
        "    if (unlikely (tuple->nexthdr != IPPROTO_TCP && tuple->nexthdr != IPPROTO_UDP))\n",
        "        return DROP_CT_UNKNOWN_PROTO;\n",
        "    if (ret < 0)\n",
        "        return ret;\n",
        "    *l4_off = l3_off + ret;\n",
        "    return CTX_ACT_OK;\n",
        "}\n"
      ],
      "called_function_list": [
        "ipv6_addr_copy",
        "ipv6_hdrlen"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ct_flip_tuple_dir6": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 305,
      "endLine": 311,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h",
      "funcName": "ct_flip_tuple_dir6",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct ipv6_ct_tuple *tuple"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void ct_flip_tuple_dir6 (struct ipv6_ct_tuple *tuple)\n",
        "{\n",
        "    if (tuple->flags & TUPLE_F_IN)\n",
        "        tuple->flags &= ~TUPLE_F_IN;\n",
        "    else\n",
        "        tuple->flags |= TUPLE_F_IN;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__ipv6_ct_tuple_reverse": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 313,
      "endLine": 326,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h",
      "funcName": "__ipv6_ct_tuple_reverse",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct ipv6_ct_tuple *tuple"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void __ipv6_ct_tuple_reverse (struct ipv6_ct_tuple *tuple)\n",
        "{\n",
        "    union v6addr tmp_addr = {}\n",
        "    ;\n",
        "    __be16 tmp;\n",
        "    ipv6_addr_copy (&tmp_addr, &tuple->saddr);\n",
        "    ipv6_addr_copy (&tuple->saddr, &tuple->daddr);\n",
        "    ipv6_addr_copy (&tuple->daddr, &tmp_addr);\n",
        "    tmp = tuple->sport;\n",
        "    tuple->sport = tuple->dport;\n",
        "    tuple->dport = tmp;\n",
        "}\n"
      ],
      "called_function_list": [
        "ipv6_addr_copy"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ipv6_ct_tuple_reverse": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 328,
      "endLine": 333,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h",
      "funcName": "ipv6_ct_tuple_reverse",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct ipv6_ct_tuple *tuple"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void ipv6_ct_tuple_reverse (struct ipv6_ct_tuple *tuple)\n",
        "{\n",
        "    __ipv6_ct_tuple_reverse (tuple);\n",
        "    ct_flip_tuple_dir6 (tuple);\n",
        "}\n"
      ],
      "called_function_list": [
        "ct_flip_tuple_dir6",
        "__ipv6_ct_tuple_reverse"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ct_lookup6": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 336,
      "endLine": 459,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h",
      "funcName": "ct_lookup6",
      "developer_inline_comments": [
        {
          "start_line": 335,
          "end_line": 335,
          "text": "/* Offset must point to IPv6 */"
        },
        {
          "start_line": 346,
          "end_line": 352,
          "text": "/* The tuple is created in reverse order initially to find a\n\t * potential reverse flow. This is required because the RELATED\n\t * or REPLY state takes precedence over ESTABLISHED due to\n\t * policy requirements.\n\t *\n\t * tuple->flags separates entries that could otherwise be overlapping.\n\t */"
        },
        {
          "start_line": 393,
          "end_line": 393,
          "text": "/* fall through */"
        },
        {
          "start_line": 412,
          "end_line": 412,
          "text": "/* load sport + dport into tuple */"
        },
        {
          "start_line": 418,
          "end_line": 418,
          "text": "/* load sport + dport into tuple */"
        },
        {
          "start_line": 426,
          "end_line": 426,
          "text": "/* Can't handle extension headers yet */"
        },
        {
          "start_line": 430,
          "end_line": 434,
          "text": "/* Lookup the reverse direction\n\t *\n\t * This will find an existing flow in the reverse direction.\n\t * The reverse direction is the one where reverse nat index is stored.\n\t */"
        },
        {
          "start_line": 450,
          "end_line": 450,
          "text": "/* Lookup entry in forward direction */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const void *map",
        " struct ipv6_ct_tuple *tuple",
        " struct  __ctx_buff *ctx",
        " int l4_off",
        " int dir",
        " struct ct_state *ct_state",
        " __u32 *monitor"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int ct_lookup6 (const void *map, struct ipv6_ct_tuple *tuple, struct  __ctx_buff *ctx, int l4_off, int dir, struct ct_state *ct_state, __u32 *monitor)\n",
        "{\n",
        "    int ret = CT_NEW, action = ACTION_UNSPEC;\n",
        "    bool is_tcp = tuple->nexthdr == IPPROTO_TCP;\n",
        "    union tcp_flags tcp_flags = {\n",
        "        .value = 0}\n",
        "    ;\n",
        "    if (dir == CT_INGRESS)\n",
        "        tuple->flags = TUPLE_F_OUT;\n",
        "    else if (dir == CT_EGRESS)\n",
        "        tuple->flags = TUPLE_F_IN;\n",
        "    else if (dir == CT_SERVICE)\n",
        "        tuple->flags = TUPLE_F_SERVICE;\n",
        "    else\n",
        "        return DROP_CT_INVALID_HDR;\n",
        "    switch (tuple->nexthdr) {\n",
        "    case IPPROTO_ICMPV6 :\n",
        "        if (1) {\n",
        "            __be16 identifier = 0;\n",
        "            __u8 type;\n",
        "            if (ctx_load_bytes (ctx, l4_off, &type, 1) < 0)\n",
        "                return DROP_CT_INVALID_HDR;\n",
        "            if ((type == ICMPV6_ECHO_REQUEST || type == ICMPV6_ECHO_REPLY) && ctx_load_bytes (ctx, l4_off + offsetof (struct icmp6hdr, icmp6_dataun.u_echo.identifier), &identifier, 2) < 0)\n",
        "                return DROP_CT_INVALID_HDR;\n",
        "            tuple->sport = 0;\n",
        "            tuple->dport = 0;\n",
        "            switch (type) {\n",
        "            case ICMPV6_DEST_UNREACH :\n",
        "            case ICMPV6_PKT_TOOBIG :\n",
        "            case ICMPV6_TIME_EXCEED :\n",
        "            case ICMPV6_PARAMPROB :\n",
        "                tuple->flags |= TUPLE_F_RELATED;\n",
        "                break;\n",
        "            case ICMPV6_ECHO_REPLY :\n",
        "                tuple->sport = identifier;\n",
        "                break;\n",
        "            case ICMPV6_ECHO_REQUEST :\n",
        "                tuple->dport = identifier;\n",
        "            default :\n",
        "                action = ACTION_CREATE;\n",
        "                break;\n",
        "            }\n",
        "        }\n",
        "        break;\n",
        "    case IPPROTO_TCP :\n",
        "        if (1) {\n",
        "            if (ctx_load_bytes (ctx, l4_off + 12, &tcp_flags, 2) < 0)\n",
        "                return DROP_CT_INVALID_HDR;\n",
        "            if (unlikely (tcp_flags.value & (TCP_FLAG_RST | TCP_FLAG_FIN)))\n",
        "                action = ACTION_CLOSE;\n",
        "            else\n",
        "                action = ACTION_CREATE;\n",
        "        }\n",
        "        if (ctx_load_bytes (ctx, l4_off, &tuple->dport, 4) < 0)\n",
        "            return DROP_CT_INVALID_HDR;\n",
        "        break;\n",
        "    case IPPROTO_UDP :\n",
        "        if (ctx_load_bytes (ctx, l4_off, &tuple->dport, 4) < 0)\n",
        "            return DROP_CT_INVALID_HDR;\n",
        "        action = ACTION_CREATE;\n",
        "        break;\n",
        "    default :\n",
        "        return DROP_CT_UNKNOWN_PROTO;\n",
        "    }\n",
        "    cilium_dbg3 (ctx, DBG_CT_LOOKUP6_1, (__u32) tuple->saddr.p4, (__u32) tuple->daddr.p4, (bpf_ntohs (tuple->sport) << 16) | bpf_ntohs (tuple->dport));\n",
        "    cilium_dbg3 (ctx, DBG_CT_LOOKUP6_2, (tuple->nexthdr << 8) | tuple->flags, 0, 0);\n",
        "    ret = __ct_lookup (map, ctx, tuple, action, dir, ct_state, is_tcp, tcp_flags, monitor);\n",
        "    if (ret != CT_NEW) {\n",
        "        if (likely (ret == CT_ESTABLISHED || ret == CT_REOPENED)) {\n",
        "            if (unlikely (tuple->flags & TUPLE_F_RELATED))\n",
        "                ret = CT_RELATED;\n",
        "            else\n",
        "                ret = CT_REPLY;\n",
        "        }\n",
        "        goto out;\n",
        "    }\n",
        "    if (dir != CT_SERVICE) {\n",
        "        ipv6_ct_tuple_reverse (tuple);\n",
        "        ret = __ct_lookup (map, ctx, tuple, action, dir, ct_state, is_tcp, tcp_flags, monitor);\n",
        "    }\n",
        "out :\n",
        "    cilium_dbg (ctx, DBG_CT_VERDICT, ret < 0 ? -ret : ret, ct_state->rev_nat_index);\n",
        "    return ret;\n",
        "}\n"
      ],
      "called_function_list": [
        "cilium_dbg3",
        "__ct_lookup",
        "ipv6_ct_tuple_reverse",
        "cilium_dbg"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ipv4_extract_tuple": [
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 461,
      "endLine": 483,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h",
      "funcName": "ipv4_extract_tuple",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " struct ipv4_ct_tuple *tuple",
        " int *l4_off"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "CTX_ACT_OK"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "static __always_inline int ipv4_extract_tuple (struct  __ctx_buff *ctx, struct ipv4_ct_tuple *tuple, int *l4_off)\n",
        "{\n",
        "    int l3_off = ETH_HLEN;\n",
        "    void *data, *data_end;\n",
        "    struct iphdr *ip4;\n",
        "    if (!revalidate_data (ctx, &data, &data_end, &ip4))\n",
        "        return DROP_INVALID;\n",
        "    tuple->nexthdr = ip4->protocol;\n",
        "    if (unlikely (tuple->nexthdr != IPPROTO_TCP && tuple->nexthdr != IPPROTO_UDP))\n",
        "        return DROP_CT_UNKNOWN_PROTO;\n",
        "    tuple->daddr = ip4->daddr;\n",
        "    tuple->saddr = ip4->saddr;\n",
        "    *l4_off = l3_off + ipv4_hdrlen (ip4);\n",
        "    return CTX_ACT_OK;\n",
        "}\n"
      ],
      "called_function_list": [
        "ipv4_hdrlen"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ct_flip_tuple_dir4": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 485,
      "endLine": 491,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h",
      "funcName": "ct_flip_tuple_dir4",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct ipv4_ct_tuple *tuple"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void ct_flip_tuple_dir4 (struct ipv4_ct_tuple *tuple)\n",
        "{\n",
        "    if (tuple->flags & TUPLE_F_IN)\n",
        "        tuple->flags &= ~TUPLE_F_IN;\n",
        "    else\n",
        "        tuple->flags |= TUPLE_F_IN;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__ipv4_ct_tuple_reverse": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 493,
      "endLine": 505,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h",
      "funcName": "__ipv4_ct_tuple_reverse",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct ipv4_ct_tuple *tuple"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void __ipv4_ct_tuple_reverse (struct ipv4_ct_tuple *tuple)\n",
        "{\n",
        "    __be32 tmp_addr = tuple->saddr;\n",
        "    __be16 tmp;\n",
        "    tuple->saddr = tuple->daddr;\n",
        "    tuple->daddr = tmp_addr;\n",
        "    tmp = tuple->sport;\n",
        "    tuple->sport = tuple->dport;\n",
        "    tuple->dport = tmp;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ipv4_ct_tuple_reverse": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 507,
      "endLine": 512,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h",
      "funcName": "ipv4_ct_tuple_reverse",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct ipv4_ct_tuple *tuple"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void ipv4_ct_tuple_reverse (struct ipv4_ct_tuple *tuple)\n",
        "{\n",
        "    __ipv4_ct_tuple_reverse (tuple);\n",
        "    ct_flip_tuple_dir4 (tuple);\n",
        "}\n"
      ],
      "called_function_list": [
        "__ipv4_ct_tuple_reverse",
        "ct_flip_tuple_dir4"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ipv4_ct_extract_l4_ports": [
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 514,
      "endLine": 540,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h",
      "funcName": "ipv4_ct_extract_l4_ports",
      "developer_inline_comments": [
        {
          "start_line": 524,
          "end_line": 526,
          "text": "/* This function is called from ct_lookup4(), which is sometimes called\n\t * after data has been invalidated (see handle_ipv4_from_lxc())\n\t */"
        },
        {
          "start_line": 534,
          "end_line": 534,
          "text": "/* load sport + dport into tuple */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " int off",
        " enum ct_dir dir __maybe_unused",
        " struct ipv4_ct_tuple *tuple",
        " bool * has_l4_header __maybe_unused"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "CTX_ACT_OK"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "static __always_inline int ipv4_ct_extract_l4_ports (struct  __ctx_buff *ctx, int off, enum ct_dir dir __maybe_unused, struct ipv4_ct_tuple *tuple, bool * has_l4_header __maybe_unused)\n",
        "{\n",
        "\n",
        "#ifdef ENABLE_IPV4_FRAGMENTS\n",
        "    void *data, *data_end;\n",
        "    struct iphdr *ip4;\n",
        "    if (!revalidate_data (ctx, &data, &data_end, &ip4))\n",
        "        return DROP_CT_INVALID_HDR;\n",
        "    return ipv4_handle_fragmentation (ctx, ip4, off, dir, (struct ipv4_frag_l4ports *) &tuple->dport, has_l4_header);\n",
        "\n",
        "#else\n",
        "    if (ctx_load_bytes (ctx, off, &tuple->dport, 4) < 0)\n",
        "        return DROP_CT_INVALID_HDR;\n",
        "\n",
        "#endif\n",
        "    return CTX_ACT_OK;\n",
        "}\n"
      ],
      "called_function_list": [
        "ipv4_handle_fragmentation"
      ],
      "call_depth": 5,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ct4_cilium_dbg_tuple": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 542,
      "endLine": 549,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h",
      "funcName": "ct4_cilium_dbg_tuple",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " __u8 type",
        " const struct ipv4_ct_tuple *tuple",
        " __u32 rev_nat_index",
        " int dir"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void ct4_cilium_dbg_tuple (struct  __ctx_buff *ctx, __u8 type, const struct ipv4_ct_tuple *tuple, __u32 rev_nat_index, int dir)\n",
        "{\n",
        "    __be32 addr = (dir == CT_INGRESS) ? tuple->saddr : tuple->daddr;\n",
        "    cilium_dbg (ctx, type, addr, rev_nat_index);\n",
        "}\n"
      ],
      "called_function_list": [
        "cilium_dbg"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ct_extract_ports4": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 551,
      "endLine": 606,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h",
      "funcName": "ct_extract_ports4",
      "developer_inline_comments": [
        {
          "start_line": 585,
          "end_line": 585,
          "text": "/* fall through */"
        },
        {
          "start_line": 601,
          "end_line": 601,
          "text": "/* Can't handle extension headers yet */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " int off",
        " enum ct_dir dir",
        " struct ipv4_ct_tuple *tuple"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int ct_extract_ports4 (struct  __ctx_buff *ctx, int off, enum ct_dir dir, struct ipv4_ct_tuple *tuple)\n",
        "{\n",
        "    int err;\n",
        "    switch (tuple->nexthdr) {\n",
        "    case IPPROTO_ICMP :\n",
        "        if (1) {\n",
        "            __be16 identifier = 0;\n",
        "            __u8 type;\n",
        "            if (ctx_load_bytes (ctx, off, &type, 1) < 0)\n",
        "                return DROP_CT_INVALID_HDR;\n",
        "            if ((type == ICMP_ECHO || type == ICMP_ECHOREPLY) && ctx_load_bytes (ctx, off + offsetof (struct icmphdr, un.echo.id), &identifier, 2) < 0)\n",
        "                return DROP_CT_INVALID_HDR;\n",
        "            tuple->sport = 0;\n",
        "            tuple->dport = 0;\n",
        "            switch (type) {\n",
        "            case ICMP_DEST_UNREACH :\n",
        "            case ICMP_TIME_EXCEEDED :\n",
        "            case ICMP_PARAMETERPROB :\n",
        "                tuple->flags |= TUPLE_F_RELATED;\n",
        "                break;\n",
        "            case ICMP_ECHOREPLY :\n",
        "                tuple->sport = identifier;\n",
        "                break;\n",
        "            case ICMP_ECHO :\n",
        "                tuple->dport = identifier;\n",
        "            default :\n",
        "                break;\n",
        "            }\n",
        "        }\n",
        "        break;\n",
        "    case IPPROTO_TCP :\n",
        "    case IPPROTO_UDP :\n",
        "        err = ipv4_ct_extract_l4_ports (ctx, off, dir, tuple, NULL);\n",
        "        if (err < 0)\n",
        "            return err;\n",
        "        break;\n",
        "    default :\n",
        "        return DROP_CT_UNKNOWN_PROTO;\n",
        "    }\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "ipv4_ct_extract_l4_ports"
      ],
      "call_depth": 6,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ct_is_reply4": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 616,
      "endLine": 631,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h",
      "funcName": "ct_is_reply4",
      "developer_inline_comments": [
        {
          "start_line": 608,
          "end_line": 615,
          "text": "/* The function determines whether an egress flow identified by the given\n * tuple is a reply.\n *\n * The datapath creates a CT entry in a reverse order. E.g., if a pod sends a\n * request to outside, the CT entry stored in the BPF map will be TUPLE_F_IN:\n * pod => outside. So, we can leverage this fact to determine whether the given\n * flow is a reply.\n */"
        }
      ],
      "updateMaps": [],
      "readMaps": [
        " map"
      ],
      "input": [
        "const void *map",
        " struct  __ctx_buff *ctx",
        " int off",
        " struct ipv4_ct_tuple *tuple",
        " bool *is_reply"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int ct_is_reply4 (const void *map, struct  __ctx_buff *ctx, int off, struct ipv4_ct_tuple *tuple, bool *is_reply)\n",
        "{\n",
        "    int err = 0;\n",
        "    err = ct_extract_ports4 (ctx, off, CT_EGRESS, tuple);\n",
        "    if (err < 0)\n",
        "        return err;\n",
        "    tuple->flags = TUPLE_F_IN;\n",
        "    *is_reply = map_lookup_elem (map, tuple) != NULL;\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "ct_extract_ports4"
      ],
      "call_depth": 7,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ct_lookup4": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 634,
      "endLine": 757,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h",
      "funcName": "ct_lookup4",
      "developer_inline_comments": [
        {
          "start_line": 633,
          "end_line": 633,
          "text": "/* Offset must point to IPv4 header */"
        },
        {
          "start_line": 644,
          "end_line": 650,
          "text": "/* The tuple is created in reverse order initially to find a\n\t * potential reverse flow. This is required because the RELATED\n\t * or REPLY state takes precedence over ESTABLISHED due to\n\t * policy requirements.\n\t *\n\t * tuple->flags separates entries that could otherwise be overlapping.\n\t */"
        },
        {
          "start_line": 688,
          "end_line": 688,
          "text": "/* fall through */"
        },
        {
          "start_line": 721,
          "end_line": 721,
          "text": "/* Can't handle extension headers yet */"
        },
        {
          "start_line": 725,
          "end_line": 728,
          "text": "/* Lookup the reverse direction\n\t *\n\t * This will find an existing flow in the reverse direction.\n\t */"
        },
        {
          "start_line": 748,
          "end_line": 748,
          "text": "/* Lookup entry in forward direction */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const void *map",
        " struct ipv4_ct_tuple *tuple",
        " struct  __ctx_buff *ctx",
        " int off",
        " enum ct_dir dir",
        " struct ct_state *ct_state",
        " __u32 *monitor"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int ct_lookup4 (const void *map, struct ipv4_ct_tuple *tuple, struct  __ctx_buff *ctx, int off, enum ct_dir dir, struct ct_state *ct_state, __u32 *monitor)\n",
        "{\n",
        "    int err, ret = CT_NEW, action = ACTION_UNSPEC;\n",
        "    bool is_tcp = tuple->nexthdr == IPPROTO_TCP, has_l4_header = true;\n",
        "    union tcp_flags tcp_flags = {\n",
        "        .value = 0}\n",
        "    ;\n",
        "    if (dir == CT_INGRESS)\n",
        "        tuple->flags = TUPLE_F_OUT;\n",
        "    else if (dir == CT_EGRESS)\n",
        "        tuple->flags = TUPLE_F_IN;\n",
        "    else if (dir == CT_SERVICE)\n",
        "        tuple->flags = TUPLE_F_SERVICE;\n",
        "    else\n",
        "        return DROP_CT_INVALID_HDR;\n",
        "    switch (tuple->nexthdr) {\n",
        "    case IPPROTO_ICMP :\n",
        "        if (1) {\n",
        "            __be16 identifier = 0;\n",
        "            __u8 type;\n",
        "            if (ctx_load_bytes (ctx, off, &type, 1) < 0)\n",
        "                return DROP_CT_INVALID_HDR;\n",
        "            if ((type == ICMP_ECHO || type == ICMP_ECHOREPLY) && ctx_load_bytes (ctx, off + offsetof (struct icmphdr, un.echo.id), &identifier, 2) < 0)\n",
        "                return DROP_CT_INVALID_HDR;\n",
        "            tuple->sport = 0;\n",
        "            tuple->dport = 0;\n",
        "            switch (type) {\n",
        "            case ICMP_DEST_UNREACH :\n",
        "            case ICMP_TIME_EXCEEDED :\n",
        "            case ICMP_PARAMETERPROB :\n",
        "                tuple->flags |= TUPLE_F_RELATED;\n",
        "                break;\n",
        "            case ICMP_ECHOREPLY :\n",
        "                tuple->sport = identifier;\n",
        "                break;\n",
        "            case ICMP_ECHO :\n",
        "                tuple->dport = identifier;\n",
        "            default :\n",
        "                action = ACTION_CREATE;\n",
        "                break;\n",
        "            }\n",
        "        }\n",
        "        break;\n",
        "    case IPPROTO_TCP :\n",
        "        err = ipv4_ct_extract_l4_ports (ctx, off, dir, tuple, &has_l4_header);\n",
        "        if (err < 0)\n",
        "            return err;\n",
        "        action = ACTION_CREATE;\n",
        "        if (has_l4_header) {\n",
        "            if (ctx_load_bytes (ctx, off + 12, &tcp_flags, 2) < 0)\n",
        "                return DROP_CT_INVALID_HDR;\n",
        "            if (unlikely (tcp_flags.value & (TCP_FLAG_RST | TCP_FLAG_FIN)))\n",
        "                action = ACTION_CLOSE;\n",
        "        }\n",
        "        break;\n",
        "    case IPPROTO_UDP :\n",
        "        err = ipv4_ct_extract_l4_ports (ctx, off, dir, tuple, NULL);\n",
        "        if (err < 0)\n",
        "            return err;\n",
        "        action = ACTION_CREATE;\n",
        "        break;\n",
        "    default :\n",
        "        return DROP_CT_UNKNOWN_PROTO;\n",
        "    }\n",
        "\n",
        "#ifndef QUIET_CT\n",
        "    cilium_dbg3 (ctx, DBG_CT_LOOKUP4_1, tuple->saddr, tuple->daddr, (bpf_ntohs (tuple->sport) << 16) | bpf_ntohs (tuple->dport));\n",
        "    cilium_dbg3 (ctx, DBG_CT_LOOKUP4_2, (tuple->nexthdr << 8) | tuple->flags, 0, 0);\n",
        "\n",
        "#endif\n",
        "    ret = __ct_lookup (map, ctx, tuple, action, dir, ct_state, is_tcp, tcp_flags, monitor);\n",
        "    if (ret != CT_NEW) {\n",
        "        if (likely (ret == CT_ESTABLISHED || ret == CT_REOPENED)) {\n",
        "            if (unlikely (tuple->flags & TUPLE_F_RELATED))\n",
        "                ret = CT_RELATED;\n",
        "            else\n",
        "                ret = CT_REPLY;\n",
        "        }\n",
        "        goto out;\n",
        "    }\n",
        "    relax_verifier ();\n",
        "    if (dir != CT_SERVICE) {\n",
        "        ipv4_ct_tuple_reverse (tuple);\n",
        "        ret = __ct_lookup (map, ctx, tuple, action, dir, ct_state, is_tcp, tcp_flags, monitor);\n",
        "    }\n",
        "out :\n",
        "    cilium_dbg (ctx, DBG_CT_VERDICT, ret < 0 ? -ret : ret, ct_state->rev_nat_index);\n",
        "    return ret;\n",
        "}\n"
      ],
      "called_function_list": [
        "ipv4_ct_tuple_reverse",
        "ipv4_ct_extract_l4_ports",
        "cilium_dbg3",
        "__ct_lookup",
        "relax_verifier",
        "cilium_dbg"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ct_update6_backend_id": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 759,
      "endLine": 770,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h",
      "funcName": "ct_update6_backend_id",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [
        " map"
      ],
      "input": [
        "const void *map",
        " const struct ipv6_ct_tuple *tuple",
        " const struct ct_state *state"
      ],
      "output": "static__always_inlinevoid",
      "helper": [
        "map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void ct_update6_backend_id (const void *map, const struct ipv6_ct_tuple *tuple, const struct ct_state *state)\n",
        "{\n",
        "    struct ct_entry *entry;\n",
        "    entry = map_lookup_elem (map, tuple);\n",
        "    if (!entry)\n",
        "        return;\n",
        "    entry->backend_id = state->backend_id;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ct_update6_rev_nat_index": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 772,
      "endLine": 783,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h",
      "funcName": "ct_update6_rev_nat_index",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [
        " map"
      ],
      "input": [
        "const void *map",
        " const struct ipv6_ct_tuple *tuple",
        " const struct ct_state *state"
      ],
      "output": "static__always_inlinevoid",
      "helper": [
        "map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void ct_update6_rev_nat_index (const void *map, const struct ipv6_ct_tuple *tuple, const struct ct_state *state)\n",
        "{\n",
        "    struct ct_entry *entry;\n",
        "    entry = map_lookup_elem (map, tuple);\n",
        "    if (!entry)\n",
        "        return;\n",
        "    entry->rev_nat_index = state->rev_nat_index;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ct_update6_dsr": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 785,
      "endLine": 796,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h",
      "funcName": "ct_update6_dsr",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [
        " map"
      ],
      "input": [
        "const void *map",
        " const struct ipv6_ct_tuple *tuple",
        " const bool dsr"
      ],
      "output": "static__always_inlinevoid",
      "helper": [
        "map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void ct_update6_dsr (const void *map, const struct ipv6_ct_tuple *tuple, const bool dsr)\n",
        "{\n",
        "    struct ct_entry *entry;\n",
        "    entry = map_lookup_elem (map, tuple);\n",
        "    if (!entry)\n",
        "        return;\n",
        "    entry->dsr = dsr;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ct_create6": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 799,
      "endLine": 865,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h",
      "funcName": "ct_create6",
      "developer_inline_comments": [
        {
          "start_line": 798,
          "end_line": 798,
          "text": "/* Offset must point to IPv6 */"
        },
        {
          "start_line": 805,
          "end_line": 805,
          "text": "/* Create entry in original direction */"
        },
        {
          "start_line": 810,
          "end_line": 812,
          "text": "/* Note if this is a proxy connection so that replies can be redirected\n\t * back to the proxy.\n\t */"
        },
        {
          "start_line": 846,
          "end_line": 846,
          "text": "/* Create an ICMPv6 entry to relate errors */"
        },
        {
          "start_line": 854,
          "end_line": 854,
          "text": "/* For ICMP, there is no SYN. */"
        }
      ],
      "updateMaps": [
        " map_main",
        " map_related"
      ],
      "readMaps": [],
      "input": [
        "const void *map_main",
        " const void *map_related",
        " struct ipv6_ct_tuple *tuple",
        " struct  __ctx_buff *ctx",
        " const int dir",
        " const struct ct_state *ct_state",
        " bool proxy_redirect",
        " bool from_l7lb"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "send_signal"
      ],
      "compatibleHookpoints": [
        "perf_event",
        "raw_tracepoint_writable",
        "kprobe",
        "tracepoint",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int ct_create6 (const void *map_main, const void *map_related, struct ipv6_ct_tuple *tuple, struct  __ctx_buff *ctx, const int dir, const struct ct_state *ct_state, bool proxy_redirect, bool from_l7lb)\n",
        "{\n",
        "    struct ct_entry entry = {}\n",
        "    ;\n",
        "    bool is_tcp = tuple->nexthdr == IPPROTO_TCP;\n",
        "    union tcp_flags seen_flags = {\n",
        "        .value = 0}\n",
        "    ;\n",
        "    entry.proxy_redirect = proxy_redirect;\n",
        "    entry.from_l7lb = from_l7lb;\n",
        "    if (dir == CT_SERVICE)\n",
        "        entry.backend_id = ct_state->backend_id;\n",
        "    entry.lb_loopback = ct_state->loopback;\n",
        "    entry.node_port = ct_state->node_port;\n",
        "    relax_verifier ();\n",
        "    entry.dsr = ct_state->dsr;\n",
        "    entry.ifindex = ct_state->ifindex;\n",
        "    entry.rev_nat_index = ct_state->rev_nat_index;\n",
        "    seen_flags.value |= is_tcp ? TCP_FLAG_SYN : 0;\n",
        "    ct_update_timeout (&entry, is_tcp, dir, seen_flags);\n",
        "    if (dir == CT_INGRESS) {\n",
        "        entry.rx_packets = 1;\n",
        "        entry.rx_bytes = ctx_full_len (ctx);\n",
        "    }\n",
        "    else if (dir == CT_EGRESS) {\n",
        "        entry.tx_packets = 1;\n",
        "        entry.tx_bytes = ctx_full_len (ctx);\n",
        "    }\n",
        "    cilium_dbg3 (ctx, DBG_CT_CREATED6, entry.rev_nat_index, ct_state->src_sec_id, 0);\n",
        "    entry.src_sec_id = ct_state->src_sec_id;\n",
        "    if (map_update_elem (map_main, tuple, &entry, 0) < 0) {\n",
        "        send_signal_ct_fill_up (ctx, SIGNAL_PROTO_V6);\n",
        "        return DROP_CT_CREATE_FAILED;\n",
        "    }\n",
        "    if (map_related != NULL) {\n",
        "        struct ipv6_ct_tuple icmp_tuple = {\n",
        "            .nexthdr = IPPROTO_ICMPV6,\n",
        "            .sport = 0,\n",
        "            .dport = 0,\n",
        "            .flags = tuple->flags | TUPLE_F_RELATED,}\n",
        "        ;\n",
        "        entry.seen_non_syn = true;\n",
        "        ipv6_addr_copy (&icmp_tuple.daddr, &tuple->daddr);\n",
        "        ipv6_addr_copy (&icmp_tuple.saddr, &tuple->saddr);\n",
        "        if (map_update_elem (map_related, &icmp_tuple, &entry, 0) < 0) {\n",
        "            send_signal_ct_fill_up (ctx, SIGNAL_PROTO_V6);\n",
        "            return DROP_CT_CREATE_FAILED;\n",
        "        }\n",
        "    }\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "cilium_dbg3",
        "ct_update_timeout",
        "send_signal_ct_fill_up",
        "relax_verifier",
        "ipv6_addr_copy",
        "ctx_full_len"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ct_update4_backend_id": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 867,
      "endLine": 878,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h",
      "funcName": "ct_update4_backend_id",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [
        " map"
      ],
      "input": [
        "const void *map",
        " const struct ipv4_ct_tuple *tuple",
        " const struct ct_state *state"
      ],
      "output": "static__always_inlinevoid",
      "helper": [
        "map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void ct_update4_backend_id (const void *map, const struct ipv4_ct_tuple *tuple, const struct ct_state *state)\n",
        "{\n",
        "    struct ct_entry *entry;\n",
        "    entry = map_lookup_elem (map, tuple);\n",
        "    if (!entry)\n",
        "        return;\n",
        "    entry->backend_id = state->backend_id;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ct_update4_rev_nat_index": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 880,
      "endLine": 891,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h",
      "funcName": "ct_update4_rev_nat_index",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [
        " map"
      ],
      "input": [
        "const void *map",
        " const struct ipv4_ct_tuple *tuple",
        " const struct ct_state *state"
      ],
      "output": "static__always_inlinevoid",
      "helper": [
        "map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void ct_update4_rev_nat_index (const void *map, const struct ipv4_ct_tuple *tuple, const struct ct_state *state)\n",
        "{\n",
        "    struct ct_entry *entry;\n",
        "    entry = map_lookup_elem (map, tuple);\n",
        "    if (!entry)\n",
        "        return;\n",
        "    entry->rev_nat_index = state->rev_nat_index;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ct_update4_dsr": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 893,
      "endLine": 904,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h",
      "funcName": "ct_update4_dsr",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [
        " map"
      ],
      "input": [
        "const void *map",
        " const struct ipv4_ct_tuple *tuple",
        " const bool dsr"
      ],
      "output": "static__always_inlinevoid",
      "helper": [
        "map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void ct_update4_dsr (const void *map, const struct ipv4_ct_tuple *tuple, const bool dsr)\n",
        "{\n",
        "    struct ct_entry *entry;\n",
        "    entry = map_lookup_elem (map, tuple);\n",
        "    if (!entry)\n",
        "        return;\n",
        "    entry->dsr = dsr;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ct_create4": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 906,
      "endLine": 1006,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h",
      "funcName": "ct_create4",
      "developer_inline_comments": [
        {
          "start_line": 913,
          "end_line": 913,
          "text": "/* Create entry in original direction */"
        },
        {
          "start_line": 918,
          "end_line": 920,
          "text": "/* Note if this is a proxy connection so that replies can be redirected\n\t * back to the proxy.\n\t */"
        },
        {
          "start_line": 960,
          "end_line": 964,
          "text": "/* We are looping back into the origin endpoint through a\n\t\t * service, set up a conntrack tuple for the reply to ensure we\n\t\t * do rev NAT before attempting to route the destination\n\t\t * address which will not point back to the right source.\n\t\t */"
        },
        {
          "start_line": 985,
          "end_line": 985,
          "text": "/* Create an ICMP entry to relate errors */"
        },
        {
          "start_line": 995,
          "end_line": 995,
          "text": "/* For ICMP, there is no SYN. */"
        },
        {
          "start_line": 996,
          "end_line": 999,
          "text": "/* Previous map update succeeded, we could delete it in case\n\t\t * the below throws an error, but we might as well just let\n\t\t * it time out.\n\t\t */"
        }
      ],
      "updateMaps": [
        " map_main",
        " map_related"
      ],
      "readMaps": [],
      "input": [
        "const void *map_main",
        " const void *map_related",
        " struct ipv4_ct_tuple *tuple",
        " struct  __ctx_buff *ctx",
        " const int dir",
        " const struct ct_state *ct_state",
        " bool proxy_redirect",
        " bool from_l7lb"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "send_signal"
      ],
      "compatibleHookpoints": [
        "perf_event",
        "raw_tracepoint_writable",
        "kprobe",
        "tracepoint",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int ct_create4 (const void *map_main, const void *map_related, struct ipv4_ct_tuple *tuple, struct  __ctx_buff *ctx, const int dir, const struct ct_state *ct_state, bool proxy_redirect, bool from_l7lb)\n",
        "{\n",
        "    struct ct_entry entry = {}\n",
        "    ;\n",
        "    bool is_tcp = tuple->nexthdr == IPPROTO_TCP;\n",
        "    union tcp_flags seen_flags = {\n",
        "        .value = 0}\n",
        "    ;\n",
        "    entry.proxy_redirect = proxy_redirect;\n",
        "    entry.from_l7lb = from_l7lb;\n",
        "    entry.lb_loopback = ct_state->loopback;\n",
        "    entry.node_port = ct_state->node_port;\n",
        "    relax_verifier ();\n",
        "    entry.dsr = ct_state->dsr;\n",
        "    entry.ifindex = ct_state->ifindex;\n",
        "    if (dir == CT_SERVICE)\n",
        "        entry.backend_id = ct_state->backend_id;\n",
        "    entry.rev_nat_index = ct_state->rev_nat_index;\n",
        "    seen_flags.value |= is_tcp ? TCP_FLAG_SYN : 0;\n",
        "    ct_update_timeout (&entry, is_tcp, dir, seen_flags);\n",
        "    if (dir == CT_INGRESS) {\n",
        "        entry.rx_packets = 1;\n",
        "        entry.rx_bytes = ctx_full_len (ctx);\n",
        "    }\n",
        "    else if (dir == CT_EGRESS) {\n",
        "        entry.tx_packets = 1;\n",
        "        entry.tx_bytes = ctx_full_len (ctx);\n",
        "    }\n",
        "    cilium_dbg3 (ctx, DBG_CT_CREATED4, entry.rev_nat_index, ct_state->src_sec_id, ct_state->addr);\n",
        "    entry.src_sec_id = ct_state->src_sec_id;\n",
        "    if (map_update_elem (map_main, tuple, &entry, 0) < 0) {\n",
        "        send_signal_ct_fill_up (ctx, SIGNAL_PROTO_V4);\n",
        "        return DROP_CT_CREATE_FAILED;\n",
        "    }\n",
        "    if (ct_state->addr && ct_state->loopback) {\n",
        "        __u8 flags = tuple->flags;\n",
        "        __be32 saddr, daddr;\n",
        "        saddr = tuple->saddr;\n",
        "        daddr = tuple->daddr;\n",
        "        tuple->flags = TUPLE_F_IN;\n",
        "        if (dir == CT_INGRESS) {\n",
        "            tuple->saddr = ct_state->addr;\n",
        "            tuple->daddr = ct_state->svc_addr;\n",
        "        }\n",
        "        else {\n",
        "            tuple->saddr = ct_state->svc_addr;\n",
        "            tuple->daddr = ct_state->addr;\n",
        "        }\n",
        "        if (map_update_elem (map_main, tuple, &entry, 0) < 0) {\n",
        "            send_signal_ct_fill_up (ctx, SIGNAL_PROTO_V4);\n",
        "            return DROP_CT_CREATE_FAILED;\n",
        "        }\n",
        "        tuple->saddr = saddr;\n",
        "        tuple->daddr = daddr;\n",
        "        tuple->flags = flags;\n",
        "    }\n",
        "    if (map_related != NULL) {\n",
        "        struct ipv4_ct_tuple icmp_tuple = {\n",
        "            .daddr = tuple->daddr,\n",
        "            .saddr = tuple->saddr,\n",
        "            .nexthdr = IPPROTO_ICMP,\n",
        "            .sport = 0,\n",
        "            .dport = 0,\n",
        "            .flags = tuple->flags | TUPLE_F_RELATED,}\n",
        "        ;\n",
        "        entry.seen_non_syn = true;\n",
        "        if (map_update_elem (map_related, &icmp_tuple, &entry, 0) < 0) {\n",
        "            send_signal_ct_fill_up (ctx, SIGNAL_PROTO_V4);\n",
        "            return DROP_CT_CREATE_FAILED;\n",
        "        }\n",
        "    }\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "cilium_dbg3",
        "ct_update_timeout",
        "send_signal_ct_fill_up",
        "relax_verifier",
        "ctx_full_len"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ct_has_nodeport_egress_entry4": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 1017,
      "endLine": 1032,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h",
      "funcName": "ct_has_nodeport_egress_entry4",
      "developer_inline_comments": [
        {
          "start_line": 1008,
          "end_line": 1016,
          "text": "/* The function tries to determine whether the flow identified by the given\n * CT_INGRESS tuple belongs to a NodePort traffic (i.e., outside client => N/S\n * LB => local backend).\n *\n * When the client send the NodePort request, the NodePort BPF\n * (nodeport_lb{4,6}()) creates the CT_EGRESS entry for the\n * (saddr=client,daddr=backend) tuple. So, to derive whether the reply packet\n * backend => client belongs to the LB flow we can query the CT_EGRESS entry.\n */"
        }
      ],
      "updateMaps": [],
      "readMaps": [
        " map"
      ],
      "input": [
        "const void *map",
        " struct ipv4_ct_tuple *ingress_tuple"
      ],
      "output": "static__always_inlinebool",
      "helper": [
        "map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline bool ct_has_nodeport_egress_entry4 (const void *map, struct ipv4_ct_tuple *ingress_tuple)\n",
        "{\n",
        "    __u8 prev_flags = ingress_tuple->flags;\n",
        "    struct ct_entry *entry;\n",
        "    ingress_tuple->flags = TUPLE_F_OUT;\n",
        "    entry = map_lookup_elem (map, ingress_tuple);\n",
        "    ingress_tuple->flags = prev_flags;\n",
        "    if (entry)\n",
        "        return entry->node_port;\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ct_has_nodeport_egress_entry6": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 1034,
      "endLine": 1049,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h",
      "funcName": "ct_has_nodeport_egress_entry6",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [
        " map"
      ],
      "input": [
        "const void *map",
        " struct ipv6_ct_tuple *ingress_tuple"
      ],
      "output": "static__always_inlinebool",
      "helper": [
        "map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline bool ct_has_nodeport_egress_entry6 (const void *map, struct ipv6_ct_tuple *ingress_tuple)\n",
        "{\n",
        "    __u8 prev_flags = ingress_tuple->flags;\n",
        "    struct ct_entry *entry;\n",
        "    ingress_tuple->flags = TUPLE_F_OUT;\n",
        "    entry = map_lookup_elem (map, ingress_tuple);\n",
        "    ingress_tuple->flags = prev_flags;\n",
        "    if (entry)\n",
        "        return entry->node_port;\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ct_update_nodeport": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 1051,
      "endLine": 1061,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h",
      "funcName": "ct_update_nodeport",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [
        " map"
      ],
      "input": [
        "const void *map",
        " const void *tuple",
        " const bool node_port"
      ],
      "output": "static__always_inlinevoid",
      "helper": [
        "map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void ct_update_nodeport (const void *map, const void *tuple, const bool node_port)\n",
        "{\n",
        "    struct ct_entry *entry;\n",
        "    entry = map_lookup_elem (map, tuple);\n",
        "    if (!entry)\n",
        "        return;\n",
        "    entry->node_port = node_port;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "update_metrics": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 24,
      "endLine": 43,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/metrics.h",
      "funcName": "update_metrics",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */"
        },
        {
          "start_line": 2,
          "end_line": 2,
          "text": "/* Copyright Authors of Cilium */"
        },
        {
          "start_line": 4,
          "end_line": 7,
          "text": "/*\n * Data metrics collection functions\n *\n */"
        },
        {
          "start_line": 16,
          "end_line": 23,
          "text": "/**\n * update_metrics\n * @direction:\t1: Ingress 2: Egress\n * @reason:\treason for forwarding or dropping packet.\n *\t\treason is 0 if packet is being forwarded, else reason\n *\t\tis the drop error code.\n * Update the metrics map.\n */"
        }
      ],
      "updateMaps": [
        " METRICS_MAP"
      ],
      "readMaps": [
        "  METRICS_MAP"
      ],
      "input": [
        "__u64 bytes",
        " __u8 direction",
        " __u8 reason"
      ],
      "output": "static__always_inlinevoid",
      "helper": [
        "map_update_elem",
        "map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void update_metrics (__u64 bytes, __u8 direction, __u8 reason)\n",
        "{\n",
        "    struct metrics_value *entry, new_entry = {};\n",
        "    struct metrics_key key = {}\n",
        "    ;\n",
        "    key.reason = reason;\n",
        "    key.dir = direction;\n",
        "    entry = map_lookup_elem (& METRICS_MAP, & key);\n",
        "    if (entry) {\n",
        "        entry->count += 1;\n",
        "        entry->bytes += bytes;\n",
        "    }\n",
        "    else {\n",
        "        new_entry.count = 1;\n",
        "        new_entry.bytes = bytes;\n",
        "        map_update_elem (&METRICS_MAP, &key, &new_entry, 0);\n",
        "    }\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ct_to_metrics_dir": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 50,
      "endLine": 62,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/metrics.h",
      "funcName": "ct_to_metrics_dir",
      "developer_inline_comments": [
        {
          "start_line": 45,
          "end_line": 49,
          "text": "/**\n * ct_to_metrics_dir\n * @direction:\t1: Ingress 2: Egress 3: Service\n * Convert a CT direction into the corresponding one for metrics.\n */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "enum ct_dir ct_dir"
      ],
      "output": "static__always_inlineenummetric_dir",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline enum metric_dir ct_to_metrics_dir (enum ct_dir ct_dir)\n",
        "{\n",
        "    switch (ct_dir) {\n",
        "    case CT_INGRESS :\n",
        "        return METRIC_INGRESS;\n",
        "    case CT_EGRESS :\n",
        "        return METRIC_EGRESS;\n",
        "    case CT_SERVICE :\n",
        "        return METRIC_SERVICE;\n",
        "    default :\n",
        "        return 0;\n",
        "    }\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "rol32": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 14,
      "endLine": 17,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/jhash.h",
      "funcName": "rol32",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */"
        },
        {
          "start_line": 2,
          "end_line": 2,
          "text": "/* Copyright (C) 2006 Bob Jenkins <bob_jenkins@burtleburtle.net> */"
        },
        {
          "start_line": 3,
          "end_line": 3,
          "text": "/* Copyright (C) 2006-2020 Authors of the Linux kernel */"
        },
        {
          "start_line": 4,
          "end_line": 4,
          "text": "/* Copyright Authors of Cilium */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "__u32 word",
        " __u32 shift"
      ],
      "output": "static__always_inline__u32",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __u32 rol32 (__u32 word, __u32 shift)\n",
        "{\n",
        "    return (word << shift) | (word >> ((-shift) & 31));\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "jhash": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 40,
      "endLine": 81,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/jhash.h",
      "funcName": "jhash",
      "developer_inline_comments": [
        {
          "start_line": 76,
          "end_line": 76,
          "text": "/* Nothing left to add */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const void *key",
        " __u32 length",
        " __u32 initval"
      ],
      "output": "static__always_inline__u32",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __u32 jhash (const void *key, __u32 length, __u32 initval)\n",
        "{\n",
        "    const unsigned char *k = key;\n",
        "    __u32 a, b, c;\n",
        "    if (!__builtin_constant_p (length))\n",
        "        __throw_build_bug ();\n",
        "    a = b = c = JHASH_INITVAL + length + initval;\n",
        "    while (length > 12) {\n",
        "        a += *(__u32*) (k);\n",
        "        b += *(__u32*) (k + 4);\n",
        "        c += *(__u32*) (k + 8);\n",
        "        __jhash_mix (a, b, c);\n",
        "        length -= 12;\n",
        "        k += 12;\n",
        "    }\n",
        "    switch (length) {\n",
        "    case 12 :\n",
        "        c += (__u32) k[11] << 24;\n",
        "    case 11 :\n",
        "        c += (__u32) k[10] << 16;\n",
        "    case 10 :\n",
        "        c += (__u32) k[9] << 8;\n",
        "    case 9 :\n",
        "        c += (__u32) k[8];\n",
        "    case 8 :\n",
        "        b += (__u32) k[7] << 24;\n",
        "    case 7 :\n",
        "        b += (__u32) k[6] << 16;\n",
        "    case 6 :\n",
        "        b += (__u32) k[5] << 8;\n",
        "    case 5 :\n",
        "        b += (__u32) k[4];\n",
        "    case 4 :\n",
        "        a += (__u32) k[3] << 24;\n",
        "    case 3 :\n",
        "        a += (__u32) k[2] << 16;\n",
        "    case 2 :\n",
        "        a += (__u32) k[1] << 8;\n",
        "    case 1 :\n",
        "        a += (__u32) k[0];\n",
        "        __jhash_final (a, b, c);\n",
        "    case 0 :\n",
        "        break;\n",
        "    }\n",
        "    return c;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__jhash_nwords": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 83,
      "endLine": 91,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/jhash.h",
      "funcName": "__jhash_nwords",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "__u32 a",
        " __u32 b",
        " __u32 c",
        " __u32 initval"
      ],
      "output": "static__always_inline__u32",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __u32 __jhash_nwords (__u32 a, __u32 b, __u32 c, __u32 initval)\n",
        "{\n",
        "    a += initval;\n",
        "    b += initval;\n",
        "    c += initval;\n",
        "    __jhash_final (a, b, c);\n",
        "    return c;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "jhash_3words": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 93,
      "endLine": 97,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/jhash.h",
      "funcName": "jhash_3words",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "__u32 a",
        " __u32 b",
        " __u32 c",
        " __u32 initval"
      ],
      "output": "static__always_inline__u32",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __u32 jhash_3words (__u32 a, __u32 b, __u32 c, __u32 initval)\n",
        "{\n",
        "    return __jhash_nwords (a, b, c, initval + JHASH_INITVAL + (3 << 2));\n",
        "}\n"
      ],
      "called_function_list": [
        "__jhash_nwords"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "jhash_2words": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 99,
      "endLine": 102,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/jhash.h",
      "funcName": "jhash_2words",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "__u32 a",
        " __u32 b",
        " __u32 initval"
      ],
      "output": "static__always_inline__u32",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __u32 jhash_2words (__u32 a, __u32 b, __u32 initval)\n",
        "{\n",
        "    return __jhash_nwords (a, b, 0, initval + JHASH_INITVAL + (2 << 2));\n",
        "}\n"
      ],
      "called_function_list": [
        "__jhash_nwords"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "jhash_1word": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 104,
      "endLine": 107,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/jhash.h",
      "funcName": "jhash_1word",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "__u32 a",
        " __u32 initval"
      ],
      "output": "static__always_inline__u32",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __u32 jhash_1word (__u32 a, __u32 initval)\n",
        "{\n",
        "    return __jhash_nwords (a, 0, 0, initval + JHASH_INITVAL + (1 << 2));\n",
        "}\n"
      ],
      "called_function_list": [
        "__jhash_nwords"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ep_tail_call": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 276,
      "endLine": 280,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/maps.h",
      "funcName": "ep_tail_call",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */"
        },
        {
          "start_line": 2,
          "end_line": 2,
          "text": "/* Copyright Authors of Cilium */"
        },
        {
          "start_line": 33,
          "end_line": 33,
          "text": "/* Global map to jump into policy enforcement of receiving endpoint */"
        },
        {
          "start_line": 42,
          "end_line": 42,
          "text": "/* SKIP_POLICY_MAP */"
        },
        {
          "start_line": 45,
          "end_line": 45,
          "text": "/* Global map to jump into policy enforcement of sending endpoint */"
        },
        {
          "start_line": 65,
          "end_line": 65,
          "text": "/* ENABLE_BANDWIDTH_MANAGER */"
        },
        {
          "start_line": 67,
          "end_line": 67,
          "text": "/* Map to link endpoint id to per endpoint cilium_policy map */"
        },
        {
          "start_line": 79,
          "end_line": 79,
          "text": "/* Per-endpoint policy enforcement map */"
        },
        {
          "start_line": 91,
          "end_line": 91,
          "text": "/* Private per EP map for internal tail calls */"
        },
        {
          "start_line": 100,
          "end_line": 100,
          "text": "/* SKIP_CALLS_MAP */"
        },
        {
          "start_line": 116,
          "end_line": 120,
          "text": "/* Private per-EP map for tail calls to user-defined programs.\n * CUSTOM_CALLS_MAP is a per-EP map name, only defined for programs that need\n * to use the map, so we do not want to compile this definition if\n * CUSTOM_CALLS_MAP has not been #define-d.\n */"
        },
        {
          "start_line": 127,
          "end_line": 127,
          "text": "/* ingress and egress, IPv4 and IPv6 */"
        },
        {
          "start_line": 134,
          "end_line": 134,
          "text": "/* ENABLE_CUSTOM_CALLS && CUSTOM_CALLS_MAP */"
        },
        {
          "start_line": 143,
          "end_line": 147,
          "text": "/* Define a function with the following NAME which iterates through PREFIXES\n * (a list of integers ordered from high to low representing prefix length),\n * performing a lookup in MAP using LOOKUP_FN to find a provided IP of type\n * IPTYPE.\n */"
        },
        {
          "start_line": 162,
          "end_line": 162,
          "text": "/* HAVE_LPM_TRIE_MAP_TYPE */"
        },
        {
          "start_line": 184,
          "end_line": 184,
          "text": "/* Global IP -> Identity map for applying egress label-based policy */"
        },
        {
          "start_line": 212,
          "end_line": 212,
          "text": "/* ENABLE_EGRESS_GATEWAY */"
        },
        {
          "start_line": 238,
          "end_line": 238,
          "text": "/* inner header */"
        },
        {
          "start_line": 239,
          "end_line": 239,
          "text": "/* outer header */"
        },
        {
          "start_line": 248,
          "end_line": 248,
          "text": "/* ENABLE_IPV4 */"
        },
        {
          "start_line": 256,
          "end_line": 256,
          "text": "/* SID */"
        },
        {
          "start_line": 257,
          "end_line": 257,
          "text": "/* VRF ID */"
        },
        {
          "start_line": 262,
          "end_line": 262,
          "text": "/* ENABLE_SRV6 */"
        },
        {
          "start_line": 273,
          "end_line": 273,
          "text": "/* ENABLE_VTEP */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff * ctx __maybe_unused",
        " const __u32 index __maybe_unused"
      ],
      "output": "static__always_inlinevoid",
      "helper": [
        "tail_call"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void ep_tail_call (struct  __ctx_buff * ctx __maybe_unused, const __u32 index __maybe_unused)\n",
        "{\n",
        "    tail_call_static (ctx, &CALLS_MAP, index);\n",
        "}\n"
      ],
      "called_function_list": [
        "tail_call_static"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__lookup_ip6_endpoint": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 12,
      "endLine": 21,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/eps.h",
      "funcName": "__lookup_ip6_endpoint",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */"
        },
        {
          "start_line": 2,
          "end_line": 2,
          "text": "/* Copyright Authors of Cilium */"
        }
      ],
      "updateMaps": [],
      "readMaps": [
        " ENDPOINTS_MAP"
      ],
      "input": [
        "const union v6addr *ip6"
      ],
      "output": "static__always_inline__maybe_unusedstructendpoint_info",
      "helper": [
        "map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused struct endpoint_info *__lookup_ip6_endpoint (const union v6addr *ip6)\n",
        "{\n",
        "    struct endpoint_key key = {}\n",
        "    ;\n",
        "    key.ip6 = *ip6;\n",
        "    key.family = ENDPOINT_KEY_IPV6;\n",
        "    return map_lookup_elem (&ENDPOINTS_MAP, &key);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "lookup_ip6_endpoint": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 23,
      "endLine": 27,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/eps.h",
      "funcName": "lookup_ip6_endpoint",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct ipv6hdr *ip6"
      ],
      "output": "static__always_inline__maybe_unusedstructendpoint_info",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused struct endpoint_info *lookup_ip6_endpoint (const struct ipv6hdr *ip6)\n",
        "{\n",
        "    return __lookup_ip6_endpoint ((union v6addr *) &ip6->daddr);\n",
        "}\n"
      ],
      "called_function_list": [
        "__lookup_ip6_endpoint"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__lookup_ip4_endpoint": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 29,
      "endLine": 38,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/eps.h",
      "funcName": "__lookup_ip4_endpoint",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [
        " ENDPOINTS_MAP"
      ],
      "input": [
        "__u32 ip"
      ],
      "output": "static__always_inline__maybe_unusedstructendpoint_info",
      "helper": [
        "map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused struct endpoint_info *__lookup_ip4_endpoint (__u32 ip)\n",
        "{\n",
        "    struct endpoint_key key = {}\n",
        "    ;\n",
        "    key.ip4 = ip;\n",
        "    key.family = ENDPOINT_KEY_IPV4;\n",
        "    return map_lookup_elem (&ENDPOINTS_MAP, &key);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "lookup_ip4_endpoint": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 40,
      "endLine": 44,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/eps.h",
      "funcName": "lookup_ip4_endpoint",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct iphdr *ip4"
      ],
      "output": "static__always_inline__maybe_unusedstructendpoint_info",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused struct endpoint_info *lookup_ip4_endpoint (const struct iphdr *ip4)\n",
        "{\n",
        "    return __lookup_ip4_endpoint (ip4->daddr);\n",
        "}\n"
      ],
      "called_function_list": [
        "__lookup_ip4_endpoint"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "lookup_ip4_endpoint_policy_map": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 47,
      "endLine": 56,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/eps.h",
      "funcName": "lookup_ip4_endpoint_policy_map",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [
        " EP_POLICY_MAP"
      ],
      "input": [
        "__u32 ip"
      ],
      "output": "static__always_inlinevoid",
      "helper": [
        "map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void *lookup_ip4_endpoint_policy_map (__u32 ip)\n",
        "{\n",
        "    struct endpoint_key key = {}\n",
        "    ;\n",
        "    key.ip4 = ip;\n",
        "    key.family = ENDPOINT_KEY_IPV4;\n",
        "    return map_lookup_elem (&EP_POLICY_MAP, &key);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ipcache_lookup6": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 67,
      "endLine": 78,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/eps.h",
      "funcName": "ipcache_lookup6",
      "developer_inline_comments": [
        {
          "start_line": 59,
          "end_line": 59,
          "text": "/* IPCACHE_STATIC_PREFIX gets sizeof non-IP, non-prefix part of ipcache_key */"
        }
      ],
      "updateMaps": [],
      "readMaps": [
        " map"
      ],
      "input": [
        "const void *map",
        " const union v6addr *addr",
        " __u32 prefix"
      ],
      "output": "static__always_inline__maybe_unusedstructremote_endpoint_info",
      "helper": [
        "map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused struct remote_endpoint_info *ipcache_lookup6 (const void *map, const union v6addr *addr, __u32 prefix)\n",
        "{\n",
        "    struct ipcache_key key = {\n",
        "        .lpm_key = {IPCACHE_PREFIX_LEN (prefix),\n",
        "            {}},\n",
        "        .family = ENDPOINT_KEY_IPV6,\n",
        "        .ip6 = *addr,}\n",
        "    ;\n",
        "    ipv6_addr_clear_suffix (&key.ip6, prefix);\n",
        "    return map_lookup_elem (map, &key);\n",
        "}\n"
      ],
      "called_function_list": [
        "ipv6_addr_clear_suffix"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ipcache_lookup4": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 82,
      "endLine": 92,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/eps.h",
      "funcName": "ipcache_lookup4",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [
        " map"
      ],
      "input": [
        "const void *map",
        " __be32 addr",
        " __u32 prefix"
      ],
      "output": "static__always_inline__maybe_unusedstructremote_endpoint_info",
      "helper": [
        "map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused struct remote_endpoint_info *ipcache_lookup4 (const void *map, __be32 addr, __u32 prefix)\n",
        "{\n",
        "    struct ipcache_key key = {\n",
        "        .lpm_key = {IPCACHE_PREFIX_LEN (prefix),\n",
        "            {}},\n",
        "        .family = ENDPOINT_KEY_IPV4,\n",
        "        .ip4 = addr,}\n",
        "    ;\n",
        "    key.ip4 &= GET_PREFIX (prefix);\n",
        "    return map_lookup_elem (map, &key);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "bpf_skip_nodeport_clear": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 31,
      "endLine": 35,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h",
      "funcName": "bpf_skip_nodeport_clear",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */"
        },
        {
          "start_line": 2,
          "end_line": 2,
          "text": "/* Copyright Authors of Cilium */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "static__always_inline__maybe_unusedvoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused void bpf_skip_nodeport_clear (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    ctx_skip_nodeport_clear (ctx);\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_skip_nodeport_clear"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "bpf_skip_nodeport_set": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 37,
      "endLine": 41,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h",
      "funcName": "bpf_skip_nodeport_set",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "static__always_inline__maybe_unusedvoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused void bpf_skip_nodeport_set (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    ctx_skip_nodeport_set (ctx);\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_skip_nodeport_set"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "bpf_skip_nodeport": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 43,
      "endLine": 47,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h",
      "funcName": "bpf_skip_nodeport",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "static__always_inline__maybe_unusedbool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused bool bpf_skip_nodeport (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    return ctx_skip_nodeport (ctx);\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_skip_nodeport"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "nodeport_uses_dsr": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 81,
      "endLine": 92,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h",
      "funcName": "nodeport_uses_dsr",
      "developer_inline_comments": [
        {
          "start_line": 53,
          "end_line": 53,
          "text": "/* ipv4 addr */"
        },
        {
          "start_line": 54,
          "end_line": 54,
          "text": "/* hw addr */"
        },
        {
          "start_line": 58,
          "end_line": 58,
          "text": "/* ENABLE_IPV4 */"
        },
        {
          "start_line": 63,
          "end_line": 63,
          "text": "/* ipv6 addr */"
        },
        {
          "start_line": 64,
          "end_line": 64,
          "text": "/* hw addr */"
        },
        {
          "start_line": 69,
          "end_line": 69,
          "text": "/* The IPv6 extension should be 8-bytes aligned */"
        },
        {
          "start_line": 79,
          "end_line": 79,
          "text": "/* ENABLE_IPV6 */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "__u8 nexthdr __maybe_unused"
      ],
      "output": "static__always_inlinebool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline bool nodeport_uses_dsr (__u8 nexthdr __maybe_unused)\n",
        "{\n",
        "\n",
        "# if defined(ENABLE_DSR) && !defined(ENABLE_DSR_HYBRID)\n",
        "    return true;\n",
        "\n",
        "# elif defined(ENABLE_DSR) && defined(ENABLE_DSR_HYBRID)\n",
        "    if (nexthdr == IPPROTO_TCP)\n",
        "        return true;\n",
        "    return false;\n",
        "\n",
        "# else\n",
        "    return false;\n",
        "\n",
        "# endif\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "bpf_mark_snat_done": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 94,
      "endLine": 103,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h",
      "funcName": "bpf_mark_snat_done",
      "developer_inline_comments": [
        {
          "start_line": 97,
          "end_line": 99,
          "text": "/* From XDP layer, we do not go through an egress hook from\n\t * here, hence nothing to be done.\n\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff * ctx __maybe_unused"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void bpf_mark_snat_done (struct  __ctx_buff * ctx __maybe_unused)\n",
        "{\n",
        "\n",
        "#if __ctx_is == __ctx_skb\n",
        "    ctx->mark |= MARK_MAGIC_SNAT_DONE;\n",
        "\n",
        "#endif\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "bpf_skip_recirculation": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 105,
      "endLine": 116,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h",
      "funcName": "bpf_skip_recirculation",
      "developer_inline_comments": [
        {
          "start_line": 108,
          "end_line": 110,
          "text": "/* From XDP layer, we do not go through an egress hook from\n\t * here, hence nothing to be skipped.\n\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct  __ctx_buff * ctx __maybe_unused"
      ],
      "output": "static__always_inlinebool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline bool bpf_skip_recirculation (const struct  __ctx_buff * ctx __maybe_unused)\n",
        "{\n",
        "\n",
        "#if __ctx_is == __ctx_skb\n",
        "    return ctx->tc_index & TC_INDEX_F_SKIP_RECIRCULATION;\n",
        "\n",
        "#else\n",
        "    return false;\n",
        "\n",
        "#endif\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ctx_adjust_hroom_dsr_flags": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 118,
      "endLine": 125,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h",
      "funcName": "ctx_adjust_hroom_dsr_flags",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void"
      ],
      "output": "static__always_inline__u64",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __u64 ctx_adjust_hroom_dsr_flags (void)\n",
        "{\n",
        "\n",
        "#ifdef BPF_HAVE_CSUM_LEVEL\n",
        "    return BPF_F_ADJ_ROOM_NO_CSUM_RESET;\n",
        "\n",
        "#else\n",
        "    return 0;\n",
        "\n",
        "#endif\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "dsr_fail_needs_reply": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 127,
      "endLine": 134,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h",
      "funcName": "dsr_fail_needs_reply",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "int code __maybe_unused"
      ],
      "output": "static__always_inlinebool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline bool dsr_fail_needs_reply (int code __maybe_unused)\n",
        "{\n",
        "\n",
        "#ifdef ENABLE_DSR_ICMP_ERRORS\n",
        "    if (code == DROP_FRAG_NEEDED)\n",
        "        return true;\n",
        "\n",
        "#endif\n",
        "    return false;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "dsr_is_too_big": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 136,
      "endLine": 144,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h",
      "funcName": "dsr_is_too_big",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff * ctx __maybe_unused",
        " __u16 expanded_len __maybe_unused"
      ],
      "output": "static__always_inlinebool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline bool dsr_is_too_big (struct  __ctx_buff * ctx __maybe_unused, __u16 expanded_len __maybe_unused)\n",
        "{\n",
        "\n",
        "#ifdef ENABLE_DSR_ICMP_ERRORS\n",
        "    if (expanded_len > THIS_MTU)\n",
        "        return true;\n",
        "\n",
        "#endif\n",
        "    return false;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "maybe_add_l2_hdr": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 146,
      "endLine": 170,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h",
      "funcName": "maybe_add_l2_hdr",
      "developer_inline_comments": [
        {
          "start_line": 152,
          "end_line": 154,
          "text": "/* NodePort request is going to be redirected to L3 dev, so skip\n\t\t * L2 addr settings.\n\t\t */"
        },
        {
          "start_line": 157,
          "end_line": 159,
          "text": "/* NodePort request is going to be redirected from L3 to L2 dev,\n\t\t * so we need to create L2 hdr first.\n\t\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff * ctx __maybe_unused",
        " __u32 ifindex __maybe_unused",
        " bool * l2_hdr_required __maybe_unused"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int maybe_add_l2_hdr (struct  __ctx_buff * ctx __maybe_unused, __u32 ifindex __maybe_unused, bool * l2_hdr_required __maybe_unused)\n",
        "{\n",
        "    if (IS_L3_DEV (ifindex))\n",
        "        *l2_hdr_required = false;\n",
        "    else if (ETH_HLEN == 0) {\n",
        "        __u16 proto = ctx_get_protocol (ctx);\n",
        "        if (ctx_change_head (ctx, __ETH_HLEN, 0))\n",
        "            return DROP_INVALID;\n",
        "        if (eth_store_proto (ctx, proto, 0) < 0)\n",
        "            return DROP_WRITE_ERROR;\n",
        "    }\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "eth_store_proto",
        "ctx_get_protocol",
        "ctx_change_head"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "nodeport_uses_dsr6": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 173,
      "endLine": 176,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h",
      "funcName": "nodeport_uses_dsr6",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct ipv6_ct_tuple *tuple"
      ],
      "output": "static__always_inlinebool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline bool nodeport_uses_dsr6 (const struct ipv6_ct_tuple *tuple)\n",
        "{\n",
        "    return nodeport_uses_dsr (tuple->nexthdr);\n",
        "}\n"
      ],
      "called_function_list": [
        "nodeport_uses_dsr"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "snat_v6_needed": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 181,
      "endLine": 203,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h",
      "funcName": "snat_v6_needed",
      "developer_inline_comments": [
        {
          "start_line": 178,
          "end_line": 180,
          "text": "/* TODO(brb): after GH#6320, we can move snat_v{4,6}_needed() to lib/nat.h, as\n * then the helper function won't depend the dsr checks.\n */"
        },
        {
          "start_line": 200,
          "end_line": 200,
          "text": "/* ENABLE_DSR_HYBRID */"
        },
        {
          "start_line": 201,
          "end_line": 201,
          "text": "/* See snat_v4_needed(). */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " const union v6addr *addr"
      ],
      "output": "static__always_inlinebool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline bool snat_v6_needed (struct  __ctx_buff *ctx, const union v6addr *addr)\n",
        "{\n",
        "    void *data, *data_end;\n",
        "    struct ipv6hdr *ip6;\n",
        "    if (!revalidate_data (ctx, &data, &data_end, &ip6))\n",
        "        return false;\n",
        "\n",
        "#ifdef ENABLE_DSR_HYBRID\n",
        "    {\n",
        "        __u8 nexthdr = ip6->nexthdr;\n",
        "        int ret;\n",
        "        ret = ipv6_hdrlen (ctx, & nexthdr);\n",
        "        if (ret > 0) {\n",
        "            if (nodeport_uses_dsr (nexthdr))\n",
        "                return false;\n",
        "        }\n",
        "    }\n",
        "\n",
        "#endif /* ENABLE_DSR_HYBRID */\n",
        "    return !ipv6_addrcmp ((union v6addr *) &ip6->saddr, addr);\n",
        "}\n"
      ],
      "called_function_list": [
        "nodeport_uses_dsr",
        "ipv6_addrcmp",
        "ipv6_hdrlen"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "nodeport_nat_ipv6_fwd": [
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 205,
      "endLine": 221,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h",
      "funcName": "nodeport_nat_ipv6_fwd",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " const union v6addr *addr"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "CTX_ACT_OK"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "static __always_inline int nodeport_nat_ipv6_fwd (struct  __ctx_buff *ctx, const union v6addr *addr)\n",
        "{\n",
        "    struct ipv6_nat_target target = {\n",
        "        .min_port = NODEPORT_PORT_MIN_NAT,\n",
        "        .max_port = NODEPORT_PORT_MAX_NAT,}\n",
        "    ;\n",
        "    int ret;\n",
        "    ipv6_addr_copy (&target.addr, addr);\n",
        "    ret = snat_v6_needed (ctx, addr) ? snat_v6_process (ctx, NAT_DIR_EGRESS, &target) : CTX_ACT_OK;\n",
        "    if (ret == NAT_PUNT_TO_STACK)\n",
        "        ret = CTX_ACT_OK;\n",
        "    return ret;\n",
        "}\n"
      ],
      "called_function_list": [
        "ipv6_addr_copy",
        "snat_v6_needed",
        "snat_v6_process"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "rss_gen_src6": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 225,
      "endLine": 252,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h",
      "funcName": "rss_gen_src6",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "union v6addr *src",
        " const union v6addr *client",
        " __be32 l4_hint"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void rss_gen_src6 (union v6addr *src, const union v6addr *client, __be32 l4_hint)\n",
        "{\n",
        "    __u32 bits = 128 - IPV6_RSS_PREFIX_BITS;\n",
        "    *src = (union v6addr) IPV6_RSS_PREFIX;\n",
        "    if (bits) {\n",
        "        __u32 todo;\n",
        "        if (bits > 96) {\n",
        "            todo = bits - 96;\n",
        "            src->p1 |= bpf_htonl (hash_32 (client->p1 ^ l4_hint, todo));\n",
        "            bits -= todo;\n",
        "        }\n",
        "        if (bits > 64) {\n",
        "            todo = bits - 64;\n",
        "            src->p2 |= bpf_htonl (hash_32 (client->p2 ^ l4_hint, todo));\n",
        "            bits -= todo;\n",
        "        }\n",
        "        if (bits > 32) {\n",
        "            todo = bits - 32;\n",
        "            src->p3 |= bpf_htonl (hash_32 (client->p3 ^ l4_hint, todo));\n",
        "            bits -= todo;\n",
        "        }\n",
        "        src->p4 |= bpf_htonl (hash_32 (client->p4 ^ l4_hint, bits));\n",
        "    }\n",
        "}\n"
      ],
      "called_function_list": [
        "hash_32"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "dsr_set_ipip6": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 254,
      "endLine": 292,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h",
      "funcName": "dsr_set_ipip6",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " const struct ipv6hdr *ip6",
        " const union v6addr *backend_addr",
        " __be32 l4_hint",
        " int *ohead"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int dsr_set_ipip6 (struct  __ctx_buff *ctx, const struct ipv6hdr *ip6, const union v6addr *backend_addr, __be32 l4_hint, int *ohead)\n",
        "{\n",
        "    __u16 payload_len = bpf_ntohs (ip6->payload_len) + sizeof (*ip6);\n",
        "    const int l3_off = ETH_HLEN;\n",
        "    union v6addr saddr;\n",
        "    struct {\n",
        "        __be16 payload_len;\n",
        "        __u8 nexthdr;\n",
        "        __u8 hop_limit;\n",
        "    } tp_new = {\n",
        "        .payload_len = bpf_htons (payload_len),\n",
        "        .nexthdr = IPPROTO_IPV6,\n",
        "        .hop_limit = IPDEFTTL,};\n",
        "\n",
        "    if (dsr_is_too_big (ctx, payload_len + sizeof (*ip6))) {\n",
        "        *ohead = sizeof (*ip6);\n",
        "        return DROP_FRAG_NEEDED;\n",
        "    }\n",
        "    rss_gen_src6 (&saddr, (union v6addr *) &ip6->saddr, l4_hint);\n",
        "    if (ctx_adjust_hroom (ctx, sizeof (*ip6), BPF_ADJ_ROOM_NET, ctx_adjust_hroom_dsr_flags ()))\n",
        "        return DROP_INVALID;\n",
        "    if (ctx_store_bytes (ctx, l3_off + offsetof (struct ipv6hdr, payload_len), &tp_new.payload_len, 4, 0) < 0)\n",
        "        return DROP_WRITE_ERROR;\n",
        "    if (ctx_store_bytes (ctx, l3_off + offsetof (struct ipv6hdr, daddr), backend_addr, sizeof (ip6->daddr), 0) < 0)\n",
        "        return DROP_WRITE_ERROR;\n",
        "    if (ctx_store_bytes (ctx, l3_off + offsetof (struct ipv6hdr, saddr), &saddr, sizeof (ip6->saddr), 0) < 0)\n",
        "        return DROP_WRITE_ERROR;\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_adjust_hroom_dsr_flags",
        "dsr_is_too_big",
        "rss_gen_src6",
        "ctx_adjust_hroom"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "dsr_set_ext6": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 294,
      "endLine": 327,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h",
      "funcName": "dsr_set_ext6",
      "developer_inline_comments": [
        {
          "start_line": 302,
          "end_line": 302,
          "text": "/* The IPv6 extension should be 8-bytes aligned */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " struct ipv6hdr *ip6",
        " const union v6addr *svc_addr",
        " __be16 svc_port",
        " int *ohead"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int dsr_set_ext6 (struct  __ctx_buff *ctx, struct ipv6hdr *ip6, const union v6addr *svc_addr, __be16 svc_port, int *ohead)\n",
        "{\n",
        "    struct dsr_opt_v6 opt __align_stack_8 = {}\n",
        "    ;\n",
        "    __u16 payload_len = bpf_ntohs (ip6->payload_len) + sizeof (opt);\n",
        "    build_bug_on ((sizeof (struct dsr_opt_v6) % 8) != 0);\n",
        "    if (dsr_is_too_big (ctx, payload_len)) {\n",
        "        *ohead = sizeof (opt);\n",
        "        return DROP_FRAG_NEEDED;\n",
        "    }\n",
        "    opt.nexthdr = ip6->nexthdr;\n",
        "    ip6->nexthdr = NEXTHDR_DEST;\n",
        "    ip6->payload_len = bpf_htons (payload_len);\n",
        "    opt.len = DSR_IPV6_EXT_LEN;\n",
        "    opt.opt_type = DSR_IPV6_OPT_TYPE;\n",
        "    opt.opt_len = DSR_IPV6_OPT_LEN;\n",
        "    ipv6_addr_copy (&opt.addr, svc_addr);\n",
        "    opt.port = svc_port;\n",
        "    if (ctx_adjust_hroom (ctx, sizeof (opt), BPF_ADJ_ROOM_NET, ctx_adjust_hroom_dsr_flags ()))\n",
        "        return DROP_INVALID;\n",
        "    if (ctx_store_bytes (ctx, ETH_HLEN + sizeof (*ip6), &opt, sizeof (opt), 0) < 0)\n",
        "        return DROP_INVALID;\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_adjust_hroom_dsr_flags",
        "dsr_is_too_big",
        "ctx_adjust_hroom",
        "ipv6_addr_copy"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "find_dsr_v6": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 330,
      "endLine": 378,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h",
      "funcName": "find_dsr_v6",
      "developer_inline_comments": [
        {
          "start_line": 376,
          "end_line": 376,
          "text": "/* Reached limit of supported extension headers */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " __u8 nexthdr",
        " struct dsr_opt_v6 *dsr_opt",
        " bool *found"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int find_dsr_v6 (struct  __ctx_buff *ctx, __u8 nexthdr, struct dsr_opt_v6 *dsr_opt, bool *found)\n",
        "{\n",
        "    struct ipv6_opt_hdr opthdr __align_stack_8;\n",
        "    int i, len = sizeof (struct ipv6hdr);\n",
        "    __u8 nh = nexthdr;\n",
        "\n",
        "#pragma unroll\n",
        "    for (i = 0; i < IPV6_MAX_HEADERS; i++) {\n",
        "        switch (nh) {\n",
        "        case NEXTHDR_NONE :\n",
        "            return DROP_INVALID_EXTHDR;\n",
        "        case NEXTHDR_FRAGMENT :\n",
        "            return DROP_FRAG_NOSUPPORT;\n",
        "        case NEXTHDR_HOP :\n",
        "        case NEXTHDR_ROUTING :\n",
        "        case NEXTHDR_AUTH :\n",
        "        case NEXTHDR_DEST :\n",
        "            if (ctx_load_bytes (ctx, ETH_HLEN + len, &opthdr, sizeof (opthdr)) < 0)\n",
        "                return DROP_INVALID;\n",
        "            if (nh == NEXTHDR_DEST && opthdr.hdrlen == DSR_IPV6_EXT_LEN) {\n",
        "                if (ctx_load_bytes (ctx, ETH_HLEN + len, dsr_opt, sizeof (*dsr_opt)) < 0)\n",
        "                    return DROP_INVALID;\n",
        "                if (dsr_opt->opt_type == DSR_IPV6_OPT_TYPE && dsr_opt->opt_len == DSR_IPV6_OPT_LEN) {\n",
        "                    *found = true;\n",
        "                    return 0;\n",
        "                }\n",
        "            }\n",
        "            nh = opthdr.nexthdr;\n",
        "            if (nh == NEXTHDR_AUTH)\n",
        "                len += ipv6_authlen (&opthdr);\n",
        "            else\n",
        "                len += ipv6_optlen (&opthdr);\n",
        "            break;\n",
        "        default :\n",
        "            return 0;\n",
        "        }\n",
        "    }\n",
        "    return DROP_INVALID_EXTHDR;\n",
        "}\n"
      ],
      "called_function_list": [
        "ipv6_authlen",
        "ipv6_optlen"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "handle_dsr_v6": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 380,
      "endLine": 400,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h",
      "funcName": "handle_dsr_v6",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " bool *dsr"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int handle_dsr_v6 (struct  __ctx_buff *ctx, bool *dsr)\n",
        "{\n",
        "    struct dsr_opt_v6 opt __align_stack_8 = {}\n",
        "    ;\n",
        "    void *data, *data_end;\n",
        "    struct ipv6hdr *ip6;\n",
        "    int ret;\n",
        "    if (!revalidate_data (ctx, &data, &data_end, &ip6))\n",
        "        return DROP_INVALID;\n",
        "    ret = find_dsr_v6 (ctx, ip6 -> nexthdr, & opt, dsr);\n",
        "    if (ret != 0)\n",
        "        return ret;\n",
        "    if (*dsr) {\n",
        "        if (snat_v6_create_dsr (ctx, &opt.addr, opt.port) < 0)\n",
        "            return DROP_INVALID;\n",
        "    }\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "snat_v6_create_dsr",
        "find_dsr_v6"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "xlate_dsr_v6": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 402,
      "endLine": 418,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h",
      "funcName": "xlate_dsr_v6",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " const struct ipv6_ct_tuple *tuple",
        " int l4_off"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int xlate_dsr_v6 (struct  __ctx_buff *ctx, const struct ipv6_ct_tuple *tuple, int l4_off)\n",
        "{\n",
        "    struct ipv6_ct_tuple nat_tup = *tuple;\n",
        "    struct ipv6_nat_entry *entry;\n",
        "    int ret = 0;\n",
        "    nat_tup.flags = NAT_DIR_EGRESS;\n",
        "    nat_tup.sport = tuple->dport;\n",
        "    nat_tup.dport = tuple->sport;\n",
        "    entry = snat_v6_lookup (& nat_tup);\n",
        "    if (entry)\n",
        "        ret = snat_v6_rewrite_egress (ctx, &nat_tup, entry, l4_off);\n",
        "    return ret;\n",
        "}\n"
      ],
      "called_function_list": [
        "snat_v6_rewrite_egress",
        "snat_v6_lookup"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "dsr_reply_icmp6": [
    {
      "capabilities": [
        {
          "capability": "read_skb",
          "read_skb": [
            {
              "Project": "cilium",
              "Return Type": "s64",
              "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ",
              "Return": " The checksum result, or a negative error code in case of failure.",
              "Function Name": "csum_diff",
              "Input Params": [
                "{Type: __be32 ,Var: *from}",
                "{Type:  u32 ,Var: from_size}",
                "{Type:  __be32 ,Var: *to}",
                "{Type:  u32 ,Var: to_size}",
                "{Type:  __wsum ,Var: seed}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "xdp",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "lwt_seg6local"
              ],
              "capabilities": [
                "read_skb"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 420,
      "endLine": 492,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h",
      "funcName": "dsr_reply_icmp6",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " const struct ipv6hdr * ip6 __maybe_unused",
        " int code",
        " int ohead __maybe_unused"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "csum_diff"
      ],
      "compatibleHookpoints": [
        "lwt_seg6local",
        "sched_act",
        "xdp",
        "lwt_xmit",
        "sched_cls",
        "lwt_in",
        "lwt_out"
      ],
      "source": [
        "static __always_inline int dsr_reply_icmp6 (struct  __ctx_buff *ctx, const struct ipv6hdr * ip6 __maybe_unused, int code, int ohead __maybe_unused)\n",
        "{\n",
        "\n",
        "#ifdef ENABLE_DSR_ICMP_ERRORS\n",
        "    const __s32 orig_dgram = 64, off = ETH_HLEN;\n",
        "    const __u32 l3_max = sizeof (*ip6) + orig_dgram;\n",
        "    __be16 type = bpf_htons (ETH_P_IPV6);\n",
        "    __u64 len_new = off + sizeof (*ip6) + orig_dgram;\n",
        "    __u64 len_old = ctx_full_len (ctx);\n",
        "    void *data_end = ctx_data_end (ctx);\n",
        "    void *data = ctx_data (ctx);\n",
        "    __u8 reason = (__u8) -code;\n",
        "    __wsum wsum;\n",
        "    union macaddr smac, dmac;\n",
        "    struct icmp6hdr icmp __align_stack_8 = {\n",
        "        .icmp6_type = ICMPV6_PKT_TOOBIG,\n",
        "        .icmp6_mtu = bpf_htonl (THIS_MTU - ohead),}\n",
        "    ;\n",
        "    __u64 payload_len = sizeof (*ip6) + sizeof (icmp) + orig_dgram;\n",
        "    struct ipv6hdr ip __align_stack_8 = {\n",
        "        .version = 6,\n",
        "        .priority = ip6->priority,\n",
        "        .flow_lbl [0] = ip6->flow_lbl[0],\n",
        "        .flow_lbl [1] = ip6->flow_lbl[1],\n",
        "        .flow_lbl [2] = ip6->flow_lbl[2],\n",
        "        .nexthdr = IPPROTO_ICMPV6,\n",
        "        .hop_limit = IPDEFTTL,\n",
        "        .saddr = ip6->daddr,\n",
        "        .daddr = ip6->saddr,\n",
        "        .payload_len = bpf_htons ((__u16) payload_len),}\n",
        "    ;\n",
        "    update_metrics (ctx_full_len (ctx), METRIC_EGRESS, reason);\n",
        "    if (eth_load_saddr (ctx, smac.addr, 0) < 0)\n",
        "        goto drop_err;\n",
        "    if (eth_load_daddr (ctx, dmac.addr, 0) < 0)\n",
        "        goto drop_err;\n",
        "    if (unlikely (data + len_new > data_end))\n",
        "        goto drop_err;\n",
        "    wsum = ipv6_pseudohdr_checksum (& ip, IPPROTO_ICMPV6, bpf_ntohs (ip.payload_len), 0);\n",
        "    icmp.icmp6_cksum = csum_fold (csum_diff (NULL, 0, data + off, l3_max, csum_diff (NULL, 0, &icmp, sizeof (icmp), wsum)));\n",
        "    if (ctx_adjust_troom (ctx, -(len_old - len_new)) < 0)\n",
        "        goto drop_err;\n",
        "    if (ctx_adjust_hroom (ctx, sizeof (ip) + sizeof (icmp), BPF_ADJ_ROOM_NET, ctx_adjust_hroom_dsr_flags ()) < 0)\n",
        "        goto drop_err;\n",
        "    if (eth_store_daddr (ctx, smac.addr, 0) < 0)\n",
        "        goto drop_err;\n",
        "    if (eth_store_saddr (ctx, dmac.addr, 0) < 0)\n",
        "        goto drop_err;\n",
        "    if (ctx_store_bytes (ctx, ETH_ALEN * 2, &type, sizeof (type), 0) < 0)\n",
        "        goto drop_err;\n",
        "    if (ctx_store_bytes (ctx, off, &ip, sizeof (ip), 0) < 0)\n",
        "        goto drop_err;\n",
        "    if (ctx_store_bytes (ctx, off + sizeof (ip), &icmp, sizeof (icmp), 0) < 0)\n",
        "        goto drop_err;\n",
        "    return ctx_redirect (ctx, ctx_get_ifindex (ctx), 0);\n",
        "drop_err :\n",
        "\n",
        "#endif\n",
        "    return send_drop_notify_error (ctx, 0, code, CTX_ACT_DROP, METRIC_EGRESS);\n",
        "}\n"
      ],
      "called_function_list": [
        "csum_fold",
        "ctx_adjust_hroom_dsr_flags",
        "ctx_adjust_hroom",
        "eth_load_daddr",
        "ctx_redirect",
        "update_metrics",
        "ctx_full_len",
        "ctx_data_end",
        "eth_store_daddr",
        "ctx_data",
        "eth_load_saddr",
        "ctx_adjust_troom",
        "ctx_get_ifindex",
        "ipv6_pseudohdr_checksum",
        "eth_store_saddr"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "tail_nodeport_ipv6_dsr": [
    {
      "capabilities": [
        {
          "capability": "read_sys_info",
          "read_sys_info": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Description": "Do FIB lookup in kernel tables using parameters in params. If lookup is successful and result shows packet is to be forwarded , the neighbor tables are searched for the nexthop. If successful (ie. , FIB lookup shows forwarding and nexthop is resolved) , the nexthop address is returned in ipv4_dst or ipv6_dst based on family , smac is set to mac address of egress device , dmac is set to nexthop mac address , rt_metric is set to metric from route (IPv4/IPv6 only) , and ifindex is set to the device index of the nexthop from the FIB lookup. <[ plen ]>(IP: 2) argument is the size of the passed in struct. <[ flags ]>(IP: 3) argument can be a combination of one or more of the following values: BPF_FIB_LOOKUP_DIRECT Do a direct table lookup vs full lookup using FIB rules. BPF_FIB_LOOKUP_OUTPUT Perform lookup from an egress perspective (default is ingress). <[ ctx ]>(IP: 0) is either struct xdp_md for XDP programs or struct sk_buff tc cls_act programs. Return \u00b7 < 0 if any input argument is invalid \u00b7 0 on success (packet is forwarded , nexthop neighbor exists) \u00b7 > 0 one of BPF_FIB_LKUP_RET_ codes explaining why the packet is not forwarded or needs assist from full stack ",
              "Function Name": "fib_lookup",
              "Input Params": [
                "{Type: void ,Var: *ctx}",
                "{Type:  struct fib_lookup ,Var: *params}",
                "{Type:  int ,Var: plen}",
                "{Type:  u32 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "xdp"
              ],
              "capabilities": [
                "read_sys_info"
              ]
            },
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Do FIB lookup in kernel tables using parameters in params. If lookup is successful and result shows packet is to be forwarded , the neighbor tables are searched for the nexthop. If successful (ie. , FIB lookup shows forwarding and nexthop is resolved) , the nexthop address is returned in ipv4_dst or ipv6_dst based on family , smac is set to mac address of egress device , dmac is set to nexthop mac address , rt_metric is set to metric from route (IPv4/IPv6 only) , and ifindex is set to the device index of the nexthop from the FIB lookup. <[ plen ]>(IP: 2) argument is the size of the passed in struct. <[ flags ]>(IP: 3) argument can be a combination of one or more of the following values: BPF_FIB_LOOKUP_DIRECT Do a direct table lookup vs full lookup using FIB rules. BPF_FIB_LOOKUP_OUTPUT Perform lookup from an egress perspective (default is ingress). <[ ctx ]>(IP: 0) is either struct xdp_md for XDP programs or struct sk_buff tc cls_act programs. Return \u00b7 < 0 if any input argument is invalid \u00b7 0 on success (packet is forwarded , nexthop neighbor exists) \u00b7 > 0 one of BPF_FIB_LKUP_RET_ codes explaining why the packet is not forwarded or needs assist from full stack ",
              "Function Name": "bpf_fib_lookup",
              "Input Params": [
                "{Type: void ,Var: *ctx}",
                "{Type:  struct bpf_fib_lookup ,Var: *params}",
                "{Type:  int ,Var: plen}",
                "{Type:  u32 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "xdp"
              ],
              "capabilities": [
                "read_sys_info"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 495,
      "endLine": 571,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h",
      "funcName": "tail_nodeport_ipv6_dsr",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "int",
      "helper": [
        "fib_lookup",
        "bpf_fib_lookup"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "int tail_nodeport_ipv6_dsr (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    struct bpf_fib_lookup_padded fib_params = {\n",
        "        .l = {\n",
        "            .family = AF_INET6,\n",
        "            .ifindex = ctx_get_ifindex (ctx),},}\n",
        "    ;\n",
        "    __u16 port __maybe_unused;\n",
        "    void *data, *data_end;\n",
        "    struct ipv6hdr *ip6;\n",
        "    union v6addr addr;\n",
        "    int ret, ohead = 0;\n",
        "    int ext_err = 0;\n",
        "    bool l2_hdr_required = true;\n",
        "    if (!revalidate_data (ctx, &data, &data_end, &ip6)) {\n",
        "        ret = DROP_INVALID;\n",
        "        goto drop_err;\n",
        "    }\n",
        "    addr.p1 = ctx_load_meta (ctx, CB_ADDR_V6_1);\n",
        "    addr.p2 = ctx_load_meta (ctx, CB_ADDR_V6_2);\n",
        "    addr.p3 = ctx_load_meta (ctx, CB_ADDR_V6_3);\n",
        "    addr.p4 = ctx_load_meta (ctx, CB_ADDR_V6_4);\n",
        "\n",
        "#if DSR_ENCAP_MODE == DSR_ENCAP_IPIP\n",
        "    ret = dsr_set_ipip6 (ctx, ip6, & addr, ctx_load_meta (ctx, CB_HINT), & ohead);\n",
        "\n",
        "#elif DSR_ENCAP_MODE == DSR_ENCAP_NONE\n",
        "    port = (__u16) ctx_load_meta (ctx, CB_PORT);\n",
        "    ret = dsr_set_ext6 (ctx, ip6, & addr, port, & ohead);\n",
        "\n",
        "#else\n",
        "\n",
        "# error \"Invalid load balancer DSR encapsulation mode!\"\n",
        "\n",
        "#endif\n",
        "    if (unlikely (ret)) {\n",
        "        if (dsr_fail_needs_reply (ret))\n",
        "            return dsr_reply_icmp6 (ctx, ip6, ret, ohead);\n",
        "        goto drop_err;\n",
        "    }\n",
        "    if (!revalidate_data (ctx, &data, &data_end, &ip6)) {\n",
        "        ret = DROP_INVALID;\n",
        "        goto drop_err;\n",
        "    }\n",
        "    ipv6_addr_copy ((union v6addr *) &fib_params.l.ipv6_src, (union v6addr *) &ip6->saddr);\n",
        "    ipv6_addr_copy ((union v6addr *) &fib_params.l.ipv6_dst, (union v6addr *) &ip6->daddr);\n",
        "    ret = fib_lookup (ctx, & fib_params.l, sizeof (fib_params), 0);\n",
        "    if (ret != 0) {\n",
        "        ext_err = ret;\n",
        "        ret = DROP_NO_FIB;\n",
        "        goto drop_err;\n",
        "    }\n",
        "    ret = maybe_add_l2_hdr (ctx, fib_params.l.ifindex, & l2_hdr_required);\n",
        "    if (ret != 0)\n",
        "        goto drop_err;\n",
        "    if (!l2_hdr_required)\n",
        "        goto out_send;\n",
        "    if (eth_store_daddr (ctx, fib_params.l.dmac, 0) < 0) {\n",
        "        ret = DROP_WRITE_ERROR;\n",
        "        goto drop_err;\n",
        "    }\n",
        "    if (eth_store_saddr (ctx, fib_params.l.smac, 0) < 0) {\n",
        "        ret = DROP_WRITE_ERROR;\n",
        "        goto drop_err;\n",
        "    }\n",
        "out_send :\n",
        "    cilium_capture_out (ctx);\n",
        "    return ctx_redirect (ctx, fib_params.l.ifindex, 0);\n",
        "drop_err :\n",
        "    return send_drop_notify_error_ext (ctx, 0, ret, ext_err, CTX_ACT_DROP, METRIC_EGRESS);\n",
        "}\n"
      ],
      "called_function_list": [
        "dsr_reply_icmp6",
        "maybe_add_l2_hdr",
        "cilium_capture_out",
        "dsr_set_ipip6",
        "ctx_load_meta",
        "eth_store_daddr",
        "ctx_get_ifindex",
        "ctx_redirect",
        "dsr_fail_needs_reply",
        "dsr_set_ext6",
        "eth_store_saddr",
        "ipv6_addr_copy"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "tail_nodeport_nat_ipv6": [
    {
      "capabilities": [
        {
          "capability": "read_sys_info",
          "read_sys_info": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Description": "Do FIB lookup in kernel tables using parameters in params. If lookup is successful and result shows packet is to be forwarded , the neighbor tables are searched for the nexthop. If successful (ie. , FIB lookup shows forwarding and nexthop is resolved) , the nexthop address is returned in ipv4_dst or ipv6_dst based on family , smac is set to mac address of egress device , dmac is set to nexthop mac address , rt_metric is set to metric from route (IPv4/IPv6 only) , and ifindex is set to the device index of the nexthop from the FIB lookup. <[ plen ]>(IP: 2) argument is the size of the passed in struct. <[ flags ]>(IP: 3) argument can be a combination of one or more of the following values: BPF_FIB_LOOKUP_DIRECT Do a direct table lookup vs full lookup using FIB rules. BPF_FIB_LOOKUP_OUTPUT Perform lookup from an egress perspective (default is ingress). <[ ctx ]>(IP: 0) is either struct xdp_md for XDP programs or struct sk_buff tc cls_act programs. Return \u00b7 < 0 if any input argument is invalid \u00b7 0 on success (packet is forwarded , nexthop neighbor exists) \u00b7 > 0 one of BPF_FIB_LKUP_RET_ codes explaining why the packet is not forwarded or needs assist from full stack ",
              "Function Name": "fib_lookup",
              "Input Params": [
                "{Type: void ,Var: *ctx}",
                "{Type:  struct fib_lookup ,Var: *params}",
                "{Type:  int ,Var: plen}",
                "{Type:  u32 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "xdp"
              ],
              "capabilities": [
                "read_sys_info"
              ]
            },
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Do FIB lookup in kernel tables using parameters in params. If lookup is successful and result shows packet is to be forwarded , the neighbor tables are searched for the nexthop. If successful (ie. , FIB lookup shows forwarding and nexthop is resolved) , the nexthop address is returned in ipv4_dst or ipv6_dst based on family , smac is set to mac address of egress device , dmac is set to nexthop mac address , rt_metric is set to metric from route (IPv4/IPv6 only) , and ifindex is set to the device index of the nexthop from the FIB lookup. <[ plen ]>(IP: 2) argument is the size of the passed in struct. <[ flags ]>(IP: 3) argument can be a combination of one or more of the following values: BPF_FIB_LOOKUP_DIRECT Do a direct table lookup vs full lookup using FIB rules. BPF_FIB_LOOKUP_OUTPUT Perform lookup from an egress perspective (default is ingress). <[ ctx ]>(IP: 0) is either struct xdp_md for XDP programs or struct sk_buff tc cls_act programs. Return \u00b7 < 0 if any input argument is invalid \u00b7 0 on success (packet is forwarded , nexthop neighbor exists) \u00b7 > 0 one of BPF_FIB_LKUP_RET_ codes explaining why the packet is not forwarded or needs assist from full stack ",
              "Function Name": "bpf_fib_lookup",
              "Input Params": [
                "{Type: void ,Var: *ctx}",
                "{Type:  struct bpf_fib_lookup ,Var: *params}",
                "{Type:  int ,Var: plen}",
                "{Type:  u32 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "xdp"
              ],
              "capabilities": [
                "read_sys_info"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 575,
      "endLine": 715,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h",
      "funcName": "tail_nodeport_nat_ipv6",
      "developer_inline_comments": [
        {
          "start_line": 623,
          "end_line": 623,
          "text": "/* fib lookup not necessary when going over tunnel. */"
        },
        {
          "start_line": 637,
          "end_line": 641,
          "text": "/* In case of no mapping, recircle back to main path. SNAT is very\n\t\t * expensive in terms of instructions (since we don't have BPF to\n\t\t * BPF calls as we use tail calls) and complexity, hence this is\n\t\t * done inside a tail call here.\n\t\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "int",
      "helper": [
        "fib_lookup",
        "bpf_fib_lookup"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "int tail_nodeport_nat_ipv6 (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    enum nat_dir dir = (enum nat_dir) ctx_load_meta (ctx, CB_NAT);\n",
        "    const bool nat_46x64 = ctx_load_meta (ctx, CB_NAT_46X64);\n",
        "    union v6addr tmp = IPV6_DIRECT_ROUTING;\n",
        "    struct bpf_fib_lookup_padded fib_params = {\n",
        "        .l = {\n",
        "            .family = AF_INET6,\n",
        "            .ifindex = ctx_get_ifindex (ctx),},}\n",
        "    ;\n",
        "    struct ipv6_nat_target target = {\n",
        "        .min_port = NODEPORT_PORT_MIN_NAT,\n",
        "        .max_port = NODEPORT_PORT_MAX_NAT,\n",
        "        .src_from_world = true,}\n",
        "    ;\n",
        "    bool l2_hdr_required = true;\n",
        "    void *data, *data_end;\n",
        "    struct ipv6hdr *ip6;\n",
        "    int ret, ext_err = 0;\n",
        "    if (nat_46x64)\n",
        "        build_v4_in_v6 (&tmp, IPV4_DIRECT_ROUTING);\n",
        "    target.addr = tmp;\n",
        "\n",
        "#ifdef TUNNEL_MODE\n",
        "    if (dir == NAT_DIR_EGRESS) {\n",
        "        struct remote_endpoint_info *info;\n",
        "        union v6addr *dst;\n",
        "        if (!revalidate_data (ctx, &data, &data_end, &ip6)) {\n",
        "            ret = DROP_INVALID;\n",
        "            goto drop_err;\n",
        "        }\n",
        "        dst = (union v6addr *) &ip6->daddr;\n",
        "        info = ipcache_lookup6 (& IPCACHE_MAP, dst, V6_CACHE_KEY_LEN);\n",
        "        if (info != NULL && info->tunnel_endpoint != 0) {\n",
        "            ret = __encap_with_nodeid (ctx, info -> tunnel_endpoint, WORLD_ID, NOT_VTEP_DST, (enum trace_reason) CT_NEW, TRACE_PAYLOAD_LEN);\n",
        "            if (ret)\n",
        "                goto drop_err;\n",
        "            BPF_V6 (target.addr, ROUTER_IP);\n",
        "            fib_params.l.ifindex = ENCAP_IFINDEX;\n",
        "            if (eth_store_daddr (ctx, fib_params.l.dmac, 0) < 0) {\n",
        "                ret = DROP_WRITE_ERROR;\n",
        "                goto drop_err;\n",
        "            }\n",
        "            if (eth_store_saddr (ctx, fib_params.l.smac, 0) < 0) {\n",
        "                ret = DROP_WRITE_ERROR;\n",
        "                goto drop_err;\n",
        "            }\n",
        "        }\n",
        "    }\n",
        "\n",
        "#endif\n",
        "    ret = snat_v6_process (ctx, dir, & target);\n",
        "    if (IS_ERR (ret)) {\n",
        "        if (dir == NAT_DIR_INGRESS) {\n",
        "            bpf_skip_nodeport_set (ctx);\n",
        "            ep_tail_call (ctx, CILIUM_CALL_IPV6_FROM_NETDEV);\n",
        "            ret = DROP_MISSED_TAIL_CALL;\n",
        "            goto drop_err;\n",
        "        }\n",
        "        if (ret != NAT_PUNT_TO_STACK)\n",
        "            goto drop_err;\n",
        "    }\n",
        "    bpf_mark_snat_done (ctx);\n",
        "    if (dir == NAT_DIR_INGRESS) {\n",
        "        ep_tail_call (ctx, CILIUM_CALL_IPV6_NODEPORT_REVNAT);\n",
        "        ret = DROP_MISSED_TAIL_CALL;\n",
        "        goto drop_err;\n",
        "    }\n",
        "\n",
        "#ifdef TUNNEL_MODE\n",
        "    if (fib_params.l.ifindex == ENCAP_IFINDEX)\n",
        "        goto out_send;\n",
        "\n",
        "#endif\n",
        "    if (!revalidate_data (ctx, &data, &data_end, &ip6)) {\n",
        "        ret = DROP_INVALID;\n",
        "        goto drop_err;\n",
        "    }\n",
        "    if (nat_46x64) {\n",
        "        struct iphdr *ip4;\n",
        "        ret = lb6_to_lb4 (ctx, ip6);\n",
        "        if (ret < 0)\n",
        "            goto drop_err;\n",
        "        if (!revalidate_data (ctx, &data, &data_end, &ip4)) {\n",
        "            ret = DROP_INVALID;\n",
        "            goto drop_err;\n",
        "        }\n",
        "        fib_params.l.ipv4_src = ip4->saddr;\n",
        "        fib_params.l.ipv4_dst = ip4->daddr;\n",
        "        fib_params.l.family = AF_INET;\n",
        "    }\n",
        "    else {\n",
        "        ipv6_addr_copy ((union v6addr *) &fib_params.l.ipv6_src, (union v6addr *) &ip6->saddr);\n",
        "        ipv6_addr_copy ((union v6addr *) &fib_params.l.ipv6_dst, (union v6addr *) &ip6->daddr);\n",
        "    }\n",
        "    ret = fib_lookup (ctx, & fib_params.l, sizeof (fib_params), 0);\n",
        "    if (ret != 0) {\n",
        "        ext_err = ret;\n",
        "        ret = DROP_NO_FIB;\n",
        "        goto drop_err;\n",
        "    }\n",
        "    ret = maybe_add_l2_hdr (ctx, fib_params.l.ifindex, & l2_hdr_required);\n",
        "    if (ret != 0)\n",
        "        goto drop_err;\n",
        "    if (!l2_hdr_required)\n",
        "        goto out_send;\n",
        "    if (eth_store_daddr (ctx, fib_params.l.dmac, 0) < 0) {\n",
        "        ret = DROP_WRITE_ERROR;\n",
        "        goto drop_err;\n",
        "    }\n",
        "    if (eth_store_saddr (ctx, fib_params.l.smac, 0) < 0) {\n",
        "        ret = DROP_WRITE_ERROR;\n",
        "        goto drop_err;\n",
        "    }\n",
        "out_send :\n",
        "    cilium_capture_out (ctx);\n",
        "    return ctx_redirect (ctx, fib_params.l.ifindex, 0);\n",
        "drop_err :\n",
        "    return send_drop_notify_error_ext (ctx, 0, ret, ext_err, CTX_ACT_DROP, dir == NAT_DIR_INGRESS ? METRIC_INGRESS : METRIC_EGRESS);\n",
        "}\n"
      ],
      "called_function_list": [
        "bpf_skip_nodeport_set",
        "ipcache_lookup6",
        "cilium_capture_out",
        "ctx_redirect",
        "ipv6_addr_copy",
        "maybe_add_l2_hdr",
        "ep_tail_call",
        "eth_store_daddr",
        "build_v4_in_v6",
        "lb6_to_lb4",
        "bpf_mark_snat_done",
        "__encap_with_nodeid",
        "snat_v6_process",
        "ctx_get_ifindex",
        "ctx_load_meta",
        "eth_store_saddr"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "nodeport_lb6": [
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        },
        {
          "capability": "map_update",
          "map_update": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "map_update_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}",
                "{Type:  const void ,Var: *value}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_update"
              ]
            }
          ]
        },
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 718,
      "endLine": 881,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h",
      "funcName": "nodeport_lb6",
      "developer_inline_comments": [
        {
          "start_line": 717,
          "end_line": 717,
          "text": "/* See nodeport_lb4(). */"
        },
        {
          "start_line": 859,
          "end_line": 859,
          "text": "/* DSR_ENCAP_MODE */"
        },
        {
          "start_line": 863,
          "end_line": 869,
          "text": "/* This code path is not only hit for NAT64, but also\n\t\t\t * for NAT46. For the latter we initially hit the IPv4\n\t\t\t * NodePort path, then migrate the request to IPv6 and\n\t\t\t * recirculate into the regular IPv6 NodePort path. So\n\t\t\t * we need to make sure to not NAT back to IPv4 for\n\t\t\t * IPv4-in-IPv6 converted addresses.\n\t\t\t */"
        }
      ],
      "updateMaps": [
        "  NODEPORT_NEIGH6"
      ],
      "readMaps": [
        "  NODEPORT_NEIGH6"
      ],
      "input": [
        "struct  __ctx_buff *ctx",
        " __u32 src_identity"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "CTX_ACT_OK",
        "map_update_elem",
        "map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "static __always_inline int nodeport_lb6 (struct  __ctx_buff *ctx, __u32 src_identity)\n",
        "{\n",
        "    int ret, l3_off = ETH_HLEN, l4_off, hdrlen;\n",
        "    struct ipv6_ct_tuple tuple = {}\n",
        "    ;\n",
        "    void *data, *data_end;\n",
        "    struct ipv6hdr *ip6;\n",
        "    struct csum_offset csum_off = {}\n",
        "    ;\n",
        "    struct lb6_service *svc;\n",
        "    struct lb6_key key = {}\n",
        "    ;\n",
        "    struct ct_state ct_state_new = {}\n",
        "    ;\n",
        "    union macaddr smac, *mac;\n",
        "    bool backend_local;\n",
        "    __u32 monitor = 0;\n",
        "    cilium_capture_in (ctx);\n",
        "    if (!revalidate_data (ctx, &data, &data_end, &ip6))\n",
        "        return DROP_INVALID;\n",
        "    tuple.nexthdr = ip6->nexthdr;\n",
        "    ipv6_addr_copy (&tuple.daddr, (union v6addr *) &ip6->daddr);\n",
        "    ipv6_addr_copy (&tuple.saddr, (union v6addr *) &ip6->saddr);\n",
        "    hdrlen = ipv6_hdrlen (ctx, & tuple.nexthdr);\n",
        "    if (hdrlen < 0)\n",
        "        return hdrlen;\n",
        "    l4_off = l3_off + hdrlen;\n",
        "    ret = lb6_extract_key (ctx, & tuple, l4_off, & key, & csum_off, CT_EGRESS);\n",
        "    if (IS_ERR (ret)) {\n",
        "        if (ret == DROP_NO_SERVICE)\n",
        "            goto skip_service_lookup;\n",
        "        else if (ret == DROP_UNKNOWN_L4)\n",
        "            return CTX_ACT_OK;\n",
        "        else\n",
        "            return ret;\n",
        "    }\n",
        "    svc = lb6_lookup_service (& key, false);\n",
        "    if (svc) {\n",
        "        const bool skip_l3_xlate = DSR_ENCAP_MODE == DSR_ENCAP_IPIP;\n",
        "        if (!lb6_src_range_ok (svc, (union v6addr *) &ip6->saddr))\n",
        "            return DROP_NOT_IN_SRC_RANGE;\n",
        "\n",
        "#if defined(ENABLE_L7_LB)\n",
        "        if (lb6_svc_is_l7loadbalancer (svc) && svc->l7_lb_proxy_port > 0) {\n",
        "            send_trace_notify (ctx, TRACE_TO_PROXY, src_identity, 0, bpf_ntohs ((__u16) svc->l7_lb_proxy_port), 0, TRACE_REASON_POLICY, monitor);\n",
        "            return ctx_redirect_to_proxy_hairpin_ipv6 (ctx, (__be16) svc->l7_lb_proxy_port);\n",
        "        }\n",
        "\n",
        "#endif\n",
        "        ret = lb6_local (get_ct_map6 (& tuple), ctx, l3_off, l4_off, & csum_off, & key, & tuple, svc, & ct_state_new, skip_l3_xlate);\n",
        "        if (IS_ERR (ret))\n",
        "            return ret;\n",
        "    }\n",
        "    if (!svc || !lb6_svc_is_routable (svc)) {\n",
        "        if (svc)\n",
        "            return DROP_IS_CLUSTER_IP;\n",
        "    skip_service_lookup :\n",
        "        ctx_set_xfer (ctx, XFER_PKT_NO_SVC);\n",
        "        if (nodeport_uses_dsr6 (&tuple))\n",
        "            return CTX_ACT_OK;\n",
        "        ctx_store_meta (ctx, CB_NAT, NAT_DIR_INGRESS);\n",
        "        ctx_store_meta (ctx, CB_NAT_46X64, 0);\n",
        "        ctx_store_meta (ctx, CB_SRC_IDENTITY, src_identity);\n",
        "        ep_tail_call (ctx, CILIUM_CALL_IPV6_NODEPORT_NAT);\n",
        "        return DROP_MISSED_TAIL_CALL;\n",
        "    }\n",
        "    backend_local = __lookup_ip6_endpoint (& tuple.daddr);\n",
        "    if (!backend_local && lb6_svc_is_hostport (svc))\n",
        "        return DROP_INVALID;\n",
        "    if (backend_local || !nodeport_uses_dsr6 (&tuple)) {\n",
        "        struct ct_state ct_state = {}\n",
        "        ;\n",
        "        ret = ct_lookup6 (get_ct_map6 (& tuple), & tuple, ctx, l4_off, CT_EGRESS, & ct_state, & monitor);\n",
        "        switch (ret) {\n",
        "        case CT_NEW :\n",
        "        redo :\n",
        "            ct_state_new.src_sec_id = WORLD_ID;\n",
        "            ct_state_new.node_port = 1;\n",
        "            ct_state_new.ifindex = (__u16) NATIVE_DEV_IFINDEX;\n",
        "            ret = ct_create6 (get_ct_map6 (& tuple), NULL, & tuple, ctx, CT_EGRESS, & ct_state_new, false, false);\n",
        "            if (IS_ERR (ret))\n",
        "                return ret;\n",
        "            break;\n",
        "        case CT_REOPENED :\n",
        "        case CT_ESTABLISHED :\n",
        "        case CT_REPLY :\n",
        "            if (unlikely (ct_state.rev_nat_index != svc->rev_nat_index))\n",
        "                goto redo;\n",
        "            break;\n",
        "        default :\n",
        "            return DROP_UNKNOWN_CT;\n",
        "        }\n",
        "        if (!revalidate_data (ctx, &data, &data_end, &ip6))\n",
        "            return DROP_INVALID;\n",
        "        if (eth_load_saddr (ctx, smac.addr, 0) < 0)\n",
        "            return DROP_INVALID;\n",
        "        mac = map_lookup_elem (& NODEPORT_NEIGH6, & ip6 -> saddr);\n",
        "        if (!mac || eth_addrcmp (mac, &smac)) {\n",
        "            ret = map_update_elem (& NODEPORT_NEIGH6, & ip6 -> saddr, & smac, 0);\n",
        "            if (ret < 0)\n",
        "                return ret;\n",
        "        }\n",
        "    }\n",
        "    if (!backend_local) {\n",
        "        edt_set_aggregate (ctx, 0);\n",
        "        if (nodeport_uses_dsr6 (&tuple)) {\n",
        "\n",
        "#if DSR_ENCAP_MODE == DSR_ENCAP_IPIP\n",
        "            ctx_store_meta (ctx, CB_HINT, ((__u32) tuple.sport << 16) | tuple.dport);\n",
        "            ctx_store_meta (ctx, CB_ADDR_V6_1, tuple.daddr.p1);\n",
        "            ctx_store_meta (ctx, CB_ADDR_V6_2, tuple.daddr.p2);\n",
        "            ctx_store_meta (ctx, CB_ADDR_V6_3, tuple.daddr.p3);\n",
        "            ctx_store_meta (ctx, CB_ADDR_V6_4, tuple.daddr.p4);\n",
        "\n",
        "#elif DSR_ENCAP_MODE == DSR_ENCAP_NONE\n",
        "            ctx_store_meta (ctx, CB_PORT, key.dport);\n",
        "            ctx_store_meta (ctx, CB_ADDR_V6_1, key.address.p1);\n",
        "            ctx_store_meta (ctx, CB_ADDR_V6_2, key.address.p2);\n",
        "            ctx_store_meta (ctx, CB_ADDR_V6_3, key.address.p3);\n",
        "            ctx_store_meta (ctx, CB_ADDR_V6_4, key.address.p4);\n",
        "\n",
        "#endif /* DSR_ENCAP_MODE */\n",
        "            ep_tail_call (ctx, CILIUM_CALL_IPV6_NODEPORT_DSR);\n",
        "        }\n",
        "        else {\n",
        "            ctx_store_meta (ctx, CB_NAT, NAT_DIR_EGRESS);\n",
        "            ctx_store_meta (ctx, CB_NAT_46X64, !is_v4_in_v6 (&key.address) && lb6_to_lb4_service (svc));\n",
        "            ep_tail_call (ctx, CILIUM_CALL_IPV6_NODEPORT_NAT);\n",
        "        }\n",
        "        return DROP_MISSED_TAIL_CALL;\n",
        "    }\n",
        "    ctx_set_xfer (ctx, XFER_PKT_NO_SVC);\n",
        "    return CTX_ACT_OK;\n",
        "}\n"
      ],
      "called_function_list": [
        "nodeport_uses_dsr6",
        "ctx_set_xfer",
        "lb6_svc_is_hostport",
        "cilium_capture_in",
        "is_v4_in_v6",
        "ctx_store_meta",
        "lb6_extract_key",
        "lb6_lookup_service",
        "__lookup_ip6_endpoint",
        "eth_addrcmp",
        "ipv6_addr_copy",
        "lb6_src_range_ok",
        "ct_lookup6",
        "ipv6_hdrlen",
        "edt_set_aggregate",
        "ctx_redirect_to_proxy_hairpin_ipv6",
        "lb6_svc_is_routable",
        "ep_tail_call",
        "send_trace_notify",
        "lb6_svc_is_l7loadbalancer",
        "ct_create6",
        "get_ct_map6",
        "eth_load_saddr",
        "lb6_local",
        "lb6_to_lb4_service"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "rev_nodeport_lb6": [
    {
      "capabilities": [
        {
          "capability": "read_sys_info",
          "read_sys_info": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Description": "Do FIB lookup in kernel tables using parameters in params. If lookup is successful and result shows packet is to be forwarded , the neighbor tables are searched for the nexthop. If successful (ie. , FIB lookup shows forwarding and nexthop is resolved) , the nexthop address is returned in ipv4_dst or ipv6_dst based on family , smac is set to mac address of egress device , dmac is set to nexthop mac address , rt_metric is set to metric from route (IPv4/IPv6 only) , and ifindex is set to the device index of the nexthop from the FIB lookup. <[ plen ]>(IP: 2) argument is the size of the passed in struct. <[ flags ]>(IP: 3) argument can be a combination of one or more of the following values: BPF_FIB_LOOKUP_DIRECT Do a direct table lookup vs full lookup using FIB rules. BPF_FIB_LOOKUP_OUTPUT Perform lookup from an egress perspective (default is ingress). <[ ctx ]>(IP: 0) is either struct xdp_md for XDP programs or struct sk_buff tc cls_act programs. Return \u00b7 < 0 if any input argument is invalid \u00b7 0 on success (packet is forwarded , nexthop neighbor exists) \u00b7 > 0 one of BPF_FIB_LKUP_RET_ codes explaining why the packet is not forwarded or needs assist from full stack ",
              "Function Name": "fib_lookup",
              "Input Params": [
                "{Type: void ,Var: *ctx}",
                "{Type:  struct fib_lookup ,Var: *params}",
                "{Type:  int ,Var: plen}",
                "{Type:  u32 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "xdp"
              ],
              "capabilities": [
                "read_sys_info"
              ]
            },
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Do FIB lookup in kernel tables using parameters in params. If lookup is successful and result shows packet is to be forwarded , the neighbor tables are searched for the nexthop. If successful (ie. , FIB lookup shows forwarding and nexthop is resolved) , the nexthop address is returned in ipv4_dst or ipv6_dst based on family , smac is set to mac address of egress device , dmac is set to nexthop mac address , rt_metric is set to metric from route (IPv4/IPv6 only) , and ifindex is set to the device index of the nexthop from the FIB lookup. <[ plen ]>(IP: 2) argument is the size of the passed in struct. <[ flags ]>(IP: 3) argument can be a combination of one or more of the following values: BPF_FIB_LOOKUP_DIRECT Do a direct table lookup vs full lookup using FIB rules. BPF_FIB_LOOKUP_OUTPUT Perform lookup from an egress perspective (default is ingress). <[ ctx ]>(IP: 0) is either struct xdp_md for XDP programs or struct sk_buff tc cls_act programs. Return \u00b7 < 0 if any input argument is invalid \u00b7 0 on success (packet is forwarded , nexthop neighbor exists) \u00b7 > 0 one of BPF_FIB_LKUP_RET_ codes explaining why the packet is not forwarded or needs assist from full stack ",
              "Function Name": "bpf_fib_lookup",
              "Input Params": [
                "{Type: void ,Var: *ctx}",
                "{Type:  struct bpf_fib_lookup ,Var: *params}",
                "{Type:  int ,Var: plen}",
                "{Type:  u32 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "xdp"
              ],
              "capabilities": [
                "read_sys_info"
              ]
            }
          ]
        },
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        },
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 884,
      "endLine": 1006,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h",
      "funcName": "rev_nodeport_lb6",
      "developer_inline_comments": [
        {
          "start_line": 883,
          "end_line": 883,
          "text": "/* See comment in tail_rev_nodeport_lb4(). */"
        },
        {
          "start_line": 943,
          "end_line": 943,
          "text": "/* fib lookup not necessary when going over tunnel. */"
        },
        {
          "start_line": 981,
          "end_line": 981,
          "text": "/* See comment in rev_nodeport_lb4(). */"
        }
      ],
      "updateMaps": [],
      "readMaps": [
        "  NODEPORT_NEIGH6"
      ],
      "input": [
        "struct  __ctx_buff *ctx",
        " int *ifindex",
        " int *ext_err"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "fib_lookup",
        "CTX_ACT_OK",
        "bpf_fib_lookup",
        "map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "static __always_inline int rev_nodeport_lb6 (struct  __ctx_buff *ctx, int *ifindex, int *ext_err)\n",
        "{\n",
        "    int ret, fib_ret, ret2, l3_off = ETH_HLEN, l4_off, hdrlen;\n",
        "    struct ipv6_ct_tuple tuple = {}\n",
        "    ;\n",
        "    void *data, *data_end;\n",
        "    struct ipv6hdr *ip6;\n",
        "    struct csum_offset csum_off = {}\n",
        "    ;\n",
        "    struct ct_state ct_state = {}\n",
        "    ;\n",
        "    struct bpf_fib_lookup fib_params = {}\n",
        "    ;\n",
        "    __u32 monitor = 0;\n",
        "    bool l2_hdr_required = true;\n",
        "    if (!revalidate_data (ctx, &data, &data_end, &ip6))\n",
        "        return DROP_INVALID;\n",
        "    tuple.nexthdr = ip6->nexthdr;\n",
        "    ipv6_addr_copy (&tuple.daddr, (union v6addr *) &ip6->daddr);\n",
        "    ipv6_addr_copy (&tuple.saddr, (union v6addr *) &ip6->saddr);\n",
        "    hdrlen = ipv6_hdrlen (ctx, & tuple.nexthdr);\n",
        "    if (hdrlen < 0)\n",
        "        return hdrlen;\n",
        "    l4_off = l3_off + hdrlen;\n",
        "    csum_l4_offset_and_flags (tuple.nexthdr, &csum_off);\n",
        "    ret = ct_lookup6 (get_ct_map6 (& tuple), & tuple, ctx, l4_off, CT_INGRESS, & ct_state, & monitor);\n",
        "    if (ret == CT_REPLY && ct_state.node_port == 1 && ct_state.rev_nat_index != 0) {\n",
        "        ret2 = lb6_rev_nat (ctx, l4_off, & csum_off, ct_state.rev_nat_index, & tuple, REV_NAT_F_TUPLE_SADDR);\n",
        "        if (IS_ERR (ret2))\n",
        "            return ret2;\n",
        "        if (!revalidate_data (ctx, &data, &data_end, &ip6))\n",
        "            return DROP_INVALID;\n",
        "        bpf_mark_snat_done (ctx);\n",
        "        *ifindex = ct_state.ifindex;\n",
        "\n",
        "#ifdef TUNNEL_MODE\n",
        "        {\n",
        "            union v6addr *dst = (union v6addr *) &ip6->daddr;\n",
        "            struct remote_endpoint_info *info;\n",
        "            info = ipcache_lookup6 (& IPCACHE_MAP, dst, V6_CACHE_KEY_LEN);\n",
        "            if (info != NULL && info->tunnel_endpoint != 0) {\n",
        "                ret = __encap_with_nodeid (ctx, info -> tunnel_endpoint, SECLABEL, NOT_VTEP_DST, TRACE_REASON_CT_REPLY, TRACE_PAYLOAD_LEN);\n",
        "                if (ret)\n",
        "                    return ret;\n",
        "                *ifindex = ENCAP_IFINDEX;\n",
        "                if (eth_store_daddr (ctx, fib_params.dmac, 0) < 0)\n",
        "                    return DROP_WRITE_ERROR;\n",
        "                if (eth_store_saddr (ctx, fib_params.smac, 0) < 0)\n",
        "                    return DROP_WRITE_ERROR;\n",
        "                return CTX_ACT_OK;\n",
        "            }\n",
        "        }\n",
        "\n",
        "#endif\n",
        "        fib_params.family = AF_INET6;\n",
        "        fib_params.ifindex = ctx_get_ifindex (ctx);\n",
        "        ipv6_addr_copy ((union v6addr *) &fib_params.ipv6_src, &tuple.saddr);\n",
        "        ipv6_addr_copy ((union v6addr *) &fib_params.ipv6_dst, &tuple.daddr);\n",
        "        fib_ret = fib_lookup (ctx, & fib_params, sizeof (fib_params), 0);\n",
        "        if (fib_ret == 0)\n",
        "            *ifindex = fib_params.ifindex;\n",
        "        ret = maybe_add_l2_hdr (ctx, * ifindex, & l2_hdr_required);\n",
        "        if (ret != 0)\n",
        "            return ret;\n",
        "        if (!l2_hdr_required)\n",
        "            return CTX_ACT_OK;\n",
        "        if (fib_ret != 0) {\n",
        "            union macaddr smac = NATIVE_DEV_MAC_BY_IFINDEX (* ifindex);\n",
        "            union macaddr *dmac;\n",
        "            if (fib_ret != BPF_FIB_LKUP_RET_NO_NEIGH) {\n",
        "                *ext_err = fib_ret;\n",
        "                return DROP_NO_FIB;\n",
        "            }\n",
        "            dmac = map_lookup_elem (& NODEPORT_NEIGH6, & tuple.daddr);\n",
        "            if (unlikely (!dmac)) {\n",
        "                *ext_err = fib_ret;\n",
        "                return DROP_NO_FIB;\n",
        "            }\n",
        "            if (eth_store_daddr_aligned (ctx, dmac->addr, 0) < 0)\n",
        "                return DROP_WRITE_ERROR;\n",
        "            if (eth_store_saddr_aligned (ctx, smac.addr, 0) < 0)\n",
        "                return DROP_WRITE_ERROR;\n",
        "        }\n",
        "        else {\n",
        "            if (eth_store_daddr (ctx, fib_params.dmac, 0) < 0)\n",
        "                return DROP_WRITE_ERROR;\n",
        "            if (eth_store_saddr (ctx, fib_params.smac, 0) < 0)\n",
        "                return DROP_WRITE_ERROR;\n",
        "        }\n",
        "    }\n",
        "    else {\n",
        "        if (!bpf_skip_recirculation (ctx)) {\n",
        "            bpf_skip_nodeport_set (ctx);\n",
        "            ep_tail_call (ctx, CILIUM_CALL_IPV6_FROM_NETDEV);\n",
        "            return DROP_MISSED_TAIL_CALL;\n",
        "        }\n",
        "    }\n",
        "    return CTX_ACT_OK;\n",
        "}\n"
      ],
      "called_function_list": [
        "bpf_skip_nodeport_set",
        "ipcache_lookup6",
        "lb6_rev_nat",
        "ipv6_addr_copy",
        "ct_lookup6",
        "ipv6_hdrlen",
        "maybe_add_l2_hdr",
        "ep_tail_call",
        "eth_store_daddr",
        "eth_store_saddr_aligned",
        "get_ct_map6",
        "bpf_mark_snat_done",
        "__encap_with_nodeid",
        "ctx_get_ifindex",
        "bpf_skip_recirculation",
        "eth_store_daddr_aligned",
        "eth_store_saddr",
        "csum_l4_offset_and_flags"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "tail_rev_nodeport_lb6": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1009,
      "endLine": 1052,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h",
      "funcName": "tail_rev_nodeport_lb6",
      "developer_inline_comments": [
        {
          "start_line": 1017,
          "end_line": 1019,
          "text": "/* We only enforce the host policies if nodeport.h is included from\n\t * bpf_host.\n\t */"
        },
        {
          "start_line": 1030,
          "end_line": 1032,
          "text": "/* We don't want to enforce host policies a second time if we jump back to\n\t * bpf_host's handle_ipv6.\n\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "int",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "int tail_rev_nodeport_lb6 (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    int ifindex = 0, ret = 0;\n",
        "    void *data, *data_end;\n",
        "    struct ipv6hdr *ip6;\n",
        "    int ext_err = 0;\n",
        "\n",
        "#if defined(ENABLE_HOST_FIREWALL) && defined(IS_BPF_HOST)\n",
        "    struct trace_ctx __maybe_unused trace = {\n",
        "        .reason = TRACE_REASON_UNKNOWN,\n",
        "        .monitor = 0,}\n",
        "    ;\n",
        "    __u32 src_id = 0;\n",
        "    ret = ipv6_host_policy_ingress (ctx, & src_id, & trace);\n",
        "    if (IS_ERR (ret))\n",
        "        return send_drop_notify_error (ctx, src_id, ret, CTX_ACT_DROP, METRIC_INGRESS);\n",
        "    ctx_skip_host_fw_set (ctx);\n",
        "\n",
        "#endif\n",
        "    ret = rev_nodeport_lb6 (ctx, & ifindex, & ext_err);\n",
        "    if (IS_ERR (ret))\n",
        "        goto drop;\n",
        "    if (!revalidate_data (ctx, &data, &data_end, &ip6))\n",
        "        goto drop;\n",
        "    if (is_v4_in_v6 ((union v6addr *) &ip6->saddr)) {\n",
        "        ret = lb6_to_lb4 (ctx, ip6);\n",
        "        if (ret)\n",
        "            goto drop;\n",
        "    }\n",
        "    edt_set_aggregate (ctx, 0);\n",
        "    cilium_capture_out (ctx);\n",
        "    return ctx_redirect (ctx, ifindex, 0);\n",
        "drop :\n",
        "    return send_drop_notify_error_ext (ctx, 0, ret, ext_err, CTX_ACT_DROP, METRIC_EGRESS);\n",
        "}\n"
      ],
      "called_function_list": [
        "is_v4_in_v6",
        "edt_set_aggregate",
        "cilium_capture_out",
        "ctx_redirect",
        "ctx_skip_host_fw_set",
        "lb6_to_lb4",
        "rev_nodeport_lb6",
        "ipv6_host_policy_ingress"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "tail_handle_nat_fwd_ipv6": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1059,
      "endLine": 1078,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h",
      "funcName": "tail_handle_nat_fwd_ipv6",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "int",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "int tail_handle_nat_fwd_ipv6 (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    int ret;\n",
        "    enum trace_point obs_point;\n",
        "\n",
        "#if defined(TUNNEL_MODE) && defined(IS_BPF_OVERLAY)\n",
        "    union v6addr addr = {\n",
        "        .p1 = 0}\n",
        "    ;\n",
        "    BPF_V6 (addr, ROUTER_IP);\n",
        "    obs_point = TRACE_TO_OVERLAY;\n",
        "\n",
        "#else\n",
        "    union v6addr addr = IPV6_DIRECT_ROUTING;\n",
        "    obs_point = TRACE_TO_NETWORK;\n",
        "\n",
        "#endif\n",
        "    ret = nodeport_nat_ipv6_fwd (ctx, & addr);\n",
        "    if (IS_ERR (ret))\n",
        "        return send_drop_notify_error (ctx, 0, ret, CTX_ACT_DROP, METRIC_EGRESS);\n",
        "    send_trace_notify (ctx, obs_point, 0, 0, 0, 0, TRACE_REASON_UNKNOWN, 0);\n",
        "    return ret;\n",
        "}\n"
      ],
      "called_function_list": [
        "nodeport_nat_ipv6_fwd",
        "send_trace_notify"
      ],
      "call_depth": 4,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "nodeport_uses_dsr4": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1082,
      "endLine": 1085,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h",
      "funcName": "nodeport_uses_dsr4",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct ipv4_ct_tuple *tuple"
      ],
      "output": "static__always_inlinebool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline bool nodeport_uses_dsr4 (const struct ipv4_ct_tuple *tuple)\n",
        "{\n",
        "    return nodeport_uses_dsr (tuple->nexthdr);\n",
        "}\n"
      ],
      "called_function_list": [
        "nodeport_uses_dsr"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "snat_v4_needed": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1101,
      "endLine": 1259,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h",
      "funcName": "snat_v4_needed",
      "developer_inline_comments": [
        {
          "start_line": 1087,
          "end_line": 1100,
          "text": "/* The function contains a core logic for deciding whether an egressing packet\n * has to be SNAT-ed. Currently, the function targets the following flows:\n *\n *\t- From pod to outside to masquerade requests\n *\t  when --enable-bpf-masquerade=true.\n *\t- From host to outside to track (and masquerade) flows which\n *\t  can conflict with NodePort BPF.\n *\n * The function sets \"addr\" to the SNAT IP addr, and \"from_endpoint\" to true\n * if the packet is sent from a local endpoint.\n *\n * Callers should treat contents of \"from_endpoint\" and \"addr\" as undetermined,\n * if function returns false.\n */"
        },
        {
          "start_line": 1114,
          "end_line": 1117,
          "text": "/* Basic minimum is to only NAT when there is a potential of\n\t * overlapping tuples, e.g. applications in hostns reusing\n\t * source IPs we SNAT in NodePort and BPF-masq.\n\t */"
        },
        {
          "start_line": 1124,
          "end_line": 1127,
          "text": "/* NATIVE_DEV_IFINDEX == DIRECT_ROUTING_DEV_IFINDEX cannot be moved into\n     * preprocessor, as the former is known only during load time (templating).\n     * This checks whether bpf_host is running on the direct routing device.\n     */"
        },
        {
          "start_line": 1139,
          "end_line": 1139,
          "text": "/* defined(TUNNEL_MODE) && defined(IS_BPF_OVERLAY) */"
        },
        {
          "start_line": 1144,
          "end_line": 1150,
          "text": "/* Check if this packet belongs to reply traffic coming from a\n\t * local endpoint.\n\t *\n\t * If local_ep is NULL, it means there's no endpoint running on the\n\t * node which matches the packet source IP, which means we can\n\t * skip the CT lookup since this cannot be reply traffic.\n\t */"
        },
        {
          "start_line": 1162,
          "end_line": 1162,
          "text": "/* SNAT local pod to world packets */"
        },
        {
          "start_line": 1164,
          "end_line": 1167,
          "text": "/* Do not MASQ when this function is executed from bpf_overlay\n\t * (IS_BPF_OVERLAY denotes this fact). Otherwise, a packet will\n\t * be SNAT'd to cilium_host IP addr.\n\t */"
        },
        {
          "start_line": 1171,
          "end_line": 1176,
          "text": "/* Check if the packet matches an egress NAT policy and so needs to be SNAT'ed.\n *\n * This check must happen before the IPV4_SNAT_EXCLUSION_DST_CIDR check below as\n * the destination may be in the SNAT exclusion CIDR but regardless of that we\n * always want to SNAT a packet if it's matched by an egress NAT policy.\n */"
        },
        {
          "start_line": 1178,
          "end_line": 1181,
          "text": "/* If the packet is destined to an entity inside the cluster, either EP\n\t * or node, skip SNAT since only traffic leaving the cluster is supposed\n\t * to be masqueraded with an egress IP.\n\t */"
        },
        {
          "start_line": 1186,
          "end_line": 1188,
          "text": "/* If the packet is a reply it means that outside has initiated the\n\t * connection, so no need to SNAT the reply.\n\t */"
        },
        {
          "start_line": 1205,
          "end_line": 1210,
          "text": "/* Do not MASQ if a dst IP belongs to a pods CIDR\n\t * (ipv4-native-routing-cidr if specified, otherwise local pod CIDR).\n\t * The check is performed before we determine that a packet is\n\t * sent from a local pod, as this check is cheaper than\n\t * the map lookup done in the latter check.\n\t */"
        },
        {
          "start_line": 1216,
          "end_line": 1216,
          "text": "/* if this is a localhost endpoint, no SNAT is needed */"
        },
        {
          "start_line": 1222,
          "end_line": 1224,
          "text": "/* Do not SNAT if dst belongs to any ip-masq-agent\n\t\t * subnet.\n\t\t */"
        },
        {
          "start_line": 1233,
          "end_line": 1241,
          "text": "/* In the tunnel mode, a packet from a local ep\n\t\t * to a remote node is not encap'd, and is sent\n\t\t * via a native dev. Therefore, such packet has\n\t\t * to be MASQ'd. Otherwise, it might be dropped\n\t\t * either by underlying network (e.g. AWS drops\n\t\t * packets by default from unknown subnets) or\n\t\t * by the remote node if its native dev's\n\t\t * rp_filter=1.\n\t\t */"
        },
        {
          "start_line": 1246,
          "end_line": 1249,
          "text": "/* If the packet is a reply it means that outside has\n\t\t * initiated the connection, so no need to SNAT the\n\t\t * reply.\n\t\t */"
        },
        {
          "start_line": 1256,
          "end_line": 1256,
          "text": "/*ENABLE_MASQUERADE */"
        }
      ],
      "updateMaps": [],
      "readMaps": [
        " IP_MASQ_AGENT_IPV4"
      ],
      "input": [
        "struct  __ctx_buff *ctx",
        " __be32 *addr",
        " bool * from_endpoint __maybe_unused"
      ],
      "output": "static__always_inlinebool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline bool snat_v4_needed (struct  __ctx_buff *ctx, __be32 *addr, bool * from_endpoint __maybe_unused)\n",
        "{\n",
        "    void *data, *data_end;\n",
        "    struct iphdr *ip4;\n",
        "    struct endpoint_info * local_ep __maybe_unused;\n",
        "    struct remote_endpoint_info * remote_ep __maybe_unused;\n",
        "    struct egress_gw_policy_entry * egress_gw_policy __maybe_unused;\n",
        "    bool is_reply = false;\n",
        "    if (!revalidate_data (ctx, &data, &data_end, &ip4))\n",
        "        return false;\n",
        "\n",
        "#if defined(TUNNEL_MODE) && defined(IS_BPF_OVERLAY)\n",
        "    if (ip4->saddr == IPV4_GATEWAY) {\n",
        "        *addr = IPV4_GATEWAY;\n",
        "        return true;\n",
        "    }\n",
        "\n",
        "#else\n",
        "    if (DIRECT_ROUTING_DEV_IFINDEX == NATIVE_DEV_IFINDEX && ip4->saddr == IPV4_DIRECT_ROUTING) {\n",
        "        *addr = IPV4_DIRECT_ROUTING;\n",
        "        return true;\n",
        "    }\n",
        "\n",
        "# ifdef ENABLE_MASQUERADE\n",
        "    if (ip4->saddr == IPV4_MASQUERADE) {\n",
        "        *addr = IPV4_MASQUERADE;\n",
        "        return true;\n",
        "    }\n",
        "\n",
        "# endif\n",
        "\n",
        "#endif /* defined(TUNNEL_MODE) && defined(IS_BPF_OVERLAY) */\n",
        "    local_ep = __lookup_ip4_endpoint (ip4 -> saddr);\n",
        "    remote_ep = lookup_ip4_remote_endpoint (ip4 -> daddr);\n",
        "    if (local_ep) {\n",
        "        struct ipv4_ct_tuple tuple = {\n",
        "            .nexthdr = ip4->protocol,\n",
        "            .daddr = ip4->daddr,\n",
        "            .saddr = ip4->saddr}\n",
        "        ;\n",
        "        ct_is_reply4 (get_ct_map4 (&tuple), ctx, ETH_HLEN + ipv4_hdrlen (ip4), &tuple, &is_reply);\n",
        "    }\n",
        "\n",
        "#ifdef ENABLE_MASQUERADE /* SNAT local pod to world packets */\n",
        "\n",
        "# ifdef IS_BPF_OVERLAY\n",
        "    return false;\n",
        "\n",
        "# endif\n",
        "\n",
        "#if defined(ENABLE_EGRESS_GATEWAY)\n",
        "    if (remote_ep && identity_is_cluster (remote_ep->sec_label))\n",
        "        goto skip_egress_gateway;\n",
        "    if (is_reply)\n",
        "        goto skip_egress_gateway;\n",
        "    egress_gw_policy = lookup_ip4_egress_gw_policy (ip4 -> saddr, ip4 -> daddr);\n",
        "    if (!egress_gw_policy)\n",
        "        goto skip_egress_gateway;\n",
        "    *addr = egress_gw_policy->egress_ip;\n",
        "    *from_endpoint = true;\n",
        "    return true;\n",
        "skip_egress_gateway :\n",
        "\n",
        "#endif\n",
        "\n",
        "#ifdef IPV4_SNAT_EXCLUSION_DST_CIDR\n",
        "    if (ipv4_is_in_subnet (ip4->daddr, IPV4_SNAT_EXCLUSION_DST_CIDR, IPV4_SNAT_EXCLUSION_DST_CIDR_LEN))\n",
        "        return false;\n",
        "\n",
        "#endif\n",
        "    if (local_ep && (local_ep->flags & ENDPOINT_F_HOST))\n",
        "        return false;\n",
        "    if (remote_ep) {\n",
        "\n",
        "#ifdef ENABLE_IP_MASQ_AGENT\n",
        "        struct lpm_v4_key pfx;\n",
        "        pfx.lpm.prefixlen = 32;\n",
        "        memcpy (pfx.lpm.data, &ip4->daddr, sizeof (pfx.addr));\n",
        "        if (map_lookup_elem (&IP_MASQ_AGENT_IPV4, &pfx))\n",
        "            return false;\n",
        "\n",
        "#endif\n",
        "\n",
        "#ifndef TUNNEL_MODE\n",
        "        if (identity_is_remote_node (remote_ep->sec_label))\n",
        "            return false;\n",
        "\n",
        "#endif\n",
        "        if (!is_reply && local_ep) {\n",
        "            *from_endpoint = true;\n",
        "            *addr = IPV4_MASQUERADE;\n",
        "            return true;\n",
        "        }\n",
        "    }\n",
        "\n",
        "#endif /*ENABLE_MASQUERADE */\n",
        "    return false;\n",
        "}\n"
      ],
      "called_function_list": [
        "memcpy",
        "ipv4_hdrlen",
        "lookup_ip4_egress_gw_policy",
        "__lookup_ip4_endpoint",
        "ct_is_reply4",
        "ipv4_is_in_subnet",
        "get_ct_map4",
        "identity_is_cluster",
        "identity_is_remote_node"
      ],
      "call_depth": 8,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "nodeport_nat_ipv4_fwd": [
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 1261,
      "endLine": 1278,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h",
      "funcName": "nodeport_nat_ipv4_fwd",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "CTX_ACT_OK"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "static __always_inline int nodeport_nat_ipv4_fwd (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    bool from_endpoint = false;\n",
        "    struct ipv4_nat_target target = {\n",
        "        .min_port = NODEPORT_PORT_MIN_NAT,\n",
        "        .max_port = NODEPORT_PORT_MAX_NAT,\n",
        "        .addr = 0,}\n",
        "    ;\n",
        "    int ret = CTX_ACT_OK;\n",
        "    if (snat_v4_needed (ctx, &target.addr, &from_endpoint))\n",
        "        ret = snat_v4_process (ctx, NAT_DIR_EGRESS, &target, from_endpoint);\n",
        "    if (ret == NAT_PUNT_TO_STACK)\n",
        "        ret = CTX_ACT_OK;\n",
        "    return ret;\n",
        "}\n"
      ],
      "called_function_list": [
        "snat_v4_process",
        "snat_v4_needed"
      ],
      "call_depth": 9,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "rss_gen_src4": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1282,
      "endLine": 1290,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h",
      "funcName": "rss_gen_src4",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "__be32 client",
        " __be32 l4_hint"
      ],
      "output": "static__always_inline__be32",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __be32 rss_gen_src4 (__be32 client, __be32 l4_hint)\n",
        "{\n",
        "    const __u32 bits = 32 - IPV4_RSS_PREFIX_BITS;\n",
        "    __be32 src = IPV4_RSS_PREFIX;\n",
        "    if (bits)\n",
        "        src |= bpf_htonl (hash_32 (client ^ l4_hint, bits));\n",
        "    return src;\n",
        "}\n"
      ],
      "called_function_list": [
        "hash_32"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "dsr_set_ipip4": [
    {
      "capabilities": [
        {
          "capability": "read_skb",
          "read_skb": [
            {
              "Project": "cilium",
              "Return Type": "s64",
              "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ",
              "Return": " The checksum result, or a negative error code in case of failure.",
              "Function Name": "csum_diff",
              "Input Params": [
                "{Type: __be32 ,Var: *from}",
                "{Type:  u32 ,Var: from_size}",
                "{Type:  __be32 ,Var: *to}",
                "{Type:  u32 ,Var: to_size}",
                "{Type:  __wsum ,Var: seed}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "xdp",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "lwt_seg6local"
              ],
              "capabilities": [
                "read_skb"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 1298,
      "endLine": 1350,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h",
      "funcName": "dsr_set_ipip4",
      "developer_inline_comments": [
        {
          "start_line": 1292,
          "end_line": 1297,
          "text": "/*\n * Original packet: [clientIP:clientPort -> serviceIP:servicePort] } IP/L4\n *\n * After DSR IPIP:  [rssSrcIP -> backendIP]                        } IP\n *                  [clientIP:clientPort -> serviceIP:servicePort] } IP/L4\n */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " const struct iphdr *ip4",
        " __be32 backend_addr",
        " __be32 l4_hint",
        " __be16 *ohead"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "csum_diff"
      ],
      "compatibleHookpoints": [
        "lwt_seg6local",
        "sched_act",
        "xdp",
        "lwt_xmit",
        "sched_cls",
        "lwt_in",
        "lwt_out"
      ],
      "source": [
        "static __always_inline int dsr_set_ipip4 (struct  __ctx_buff *ctx, const struct iphdr *ip4, __be32 backend_addr, __be32 l4_hint, __be16 *ohead)\n",
        "{\n",
        "    __u16 tot_len = bpf_ntohs (ip4->tot_len) + sizeof (*ip4);\n",
        "    const int l3_off = ETH_HLEN;\n",
        "    __be32 sum;\n",
        "    struct {\n",
        "        __be16 tot_len;\n",
        "        __be16 id;\n",
        "        __be16 frag_off;\n",
        "        __u8 ttl;\n",
        "        __u8 protocol;\n",
        "        __be32 saddr;\n",
        "        __be32 daddr;\n",
        "    } tp_old = {\n",
        "        .tot_len = ip4->tot_len,\n",
        "        .ttl = ip4->ttl,\n",
        "        .protocol = ip4->protocol,\n",
        "        .saddr = ip4->saddr,\n",
        "        .daddr = ip4->daddr,}, tp_new = {\n",
        "        .tot_len = bpf_htons (tot_len),\n",
        "        .ttl = IPDEFTTL,\n",
        "        .protocol = IPPROTO_IPIP,\n",
        "        .saddr = rss_gen_src4 (ip4->saddr, l4_hint),\n",
        "        .daddr = backend_addr,};\n",
        "\n",
        "    if (dsr_is_too_big (ctx, tot_len)) {\n",
        "        *ohead = sizeof (*ip4);\n",
        "        return DROP_FRAG_NEEDED;\n",
        "    }\n",
        "    if (ctx_adjust_hroom (ctx, sizeof (*ip4), BPF_ADJ_ROOM_NET, ctx_adjust_hroom_dsr_flags ()))\n",
        "        return DROP_INVALID;\n",
        "    sum = csum_diff (& tp_old, 16, & tp_new, 16, 0);\n",
        "    if (ctx_store_bytes (ctx, l3_off + offsetof (struct iphdr, tot_len), &tp_new.tot_len, 2, 0) < 0)\n",
        "        return DROP_WRITE_ERROR;\n",
        "    if (ctx_store_bytes (ctx, l3_off + offsetof (struct iphdr, ttl), &tp_new.ttl, 2, 0) < 0)\n",
        "        return DROP_WRITE_ERROR;\n",
        "    if (ctx_store_bytes (ctx, l3_off + offsetof (struct iphdr, saddr), &tp_new.saddr, 8, 0) < 0)\n",
        "        return DROP_WRITE_ERROR;\n",
        "    if (l3_csum_replace (ctx, l3_off + offsetof (struct iphdr, check), 0, sum, 0) < 0)\n",
        "        return DROP_CSUM_L3;\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_adjust_hroom_dsr_flags",
        "dsr_is_too_big",
        "rss_gen_src4",
        "ctx_adjust_hroom"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "dsr_set_opt4": [
    {
      "capabilities": [
        {
          "capability": "read_skb",
          "read_skb": [
            {
              "Project": "cilium",
              "Return Type": "s64",
              "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ",
              "Return": " The checksum result, or a negative error code in case of failure.",
              "Function Name": "csum_diff",
              "Input Params": [
                "{Type: __be32 ,Var: *from}",
                "{Type:  u32 ,Var: from_size}",
                "{Type:  __be32 ,Var: *to}",
                "{Type:  u32 ,Var: to_size}",
                "{Type:  __wsum ,Var: seed}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "xdp",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "lwt_seg6local"
              ],
              "capabilities": [
                "read_skb"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 1352,
      "endLine": 1404,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h",
      "funcName": "dsr_set_opt4",
      "developer_inline_comments": [
        {
          "start_line": 1367,
          "end_line": 1371,
          "text": "/* Setting the option is required only for the first packet\n\t\t * (SYN), in the case of TCP, as for further packets of the\n\t\t * same connection a remote node will use a NAT entry to\n\t\t * reverse xlate a reply.\n\t\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " struct iphdr *ip4",
        " __be32 svc_addr",
        " __be32 svc_port",
        " __be16 *ohead"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "csum_diff"
      ],
      "compatibleHookpoints": [
        "lwt_seg6local",
        "sched_act",
        "xdp",
        "lwt_xmit",
        "sched_cls",
        "lwt_in",
        "lwt_out"
      ],
      "source": [
        "static __always_inline int dsr_set_opt4 (struct  __ctx_buff *ctx, struct iphdr *ip4, __be32 svc_addr, __be32 svc_port, __be16 *ohead)\n",
        "{\n",
        "    __u32 iph_old, iph_new, opt [2];\n",
        "    __u16 tot_len = bpf_ntohs (ip4->tot_len) + sizeof (opt);\n",
        "    __be32 sum;\n",
        "    if (ip4->protocol == IPPROTO_TCP) {\n",
        "        union tcp_flags tcp_flags = {\n",
        "            .value = 0}\n",
        "        ;\n",
        "        if (ctx_load_bytes (ctx, ETH_HLEN + sizeof (*ip4) + 12, &tcp_flags, 2) < 0)\n",
        "            return DROP_CT_INVALID_HDR;\n",
        "        if (!(tcp_flags.value & (TCP_FLAG_SYN)))\n",
        "            return 0;\n",
        "    }\n",
        "    if (dsr_is_too_big (ctx, tot_len)) {\n",
        "        *ohead = sizeof (opt);\n",
        "        return DROP_FRAG_NEEDED;\n",
        "    }\n",
        "    iph_old = *(__u32*) ip4;\n",
        "    ip4->ihl += sizeof (opt) >> 2;\n",
        "    ip4->tot_len = bpf_htons (tot_len);\n",
        "    iph_new = *(__u32*) ip4;\n",
        "    opt[0] = bpf_htonl (DSR_IPV4_OPT_32 | svc_port);\n",
        "    opt[1] = bpf_htonl (svc_addr);\n",
        "    sum = csum_diff (& iph_old, 4, & iph_new, 4, 0);\n",
        "    sum = csum_diff (NULL, 0, & opt, sizeof (opt), sum);\n",
        "    if (ctx_adjust_hroom (ctx, sizeof (opt), BPF_ADJ_ROOM_NET, ctx_adjust_hroom_dsr_flags ()))\n",
        "        return DROP_INVALID;\n",
        "    if (ctx_store_bytes (ctx, ETH_HLEN + sizeof (*ip4), &opt, sizeof (opt), 0) < 0)\n",
        "        return DROP_INVALID;\n",
        "    if (l3_csum_replace (ctx, ETH_HLEN + offsetof (struct iphdr, check), 0, sum, 0) < 0)\n",
        "        return DROP_CSUM_L3;\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_adjust_hroom_dsr_flags",
        "dsr_is_too_big",
        "ctx_adjust_hroom"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "handle_dsr_v4": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1407,
      "endLine": 1446,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h",
      "funcName": "handle_dsr_v4",
      "developer_inline_comments": [
        {
          "start_line": 1415,
          "end_line": 1417,
          "text": "/* Check whether IPv4 header contains a 64-bit option (IPv4 header\n\t * w/o option (5 x 32-bit words) + the DSR option (2 x 32-bit words)).\n\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " bool *dsr"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int handle_dsr_v4 (struct  __ctx_buff *ctx, bool *dsr)\n",
        "{\n",
        "    void *data, *data_end;\n",
        "    struct iphdr *ip4;\n",
        "    if (!revalidate_data (ctx, &data, &data_end, &ip4))\n",
        "        return DROP_INVALID;\n",
        "    if (ip4->ihl == 0x7) {\n",
        "        __u32 opt1 = 0, opt2 = 0;\n",
        "        __be32 address;\n",
        "        __be16 dport;\n",
        "        if (ctx_load_bytes (ctx, ETH_HLEN + sizeof (struct iphdr), &opt1, sizeof (opt1)) < 0)\n",
        "            return DROP_INVALID;\n",
        "        opt1 = bpf_ntohl (opt1);\n",
        "        if ((opt1 & DSR_IPV4_OPT_MASK) == DSR_IPV4_OPT_32) {\n",
        "            if (ctx_load_bytes (ctx, ETH_HLEN + sizeof (struct iphdr) + sizeof (opt1), &opt2, sizeof (opt2)) < 0)\n",
        "                return DROP_INVALID;\n",
        "            opt2 = bpf_ntohl (opt2);\n",
        "            dport = opt1 & DSR_IPV4_DPORT_MASK;\n",
        "            address = opt2;\n",
        "            *dsr = true;\n",
        "            if (snat_v4_create_dsr (ctx, address, dport) < 0)\n",
        "                return DROP_INVALID;\n",
        "        }\n",
        "    }\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "snat_v4_create_dsr"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "xlate_dsr_v4": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1448,
      "endLine": 1464,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h",
      "funcName": "xlate_dsr_v4",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " const struct ipv4_ct_tuple *tuple",
        " int l4_off",
        " bool has_l4_header"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int xlate_dsr_v4 (struct  __ctx_buff *ctx, const struct ipv4_ct_tuple *tuple, int l4_off, bool has_l4_header)\n",
        "{\n",
        "    struct ipv4_ct_tuple nat_tup = *tuple;\n",
        "    struct ipv4_nat_entry *entry;\n",
        "    int ret = 0;\n",
        "    nat_tup.flags = NAT_DIR_EGRESS;\n",
        "    nat_tup.sport = tuple->dport;\n",
        "    nat_tup.dport = tuple->sport;\n",
        "    entry = snat_v4_lookup (& nat_tup);\n",
        "    if (entry)\n",
        "        ret = snat_v4_rewrite_egress (ctx, &nat_tup, entry, l4_off, has_l4_header);\n",
        "    return ret;\n",
        "}\n"
      ],
      "called_function_list": [
        "snat_v4_rewrite_egress",
        "snat_v4_lookup"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "dsr_reply_icmp4": [
    {
      "capabilities": [
        {
          "capability": "read_skb",
          "read_skb": [
            {
              "Project": "cilium",
              "Return Type": "s64",
              "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ",
              "Return": " The checksum result, or a negative error code in case of failure.",
              "Function Name": "csum_diff",
              "Input Params": [
                "{Type: __be32 ,Var: *from}",
                "{Type:  u32 ,Var: from_size}",
                "{Type:  __be32 ,Var: *to}",
                "{Type:  u32 ,Var: to_size}",
                "{Type:  __wsum ,Var: seed}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "xdp",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "lwt_seg6local"
              ],
              "capabilities": [
                "read_skb"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 1466,
      "endLine": 1549,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h",
      "funcName": "dsr_reply_icmp4",
      "developer_inline_comments": [
        {
          "start_line": 1511,
          "end_line": 1514,
          "text": "/* We use a workaround here in that we push zero-bytes into the\n\t * payload in order to support dynamic IPv4 header size. This\n\t * works given one's complement sum does not change.\n\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " struct iphdr * ip4 __maybe_unused",
        " int code",
        " __be16 ohead __maybe_unused"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "csum_diff"
      ],
      "compatibleHookpoints": [
        "lwt_seg6local",
        "sched_act",
        "xdp",
        "lwt_xmit",
        "sched_cls",
        "lwt_in",
        "lwt_out"
      ],
      "source": [
        "static __always_inline int dsr_reply_icmp4 (struct  __ctx_buff *ctx, struct iphdr * ip4 __maybe_unused, int code, __be16 ohead __maybe_unused)\n",
        "{\n",
        "\n",
        "#ifdef ENABLE_DSR_ICMP_ERRORS\n",
        "    const __s32 orig_dgram = 8, off = ETH_HLEN;\n",
        "    const __u32 l3_max = MAX_IPOPTLEN + sizeof (*ip4) + orig_dgram;\n",
        "    __be16 type = bpf_htons (ETH_P_IP);\n",
        "    __s32 len_new = off + ipv4_hdrlen (ip4) + orig_dgram;\n",
        "    __s32 len_old = ctx_full_len (ctx);\n",
        "    __u8 reason = (__u8) -code;\n",
        "    __u8 tmp [l3_max];\n",
        "    union macaddr smac, dmac;\n",
        "    struct icmphdr icmp __align_stack_8 = {\n",
        "        .type = ICMP_DEST_UNREACH,\n",
        "        .code = ICMP_FRAG_NEEDED,\n",
        "        .un = {\n",
        "            .frag = {\n",
        "                .mtu = bpf_htons (THIS_MTU - ohead),},},}\n",
        "    ;\n",
        "    __u64 tot_len = sizeof (struct iphdr) + ipv4_hdrlen (ip4) + sizeof (icmp) + orig_dgram;\n",
        "    struct iphdr ip __align_stack_8 = {\n",
        "        .ihl = sizeof (ip) >> 2,\n",
        "        .version = IPVERSION,\n",
        "        .ttl = IPDEFTTL,\n",
        "        .tos = ip4->tos,\n",
        "        .id = ip4->id,\n",
        "        .protocol = IPPROTO_ICMP,\n",
        "        .saddr = ip4->daddr,\n",
        "        .daddr = ip4->saddr,\n",
        "        .frag_off = bpf_htons (IP_DF),\n",
        "        .tot_len = bpf_htons ((__u16) tot_len),}\n",
        "    ;\n",
        "    update_metrics (ctx_full_len (ctx), METRIC_EGRESS, reason);\n",
        "    if (eth_load_saddr (ctx, smac.addr, 0) < 0)\n",
        "        goto drop_err;\n",
        "    if (eth_load_daddr (ctx, dmac.addr, 0) < 0)\n",
        "        goto drop_err;\n",
        "    ip.check = csum_fold (csum_diff (NULL, 0, &ip, sizeof (ip), 0));\n",
        "    memset (tmp, 0, MAX_IPOPTLEN);\n",
        "    if (ctx_store_bytes (ctx, len_new, tmp, MAX_IPOPTLEN, 0) < 0)\n",
        "        goto drop_err;\n",
        "    if (ctx_load_bytes (ctx, off, tmp, sizeof (tmp)) < 0)\n",
        "        goto drop_err;\n",
        "    icmp.checksum = csum_fold (csum_diff (NULL, 0, tmp, sizeof (tmp), csum_diff (NULL, 0, &icmp, sizeof (icmp), 0)));\n",
        "    if (ctx_adjust_troom (ctx, -(len_old - len_new)) < 0)\n",
        "        goto drop_err;\n",
        "    if (ctx_adjust_hroom (ctx, sizeof (ip) + sizeof (icmp), BPF_ADJ_ROOM_NET, ctx_adjust_hroom_dsr_flags ()) < 0)\n",
        "        goto drop_err;\n",
        "    if (eth_store_daddr (ctx, smac.addr, 0) < 0)\n",
        "        goto drop_err;\n",
        "    if (eth_store_saddr (ctx, dmac.addr, 0) < 0)\n",
        "        goto drop_err;\n",
        "    if (ctx_store_bytes (ctx, ETH_ALEN * 2, &type, sizeof (type), 0) < 0)\n",
        "        goto drop_err;\n",
        "    if (ctx_store_bytes (ctx, off, &ip, sizeof (ip), 0) < 0)\n",
        "        goto drop_err;\n",
        "    if (ctx_store_bytes (ctx, off + sizeof (ip), &icmp, sizeof (icmp), 0) < 0)\n",
        "        goto drop_err;\n",
        "    return ctx_redirect (ctx, ctx_get_ifindex (ctx), 0);\n",
        "drop_err :\n",
        "\n",
        "#endif\n",
        "    return send_drop_notify_error (ctx, 0, code, CTX_ACT_DROP, METRIC_EGRESS);\n",
        "}\n"
      ],
      "called_function_list": [
        "eth_load_saddr",
        "csum_fold",
        "memset",
        "eth_store_saddr",
        "ipv4_hdrlen",
        "ctx_adjust_hroom_dsr_flags",
        "ctx_adjust_troom",
        "eth_store_daddr",
        "ctx_get_ifindex",
        "ctx_adjust_hroom",
        "ctx_redirect",
        "ctx_full_len",
        "eth_load_daddr",
        "update_metrics"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "tail_nodeport_ipv4_dsr": [
    {
      "capabilities": [
        {
          "capability": "read_sys_info",
          "read_sys_info": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Description": "Do FIB lookup in kernel tables using parameters in params. If lookup is successful and result shows packet is to be forwarded , the neighbor tables are searched for the nexthop. If successful (ie. , FIB lookup shows forwarding and nexthop is resolved) , the nexthop address is returned in ipv4_dst or ipv6_dst based on family , smac is set to mac address of egress device , dmac is set to nexthop mac address , rt_metric is set to metric from route (IPv4/IPv6 only) , and ifindex is set to the device index of the nexthop from the FIB lookup. <[ plen ]>(IP: 2) argument is the size of the passed in struct. <[ flags ]>(IP: 3) argument can be a combination of one or more of the following values: BPF_FIB_LOOKUP_DIRECT Do a direct table lookup vs full lookup using FIB rules. BPF_FIB_LOOKUP_OUTPUT Perform lookup from an egress perspective (default is ingress). <[ ctx ]>(IP: 0) is either struct xdp_md for XDP programs or struct sk_buff tc cls_act programs. Return \u00b7 < 0 if any input argument is invalid \u00b7 0 on success (packet is forwarded , nexthop neighbor exists) \u00b7 > 0 one of BPF_FIB_LKUP_RET_ codes explaining why the packet is not forwarded or needs assist from full stack ",
              "Function Name": "fib_lookup",
              "Input Params": [
                "{Type: void ,Var: *ctx}",
                "{Type:  struct fib_lookup ,Var: *params}",
                "{Type:  int ,Var: plen}",
                "{Type:  u32 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "xdp"
              ],
              "capabilities": [
                "read_sys_info"
              ]
            },
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Do FIB lookup in kernel tables using parameters in params. If lookup is successful and result shows packet is to be forwarded , the neighbor tables are searched for the nexthop. If successful (ie. , FIB lookup shows forwarding and nexthop is resolved) , the nexthop address is returned in ipv4_dst or ipv6_dst based on family , smac is set to mac address of egress device , dmac is set to nexthop mac address , rt_metric is set to metric from route (IPv4/IPv6 only) , and ifindex is set to the device index of the nexthop from the FIB lookup. <[ plen ]>(IP: 2) argument is the size of the passed in struct. <[ flags ]>(IP: 3) argument can be a combination of one or more of the following values: BPF_FIB_LOOKUP_DIRECT Do a direct table lookup vs full lookup using FIB rules. BPF_FIB_LOOKUP_OUTPUT Perform lookup from an egress perspective (default is ingress). <[ ctx ]>(IP: 0) is either struct xdp_md for XDP programs or struct sk_buff tc cls_act programs. Return \u00b7 < 0 if any input argument is invalid \u00b7 0 on success (packet is forwarded , nexthop neighbor exists) \u00b7 > 0 one of BPF_FIB_LKUP_RET_ codes explaining why the packet is not forwarded or needs assist from full stack ",
              "Function Name": "bpf_fib_lookup",
              "Input Params": [
                "{Type: void ,Var: *ctx}",
                "{Type:  struct bpf_fib_lookup ,Var: *params}",
                "{Type:  int ,Var: plen}",
                "{Type:  u32 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "xdp"
              ],
              "capabilities": [
                "read_sys_info"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 1552,
      "endLine": 1621,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h",
      "funcName": "tail_nodeport_ipv4_dsr",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "int",
      "helper": [
        "fib_lookup",
        "bpf_fib_lookup"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "int tail_nodeport_ipv4_dsr (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    struct bpf_fib_lookup_padded fib_params = {\n",
        "        .l = {\n",
        "            .family = AF_INET,\n",
        "            .ifindex = ctx_get_ifindex (ctx),},}\n",
        "    ;\n",
        "    bool l2_hdr_required = true;\n",
        "    void *data, *data_end;\n",
        "    struct iphdr *ip4;\n",
        "    __be16 ohead = 0;\n",
        "    int ret, ext_err = 0;\n",
        "    if (!revalidate_data (ctx, &data, &data_end, &ip4)) {\n",
        "        ret = DROP_INVALID;\n",
        "        goto drop_err;\n",
        "    }\n",
        "\n",
        "#if DSR_ENCAP_MODE == DSR_ENCAP_IPIP\n",
        "    ret = dsr_set_ipip4 (ctx, ip4, ctx_load_meta (ctx, CB_ADDR_V4), ctx_load_meta (ctx, CB_HINT), & ohead);\n",
        "\n",
        "#elif DSR_ENCAP_MODE == DSR_ENCAP_NONE\n",
        "    ret = dsr_set_opt4 (ctx, ip4, ctx_load_meta (ctx, CB_ADDR_V4), ctx_load_meta (ctx, CB_PORT), & ohead);\n",
        "\n",
        "#else\n",
        "\n",
        "# error \"Invalid load balancer DSR encapsulation mode!\"\n",
        "\n",
        "#endif\n",
        "    if (unlikely (ret)) {\n",
        "        if (dsr_fail_needs_reply (ret))\n",
        "            return dsr_reply_icmp4 (ctx, ip4, ret, ohead);\n",
        "        goto drop_err;\n",
        "    }\n",
        "    if (!revalidate_data (ctx, &data, &data_end, &ip4)) {\n",
        "        ret = DROP_INVALID;\n",
        "        goto drop_err;\n",
        "    }\n",
        "    fib_params.l.ipv4_src = ip4->saddr;\n",
        "    fib_params.l.ipv4_dst = ip4->daddr;\n",
        "    ret = fib_lookup (ctx, & fib_params.l, sizeof (fib_params), 0);\n",
        "    if (ret != 0) {\n",
        "        ext_err = ret;\n",
        "        ret = DROP_NO_FIB;\n",
        "        goto drop_err;\n",
        "    }\n",
        "    ret = maybe_add_l2_hdr (ctx, fib_params.l.ifindex, & l2_hdr_required);\n",
        "    if (ret != 0)\n",
        "        goto drop_err;\n",
        "    if (!l2_hdr_required)\n",
        "        goto out_send;\n",
        "    if (eth_store_daddr (ctx, fib_params.l.dmac, 0) < 0) {\n",
        "        ret = DROP_WRITE_ERROR;\n",
        "        goto drop_err;\n",
        "    }\n",
        "    if (eth_store_saddr (ctx, fib_params.l.smac, 0) < 0) {\n",
        "        ret = DROP_WRITE_ERROR;\n",
        "        goto drop_err;\n",
        "    }\n",
        "out_send :\n",
        "    cilium_capture_out (ctx);\n",
        "    return ctx_redirect (ctx, fib_params.l.ifindex, 0);\n",
        "drop_err :\n",
        "    return send_drop_notify_error_ext (ctx, 0, ret, ext_err, CTX_ACT_DROP, METRIC_EGRESS);\n",
        "}\n"
      ],
      "called_function_list": [
        "dsr_set_opt4",
        "dsr_set_ipip4",
        "maybe_add_l2_hdr",
        "cilium_capture_out",
        "dsr_reply_icmp4",
        "eth_store_daddr",
        "ctx_get_ifindex",
        "ctx_redirect",
        "dsr_fail_needs_reply",
        "ctx_load_meta",
        "eth_store_saddr"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "tail_nodeport_nat_ipv4": [
    {
      "capabilities": [
        {
          "capability": "read_sys_info",
          "read_sys_info": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Description": "Do FIB lookup in kernel tables using parameters in params. If lookup is successful and result shows packet is to be forwarded , the neighbor tables are searched for the nexthop. If successful (ie. , FIB lookup shows forwarding and nexthop is resolved) , the nexthop address is returned in ipv4_dst or ipv6_dst based on family , smac is set to mac address of egress device , dmac is set to nexthop mac address , rt_metric is set to metric from route (IPv4/IPv6 only) , and ifindex is set to the device index of the nexthop from the FIB lookup. <[ plen ]>(IP: 2) argument is the size of the passed in struct. <[ flags ]>(IP: 3) argument can be a combination of one or more of the following values: BPF_FIB_LOOKUP_DIRECT Do a direct table lookup vs full lookup using FIB rules. BPF_FIB_LOOKUP_OUTPUT Perform lookup from an egress perspective (default is ingress). <[ ctx ]>(IP: 0) is either struct xdp_md for XDP programs or struct sk_buff tc cls_act programs. Return \u00b7 < 0 if any input argument is invalid \u00b7 0 on success (packet is forwarded , nexthop neighbor exists) \u00b7 > 0 one of BPF_FIB_LKUP_RET_ codes explaining why the packet is not forwarded or needs assist from full stack ",
              "Function Name": "fib_lookup",
              "Input Params": [
                "{Type: void ,Var: *ctx}",
                "{Type:  struct fib_lookup ,Var: *params}",
                "{Type:  int ,Var: plen}",
                "{Type:  u32 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "xdp"
              ],
              "capabilities": [
                "read_sys_info"
              ]
            },
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Do FIB lookup in kernel tables using parameters in params. If lookup is successful and result shows packet is to be forwarded , the neighbor tables are searched for the nexthop. If successful (ie. , FIB lookup shows forwarding and nexthop is resolved) , the nexthop address is returned in ipv4_dst or ipv6_dst based on family , smac is set to mac address of egress device , dmac is set to nexthop mac address , rt_metric is set to metric from route (IPv4/IPv6 only) , and ifindex is set to the device index of the nexthop from the FIB lookup. <[ plen ]>(IP: 2) argument is the size of the passed in struct. <[ flags ]>(IP: 3) argument can be a combination of one or more of the following values: BPF_FIB_LOOKUP_DIRECT Do a direct table lookup vs full lookup using FIB rules. BPF_FIB_LOOKUP_OUTPUT Perform lookup from an egress perspective (default is ingress). <[ ctx ]>(IP: 0) is either struct xdp_md for XDP programs or struct sk_buff tc cls_act programs. Return \u00b7 < 0 if any input argument is invalid \u00b7 0 on success (packet is forwarded , nexthop neighbor exists) \u00b7 > 0 one of BPF_FIB_LKUP_RET_ codes explaining why the packet is not forwarded or needs assist from full stack ",
              "Function Name": "bpf_fib_lookup",
              "Input Params": [
                "{Type: void ,Var: *ctx}",
                "{Type:  struct bpf_fib_lookup ,Var: *params}",
                "{Type:  int ,Var: plen}",
                "{Type:  u32 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "xdp"
              ],
              "capabilities": [
                "read_sys_info"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 1625,
      "endLine": 1767,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h",
      "funcName": "tail_nodeport_nat_ipv4",
      "developer_inline_comments": [
        {
          "start_line": 1644,
          "end_line": 1648,
          "text": "/* Unfortunately, the bpf_fib_lookup() is not able to set src IP addr.\n\t * So we need to assume that the direct routing device is going to be\n\t * used to fwd the NodePort request, thus SNAT-ing to its IP addr.\n\t * This will change once we have resolved GH#17158.\n\t */"
        },
        {
          "start_line": 1661,
          "end_line": 1669,
          "text": "/* The dir == NAT_DIR_EGRESS branch is executed for\n\t\t\t * N/S LB requests which needs to be fwd-ed to a remote\n\t\t\t * node. As the request came from outside, we need to\n\t\t\t * set the security id in the tunnel header to WORLD_ID.\n\t\t\t * Otherwise, the remote node will assume, that the\n\t\t\t * request originated from a cluster node which will\n\t\t\t * bypass any netpol which disallows LB requests from\n\t\t\t * outside.\n\t\t\t */"
        },
        {
          "start_line": 1681,
          "end_line": 1681,
          "text": "/* fib lookup not necessary when going over tunnel. */"
        },
        {
          "start_line": 1693,
          "end_line": 1695,
          "text": "/* Handles SNAT on NAT_DIR_EGRESS and reverse SNAT for reply packets\n\t * from remote backends on NAT_DIR_INGRESS.\n\t */"
        },
        {
          "start_line": 1698,
          "end_line": 1702,
          "text": "/* In case of no mapping, recircle back to main path. SNAT is very\n\t\t * expensive in terms of instructions (since we don't have BPF to\n\t\t * BPF calls as we use tail calls) and complexity, hence this is\n\t\t * done inside a tail call here.\n\t\t */"
        },
        {
          "start_line": 1716,
          "end_line": 1722,
          "text": "/* At this point we know that a reverse SNAT mapping exists.\n\t\t * Otherwise, we would have tail-called back to\n\t\t * CALL_IPV4_FROM_NETDEV in the code above. The existence of the\n\t\t * mapping is an indicator that the packet might be a reply from\n\t\t * a remote backend. So handle the service reverse DNAT (if\n\t\t * needed)\n\t\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "int",
      "helper": [
        "fib_lookup",
        "bpf_fib_lookup"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "int tail_nodeport_nat_ipv4 (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    enum nat_dir dir = (enum nat_dir) ctx_load_meta (ctx, CB_NAT);\n",
        "    struct bpf_fib_lookup_padded fib_params = {\n",
        "        .l = {\n",
        "            .family = AF_INET,\n",
        "            .ifindex = ctx_get_ifindex (ctx),},}\n",
        "    ;\n",
        "    struct ipv4_nat_target target = {\n",
        "        .min_port = NODEPORT_PORT_MIN_NAT,\n",
        "        .max_port = NODEPORT_PORT_MAX_NAT,\n",
        "        .src_from_world = true,}\n",
        "    ;\n",
        "    void *data, *data_end;\n",
        "    struct iphdr *ip4;\n",
        "    bool l2_hdr_required = true;\n",
        "    int ret, ext_err = 0;\n",
        "    target.addr = IPV4_DIRECT_ROUTING;\n",
        "\n",
        "#ifdef TUNNEL_MODE\n",
        "    if (dir == NAT_DIR_EGRESS) {\n",
        "        struct remote_endpoint_info *info;\n",
        "        if (!revalidate_data (ctx, &data, &data_end, &ip4)) {\n",
        "            ret = DROP_INVALID;\n",
        "            goto drop_err;\n",
        "        }\n",
        "        info = ipcache_lookup4 (& IPCACHE_MAP, ip4 -> daddr, V4_CACHE_KEY_LEN);\n",
        "        if (info != NULL && info->tunnel_endpoint != 0) {\n",
        "            ret = __encap_with_nodeid (ctx, info -> tunnel_endpoint, WORLD_ID, NOT_VTEP_DST, (enum trace_reason) CT_NEW, TRACE_PAYLOAD_LEN);\n",
        "            if (ret)\n",
        "                goto drop_err;\n",
        "            target.addr = IPV4_GATEWAY;\n",
        "            fib_params.l.ifindex = ENCAP_IFINDEX;\n",
        "            if (eth_store_daddr (ctx, fib_params.l.dmac, 0) < 0) {\n",
        "                ret = DROP_WRITE_ERROR;\n",
        "                goto drop_err;\n",
        "            }\n",
        "            if (eth_store_saddr (ctx, fib_params.l.smac, 0) < 0) {\n",
        "                ret = DROP_WRITE_ERROR;\n",
        "                goto drop_err;\n",
        "            }\n",
        "        }\n",
        "    }\n",
        "\n",
        "#endif\n",
        "    ret = snat_v4_process (ctx, dir, & target, false);\n",
        "    if (IS_ERR (ret)) {\n",
        "        if (dir == NAT_DIR_INGRESS) {\n",
        "            bpf_skip_nodeport_set (ctx);\n",
        "            ep_tail_call (ctx, CILIUM_CALL_IPV4_FROM_NETDEV);\n",
        "            ret = DROP_MISSED_TAIL_CALL;\n",
        "            goto drop_err;\n",
        "        }\n",
        "        if (ret != NAT_PUNT_TO_STACK)\n",
        "            goto drop_err;\n",
        "    }\n",
        "    bpf_mark_snat_done (ctx);\n",
        "    if (dir == NAT_DIR_INGRESS) {\n",
        "        ep_tail_call (ctx, CILIUM_CALL_IPV4_NODEPORT_REVNAT);\n",
        "        ret = DROP_MISSED_TAIL_CALL;\n",
        "        goto drop_err;\n",
        "    }\n",
        "\n",
        "#ifdef TUNNEL_MODE\n",
        "    if (fib_params.l.ifindex == ENCAP_IFINDEX)\n",
        "        goto out_send;\n",
        "\n",
        "#endif\n",
        "    if (!revalidate_data (ctx, &data, &data_end, &ip4)) {\n",
        "        ret = DROP_INVALID;\n",
        "        goto drop_err;\n",
        "    }\n",
        "    fib_params.l.ipv4_src = ip4->saddr;\n",
        "    fib_params.l.ipv4_dst = ip4->daddr;\n",
        "    ret = fib_lookup (ctx, & fib_params.l, sizeof (fib_params), 0);\n",
        "    if (ret != 0) {\n",
        "        ext_err = ret;\n",
        "        ret = DROP_NO_FIB;\n",
        "        goto drop_err;\n",
        "    }\n",
        "    ret = maybe_add_l2_hdr (ctx, fib_params.l.ifindex, & l2_hdr_required);\n",
        "    if (ret != 0)\n",
        "        goto drop_err;\n",
        "    if (!l2_hdr_required)\n",
        "        goto out_send;\n",
        "    if (eth_store_daddr (ctx, fib_params.l.dmac, 0) < 0) {\n",
        "        ret = DROP_WRITE_ERROR;\n",
        "        goto drop_err;\n",
        "    }\n",
        "    if (eth_store_saddr (ctx, fib_params.l.smac, 0) < 0) {\n",
        "        ret = DROP_WRITE_ERROR;\n",
        "        goto drop_err;\n",
        "    }\n",
        "out_send :\n",
        "    cilium_capture_out (ctx);\n",
        "    return ctx_redirect (ctx, fib_params.l.ifindex, 0);\n",
        "drop_err :\n",
        "    return send_drop_notify_error_ext (ctx, 0, ret, ext_err, CTX_ACT_DROP, dir == NAT_DIR_INGRESS ? METRIC_INGRESS : METRIC_EGRESS);\n",
        "}\n"
      ],
      "called_function_list": [
        "bpf_skip_nodeport_set",
        "snat_v4_process",
        "maybe_add_l2_hdr",
        "cilium_capture_out",
        "bpf_mark_snat_done",
        "__encap_with_nodeid",
        "ipcache_lookup4",
        "eth_store_daddr",
        "ep_tail_call",
        "ctx_get_ifindex",
        "ctx_redirect",
        "ctx_load_meta",
        "eth_store_saddr"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "nodeport_lb4": [
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        },
        {
          "capability": "map_update",
          "map_update": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "map_update_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}",
                "{Type:  const void ,Var: *value}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_update"
              ]
            }
          ]
        },
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 1773,
      "endLine": 1943,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h",
      "funcName": "nodeport_lb4",
      "developer_inline_comments": [
        {
          "start_line": 1769,
          "end_line": 1772,
          "text": "/* Main node-port entry point for host-external ingressing node-port traffic\n * which handles the case of: i) backend is local EP, ii) backend is remote EP,\n * iii) reply from remote backend EP.\n */"
        },
        {
          "start_line": 1842,
          "end_line": 1845,
          "text": "/* The packet is not destined to a service but it can be a reply\n\t\t * packet from a remote backend, in which case we need to perform\n\t\t * the reverse NAT.\n\t\t */"
        },
        {
          "start_line": 1855,
          "end_line": 1857,
          "text": "/* For NAT64 we might see an IPv4 reply from the backend to\n\t\t * the LB entering this path. Thus, transform back to IPv6.\n\t\t */"
        },
        {
          "start_line": 1874,
          "end_line": 1876,
          "text": "/* Reply from DSR packet is never seen on this node again hence no\n\t * need to track in here.\n\t */"
        },
        {
          "start_line": 1896,
          "end_line": 1898,
          "text": "/* Recreate CT entries, as the existing one is stale and\n\t\t\t * belongs to a flow which target a different svc.\n\t\t\t */"
        },
        {
          "start_line": 1931,
          "end_line": 1931,
          "text": "/* DSR_ENCAP_MODE */"
        }
      ],
      "updateMaps": [
        "  NODEPORT_NEIGH4"
      ],
      "readMaps": [
        "  NODEPORT_NEIGH4"
      ],
      "input": [
        "struct  __ctx_buff *ctx",
        " __u32 src_identity"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "CTX_ACT_OK",
        "map_update_elem",
        "map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "static __always_inline int nodeport_lb4 (struct  __ctx_buff *ctx, __u32 src_identity)\n",
        "{\n",
        "    struct ipv4_ct_tuple tuple = {}\n",
        "    ;\n",
        "    void *data, *data_end;\n",
        "    struct iphdr *ip4;\n",
        "    int ret, l3_off = ETH_HLEN, l4_off;\n",
        "    struct csum_offset csum_off = {}\n",
        "    ;\n",
        "    struct lb4_service *svc;\n",
        "    struct lb4_key key = {}\n",
        "    ;\n",
        "    struct ct_state ct_state_new = {}\n",
        "    ;\n",
        "    union macaddr smac, *mac;\n",
        "    bool backend_local;\n",
        "    __u32 monitor = 0;\n",
        "    cilium_capture_in (ctx);\n",
        "    if (!revalidate_data (ctx, &data, &data_end, &ip4))\n",
        "        return DROP_INVALID;\n",
        "    tuple.nexthdr = ip4->protocol;\n",
        "    tuple.daddr = ip4->daddr;\n",
        "    tuple.saddr = ip4->saddr;\n",
        "    l4_off = l3_off + ipv4_hdrlen (ip4);\n",
        "    ret = lb4_extract_key (ctx, ip4, l4_off, & key, & csum_off, CT_EGRESS);\n",
        "    if (IS_ERR (ret)) {\n",
        "        if (ret == DROP_NO_SERVICE)\n",
        "            goto skip_service_lookup;\n",
        "        else if (ret == DROP_UNKNOWN_L4)\n",
        "            return CTX_ACT_OK;\n",
        "        else\n",
        "            return ret;\n",
        "    }\n",
        "    svc = lb4_lookup_service (& key, false);\n",
        "    if (svc) {\n",
        "        const bool skip_l3_xlate = DSR_ENCAP_MODE == DSR_ENCAP_IPIP;\n",
        "        if (!lb4_src_range_ok (svc, ip4->saddr))\n",
        "            return DROP_NOT_IN_SRC_RANGE;\n",
        "\n",
        "#if defined(ENABLE_L7_LB)\n",
        "        if (lb4_svc_is_l7loadbalancer (svc) && svc->l7_lb_proxy_port > 0) {\n",
        "            send_trace_notify (ctx, TRACE_TO_PROXY, src_identity, 0, bpf_ntohs ((__u16) svc->l7_lb_proxy_port), 0, TRACE_REASON_POLICY, monitor);\n",
        "            return ctx_redirect_to_proxy_hairpin_ipv4 (ctx, (__be16) svc->l7_lb_proxy_port);\n",
        "        }\n",
        "\n",
        "#endif\n",
        "        if (lb4_to_lb6_service (svc)) {\n",
        "            ret = lb4_to_lb6 (ctx, ip4, l3_off);\n",
        "            if (!ret)\n",
        "                return NAT_46X64_RECIRC;\n",
        "        }\n",
        "        else {\n",
        "            ret = lb4_local (get_ct_map4 (& tuple), ctx, l3_off, l4_off, & csum_off, & key, & tuple, svc, & ct_state_new, ip4 -> saddr, ipv4_has_l4_header (ip4), skip_l3_xlate);\n",
        "        }\n",
        "        if (IS_ERR (ret))\n",
        "            return ret;\n",
        "    }\n",
        "    if (!svc || !lb4_svc_is_routable (svc)) {\n",
        "        if (svc)\n",
        "            return DROP_IS_CLUSTER_IP;\n",
        "    skip_service_lookup :\n",
        "        ctx_set_xfer (ctx, XFER_PKT_NO_SVC);\n",
        "\n",
        "#ifndef ENABLE_MASQUERADE\n",
        "        if (nodeport_uses_dsr4 (&tuple))\n",
        "            return CTX_ACT_OK;\n",
        "\n",
        "#endif\n",
        "        ctx_store_meta (ctx, CB_NAT, NAT_DIR_INGRESS);\n",
        "        ctx_store_meta (ctx, CB_SRC_IDENTITY, src_identity);\n",
        "        if (!lb4_populate_ports (ctx, &tuple, l4_off) && snat_v6_has_v4_match (&tuple)) {\n",
        "            ret = lb4_to_lb6 (ctx, ip4, l3_off);\n",
        "            if (ret)\n",
        "                return ret;\n",
        "            ep_tail_call (ctx, CILIUM_CALL_IPV6_NODEPORT_NAT);\n",
        "        }\n",
        "        else {\n",
        "            ep_tail_call (ctx, CILIUM_CALL_IPV4_NODEPORT_NAT);\n",
        "        }\n",
        "        return DROP_MISSED_TAIL_CALL;\n",
        "    }\n",
        "    backend_local = __lookup_ip4_endpoint (tuple.daddr);\n",
        "    if (!backend_local && lb4_svc_is_hostport (svc))\n",
        "        return DROP_INVALID;\n",
        "    if (backend_local || !nodeport_uses_dsr4 (&tuple)) {\n",
        "        struct ct_state ct_state = {}\n",
        "        ;\n",
        "        ret = ct_lookup4 (get_ct_map4 (& tuple), & tuple, ctx, l4_off, CT_EGRESS, & ct_state, & monitor);\n",
        "        switch (ret) {\n",
        "        case CT_NEW :\n",
        "        redo :\n",
        "            ct_state_new.src_sec_id = WORLD_ID;\n",
        "            ct_state_new.node_port = 1;\n",
        "            ct_state_new.ifindex = (__u16) NATIVE_DEV_IFINDEX;\n",
        "            ret = ct_create4 (get_ct_map4 (& tuple), NULL, & tuple, ctx, CT_EGRESS, & ct_state_new, false, false);\n",
        "            if (IS_ERR (ret))\n",
        "                return ret;\n",
        "            break;\n",
        "        case CT_REOPENED :\n",
        "        case CT_ESTABLISHED :\n",
        "        case CT_REPLY :\n",
        "            if (unlikely (ct_state.rev_nat_index != svc->rev_nat_index))\n",
        "                goto redo;\n",
        "            break;\n",
        "        default :\n",
        "            return DROP_UNKNOWN_CT;\n",
        "        }\n",
        "        if (!revalidate_data (ctx, &data, &data_end, &ip4))\n",
        "            return DROP_INVALID;\n",
        "        if (eth_load_saddr (ctx, smac.addr, 0) < 0)\n",
        "            return DROP_INVALID;\n",
        "        mac = map_lookup_elem (& NODEPORT_NEIGH4, & ip4 -> saddr);\n",
        "        if (!mac || eth_addrcmp (mac, &smac)) {\n",
        "            ret = map_update_elem (& NODEPORT_NEIGH4, & ip4 -> saddr, & smac, 0);\n",
        "            if (ret < 0)\n",
        "                return ret;\n",
        "        }\n",
        "    }\n",
        "    if (!backend_local) {\n",
        "        edt_set_aggregate (ctx, 0);\n",
        "        if (nodeport_uses_dsr4 (&tuple)) {\n",
        "\n",
        "#if DSR_ENCAP_MODE == DSR_ENCAP_IPIP\n",
        "            ctx_store_meta (ctx, CB_HINT, ((__u32) tuple.sport << 16) | tuple.dport);\n",
        "            ctx_store_meta (ctx, CB_ADDR_V4, tuple.daddr);\n",
        "\n",
        "#elif DSR_ENCAP_MODE == DSR_ENCAP_NONE\n",
        "            ctx_store_meta (ctx, CB_PORT, key.dport);\n",
        "            ctx_store_meta (ctx, CB_ADDR_V4, key.address);\n",
        "\n",
        "#endif /* DSR_ENCAP_MODE */\n",
        "            ep_tail_call (ctx, CILIUM_CALL_IPV4_NODEPORT_DSR);\n",
        "        }\n",
        "        else {\n",
        "            ctx_store_meta (ctx, CB_NAT, NAT_DIR_EGRESS);\n",
        "            ep_tail_call (ctx, CILIUM_CALL_IPV4_NODEPORT_NAT);\n",
        "        }\n",
        "        return DROP_MISSED_TAIL_CALL;\n",
        "    }\n",
        "    ctx_set_xfer (ctx, XFER_PKT_NO_SVC);\n",
        "    return CTX_ACT_OK;\n",
        "}\n"
      ],
      "called_function_list": [
        "lb4_src_range_ok",
        "ctx_set_xfer",
        "lb4_svc_is_l7loadbalancer",
        "nodeport_uses_dsr4",
        "lb4_lookup_service",
        "lb4_to_lb6_service",
        "snat_v6_has_v4_match",
        "cilium_capture_in",
        "ctx_store_meta",
        "ipv4_hdrlen",
        "eth_addrcmp",
        "ct_lookup4",
        "lb4_local",
        "edt_set_aggregate",
        "ipv4_has_l4_header",
        "lb4_extract_key",
        "ep_tail_call",
        "__lookup_ip4_endpoint",
        "ct_create4",
        "send_trace_notify",
        "lb4_to_lb6",
        "eth_load_saddr",
        "ctx_redirect_to_proxy_hairpin_ipv4",
        "lb4_svc_is_routable",
        "lb4_populate_ports",
        "get_ct_map4",
        "lb4_svc_is_hostport"
      ],
      "call_depth": 5,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "rev_nodeport_lb4": [
    {
      "capabilities": [
        {
          "capability": "read_sys_info",
          "read_sys_info": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Description": "Do FIB lookup in kernel tables using parameters in params. If lookup is successful and result shows packet is to be forwarded , the neighbor tables are searched for the nexthop. If successful (ie. , FIB lookup shows forwarding and nexthop is resolved) , the nexthop address is returned in ipv4_dst or ipv6_dst based on family , smac is set to mac address of egress device , dmac is set to nexthop mac address , rt_metric is set to metric from route (IPv4/IPv6 only) , and ifindex is set to the device index of the nexthop from the FIB lookup. <[ plen ]>(IP: 2) argument is the size of the passed in struct. <[ flags ]>(IP: 3) argument can be a combination of one or more of the following values: BPF_FIB_LOOKUP_DIRECT Do a direct table lookup vs full lookup using FIB rules. BPF_FIB_LOOKUP_OUTPUT Perform lookup from an egress perspective (default is ingress). <[ ctx ]>(IP: 0) is either struct xdp_md for XDP programs or struct sk_buff tc cls_act programs. Return \u00b7 < 0 if any input argument is invalid \u00b7 0 on success (packet is forwarded , nexthop neighbor exists) \u00b7 > 0 one of BPF_FIB_LKUP_RET_ codes explaining why the packet is not forwarded or needs assist from full stack ",
              "Function Name": "fib_lookup",
              "Input Params": [
                "{Type: void ,Var: *ctx}",
                "{Type:  struct fib_lookup ,Var: *params}",
                "{Type:  int ,Var: plen}",
                "{Type:  u32 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "xdp"
              ],
              "capabilities": [
                "read_sys_info"
              ]
            },
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Do FIB lookup in kernel tables using parameters in params. If lookup is successful and result shows packet is to be forwarded , the neighbor tables are searched for the nexthop. If successful (ie. , FIB lookup shows forwarding and nexthop is resolved) , the nexthop address is returned in ipv4_dst or ipv6_dst based on family , smac is set to mac address of egress device , dmac is set to nexthop mac address , rt_metric is set to metric from route (IPv4/IPv6 only) , and ifindex is set to the device index of the nexthop from the FIB lookup. <[ plen ]>(IP: 2) argument is the size of the passed in struct. <[ flags ]>(IP: 3) argument can be a combination of one or more of the following values: BPF_FIB_LOOKUP_DIRECT Do a direct table lookup vs full lookup using FIB rules. BPF_FIB_LOOKUP_OUTPUT Perform lookup from an egress perspective (default is ingress). <[ ctx ]>(IP: 0) is either struct xdp_md for XDP programs or struct sk_buff tc cls_act programs. Return \u00b7 < 0 if any input argument is invalid \u00b7 0 on success (packet is forwarded , nexthop neighbor exists) \u00b7 > 0 one of BPF_FIB_LKUP_RET_ codes explaining why the packet is not forwarded or needs assist from full stack ",
              "Function Name": "bpf_fib_lookup",
              "Input Params": [
                "{Type: void ,Var: *ctx}",
                "{Type:  struct bpf_fib_lookup ,Var: *params}",
                "{Type:  int ,Var: plen}",
                "{Type:  u32 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "xdp"
              ],
              "capabilities": [
                "read_sys_info"
              ]
            }
          ]
        },
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        },
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 1955,
      "endLine": 2126,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h",
      "funcName": "rev_nodeport_lb4",
      "developer_inline_comments": [
        {
          "start_line": 1945,
          "end_line": 1954,
          "text": "/* Reverse NAT handling of node-port traffic for the case where the\n * backend i) was a local EP and bpf_lxc redirected to us, ii) was\n * a remote backend and we got here after reverse SNAT from the\n * tail_nodeport_nat_ipv4().\n *\n * Also, reverse NAT handling return path egress-gw traffic.\n *\n * CILIUM_CALL_IPV{4,6}_NODEPORT_REVNAT is plugged into CILIUM_MAP_CALLS\n * of the bpf_host, bpf_overlay and of the bpf_lxc.\n */"
        },
        {
          "start_line": 1982,
          "end_line": 1994,
          "text": "/* Traffic from clients to egress gateway nodes reaches said gateways\n\t * by a vxlan tunnel. If we are not using TUNNEL_MODE, we need to\n\t * identify reverse traffic from the gateway to clients and also steer\n\t * it via the vxlan tunnel to avoid issues with iptables dropping these\n\t * packets. We do this in the code below, by performing a lookup in the\n\t * egress gateway map using a reverse address tuple. A match means that\n\t * the corresponding forward traffic was forwarded to the egress gateway\n\t * via the tunnel.\n\t *\n\t * Currently, we don't support redirect to a tunnel netdev / encap on\n\t * XDP. Thus, the problem mentioned above is present when using the\n\t * egress gw feature with bpf_xdp.\n\t */"
        },
        {
          "start_line": 2009,
          "end_line": 2009,
          "text": "/* ENABLE_EGRESS_GATEWAY */"
        },
        {
          "start_line": 2048,
          "end_line": 2054,
          "text": "/* If the FIB lookup was successful, use the outgoing\n\t\t\t * iface from its result. Otherwise, we will fallback\n\t\t\t * to CT's ifindex which was learned when the request\n\t\t\t * was sent. The latter assumes that the reply should\n\t\t\t * be sent over the same device which received the\n\t\t\t * request.\n\t\t\t */"
        },
        {
          "start_line": 2073,
          "end_line": 2082,
          "text": "/* For the case where a client from the same L2\n\t\t\t * domain previously sent traffic over the node\n\t\t\t * which did the service -> backend translation\n\t\t\t * and that node has never seen the client before\n\t\t\t * then XDP/tc BPF layer won't create a neighbor\n\t\t\t * entry for it. This makes the above fib_lookup()\n\t\t\t * fail and we have to consult the NODEPORT_NEIGH4\n\t\t\t * table instead where we recorded the client\n\t\t\t * address in nodeport_lb4().\n\t\t\t */"
        },
        {
          "start_line": 2118,
          "end_line": 2118,
          "text": "/* fib lookup not necessary when going over tunnel. */"
        }
      ],
      "updateMaps": [],
      "readMaps": [
        "  NODEPORT_NEIGH4"
      ],
      "input": [
        "struct  __ctx_buff *ctx",
        " int *ifindex",
        " int *ext_err"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "fib_lookup",
        "CTX_ACT_OK",
        "bpf_fib_lookup",
        "map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "static __always_inline int rev_nodeport_lb4 (struct  __ctx_buff *ctx, int *ifindex, int *ext_err)\n",
        "{\n",
        "    struct ipv4_ct_tuple tuple = {}\n",
        "    ;\n",
        "    void *data, *data_end;\n",
        "    struct iphdr *ip4;\n",
        "    struct csum_offset csum_off = {}\n",
        "    ;\n",
        "    int ret, fib_ret, ret2, l3_off = ETH_HLEN, l4_off;\n",
        "    struct ct_state ct_state = {}\n",
        "    ;\n",
        "    struct bpf_fib_lookup fib_params = {}\n",
        "    ;\n",
        "    enum trace_reason __maybe_unused reason = TRACE_REASON_UNKNOWN;\n",
        "    __u32 monitor = TRACE_PAYLOAD_LEN;\n",
        "    bool l2_hdr_required = true;\n",
        "    __u32 tunnel_endpoint __maybe_unused = 0;\n",
        "    if (!revalidate_data (ctx, &data, &data_end, &ip4))\n",
        "        return DROP_INVALID;\n",
        "    tuple.nexthdr = ip4->protocol;\n",
        "    tuple.daddr = ip4->daddr;\n",
        "    tuple.saddr = ip4->saddr;\n",
        "    l4_off = l3_off + ipv4_hdrlen (ip4);\n",
        "    csum_l4_offset_and_flags (tuple.nexthdr, &csum_off);\n",
        "\n",
        "#if defined(ENABLE_EGRESS_GATEWAY) && !defined(TUNNEL_MODE) && \\\n",
        "\t__ctx_is != __ctx_xdp\n",
        "    {\n",
        "        struct egress_gw_policy_entry *egress_policy;\n",
        "        egress_policy = lookup_ip4_egress_gw_policy (ip4 -> daddr, ip4 -> saddr);\n",
        "        if (egress_policy) {\n",
        "            struct remote_endpoint_info *info;\n",
        "            info = ipcache_lookup4 (& IPCACHE_MAP, ip4 -> daddr, V4_CACHE_KEY_LEN);\n",
        "            if (info && info->tunnel_endpoint != 0) {\n",
        "                tunnel_endpoint = info->tunnel_endpoint;\n",
        "                goto encap_redirect;\n",
        "            }\n",
        "        }\n",
        "    }\n",
        "\n",
        "#endif /* ENABLE_EGRESS_GATEWAY */\n",
        "    ret = ct_lookup4 (get_ct_map4 (& tuple), & tuple, ctx, l4_off, CT_INGRESS, & ct_state, & monitor);\n",
        "    if (ret == CT_REPLY && ct_state.node_port == 1 && ct_state.rev_nat_index != 0) {\n",
        "        reason = TRACE_REASON_CT_REPLY;\n",
        "        ret2 = lb4_rev_nat (ctx, l3_off, l4_off, & csum_off, & ct_state, & tuple, REV_NAT_F_TUPLE_SADDR, ipv4_has_l4_header (ip4));\n",
        "        if (IS_ERR (ret2))\n",
        "            return ret2;\n",
        "        if (!revalidate_data (ctx, &data, &data_end, &ip4))\n",
        "            return DROP_INVALID;\n",
        "        bpf_mark_snat_done (ctx);\n",
        "        *ifindex = ct_state.ifindex;\n",
        "\n",
        "#if defined(TUNNEL_MODE) && __ctx_is != __ctx_xdp\n",
        "        {\n",
        "            struct remote_endpoint_info *info;\n",
        "            info = ipcache_lookup4 (& IPCACHE_MAP, ip4 -> daddr, V4_CACHE_KEY_LEN);\n",
        "            if (info != NULL && info->tunnel_endpoint != 0) {\n",
        "                tunnel_endpoint = info->tunnel_endpoint;\n",
        "                goto encap_redirect;\n",
        "            }\n",
        "        }\n",
        "\n",
        "#endif\n",
        "        fib_params.family = AF_INET;\n",
        "        fib_params.ifindex = ctx_get_ifindex (ctx);\n",
        "        fib_params.ipv4_src = ip4->saddr;\n",
        "        fib_params.ipv4_dst = ip4->daddr;\n",
        "        fib_ret = fib_lookup (ctx, & fib_params, sizeof (fib_params), 0);\n",
        "        if (fib_ret == 0)\n",
        "            *ifindex = fib_params.ifindex;\n",
        "        ret = maybe_add_l2_hdr (ctx, * ifindex, & l2_hdr_required);\n",
        "        if (ret != 0)\n",
        "            return ret;\n",
        "        if (!l2_hdr_required)\n",
        "            return CTX_ACT_OK;\n",
        "        if (fib_ret != 0) {\n",
        "            union macaddr smac = NATIVE_DEV_MAC_BY_IFINDEX (* ifindex);\n",
        "            union macaddr *dmac;\n",
        "            if (fib_ret != BPF_FIB_LKUP_RET_NO_NEIGH) {\n",
        "                *ext_err = fib_ret;\n",
        "                return DROP_NO_FIB;\n",
        "            }\n",
        "            dmac = map_lookup_elem (& NODEPORT_NEIGH4, & tuple.daddr);\n",
        "            if (unlikely (!dmac)) {\n",
        "                *ext_err = fib_ret;\n",
        "                return DROP_NO_FIB;\n",
        "            }\n",
        "            if (eth_store_daddr_aligned (ctx, dmac->addr, 0) < 0)\n",
        "                return DROP_WRITE_ERROR;\n",
        "            if (eth_store_saddr_aligned (ctx, smac.addr, 0) < 0)\n",
        "                return DROP_WRITE_ERROR;\n",
        "        }\n",
        "        else {\n",
        "            if (eth_store_daddr (ctx, fib_params.dmac, 0) < 0)\n",
        "                return DROP_WRITE_ERROR;\n",
        "            if (eth_store_saddr (ctx, fib_params.smac, 0) < 0)\n",
        "                return DROP_WRITE_ERROR;\n",
        "        }\n",
        "    }\n",
        "    else {\n",
        "        if (!bpf_skip_recirculation (ctx)) {\n",
        "            bpf_skip_nodeport_set (ctx);\n",
        "            ep_tail_call (ctx, CILIUM_CALL_IPV4_FROM_NETDEV);\n",
        "            return DROP_MISSED_TAIL_CALL;\n",
        "        }\n",
        "    }\n",
        "    return CTX_ACT_OK;\n",
        "\n",
        "#if (defined(ENABLE_EGRESS_GATEWAY) || defined(TUNNEL_MODE)) && \\\n",
        "\t__ctx_is != __ctx_xdp\n",
        "encap_redirect :\n",
        "    ret = __encap_with_nodeid (ctx, tunnel_endpoint, SECLABEL, NOT_VTEP_DST, reason, monitor);\n",
        "    if (ret)\n",
        "        return ret;\n",
        "    *ifindex = ENCAP_IFINDEX;\n",
        "    if (eth_store_daddr (ctx, fib_params.dmac, 0) < 0)\n",
        "        return DROP_WRITE_ERROR;\n",
        "    if (eth_store_saddr (ctx, fib_params.smac, 0) < 0)\n",
        "        return DROP_WRITE_ERROR;\n",
        "    return CTX_ACT_OK;\n",
        "\n",
        "#endif\n",
        "}\n"
      ],
      "called_function_list": [
        "bpf_skip_nodeport_set",
        "ipv4_hdrlen",
        "ct_lookup4",
        "ipv4_has_l4_header",
        "maybe_add_l2_hdr",
        "ep_tail_call",
        "eth_store_daddr",
        "eth_store_saddr_aligned",
        "lookup_ip4_egress_gw_policy",
        "bpf_mark_snat_done",
        "__encap_with_nodeid",
        "ipcache_lookup4",
        "get_ct_map4",
        "lb4_rev_nat",
        "ctx_get_ifindex",
        "bpf_skip_recirculation",
        "eth_store_daddr_aligned",
        "eth_store_saddr",
        "csum_l4_offset_and_flags"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "tail_rev_nodeport_lb4": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 2129,
      "endLine": 2162,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h",
      "funcName": "tail_rev_nodeport_lb4",
      "developer_inline_comments": [
        {
          "start_line": 2135,
          "end_line": 2137,
          "text": "/* We only enforce the host policies if nodeport.h is included from\n\t * bpf_host.\n\t */"
        },
        {
          "start_line": 2148,
          "end_line": 2150,
          "text": "/* We don't want to enforce host policies a second time if we jump back to\n\t * bpf_host's handle_ipv6.\n\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "int",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "int tail_rev_nodeport_lb4 (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    int ifindex = 0;\n",
        "    int ext_err = 0;\n",
        "    int ret = 0;\n",
        "\n",
        "#if defined(ENABLE_HOST_FIREWALL) && defined(IS_BPF_HOST)\n",
        "    struct trace_ctx __maybe_unused trace = {\n",
        "        .reason = TRACE_REASON_UNKNOWN,\n",
        "        .monitor = 0,}\n",
        "    ;\n",
        "    __u32 src_id = 0;\n",
        "    ret = ipv4_host_policy_ingress (ctx, & src_id, & trace);\n",
        "    if (IS_ERR (ret))\n",
        "        return send_drop_notify_error (ctx, src_id, ret, CTX_ACT_DROP, METRIC_INGRESS);\n",
        "    ctx_skip_host_fw_set (ctx);\n",
        "\n",
        "#endif\n",
        "    ret = rev_nodeport_lb4 (ctx, & ifindex, & ext_err);\n",
        "    if (IS_ERR (ret))\n",
        "        return send_drop_notify_error_ext (ctx, 0, ret, ext_err, CTX_ACT_DROP, METRIC_EGRESS);\n",
        "    edt_set_aggregate (ctx, 0);\n",
        "    cilium_capture_out (ctx);\n",
        "    return ctx_redirect (ctx, ifindex, 0);\n",
        "}\n"
      ],
      "called_function_list": [
        "edt_set_aggregate",
        "cilium_capture_out",
        "rev_nodeport_lb4",
        "ctx_redirect",
        "ctx_skip_host_fw_set",
        "ipv4_host_policy_ingress"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "tail_handle_nat_fwd_ipv4": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 2170,
      "endLine": 2188,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h",
      "funcName": "tail_handle_nat_fwd_ipv4",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "int",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "int tail_handle_nat_fwd_ipv4 (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    int ret;\n",
        "    enum trace_point obs_point;\n",
        "\n",
        "#if defined(TUNNEL_MODE) && defined(IS_BPF_OVERLAY)\n",
        "    obs_point = TRACE_TO_OVERLAY;\n",
        "\n",
        "#else\n",
        "    obs_point = TRACE_TO_NETWORK;\n",
        "\n",
        "#endif\n",
        "    ret = nodeport_nat_ipv4_fwd (ctx);\n",
        "    if (IS_ERR (ret))\n",
        "        return send_drop_notify_error (ctx, 0, ret, CTX_ACT_DROP, METRIC_EGRESS);\n",
        "    send_trace_notify (ctx, obs_point, 0, 0, 0, 0, TRACE_REASON_UNKNOWN, 0);\n",
        "    return ret;\n",
        "}\n"
      ],
      "called_function_list": [
        "nodeport_nat_ipv4_fwd",
        "send_trace_notify"
      ],
      "call_depth": 10,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "health_encap_v4": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 2192,
      "endLine": 2211,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h",
      "funcName": "health_encap_v4",
      "developer_inline_comments": [
        {
          "start_line": 2198,
          "end_line": 2201,
          "text": "/* When encapsulating, a packet originating from the local\n\t * host is being considered as a packet from a remote node\n\t * as it is being received.\n\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " __u32 tunnel_ep",
        " __u32 seclabel"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int health_encap_v4 (struct  __ctx_buff *ctx, __u32 tunnel_ep, __u32 seclabel)\n",
        "{\n",
        "    struct bpf_tunnel_key key;\n",
        "    memset (&key, 0, sizeof (key));\n",
        "    key.tunnel_id = seclabel == HOST_ID ? LOCAL_NODE_ID : seclabel;\n",
        "    key.remote_ipv4 = bpf_htonl (tunnel_ep);\n",
        "    key.tunnel_ttl = 64;\n",
        "    if (unlikely (ctx_set_tunnel_key (ctx, &key, sizeof (key), BPF_F_ZERO_CSUM_TX) < 0))\n",
        "        return DROP_WRITE_ERROR;\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "memset"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "health_encap_v6": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 2213,
      "endLine": 2232,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h",
      "funcName": "health_encap_v6",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " const union v6addr *tunnel_ep",
        " __u32 seclabel"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int health_encap_v6 (struct  __ctx_buff *ctx, const union v6addr *tunnel_ep, __u32 seclabel)\n",
        "{\n",
        "    struct bpf_tunnel_key key;\n",
        "    memset (&key, 0, sizeof (key));\n",
        "    key.tunnel_id = seclabel == HOST_ID ? LOCAL_NODE_ID : seclabel;\n",
        "    key.remote_ipv6[0] = tunnel_ep->p1;\n",
        "    key.remote_ipv6[1] = tunnel_ep->p2;\n",
        "    key.remote_ipv6[2] = tunnel_ep->p3;\n",
        "    key.remote_ipv6[3] = tunnel_ep->p4;\n",
        "    key.tunnel_ttl = 64;\n",
        "    if (unlikely (ctx_set_tunnel_key (ctx, &key, sizeof (key), BPF_F_ZERO_CSUM_TX | BPF_F_TUNINFO_IPV6) < 0))\n",
        "        return DROP_WRITE_ERROR;\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "memset"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "lb_handle_health": [
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        },
        {
          "capability": "read_sys_info",
          "read_sys_info": [
            {
              "Project": "cilium",
              "Return Type": "u64",
              "Description": "Equivalent to get_socket_cookie() helper that accepts skb , but gets socket from struct sock_ops context. ",
              "Return": " A 8-byte long non-decreasing number.",
              "Function Name": "get_socket_cookie",
              "Input Params": [
                "{Type: struct sock_ops ,Var: *ctx}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "sched_cls",
                "sched_act",
                "cgroup_skb",
                "sock_ops",
                "sk_skb",
                "cgroup_sock_addr"
              ],
              "capabilities": [
                "read_sys_info"
              ]
            }
          ]
        },
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 2234,
      "endLine": 2280,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h",
      "funcName": "lb_handle_health",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [
        "  LB4_HEALTH_MAP",
        "  LB6_HEALTH_MAP"
      ],
      "input": [
        "struct  __ctx_buff * ctx __maybe_unused"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "CTX_ACT_OK",
        "get_socket_cookie",
        "map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act"
      ],
      "source": [
        "static __always_inline int lb_handle_health (struct  __ctx_buff * ctx __maybe_unused)\n",
        "{\n",
        "    void * data __maybe_unused, * data_end __maybe_unused;\n",
        "    __sock_cookie key __maybe_unused;\n",
        "    int ret __maybe_unused;\n",
        "    __u16 proto = 0;\n",
        "    if ((ctx->mark & MARK_MAGIC_HEALTH_IPIP_DONE) == MARK_MAGIC_HEALTH_IPIP_DONE)\n",
        "        return CTX_ACT_OK;\n",
        "    validate_ethertype (ctx, &proto);\n",
        "    switch (proto) {\n",
        "\n",
        "#if defined(ENABLE_IPV4) && DSR_ENCAP_MODE == DSR_ENCAP_IPIP\n",
        "    case bpf_htons (ETH_P_IP) :\n",
        "        {\n",
        "            struct lb4_health *val;\n",
        "            key = get_socket_cookie (ctx);\n",
        "            val = map_lookup_elem (& LB4_HEALTH_MAP, & key);\n",
        "            if (!val)\n",
        "                return CTX_ACT_OK;\n",
        "            ret = health_encap_v4 (ctx, val -> peer.address, 0);\n",
        "            if (ret != 0)\n",
        "                return ret;\n",
        "            ctx->mark |= MARK_MAGIC_HEALTH_IPIP_DONE;\n",
        "            return ctx_redirect (ctx, ENCAP4_IFINDEX, 0);\n",
        "        }\n",
        "\n",
        "#endif\n",
        "\n",
        "#if defined(ENABLE_IPV6) && DSR_ENCAP_MODE == DSR_ENCAP_IPIP\n",
        "    case bpf_htons (ETH_P_IPV6) :\n",
        "        {\n",
        "            struct lb6_health *val;\n",
        "            key = get_socket_cookie (ctx);\n",
        "            val = map_lookup_elem (& LB6_HEALTH_MAP, & key);\n",
        "            if (!val)\n",
        "                return CTX_ACT_OK;\n",
        "            ret = health_encap_v6 (ctx, & val -> peer.address, 0);\n",
        "            if (ret != 0)\n",
        "                return ret;\n",
        "            ctx->mark |= MARK_MAGIC_HEALTH_IPIP_DONE;\n",
        "            return ctx_redirect (ctx, ENCAP6_IFINDEX, 0);\n",
        "        }\n",
        "\n",
        "#endif\n",
        "    default :\n",
        "        return CTX_ACT_OK;\n",
        "    }\n",
        "}\n"
      ],
      "called_function_list": [
        "health_encap_v4",
        "health_encap_v6",
        "validate_ethertype",
        "ctx_redirect"
      ],
      "call_depth": 4,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "handle_nat_fwd": [
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 2283,
      "endLine": 2319,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h",
      "funcName": "handle_nat_fwd",
      "developer_inline_comments": [
        {
          "start_line": 2301,
          "end_line": 2301,
          "text": "/* ENABLE_IPV4 */"
        },
        {
          "start_line": 2311,
          "end_line": 2311,
          "text": "/* ENABLE_IPV6 */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "CTX_ACT_OK"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "static __always_inline int handle_nat_fwd (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    int ret = CTX_ACT_OK;\n",
        "    __u16 proto;\n",
        "    if (!validate_ethertype (ctx, &proto))\n",
        "        return CTX_ACT_OK;\n",
        "    switch (proto) {\n",
        "\n",
        "#ifdef ENABLE_IPV4\n",
        "    case bpf_htons (ETH_P_IP) :\n",
        "        invoke_tailcall_if (__or3 (__and (is_defined (ENABLE_IPV4), is_defined (ENABLE_IPV6)), __and (is_defined (ENABLE_HOST_FIREWALL), is_defined (IS_BPF_HOST)), is_defined (ENABLE_EGRESS_GATEWAY)), CILIUM_CALL_IPV4_ENCAP_NODEPORT_NAT, tail_handle_nat_fwd_ipv4);\n",
        "        break;\n",
        "\n",
        "#endif /* ENABLE_IPV4 */\n",
        "\n",
        "#ifdef ENABLE_IPV6\n",
        "    case bpf_htons (ETH_P_IPV6) :\n",
        "        invoke_tailcall_if (__or (__and (is_defined (ENABLE_IPV4), is_defined (ENABLE_IPV6)), __and (is_defined (ENABLE_HOST_FIREWALL), is_defined (IS_BPF_HOST))), CILIUM_CALL_IPV6_ENCAP_NODEPORT_NAT, tail_handle_nat_fwd_ipv6);\n",
        "        break;\n",
        "\n",
        "#endif /* ENABLE_IPV6 */\n",
        "    default :\n",
        "        build_bug_on (!(NODEPORT_PORT_MIN_NAT < NODEPORT_PORT_MAX_NAT));\n",
        "        build_bug_on (!(NODEPORT_PORT_MIN < NODEPORT_PORT_MAX));\n",
        "        build_bug_on (!(NODEPORT_PORT_MAX < NODEPORT_PORT_MIN_NAT));\n",
        "        break;\n",
        "    }\n",
        "    return ret;\n",
        "}\n"
      ],
      "called_function_list": [
        "validate_ethertype"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "identity_in_range": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 9,
      "endLine": 12,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/identity.h",
      "funcName": "identity_in_range",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */"
        },
        {
          "start_line": 2,
          "end_line": 2,
          "text": "/* Copyright Authors of Cilium */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "__u32 identity",
        " __u32 range_start",
        " __u32 range_end"
      ],
      "output": "static__always_inlinebool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline bool identity_in_range (__u32 identity, __u32 range_start, __u32 range_end)\n",
        "{\n",
        "    return range_start <= identity && identity <= range_end;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "identity_is_remote_node": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 14,
      "endLine": 32,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/identity.h",
      "funcName": "identity_is_remote_node",
      "developer_inline_comments": [
        {
          "start_line": 16,
          "end_line": 30,
          "text": "/* KUBE_APISERVER_NODE_ID is the reserved identity that corresponds to\n\t * the labels 'reserved:remote-node' and 'reserved:kube-apiserver'. As\n\t * such, if it is ever used for determining the identity of a node in\n\t * the cluster, then routing decisions and so on should be made the\n\t * same way as for REMOTE_NODE_ID. If we ever assign unique identities\n\t * to each node in the cluster, then we'll probably need to convert\n\t * the implementation here into a map to select any of the possible\n\t * identities. But for now, this is good enough to capture the notion\n\t * of 'remote nodes in the cluster' for routing decisions.\n\t *\n\t * Note that kube-apiserver policy is handled entirely separately by\n\t * the standard policymap enforcement logic and has no relationship to\n\t * the identity as used here. If the apiserver is outside the cluster,\n\t * then the KUBE_APISERVER_NODE_ID case should not ever be hit.\n\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "__u32 identity"
      ],
      "output": "static__always_inlinebool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline bool identity_is_remote_node (__u32 identity)\n",
        "{\n",
        "    return identity == REMOTE_NODE_ID || identity == KUBE_APISERVER_NODE_ID;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "identity_is_node": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 34,
      "endLine": 37,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/identity.h",
      "funcName": "identity_is_node",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "__u32 identity"
      ],
      "output": "static__always_inlinebool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline bool identity_is_node (__u32 identity)\n",
        "{\n",
        "    return identity == HOST_ID || identity_is_remote_node (identity);\n",
        "}\n"
      ],
      "called_function_list": [
        "identity_is_remote_node"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "identity_is_reserved": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 57,
      "endLine": 60,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/identity.h",
      "funcName": "identity_is_reserved",
      "developer_inline_comments": [
        {
          "start_line": 39,
          "end_line": 56,
          "text": "/**\n * identity_is_reserved is used to determine whether an identity is one of the\n * reserved identities that are not handed out to endpoints.\n *\n * Specifically, it should return true if the identity is one of these:\n * - IdentityUnknown\n * - ReservedIdentityHost\n * - ReservedIdentityWorld\n * - ReservedIdentityRemoteNode\n * - ReservedIdentityKubeAPIServer\n *\n * The following identities are given to endpoints so return false for these:\n * - ReservedIdentityUnmanaged\n * - ReservedIdentityHealth\n * - ReservedIdentityInit\n *\n * Identities 128 and higher are guaranteed to be generated based on user input.\n */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "__u32 identity"
      ],
      "output": "static__always_inlinebool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline bool identity_is_reserved (__u32 identity)\n",
        "{\n",
        "    return identity < UNMANAGED_ID || identity_is_remote_node (identity);\n",
        "}\n"
      ],
      "called_function_list": [
        "identity_is_remote_node"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "identity_is_cluster": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 80,
      "endLine": 90,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/identity.h",
      "funcName": "identity_is_cluster",
      "developer_inline_comments": [
        {
          "start_line": 62,
          "end_line": 79,
          "text": "/**\n * identity_is_cluster is used to determine whether an identity is assigned to\n * an entity inside the cluster.\n *\n * This function will return false for:\n * - ReservedIdentityWorld\n * - an identity in the CIDR range\n *\n * This function will return true for:\n * - ReservedIdentityHost\n * - ReservedIdentityUnmanaged\n * - ReservedIdentityHealth\n * - ReservedIdentityInit\n * - ReservedIdentityRemoteNode\n * - ReservedIdentityKubeAPIServer\n * - ReservedIdentityIngress\n * - all other identifies\n */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "__u32 identity"
      ],
      "output": "static__always_inlinebool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline bool identity_is_cluster (__u32 identity)\n",
        "{\n",
        "    if (identity == WORLD_ID)\n",
        "        return false;\n",
        "    if (identity_in_range (identity, CIDR_IDENTITY_RANGE_START, CIDR_IDENTITY_RANGE_END))\n",
        "        return false;\n",
        "    return true;\n",
        "}\n"
      ],
      "called_function_list": [
        "identity_in_range"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "inherit_identity_from_host": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 93,
      "endLine": 137,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/identity.h",
      "funcName": "inherit_identity_from_host",
      "developer_inline_comments": [
        {
          "start_line": 97,
          "end_line": 100,
          "text": "/* Packets from the ingress proxy must skip the proxy when the\n\t * destination endpoint evaluates the policy. As the packet would loop\n\t * and/or the connection be reset otherwise.\n\t */"
        },
        {
          "start_line": 104,
          "end_line": 107,
          "text": "/* (Return) packets from the egress proxy must skip the redirection to\n\t * the proxy, as the packet would loop and/or the connection be reset\n\t * otherwise.\n\t */"
        },
        {
          "start_line": 119,
          "end_line": 119,
          "text": "/* endpoint identity, not security identity! */"
        },
        {
          "start_line": 125,
          "end_line": 125,
          "text": "/* Reset packet mark to avoid hitting routing rules again */"
        },
        {
          "start_line": 129,
          "end_line": 131,
          "text": "/* Caller tail calls back to source endpoint egress in this case,\n\t * do not log the (world) identity.\n\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " __u32 *identity"
      ],
      "output": "static__always_inline__u32",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __u32 inherit_identity_from_host (struct  __ctx_buff *ctx, __u32 *identity)\n",
        "{\n",
        "    __u32 magic = ctx->mark & MARK_MAGIC_HOST_MASK;\n",
        "    if (magic == MARK_MAGIC_PROXY_INGRESS) {\n",
        "        *identity = get_identity (ctx);\n",
        "        ctx->tc_index |= TC_INDEX_F_SKIP_INGRESS_PROXY;\n",
        "    }\n",
        "    else if (magic == MARK_MAGIC_PROXY_EGRESS) {\n",
        "        *identity = get_identity (ctx);\n",
        "        ctx->tc_index |= TC_INDEX_F_SKIP_EGRESS_PROXY;\n",
        "    }\n",
        "    else if (magic == MARK_MAGIC_IDENTITY) {\n",
        "        *identity = get_identity (ctx);\n",
        "    }\n",
        "    else if (magic == MARK_MAGIC_HOST) {\n",
        "        *identity = HOST_ID;\n",
        "    }\n",
        "    else if (magic == MARK_MAGIC_ENCRYPT) {\n",
        "        *identity = get_identity (ctx);\n",
        "\n",
        "#if defined(ENABLE_L7_LB)\n",
        "    }\n",
        "    else if (magic == MARK_MAGIC_PROXY_EGRESS_EPID) {\n",
        "        *identity = get_epid (ctx);\n",
        "\n",
        "#endif\n",
        "    }\n",
        "    else {\n",
        "        *identity = WORLD_ID;\n",
        "    }\n",
        "    ctx->mark = 0;\n",
        "\n",
        "#if defined(ENABLE_L7_LB)\n",
        "    if (magic != MARK_MAGIC_PROXY_EGRESS_EPID)\n",
        "\n",
        "#endif\n",
        "        cilium_dbg (ctx, DBG_INHERIT_IDENTITY, *identity, 0);\n",
        "    return magic;\n",
        "}\n"
      ],
      "called_function_list": [
        "get_identity",
        "get_epid",
        "cilium_dbg"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ipv4_load_daddr": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 35,
      "endLine": 39,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv4.h",
      "funcName": "ipv4_load_daddr",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */"
        },
        {
          "start_line": 2,
          "end_line": 2,
          "text": "/* Copyright Authors of Cilium */"
        },
        {
          "start_line": 15,
          "end_line": 15,
          "text": "/* L4 datagram identifier */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " int off",
        " __u32 *dst"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int ipv4_load_daddr (struct  __ctx_buff *ctx, int off, __u32 *dst)\n",
        "{\n",
        "    return ctx_load_bytes (ctx, off + offsetof (struct iphdr, daddr), dst, 4);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ipv4_dec_ttl": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 41,
      "endLine": 55,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv4.h",
      "funcName": "ipv4_dec_ttl",
      "developer_inline_comments": [
        {
          "start_line": 50,
          "end_line": 50,
          "text": "/* l3_csum_replace() takes at min 2 bytes, zero extended. */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " int off",
        " const struct iphdr *ip4"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "l3_csum_replace"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "lwt_xmit"
      ],
      "source": [
        "static __always_inline int ipv4_dec_ttl (struct  __ctx_buff *ctx, int off, const struct iphdr *ip4)\n",
        "{\n",
        "    __u8 new_ttl, ttl = ip4->ttl;\n",
        "    if (ttl <= 1)\n",
        "        return 1;\n",
        "    new_ttl = ttl - 1;\n",
        "    l3_csum_replace (ctx, off + offsetof (struct iphdr, check), ttl, new_ttl, 2);\n",
        "    ctx_store_bytes (ctx, off + offsetof (struct iphdr, ttl), &new_ttl, sizeof (new_ttl), 0);\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ipv4_hdrlen": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 57,
      "endLine": 60,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv4.h",
      "funcName": "ipv4_hdrlen",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct iphdr *ip4"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int ipv4_hdrlen (const struct iphdr *ip4)\n",
        "{\n",
        "    return ip4->ihl * 4;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ipv4_is_fragment": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 62,
      "endLine": 74,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv4.h",
      "funcName": "ipv4_is_fragment",
      "developer_inline_comments": [
        {
          "start_line": 64,
          "end_line": 72,
          "text": "/* The frag_off portion of the header consists of:\n\t *\n\t * +----+----+----+----------------------------------+\n\t * | RS | DF | MF | ...13 bits of fragment offset... |\n\t * +----+----+----+----------------------------------+\n\t *\n\t * If \"More fragments\" or the offset is nonzero, then this is an IP\n\t * fragment (RFC791).\n\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct iphdr *ip4"
      ],
      "output": "static__always_inlinebool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline bool ipv4_is_fragment (const struct iphdr *ip4)\n",
        "{\n",
        "    return ip4->frag_off & bpf_htons (0x3FFF);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ipv4_is_not_first_fragment": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 76,
      "endLine": 80,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv4.h",
      "funcName": "ipv4_is_not_first_fragment",
      "developer_inline_comments": [
        {
          "start_line": 78,
          "end_line": 78,
          "text": "/* Ignore \"More fragments\" bit to catch all fragments but the first */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct iphdr *ip4"
      ],
      "output": "static__always_inlinebool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline bool ipv4_is_not_first_fragment (const struct iphdr *ip4)\n",
        "{\n",
        "    return ip4->frag_off & bpf_htons (0x1FFF);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ipv4_has_l4_header": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 83,
      "endLine": 86,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv4.h",
      "funcName": "ipv4_has_l4_header",
      "developer_inline_comments": [
        {
          "start_line": 82,
          "end_line": 82,
          "text": "/* Simply a reverse of ipv4_is_not_first_fragment to avoid double negative. */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct iphdr *ip4"
      ],
      "output": "static__always_inlinebool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline bool ipv4_has_l4_header (const struct iphdr *ip4)\n",
        "{\n",
        "    return !ipv4_is_not_first_fragment (ip4);\n",
        "}\n"
      ],
      "called_function_list": [
        "ipv4_is_not_first_fragment"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ipv4_is_in_subnet": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 88,
      "endLine": 92,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv4.h",
      "funcName": "ipv4_is_in_subnet",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "__be32 addr",
        " __be32 subnet",
        " int prefixlen"
      ],
      "output": "static__always_inlinebool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline bool ipv4_is_in_subnet (__be32 addr, __be32 subnet, int prefixlen)\n",
        "{\n",
        "    return (addr & bpf_htonl (~((1 << (32 - prefixlen)) - 1))) == subnet;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ipv4_frag_get_l4ports": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 95,
      "endLine": 108,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv4.h",
      "funcName": "ipv4_frag_get_l4ports",
      "developer_inline_comments": [
        {
          "start_line": 105,
          "end_line": 105,
          "text": "/* Do not make ports a pointer to map data, copy from map */"
        }
      ],
      "updateMaps": [],
      "readMaps": [
        "  IPV4_FRAG_DATAGRAMS_MAP"
      ],
      "input": [
        "const struct ipv4_frag_id *frag_id",
        " struct ipv4_frag_l4ports *ports"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int ipv4_frag_get_l4ports (const struct ipv4_frag_id *frag_id, struct ipv4_frag_l4ports *ports)\n",
        "{\n",
        "    struct ipv4_frag_l4ports *tmp;\n",
        "    tmp = map_lookup_elem (& IPV4_FRAG_DATAGRAMS_MAP, frag_id);\n",
        "    if (!tmp)\n",
        "        return DROP_FRAG_NOT_FOUND;\n",
        "    memcpy (ports, tmp, sizeof (*ports));\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "memcpy"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ipv4_handle_fragmentation": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 110,
      "endLine": 161,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv4.h",
      "funcName": "ipv4_handle_fragmentation",
      "developer_inline_comments": [
        {
          "start_line": 143,
          "end_line": 143,
          "text": "/* load sport + dport into tuple */"
        },
        {
          "start_line": 149,
          "end_line": 151,
          "text": "/* First logical fragment for this datagram (not necessarily the first\n\t\t * we receive). Fragment has L4 header, create an entry in datagrams map.\n\t\t */"
        },
        {
          "start_line": 155,
          "end_line": 157,
          "text": "/* Do not return an error if map update failed, as nothing prevents us\n\t\t * to process the current packet normally.\n\t\t */"
        }
      ],
      "updateMaps": [
        " IPV4_FRAG_DATAGRAMS_MAP"
      ],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " const struct iphdr *ip4",
        " int l4_off",
        " enum ct_dir ct_dir",
        " struct ipv4_frag_l4ports *ports",
        " bool *has_l4_header"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int ipv4_handle_fragmentation (struct  __ctx_buff *ctx, const struct iphdr *ip4, int l4_off, enum ct_dir ct_dir, struct ipv4_frag_l4ports *ports, bool *has_l4_header)\n",
        "{\n",
        "    bool is_fragment, not_first_fragment;\n",
        "    enum metric_dir dir;\n",
        "    int ret;\n",
        "    struct ipv4_frag_id frag_id = {\n",
        "        .daddr = ip4->daddr,\n",
        "        .saddr = ip4->saddr,\n",
        "        .id = ip4->id,\n",
        "        .proto = ip4->protocol,\n",
        "        .pad = 0,}\n",
        "    ;\n",
        "    is_fragment = ipv4_is_fragment (ip4);\n",
        "    dir = ct_to_metrics_dir (ct_dir);\n",
        "    if (unlikely (is_fragment)) {\n",
        "        update_metrics (ctx_full_len (ctx), dir, REASON_FRAG_PACKET);\n",
        "        not_first_fragment = ipv4_is_not_first_fragment (ip4);\n",
        "        if (has_l4_header)\n",
        "            *has_l4_header = !not_first_fragment;\n",
        "        if (likely (not_first_fragment))\n",
        "            return ipv4_frag_get_l4ports (&frag_id, ports);\n",
        "    }\n",
        "    ret = ctx_load_bytes (ctx, l4_off, ports, 4);\n",
        "    if (ret < 0)\n",
        "        return ret;\n",
        "    if (unlikely (is_fragment)) {\n",
        "        if (map_update_elem (&IPV4_FRAG_DATAGRAMS_MAP, &frag_id, ports, BPF_ANY))\n",
        "            update_metrics (ctx_full_len (ctx), dir, REASON_FRAG_PACKET_UPDATE);\n",
        "    }\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_full_len",
        "ipv4_frag_get_l4ports",
        "ipv4_is_not_first_fragment",
        "ipv4_is_fragment",
        "ct_to_metrics_dir",
        "update_metrics"
      ],
      "call_depth": 4,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ipv6_optlen": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 38,
      "endLine": 41,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv6.h",
      "funcName": "ipv6_optlen",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */"
        },
        {
          "start_line": 2,
          "end_line": 2,
          "text": "/* Copyright Authors of Cilium */"
        },
        {
          "start_line": 18,
          "end_line": 18,
          "text": "/* Number of extension headers that can be skipped */"
        },
        {
          "start_line": 21,
          "end_line": 21,
          "text": "/* Hop-by-hop option header. */"
        },
        {
          "start_line": 22,
          "end_line": 22,
          "text": "/* TCP segment. */"
        },
        {
          "start_line": 23,
          "end_line": 23,
          "text": "/* UDP message. */"
        },
        {
          "start_line": 24,
          "end_line": 24,
          "text": "/* IPv6 in IPv6 */"
        },
        {
          "start_line": 25,
          "end_line": 25,
          "text": "/* Routing header. */"
        },
        {
          "start_line": 26,
          "end_line": 26,
          "text": "/* Fragmentation/reassembly header. */"
        },
        {
          "start_line": 27,
          "end_line": 27,
          "text": "/* GRE header. */"
        },
        {
          "start_line": 28,
          "end_line": 28,
          "text": "/* Encapsulating security payload. */"
        },
        {
          "start_line": 29,
          "end_line": 29,
          "text": "/* Authentication header. */"
        },
        {
          "start_line": 30,
          "end_line": 30,
          "text": "/* ICMP for IPv6. */"
        },
        {
          "start_line": 31,
          "end_line": 31,
          "text": "/* No next header */"
        },
        {
          "start_line": 32,
          "end_line": 32,
          "text": "/* Destination options header. */"
        },
        {
          "start_line": 33,
          "end_line": 33,
          "text": "/* SCTP message. */"
        },
        {
          "start_line": 34,
          "end_line": 34,
          "text": "/* Mobility header. */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct ipv6_opt_hdr *opthdr"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int ipv6_optlen (const struct ipv6_opt_hdr *opthdr)\n",
        "{\n",
        "    return (opthdr->hdrlen + 1) << 3;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ipv6_authlen": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 43,
      "endLine": 46,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv6.h",
      "funcName": "ipv6_authlen",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct ipv6_opt_hdr *opthdr"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int ipv6_authlen (const struct ipv6_opt_hdr *opthdr)\n",
        "{\n",
        "    return (opthdr->hdrlen + 2) << 2;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ipv6_hdrlen": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 48,
      "endLine": 85,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv6.h",
      "funcName": "ipv6_hdrlen",
      "developer_inline_comments": [
        {
          "start_line": 83,
          "end_line": 83,
          "text": "/* Reached limit of supported extension headers */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " __u8 *nexthdr"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int ipv6_hdrlen (struct  __ctx_buff *ctx, __u8 *nexthdr)\n",
        "{\n",
        "    int i, len = sizeof (struct ipv6hdr);\n",
        "    struct ipv6_opt_hdr opthdr __align_stack_8;\n",
        "    __u8 nh = *nexthdr;\n",
        "\n",
        "#pragma unroll\n",
        "    for (i = 0; i < IPV6_MAX_HEADERS; i++) {\n",
        "        switch (nh) {\n",
        "        case NEXTHDR_NONE :\n",
        "            return DROP_INVALID_EXTHDR;\n",
        "        case NEXTHDR_FRAGMENT :\n",
        "            return DROP_FRAG_NOSUPPORT;\n",
        "        case NEXTHDR_HOP :\n",
        "        case NEXTHDR_ROUTING :\n",
        "        case NEXTHDR_AUTH :\n",
        "        case NEXTHDR_DEST :\n",
        "            if (ctx_load_bytes (ctx, ETH_HLEN + len, &opthdr, sizeof (opthdr)) < 0)\n",
        "                return DROP_INVALID;\n",
        "            nh = opthdr.nexthdr;\n",
        "            if (nh == NEXTHDR_AUTH)\n",
        "                len += ipv6_authlen (&opthdr);\n",
        "            else\n",
        "                len += ipv6_optlen (&opthdr);\n",
        "            break;\n",
        "        default :\n",
        "            *nexthdr = nh;\n",
        "            return len;\n",
        "        }\n",
        "    }\n",
        "    return DROP_INVALID_EXTHDR;\n",
        "}\n"
      ],
      "called_function_list": [
        "ipv6_authlen",
        "ipv6_optlen"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ipv6_addr_copy": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 87,
      "endLine": 92,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv6.h",
      "funcName": "ipv6_addr_copy",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "union v6addr *dst",
        " const union v6addr *src"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void ipv6_addr_copy (union v6addr *dst, const union v6addr *src)\n",
        "{\n",
        "    dst->d1 = src->d1;\n",
        "    dst->d2 = src->d2;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ipv6_addrcmp": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 94,
      "endLine": 103,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv6.h",
      "funcName": "ipv6_addrcmp",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const union v6addr *a",
        " const union v6addr *b"
      ],
      "output": "static__always_inline__u64",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __u64 ipv6_addrcmp (const union v6addr *a, const union v6addr *b)\n",
        "{\n",
        "    __u64 tmp;\n",
        "    tmp = a->d1 - b->d1;\n",
        "    if (!tmp)\n",
        "        tmp = a->d2 - b->d2;\n",
        "    return tmp;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ipv6_addr_in_net": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 106,
      "endLine": 116,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv6.h",
      "funcName": "ipv6_addr_in_net",
      "developer_inline_comments": [
        {
          "start_line": 105,
          "end_line": 105,
          "text": "/* Only works with contiguous masks. */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const union v6addr *addr",
        " const union v6addr *net",
        " const union v6addr *mask"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int ipv6_addr_in_net (const union v6addr *addr, const union v6addr *net, const union v6addr *mask)\n",
        "{\n",
        "    return ((addr->p1 & mask->p1) == net->p1) && (!mask->p2 || (((addr->p2 & mask->p2) == net->p2) && (!mask->p3 || (((addr->p3 & mask->p3) == net->p3) && (!mask->p4 || ((addr->p4 & mask->p4) == net->p4))))));\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ipv6_addr_clear_suffix": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 122,
      "endLine": 132,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv6.h",
      "funcName": "ipv6_addr_clear_suffix",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "union v6addr *addr",
        " int prefix"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void ipv6_addr_clear_suffix (union v6addr *addr, int prefix)\n",
        "{\n",
        "    addr->p1 &= GET_PREFIX (prefix);\n",
        "    prefix -= 32;\n",
        "    addr->p2 &= GET_PREFIX (prefix);\n",
        "    prefix -= 32;\n",
        "    addr->p3 &= GET_PREFIX (prefix);\n",
        "    prefix -= 32;\n",
        "    addr->p4 &= GET_PREFIX (prefix);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ipv6_match_prefix_64": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 134,
      "endLine": 144,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv6.h",
      "funcName": "ipv6_match_prefix_64",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const union v6addr *addr",
        " const union v6addr *prefix"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int ipv6_match_prefix_64 (const union v6addr *addr, const union v6addr *prefix)\n",
        "{\n",
        "    int tmp;\n",
        "    tmp = addr->p1 - prefix->p1;\n",
        "    if (!tmp)\n",
        "        tmp = addr->p2 - prefix->p2;\n",
        "    return !tmp;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ipv6_dec_hoplimit": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 146,
      "endLine": 161,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv6.h",
      "funcName": "ipv6_dec_hoplimit",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " int off"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int ipv6_dec_hoplimit (struct  __ctx_buff *ctx, int off)\n",
        "{\n",
        "    __u8 hl;\n",
        "    if (ctx_load_bytes (ctx, off + offsetof (struct ipv6hdr, hop_limit), &hl, sizeof (hl)) < 0)\n",
        "        return DROP_INVALID;\n",
        "    if (hl <= 1)\n",
        "        return 1;\n",
        "    hl--;\n",
        "    if (ctx_store_bytes (ctx, off + offsetof (struct ipv6hdr, hop_limit), &hl, sizeof (hl), BPF_F_RECOMPUTE_CSUM) < 0)\n",
        "        return DROP_WRITE_ERROR;\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ipv6_load_saddr": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 163,
      "endLine": 168,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv6.h",
      "funcName": "ipv6_load_saddr",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " int off",
        " union v6addr *dst"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int ipv6_load_saddr (struct  __ctx_buff *ctx, int off, union v6addr *dst)\n",
        "{\n",
        "    return ctx_load_bytes (ctx, off + offsetof (struct ipv6hdr, saddr), dst->addr, sizeof (((struct ipv6hdr *) NULL)->saddr));\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ipv6_store_saddr": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 171,
      "endLine": 175,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv6.h",
      "funcName": "ipv6_store_saddr",
      "developer_inline_comments": [
        {
          "start_line": 170,
          "end_line": 170,
          "text": "/* Assumes that caller fixes checksum csum_diff() and l4_csum_replace() */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " __u8 *addr",
        " int off"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int ipv6_store_saddr (struct  __ctx_buff *ctx, __u8 *addr, int off)\n",
        "{\n",
        "    return ctx_store_bytes (ctx, off + offsetof (struct ipv6hdr, saddr), addr, 16, 0);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ipv6_load_daddr": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 177,
      "endLine": 182,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv6.h",
      "funcName": "ipv6_load_daddr",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " int off",
        " union v6addr *dst"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int ipv6_load_daddr (struct  __ctx_buff *ctx, int off, union v6addr *dst)\n",
        "{\n",
        "    return ctx_load_bytes (ctx, off + offsetof (struct ipv6hdr, daddr), dst->addr, sizeof (((struct ipv6hdr *) NULL)->daddr));\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ipv6_store_daddr": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 185,
      "endLine": 189,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv6.h",
      "funcName": "ipv6_store_daddr",
      "developer_inline_comments": [
        {
          "start_line": 184,
          "end_line": 184,
          "text": "/* Assumes that caller fixes checksum csum_diff() and l4_csum_replace() */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " const __u8 *addr",
        " int off"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int ipv6_store_daddr (struct  __ctx_buff *ctx, const __u8 *addr, int off)\n",
        "{\n",
        "    return ctx_store_bytes (ctx, off + offsetof (struct ipv6hdr, daddr), addr, 16, 0);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ipv6_load_nexthdr": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 191,
      "endLine": 196,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv6.h",
      "funcName": "ipv6_load_nexthdr",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " int off",
        " __u8 *nexthdr"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int ipv6_load_nexthdr (struct  __ctx_buff *ctx, int off, __u8 *nexthdr)\n",
        "{\n",
        "    return ctx_load_bytes (ctx, off + offsetof (struct ipv6hdr, nexthdr), nexthdr, sizeof (__u8));\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ipv6_store_nexthdr": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 199,
      "endLine": 204,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv6.h",
      "funcName": "ipv6_store_nexthdr",
      "developer_inline_comments": [
        {
          "start_line": 198,
          "end_line": 198,
          "text": "/* Assumes that caller fixes checksum csum_diff() and l4_csum_replace() */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " __u8 *nexthdr",
        " int off"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int ipv6_store_nexthdr (struct  __ctx_buff *ctx, __u8 *nexthdr, int off)\n",
        "{\n",
        "    return ctx_store_bytes (ctx, off + offsetof (struct ipv6hdr, nexthdr), nexthdr, sizeof (__u8), 0);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ipv6_load_paylen": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 206,
      "endLine": 211,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv6.h",
      "funcName": "ipv6_load_paylen",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " int off",
        " __be16 *len"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int ipv6_load_paylen (struct  __ctx_buff *ctx, int off, __be16 *len)\n",
        "{\n",
        "    return ctx_load_bytes (ctx, off + offsetof (struct ipv6hdr, payload_len), len, sizeof (*len));\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ipv6_store_paylen": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 214,
      "endLine": 219,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv6.h",
      "funcName": "ipv6_store_paylen",
      "developer_inline_comments": [
        {
          "start_line": 213,
          "end_line": 213,
          "text": "/* Assumes that caller fixes checksum csum_diff() and l4_csum_replace() */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " int off",
        " __be16 *len"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int ipv6_store_paylen (struct  __ctx_buff *ctx, int off, __be16 *len)\n",
        "{\n",
        "    return ctx_store_bytes (ctx, off + offsetof (struct ipv6hdr, payload_len), len, sizeof (*len), 0);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ipv6_store_flowlabel": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 221,
      "endLine": 237,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv6.h",
      "funcName": "ipv6_store_flowlabel",
      "developer_inline_comments": [
        {
          "start_line": 226,
          "end_line": 226,
          "text": "/* use traffic class from packet */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " int off",
        " __be32 label"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int ipv6_store_flowlabel (struct  __ctx_buff *ctx, int off, __be32 label)\n",
        "{\n",
        "    __be32 old;\n",
        "    if (ctx_load_bytes (ctx, off, &old, 4) < 0)\n",
        "        return DROP_INVALID;\n",
        "    old &= IPV6_TCLASS_MASK;\n",
        "    old = bpf_htonl (0x60000000) | label | old;\n",
        "    if (ctx_store_bytes (ctx, off, &old, 4, BPF_F_RECOMPUTE_CSUM) < 0)\n",
        "        return DROP_WRITE_ERROR;\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ipv6_pseudohdr_checksum": [
    {
      "capabilities": [
        {
          "capability": "read_skb",
          "read_skb": [
            {
              "Project": "cilium",
              "Return Type": "s64",
              "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ",
              "Return": " The checksum result, or a negative error code in case of failure.",
              "Function Name": "csum_diff",
              "Input Params": [
                "{Type: __be32 ,Var: *from}",
                "{Type:  u32 ,Var: from_size}",
                "{Type:  __be32 ,Var: *to}",
                "{Type:  u32 ,Var: to_size}",
                "{Type:  __wsum ,Var: seed}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "xdp",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "lwt_seg6local"
              ],
              "capabilities": [
                "read_skb"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 239,
      "endLine": 252,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv6.h",
      "funcName": "ipv6_pseudohdr_checksum",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct ipv6hdr *hdr",
        " __u8 next_hdr",
        " __u16 payload_len",
        " __be32 sum"
      ],
      "output": "static__always_inline__be32",
      "helper": [
        "csum_diff"
      ],
      "compatibleHookpoints": [
        "lwt_seg6local",
        "sched_act",
        "xdp",
        "lwt_xmit",
        "sched_cls",
        "lwt_in",
        "lwt_out"
      ],
      "source": [
        "static __always_inline __be32 ipv6_pseudohdr_checksum (struct ipv6hdr *hdr, __u8 next_hdr, __u16 payload_len, __be32 sum)\n",
        "{\n",
        "    __be32 len = bpf_htonl ((__u32) payload_len);\n",
        "    __be32 nexthdr = bpf_htonl ((__u32) next_hdr);\n",
        "    sum = csum_diff (NULL, 0, & hdr -> saddr, sizeof (struct in6_addr), sum);\n",
        "    sum = csum_diff (NULL, 0, & hdr -> daddr, sizeof (struct in6_addr), sum);\n",
        "    sum = csum_diff (NULL, 0, & len, sizeof (len), sum);\n",
        "    sum = csum_diff (NULL, 0, & nexthdr, sizeof (nexthdr), sum);\n",
        "    return sum;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ipv6_addr_is_mapped": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 257,
      "endLine": 260,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv6.h",
      "funcName": "ipv6_addr_is_mapped",
      "developer_inline_comments": [
        {
          "start_line": 254,
          "end_line": 256,
          "text": "/*\n * Ipv4 mapped address - 0:0:0:0:0:FFFF::/96\n */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const union v6addr *addr"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int ipv6_addr_is_mapped (const union v6addr *addr)\n",
        "{\n",
        "    return addr->p1 == 0 && addr->p2 == 0 && addr->p3 == 0xFFFF0000;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "reset_queue_mapping": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 9,
      "endLine": 22,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/qm.h",
      "funcName": "reset_queue_mapping",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */"
        },
        {
          "start_line": 2,
          "end_line": 2,
          "text": "/* Copyright Authors of Cilium */"
        },
        {
          "start_line": 12,
          "end_line": 19,
          "text": "/* Workaround for GH-18311 where veth driver might have recorded\n\t * veth's RX queue mapping instead of leaving it at 0. This can\n\t * cause issues on the phys device where all traffic would only\n\t * hit a single TX queue (given veth device had a single one and\n\t * mapping was left at 1). Reset so that stack picks a fresh queue.\n\t * Kernel fix is at 710ad98c363a (\"veth: Do not record rx queue\n\t * hint in veth_xmit\").\n\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff * ctx __maybe_unused"
      ],
      "output": "staticinlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static inline void reset_queue_mapping (struct  __ctx_buff * ctx __maybe_unused)\n",
        "{\n",
        "\n",
        "#if defined(RESET_QUEUES) && __ctx_is == __ctx_skb\n",
        "    ctx->queue_mapping = 0;\n",
        "\n",
        "#endif\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ctx_redirect_to_proxy_hairpin": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 22,
      "endLine": 63,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/proxy_hairpin.h",
      "funcName": "ctx_redirect_to_proxy_hairpin",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */"
        },
        {
          "start_line": 2,
          "end_line": 2,
          "text": "/* Copyright Authors of Cilium */"
        },
        {
          "start_line": 18,
          "end_line": 21,
          "text": "/**\n * ctx_redirect_to_proxy_hairpin redirects to the proxy by hairpining the\n * packet out the incoming interface\n */"
        },
        {
          "start_line": 36,
          "end_line": 36,
          "text": "/* verifier workaround */"
        },
        {
          "start_line": 57,
          "end_line": 60,
          "text": "/* Note that the actual __ctx_buff preparation for submitting the\n\t * packet to the proxy will occur in a subsequent program via\n\t * ctx_redirect_to_proxy_first().\n\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " __be16 proxy_port",
        " const bool is_ipv6"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int ctx_redirect_to_proxy_hairpin (struct  __ctx_buff *ctx, __be16 proxy_port, const bool is_ipv6)\n",
        "{\n",
        "\n",
        "#if defined(ENABLE_IPV4) || defined(ENABLE_IPV6)\n",
        "    union macaddr host_mac = HOST_IFINDEX_MAC;\n",
        "    union macaddr router_mac = NODE_MAC;\n",
        "\n",
        "#endif\n",
        "    void *data_end = (void *) (long) ctx->data_end;\n",
        "    void *data = (void *) (long) ctx->data;\n",
        "    struct iphdr *ip4;\n",
        "    int ret = 0;\n",
        "    ctx_store_meta (ctx, CB_PROXY_MAGIC, MARK_MAGIC_TO_PROXY | (proxy_port << 16));\n",
        "    bpf_barrier ();\n",
        "    if (!revalidate_data (ctx, &data, &data_end, &ip4))\n",
        "        return DROP_INVALID;\n",
        "    if (is_ipv6) {\n",
        "\n",
        "#ifdef ENABLE_IPV6\n",
        "        ret = ipv6_l3 (ctx, ETH_HLEN, (__u8 *) & router_mac, (__u8 *) & host_mac, METRIC_EGRESS);\n",
        "\n",
        "#endif\n",
        "    }\n",
        "    else {\n",
        "\n",
        "#ifdef ENABLE_IPV4\n",
        "        ret = ipv4_l3 (ctx, ETH_HLEN, (__u8 *) & router_mac, (__u8 *) & host_mac, ip4);\n",
        "\n",
        "#endif\n",
        "    }\n",
        "    if (IS_ERR (ret))\n",
        "        return ret;\n",
        "    cilium_dbg (ctx, DBG_CAPTURE_PROXY_PRE, proxy_port, 0);\n",
        "    return ctx_redirect (ctx, HOST_IFINDEX, 0);\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_store_meta",
        "ipv6_l3",
        "ipv4_l3",
        "bpf_barrier",
        "ctx_redirect",
        "cilium_dbg"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ctx_redirect_to_proxy_hairpin_ipv4": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 66,
      "endLine": 70,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/proxy_hairpin.h",
      "funcName": "ctx_redirect_to_proxy_hairpin_ipv4",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " __be16 proxy_port"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int ctx_redirect_to_proxy_hairpin_ipv4 (struct  __ctx_buff *ctx, __be16 proxy_port)\n",
        "{\n",
        "    return ctx_redirect_to_proxy_hairpin (ctx, proxy_port, false);\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_redirect_to_proxy_hairpin"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ctx_redirect_to_proxy_hairpin_ipv6": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 74,
      "endLine": 78,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/proxy_hairpin.h",
      "funcName": "ctx_redirect_to_proxy_hairpin_ipv6",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " __be16 proxy_port"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int ctx_redirect_to_proxy_hairpin_ipv6 (struct  __ctx_buff *ctx, __be16 proxy_port)\n",
        "{\n",
        "    return ctx_redirect_to_proxy_hairpin (ctx, proxy_port, true);\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_redirect_to_proxy_hairpin"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "edt_set_aggregate": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 17,
      "endLine": 22,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/edt.h",
      "funcName": "edt_set_aggregate",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */"
        },
        {
          "start_line": 2,
          "end_line": 2,
          "text": "/* Copyright Authors of Cilium */"
        },
        {
          "start_line": 13,
          "end_line": 15,
          "text": "/* From XDP layer, we neither go through an egress hook nor qdisc\n * from here, hence nothing to be set.\n */"
        },
        {
          "start_line": 20,
          "end_line": 20,
          "text": "/* 16 bit as current used aggregate, and preserved in host ns. */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " __u32 aggregate"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void edt_set_aggregate (struct  __ctx_buff *ctx, __u32 aggregate)\n",
        "{\n",
        "    ctx->queue_mapping = aggregate;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 79,
      "endLine": 83,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/edt.h",
      "funcName": "edt_set_aggregate",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff * ctx __maybe_unused",
        " __u32 aggregate __maybe_unused"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void edt_set_aggregate (struct  __ctx_buff * ctx __maybe_unused, __u32 aggregate __maybe_unused)\n",
        "{\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "edt_get_aggregate": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 24,
      "endLine": 34,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/edt.h",
      "funcName": "edt_get_aggregate",
      "developer_inline_comments": [
        {
          "start_line": 28,
          "end_line": 30,
          "text": "/* We need to reset queue mapping here such that new mapping will\n\t * be performed based on skb hash. See netdev_pick_tx().\n\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "static__always_inline__u32",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __u32 edt_get_aggregate (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    __u32 aggregate = ctx->queue_mapping;\n",
        "    ctx->queue_mapping = 0;\n",
        "    return aggregate;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "edt_sched_departure": [
    {
      "capabilities": [
        {
          "capability": "read_sys_info",
          "read_sys_info": [
            {
              "Project": "cilium",
              "Return Type": "u64",
              "Description": "Return the time elapsed since system boot , in nanoseconds. ",
              "Return": " Current ktime.",
              "Function Name": "ktime_get_ns",
              "Input Params": [
                "{Type: voi ,Var: void}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "read_sys_info"
              ]
            }
          ]
        },
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        },
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 36,
      "endLine": 77,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/edt.h",
      "funcName": "edt_sched_departure",
      "developer_inline_comments": [
        {
          "start_line": 67,
          "end_line": 71,
          "text": "/* FQ implements a drop horizon, see also 39d010504e6b (\"net_sched:\n\t * sch_fq: add horizon attribute\"). However, we explicitly need the\n\t * drop horizon here to i) avoid having t_last messed up and ii) to\n\t * potentially allow for per aggregate control.\n\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [
        "  THROTTLE_MAP"
      ],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "ktime_get_ns",
        "CTX_ACT_OK",
        "map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "static __always_inline int edt_sched_departure (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    __u64 delay, now, t, t_next;\n",
        "    struct edt_id aggregate;\n",
        "    struct edt_info *info;\n",
        "    __u16 proto;\n",
        "    if (!validate_ethertype (ctx, &proto))\n",
        "        return CTX_ACT_OK;\n",
        "    if (proto != bpf_htons (ETH_P_IP) && proto != bpf_htons (ETH_P_IPV6))\n",
        "        return CTX_ACT_OK;\n",
        "    aggregate.id = edt_get_aggregate (ctx);\n",
        "    if (!aggregate.id)\n",
        "        return CTX_ACT_OK;\n",
        "    info = map_lookup_elem (& THROTTLE_MAP, & aggregate);\n",
        "    if (!info)\n",
        "        return CTX_ACT_OK;\n",
        "    now = ktime_get_ns ();\n",
        "    t = ctx->tstamp;\n",
        "    if (t < now)\n",
        "        t = now;\n",
        "    delay = ((__u64) ctx_wire_len (ctx)) * NSEC_PER_SEC / info->bps;\n",
        "    t_next = READ_ONCE (info->t_last) + delay;\n",
        "    if (t_next <= t) {\n",
        "        WRITE_ONCE (info->t_last, t);\n",
        "        return CTX_ACT_OK;\n",
        "    }\n",
        "    if (t_next - now >= info->t_horizon_drop)\n",
        "        return CTX_ACT_DROP;\n",
        "    WRITE_ONCE (info->t_last, t_next);\n",
        "    ctx->tstamp = t_next;\n",
        "    return CTX_ACT_OK;\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_wire_len",
        "edt_get_aggregate",
        "validate_ethertype"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "policy_sk_egress": [
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        },
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 15,
      "endLine": 79,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/policy.h",
      "funcName": "policy_sk_egress",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */"
        },
        {
          "start_line": 2,
          "end_line": 2,
          "text": "/* Copyright Authors of Cilium */"
        },
        {
          "start_line": 33,
          "end_line": 33,
          "text": "/* Start with L3/L4 lookup. */"
        },
        {
          "start_line": 36,
          "end_line": 36,
          "text": "/* FIXME: Need byte counter */"
        },
        {
          "start_line": 43,
          "end_line": 43,
          "text": "/* L4-only lookup. */"
        },
        {
          "start_line": 47,
          "end_line": 47,
          "text": "/* FIXME: Need byte counter */"
        },
        {
          "start_line": 55,
          "end_line": 55,
          "text": "/* If L4 policy check misses, fall back to L3. */"
        },
        {
          "start_line": 60,
          "end_line": 60,
          "text": "/* FIXME: Need byte counter */"
        },
        {
          "start_line": 67,
          "end_line": 67,
          "text": "/* Final fallback if allow-all policy is in place. */"
        },
        {
          "start_line": 71,
          "end_line": 71,
          "text": "/* FIXME: Need byte counter */"
        }
      ],
      "updateMaps": [],
      "readMaps": [
        " map"
      ],
      "input": [
        "__u32 identity",
        " __u32 ip",
        " __u16 dport"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "CTX_ACT_OK",
        "map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "static __always_inline int policy_sk_egress (__u32 identity, __u32 ip, __u16 dport)\n",
        "{\n",
        "    void *map = lookup_ip4_endpoint_policy_map (ip);\n",
        "    int dir = CT_EGRESS;\n",
        "    __u8 proto = IPPROTO_TCP;\n",
        "    struct policy_entry *policy;\n",
        "    struct policy_key key = {\n",
        "        .sec_label = identity,\n",
        "        .dport = dport,\n",
        "        .protocol = proto,\n",
        "        .egress = !dir,\n",
        "        .pad = 0,}\n",
        "    ;\n",
        "    if (!map)\n",
        "        return CTX_ACT_OK;\n",
        "    policy = map_lookup_elem (map, & key);\n",
        "    if (likely (policy)) {\n",
        "        __sync_fetch_and_add (&policy->packets, 1);\n",
        "        if (unlikely (policy->deny))\n",
        "            return DROP_POLICY_DENY;\n",
        "        return policy->proxy_port;\n",
        "    }\n",
        "    key.sec_label = 0;\n",
        "    policy = map_lookup_elem (map, & key);\n",
        "    if (likely (policy)) {\n",
        "        __sync_fetch_and_add (&policy->packets, 1);\n",
        "        if (unlikely (policy->deny))\n",
        "            return DROP_POLICY_DENY;\n",
        "        return policy->proxy_port;\n",
        "    }\n",
        "    key.sec_label = identity;\n",
        "    key.dport = 0;\n",
        "    key.protocol = 0;\n",
        "    policy = map_lookup_elem (map, & key);\n",
        "    if (likely (policy)) {\n",
        "        __sync_fetch_and_add (&policy->packets, 1);\n",
        "        if (unlikely (policy->deny))\n",
        "            return DROP_POLICY_DENY;\n",
        "        return CTX_ACT_OK;\n",
        "    }\n",
        "    key.sec_label = 0;\n",
        "    policy = map_lookup_elem (map, & key);\n",
        "    if (likely (policy)) {\n",
        "        __sync_fetch_and_add (&policy->packets, 1);\n",
        "        if (unlikely (policy->deny))\n",
        "            return DROP_POLICY_DENY;\n",
        "        return CTX_ACT_OK;\n",
        "    }\n",
        "    return DROP_POLICY;\n",
        "}\n"
      ],
      "called_function_list": [
        "lookup_ip4_endpoint_policy_map"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "account": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 81,
      "endLine": 87,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/policy.h",
      "funcName": "account",
      "developer_inline_comments": [
        {
          "start_line": 84,
          "end_line": 84,
          "text": "/* FIXME: Use per cpu counters */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " struct policy_entry *policy"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void account (struct  __ctx_buff *ctx, struct policy_entry *policy)\n",
        "{\n",
        "    __sync_fetch_and_add (&policy->packets, 1);\n",
        "    __sync_fetch_and_add (&policy->bytes, ctx_full_len (ctx));\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_full_len"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__policy_can_access": [
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        },
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 89,
      "endLine": 222,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/policy.h",
      "funcName": "__policy_can_access",
      "developer_inline_comments": [
        {
          "start_line": 104,
          "end_line": 106,
          "text": "/* When ALLOW_ICMP_FRAG_NEEDED is defined we allow all packets\n\t * of ICMP type 3 code 4 - Fragmentation Needed.\n\t */"
        },
        {
          "start_line": 124,
          "end_line": 124,
          "text": "/* ALLOW_ICMP_FRAG_NEEDED */"
        },
        {
          "start_line": 139,
          "end_line": 142,
          "text": "/* Convert from unsigned char to unsigned short considering byte order(little-endian).\n\t\t * In the little-endian case, for example, 2byte data \"AB\" convert to \"BA\".\n\t\t * Therefore, the \"icmp_type\" should be shifted not just casting.\n\t\t */"
        },
        {
          "start_line": 156,
          "end_line": 159,
          "text": "/* Convert from unsigned char to unsigned short considering byte order(little-endian).\n\t\t * In the little-endian case, for example, 2byte data \"AB\" convert to \"BA\".\n\t\t * Therefore, the \"icmp_type\" should be shifted not just casting.\n\t\t */"
        },
        {
          "start_line": 162,
          "end_line": 162,
          "text": "/* ENABLE_ICMP_RULE */"
        },
        {
          "start_line": 164,
          "end_line": 164,
          "text": "/* L4 lookup can't be done on untracked fragments. */"
        },
        {
          "start_line": 166,
          "end_line": 166,
          "text": "/* Start with L3/L4 lookup. */"
        },
        {
          "start_line": 179,
          "end_line": 179,
          "text": "/* L4-only lookup. */"
        },
        {
          "start_line": 192,
          "end_line": 192,
          "text": "/* If L4 policy check misses, fall back to L3. */"
        },
        {
          "start_line": 204,
          "end_line": 204,
          "text": "/* Final fallback if allow-all policy is in place. */"
        }
      ],
      "updateMaps": [],
      "readMaps": [
        " map"
      ],
      "input": [
        "const void *map",
        " struct  __ctx_buff *ctx",
        " __u32 local_id",
        " __u32 remote_id",
        " __u16 dport",
        " __u8 proto",
        " int dir",
        " bool is_untracked_fragment",
        " __u8 *match_type"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "CTX_ACT_OK",
        "map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "static __always_inline int __policy_can_access (const void *map, struct  __ctx_buff *ctx, __u32 local_id, __u32 remote_id, __u16 dport, __u8 proto, int dir, bool is_untracked_fragment, __u8 *match_type)\n",
        "{\n",
        "    struct policy_entry *policy;\n",
        "    struct policy_key key = {\n",
        "        .sec_label = remote_id,\n",
        "        .dport = dport,\n",
        "        .protocol = proto,\n",
        "        .egress = !dir,\n",
        "        .pad = 0,}\n",
        "    ;\n",
        "\n",
        "#ifdef ALLOW_ICMP_FRAG_NEEDED\n",
        "    if (proto == IPPROTO_ICMP) {\n",
        "        void *data, *data_end;\n",
        "        struct icmphdr icmphdr __align_stack_8;\n",
        "        struct iphdr *ip4;\n",
        "        __u32 off;\n",
        "        if (!revalidate_data (ctx, &data, &data_end, &ip4))\n",
        "            return DROP_INVALID;\n",
        "        off = ((void *) ip4 - data) + ipv4_hdrlen (ip4);\n",
        "        if (ctx_load_bytes (ctx, off, &icmphdr, sizeof (icmphdr)) < 0)\n",
        "            return DROP_INVALID;\n",
        "        if (icmphdr.type == ICMP_DEST_UNREACH && icmphdr.code == ICMP_FRAG_NEEDED)\n",
        "            return CTX_ACT_OK;\n",
        "    }\n",
        "\n",
        "#endif /* ALLOW_ICMP_FRAG_NEEDED */\n",
        "\n",
        "#ifdef ENABLE_ICMP_RULE\n",
        "    if (proto == IPPROTO_ICMP) {\n",
        "        void *data, *data_end;\n",
        "        struct iphdr *ip4;\n",
        "        struct icmphdr icmphdr __align_stack_8;\n",
        "        __u32 off;\n",
        "        if (!revalidate_data (ctx, &data, &data_end, &ip4))\n",
        "            return DROP_INVALID;\n",
        "        off = ((void *) ip4 - data) + ipv4_hdrlen (ip4);\n",
        "        if (ctx_load_bytes (ctx, off, &icmphdr, sizeof (icmphdr)) < 0)\n",
        "            return DROP_INVALID;\n",
        "        key.dport = (__u16) (icmphdr.type << 8);\n",
        "    }\n",
        "    else if (proto == IPPROTO_ICMPV6) {\n",
        "        void *data, *data_end;\n",
        "        struct ipv6hdr *ip6;\n",
        "        __u32 off;\n",
        "        __u8 icmp_type;\n",
        "        if (!revalidate_data (ctx, &data, &data_end, &ip6))\n",
        "            return DROP_INVALID;\n",
        "        off = ((void *) ip6 - data) + ipv6_hdrlen (ctx, &ip6->nexthdr);\n",
        "        if (ctx_load_bytes (ctx, off, &icmp_type, sizeof (icmp_type)) < 0)\n",
        "            return DROP_INVALID;\n",
        "        key.dport = (__u16) (icmp_type << 8);\n",
        "    }\n",
        "\n",
        "#endif /* ENABLE_ICMP_RULE */\n",
        "    if (!is_untracked_fragment) {\n",
        "        policy = map_lookup_elem (map, & key);\n",
        "        if (likely (policy)) {\n",
        "            cilium_dbg3 (ctx, DBG_L4_CREATE, remote_id, local_id, dport << 16 | proto);\n",
        "            account (ctx, policy);\n",
        "            *match_type = POLICY_MATCH_L3_L4;\n",
        "            if (unlikely (policy->deny))\n",
        "                return DROP_POLICY_DENY;\n",
        "            return policy->proxy_port;\n",
        "        }\n",
        "        key.sec_label = 0;\n",
        "        policy = map_lookup_elem (map, & key);\n",
        "        if (likely (policy)) {\n",
        "            account (ctx, policy);\n",
        "            *match_type = POLICY_MATCH_L4_ONLY;\n",
        "            if (unlikely (policy->deny))\n",
        "                return DROP_POLICY_DENY;\n",
        "            return policy->proxy_port;\n",
        "        }\n",
        "        key.sec_label = remote_id;\n",
        "    }\n",
        "    key.dport = 0;\n",
        "    key.protocol = 0;\n",
        "    policy = map_lookup_elem (map, & key);\n",
        "    if (likely (policy)) {\n",
        "        account (ctx, policy);\n",
        "        *match_type = POLICY_MATCH_L3_ONLY;\n",
        "        if (unlikely (policy->deny))\n",
        "            return DROP_POLICY_DENY;\n",
        "        return CTX_ACT_OK;\n",
        "    }\n",
        "    key.sec_label = 0;\n",
        "    policy = map_lookup_elem (map, & key);\n",
        "    if (policy) {\n",
        "        account (ctx, policy);\n",
        "        *match_type = POLICY_MATCH_ALL;\n",
        "        if (unlikely (policy->deny))\n",
        "            return DROP_POLICY_DENY;\n",
        "        return CTX_ACT_OK;\n",
        "    }\n",
        "    if (ctx_load_meta (ctx, CB_POLICY))\n",
        "        return CTX_ACT_OK;\n",
        "    if (is_untracked_fragment)\n",
        "        return DROP_FRAG_NOSUPPORT;\n",
        "    return DROP_POLICY;\n",
        "}\n"
      ],
      "called_function_list": [
        "ipv6_hdrlen",
        "ipv4_hdrlen",
        "cilium_dbg3",
        "ctx_load_meta",
        "account"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "policy_can_access_ingress": [
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 240,
      "endLine": 264,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/policy.h",
      "funcName": "policy_can_access_ingress",
      "developer_inline_comments": [
        {
          "start_line": 224,
          "end_line": 239,
          "text": "/**\n * Determine whether the policy allows this traffic on ingress.\n * @arg ctx\t\tPacket to allow or deny\n * @arg src_id\t\tSource security identity for this packet\n * @arg dst_id\t\tDestination security identity for this packet\n * @arg dport\t\tDestination port of this packet\n * @arg proto\t\tL3 Protocol of this packet\n * @arg is_untracked_fragment\tTrue if packet is a TCP/UDP datagram fragment\n *\t\t\t\tAND IPv4 fragment tracking is disabled\n * @arg match_type\t\tPointer to store layers used for policy match\n *\n * Returns:\n *   - Positive integer indicating the proxy_port to handle this traffic\n *   - CTX_ACT_OK if the policy allows this traffic based only on labels/L3/L4\n *   - Negative error code if the packet should be dropped\n */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " __u32 src_id",
        " __u32 dst_id",
        " __u16 dport",
        " __u8 proto",
        " bool is_untracked_fragment",
        " __u8 *match_type",
        " __u8 *audited"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "CTX_ACT_OK"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "static __always_inline int policy_can_access_ingress (struct  __ctx_buff *ctx, __u32 src_id, __u32 dst_id, __u16 dport, __u8 proto, bool is_untracked_fragment, __u8 *match_type, __u8 *audited)\n",
        "{\n",
        "    int ret;\n",
        "    ret = __policy_can_access (& POLICY_MAP, ctx, dst_id, src_id, dport, proto, CT_INGRESS, is_untracked_fragment, match_type);\n",
        "    if (ret >= CTX_ACT_OK)\n",
        "        return ret;\n",
        "    cilium_dbg (ctx, DBG_POLICY_DENIED, src_id, dst_id);\n",
        "    *audited = 0;\n",
        "\n",
        "#ifdef POLICY_AUDIT_MODE\n",
        "    if (IS_ERR (ret)) {\n",
        "        ret = CTX_ACT_OK;\n",
        "        *audited = 1;\n",
        "    }\n",
        "\n",
        "#endif\n",
        "    return ret;\n",
        "}\n"
      ],
      "called_function_list": [
        "__policy_can_access",
        "cilium_dbg"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "is_encap": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 267,
      "endLine": 270,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/policy.h",
      "funcName": "is_encap",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "__u16 dport",
        " __u8 proto"
      ],
      "output": "static__always_inlinebool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline bool is_encap (__u16 dport, __u8 proto)\n",
        "{\n",
        "    return proto == IPPROTO_UDP && dport == bpf_htons (TUNNEL_PORT);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "policy_can_egress": [
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 273,
      "endLine": 296,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/policy.h",
      "funcName": "policy_can_egress",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " __u32 src_id",
        " __u32 dst_id",
        " __u16 dport",
        " __u8 proto",
        " __u8 *match_type",
        " __u8 *audited"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "CTX_ACT_OK"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "static __always_inline int policy_can_egress (struct  __ctx_buff *ctx, __u32 src_id, __u32 dst_id, __u16 dport, __u8 proto, __u8 *match_type, __u8 *audited)\n",
        "{\n",
        "    int ret;\n",
        "\n",
        "#ifdef ENCAP_IFINDEX\n",
        "    if (src_id != HOST_ID && is_encap (dport, proto))\n",
        "        return DROP_ENCAP_PROHIBITED;\n",
        "\n",
        "#endif\n",
        "    ret = __policy_can_access (& POLICY_MAP, ctx, src_id, dst_id, dport, proto, CT_EGRESS, false, match_type);\n",
        "    if (ret >= 0)\n",
        "        return ret;\n",
        "    cilium_dbg (ctx, DBG_POLICY_DENIED, src_id, dst_id);\n",
        "    *audited = 0;\n",
        "\n",
        "#ifdef POLICY_AUDIT_MODE\n",
        "    if (IS_ERR (ret)) {\n",
        "        ret = CTX_ACT_OK;\n",
        "        *audited = 1;\n",
        "    }\n",
        "\n",
        "#endif\n",
        "    return ret;\n",
        "}\n"
      ],
      "called_function_list": [
        "__policy_can_access",
        "is_encap",
        "cilium_dbg"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "policy_can_egress6": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 298,
      "endLine": 305,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/policy.h",
      "funcName": "policy_can_egress6",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " const struct ipv6_ct_tuple *tuple",
        " __u32 src_id",
        " __u32 dst_id",
        " __u8 *match_type",
        " __u8 *audited"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int policy_can_egress6 (struct  __ctx_buff *ctx, const struct ipv6_ct_tuple *tuple, __u32 src_id, __u32 dst_id, __u8 *match_type, __u8 *audited)\n",
        "{\n",
        "    return policy_can_egress (ctx, src_id, dst_id, tuple->dport, tuple->nexthdr, match_type, audited);\n",
        "}\n"
      ],
      "called_function_list": [
        "policy_can_egress"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "policy_can_egress4": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 307,
      "endLine": 314,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/policy.h",
      "funcName": "policy_can_egress4",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " const struct ipv4_ct_tuple *tuple",
        " __u32 src_id",
        " __u32 dst_id",
        " __u8 *match_type",
        " __u8 *audited"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int policy_can_egress4 (struct  __ctx_buff *ctx, const struct ipv4_ct_tuple *tuple, __u32 src_id, __u32 dst_id, __u8 *match_type, __u8 *audited)\n",
        "{\n",
        "    return policy_can_egress (ctx, src_id, dst_id, tuple->dport, tuple->nexthdr, match_type, audited);\n",
        "}\n"
      ],
      "called_function_list": [
        "policy_can_egress"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "policy_mark_skip": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 323,
      "endLine": 326,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/policy.h",
      "funcName": "policy_mark_skip",
      "developer_inline_comments": [
        {
          "start_line": 316,
          "end_line": 322,
          "text": "/**\n * Mark ctx to skip policy enforcement\n * @arg ctx\tpacket\n *\n * Will cause the packet to ignore the policy enforcement verdict for allow rules and\n * be considered accepted despite of the policy outcome. Has no effect on deny rules.\n */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void policy_mark_skip (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    ctx_store_meta (ctx, CB_POLICY, 1);\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_store_meta"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "policy_clear_mark": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 328,
      "endLine": 331,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/policy.h",
      "funcName": "policy_clear_mark",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void policy_clear_mark (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    ctx_store_meta (ctx, CB_POLICY, 0);\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_store_meta"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "validate_ethertype": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 121,
      "endLine": 142,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/common.h",
      "funcName": "validate_ethertype",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */"
        },
        {
          "start_line": 2,
          "end_line": 2,
          "text": "/* Copyright Authors of Cilium */"
        },
        {
          "start_line": 37,
          "end_line": 39,
          "text": "/* If not available, fall back to generically detected MTU instead of more\n * fine-grained per-device MTU.\n */"
        },
        {
          "start_line": 49,
          "end_line": 49,
          "text": "/* TODO: ipsec v6 tunnel datapath still needs separate fixing */"
        },
        {
          "start_line": 56,
          "end_line": 56,
          "text": "/* XDP to SKB transferred meta data. */"
        },
        {
          "start_line": 57,
          "end_line": 57,
          "text": "/* Skip upper service handling. */"
        },
        {
          "start_line": 59,
          "end_line": 61,
          "text": "/* These are shared with test/bpf/check-complexity.sh, when modifying any of\n * the below, that script should also be updated.\n */"
        },
        {
          "start_line": 129,
          "end_line": 131,
          "text": "/* The packet is received on L2-less device. Determine L3\n\t\t * protocol from skb->protocol.\n\t\t */"
        },
        {
          "start_line": 140,
          "end_line": 140,
          "text": "/* non-Ethernet II unsupported */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " __u16 *proto"
      ],
      "output": "static__always_inlinebool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline bool validate_ethertype (struct  __ctx_buff *ctx, __u16 *proto)\n",
        "{\n",
        "    void *data = ctx_data (ctx);\n",
        "    void *data_end = ctx_data_end (ctx);\n",
        "    struct ethhdr *eth = data;\n",
        "    if (ETH_HLEN == 0) {\n",
        "        *proto = ctx_get_protocol (ctx);\n",
        "        return true;\n",
        "    }\n",
        "    if (data + ETH_HLEN > data_end)\n",
        "        return false;\n",
        "    *proto = eth->h_proto;\n",
        "    if (bpf_ntohs (*proto) < ETH_P_802_3_MIN)\n",
        "        return false;\n",
        "    return true;\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_data",
        "ctx_get_protocol",
        "ctx_data_end"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "____revalidate_data_pull": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 144,
      "endLine": 167,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/common.h",
      "funcName": "____revalidate_data_pull",
      "developer_inline_comments": [
        {
          "start_line": 153,
          "end_line": 153,
          "text": "/* Verifier workaround, do this unconditionally: invalid size of register spill. */"
        },
        {
          "start_line": 161,
          "end_line": 161,
          "text": "/* Verifier workaround: pointer arithmetic on pkt_end prohibited. */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " void **data_",
        " void **data_end_",
        " void **l3",
        " const __u32 l3_len",
        " const bool pull",
        " __u32 eth_hlen"
      ],
      "output": "static__always_inline__maybe_unusedbool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused bool ____revalidate_data_pull (struct  __ctx_buff *ctx, void **data_, void **data_end_, void **l3, const __u32 l3_len, const bool pull, __u32 eth_hlen)\n",
        "{\n",
        "    const __u64 tot_len = eth_hlen + l3_len;\n",
        "    void *data_end;\n",
        "    void *data;\n",
        "    if (pull)\n",
        "        ctx_pull_data (ctx, tot_len);\n",
        "    data_end = ctx_data_end (ctx);\n",
        "    data = ctx_data (ctx);\n",
        "    if (data + tot_len > data_end)\n",
        "        return false;\n",
        "    *data_ = data;\n",
        "    *data_end_ = data_end;\n",
        "    *l3 = data + eth_hlen;\n",
        "    return true;\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_data",
        "ctx_data_end"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__revalidate_data_pull": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 169,
      "endLine": 175,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/common.h",
      "funcName": "__revalidate_data_pull",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " void **data",
        " void **data_end",
        " void **l3",
        " const __u32 l3_len",
        " const bool pull"
      ],
      "output": "static__always_inline__maybe_unusedbool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused bool __revalidate_data_pull (struct  __ctx_buff *ctx, void **data, void **data_end, void **l3, const __u32 l3_len, const bool pull)\n",
        "{\n",
        "    return ____revalidate_data_pull (ctx, data, data_end, l3, l3_len, pull, ETH_HLEN);\n",
        "}\n"
      ],
      "called_function_list": [
        "____revalidate_data_pull"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "or_encrypt_key": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 605,
      "endLine": 608,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/common.h",
      "funcName": "or_encrypt_key",
      "developer_inline_comments": [
        {
          "start_line": 177,
          "end_line": 183,
          "text": "/* revalidate_data_pull() initializes the provided pointers from the ctx and\n * ensures that the data is pulled in for access. Should be used the first\n * time that the ctx data is accessed, subsequent calls can be made to\n * revalidate_data() which is cheaper.\n * Returns true if 'ctx' is long enough for an IP header of the provided type,\n * false otherwise.\n */"
        },
        {
          "start_line": 187,
          "end_line": 189,
          "text": "/* revalidate_data_maybe_pull() does the same as revalidate_data_pull()\n * except that the skb data pull is controlled by the \"pull\" argument.\n */"
        },
        {
          "start_line": 194,
          "end_line": 197,
          "text": "/* revalidate_data() initializes the provided pointers from the ctx.\n * Returns true if 'ctx' is long enough for an IP header of the provided type,\n * false otherwise.\n */"
        },
        {
          "start_line": 201,
          "end_line": 201,
          "text": "/* Macros for working with L3 cilium defined IPV6 addresses */"
        },
        {
          "start_line": 215,
          "end_line": 219,
          "text": "/* Structure representing an IPv4 or IPv6 address, being used for:\n *  - key as endpoints map\n *  - key for tunnel endpoint map\n *  - value for tunnel endpoint map\n */"
        },
        {
          "start_line": 235,
          "end_line": 235,
          "text": "/* Special endpoint representing local host */"
        },
        {
          "start_line": 237,
          "end_line": 237,
          "text": "/* Value of endpoint map */"
        },
        {
          "start_line": 240,
          "end_line": 240,
          "text": "/* used to be sec_label, no longer used */"
        },
        {
          "start_line": 285,
          "end_line": 285,
          "text": "/* 0: forwarded, >0 dropped */"
        },
        {
          "start_line": 286,
          "end_line": 286,
          "text": "/* 1: ingress 2: egress */"
        },
        {
          "start_line": 288,
          "end_line": 288,
          "text": "/* reserved for future extension */"
        },
        {
          "start_line": 387,
          "end_line": 387,
          "text": "/* Length of original packet */"
        },
        {
          "start_line": 388,
          "end_line": 388,
          "text": "/* Length of captured bytes */"
        },
        {
          "start_line": 389,
          "end_line": 389,
          "text": "/* Capture header version */"
        },
        {
          "start_line": 402,
          "end_line": 402,
          "text": "/* Capture notifications version. Must be incremented when format changes. */"
        },
        {
          "start_line": 415,
          "end_line": 417,
          "text": "/* Cilium IPSec code to indicate packet needs to be handled\n * by IPSec stack. Maps to CTX_ACT_OK.\n */"
        },
        {
          "start_line": 420,
          "end_line": 420,
          "text": "/* Return value to indicate that proxy redirection is required */"
        },
        {
          "start_line": 423,
          "end_line": 429,
          "text": "/* Cilium error codes, must NOT overlap with TC return codes.\n * These also serve as drop reasons for metrics,\n * where reason > 0 corresponds to -(DROP_*)\n *\n * These are shared with pkg/monitor/api/drop.go and api/v1/flow/flow.proto.\n * When modifying any of the below, those files should also be updated.\n */"
        },
        {
          "start_line": 430,
          "end_line": 430,
          "text": "/* unused */"
        },
        {
          "start_line": 431,
          "end_line": 431,
          "text": "/* unused */"
        },
        {
          "start_line": 438,
          "end_line": 438,
          "text": "/* unused */"
        },
        {
          "start_line": 448,
          "end_line": 448,
          "text": "/* unused */"
        },
        {
          "start_line": 449,
          "end_line": 449,
          "text": "/* unused */"
        },
        {
          "start_line": 452,
          "end_line": 452,
          "text": "/* unused */"
        },
        {
          "start_line": 459,
          "end_line": 459,
          "text": "/* unused */"
        },
        {
          "start_line": 473,
          "end_line": 473,
          "text": "/* Mapped as drop code, though drop not necessary. */"
        },
        {
          "start_line": 491,
          "end_line": 497,
          "text": "/* Cilium metrics reasons for forwarding packets and other stats.\n * If reason is larger than below then this is a drop reason and\n * value corresponds to -(DROP_*), see above.\n *\n * These are shared with pkg/monitor/api/drop.go.\n * When modifying any of the below, those files should also be updated.\n */"
        },
        {
          "start_line": 509,
          "end_line": 509,
          "text": "/* Lookup scope for externalTrafficPolicy=Local */"
        },
        {
          "start_line": 513,
          "end_line": 513,
          "text": "/* Cilium metrics direction for dropping/forwarding packet */"
        },
        {
          "start_line": 520,
          "end_line": 537,
          "text": "/* Magic ctx->mark identifies packets origination and encryption status.\n *\n * The upper 16 bits plus lower 8 bits (e.g. mask 0XFFFF00FF) contain the\n * packets security identity. The lower/upper halves are swapped to recover\n * the identity.\n *\n * In case of MARK_MAGIC_PROXY_EGRESS_EPID the upper 16 bits carry the Endpoint\n * ID instead of the security identity and the lower 8 bits will be zeroes.\n *\n * The 4 bits at 0X0F00 provide\n *  - the magic marker values which indicate whether the packet is coming from\n *    an ingress or egress proxy, a local process and its current encryption\n *    status.\n *\n * The 4 bits at 0xF000 provide\n *  - the key index to use for encryption when multiple keys are in-flight.\n *    In the IPsec case this becomes the SPI on the wire.\n */"
        },
        {
          "start_line": 539,
          "end_line": 539,
          "text": "/* mark carries source endpoint ID */"
        },
        {
          "start_line": 545,
          "end_line": 545,
          "text": "/* mark carries identity */"
        },
        {
          "start_line": 551,
          "end_line": 553,
          "text": "/* IPSec cannot be configured with NodePort BPF today, hence non-conflicting\n * overlap with MARK_MAGIC_KEY_ID.\n */"
        },
        {
          "start_line": 556,
          "end_line": 559,
          "text": "/* MARK_MAGIC_HEALTH_IPIP_DONE can overlap with MARK_MAGIC_SNAT_DONE with both\n * being mutual exclusive given former is only under DSR. Used to push health\n * probe packets to ipip tunnel device & to avoid looping back.\n */"
        },
        {
          "start_line": 562,
          "end_line": 564,
          "text": "/* MARK_MAGIC_HEALTH can overlap with MARK_MAGIC_DECRYPT with both being\n * mutual exclusive. Note, MARK_MAGIC_HEALTH is user-facing UAPI for LB!\n */"
        },
        {
          "start_line": 567,
          "end_line": 576,
          "text": "/* IPv4 option used to carry service addr and port for DSR. Lower 16bits set to\n * zero so that they can be OR'd with service port.\n *\n * Copy = 1 (option is copied to each fragment)\n * Class = 0 (control option)\n * Number = 26 (not used according to [1])\n * Len = 8 (option type (1) + option len (1) + addr (4) + port (2))\n *\n * [1]: https://www.iana.org/assignments/ip-parameters/ip-parameters.xhtml\n */"
        },
        {
          "start_line": 581,
          "end_line": 589,
          "text": "/* IPv6 option type of Destination Option used to carry service IPv6 addr and\n * port for DSR.\n *\n * 0b00\t\t- \"skip over this option and continue processing the header\"\n *     0\t- \"Option Data does not change en-route\"\n *      11011   - Unassigned [1]\n *\n * [1]:  https://www.iana.org/assignments/ipv6-parameters/ipv6-parameters.xhtml#ipv6-parameters-2\n */"
        },
        {
          "start_line": 594,
          "end_line": 594,
          "text": "/* We cap key index at 4 bits because mark value is used to map ctx to key */"
        },
        {
          "start_line": 597,
          "end_line": 597,
          "text": "/* encrypt_config is the current encryption context on the node */"
        },
        {
          "start_line": 602,
          "end_line": 604,
          "text": "/**\n * or_encrypt_key - mask and shift key into encryption format\n */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "__u8 key"
      ],
      "output": "static__always_inline__u32",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __u32 or_encrypt_key (__u8 key)\n",
        "{\n",
        "    return (((__u32) key & 0x0F) << 12) | MARK_MAGIC_ENCRYPT;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ct_state_is_from_l7lb": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 958,
      "endLine": 965,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/common.h",
      "funcName": "ct_state_is_from_l7lb",
      "developer_inline_comments": [
        {
          "start_line": 610,
          "end_line": 615,
          "text": "/*\n * ctx->tc_index uses\n *\n * cilium_host @egress\n *   bpf_host -> bpf_lxc\n */"
        },
        {
          "start_line": 622,
          "end_line": 629,
          "text": "/*\n * For use in ctx_{load,store}_meta(), which operates on sk_buff->cb.\n * The verifier only exposes the first 5 slots in cb[], so this enum\n * only contains 5 entries. Aliases are added to the slots to re-use\n * them under different names in different parts of the datapath.\n * Take care to not clobber slots used by other functions in the same\n * code path.\n */"
        },
        {
          "start_line": 630,
          "end_line": 630,
          "text": "/* ctx_{load,store}_meta() usage: */"
        },
        {
          "start_line": 633,
          "end_line": 633,
          "text": "/* Alias, non-overlapping */"
        },
        {
          "start_line": 634,
          "end_line": 634,
          "text": "/* Alias, non-overlapping */"
        },
        {
          "start_line": 635,
          "end_line": 635,
          "text": "/* Alias, non-overlapping */"
        },
        {
          "start_line": 636,
          "end_line": 636,
          "text": "/* Alias, non-overlapping */"
        },
        {
          "start_line": 637,
          "end_line": 637,
          "text": "/* Alias, non-overlapping */"
        },
        {
          "start_line": 638,
          "end_line": 638,
          "text": "/* Alias, non-overlapping */"
        },
        {
          "start_line": 639,
          "end_line": 639,
          "text": "/* Alias, non-overlapping */"
        },
        {
          "start_line": 641,
          "end_line": 641,
          "text": "/* Alias, non-overlapping */"
        },
        {
          "start_line": 642,
          "end_line": 642,
          "text": "/* Alias, non-overlapping */"
        },
        {
          "start_line": 643,
          "end_line": 643,
          "text": "/* Alias, non-overlapping */"
        },
        {
          "start_line": 644,
          "end_line": 644,
          "text": "/* Alias, non-overlapping */"
        },
        {
          "start_line": 645,
          "end_line": 645,
          "text": "/* Alias, non-overlapping */"
        },
        {
          "start_line": 647,
          "end_line": 647,
          "text": "/* Alias, non-overlapping */"
        },
        {
          "start_line": 648,
          "end_line": 648,
          "text": "/* Alias, non-overlapping */"
        },
        {
          "start_line": 649,
          "end_line": 649,
          "text": "/* Alias, non-overlapping */"
        },
        {
          "start_line": 651,
          "end_line": 651,
          "text": "/* Alias, non-overlapping */"
        },
        {
          "start_line": 652,
          "end_line": 652,
          "text": "/* Alias, non-overlapping */"
        },
        {
          "start_line": 653,
          "end_line": 653,
          "text": "/* Alias, non-overlapping */"
        },
        {
          "start_line": 655,
          "end_line": 655,
          "text": "/* Alias, non-overlapping */"
        },
        {
          "start_line": 656,
          "end_line": 658,
          "text": "/* Alias, non-overlapping,\n\t\t\t\t\t\t * Not used by xfrm.\n\t\t\t\t\t\t */"
        },
        {
          "start_line": 659,
          "end_line": 659,
          "text": "/* Alias, non-overlapping */"
        },
        {
          "start_line": 660,
          "end_line": 660,
          "text": "/* Alias, non-overlapping */"
        },
        {
          "start_line": 663,
          "end_line": 666,
          "text": "/* Magic values for CB_FROM_HOST.\n * CB_FROM_HOST overlaps with CB_NAT46_STATE, so this value must be distinct\n * from any in enum NAT46 below!\n */"
        },
        {
          "start_line": 669,
          "end_line": 669,
          "text": "/* Outgoing flow */"
        },
        {
          "start_line": 670,
          "end_line": 670,
          "text": "/* Incoming flow */"
        },
        {
          "start_line": 671,
          "end_line": 671,
          "text": "/* Flow represents related packets */"
        },
        {
          "start_line": 672,
          "end_line": 672,
          "text": "/* Flow represents packets to service */"
        },
        {
          "start_line": 694,
          "end_line": 694,
          "text": "/* Service flags (lb{4,6}_service->flags) */"
        },
        {
          "start_line": 696,
          "end_line": 696,
          "text": "/* External IPs */"
        },
        {
          "start_line": 697,
          "end_line": 697,
          "text": "/* NodePort service */"
        },
        {
          "start_line": 698,
          "end_line": 698,
          "text": "/* externalTrafficPolicy=Local */"
        },
        {
          "start_line": 699,
          "end_line": 699,
          "text": "/* hostPort forwarding */"
        },
        {
          "start_line": 700,
          "end_line": 700,
          "text": "/* sessionAffinity=clientIP */"
        },
        {
          "start_line": 701,
          "end_line": 701,
          "text": "/* LoadBalancer service */"
        },
        {
          "start_line": 702,
          "end_line": 702,
          "text": "/* Not a surrogate/ClusterIP entry */"
        },
        {
          "start_line": 703,
          "end_line": 703,
          "text": "/* Check LoadBalancer source range */"
        },
        {
          "start_line": 706,
          "end_line": 706,
          "text": "/* Service flags (lb{4,6}_service->flags2) */"
        },
        {
          "start_line": 708,
          "end_line": 708,
          "text": "/* local redirect */"
        },
        {
          "start_line": 709,
          "end_line": 709,
          "text": "/* NAT-46/64 entry */"
        },
        {
          "start_line": 710,
          "end_line": 710,
          "text": "/* tproxy redirect to local l7 loadbalancer */"
        },
        {
          "start_line": 713,
          "end_line": 713,
          "text": "/* Backend flags (lb{4,6}_backends->flags) */"
        },
        {
          "start_line": 722,
          "end_line": 724,
          "text": "/* Address fields are reversed, i.e.,\n\t * these field names are correct for reply direction traffic.\n\t */"
        },
        {
          "start_line": 727,
          "end_line": 729,
          "text": "/* The order of dport+sport must not be changed!\n\t * These field names are correct for original direction traffic.\n\t */"
        },
        {
          "start_line": 737,
          "end_line": 739,
          "text": "/* Address fields are reversed, i.e.,\n\t * these field names are correct for reply direction traffic.\n\t */"
        },
        {
          "start_line": 742,
          "end_line": 744,
          "text": "/* The order of dport+sport must not be changed!\n\t * These field names are correct for original direction traffic.\n\t */"
        },
        {
          "start_line": 753,
          "end_line": 756,
          "text": "/* Previously, the rx_bytes field was not used for entries with\n\t * the dir=CT_SERVICE (see GH#7060). Therefore, we can safely abuse\n\t * this field to save the backend_id.\n\t */"
        },
        {
          "start_line": 770,
          "end_line": 770,
          "text": "/* Connection is redirected to a proxy */"
        },
        {
          "start_line": 772,
          "end_line": 772,
          "text": "/* Connection is originated from an L7 LB proxy */"
        },
        {
          "start_line": 775,
          "end_line": 777,
          "text": "/* In the kernel ifindex is u32, so we need to check in cilium-agent\n\t * that ifindex of a NodePort device is <= MAX(u16).\n\t */"
        },
        {
          "start_line": 780,
          "end_line": 782,
          "text": "/* *x_flags_seen represents the OR of all TCP flags seen for the\n\t * transmit/receive direction of this entry.\n\t */"
        },
        {
          "start_line": 786,
          "end_line": 786,
          "text": "/* Used from userspace proxies, do not change offset! */"
        },
        {
          "start_line": 788,
          "end_line": 790,
          "text": "/* last_*x_report is a timestamp of the last time a monitor\n\t * notification was sent for the transmit/receive direction.\n\t */"
        },
        {
          "start_line": 796,
          "end_line": 796,
          "text": "/* Service virtual IPv6 address */"
        },
        {
          "start_line": 797,
          "end_line": 797,
          "text": "/* L4 port filter, if unset, all ports apply */"
        },
        {
          "start_line": 798,
          "end_line": 798,
          "text": "/* Backend iterator, 0 indicates the svc frontend */"
        },
        {
          "start_line": 799,
          "end_line": 799,
          "text": "/* L4 protocol, currently not used (set to 0) */"
        },
        {
          "start_line": 800,
          "end_line": 800,
          "text": "/* LB_LOOKUP_SCOPE_* for externalTrafficPolicy=Local */"
        },
        {
          "start_line": 804,
          "end_line": 804,
          "text": "/* See lb4_service comments */"
        },
        {
          "start_line": 807,
          "end_line": 807,
          "text": "/* Backend ID in lb6_backends */"
        },
        {
          "start_line": 808,
          "end_line": 808,
          "text": "/* In seconds, only for svc frontend */"
        },
        {
          "start_line": 809,
          "end_line": 809,
          "text": "/* In host byte order, only when flags2 && SVC_FLAG_L7LOADBALANCER */"
        },
        {
          "start_line": 818,
          "end_line": 818,
          "text": "/* See lb4_backend comments */"
        },
        {
          "start_line": 849,
          "end_line": 849,
          "text": "/* Service virtual IPv4 address */"
        },
        {
          "start_line": 850,
          "end_line": 850,
          "text": "/* L4 port filter, if unset, all ports apply */"
        },
        {
          "start_line": 851,
          "end_line": 851,
          "text": "/* Backend iterator, 0 indicates the svc frontend */"
        },
        {
          "start_line": 852,
          "end_line": 852,
          "text": "/* L4 protocol, currently not used (set to 0) */"
        },
        {
          "start_line": 853,
          "end_line": 853,
          "text": "/* LB_LOOKUP_SCOPE_* for externalTrafficPolicy=Local */"
        },
        {
          "start_line": 859,
          "end_line": 859,
          "text": "/* Backend ID in lb4_backends */"
        },
        {
          "start_line": 860,
          "end_line": 860,
          "text": "/* In seconds, only for svc frontend */"
        },
        {
          "start_line": 861,
          "end_line": 861,
          "text": "/* In host byte order, only when flags2 && SVC_FLAG_L7LOADBALANCER */"
        },
        {
          "start_line": 863,
          "end_line": 865,
          "text": "/* For the service frontend, count denotes number of service backend\n\t * slots (otherwise zero).\n\t */"
        },
        {
          "start_line": 867,
          "end_line": 867,
          "text": "/* Reverse NAT ID in lb4_reverse_nat */"
        },
        {
          "start_line": 874,
          "end_line": 874,
          "text": "/* Service endpoint IPv4 address */"
        },
        {
          "start_line": 875,
          "end_line": 875,
          "text": "/* L4 port filter */"
        },
        {
          "start_line": 876,
          "end_line": 876,
          "text": "/* L4 protocol, currently not used (set to 0) */"
        },
        {
          "start_line": 948,
          "end_line": 948,
          "text": "/* Connection is redirected to a proxy */"
        },
        {
          "start_line": 949,
          "end_line": 949,
          "text": "/* Connection is originated from an L7 LB proxy */"
        },
        {
          "start_line": 955,
          "end_line": 955,
          "text": "/* Backend ID in lb4_backends */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct ct_state * ct_state __maybe_unused"
      ],
      "output": "static__always_inlinebool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline bool ct_state_is_from_l7lb (const struct ct_state * ct_state __maybe_unused)\n",
        "{\n",
        "\n",
        "#ifdef ENABLE_L7_LB\n",
        "    return ct_state->from_l7lb;\n",
        "\n",
        "#else\n",
        "    return false;\n",
        "\n",
        "#endif\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "redirect_ep": [
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 984,
      "endLine": 1012,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/common.h",
      "funcName": "redirect_ep",
      "developer_inline_comments": [
        {
          "start_line": 988,
          "end_line": 996,
          "text": "/* If our datapath has proper redirect support, we make use\n\t * of it here, otherwise we terminate tc processing by letting\n\t * stack handle forwarding e.g. in ipvlan case.\n\t *\n\t * Going via CPU backlog queue (aka needs_backlog) is required\n\t * whenever we cannot do a fast ingress -> ingress switch but\n\t * instead need an ingress -> egress netns traversal or vice\n\t * versa.\n\t */"
        },
        {
          "start_line": 1002,
          "end_line": 1004,
          "text": "/* When coming from overlay, we need to set packet type\n\t\t * to HOST as otherwise we might get dropped in IP layer.\n\t\t */"
        },
        {
          "start_line": 1006,
          "end_line": 1006,
          "text": "/* ENCAP_IFINDEX */"
        },
        {
          "start_line": 1011,
          "end_line": 1011,
          "text": "/* ENABLE_HOST_REDIRECT */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff * ctx __maybe_unused",
        " int ifindex __maybe_unused",
        " bool needs_backlog __maybe_unused"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "redirect",
        "CTX_ACT_OK"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "static __always_inline int redirect_ep (struct  __ctx_buff * ctx __maybe_unused, int ifindex __maybe_unused, bool needs_backlog __maybe_unused)\n",
        "{\n",
        "\n",
        "#ifdef ENABLE_HOST_REDIRECT\n",
        "    if (needs_backlog || !is_defined (ENABLE_HOST_ROUTING)) {\n",
        "        return ctx_redirect (ctx, ifindex, 0);\n",
        "    }\n",
        "    else {\n",
        "\n",
        "# ifdef ENCAP_IFINDEX\n",
        "        ctx_change_type (ctx, PACKET_HOST);\n",
        "\n",
        "# endif /* ENCAP_IFINDEX */\n",
        "        return ctx_redirect_peer (ctx, ifindex, 0);\n",
        "    }\n",
        "\n",
        "#else\n",
        "    return CTX_ACT_OK;\n",
        "\n",
        "#endif /* ENABLE_HOST_REDIRECT */\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_redirect",
        "ctx_redirect_peer"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__send_drop_notify": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 52,
      "endLine": 80,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/drop.h",
      "funcName": "__send_drop_notify",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */"
        },
        {
          "start_line": 2,
          "end_line": 2,
          "text": "/* Copyright Authors of Cilium */"
        },
        {
          "start_line": 4,
          "end_line": 12,
          "text": "/*\n * Drop & error notification via perf event ring buffer\n *\n * API:\n * int send_drop_notify(ctx, src, dst, dst_id, reason, exitcode, enum metric_dir direction)\n * int send_drop_notify_error(ctx, error, exitcode, enum metric_dir direction)\n *\n * If DROP_NOTIFY is not defined, the API will be compiled in as a NOP.\n */"
        },
        {
          "start_line": 34,
          "end_line": 49,
          "text": "/*\n * We pass information in the meta area as follows:\n *\n *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *     |                         Source Label                          |\n *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *     |                       Destination Label                       |\n *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *     |  Error Code  | Extended Error|            Unused              |\n *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *     |             Designated Destination Endpoint ID                |\n *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *     |   Exit Code  |  Source File  |         Source Line            |\n *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *\n */"
        },
        {
          "start_line": 54,
          "end_line": 54,
          "text": "/* Mask needed to calm verifier. */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "int",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "int __send_drop_notify (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    __u32 error = ctx_load_meta (ctx, 2) & 0xFFFFFFFF;\n",
        "    __u64 ctx_len = ctx_full_len (ctx);\n",
        "    __u64 cap_len = min_t (__u64, TRACE_PAYLOAD_LEN, ctx_len);\n",
        "    __u32 meta4 = ctx_load_meta (ctx, 4);\n",
        "    __u16 line = (__u16) (meta4 >> 16);\n",
        "    __u8 file = (__u8) (meta4 >> 8);\n",
        "    __u8 exitcode = (__u8) meta4;\n",
        "    struct drop_notify msg;\n",
        "    msg = (typeof (msg)) {__notify_common_hdr (CILIUM_NOTIFY_DROP, (__u8) error), __notify_pktcap_hdr (ctx_len, (__u16) cap_len),\n",
        "        .src_label = ctx_load_meta (ctx, 0),\n",
        "        .dst_label = ctx_load_meta (ctx, 1),\n",
        "        .dst_id = ctx_load_meta (ctx, 3),\n",
        "        .line = line,\n",
        "        .file = file,\n",
        "        .ext_error = (__s8) (__u8) (error >> 8),};\n",
        "    ctx_event_output (ctx, &EVENTS_MAP, (cap_len << 32) | BPF_F_CURRENT_CPU, &msg, sizeof (msg));\n",
        "    return exitcode;\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_full_len",
        "ctx_load_meta"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "_send_drop_notify": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 95,
      "endLine": 116,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/drop.h",
      "funcName": "_send_drop_notify",
      "developer_inline_comments": [
        {
          "start_line": 82,
          "end_line": 94,
          "text": "/**\n * send_drop_notify\n * @ctx:\tsocket buffer\n * @src:\tsource identity\n * @dst:\tdestination identity\n * @dst_id:\tdesignated destination endpoint ID\n * @reason:\tReason for drop\n * @exitcode:\terror code to return to the kernel\n *\n * Generate a notification to indicate a packet was dropped.\n *\n * NOTE: This is terminal function and will cause the BPF program to exit\n */"
        },
        {
          "start_line": 100,
          "end_line": 100,
          "text": "/* These fields should be constants and fit (together) in 32 bits */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "__u8 file",
        " __u16 line",
        " struct  __ctx_buff *ctx",
        " __u32 src",
        " __u32 dst",
        " __u32 dst_id",
        " __u32 reason",
        " __u32 exitcode",
        " enum metric_dir direction"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int _send_drop_notify (__u8 file, __u16 line, struct  __ctx_buff *ctx, __u32 src, __u32 dst, __u32 dst_id, __u32 reason, __u32 exitcode, enum metric_dir direction)\n",
        "{\n",
        "    if (!__builtin_constant_p (exitcode) || exitcode > 0xff || !__builtin_constant_p (file) || file > 0xff || !__builtin_constant_p (line) || line > 0xffff)\n",
        "        __throw_build_bug ();\n",
        "    ctx_store_meta (ctx, 0, src);\n",
        "    ctx_store_meta (ctx, 1, dst);\n",
        "    ctx_store_meta (ctx, 2, reason);\n",
        "    ctx_store_meta (ctx, 3, dst_id);\n",
        "    ctx_store_meta (ctx, 4, exitcode | file << 8 | line << 16);\n",
        "    update_metrics (ctx_full_len (ctx), direction, (__u8) reason);\n",
        "    ep_tail_call (ctx, CILIUM_CALL_DROP_NOTIFY);\n",
        "    return exitcode;\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_store_meta",
        "ep_tail_call",
        "ctx_full_len",
        "update_metrics"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 118,
      "endLine": 126,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/drop.h",
      "funcName": "_send_drop_notify",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "__u8 file __maybe_unused",
        " __u16 line __maybe_unused",
        " struct  __ctx_buff *ctx",
        " __u32 src __maybe_unused",
        " __u32 dst __maybe_unused",
        " __u32 dst_id __maybe_unused",
        " __u32 reason",
        " __u32 exitcode",
        " enum metric_dir direction"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int _send_drop_notify (__u8 file __maybe_unused, __u16 line __maybe_unused, struct  __ctx_buff *ctx, __u32 src __maybe_unused, __u32 dst __maybe_unused, __u32 dst_id __maybe_unused, __u32 reason, __u32 exitcode, enum metric_dir direction)\n",
        "{\n",
        "    update_metrics (ctx_full_len (ctx), direction, (__u8) reason);\n",
        "    return exitcode;\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_store_meta",
        "ep_tail_call",
        "ctx_full_len",
        "update_metrics"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "cilium_dbg": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 183,
      "endLine": 194,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/dbg.h",
      "funcName": "cilium_dbg",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */"
        },
        {
          "start_line": 2,
          "end_line": 2,
          "text": "/* Copyright Authors of Cilium */"
        },
        {
          "start_line": 7,
          "end_line": 7,
          "text": "/* Trace types */"
        },
        {
          "start_line": 10,
          "end_line": 10,
          "text": "/* Generic, no message, useful to dump random integers */"
        },
        {
          "start_line": 15,
          "end_line": 15,
          "text": "/* unused */"
        },
        {
          "start_line": 16,
          "end_line": 16,
          "text": "/* unused */"
        },
        {
          "start_line": 18,
          "end_line": 18,
          "text": "/* unused */"
        },
        {
          "start_line": 19,
          "end_line": 19,
          "text": "/* unused */"
        },
        {
          "start_line": 55,
          "end_line": 55,
          "text": "/* arg1: security-context, arg2: unused */"
        },
        {
          "start_line": 56,
          "end_line": 56,
          "text": "/* arg1 encap lookup key, arg2: identity */"
        },
        {
          "start_line": 57,
          "end_line": 60,
          "text": "/* arg1: saddr\n\t\t\t\t * arg2: daddr\n\t\t\t\t * arg3: (sport << 16) | dport\n\t\t\t\t */"
        },
        {
          "start_line": 61,
          "end_line": 64,
          "text": "/* arg1: (nexthdr << 8) | flags\n\t\t\t\t * arg2: direction\n\t\t\t\t * arg3: unused\n\t\t\t\t */"
        },
        {
          "start_line": 65,
          "end_line": 68,
          "text": "/* arg1: (unused << 16) | rev_nat_index\n\t\t\t\t * arg2: src sec-id\n\t\t\t\t * arg3: lb address\n\t\t\t\t */"
        },
        {
          "start_line": 69,
          "end_line": 72,
          "text": "/* arg1: saddr (last 4 bytes)\n\t\t\t\t * arg2: daddr (last 4 bytes)\n\t\t\t\t * arg3: (sport << 16) | dport\n\t\t\t\t */"
        },
        {
          "start_line": 73,
          "end_line": 76,
          "text": "/* arg1: (nexthdr << 8) | flags\n\t\t\t\t * arg2: direction\n\t\t\t\t * arg3: unused\n\t\t\t\t */"
        },
        {
          "start_line": 77,
          "end_line": 80,
          "text": "/* arg1: (unused << 16) | rev_nat_index\n\t\t\t\t * arg2: src sec-id\n\t\t\t\t * arg3: unused\n\t\t\t\t */"
        },
        {
          "start_line": 81,
          "end_line": 83,
          "text": "/* arg1: ctx->tc_index\n\t\t\t\t  * arg2: unused\n\t\t\t\t  */"
        },
        {
          "start_line": 84,
          "end_line": 87,
          "text": "/* arg1: src sec-id\n\t\t\t\t * arg2: dst sec-id\n\t\t\t\t * arg3: (dport << 16) | protocol\n\t\t\t\t */"
        },
        {
          "start_line": 88,
          "end_line": 91,
          "text": "/* arg1: daddr\n\t\t\t\t * arg2: unused\n\t\t\t\t * arg3: unused\n\t\t\t\t */"
        },
        {
          "start_line": 92,
          "end_line": 95,
          "text": "/* arg1: daddr (last 4 bytes)\n\t\t\t\t * arg2: unused\n\t\t\t\t * arg3: unused\n\t\t\t\t */"
        },
        {
          "start_line": 96,
          "end_line": 99,
          "text": "/* arg1: daddr\n\t\t\t\t * arg2: identity\n\t\t\t\t * arg3: unused\n\t\t\t\t */"
        },
        {
          "start_line": 100,
          "end_line": 103,
          "text": "/* arg1: daddr (last 4 bytes)\n\t\t\t\t * arg2: identity\n\t\t\t\t * arg3: unused\n\t\t\t\t */"
        },
        {
          "start_line": 104,
          "end_line": 107,
          "text": "/* arg1: svc rev_nat_id\n\t\t\t\t * arg2: stale CT rev_nat_id\n\t\t\t\t * arg3: unused\n\t\t\t\t */"
        },
        {
          "start_line": 108,
          "end_line": 110,
          "text": "/* arg1: ctx->mark\n\t\t\t\t * arg2: unused\n\t\t\t\t */"
        },
        {
          "start_line": 111,
          "end_line": 114,
          "text": "/* arg1: saddr\n\t\t\t\t * arg2: daddr\n\t\t\t\t * arg3: (sport << 16) | dport\n\t\t\t\t */"
        },
        {
          "start_line": 115,
          "end_line": 118,
          "text": "/* arg1: saddr (last 4 bytes)\n\t\t\t\t * arg2: daddr (last 4 bytes)\n\t\t\t\t * arg3: (sport << 16) | dport\n\t\t\t\t */"
        },
        {
          "start_line": 119,
          "end_line": 121,
          "text": "/* arg1: result\n\t\t\t\t * arg2: unuseds\n\t\t\t\t */"
        },
        {
          "start_line": 122,
          "end_line": 125,
          "text": "/* arg1: saddr (last 4 bytes for IPv6)\n\t\t\t\t * arg2: daddr (last 4 bytes for IPv6)\n\t\t\t\t * arg3: proxy port (in host byte order)\n\t\t\t\t */"
        },
        {
          "start_line": 128,
          "end_line": 128,
          "text": "/* Capture types */"
        },
        {
          "start_line": 156,
          "end_line": 168,
          "text": "/* This takes both literals and modifiers, e.g.,\n * printk(\"hello\\n\");\n * printk(\"%d\\n\", ret);\n *\n * Three caveats when using this:\n * - message needs to end with newline\n *\n * - only a subset of specifier are supported:\n *   https://elixir.bootlin.com/linux/v5.7.7/source/kernel/trace/bpf_trace.c#L325\n *\n * - cannot use more than 3 format specifiers in the format string\n *   because BPF helpers take a maximum of 5 arguments\n */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " __u8 type",
        " __u32 arg1",
        " __u32 arg2"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void cilium_dbg (struct  __ctx_buff *ctx, __u8 type, __u32 arg1, __u32 arg2)\n",
        "{\n",
        "    struct debug_msg msg = {__notify_common_hdr (CILIUM_NOTIFY_DBG_MSG, type),\n",
        "        .arg1 = arg1,\n",
        "        .arg2 = arg2,}\n",
        "    ;\n",
        "    ctx_event_output (ctx, &EVENTS_MAP, BPF_F_CURRENT_CPU, &msg, sizeof (msg));\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 242,
      "endLine": 246,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/dbg.h",
      "funcName": "cilium_dbg",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff * ctx __maybe_unused",
        " __u8 type __maybe_unused",
        " __u32 arg1 __maybe_unused",
        " __u32 arg2 __maybe_unused"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void cilium_dbg (struct  __ctx_buff * ctx __maybe_unused, __u8 type __maybe_unused, __u32 arg1 __maybe_unused, __u32 arg2 __maybe_unused)\n",
        "{\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "cilium_dbg3": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 196,
      "endLine": 208,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/dbg.h",
      "funcName": "cilium_dbg3",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " __u8 type",
        " __u32 arg1",
        " __u32 arg2",
        " __u32 arg3"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void cilium_dbg3 (struct  __ctx_buff *ctx, __u8 type, __u32 arg1, __u32 arg2, __u32 arg3)\n",
        "{\n",
        "    struct debug_msg msg = {__notify_common_hdr (CILIUM_NOTIFY_DBG_MSG, type),\n",
        "        .arg1 = arg1,\n",
        "        .arg2 = arg2,\n",
        "        .arg3 = arg3,}\n",
        "    ;\n",
        "    ctx_event_output (ctx, &EVENTS_MAP, BPF_F_CURRENT_CPU, &msg, sizeof (msg));\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 248,
      "endLine": 253,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/dbg.h",
      "funcName": "cilium_dbg3",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff * ctx __maybe_unused",
        " __u8 type __maybe_unused",
        " __u32 arg1 __maybe_unused",
        " __u32 arg2 __maybe_unused",
        " __u32 arg3 __maybe_unused"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void cilium_dbg3 (struct  __ctx_buff * ctx __maybe_unused, __u8 type __maybe_unused, __u32 arg1 __maybe_unused, __u32 arg2 __maybe_unused, __u32 arg3 __maybe_unused)\n",
        "{\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "cilium_dbg_capture2": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 216,
      "endLine": 231,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/dbg.h",
      "funcName": "cilium_dbg_capture2",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " __u8 type",
        " __u32 arg1",
        " __u32 arg2"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void cilium_dbg_capture2 (struct  __ctx_buff *ctx, __u8 type, __u32 arg1, __u32 arg2)\n",
        "{\n",
        "    __u64 ctx_len = ctx_full_len (ctx);\n",
        "    __u64 cap_len = min_t (__u64, TRACE_PAYLOAD_LEN, ctx_len);\n",
        "    struct debug_capture_msg msg = {__notify_common_hdr (CILIUM_NOTIFY_DBG_CAPTURE, type), __notify_pktcap_hdr (ctx_len, (__u16) cap_len),\n",
        "        .arg1 = arg1,\n",
        "        .arg2 = arg2,}\n",
        "    ;\n",
        "    ctx_event_output (ctx, &EVENTS_MAP, (cap_len << 32) | BPF_F_CURRENT_CPU, &msg, sizeof (msg));\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_full_len"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 261,
      "endLine": 266,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/dbg.h",
      "funcName": "cilium_dbg_capture2",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff * ctx __maybe_unused",
        " __u8 type __maybe_unused",
        " __u32 arg1 __maybe_unused",
        " __u32 arg2 __maybe_unused"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void cilium_dbg_capture2 (struct  __ctx_buff * ctx __maybe_unused, __u8 type __maybe_unused, __u32 arg1 __maybe_unused, __u32 arg2 __maybe_unused)\n",
        "{\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_full_len"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "cilium_dbg_capture": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 233,
      "endLine": 237,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/dbg.h",
      "funcName": "cilium_dbg_capture",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " __u8 type",
        " __u32 arg1"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void cilium_dbg_capture (struct  __ctx_buff *ctx, __u8 type, __u32 arg1)\n",
        "{\n",
        "    cilium_dbg_capture2 (ctx, type, arg1, 0);\n",
        "}\n"
      ],
      "called_function_list": [
        "cilium_dbg_capture2"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 255,
      "endLine": 259,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/dbg.h",
      "funcName": "cilium_dbg_capture",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff * ctx __maybe_unused",
        " __u8 type __maybe_unused",
        " __u32 arg1 __maybe_unused"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void cilium_dbg_capture (struct  __ctx_buff * ctx __maybe_unused, __u8 type __maybe_unused, __u32 arg1 __maybe_unused)\n",
        "{\n",
        "}\n"
      ],
      "called_function_list": [
        "cilium_dbg_capture2"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "do_decrypt": [
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 15,
      "endLine": 75,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/encrypt.h",
      "funcName": "do_decrypt",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */"
        },
        {
          "start_line": 2,
          "end_line": 2,
          "text": "/* Copyright Authors of Cilium */"
        },
        {
          "start_line": 54,
          "end_line": 56,
          "text": "/* Allow all non-ESP packets up the stack per normal case\n\t\t * without encryption enabled.\n\t\t */"
        },
        {
          "start_line": 59,
          "end_line": 59,
          "text": "/* Decrypt \"key\" is determined by SPI */"
        },
        {
          "start_line": 61,
          "end_line": 65,
          "text": "/* We are going to pass this up the stack for IPsec decryption\n\t\t * but eth_type_trans may already have labeled this as an\n\t\t * OTHERHOST type packet. To avoid being dropped by IP stack\n\t\t * before IPSec can be processed mark as a HOST packet.\n\t\t */"
        },
        {
          "start_line": 74,
          "end_line": 74,
          "text": "/* ENABLE_ROUTING */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " __u16 proto"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "CTX_ACT_OK"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "static __always_inline int do_decrypt (struct  __ctx_buff *ctx, __u16 proto)\n",
        "{\n",
        "    void *data, *data_end;\n",
        "    __u8 protocol = 0;\n",
        "    bool decrypted;\n",
        "\n",
        "#ifdef ENABLE_IPV6\n",
        "    struct ipv6hdr *ip6;\n",
        "\n",
        "#endif\n",
        "\n",
        "#ifdef ENABLE_IPV4\n",
        "    struct iphdr *ip4;\n",
        "\n",
        "#endif\n",
        "    decrypted = ((ctx->mark & MARK_MAGIC_HOST_MASK) == MARK_MAGIC_DECRYPT);\n",
        "    switch (proto) {\n",
        "\n",
        "#ifdef ENABLE_IPV6\n",
        "    case bpf_htons (ETH_P_IPV6) :\n",
        "        if (!revalidate_data_pull (ctx, &data, &data_end, &ip6)) {\n",
        "            ctx->mark = 0;\n",
        "            return CTX_ACT_OK;\n",
        "        }\n",
        "        protocol = ip6->nexthdr;\n",
        "        break;\n",
        "\n",
        "#endif\n",
        "\n",
        "#ifdef ENABLE_IPV4\n",
        "    case bpf_htons (ETH_P_IP) :\n",
        "        if (!revalidate_data_pull (ctx, &data, &data_end, &ip4)) {\n",
        "            ctx->mark = 0;\n",
        "            return CTX_ACT_OK;\n",
        "        }\n",
        "        protocol = ip4->protocol;\n",
        "        break;\n",
        "\n",
        "#endif\n",
        "    default :\n",
        "        return CTX_ACT_OK;\n",
        "    }\n",
        "    if (!decrypted) {\n",
        "        if (protocol != IPPROTO_ESP)\n",
        "            return CTX_ACT_OK;\n",
        "        ctx->mark = MARK_MAGIC_DECRYPT;\n",
        "        ctx_change_type (ctx, PACKET_HOST);\n",
        "        return CTX_ACT_OK;\n",
        "    }\n",
        "    ctx->mark = 0;\n",
        "\n",
        "#ifdef ENABLE_ENDPOINT_ROUTES\n",
        "    return CTX_ACT_OK;\n",
        "\n",
        "#else\n",
        "    return ctx_redirect (ctx, CILIUM_IFINDEX, 0);\n",
        "\n",
        "#endif /* ENABLE_ROUTING */\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_redirect"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 77,
      "endLine": 81,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/encrypt.h",
      "funcName": "do_decrypt",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff  __maybe_unused *ctx",
        " __u16 __maybe_unused proto"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "CTX_ACT_OK"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "static __always_inline int do_decrypt (struct  __ctx_buff  __maybe_unused *ctx, __u16 __maybe_unused proto)\n",
        "{\n",
        "    return CTX_ACT_OK;\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_redirect"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "assign_socket_tcp": [
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        },
        {
          "capability": "read_sys_info",
          "read_sys_info": [
            {
              "Project": "cilium",
              "Return Type": "struct sock*",
              "Description": "Look for TCP socket matching <[ tuple ]>(IP: 1) , optionally in a child network namespace netns. The return value must be checked , and if non-NULL , released via sk_release(). This function is identical to sk_lookup_tcp() , except that it also returns timewait or request sockets. Use sk_fullsock() or tcp_sock() to access the full structure. This helper is available only if the kernel was compiled with CONFIG_NET configuration option. ",
              "Return": " Pointer  to  struct  sock, or NULL in case of failure.  For sockets with                     reuseport option, the struct  sock result is  from  reuse->socks[]  using                     the hash of the tuple.",
              "Function Name": "skc_lookup_tcp",
              "Input Params": [
                "{Type: void ,Var: *ctx}",
                "{Type:  struct sock_tuple ,Var: *tuple}",
                "{Type:  u32 ,Var: tuple_size}",
                "{Type:  u64 ,Var: netns}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "xdp",
                "sk_skb",
                "cgroup_sock_addr"
              ],
              "capabilities": [
                "read_sys_info"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 14,
      "endLine": 42,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/proxy.h",
      "funcName": "assign_socket_tcp",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */"
        },
        {
          "start_line": 2,
          "end_line": 2,
          "text": "/* Copyright Authors of Cilium */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " struct bpf_sock_tuple *tuple",
        " __u32 len",
        " bool established"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "sk_release",
        "CTX_ACT_OK",
        "skc_lookup_tcp"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "static __always_inline int assign_socket_tcp (struct  __ctx_buff *ctx, struct bpf_sock_tuple *tuple, __u32 len, bool established)\n",
        "{\n",
        "    int result = DROP_PROXY_LOOKUP_FAILED;\n",
        "    struct bpf_sock *sk;\n",
        "    __u32 dbg_ctx;\n",
        "    sk = skc_lookup_tcp (ctx, tuple, len, BPF_F_CURRENT_NETNS, 0);\n",
        "    if (!sk)\n",
        "        goto out;\n",
        "    if (established && sk->state == BPF_TCP_TIME_WAIT)\n",
        "        goto release;\n",
        "    if (established && sk->state == BPF_TCP_LISTEN)\n",
        "        goto release;\n",
        "    dbg_ctx = sk->family << 16 | ctx->protocol;\n",
        "    result = sk_assign (ctx, sk, 0);\n",
        "    cilium_dbg (ctx, DBG_SK_ASSIGN, -result, dbg_ctx);\n",
        "    if (result == 0)\n",
        "        result = CTX_ACT_OK;\n",
        "    else\n",
        "        result = DROP_PROXY_SET_FAILED;\n",
        "release :\n",
        "    sk_release (sk);\n",
        "out :\n",
        "    return result;\n",
        "}\n"
      ],
      "called_function_list": [
        "cilium_dbg"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "assign_socket_udp": [
    {
      "capabilities": [
        {
          "capability": "read_sys_info",
          "read_sys_info": [
            {
              "Project": "cilium",
              "Return Type": "struct sock*",
              "Description": "Look for UDP socket matching <[ tuple ]>(IP: 1) , optionally in a child network namespace netns. The return value must be checked , and if non-NULL , released via sk_release(). The <[ ctx ]>(IP: 0) should point to the context of the program , such as the skb or socket (depending on the hook in use). This is used to determine the base network namespace for the lookup. <[ tuple_size ]>(IP: 2) must be one of: sizeof(tuple->ipv4) Look for an IPv4 socket. sizeof(tuple->ipv6) Look for an IPv6 socket. If the <[ netns ]>(IP: 3) is a negative signed 32-bit integer , then the socket lookup table in the <[ netns ]>(IP: 3) associated with the <[ ctx ]>(IP: 0) will will be used. For the TC hooks , this is the <[ netns ]>(IP: 3) of the device in the skb. For socket hooks , this is the <[ netns ]>(IP: 3) of the socket. If <[ netns ]>(IP: 3) is any other signed 32-bit value greater than or equal to zero then it specifies the ID of the <[ netns ]>(IP: 3) relative to the <[ netns ]>(IP: 3) associated with the ctx. <[ netns ]>(IP: 3) values beyond the range of 32-bit integers are reserved for future use. All values for <[ flags ]>(IP: 4) are reserved for future usage , and must be left at zero. This helper is available only if the kernel was compiled with CONFIG_NET configuration option. ",
              "Return": " Pointer  to  struct  sock, or NULL in case of failure.  For sockets with                     reuseport option, the struct  sock result is  from  reuse->socks[]  using                     the hash of the tuple.",
              "Function Name": "sk_lookup_udp",
              "Input Params": [
                "{Type: void ,Var: *ctx}",
                "{Type:  struct sock_tuple ,Var: *tuple}",
                "{Type:  u32 ,Var: tuple_size}",
                "{Type:  u64 ,Var: netns}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "xdp",
                "sk_skb",
                "cgroup_sock_addr"
              ],
              "capabilities": [
                "read_sys_info"
              ]
            }
          ]
        },
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 44,
      "endLine": 67,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/proxy.h",
      "funcName": "assign_socket_udp",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " struct bpf_sock_tuple *tuple",
        " __u32 len",
        " bool established __maybe_unused"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "sk_lookup_udp",
        "CTX_ACT_OK",
        "sk_release"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "static __always_inline int assign_socket_udp (struct  __ctx_buff *ctx, struct bpf_sock_tuple *tuple, __u32 len, bool established __maybe_unused)\n",
        "{\n",
        "    int result = DROP_PROXY_LOOKUP_FAILED;\n",
        "    struct bpf_sock *sk;\n",
        "    __u32 dbg_ctx;\n",
        "    sk = sk_lookup_udp (ctx, tuple, len, BPF_F_CURRENT_NETNS, 0);\n",
        "    if (!sk)\n",
        "        goto out;\n",
        "    dbg_ctx = sk->family << 16 | ctx->protocol;\n",
        "    result = sk_assign (ctx, sk, 0);\n",
        "    cilium_dbg (ctx, DBG_SK_ASSIGN, -result, dbg_ctx);\n",
        "    if (result == 0)\n",
        "        result = CTX_ACT_OK;\n",
        "    else\n",
        "        result = DROP_PROXY_SET_FAILED;\n",
        "    sk_release (sk);\n",
        "out :\n",
        "    return result;\n",
        "}\n"
      ],
      "called_function_list": [
        "cilium_dbg"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "assign_socket": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 69,
      "endLine": 86,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/proxy.h",
      "funcName": "assign_socket",
      "developer_inline_comments": [
        {
          "start_line": 74,
          "end_line": 78,
          "text": "/* Workaround: While the below functions are nearly identical in C\n\t * implementation, the 'struct bpf_sock *' has a different verifier\n\t * pointer type, which means we can't fold these implementations\n\t * together.\n\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " struct bpf_sock_tuple *tuple",
        " __u32 len",
        " __u8 nexthdr",
        " bool established"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int assign_socket (struct  __ctx_buff *ctx, struct bpf_sock_tuple *tuple, __u32 len, __u8 nexthdr, bool established)\n",
        "{\n",
        "    switch (nexthdr) {\n",
        "    case IPPROTO_TCP :\n",
        "        return assign_socket_tcp (ctx, tuple, len, established);\n",
        "    case IPPROTO_UDP :\n",
        "        return assign_socket_udp (ctx, tuple, len, established);\n",
        "    }\n",
        "    return DROP_PROXY_UNKNOWN_PROTO;\n",
        "}\n"
      ],
      "called_function_list": [
        "assign_socket_udp",
        "assign_socket_tcp"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "combine_ports": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 92,
      "endLine": 96,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/proxy.h",
      "funcName": "combine_ports",
      "developer_inline_comments": [
        {
          "start_line": 88,
          "end_line": 91,
          "text": "/**\n * combine_ports joins the specified ports in a manner consistent with\n * pkg/monitor/dataapth_debug.go to report the ports ino monitor messages.\n */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "__u16 dport",
        " __u16 sport"
      ],
      "output": "static__always_inline__u32",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __u32 combine_ports (__u16 dport, __u16 sport)\n",
        "{\n",
        "    return (bpf_ntohs (dport) << 16) | bpf_ntohs (sport);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__ctx_redirect_to_proxy": [
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 190,
      "endLine": 220,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/proxy.h",
      "funcName": "__ctx_redirect_to_proxy",
      "developer_inline_comments": [
        {
          "start_line": 100,
          "end_line": 108,
          "text": "/**\t\t\t\t\t\t\t\t\t\t\\\n * ctx_redirect_to_proxy_ingress4 / ctx_redirect_to_proxy_ingress6\t\t\\\n * @ctx\t\t\tpointer to program context\t\t\t\t\\\n * @tuple\t\tpointer to *scratch buffer* with packet tuple\t\t\\\n * @proxy_port\t\tport to redirect traffic towards\t\t\t\\\n *\t\t\t\t\t\t\t\t\t\t\\\n * Prefetch the proxy socket and associate with the ctx. Must be run on tc\t\\\n * ingress. Will modify 'tuple'!\t\t\t\t\t\t\\\n */"
        },
        {
          "start_line": 118,
          "end_line": 123,
          "text": "/* The provided 'ct_tuple' is in the internal Cilium format, which\t\\\n\t * reverses the source/destination ports as compared with the actual\t\\\n\t * packet contents. 'bpf_sock_tuple' in the eBPF API needs these to\t\\\n\t * match normal packet ordering to successfully look up the\t\t\\\n\t * corresponding socket. So, swap them here.\t\t\t\t\\\n\t */"
        },
        {
          "start_line": 128,
          "end_line": 128,
          "text": "/* Look for established socket locally first */"
        },
        {
          "start_line": 136,
          "end_line": 136,
          "text": "/* if there's no established connection, locate the tproxy socket */"
        },
        {
          "start_line": 159,
          "end_line": 159,
          "text": "/* ENABLE_TPROXY */"
        },
        {
          "start_line": 161,
          "end_line": 189,
          "text": "/**\n * __ctx_redirect_to_proxy configures the ctx with the proxy mark and proxy\n * port number to ensure that the stack redirects the packet into the proxy.\n *\n * It is called from both ingress and egress side of endpoint devices.\n *\n * In regular veth mode:\n * * To apply egress policy, the egressing endpoint configures the mark,\n *   which returns CTX_ACT_OK to pass the packet to the stack in the context\n *   of the source device (stack ingress).\n * * To apply ingress policy, the egressing endpoint or netdev program tail\n *   calls into the policy program which configures the mark here, which\n *   returns CTX_ACT_OK to pass the packet to the stack in the context of the\n *   source device (netdev or egress endpoint device, stack ingress).\n *\n * In chaining mode with bridged endpoint devices:\n * * To apply egress policy, the egressing endpoint configures the mark,\n *   which is propagated via ctx_store_meta() in the caller. The redirect() call\n *   here redirects the packet to the ingress TC filter configured on the bridge\n *   master device.\n * * To apply ingress policy, the stack transmits the packet into the bridge\n *   master device which tail calls into the policy program for the ingress\n *   endpoint, which configures mark and cb[] as described for the egress path.\n *   The redirect() call here redirects the packet to the ingress TC filter\n *   configured on the bridge master device.\n * * In both cases for bridged endpoint devices, the bridge master device has\n *   a BPF program configured upon ingress to transfer the cb[] to the mark\n *   before passing the traffic up to the stack towards the proxy.\n */"
        },
        {
          "start_line": 211,
          "end_line": 211,
          "text": "/* ENABLE_IPV4 */"
        },
        {
          "start_line": 215,
          "end_line": 215,
          "text": "/* ENABLE_IPV6 */"
        },
        {
          "start_line": 217,
          "end_line": 217,
          "text": "/* ENABLE_TPROXY */"
        },
        {
          "start_line": 218,
          "end_line": 218,
          "text": "/* Required for ingress packets from overlay */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " void * tuple __maybe_unused",
        " __be16 proxy_port",
        " bool from_host __maybe_unused",
        " bool ipv4 __maybe_unused"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "CTX_ACT_OK"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "static __always_inline int __ctx_redirect_to_proxy (struct  __ctx_buff *ctx, void * tuple __maybe_unused, __be16 proxy_port, bool from_host __maybe_unused, bool ipv4 __maybe_unused)\n",
        "{\n",
        "    int result __maybe_unused = CTX_ACT_OK;\n",
        "\n",
        "#ifdef ENABLE_TPROXY\n",
        "    if (!from_host)\n",
        "        ctx->mark |= MARK_MAGIC_TO_PROXY;\n",
        "    else\n",
        "\n",
        "#endif\n",
        "        ctx->mark = MARK_MAGIC_TO_PROXY | proxy_port << 16;\n",
        "    cilium_dbg (ctx, DBG_CAPTURE_PROXY_PRE, proxy_port, 0);\n",
        "\n",
        "#ifdef ENABLE_TPROXY\n",
        "    if (proxy_port && !from_host) {\n",
        "\n",
        "#ifdef ENABLE_IPV4\n",
        "        if (ipv4)\n",
        "            result = ctx_redirect_to_proxy_ingress4 (ctx, tuple, proxy_port);\n",
        "\n",
        "#endif /* ENABLE_IPV4 */\n",
        "\n",
        "#ifdef ENABLE_IPV6\n",
        "        if (!ipv4)\n",
        "            result = ctx_redirect_to_proxy_ingress6 (ctx, tuple, proxy_port);\n",
        "\n",
        "#endif /* ENABLE_IPV6 */\n",
        "    }\n",
        "\n",
        "#endif /* ENABLE_TPROXY */\n",
        "    ctx_change_type (ctx, PACKET_HOST);\n",
        "    return result;\n",
        "}\n"
      ],
      "called_function_list": [
        "cilium_dbg"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ctx_redirect_to_proxy4": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 223,
      "endLine": 228,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/proxy.h",
      "funcName": "ctx_redirect_to_proxy4",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " void * tuple __maybe_unused",
        " __be16 proxy_port",
        " bool from_host __maybe_unused"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int ctx_redirect_to_proxy4 (struct  __ctx_buff *ctx, void * tuple __maybe_unused, __be16 proxy_port, bool from_host __maybe_unused)\n",
        "{\n",
        "    return __ctx_redirect_to_proxy (ctx, tuple, proxy_port, from_host, true);\n",
        "}\n"
      ],
      "called_function_list": [
        "__ctx_redirect_to_proxy"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ctx_redirect_to_proxy6": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 232,
      "endLine": 237,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/proxy.h",
      "funcName": "ctx_redirect_to_proxy6",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " void * tuple __maybe_unused",
        " __be16 proxy_port",
        " bool from_host __maybe_unused"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int ctx_redirect_to_proxy6 (struct  __ctx_buff *ctx, void * tuple __maybe_unused, __be16 proxy_port, bool from_host __maybe_unused)\n",
        "{\n",
        "    return __ctx_redirect_to_proxy (ctx, tuple, proxy_port, from_host, false);\n",
        "}\n"
      ],
      "called_function_list": [
        "__ctx_redirect_to_proxy"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ctx_redirect_to_proxy_first": [
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 280,
      "endLine": 337,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/proxy.h",
      "funcName": "ctx_redirect_to_proxy_first",
      "developer_inline_comments": [
        {
          "start_line": 242,
          "end_line": 249,
          "text": "/**\t\t\t\t\t\t\t\t\t\\\n * extract_tuple4 / extract_tuple6\t\t\t\t\t\\\n *\t\t\t\t\t\t\t\t\t\\\n * Extracts the packet 5-tuple into 'tuple'.\t\t\t\t\\\n *\t\t\t\t\t\t\t\t\t\\\n * Note that it doesn't fully initialize 'tuple' as the directionality\t\\\n * bit is unused in the proxy paths.\t\t\t\t\t\\\n */"
        },
        {
          "start_line": 269,
          "end_line": 269,
          "text": "/* ENABLE_IPV4 */"
        },
        {
          "start_line": 272,
          "end_line": 272,
          "text": "/* ENABLE_IPV6 */"
        },
        {
          "start_line": 273,
          "end_line": 273,
          "text": "/* ENABLE_TPROXY */"
        },
        {
          "start_line": 275,
          "end_line": 279,
          "text": "/**\n * ctx_redirect_to_proxy_first() applies changes to the context to forward\n * the packet towards the proxy. It is designed to run as the first function\n * that accesses the context from the current BPF program.\n */"
        },
        {
          "start_line": 287,
          "end_line": 294,
          "text": "/**\n\t * For reply traffic to egress proxy for a local endpoint, we skip the\n\t * policy & proxy_port lookup and just hairpin & rely on local stack\n\t * routing via ctx->mark to ensure that the return traffic reaches the\n\t * proxy. This is only relevant for endpoint-routes mode but we don't\n\t * have a macro for this so the logic applies unconditionally here.\n\t * See ct_state.proxy_redirect usage in bpf_lxc.c for more info.\n\t */"
        },
        {
          "start_line": 313,
          "end_line": 313,
          "text": "/* ENABLE_IPV6 */"
        },
        {
          "start_line": 324,
          "end_line": 324,
          "text": "/* ENABLE_IPV4 */"
        },
        {
          "start_line": 328,
          "end_line": 328,
          "text": "/* ENABLE_TPROXY */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " __be16 proxy_port"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "CTX_ACT_OK"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "static __always_inline int ctx_redirect_to_proxy_first (struct  __ctx_buff *ctx, __be16 proxy_port)\n",
        "{\n",
        "    int ret = CTX_ACT_OK;\n",
        "\n",
        "#if defined(ENABLE_TPROXY)\n",
        "    __u16 proto;\n",
        "    if (!proxy_port)\n",
        "        goto mark;\n",
        "    if (!validate_ethertype (ctx, &proto))\n",
        "        return DROP_UNSUPPORTED_L2;\n",
        "    ret = DROP_UNKNOWN_L3;\n",
        "    switch (proto) {\n",
        "\n",
        "#ifdef ENABLE_IPV6\n",
        "    case bpf_htons (ETH_P_IPV6) :\n",
        "        {\n",
        "            struct ipv6_ct_tuple tuple;\n",
        "            ret = extract_tuple6 (ctx, & tuple);\n",
        "            if (ret < 0)\n",
        "                return ret;\n",
        "            ret = ctx_redirect_to_proxy_ingress6 (ctx, & tuple, proxy_port);\n",
        "            break;\n",
        "        }\n",
        "\n",
        "#endif /* ENABLE_IPV6 */\n",
        "\n",
        "#ifdef ENABLE_IPV4\n",
        "    case bpf_htons (ETH_P_IP) :\n",
        "        {\n",
        "            struct ipv4_ct_tuple tuple;\n",
        "            ret = extract_tuple4 (ctx, & tuple);\n",
        "            if (ret < 0)\n",
        "                return ret;\n",
        "            ret = ctx_redirect_to_proxy_ingress4 (ctx, & tuple, proxy_port);\n",
        "            break;\n",
        "        }\n",
        "\n",
        "#endif /* ENABLE_IPV4 */\n",
        "    default :\n",
        "        goto out;\n",
        "    }\n",
        "\n",
        "#endif /* ENABLE_TPROXY */\n",
        "mark :\n",
        "    __maybe_unused cilium_dbg (ctx, DBG_CAPTURE_PROXY_POST, proxy_port, 0);\n",
        "    ctx->mark = MARK_MAGIC_TO_PROXY | (proxy_port << 16);\n",
        "    ctx_change_type (ctx, PACKET_HOST);\n",
        "out :\n",
        "    __maybe_unused\n",
        "    return ret;\n",
        "}\n"
      ],
      "called_function_list": [
        "validate_ethertype",
        "cilium_dbg"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "tc_index_skip_ingress_proxy": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 342,
      "endLine": 351,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/proxy.h",
      "funcName": "tc_index_skip_ingress_proxy",
      "developer_inline_comments": [
        {
          "start_line": 339,
          "end_line": 341,
          "text": "/**\n * tc_index_skip_ingress_proxy - returns true if packet originates from ingress proxy\n */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "static__always_inlinebool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline bool tc_index_skip_ingress_proxy (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    volatile __u32 tc_index = ctx->tc_index;\n",
        "\n",
        "#ifdef DEBUG\n",
        "    if (tc_index & TC_INDEX_F_SKIP_INGRESS_PROXY)\n",
        "        cilium_dbg (ctx, DBG_SKIP_PROXY, tc_index, 0);\n",
        "\n",
        "#endif\n",
        "    return tc_index & TC_INDEX_F_SKIP_INGRESS_PROXY;\n",
        "}\n"
      ],
      "called_function_list": [
        "cilium_dbg"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "tc_index_skip_egress_proxy": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 356,
      "endLine": 365,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/proxy.h",
      "funcName": "tc_index_skip_egress_proxy",
      "developer_inline_comments": [
        {
          "start_line": 353,
          "end_line": 355,
          "text": "/**\n * tc_index_skip_egress_proxy - returns true if packet originates from egress proxy\n */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "static__always_inlinebool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline bool tc_index_skip_egress_proxy (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    volatile __u32 tc_index = ctx->tc_index;\n",
        "\n",
        "#ifdef DEBUG\n",
        "    if (tc_index & TC_INDEX_F_SKIP_EGRESS_PROXY)\n",
        "        cilium_dbg (ctx, DBG_SKIP_PROXY, tc_index, 0);\n",
        "\n",
        "#endif\n",
        "    return tc_index & TC_INDEX_F_SKIP_EGRESS_PROXY;\n",
        "}\n"
      ],
      "called_function_list": [
        "cilium_dbg"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "is_valid_lxc_src_ip": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 22,
      "endLine": 34,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lxc.h",
      "funcName": "is_valid_lxc_src_ip",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */"
        },
        {
          "start_line": 2,
          "end_line": 2,
          "text": "/* Copyright Authors of Cilium */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct ipv6hdr * ip6 __maybe_unused"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int is_valid_lxc_src_ip (struct ipv6hdr * ip6 __maybe_unused)\n",
        "{\n",
        "\n",
        "#ifdef ENABLE_IPV6\n",
        "    union v6addr valid = {}\n",
        "    ;\n",
        "    BPF_V6 (valid, LXC_IP);\n",
        "    return !ipv6_addrcmp ((union v6addr *) &ip6->saddr, &valid);\n",
        "\n",
        "#else\n",
        "    return 0;\n",
        "\n",
        "#endif\n",
        "}\n"
      ],
      "called_function_list": [
        "ipv6_addrcmp"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 47,
      "endLine": 51,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lxc.h",
      "funcName": "is_valid_lxc_src_ip",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct ipv6hdr * ip6 __maybe_unused"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int is_valid_lxc_src_ip (struct ipv6hdr * ip6 __maybe_unused)\n",
        "{\n",
        "    return 1;\n",
        "}\n"
      ],
      "called_function_list": [
        "ipv6_addrcmp"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "is_valid_lxc_src_ipv4": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 36,
      "endLine": 45,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lxc.h",
      "funcName": "is_valid_lxc_src_ipv4",
      "developer_inline_comments": [
        {
          "start_line": 42,
          "end_line": 42,
          "text": "/* Can't send IPv4 if no IPv4 address is configured */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct iphdr * ip4 __maybe_unused"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int is_valid_lxc_src_ipv4 (const struct iphdr * ip4 __maybe_unused)\n",
        "{\n",
        "\n",
        "#ifdef ENABLE_IPV4\n",
        "    return ip4->saddr == LXC_IPV4;\n",
        "\n",
        "#else\n",
        "    return 0;\n",
        "\n",
        "#endif\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 53,
      "endLine": 57,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lxc.h",
      "funcName": "is_valid_lxc_src_ipv4",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct iphdr * ip4 __maybe_unused"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int is_valid_lxc_src_ipv4 (struct iphdr * ip4 __maybe_unused)\n",
        "{\n",
        "    return 1;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "redirect_direct_v6": [
    {
      "capabilities": [
        {
          "capability": "read_sys_info",
          "read_sys_info": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Description": "Do FIB lookup in kernel tables using parameters in params. If lookup is successful and result shows packet is to be forwarded , the neighbor tables are searched for the nexthop. If successful (ie. , FIB lookup shows forwarding and nexthop is resolved) , the nexthop address is returned in ipv4_dst or ipv6_dst based on family , smac is set to mac address of egress device , dmac is set to nexthop mac address , rt_metric is set to metric from route (IPv4/IPv6 only) , and ifindex is set to the device index of the nexthop from the FIB lookup. <[ plen ]>(IP: 2) argument is the size of the passed in struct. <[ flags ]>(IP: 3) argument can be a combination of one or more of the following values: BPF_FIB_LOOKUP_DIRECT Do a direct table lookup vs full lookup using FIB rules. BPF_FIB_LOOKUP_OUTPUT Perform lookup from an egress perspective (default is ingress). <[ ctx ]>(IP: 0) is either struct xdp_md for XDP programs or struct sk_buff tc cls_act programs. Return \u00b7 < 0 if any input argument is invalid \u00b7 0 on success (packet is forwarded , nexthop neighbor exists) \u00b7 > 0 one of BPF_FIB_LKUP_RET_ codes explaining why the packet is not forwarded or needs assist from full stack ",
              "Function Name": "fib_lookup",
              "Input Params": [
                "{Type: void ,Var: *ctx}",
                "{Type:  struct fib_lookup ,Var: *params}",
                "{Type:  int ,Var: plen}",
                "{Type:  u32 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "xdp"
              ],
              "capabilities": [
                "read_sys_info"
              ]
            },
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Do FIB lookup in kernel tables using parameters in params. If lookup is successful and result shows packet is to be forwarded , the neighbor tables are searched for the nexthop. If successful (ie. , FIB lookup shows forwarding and nexthop is resolved) , the nexthop address is returned in ipv4_dst or ipv6_dst based on family , smac is set to mac address of egress device , dmac is set to nexthop mac address , rt_metric is set to metric from route (IPv4/IPv6 only) , and ifindex is set to the device index of the nexthop from the FIB lookup. <[ plen ]>(IP: 2) argument is the size of the passed in struct. <[ flags ]>(IP: 3) argument can be a combination of one or more of the following values: BPF_FIB_LOOKUP_DIRECT Do a direct table lookup vs full lookup using FIB rules. BPF_FIB_LOOKUP_OUTPUT Perform lookup from an egress perspective (default is ingress). <[ ctx ]>(IP: 0) is either struct xdp_md for XDP programs or struct sk_buff tc cls_act programs. Return \u00b7 < 0 if any input argument is invalid \u00b7 0 on success (packet is forwarded , nexthop neighbor exists) \u00b7 > 0 one of BPF_FIB_LKUP_RET_ codes explaining why the packet is not forwarded or needs assist from full stack ",
              "Function Name": "bpf_fib_lookup",
              "Input Params": [
                "{Type: void ,Var: *ctx}",
                "{Type:  struct bpf_fib_lookup ,Var: *params}",
                "{Type:  int ,Var: plen}",
                "{Type:  u32 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "xdp"
              ],
              "capabilities": [
                "read_sys_info"
              ]
            }
          ]
        },
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 14,
      "endLine": 66,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/fib.h",
      "funcName": "redirect_direct_v6",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */"
        },
        {
          "start_line": 2,
          "end_line": 2,
          "text": "/* Copyright Authors of Cilium */"
        },
        {
          "start_line": 51,
          "end_line": 51,
          "text": "/* ENABLE_SKIP_FIB */"
        },
        {
          "start_line": 64,
          "end_line": 64,
          "text": "/* ENABLE_SKIP_FIB */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff * ctx __maybe_unused",
        " int l3_off __maybe_unused",
        " struct ipv6hdr * ip6 __maybe_unused"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "fib_lookup",
        "redirect",
        "bpf_fib_lookup",
        "CTX_ACT_OK"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "static __always_inline int redirect_direct_v6 (struct  __ctx_buff * ctx __maybe_unused, int l3_off __maybe_unused, struct ipv6hdr * ip6 __maybe_unused)\n",
        "{\n",
        "    bool no_neigh = is_defined (ENABLE_SKIP_FIB);\n",
        "    int ret, oif = DIRECT_ROUTING_DEV_IFINDEX;\n",
        "    struct bpf_redir_neigh *nh = NULL;\n",
        "\n",
        "# ifndef ENABLE_SKIP_FIB\n",
        "    struct bpf_redir_neigh nh_params;\n",
        "    struct bpf_fib_lookup fib_params = {\n",
        "        .family = AF_INET6,\n",
        "        .ifindex = ctx->ingress_ifindex,}\n",
        "    ;\n",
        "    ipv6_addr_copy ((union v6addr *) &fib_params.ipv6_src, (union v6addr *) &ip6->saddr);\n",
        "    ipv6_addr_copy ((union v6addr *) &fib_params.ipv6_dst, (union v6addr *) &ip6->daddr);\n",
        "    ret = fib_lookup (ctx, & fib_params, sizeof (fib_params), BPF_FIB_LOOKUP_DIRECT);\n",
        "    switch (ret) {\n",
        "    case BPF_FIB_LKUP_RET_SUCCESS :\n",
        "        break;\n",
        "    case BPF_FIB_LKUP_RET_NO_NEIGH :\n",
        "        nh_params.nh_family = fib_params.family;\n",
        "        __bpf_memcpy_builtin (&nh_params.ipv6_nh, &fib_params.ipv6_dst, sizeof (nh_params.ipv6_nh));\n",
        "        no_neigh = true;\n",
        "        nh = &nh_params;\n",
        "        break;\n",
        "    default :\n",
        "        return CTX_ACT_DROP;\n",
        "    }\n",
        "    oif = fib_params.ifindex;\n",
        "\n",
        "# endif /* ENABLE_SKIP_FIB */\n",
        "    ret = ipv6_l3 (ctx, l3_off, NULL, NULL, METRIC_EGRESS);\n",
        "    if (unlikely (ret != CTX_ACT_OK))\n",
        "        return ret;\n",
        "    if (no_neigh)\n",
        "        return redirect_neigh (oif, nh, nh ? sizeof (*nh) : 0, 0);\n",
        "\n",
        "# ifndef ENABLE_SKIP_FIB\n",
        "    if (eth_store_daddr (ctx, fib_params.dmac, 0) < 0)\n",
        "        return CTX_ACT_DROP;\n",
        "    if (eth_store_saddr (ctx, fib_params.smac, 0) < 0)\n",
        "        return CTX_ACT_DROP;\n",
        "    return ctx_redirect (ctx, oif, 0);\n",
        "\n",
        "# endif /* ENABLE_SKIP_FIB */\n",
        "    return CTX_ACT_DROP;\n",
        "}\n"
      ],
      "called_function_list": [
        "ipv6_l3",
        "eth_store_daddr",
        "ctx_redirect",
        "__bpf_memcpy_builtin",
        "ipv6_addr_copy",
        "eth_store_saddr"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "redirect_direct_v4": [
    {
      "capabilities": [
        {
          "capability": "read_sys_info",
          "read_sys_info": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Description": "Do FIB lookup in kernel tables using parameters in params. If lookup is successful and result shows packet is to be forwarded , the neighbor tables are searched for the nexthop. If successful (ie. , FIB lookup shows forwarding and nexthop is resolved) , the nexthop address is returned in ipv4_dst or ipv6_dst based on family , smac is set to mac address of egress device , dmac is set to nexthop mac address , rt_metric is set to metric from route (IPv4/IPv6 only) , and ifindex is set to the device index of the nexthop from the FIB lookup. <[ plen ]>(IP: 2) argument is the size of the passed in struct. <[ flags ]>(IP: 3) argument can be a combination of one or more of the following values: BPF_FIB_LOOKUP_DIRECT Do a direct table lookup vs full lookup using FIB rules. BPF_FIB_LOOKUP_OUTPUT Perform lookup from an egress perspective (default is ingress). <[ ctx ]>(IP: 0) is either struct xdp_md for XDP programs or struct sk_buff tc cls_act programs. Return \u00b7 < 0 if any input argument is invalid \u00b7 0 on success (packet is forwarded , nexthop neighbor exists) \u00b7 > 0 one of BPF_FIB_LKUP_RET_ codes explaining why the packet is not forwarded or needs assist from full stack ",
              "Function Name": "fib_lookup",
              "Input Params": [
                "{Type: void ,Var: *ctx}",
                "{Type:  struct fib_lookup ,Var: *params}",
                "{Type:  int ,Var: plen}",
                "{Type:  u32 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "xdp"
              ],
              "capabilities": [
                "read_sys_info"
              ]
            },
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Description": "Do FIB lookup in kernel tables using parameters in params. If lookup is successful and result shows packet is to be forwarded , the neighbor tables are searched for the nexthop. If successful (ie. , FIB lookup shows forwarding and nexthop is resolved) , the nexthop address is returned in ipv4_dst or ipv6_dst based on family , smac is set to mac address of egress device , dmac is set to nexthop mac address , rt_metric is set to metric from route (IPv4/IPv6 only) , and ifindex is set to the device index of the nexthop from the FIB lookup. <[ plen ]>(IP: 2) argument is the size of the passed in struct. <[ flags ]>(IP: 3) argument can be a combination of one or more of the following values: BPF_FIB_LOOKUP_DIRECT Do a direct table lookup vs full lookup using FIB rules. BPF_FIB_LOOKUP_OUTPUT Perform lookup from an egress perspective (default is ingress). <[ ctx ]>(IP: 0) is either struct xdp_md for XDP programs or struct sk_buff tc cls_act programs. Return \u00b7 < 0 if any input argument is invalid \u00b7 0 on success (packet is forwarded , nexthop neighbor exists) \u00b7 > 0 one of BPF_FIB_LKUP_RET_ codes explaining why the packet is not forwarded or needs assist from full stack ",
              "Function Name": "bpf_fib_lookup",
              "Input Params": [
                "{Type: void ,Var: *ctx}",
                "{Type:  struct bpf_fib_lookup ,Var: *params}",
                "{Type:  int ,Var: plen}",
                "{Type:  u32 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "xdp"
              ],
              "capabilities": [
                "read_sys_info"
              ]
            }
          ]
        },
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 70,
      "endLine": 126,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/fib.h",
      "funcName": "redirect_direct_v4",
      "developer_inline_comments": [
        {
          "start_line": 75,
          "end_line": 80,
          "text": "/* For deployments with just single external dev, redirect_neigh()\n\t * will resolve the GW and do L2 resolution for us. For multi-device\n\t * deployments we perform a FIB lookup prior to the redirect. If the\n\t * neigh entry cannot be resolved, we ask redirect_neigh() to do it,\n\t * otherwise we can directly call redirect().\n\t */"
        },
        {
          "start_line": 99,
          "end_line": 99,
          "text": "/* GW could also be v6, so copy union. */"
        },
        {
          "start_line": 111,
          "end_line": 111,
          "text": "/* ENABLE_SKIP_FIB */"
        },
        {
          "start_line": 124,
          "end_line": 124,
          "text": "/* ENABLE_SKIP_FIB */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff * ctx __maybe_unused",
        " int l3_off __maybe_unused",
        " struct iphdr * ip4 __maybe_unused"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "fib_lookup",
        "redirect",
        "bpf_fib_lookup",
        "CTX_ACT_OK"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "static __always_inline int redirect_direct_v4 (struct  __ctx_buff * ctx __maybe_unused, int l3_off __maybe_unused, struct iphdr * ip4 __maybe_unused)\n",
        "{\n",
        "    bool no_neigh = is_defined (ENABLE_SKIP_FIB);\n",
        "    int ret, oif = DIRECT_ROUTING_DEV_IFINDEX;\n",
        "    struct bpf_redir_neigh *nh = NULL;\n",
        "\n",
        "# ifndef ENABLE_SKIP_FIB\n",
        "    struct bpf_redir_neigh nh_params;\n",
        "    struct bpf_fib_lookup fib_params = {\n",
        "        .family = AF_INET,\n",
        "        .ifindex = ctx->ingress_ifindex,\n",
        "        .ipv4_src = ip4->saddr,\n",
        "        .ipv4_dst = ip4->daddr,}\n",
        "    ;\n",
        "    ret = fib_lookup (ctx, & fib_params, sizeof (fib_params), BPF_FIB_LOOKUP_DIRECT);\n",
        "    switch (ret) {\n",
        "    case BPF_FIB_LKUP_RET_SUCCESS :\n",
        "        break;\n",
        "    case BPF_FIB_LKUP_RET_NO_NEIGH :\n",
        "        nh_params.nh_family = fib_params.family;\n",
        "        __bpf_memcpy_builtin (&nh_params.ipv6_nh, &fib_params.ipv6_dst, sizeof (nh_params.ipv6_nh));\n",
        "        no_neigh = true;\n",
        "        nh = &nh_params;\n",
        "        break;\n",
        "    default :\n",
        "        return CTX_ACT_DROP;\n",
        "    }\n",
        "    oif = fib_params.ifindex;\n",
        "\n",
        "# endif /* ENABLE_SKIP_FIB */\n",
        "    ret = ipv4_l3 (ctx, l3_off, NULL, NULL, ip4);\n",
        "    if (unlikely (ret != CTX_ACT_OK))\n",
        "        return ret;\n",
        "    if (no_neigh)\n",
        "        return redirect_neigh (oif, nh, nh ? sizeof (*nh) : 0, 0);\n",
        "\n",
        "# ifndef ENABLE_SKIP_FIB\n",
        "    if (eth_store_daddr (ctx, fib_params.dmac, 0) < 0)\n",
        "        return CTX_ACT_DROP;\n",
        "    if (eth_store_saddr (ctx, fib_params.smac, 0) < 0)\n",
        "        return CTX_ACT_DROP;\n",
        "    return ctx_redirect (ctx, oif, 0);\n",
        "\n",
        "# endif /* ENABLE_SKIP_FIB */\n",
        "    return CTX_ACT_DROP;\n",
        "}\n"
      ],
      "called_function_list": [
        "eth_store_daddr",
        "ipv4_l3",
        "__bpf_memcpy_builtin",
        "ctx_redirect",
        "eth_store_saddr"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "encap_and_redirect_nomark_ipsec": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 18,
      "endLine": 40,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/encap.h",
      "funcName": "encap_and_redirect_nomark_ipsec",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */"
        },
        {
          "start_line": 2,
          "end_line": 2,
          "text": "/* Copyright Authors of Cilium */"
        },
        {
          "start_line": 13,
          "end_line": 15,
          "text": "/* NOT_VTEP_DST is passed to an encapsulation function when the\n * destination of the tunnel is not a VTEP.\n */"
        },
        {
          "start_line": 22,
          "end_line": 35,
          "text": "/* Traffic from local host in tunnel mode will be passed to\n\t * cilium_host. In non-IPSec case traffic with non-local dst\n\t * will then be redirected to tunnel device. In IPSec case\n\t * though we need to traverse xfrm path still. The mark +\n\t * cb[4] hints will not survive a veth pair xmit to ingress\n\t * however so below encap_and_redirect_ipsec will not work.\n\t * Instead pass hints via cb[0], cb[4] (cb is not cleared\n\t * by dev_ctx_forward) and catch hints with bpf_host\n\t * prog that will populate mark/cb as expected by xfrm and 2nd\n\t * traversal into bpf_host. Remember we can't use cb[0-3]\n\t * in both cases because xfrm layer would overwrite them. We\n\t * use cb[4] here so it doesn't need to be reset by\n\t * bpf_host.\n\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " __u32 tunnel_endpoint",
        " __u8 key",
        " __u32 seclabel"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int encap_and_redirect_nomark_ipsec (struct  __ctx_buff *ctx, __u32 tunnel_endpoint, __u8 key, __u32 seclabel)\n",
        "{\n",
        "    ctx_store_meta (ctx, CB_ENCRYPT_MAGIC, or_encrypt_key (key));\n",
        "    ctx_store_meta (ctx, CB_ENCRYPT_IDENTITY, seclabel);\n",
        "    ctx_store_meta (ctx, CB_ENCRYPT_DST, tunnel_endpoint);\n",
        "    return IPSEC_ENDPOINT;\n",
        "}\n"
      ],
      "called_function_list": [
        "or_encrypt_key",
        "ctx_store_meta"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "encap_and_redirect_ipsec": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 42,
      "endLine": 57,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/encap.h",
      "funcName": "encap_and_redirect_ipsec",
      "developer_inline_comments": [
        {
          "start_line": 46,
          "end_line": 52,
          "text": "/* IPSec is performed by the stack on any packets with the\n\t * MARK_MAGIC_ENCRYPT bit set. During the process though we\n\t * lose the lxc context (seclabel and tunnel endpoint). The\n\t * tunnel endpoint can be looked up from daddr but the sec\n\t * label is stashed in the mark and extracted in bpf_host\n\t * to send ctx onto tunnel for encap.\n\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " __u32 tunnel_endpoint",
        " __u8 key",
        " __u32 seclabel"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int encap_and_redirect_ipsec (struct  __ctx_buff *ctx, __u32 tunnel_endpoint, __u8 key, __u32 seclabel)\n",
        "{\n",
        "    set_encrypt_key_mark (ctx, key);\n",
        "    set_identity_mark (ctx, seclabel);\n",
        "    ctx_store_meta (ctx, CB_ENCRYPT_DST, tunnel_endpoint);\n",
        "    return IPSEC_ENDPOINT;\n",
        "}\n"
      ],
      "called_function_list": [
        "set_encrypt_key_mark",
        "set_identity_mark",
        "ctx_store_meta"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "encap_remap_v6_host_address": [
    {
      "capabilities": [
        {
          "capability": "read_skb",
          "read_skb": [
            {
              "Project": "cilium",
              "Return Type": "s64",
              "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ",
              "Return": " The checksum result, or a negative error code in case of failure.",
              "Function Name": "csum_diff",
              "Input Params": [
                "{Type: __be32 ,Var: *from}",
                "{Type:  u32 ,Var: from_size}",
                "{Type:  __be32 ,Var: *to}",
                "{Type:  u32 ,Var: to_size}",
                "{Type:  __wsum ,Var: seed}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "xdp",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "lwt_seg6local"
              ],
              "capabilities": [
                "read_skb"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 60,
      "endLine": 117,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/encap.h",
      "funcName": "encap_remap_v6_host_address",
      "developer_inline_comments": [
        {
          "start_line": 82,
          "end_line": 86,
          "text": "/* For requests routed via tunnel with external v6 node IP\n\t * we need to remap their source address to the router address\n\t * as otherwise replies are not routed via tunnel but public\n\t * address instead.\n\t */"
        },
        {
          "start_line": 115,
          "end_line": 115,
          "text": "/* ENABLE_ENCAP_HOST_REMAP */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff * ctx __maybe_unused",
        " const bool egress __maybe_unused"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "csum_diff"
      ],
      "compatibleHookpoints": [
        "lwt_seg6local",
        "sched_act",
        "xdp",
        "lwt_xmit",
        "sched_cls",
        "lwt_in",
        "lwt_out"
      ],
      "source": [
        "static __always_inline int encap_remap_v6_host_address (struct  __ctx_buff * ctx __maybe_unused, const bool egress __maybe_unused)\n",
        "{\n",
        "\n",
        "#ifdef ENABLE_ENCAP_HOST_REMAP\n",
        "    struct csum_offset csum = {}\n",
        "    ;\n",
        "    union v6addr host_ip;\n",
        "    void *data, *data_end;\n",
        "    struct ipv6hdr *ip6;\n",
        "    union v6addr *which;\n",
        "    __u8 nexthdr;\n",
        "    __u16 proto;\n",
        "    __be32 sum;\n",
        "    __u32 noff;\n",
        "    __u64 off;\n",
        "    int ret;\n",
        "    validate_ethertype (ctx, &proto);\n",
        "    if (proto != bpf_htons (ETH_P_IPV6))\n",
        "        return 0;\n",
        "    if (!revalidate_data (ctx, &data, &data_end, &ip6))\n",
        "        return DROP_INVALID;\n",
        "    if (egress) {\n",
        "        BPF_V6 (host_ip, HOST_IP);\n",
        "        which = (union v6addr *) &ip6->saddr;\n",
        "    }\n",
        "    else {\n",
        "        BPF_V6 (host_ip, ROUTER_IP);\n",
        "        which = (union v6addr *) &ip6->daddr;\n",
        "    }\n",
        "    if (ipv6_addrcmp (which, &host_ip))\n",
        "        return 0;\n",
        "    nexthdr = ip6->nexthdr;\n",
        "    ret = ipv6_hdrlen (ctx, & nexthdr);\n",
        "    if (ret < 0)\n",
        "        return ret;\n",
        "    off = ((void *) ip6 - data) + ret;\n",
        "    if (egress) {\n",
        "        BPF_V6 (host_ip, ROUTER_IP);\n",
        "        noff = ETH_HLEN + offsetof (struct ipv6hdr, saddr);\n",
        "    }\n",
        "    else {\n",
        "        BPF_V6 (host_ip, HOST_IP);\n",
        "        noff = ETH_HLEN + offsetof (struct ipv6hdr, daddr);\n",
        "    }\n",
        "    sum = csum_diff (which, 16, & host_ip, 16, 0);\n",
        "    csum_l4_offset_and_flags (nexthdr, &csum);\n",
        "    if (ctx_store_bytes (ctx, noff, &host_ip, 16, 0) < 0)\n",
        "        return DROP_WRITE_ERROR;\n",
        "    if (csum.offset && csum_l4_replace (ctx, off, &csum, 0, sum, BPF_F_PSEUDO_HDR) < 0)\n",
        "        return DROP_CSUM_L4;\n",
        "\n",
        "#endif /* ENABLE_ENCAP_HOST_REMAP */\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "ipv6_hdrlen",
        "ipv6_addrcmp",
        "validate_ethertype",
        "csum_l4_replace",
        "csum_l4_offset_and_flags"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__encap_with_nodeid": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 119,
      "endLine": 154,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/encap.h",
      "funcName": "__encap_with_nodeid",
      "developer_inline_comments": [
        {
          "start_line": 128,
          "end_line": 131,
          "text": "/* When encapsulating, a packet originating from the local host is\n\t * being considered as a packet from a remote node as it is being\n\t * received.\n\t */"
        },
        {
          "start_line": 140,
          "end_line": 140,
          "text": "/* ENABLE_VTEP */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " __u32 tunnel_endpoint",
        " __u32 seclabel",
        " __u32 vni __maybe_unused",
        " enum trace_reason ct_reason",
        " __u32 monitor"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int __encap_with_nodeid (struct  __ctx_buff *ctx, __u32 tunnel_endpoint, __u32 seclabel, __u32 vni __maybe_unused, enum trace_reason ct_reason, __u32 monitor)\n",
        "{\n",
        "    struct bpf_tunnel_key key = {}\n",
        "    ;\n",
        "    __u32 node_id;\n",
        "    int ret;\n",
        "    if (seclabel == HOST_ID)\n",
        "        seclabel = LOCAL_NODE_ID;\n",
        "    node_id = bpf_htonl (tunnel_endpoint);\n",
        "\n",
        "#ifdef ENABLE_VTEP\n",
        "    if (vni != NOT_VTEP_DST)\n",
        "        key.tunnel_id = vni;\n",
        "    else\n",
        "\n",
        "#endif /* ENABLE_VTEP */\n",
        "        key.tunnel_id = seclabel;\n",
        "    key.remote_ipv4 = node_id;\n",
        "    key.tunnel_ttl = 64;\n",
        "    cilium_dbg (ctx, DBG_ENCAP, node_id, seclabel);\n",
        "    ret = ctx_set_tunnel_key (ctx, & key, sizeof (key), BPF_F_ZERO_CSUM_TX);\n",
        "    if (unlikely (ret < 0))\n",
        "        return DROP_WRITE_ERROR;\n",
        "    send_trace_notify (ctx, TRACE_TO_OVERLAY, seclabel, 0, 0, ENCAP_IFINDEX, ct_reason, monitor);\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "send_trace_notify",
        "cilium_dbg"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__encap_and_redirect_with_nodeid": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 156,
      "endLine": 167,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/encap.h",
      "funcName": "__encap_and_redirect_with_nodeid",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " __u32 tunnel_endpoint",
        " __u32 seclabel",
        " __u32 vni",
        " const struct trace_ctx *trace"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int __encap_and_redirect_with_nodeid (struct  __ctx_buff *ctx, __u32 tunnel_endpoint, __u32 seclabel, __u32 vni, const struct trace_ctx *trace)\n",
        "{\n",
        "    int ret = __encap_with_nodeid (ctx, tunnel_endpoint, seclabel, vni, trace -> reason, trace -> monitor);\n",
        "    if (ret != 0)\n",
        "        return ret;\n",
        "    return ctx_redirect (ctx, ENCAP_IFINDEX, 0);\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_redirect",
        "__encap_with_nodeid"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "encap_and_redirect_with_nodeid": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 174,
      "endLine": 185,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/encap.h",
      "funcName": "encap_and_redirect_with_nodeid",
      "developer_inline_comments": [
        {
          "start_line": 169,
          "end_line": 173,
          "text": "/* encap_and_redirect_with_nodeid returns IPSEC_ENDPOINT after ctx meta-data is\n * set when IPSec is enabled. Caller should pass the ctx to the stack at this\n * point. Otherwise returns CTX_ACT_TX on successful redirect to tunnel device.\n * On error returns CTX_ACT_DROP, DROP_NO_TUNNEL_ENDPOINT or DROP_WRITE_ERROR.\n */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " __u32 tunnel_endpoint",
        " __u8 key __maybe_unused",
        " __u32 seclabel",
        " const struct trace_ctx *trace"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int encap_and_redirect_with_nodeid (struct  __ctx_buff *ctx, __u32 tunnel_endpoint, __u8 key __maybe_unused, __u32 seclabel, const struct trace_ctx *trace)\n",
        "{\n",
        "\n",
        "#ifdef ENABLE_IPSEC\n",
        "    if (key)\n",
        "        return encap_and_redirect_nomark_ipsec (ctx, tunnel_endpoint, key, seclabel);\n",
        "\n",
        "#endif\n",
        "    return __encap_and_redirect_with_nodeid (ctx, tunnel_endpoint, seclabel, NOT_VTEP_DST, trace);\n",
        "}\n"
      ],
      "called_function_list": [
        "encap_and_redirect_nomark_ipsec",
        "__encap_and_redirect_with_nodeid"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "encap_and_redirect_lxc": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 197,
      "endLine": 242,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/encap.h",
      "funcName": "encap_and_redirect_lxc",
      "developer_inline_comments": [
        {
          "start_line": 187,
          "end_line": 196,
          "text": "/* encap_and_redirect based on ENABLE_IPSEC flag and from_host bool will decide\n * which version of code to call. With IPSec enabled and from_host set use the\n * IPSec branch which configures metadata for IPSec kernel stack. Otherwise\n * packet is redirected to output tunnel device and ctx will not be seen by\n * IP stack.\n *\n * Returns IPSEC_ENDPOINT when ctx needs to be handed to IP stack for IPSec\n * handling, CTX_ACT_DROP, DROP_NO_TUNNEL_ENDPOINT or DROP_WRITE_ERROR on error,\n * and finally on successful redirect returns CTX_ACT_TX.\n */"
        },
        {
          "start_line": 212,
          "end_line": 218,
          "text": "/* For IPSec and the host firewall, traffic from a pod to a remote node\n\t\t * is sent through the tunnel. In the case of node --> VIP@remote pod,\n\t\t * packets may be DNATed when they enter the remote node. If kube-proxy\n\t\t * is used, the response needs to go through the stack on the way to\n\t\t * the tunnel, to apply the correct reverse DNAT.\n\t\t * See #14674 for details.\n\t\t */"
        },
        {
          "start_line": 224,
          "end_line": 224,
          "text": "/* !ENABLE_NODEPORT && (ENABLE_IPSEC || ENABLE_HOST_FIREWALL) */"
        }
      ],
      "updateMaps": [],
      "readMaps": [
        "  TUNNEL_MAP"
      ],
      "input": [
        "struct  __ctx_buff *ctx",
        " __u32 tunnel_endpoint",
        " __u8 encrypt_key __maybe_unused",
        " struct endpoint_key *key",
        " __u32 seclabel",
        " const struct trace_ctx *trace"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int encap_and_redirect_lxc (struct  __ctx_buff *ctx, __u32 tunnel_endpoint, __u8 encrypt_key __maybe_unused, struct endpoint_key *key, __u32 seclabel, const struct trace_ctx *trace)\n",
        "{\n",
        "    struct endpoint_key *tunnel;\n",
        "    if (tunnel_endpoint) {\n",
        "\n",
        "#ifdef ENABLE_IPSEC\n",
        "        if (encrypt_key)\n",
        "            return encap_and_redirect_ipsec (ctx, tunnel_endpoint, encrypt_key, seclabel);\n",
        "\n",
        "#endif\n",
        "\n",
        "#if !defined(ENABLE_NODEPORT) && (defined(ENABLE_IPSEC) || defined(ENABLE_HOST_FIREWALL))\n",
        "        return __encap_with_nodeid (ctx, tunnel_endpoint, seclabel, NOT_VTEP_DST, trace->reason, trace->monitor);\n",
        "\n",
        "#else\n",
        "        return __encap_and_redirect_with_nodeid (ctx, tunnel_endpoint, seclabel, NOT_VTEP_DST, trace);\n",
        "\n",
        "#endif /* !ENABLE_NODEPORT && (ENABLE_IPSEC || ENABLE_HOST_FIREWALL) */\n",
        "    }\n",
        "    tunnel = map_lookup_elem (& TUNNEL_MAP, key);\n",
        "    if (!tunnel)\n",
        "        return DROP_NO_TUNNEL_ENDPOINT;\n",
        "\n",
        "#ifdef ENABLE_IPSEC\n",
        "    if (tunnel->key) {\n",
        "        __u8 min_encrypt_key = get_min_encrypt_key (tunnel -> key);\n",
        "        return encap_and_redirect_ipsec (ctx, tunnel->ip4, min_encrypt_key, seclabel);\n",
        "    }\n",
        "\n",
        "#endif\n",
        "    return __encap_and_redirect_with_nodeid (ctx, tunnel->ip4, seclabel, NOT_VTEP_DST, trace);\n",
        "}\n"
      ],
      "called_function_list": [
        "get_min_encrypt_key",
        "encap_and_redirect_ipsec",
        "__encap_with_nodeid",
        "__encap_and_redirect_with_nodeid"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "encap_and_redirect_netdev": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 244,
      "endLine": 264,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/encap.h",
      "funcName": "encap_and_redirect_netdev",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [
        "  TUNNEL_MAP"
      ],
      "input": [
        "struct  __ctx_buff *ctx",
        " struct endpoint_key *k",
        " __u32 seclabel",
        " const struct trace_ctx *trace"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int encap_and_redirect_netdev (struct  __ctx_buff *ctx, struct endpoint_key *k, __u32 seclabel, const struct trace_ctx *trace)\n",
        "{\n",
        "    struct endpoint_key *tunnel;\n",
        "    tunnel = map_lookup_elem (& TUNNEL_MAP, k);\n",
        "    if (!tunnel)\n",
        "        return DROP_NO_TUNNEL_ENDPOINT;\n",
        "\n",
        "#ifdef ENABLE_IPSEC\n",
        "    if (tunnel->key) {\n",
        "        __u8 key = get_min_encrypt_key (tunnel -> key);\n",
        "        return encap_and_redirect_nomark_ipsec (ctx, tunnel->ip4, key, seclabel);\n",
        "    }\n",
        "\n",
        "#endif\n",
        "    return __encap_and_redirect_with_nodeid (ctx, tunnel->ip4, seclabel, NOT_VTEP_DST, trace);\n",
        "}\n"
      ],
      "called_function_list": [
        "encap_and_redirect_nomark_ipsec",
        "get_min_encrypt_key",
        "__encap_and_redirect_with_nodeid"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "icmp6_load_type": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 43,
      "endLine": 49,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/icmp6.h",
      "funcName": "icmp6_load_type",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */"
        },
        {
          "start_line": 2,
          "end_line": 2,
          "text": "/* Copyright Authors of Cilium */"
        },
        {
          "start_line": 36,
          "end_line": 38,
          "text": "/* If no specific action is specified, drop unknown neighbour solicitation\n * messages.\n */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " int nh_off"
      ],
      "output": "static__always_inline__u8",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __u8 icmp6_load_type (struct  __ctx_buff *ctx, int nh_off)\n",
        "{\n",
        "    __u8 type;\n",
        "    ctx_load_bytes (ctx, nh_off + ICMP6_TYPE_OFFSET, &type, sizeof (type));\n",
        "    return type;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "icmp6_send_reply": [
    {
      "capabilities": [
        {
          "capability": "read_skb",
          "read_skb": [
            {
              "Project": "cilium",
              "Return Type": "s64",
              "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ",
              "Return": " The checksum result, or a negative error code in case of failure.",
              "Function Name": "csum_diff",
              "Input Params": [
                "{Type: __be32 ,Var: *from}",
                "{Type:  u32 ,Var: from_size}",
                "{Type:  __be32 ,Var: *to}",
                "{Type:  u32 ,Var: to_size}",
                "{Type:  __wsum ,Var: seed}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "xdp",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "lwt_seg6local"
              ],
              "capabilities": [
                "read_skb"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 51,
      "endLine": 90,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/icmp6.h",
      "funcName": "icmp6_send_reply",
      "developer_inline_comments": [
        {
          "start_line": 63,
          "end_line": 63,
          "text": "/* ctx->saddr = ctx->daddr */"
        },
        {
          "start_line": 66,
          "end_line": 66,
          "text": "/* ctx->daddr = ctx->saddr */"
        },
        {
          "start_line": 70,
          "end_line": 70,
          "text": "/* fixup checksums */"
        },
        {
          "start_line": 79,
          "end_line": 79,
          "text": "/* dmac = smac, smac = dmac */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " int nh_off"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "csum_diff",
        "redirect"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp",
        "lwt_xmit"
      ],
      "source": [
        "static __always_inline int icmp6_send_reply (struct  __ctx_buff *ctx, int nh_off)\n",
        "{\n",
        "    union macaddr smac, dmac = NODE_MAC;\n",
        "    const int csum_off = nh_off + ICMP6_CSUM_OFFSET;\n",
        "    union v6addr sip, dip, router_ip;\n",
        "    __be32 sum;\n",
        "    if (ipv6_load_saddr (ctx, nh_off, &sip) < 0 || ipv6_load_daddr (ctx, nh_off, &dip) < 0)\n",
        "        return DROP_INVALID;\n",
        "    BPF_V6 (router_ip, ROUTER_IP);\n",
        "    if (ipv6_store_saddr (ctx, router_ip.addr, nh_off) < 0)\n",
        "        return DROP_WRITE_ERROR;\n",
        "    if (ipv6_store_daddr (ctx, sip.addr, nh_off) < 0)\n",
        "        return DROP_WRITE_ERROR;\n",
        "    sum = csum_diff (sip.addr, 16, router_ip.addr, 16, 0);\n",
        "    if (l4_csum_replace (ctx, csum_off, 0, sum, BPF_F_PSEUDO_HDR) < 0)\n",
        "        return DROP_CSUM_L4;\n",
        "    sum = csum_diff (dip.addr, 16, sip.addr, 16, 0);\n",
        "    if (l4_csum_replace (ctx, csum_off, 0, sum, BPF_F_PSEUDO_HDR) < 0)\n",
        "        return DROP_CSUM_L4;\n",
        "    if (eth_load_saddr (ctx, smac.addr, 0) < 0)\n",
        "        return DROP_INVALID;\n",
        "    if (eth_store_daddr (ctx, smac.addr, 0) < 0 || eth_store_saddr (ctx, dmac.addr, 0) < 0)\n",
        "        return DROP_WRITE_ERROR;\n",
        "    cilium_dbg_capture (ctx, DBG_CAPTURE_DELIVERY, ctx_get_ifindex (ctx));\n",
        "    return redirect_self (ctx);\n",
        "}\n"
      ],
      "called_function_list": [
        "eth_load_saddr",
        "cilium_dbg_capture",
        "eth_store_daddr",
        "ipv6_store_saddr",
        "ipv6_store_daddr",
        "ctx_get_ifindex",
        "redirect_self",
        "ipv6_load_saddr",
        "ipv6_load_daddr",
        "eth_store_saddr"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__icmp6_send_echo_reply": [
    {
      "capabilities": [
        {
          "capability": "read_skb",
          "read_skb": [
            {
              "Project": "cilium",
              "Return Type": "s64",
              "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ",
              "Return": " The checksum result, or a negative error code in case of failure.",
              "Function Name": "csum_diff",
              "Input Params": [
                "{Type: __be32 ,Var: *from}",
                "{Type:  u32 ,Var: from_size}",
                "{Type:  __be32 ,Var: *to}",
                "{Type:  u32 ,Var: to_size}",
                "{Type:  __wsum ,Var: seed}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "xdp",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "lwt_seg6local"
              ],
              "capabilities": [
                "read_skb"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 92,
      "endLine": 125,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/icmp6.h",
      "funcName": "__icmp6_send_echo_reply",
      "developer_inline_comments": [
        {
          "start_line": 105,
          "end_line": 105,
          "text": "/* fill icmp6hdr */"
        },
        {
          "start_line": 117,
          "end_line": 117,
          "text": "/* fixup checksum */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " int nh_off"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "csum_diff"
      ],
      "compatibleHookpoints": [
        "lwt_seg6local",
        "sched_act",
        "xdp",
        "lwt_xmit",
        "sched_cls",
        "lwt_in",
        "lwt_out"
      ],
      "source": [
        "static __always_inline int __icmp6_send_echo_reply (struct  __ctx_buff *ctx, int nh_off)\n",
        "{\n",
        "    struct icmp6hdr icmp6hdr __align_stack_8 = {}, icmp6hdr_old  __align_stack_8;\n",
        "    int csum_off = nh_off + ICMP6_CSUM_OFFSET;\n",
        "    __be32 sum;\n",
        "    cilium_dbg (ctx, DBG_ICMP6_REQUEST, nh_off, 0);\n",
        "    if (ctx_load_bytes (ctx, nh_off + sizeof (struct ipv6hdr), &icmp6hdr_old, sizeof (icmp6hdr_old)) < 0)\n",
        "        return DROP_INVALID;\n",
        "    icmp6hdr.icmp6_type = 129;\n",
        "    icmp6hdr.icmp6_code = 0;\n",
        "    icmp6hdr.icmp6_cksum = icmp6hdr_old.icmp6_cksum;\n",
        "    icmp6hdr.icmp6_dataun.un_data32[0] = 0;\n",
        "    icmp6hdr.icmp6_identifier = icmp6hdr_old.icmp6_identifier;\n",
        "    icmp6hdr.icmp6_sequence = icmp6hdr_old.icmp6_sequence;\n",
        "    if (ctx_store_bytes (ctx, nh_off + sizeof (struct ipv6hdr), &icmp6hdr, sizeof (icmp6hdr), 0) < 0)\n",
        "        return DROP_WRITE_ERROR;\n",
        "    sum = csum_diff (& icmp6hdr_old, sizeof (icmp6hdr_old), & icmp6hdr, sizeof (icmp6hdr), 0);\n",
        "    if (l4_csum_replace (ctx, csum_off, 0, sum, BPF_F_PSEUDO_HDR) < 0)\n",
        "        return DROP_CSUM_L4;\n",
        "    return icmp6_send_reply (ctx, nh_off);\n",
        "}\n"
      ],
      "called_function_list": [
        "icmp6_send_reply",
        "cilium_dbg"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "tail_icmp6_send_echo_reply": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 129,
      "endLine": 139,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/icmp6.h",
      "funcName": "tail_icmp6_send_echo_reply",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "int",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "int tail_icmp6_send_echo_reply (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    int ret, nh_off = ctx_load_meta (ctx, 0);\n",
        "    enum metric_dir direction = (enum metric_dir) ctx_load_meta (ctx, 1);\n",
        "    ctx_store_meta (ctx, 0, 0);\n",
        "    ret = __icmp6_send_echo_reply (ctx, nh_off);\n",
        "    if (IS_ERR (ret))\n",
        "        return send_drop_notify_error (ctx, 0, ret, CTX_ACT_DROP, direction);\n",
        "    return ret;\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_store_meta",
        "ctx_load_meta",
        "__icmp6_send_echo_reply"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "icmp6_send_echo_reply": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 151,
      "endLine": 160,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/icmp6.h",
      "funcName": "icmp6_send_echo_reply",
      "developer_inline_comments": [
        {
          "start_line": 142,
          "end_line": 150,
          "text": "/*\n * icmp6_send_echo_reply\n * @ctx:\tsocket buffer\n * @nh_off:\toffset to the IPv6 header\n *\n * Send an ICMPv6 echo reply in return to an ICMPv6 echo reply.\n *\n * NOTE: This is terminal function and will cause the BPF program to exit\n */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " int nh_off",
        " enum metric_dir direction"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int icmp6_send_echo_reply (struct  __ctx_buff *ctx, int nh_off, enum metric_dir direction)\n",
        "{\n",
        "    ctx_store_meta (ctx, 0, nh_off);\n",
        "    ctx_store_meta (ctx, 1, direction);\n",
        "    ep_tail_call (ctx, CILIUM_CALL_SEND_ICMP6_ECHO_REPLY);\n",
        "    return DROP_MISSED_TAIL_CALL;\n",
        "}\n"
      ],
      "called_function_list": [
        "ep_tail_call",
        "ctx_store_meta"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "send_icmp6_ndisc_adv": [
    {
      "capabilities": [
        {
          "capability": "read_skb",
          "read_skb": [
            {
              "Project": "cilium",
              "Return Type": "s64",
              "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ",
              "Return": " The checksum result, or a negative error code in case of failure.",
              "Function Name": "csum_diff",
              "Input Params": [
                "{Type: __be32 ,Var: *from}",
                "{Type:  u32 ,Var: from_size}",
                "{Type:  __be32 ,Var: *to}",
                "{Type:  u32 ,Var: to_size}",
                "{Type:  __wsum ,Var: seed}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "xdp",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "lwt_seg6local"
              ],
              "capabilities": [
                "read_skb"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 171,
      "endLine": 232,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/icmp6.h",
      "funcName": "send_icmp6_ndisc_adv",
      "developer_inline_comments": [
        {
          "start_line": 162,
          "end_line": 170,
          "text": "/*\n * send_icmp6_ndisc_adv\n * @ctx:\tsocket buffer\n * @nh_off:\toffset to the IPv6 header\n * @mac:\tdevice mac address\n * @to_router:\tndisc is sent to router, otherwise ndisc is sent to an endpoint.\n *\n * Send an ICMPv6 nadv reply in return to an ICMPv6 ndisc.\n */"
        },
        {
          "start_line": 183,
          "end_line": 183,
          "text": "/* fill icmp6hdr */"
        },
        {
          "start_line": 203,
          "end_line": 203,
          "text": "/* fixup checksums */"
        },
        {
          "start_line": 209,
          "end_line": 209,
          "text": "/* get old options */"
        },
        {
          "start_line": 222,
          "end_line": 222,
          "text": "/* store ND_OPT_TARGET_LL_ADDR option */"
        },
        {
          "start_line": 226,
          "end_line": 226,
          "text": "/* fixup checksum */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " int nh_off",
        " union macaddr *mac",
        " bool to_router"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "csum_diff"
      ],
      "compatibleHookpoints": [
        "lwt_seg6local",
        "sched_act",
        "xdp",
        "lwt_xmit",
        "sched_cls",
        "lwt_in",
        "lwt_out"
      ],
      "source": [
        "static __always_inline int send_icmp6_ndisc_adv (struct  __ctx_buff *ctx, int nh_off, union macaddr *mac, bool to_router)\n",
        "{\n",
        "    struct icmp6hdr icmp6hdr __align_stack_8 = {}, icmp6hdr_old  __align_stack_8;\n",
        "    __u8 opts [8], opts_old [8];\n",
        "    const int csum_off = nh_off + ICMP6_CSUM_OFFSET;\n",
        "    __be32 sum;\n",
        "    if (ctx_load_bytes (ctx, nh_off + sizeof (struct ipv6hdr), &icmp6hdr_old, sizeof (icmp6hdr_old)) < 0)\n",
        "        return DROP_INVALID;\n",
        "    icmp6hdr.icmp6_type = 136;\n",
        "    icmp6hdr.icmp6_code = 0;\n",
        "    icmp6hdr.icmp6_cksum = icmp6hdr_old.icmp6_cksum;\n",
        "    icmp6hdr.icmp6_dataun.un_data32[0] = 0;\n",
        "    if (to_router) {\n",
        "        icmp6hdr.icmp6_router = 1;\n",
        "        icmp6hdr.icmp6_solicited = 1;\n",
        "        icmp6hdr.icmp6_override = 0;\n",
        "    }\n",
        "    else {\n",
        "        icmp6hdr.icmp6_router = 0;\n",
        "        icmp6hdr.icmp6_solicited = 1;\n",
        "        icmp6hdr.icmp6_override = 1;\n",
        "    }\n",
        "    if (ctx_store_bytes (ctx, nh_off + sizeof (struct ipv6hdr), &icmp6hdr, sizeof (icmp6hdr), 0) < 0)\n",
        "        return DROP_WRITE_ERROR;\n",
        "    sum = csum_diff (& icmp6hdr_old, sizeof (icmp6hdr_old), & icmp6hdr, sizeof (icmp6hdr), 0);\n",
        "    if (l4_csum_replace (ctx, csum_off, 0, sum, BPF_F_PSEUDO_HDR) < 0)\n",
        "        return DROP_CSUM_L4;\n",
        "    if (ctx_load_bytes (ctx, nh_off + ICMP6_ND_OPTS, opts_old, sizeof (opts_old)) < 0)\n",
        "        return DROP_INVALID;\n",
        "    opts[0] = 2;\n",
        "    opts[1] = 1;\n",
        "    opts[2] = mac->addr[0];\n",
        "    opts[3] = mac->addr[1];\n",
        "    opts[4] = mac->addr[2];\n",
        "    opts[5] = mac->addr[3];\n",
        "    opts[6] = mac->addr[4];\n",
        "    opts[7] = mac->addr[5];\n",
        "    if (ctx_store_bytes (ctx, nh_off + ICMP6_ND_OPTS, opts, sizeof (opts), 0) < 0)\n",
        "        return DROP_WRITE_ERROR;\n",
        "    sum = csum_diff (opts_old, sizeof (opts_old), opts, sizeof (opts), 0);\n",
        "    if (l4_csum_replace (ctx, csum_off, 0, sum, BPF_F_PSEUDO_HDR) < 0)\n",
        "        return DROP_CSUM_L4;\n",
        "    return icmp6_send_reply (ctx, nh_off);\n",
        "}\n"
      ],
      "called_function_list": [
        "icmp6_send_reply"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "compute_icmp6_csum": [
    {
      "capabilities": [
        {
          "capability": "read_skb",
          "read_skb": [
            {
              "Project": "cilium",
              "Return Type": "s64",
              "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ",
              "Return": " The checksum result, or a negative error code in case of failure.",
              "Function Name": "csum_diff",
              "Input Params": [
                "{Type: __be32 ,Var: *from}",
                "{Type:  u32 ,Var: from_size}",
                "{Type:  __be32 ,Var: *to}",
                "{Type:  u32 ,Var: to_size}",
                "{Type:  __wsum ,Var: seed}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "xdp",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "lwt_seg6local"
              ],
              "capabilities": [
                "read_skb"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 234,
      "endLine": 244,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/icmp6.h",
      "funcName": "compute_icmp6_csum",
      "developer_inline_comments": [
        {
          "start_line": 239,
          "end_line": 239,
          "text": "/* compute checksum with new payload length */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "char data [80]",
        " __u16 payload_len",
        " struct ipv6hdr *ipv6hdr"
      ],
      "output": "static__always_inline__be32",
      "helper": [
        "csum_diff"
      ],
      "compatibleHookpoints": [
        "lwt_seg6local",
        "sched_act",
        "xdp",
        "lwt_xmit",
        "sched_cls",
        "lwt_in",
        "lwt_out"
      ],
      "source": [
        "static __always_inline __be32 compute_icmp6_csum (char data [80], __u16 payload_len, struct ipv6hdr *ipv6hdr)\n",
        "{\n",
        "    __be32 sum;\n",
        "    sum = csum_diff (NULL, 0, data, payload_len, 0);\n",
        "    sum = ipv6_pseudohdr_checksum (ipv6hdr, IPPROTO_ICMPV6, payload_len, sum);\n",
        "    return sum;\n",
        "}\n"
      ],
      "called_function_list": [
        "ipv6_pseudohdr_checksum"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__icmp6_send_time_exceeded": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 247,
      "endLine": 327,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/icmp6.h",
      "funcName": "__icmp6_send_time_exceeded",
      "developer_inline_comments": [
        {
          "start_line": 250,
          "end_line": 250,
          "text": "/* FIXME: Fix code below to not require this init */"
        },
        {
          "start_line": 254,
          "end_line": 254,
          "text": "/* icmp6 or tcp or udp */"
        },
        {
          "start_line": 257,
          "end_line": 257,
          "text": "/* FIXME: Uninit of this causes verifier bug */"
        },
        {
          "start_line": 261,
          "end_line": 261,
          "text": "/* initialize pointers to offsets in data */"
        },
        {
          "start_line": 266,
          "end_line": 266,
          "text": "/* fill icmp6hdr */"
        },
        {
          "start_line": 274,
          "end_line": 274,
          "text": "/* read original v6 hdr into offset 8 */"
        },
        {
          "start_line": 281,
          "end_line": 281,
          "text": "/* read original v6 payload into offset 48 */"
        },
        {
          "start_line": 293,
          "end_line": 293,
          "text": "/* trim or expand buffer and copy data buffer after ipv6 header */"
        },
        {
          "start_line": 301,
          "end_line": 301,
          "text": "/* copy header without options */"
        },
        {
          "start_line": 308,
          "end_line": 308,
          "text": "/* trim or expand buffer and copy data buffer after ipv6 header */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " int nh_off"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int __icmp6_send_time_exceeded (struct  __ctx_buff *ctx, int nh_off)\n",
        "{\n",
        "    char data [80] = {};\n",
        "    struct icmp6hdr *icmp6hoplim;\n",
        "    struct ipv6hdr *ipv6hdr;\n",
        "    char *upper;\n",
        "    const int csum_off = nh_off + ICMP6_CSUM_OFFSET;\n",
        "    __be32 sum = 0;\n",
        "    __u16 payload_len = 0;\n",
        "    __u8 icmp6_nexthdr = IPPROTO_ICMPV6;\n",
        "    int trimlen;\n",
        "    icmp6hoplim = (struct icmp6hdr *) data;\n",
        "    ipv6hdr = (struct ipv6hdr *) (data + 8);\n",
        "    upper = (data + 48);\n",
        "    icmp6hoplim->icmp6_type = 3;\n",
        "    icmp6hoplim->icmp6_code = 0;\n",
        "    icmp6hoplim->icmp6_cksum = 0;\n",
        "    icmp6hoplim->icmp6_dataun.un_data32[0] = 0;\n",
        "    cilium_dbg (ctx, DBG_ICMP6_TIME_EXCEEDED, 0, 0);\n",
        "    if (ctx_load_bytes (ctx, nh_off, ipv6hdr, sizeof (*ipv6hdr)) < 0)\n",
        "        return DROP_INVALID;\n",
        "    if (ipv6_store_nexthdr (ctx, &icmp6_nexthdr, nh_off) < 0)\n",
        "        return DROP_WRITE_ERROR;\n",
        "    switch (ipv6hdr->nexthdr) {\n",
        "    case IPPROTO_ICMPV6 :\n",
        "    case IPPROTO_UDP :\n",
        "        if (ctx_load_bytes (ctx, nh_off + sizeof (struct ipv6hdr), upper, 8) < 0)\n",
        "            return DROP_INVALID;\n",
        "        sum = compute_icmp6_csum (data, 56, ipv6hdr);\n",
        "        payload_len = bpf_htons (56);\n",
        "        trimlen = 56 - bpf_ntohs (ipv6hdr->payload_len);\n",
        "        if (ctx_change_tail (ctx, ctx_full_len (ctx) + trimlen, 0) < 0)\n",
        "            return DROP_WRITE_ERROR;\n",
        "        if (ctx_store_bytes (ctx, nh_off + sizeof (struct ipv6hdr), data, 56, 0) < 0)\n",
        "            return DROP_WRITE_ERROR;\n",
        "        if (ipv6_store_paylen (ctx, nh_off, &payload_len) < 0)\n",
        "            return DROP_WRITE_ERROR;\n",
        "        break;\n",
        "    case IPPROTO_TCP :\n",
        "        if (ctx_load_bytes (ctx, nh_off + sizeof (struct ipv6hdr), upper, 20) < 0)\n",
        "            return DROP_INVALID;\n",
        "        sum = compute_icmp6_csum (data, 68, ipv6hdr);\n",
        "        payload_len = bpf_htons (68);\n",
        "        trimlen = 68 - bpf_ntohs (ipv6hdr->payload_len);\n",
        "        if (ctx_change_tail (ctx, ctx_full_len (ctx) + trimlen, 0) < 0)\n",
        "            return DROP_WRITE_ERROR;\n",
        "        if (ctx_store_bytes (ctx, nh_off + sizeof (struct ipv6hdr), data, 68, 0) < 0)\n",
        "            return DROP_WRITE_ERROR;\n",
        "        if (ipv6_store_paylen (ctx, nh_off, &payload_len) < 0)\n",
        "            return DROP_WRITE_ERROR;\n",
        "        break;\n",
        "    default :\n",
        "        return DROP_UNKNOWN_L4;\n",
        "    }\n",
        "    if (l4_csum_replace (ctx, csum_off, 0, sum, BPF_F_PSEUDO_HDR) < 0)\n",
        "        return DROP_CSUM_L4;\n",
        "    return icmp6_send_reply (ctx, nh_off);\n",
        "}\n"
      ],
      "called_function_list": [
        "compute_icmp6_csum",
        "ipv6_store_paylen",
        "icmp6_send_reply",
        "ipv6_store_nexthdr",
        "ctx_full_len",
        "cilium_dbg"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "tail_icmp6_send_time_exceeded": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 332,
      "endLine": 347,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/icmp6.h",
      "funcName": "tail_icmp6_send_time_exceeded",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff * ctx __maybe_unused"
      ],
      "output": "int",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "int tail_icmp6_send_time_exceeded (struct  __ctx_buff * ctx __maybe_unused)\n",
        "{\n",
        "\n",
        "# ifdef BPF_HAVE_CHANGE_TAIL\n",
        "    int ret, nh_off = ctx_load_meta (ctx, 0);\n",
        "    enum metric_dir direction = (enum metric_dir) ctx_load_meta (ctx, 1);\n",
        "    ctx_store_meta (ctx, 0, 0);\n",
        "    ret = __icmp6_send_time_exceeded (ctx, nh_off);\n",
        "    if (IS_ERR (ret))\n",
        "        return send_drop_notify_error (ctx, 0, ret, CTX_ACT_DROP, direction);\n",
        "    return ret;\n",
        "\n",
        "# else\n",
        "    return 0;\n",
        "\n",
        "# endif\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_store_meta",
        "ctx_load_meta",
        "__icmp6_send_time_exceeded"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "icmp6_send_time_exceeded": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 359,
      "endLine": 368,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/icmp6.h",
      "funcName": "icmp6_send_time_exceeded",
      "developer_inline_comments": [
        {
          "start_line": 350,
          "end_line": 358,
          "text": "/*\n * icmp6_send_time_exceeded\n * @ctx:\tsocket buffer\n * @nh_off:\toffset to the IPv6 header\n * @direction:  direction of packet (can be ingress or egress)\n * Send a ICMPv6 time exceeded in response to an IPv6 frame.\n *\n * NOTE: This is terminal function and will cause the BPF program to exit\n */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " int nh_off",
        " enum metric_dir direction"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int icmp6_send_time_exceeded (struct  __ctx_buff *ctx, int nh_off, enum metric_dir direction)\n",
        "{\n",
        "    ctx_store_meta (ctx, 0, nh_off);\n",
        "    ctx_store_meta (ctx, 1, direction);\n",
        "    ep_tail_call (ctx, CILIUM_CALL_SEND_ICMP6_TIME_EXCEEDED);\n",
        "    return DROP_MISSED_TAIL_CALL;\n",
        "}\n"
      ],
      "called_function_list": [
        "ep_tail_call",
        "ctx_store_meta"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__icmp6_handle_ns": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 370,
      "endLine": 398,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/icmp6.h",
      "funcName": "__icmp6_handle_ns",
      "developer_inline_comments": [
        {
          "start_line": 396,
          "end_line": 396,
          "text": "/* Unknown target address, drop */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " int nh_off"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int __icmp6_handle_ns (struct  __ctx_buff *ctx, int nh_off)\n",
        "{\n",
        "    union v6addr target, router;\n",
        "    struct endpoint_info *ep;\n",
        "    if (ctx_load_bytes (ctx, nh_off + ICMP6_ND_TARGET_OFFSET, target.addr, sizeof (((struct ipv6hdr *) NULL)->saddr)) < 0)\n",
        "        return DROP_INVALID;\n",
        "    cilium_dbg (ctx, DBG_ICMP6_NS, target.p3, target.p4);\n",
        "    BPF_V6 (router, ROUTER_IP);\n",
        "    if (ipv6_addrcmp (&target, &router) == 0) {\n",
        "        union macaddr router_mac = NODE_MAC;\n",
        "        return send_icmp6_ndisc_adv (ctx, nh_off, &router_mac, true);\n",
        "    }\n",
        "    ep = __lookup_ip6_endpoint (& target);\n",
        "    if (ep) {\n",
        "        union macaddr router_mac = NODE_MAC;\n",
        "        return send_icmp6_ndisc_adv (ctx, nh_off, &router_mac, false);\n",
        "    }\n",
        "    return ACTION_UNKNOWN_ICMP6_NS;\n",
        "}\n"
      ],
      "called_function_list": [
        "ipv6_addrcmp",
        "__lookup_ip6_endpoint",
        "send_icmp6_ndisc_adv",
        "cilium_dbg"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "tail_icmp6_handle_ns": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 402,
      "endLine": 412,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/icmp6.h",
      "funcName": "tail_icmp6_handle_ns",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx"
      ],
      "output": "int",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "int tail_icmp6_handle_ns (struct  __ctx_buff *ctx)\n",
        "{\n",
        "    int ret, nh_off = ctx_load_meta (ctx, 0);\n",
        "    enum metric_dir direction = (enum metric_dir) ctx_load_meta (ctx, 1);\n",
        "    ctx_store_meta (ctx, 0, 0);\n",
        "    ret = __icmp6_handle_ns (ctx, nh_off);\n",
        "    if (IS_ERR (ret))\n",
        "        return send_drop_notify_error (ctx, 0, ret, CTX_ACT_DROP, direction);\n",
        "    return ret;\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_store_meta",
        "ctx_load_meta",
        "__icmp6_handle_ns"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "icmp6_handle_ns": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 425,
      "endLine": 434,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/icmp6.h",
      "funcName": "icmp6_handle_ns",
      "developer_inline_comments": [
        {
          "start_line": 415,
          "end_line": 424,
          "text": "/*\n * icmp6_handle_ns\n * @ctx:\tsocket buffer\n * @nh_off:\toffset to the IPv6 header\n * @direction:  direction of packet(ingress or egress)\n *\n * Respond to ICMPv6 Neighbour Solicitation\n *\n * NOTE: This is terminal function and will cause the BPF program to exit\n */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " int nh_off",
        " enum metric_dir direction"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int icmp6_handle_ns (struct  __ctx_buff *ctx, int nh_off, enum metric_dir direction)\n",
        "{\n",
        "    ctx_store_meta (ctx, 0, nh_off);\n",
        "    ctx_store_meta (ctx, 1, direction);\n",
        "    ep_tail_call (ctx, CILIUM_CALL_HANDLE_ICMP6_NS);\n",
        "    return DROP_MISSED_TAIL_CALL;\n",
        "}\n"
      ],
      "called_function_list": [
        "ep_tail_call",
        "ctx_store_meta"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "icmp6_handle": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 436,
      "endLine": 458,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/icmp6.h",
      "funcName": "icmp6_handle",
      "developer_inline_comments": [
        {
          "start_line": 454,
          "end_line": 456,
          "text": "/* All branching above will have issued a tail call, all\n\t * remaining traffic is subject to forwarding to containers.\n\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " int nh_off",
        " struct ipv6hdr *ip6",
        " enum metric_dir direction"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int icmp6_handle (struct  __ctx_buff *ctx, int nh_off, struct ipv6hdr *ip6, enum metric_dir direction)\n",
        "{\n",
        "    union v6addr router_ip;\n",
        "    __u8 type = icmp6_load_type (ctx, nh_off);\n",
        "    cilium_dbg (ctx, DBG_ICMP6_HANDLE, type, 0);\n",
        "    BPF_V6 (router_ip, ROUTER_IP);\n",
        "    switch (type) {\n",
        "    case ICMP6_NS_MSG_TYPE :\n",
        "        return icmp6_handle_ns (ctx, nh_off, direction);\n",
        "    case ICMPV6_ECHO_REQUEST :\n",
        "        if (!ipv6_addrcmp ((union v6addr *) &ip6->daddr, &router_ip))\n",
        "            return icmp6_send_echo_reply (ctx, nh_off, direction);\n",
        "        break;\n",
        "    }\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "icmp6_send_echo_reply",
        "icmp6_load_type",
        "ipv6_addrcmp",
        "icmp6_handle_ns",
        "cilium_dbg"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "icmp6_host_handle": [
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 460,
      "endLine": 531,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/icmp6.h",
      "funcName": "icmp6_host_handle",
      "developer_inline_comments": [
        {
          "start_line": 470,
          "end_line": 515,
          "text": "/* When the host firewall is enabled, we drop and allow ICMPv6 messages\n\t * according to RFC4890, except for echo request and reply messages which\n\t * are handled by host policies and can be dropped.\n\t * |          ICMPv6 Message         |     Action      | Type |\n\t * |---------------------------------|-----------------|------|\n\t * |          ICMPv6-unreach         |   CTX_ACT_OK    |   1  |\n\t * |          ICMPv6-too-big         |   CTX_ACT_OK    |   2  |\n\t * |           ICMPv6-timed          |   CTX_ACT_OK    |   3  |\n\t * |         ICMPv6-parameter        |   CTX_ACT_OK    |   4  |\n\t * |    ICMPv6-err-private-exp-100   |  CTX_ACT_DROP   |  100 |\n\t * |    ICMPv6-err-private-exp-101   |  CTX_ACT_DROP   |  101 |\n\t * |       ICMPv6-err-expansion      |  CTX_ACT_DROP   |  127 |\n\t * |       ICMPv6-echo-message       |    Firewall     |  128 |\n\t * |        ICMPv6-echo-reply        |    Firewall     |  129 |\n\t * |      ICMPv6-mult-list-query     |   CTX_ACT_OK    |  130 |\n\t * |      ICMPv6-mult-list-report    |   CTX_ACT_OK    |  131 |\n\t * |      ICMPv6-mult-list-done      |   CTX_ACT_OK    |  132 |\n\t * |      ICMPv6-router-solici       |   CTX_ACT_OK    |  133 |\n\t * |      ICMPv6-router-advert       |   CTX_ACT_OK    |  134 |\n\t * |     ICMPv6-neighbor-solicit     | icmp6_handle_ns |  135 |\n\t * |      ICMPv6-neighbor-advert     |   CTX_ACT_OK    |  136 |\n\t * |     ICMPv6-redirect-message     |  CTX_ACT_DROP   |  137 |\n\t * |      ICMPv6-router-renumber     |   CTX_ACT_OK    |  138 |\n\t * |      ICMPv6-node-info-query     |  CTX_ACT_DROP   |  139 |\n\t * |     ICMPv6-node-info-response   |  CTX_ACT_DROP   |  140 |\n\t * |   ICMPv6-inv-neighbor-solicit   |   CTX_ACT_OK    |  141 |\n\t * |    ICMPv6-inv-neighbor-advert   |   CTX_ACT_OK    |  142 |\n\t * |    ICMPv6-mult-list-report-v2   |   CTX_ACT_OK    |  143 |\n\t * | ICMPv6-home-agent-disco-request |  CTX_ACT_DROP   |  144 |\n\t * |  ICMPv6-home-agent-disco-reply  |  CTX_ACT_DROP   |  145 |\n\t * |      ICMPv6-mobile-solicit      |  CTX_ACT_DROP   |  146 |\n\t * |      ICMPv6-mobile-advert       |  CTX_ACT_DROP   |  147 |\n\t * |      ICMPv6-send-solicit        |   CTX_ACT_OK    |  148 |\n\t * |       ICMPv6-send-advert        |   CTX_ACT_OK    |  149 |\n\t * |       ICMPv6-mobile-exp         |  CTX_ACT_DROP   |  150 |\n\t * |    ICMPv6-mult-router-advert    |   CTX_ACT_OK    |  151 |\n\t * |    ICMPv6-mult-router-solicit   |   CTX_ACT_OK    |  152 |\n\t * |     ICMPv6-mult-router-term     |   CTX_ACT_OK    |  153 |\n\t * |         ICMPv6-FMIPv6           |  CTX_ACT_DROP   |  154 |\n\t * |       ICMPv6-rpl-control        |  CTX_ACT_DROP   |  155 |\n\t * |   ICMPv6-info-private-exp-200   |  CTX_ACT_DROP   |  200 |\n\t * |   ICMPv6-info-private-exp-201   |  CTX_ACT_DROP   |  201 |\n\t * |      ICMPv6-info-expansion      |  CTX_ACT_DROP   |  255 |\n\t * |       ICMPv6-unallocated        |  CTX_ACT_DROP   |      |\n\t * |       ICMPv6-unassigned         |  CTX_ACT_DROP   |      |\n\t */"
        },
        {
          "start_line": 518,
          "end_line": 518,
          "text": "/* Decision is deferred to the host policies. */"
        },
        {
          "start_line": 530,
          "end_line": 530,
          "text": "/* ENABLE_HOST_FIREWALL */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff * ctx __maybe_unused"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "CTX_ACT_OK"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "static __always_inline int icmp6_host_handle (struct  __ctx_buff * ctx __maybe_unused)\n",
        "{\n",
        "    __u8 type __maybe_unused;\n",
        "    type = icmp6_load_type (ctx, ETH_HLEN);\n",
        "    if (type == ICMP6_NS_MSG_TYPE)\n",
        "        return icmp6_handle_ns (ctx, ETH_HLEN, METRIC_INGRESS);\n",
        "\n",
        "#ifdef ENABLE_HOST_FIREWALL\n",
        "    if (type == ICMP6_ECHO_REQUEST_MSG_TYPE || type == ICMP6_ECHO_REPLY_MSG_TYPE)\n",
        "        return CTX_ACT_OK;\n",
        "    if ((ICMP6_UNREACH_MSG_TYPE <= type && type <= ICMP6_PARAM_ERR_MSG_TYPE) || (ICMP6_MULT_LIST_QUERY_TYPE <= type && type <= ICMP6_NA_MSG_TYPE) || (ICMP6_INV_NS_MSG_TYPE <= type && type <= ICMP6_MULT_LIST_REPORT_V2_TYPE) || (ICMP6_SEND_NS_MSG_TYPE <= type && type <= ICMP6_SEND_NA_MSG_TYPE) || (ICMP6_MULT_RA_MSG_TYPE <= type && type <= ICMP6_MULT_RT_MSG_TYPE))\n",
        "        return SKIP_HOST_FIREWALL;\n",
        "    return DROP_FORBIDDEN_ICMP6;\n",
        "\n",
        "#else\n",
        "    return CTX_ACT_OK;\n",
        "\n",
        "#endif /* ENABLE_HOST_FIREWALL */\n",
        "}\n"
      ],
      "called_function_list": [
        "icmp6_handle_ns",
        "icmp6_load_type"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "lb4_svc_is_loadbalancer": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 192,
      "endLine": 196,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "lb4_svc_is_loadbalancer",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */"
        },
        {
          "start_line": 2,
          "end_line": 2,
          "text": "/* Copyright Authors of Cilium */"
        },
        {
          "start_line": 81,
          "end_line": 81,
          "text": "/* Maglev inner map definition */"
        },
        {
          "start_line": 89,
          "end_line": 89,
          "text": "/* LB_SELECTION == LB_SELECTION_MAGLEV */"
        },
        {
          "start_line": 90,
          "end_line": 90,
          "text": "/* ENABLE_IPV6 */"
        },
        {
          "start_line": 159,
          "end_line": 159,
          "text": "/* Maglev inner map definition */"
        },
        {
          "start_line": 167,
          "end_line": 167,
          "text": "/* LB_SELECTION == LB_SELECTION_MAGLEV */"
        },
        {
          "start_line": 168,
          "end_line": 168,
          "text": "/* ENABLE_IPV4 */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct lb4_service * svc __maybe_unused"
      ],
      "output": "static__always_inlinebool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline bool lb4_svc_is_loadbalancer (const struct lb4_service * svc __maybe_unused)\n",
        "{\n",
        "    return svc->flags & SVC_FLAG_LOADBALANCER;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "lb6_svc_is_loadbalancer": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 198,
      "endLine": 202,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "lb6_svc_is_loadbalancer",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct lb6_service * svc __maybe_unused"
      ],
      "output": "static__always_inlinebool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline bool lb6_svc_is_loadbalancer (const struct lb6_service * svc __maybe_unused)\n",
        "{\n",
        "    return svc->flags & SVC_FLAG_LOADBALANCER;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "lb4_svc_is_nodeport": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 204,
      "endLine": 212,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "lb4_svc_is_nodeport",
      "developer_inline_comments": [
        {
          "start_line": 211,
          "end_line": 211,
          "text": "/* ENABLE_NODEPORT */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct lb4_service * svc __maybe_unused"
      ],
      "output": "static__always_inlinebool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline bool lb4_svc_is_nodeport (const struct lb4_service * svc __maybe_unused)\n",
        "{\n",
        "\n",
        "#ifdef ENABLE_NODEPORT\n",
        "    return svc->flags & SVC_FLAG_NODEPORT;\n",
        "\n",
        "#else\n",
        "    return false;\n",
        "\n",
        "#endif /* ENABLE_NODEPORT */\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "lb6_svc_is_nodeport": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 214,
      "endLine": 222,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "lb6_svc_is_nodeport",
      "developer_inline_comments": [
        {
          "start_line": 221,
          "end_line": 221,
          "text": "/* ENABLE_NODEPORT */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct lb6_service * svc __maybe_unused"
      ],
      "output": "static__always_inlinebool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline bool lb6_svc_is_nodeport (const struct lb6_service * svc __maybe_unused)\n",
        "{\n",
        "\n",
        "#ifdef ENABLE_NODEPORT\n",
        "    return svc->flags & SVC_FLAG_NODEPORT;\n",
        "\n",
        "#else\n",
        "    return false;\n",
        "\n",
        "#endif /* ENABLE_NODEPORT */\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "lb4_svc_is_external_ip": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 224,
      "endLine": 228,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "lb4_svc_is_external_ip",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct lb4_service * svc __maybe_unused"
      ],
      "output": "static__always_inlinebool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline bool lb4_svc_is_external_ip (const struct lb4_service * svc __maybe_unused)\n",
        "{\n",
        "    return svc->flags & SVC_FLAG_EXTERNAL_IP;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "lb6_svc_is_external_ip": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 230,
      "endLine": 234,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "lb6_svc_is_external_ip",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct lb6_service * svc __maybe_unused"
      ],
      "output": "static__always_inlinebool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline bool lb6_svc_is_external_ip (const struct lb6_service * svc __maybe_unused)\n",
        "{\n",
        "    return svc->flags & SVC_FLAG_EXTERNAL_IP;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "lb4_svc_is_hostport": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 236,
      "endLine": 240,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "lb4_svc_is_hostport",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct lb4_service * svc __maybe_unused"
      ],
      "output": "static__always_inlinebool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline bool lb4_svc_is_hostport (const struct lb4_service * svc __maybe_unused)\n",
        "{\n",
        "    return svc->flags & SVC_FLAG_HOSTPORT;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "lb6_svc_is_hostport": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 242,
      "endLine": 246,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "lb6_svc_is_hostport",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct lb6_service * svc __maybe_unused"
      ],
      "output": "static__always_inlinebool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline bool lb6_svc_is_hostport (const struct lb6_service * svc __maybe_unused)\n",
        "{\n",
        "    return svc->flags & SVC_FLAG_HOSTPORT;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "lb4_svc_has_src_range_check": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 248,
      "endLine": 256,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "lb4_svc_has_src_range_check",
      "developer_inline_comments": [
        {
          "start_line": 255,
          "end_line": 255,
          "text": "/* ENABLE_SRC_RANGE_CHECK */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct lb4_service * svc __maybe_unused"
      ],
      "output": "static__always_inlinebool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline bool lb4_svc_has_src_range_check (const struct lb4_service * svc __maybe_unused)\n",
        "{\n",
        "\n",
        "#ifdef ENABLE_SRC_RANGE_CHECK\n",
        "    return svc->flags & SVC_FLAG_SOURCE_RANGE;\n",
        "\n",
        "#else\n",
        "    return false;\n",
        "\n",
        "#endif /* ENABLE_SRC_RANGE_CHECK */\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "lb6_svc_has_src_range_check": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 258,
      "endLine": 266,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "lb6_svc_has_src_range_check",
      "developer_inline_comments": [
        {
          "start_line": 265,
          "end_line": 265,
          "text": "/* ENABLE_SRC_RANGE_CHECK */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct lb6_service * svc __maybe_unused"
      ],
      "output": "static__always_inlinebool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline bool lb6_svc_has_src_range_check (const struct lb6_service * svc __maybe_unused)\n",
        "{\n",
        "\n",
        "#ifdef ENABLE_SRC_RANGE_CHECK\n",
        "    return svc->flags & SVC_FLAG_SOURCE_RANGE;\n",
        "\n",
        "#else\n",
        "    return false;\n",
        "\n",
        "#endif /* ENABLE_SRC_RANGE_CHECK */\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "lb_skip_l4_dnat": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 268,
      "endLine": 271,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "lb_skip_l4_dnat",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void"
      ],
      "output": "static__always_inlinebool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline bool lb_skip_l4_dnat (void)\n",
        "{\n",
        "    return DSR_XLATE_MODE == DSR_XLATE_FRONTEND;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "lb4_svc_is_local_scope": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 273,
      "endLine": 277,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "lb4_svc_is_local_scope",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct lb4_service *svc"
      ],
      "output": "static__always_inlinebool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline bool lb4_svc_is_local_scope (const struct lb4_service *svc)\n",
        "{\n",
        "    return svc->flags & SVC_FLAG_LOCAL_SCOPE;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "lb6_svc_is_local_scope": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 279,
      "endLine": 283,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "lb6_svc_is_local_scope",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct lb6_service *svc"
      ],
      "output": "static__always_inlinebool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline bool lb6_svc_is_local_scope (const struct lb6_service *svc)\n",
        "{\n",
        "    return svc->flags & SVC_FLAG_LOCAL_SCOPE;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "lb4_svc_is_affinity": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 285,
      "endLine": 289,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "lb4_svc_is_affinity",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct lb4_service *svc"
      ],
      "output": "static__always_inlinebool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline bool lb4_svc_is_affinity (const struct lb4_service *svc)\n",
        "{\n",
        "    return svc->flags & SVC_FLAG_AFFINITY;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "lb6_svc_is_affinity": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 291,
      "endLine": 295,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "lb6_svc_is_affinity",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct lb6_service *svc"
      ],
      "output": "static__always_inlinebool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline bool lb6_svc_is_affinity (const struct lb6_service *svc)\n",
        "{\n",
        "    return svc->flags & SVC_FLAG_AFFINITY;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__lb_svc_is_routable": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 297,
      "endLine": 300,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "__lb_svc_is_routable",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "__u8 flags"
      ],
      "output": "static__always_inlinebool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline bool __lb_svc_is_routable (__u8 flags)\n",
        "{\n",
        "    return (flags & SVC_FLAG_ROUTABLE) != 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "lb4_svc_is_routable": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 302,
      "endLine": 306,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "lb4_svc_is_routable",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct lb4_service *svc"
      ],
      "output": "static__always_inlinebool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline bool lb4_svc_is_routable (const struct lb4_service *svc)\n",
        "{\n",
        "    return __lb_svc_is_routable (svc->flags);\n",
        "}\n"
      ],
      "called_function_list": [
        "__lb_svc_is_routable"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "lb6_svc_is_routable": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 308,
      "endLine": 312,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "lb6_svc_is_routable",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct lb6_service *svc"
      ],
      "output": "static__always_inlinebool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline bool lb6_svc_is_routable (const struct lb6_service *svc)\n",
        "{\n",
        "    return __lb_svc_is_routable (svc->flags);\n",
        "}\n"
      ],
      "called_function_list": [
        "__lb_svc_is_routable"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "lb4_svc_is_localredirect": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 314,
      "endLine": 318,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "lb4_svc_is_localredirect",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct lb4_service *svc"
      ],
      "output": "static__always_inlinebool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline bool lb4_svc_is_localredirect (const struct lb4_service *svc)\n",
        "{\n",
        "    return svc->flags2 & SVC_FLAG_LOCALREDIRECT;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "lb4_svc_is_l7loadbalancer": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 320,
      "endLine": 328,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "lb4_svc_is_l7loadbalancer",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct lb4_service * svc __maybe_unused"
      ],
      "output": "static__always_inlinebool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline bool lb4_svc_is_l7loadbalancer (const struct lb4_service * svc __maybe_unused)\n",
        "{\n",
        "\n",
        "#ifdef ENABLE_L7_LB\n",
        "    return svc->flags2 & SVC_FLAG_L7LOADBALANCER;\n",
        "\n",
        "#else\n",
        "    return false;\n",
        "\n",
        "#endif\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "lb6_svc_is_l7loadbalancer": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 330,
      "endLine": 338,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "lb6_svc_is_l7loadbalancer",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct lb6_service * svc __maybe_unused"
      ],
      "output": "static__always_inlinebool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline bool lb6_svc_is_l7loadbalancer (const struct lb6_service * svc __maybe_unused)\n",
        "{\n",
        "\n",
        "#ifdef ENABLE_L7_LB\n",
        "    return svc->flags2 & SVC_FLAG_L7LOADBALANCER;\n",
        "\n",
        "#else\n",
        "    return false;\n",
        "\n",
        "#endif\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "extract_l4_port": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 340,
      "endLine": 380,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "extract_l4_port",
      "developer_inline_comments": [
        {
          "start_line": 363,
          "end_line": 363,
          "text": "/* Port offsets for UDP and TCP are the same */"
        },
        {
          "start_line": 371,
          "end_line": 371,
          "text": "/* No need to perform a service lookup for ICMP packets */"
        },
        {
          "start_line": 375,
          "end_line": 375,
          "text": "/* Pass unknown L4 to stack */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " __u8 nexthdr",
        " int l4_off",
        " enum ct_dir dir __maybe_unused",
        " __be16 *port",
        " __maybe_unused struct iphdr *ip4"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int extract_l4_port (struct  __ctx_buff *ctx, __u8 nexthdr, int l4_off, enum ct_dir dir __maybe_unused, __be16 *port, __maybe_unused struct iphdr *ip4)\n",
        "{\n",
        "    int ret;\n",
        "    switch (nexthdr) {\n",
        "    case IPPROTO_TCP :\n",
        "    case IPPROTO_UDP :\n",
        "\n",
        "#ifdef ENABLE_IPV4_FRAGMENTS\n",
        "        if (ip4) {\n",
        "            struct ipv4_frag_l4ports ports = {}\n",
        "            ;\n",
        "            ret = ipv4_handle_fragmentation (ctx, ip4, l4_off, dir, & ports, NULL);\n",
        "            if (IS_ERR (ret))\n",
        "                return ret;\n",
        "            *port = ports.dport;\n",
        "            break;\n",
        "        }\n",
        "\n",
        "#endif\n",
        "        ret = l4_load_port (ctx, l4_off + TCP_DPORT_OFF, port);\n",
        "        if (IS_ERR (ret))\n",
        "            return ret;\n",
        "        break;\n",
        "    case IPPROTO_ICMPV6 :\n",
        "    case IPPROTO_ICMP :\n",
        "        return DROP_NO_SERVICE;\n",
        "    default :\n",
        "        return DROP_UNKNOWN_L4;\n",
        "    }\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "l4_load_port",
        "ipv4_handle_fragmentation"
      ],
      "call_depth": 5,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "reverse_map_l4_port": [
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 382,
      "endLine": 416,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "reverse_map_l4_port",
      "developer_inline_comments": [
        {
          "start_line": 393,
          "end_line": 393,
          "text": "/* Port offsets for UDP and TCP are the same */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " __u8 nexthdr",
        " __be16 port",
        " int l4_off",
        " struct csum_offset *csum_off"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "CTX_ACT_OK"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "static __always_inline int reverse_map_l4_port (struct  __ctx_buff *ctx, __u8 nexthdr, __be16 port, int l4_off, struct csum_offset *csum_off)\n",
        "{\n",
        "    switch (nexthdr) {\n",
        "    case IPPROTO_TCP :\n",
        "    case IPPROTO_UDP :\n",
        "        if (port) {\n",
        "            __be16 old_port;\n",
        "            int ret;\n",
        "            ret = l4_load_port (ctx, l4_off + TCP_SPORT_OFF, & old_port);\n",
        "            if (IS_ERR (ret))\n",
        "                return ret;\n",
        "            if (port != old_port) {\n",
        "                ret = l4_modify_port (ctx, l4_off, TCP_SPORT_OFF, csum_off, port, old_port);\n",
        "                if (IS_ERR (ret))\n",
        "                    return ret;\n",
        "            }\n",
        "        }\n",
        "        break;\n",
        "    case IPPROTO_ICMPV6 :\n",
        "    case IPPROTO_ICMP :\n",
        "        return CTX_ACT_OK;\n",
        "    default :\n",
        "        return DROP_UNKNOWN_L4;\n",
        "    }\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "l4_modify_port",
        "l4_load_port"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__lb6_rev_nat": [
    {
      "capabilities": [
        {
          "capability": "read_skb",
          "read_skb": [
            {
              "Project": "cilium",
              "Return Type": "s64",
              "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ",
              "Return": " The checksum result, or a negative error code in case of failure.",
              "Function Name": "csum_diff",
              "Input Params": [
                "{Type: __be32 ,Var: *from}",
                "{Type:  u32 ,Var: from_size}",
                "{Type:  __be32 ,Var: *to}",
                "{Type:  u32 ,Var: to_size}",
                "{Type:  __wsum ,Var: seed}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "xdp",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "lwt_seg6local"
              ],
              "capabilities": [
                "read_skb"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 419,
      "endLine": 459,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "__lb6_rev_nat",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " int l4_off",
        " struct csum_offset *csum_off",
        " struct ipv6_ct_tuple *tuple",
        " int flags",
        " struct lb6_reverse_nat *nat"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "csum_diff"
      ],
      "compatibleHookpoints": [
        "lwt_seg6local",
        "sched_act",
        "xdp",
        "lwt_xmit",
        "sched_cls",
        "lwt_in",
        "lwt_out"
      ],
      "source": [
        "static __always_inline int __lb6_rev_nat (struct  __ctx_buff *ctx, int l4_off, struct csum_offset *csum_off, struct ipv6_ct_tuple *tuple, int flags, struct lb6_reverse_nat *nat)\n",
        "{\n",
        "    union v6addr old_saddr;\n",
        "    union v6addr tmp;\n",
        "    __u8 *new_saddr;\n",
        "    __be32 sum;\n",
        "    int ret;\n",
        "    cilium_dbg_lb (ctx, DBG_LB6_REVERSE_NAT, nat->address.p4, nat->port);\n",
        "    if (nat->port) {\n",
        "        ret = reverse_map_l4_port (ctx, tuple -> nexthdr, nat -> port, l4_off, csum_off);\n",
        "        if (IS_ERR (ret))\n",
        "            return ret;\n",
        "    }\n",
        "    if (flags & REV_NAT_F_TUPLE_SADDR) {\n",
        "        ipv6_addr_copy (&old_saddr, &tuple->saddr);\n",
        "        ipv6_addr_copy (&tuple->saddr, &nat->address);\n",
        "        new_saddr = tuple->saddr.addr;\n",
        "    }\n",
        "    else {\n",
        "        if (ipv6_load_saddr (ctx, ETH_HLEN, &old_saddr) < 0)\n",
        "            return DROP_INVALID;\n",
        "        ipv6_addr_copy (&tmp, &nat->address);\n",
        "        new_saddr = tmp.addr;\n",
        "    }\n",
        "    ret = ipv6_store_saddr (ctx, new_saddr, ETH_HLEN);\n",
        "    if (IS_ERR (ret))\n",
        "        return DROP_WRITE_ERROR;\n",
        "    sum = csum_diff (old_saddr.addr, 16, new_saddr, 16, 0);\n",
        "    if (csum_l4_replace (ctx, l4_off, csum_off, 0, sum, BPF_F_PSEUDO_HDR) < 0)\n",
        "        return DROP_CSUM_L4;\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "ipv6_store_saddr",
        "csum_l4_replace",
        "ipv6_load_saddr",
        "ipv6_addr_copy",
        "reverse_map_l4_port"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "lb6_rev_nat": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 470,
      "endLine": 482,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "lb6_rev_nat",
      "developer_inline_comments": [
        {
          "start_line": 461,
          "end_line": 469,
          "text": "/** Perform IPv6 reverse NAT based on reverse NAT index\n * @arg ctx\t\tpacket\n * @arg l4_off\t\toffset to L4\n * @arg csum_off\toffset to L4 checksum field\n * @arg csum_flags\tchecksum flags\n * @arg index\t\treverse NAT index\n * @arg tuple\t\ttuple\n * @arg saddr_tuple\tIf set, tuple address will be updated with new source address\n */"
        }
      ],
      "updateMaps": [],
      "readMaps": [
        "  LB6_REVERSE_NAT_MAP"
      ],
      "input": [
        "struct  __ctx_buff *ctx",
        " int l4_off",
        " struct csum_offset *csum_off",
        " __u16 index",
        " struct ipv6_ct_tuple *tuple",
        " int flags"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int lb6_rev_nat (struct  __ctx_buff *ctx, int l4_off, struct csum_offset *csum_off, __u16 index, struct ipv6_ct_tuple *tuple, int flags)\n",
        "{\n",
        "    struct lb6_reverse_nat *nat;\n",
        "    cilium_dbg_lb (ctx, DBG_LB6_REVERSE_NAT_LOOKUP, index, 0);\n",
        "    nat = map_lookup_elem (& LB6_REVERSE_NAT_MAP, & index);\n",
        "    if (nat == NULL)\n",
        "        return 0;\n",
        "    return __lb6_rev_nat (ctx, l4_off, csum_off, tuple, flags, nat);\n",
        "}\n"
      ],
      "called_function_list": [
        "__lb6_rev_nat"
      ],
      "call_depth": 4,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "lb6_extract_key": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 500,
      "endLine": 516,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "lb6_extract_key",
      "developer_inline_comments": [
        {
          "start_line": 484,
          "end_line": 499,
          "text": "/** Extract IPv6 LB key from packet\n * @arg ctx\t\tPacket\n * @arg tuple\t\tTuple\n * @arg l4_off\t\tOffset to L4 header\n * @arg key\t\tPointer to store LB key in\n * @arg csum_off\tPointer to store L4 checksum field offset and flags\n * @arg dir\t\tFlow direction\n *\n * Expects the ctx to be validated for direct packet access up to L4. Fills\n * lb6_key based on L4 nexthdr.\n *\n * Returns:\n *   - CTX_ACT_OK on successful extraction\n *   - DROP_UNKNOWN_L4 if packet should be ignore (sent to stack)\n *   - Negative error code\n */"
        },
        {
          "start_line": 508,
          "end_line": 508,
          "text": "/* FIXME(brb): set after adding support for different L4 protocols in LB */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff * ctx __maybe_unused",
        " struct ipv6_ct_tuple *tuple",
        " int l4_off __maybe_unused",
        " struct lb6_key *key",
        " struct csum_offset *csum_off",
        " enum ct_dir dir"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int lb6_extract_key (struct  __ctx_buff * ctx __maybe_unused, struct ipv6_ct_tuple *tuple, int l4_off __maybe_unused, struct lb6_key *key, struct csum_offset *csum_off, enum ct_dir dir)\n",
        "{\n",
        "    union v6addr *addr;\n",
        "    key->proto = 0;\n",
        "    addr = (dir == CT_INGRESS) ? &tuple->saddr : &tuple->daddr;\n",
        "    ipv6_addr_copy (&key->address, addr);\n",
        "    csum_l4_offset_and_flags (tuple->nexthdr, csum_off);\n",
        "    return extract_l4_port (ctx, tuple->nexthdr, l4_off, dir, &key->dport, NULL);\n",
        "}\n"
      ],
      "called_function_list": [
        "ipv6_addr_copy",
        "extract_l4_port",
        "csum_l4_offset_and_flags"
      ],
      "call_depth": 6,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "lb6_src_range_ok": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 518,
      "endLine": 541,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "lb6_src_range_ok",
      "developer_inline_comments": [
        {
          "start_line": 540,
          "end_line": 540,
          "text": "/* ENABLE_SRC_RANGE_CHECK */"
        }
      ],
      "updateMaps": [],
      "readMaps": [
        " LB6_SRC_RANGE_MAP"
      ],
      "input": [
        "const struct lb6_service * svc __maybe_unused",
        " const union v6addr * saddr __maybe_unused"
      ],
      "output": "static__always_inlinebool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline bool lb6_src_range_ok (const struct lb6_service * svc __maybe_unused, const union v6addr * saddr __maybe_unused)\n",
        "{\n",
        "\n",
        "#ifdef ENABLE_SRC_RANGE_CHECK\n",
        "    struct lb6_src_range_key key;\n",
        "    if (!lb6_svc_has_src_range_check (svc))\n",
        "        return true;\n",
        "    key = (typeof (key)) {\n",
        "        .lpm_key = {SRC_RANGE_STATIC_PREFIX (key),\n",
        "            {}},\n",
        "        .rev_nat_id = svc->rev_nat_index,\n",
        "        .addr = *saddr,};\n",
        "    if (map_lookup_elem (&LB6_SRC_RANGE_MAP, &key))\n",
        "        return true;\n",
        "    return false;\n",
        "\n",
        "#else\n",
        "    return true;\n",
        "\n",
        "#endif /* ENABLE_SRC_RANGE_CHECK */\n",
        "}\n"
      ],
      "called_function_list": [
        "lb6_svc_has_src_range_check"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "lb6_to_lb4_service": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 543,
      "endLine": 551,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "lb6_to_lb4_service",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct lb6_service * svc __maybe_unused"
      ],
      "output": "static__always_inlinebool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline bool lb6_to_lb4_service (const struct lb6_service * svc __maybe_unused)\n",
        "{\n",
        "\n",
        "#ifdef ENABLE_NAT_46X64\n",
        "    return svc->flags2 & SVC_FLAG_NAT_46X64;\n",
        "\n",
        "#else\n",
        "    return false;\n",
        "\n",
        "#endif\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 991,
      "endLine": 995,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "lb6_to_lb4_service",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct lb6_service * svc __maybe_unused"
      ],
      "output": "static__always_inlinebool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline bool lb6_to_lb4_service (const struct lb6_service * svc __maybe_unused)\n",
        "{\n",
        "    return false;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "lb6_lookup_service": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 553,
      "endLine": 573,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "lb6_lookup_service",
      "developer_inline_comments": [
        {
          "start_line": 564,
          "end_line": 564,
          "text": "/* Packets for L7 LB are redirected even when there are no backends. */"
        }
      ],
      "updateMaps": [],
      "readMaps": [
        "  LB6_SERVICES_MAP_V2"
      ],
      "input": [
        "struct lb6_key *key",
        " const bool scope_switch"
      ],
      "output": "static__always_inlinestructlb6_service",
      "helper": [
        "map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline struct lb6_service *lb6_lookup_service (struct lb6_key *key, const bool scope_switch)\n",
        "{\n",
        "    struct lb6_service *svc;\n",
        "    key->scope = LB_LOOKUP_SCOPE_EXT;\n",
        "    key->backend_slot = 0;\n",
        "    svc = map_lookup_elem (& LB6_SERVICES_MAP_V2, key);\n",
        "    if (svc) {\n",
        "        if (!scope_switch || !lb6_svc_is_local_scope (svc))\n",
        "            return (svc->count || lb6_svc_is_l7loadbalancer (svc)) ? svc : NULL;\n",
        "        key->scope = LB_LOOKUP_SCOPE_INT;\n",
        "        svc = map_lookup_elem (& LB6_SERVICES_MAP_V2, key);\n",
        "        if (svc && (svc->count || lb6_svc_is_l7loadbalancer (svc)))\n",
        "            return svc;\n",
        "    }\n",
        "    return NULL;\n",
        "}\n"
      ],
      "called_function_list": [
        "lb6_svc_is_l7loadbalancer",
        "lb6_svc_is_local_scope"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 972,
      "endLine": 977,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "lb6_lookup_service",
      "developer_inline_comments": [
        {
          "start_line": 969,
          "end_line": 971,
          "text": "/* Stubs for v4-in-v6 socket cgroup hook case when only v4 is enabled to avoid\n * additional map management.\n */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct lb6_key * key __maybe_unused",
        " const bool scope_switch __maybe_unused"
      ],
      "output": "static__always_inlinestructlb6_service",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline struct lb6_service *lb6_lookup_service (struct lb6_key * key __maybe_unused, const bool scope_switch __maybe_unused)\n",
        "{\n",
        "    return NULL;\n",
        "}\n"
      ],
      "called_function_list": [
        "lb6_svc_is_l7loadbalancer",
        "lb6_svc_is_local_scope"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__lb6_lookup_backend": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 575,
      "endLine": 578,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "__lb6_lookup_backend",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [
        " LB6_BACKEND_MAP_V2"
      ],
      "input": [
        "__u32 backend_id"
      ],
      "output": "static__always_inlinestructlb6_backend",
      "helper": [
        "map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline struct lb6_backend *__lb6_lookup_backend (__u32 backend_id)\n",
        "{\n",
        "    return map_lookup_elem (&LB6_BACKEND_MAP_V2, &backend_id);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 985,
      "endLine": 989,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "__lb6_lookup_backend",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "__u16 backend_id __maybe_unused"
      ],
      "output": "static__always_inlinestructlb6_backend",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline struct lb6_backend *__lb6_lookup_backend (__u16 backend_id __maybe_unused)\n",
        "{\n",
        "    return NULL;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "lb6_lookup_backend": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 580,
      "endLine": 590,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "lb6_lookup_backend",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff * ctx __maybe_unused",
        " __u32 backend_id"
      ],
      "output": "static__always_inlinestructlb6_backend",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline struct lb6_backend *lb6_lookup_backend (struct  __ctx_buff * ctx __maybe_unused, __u32 backend_id)\n",
        "{\n",
        "    struct lb6_backend *backend;\n",
        "    backend = __lb6_lookup_backend (backend_id);\n",
        "    if (!backend)\n",
        "        cilium_dbg_lb (ctx, DBG_LB6_LOOKUP_BACKEND_FAIL, backend_id, 0);\n",
        "    return backend;\n",
        "}\n"
      ],
      "called_function_list": [
        "__lb6_lookup_backend"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__lb6_lookup_backend_slot": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 592,
      "endLine": 596,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "__lb6_lookup_backend_slot",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [
        " LB6_SERVICES_MAP_V2"
      ],
      "input": [
        "struct lb6_key *key"
      ],
      "output": "static__always_inlinestructlb6_service",
      "helper": [
        "map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline struct lb6_service *__lb6_lookup_backend_slot (struct lb6_key *key)\n",
        "{\n",
        "    return map_lookup_elem (&LB6_SERVICES_MAP_V2, key);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 979,
      "endLine": 983,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "__lb6_lookup_backend_slot",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct lb6_key * key __maybe_unused"
      ],
      "output": "static__always_inlinestructlb6_service",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline struct lb6_service *__lb6_lookup_backend_slot (struct lb6_key * key __maybe_unused)\n",
        "{\n",
        "    return NULL;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "lb6_lookup_backend_slot": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 598,
      "endLine": 613,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "lb6_lookup_backend_slot",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff * ctx __maybe_unused",
        " struct lb6_key *key",
        " __u16 slot"
      ],
      "output": "static__always_inlinestructlb6_service",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline struct lb6_service *lb6_lookup_backend_slot (struct  __ctx_buff * ctx __maybe_unused, struct lb6_key *key, __u16 slot)\n",
        "{\n",
        "    struct lb6_service *svc;\n",
        "    key->backend_slot = slot;\n",
        "    cilium_dbg_lb (ctx, DBG_LB6_LOOKUP_BACKEND_SLOT, key->backend_slot, key->dport);\n",
        "    svc = __lb6_lookup_backend_slot (key);\n",
        "    if (svc)\n",
        "        return svc;\n",
        "    cilium_dbg_lb (ctx, DBG_LB6_LOOKUP_BACKEND_SLOT_V2_FAIL, key->backend_slot, key->dport);\n",
        "    return NULL;\n",
        "}\n"
      ],
      "called_function_list": [
        "__lb6_lookup_backend_slot"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "lb6_select_backend_id": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 617,
      "endLine": 627,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "lb6_select_backend_id",
      "developer_inline_comments": [
        {
          "start_line": 615,
          "end_line": 615,
          "text": "/* Backend slot 0 is always reserved for the service frontend. */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " struct lb6_key *key",
        " const struct ipv6_ct_tuple * tuple __maybe_unused",
        " const struct lb6_service *svc"
      ],
      "output": "static__always_inline__u32",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __u32 lb6_select_backend_id (struct  __ctx_buff *ctx, struct lb6_key *key, const struct ipv6_ct_tuple * tuple __maybe_unused, const struct lb6_service *svc)\n",
        "{\n",
        "    __u16 slot = (get_prandom_u32 () % svc->count) + 1;\n",
        "    struct lb6_service *be = lb6_lookup_backend_slot (ctx, key, slot);\n",
        "    return be ? be->backend_id : 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "hash_from_tuple_v6",
        "lb6_lookup_backend_slot",
        "map_array_get_32"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 629,
      "endLine": 649,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "lb6_select_backend_id",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [
        "  LB6_MAGLEV_MAP_OUTER",
        " maglev_lut"
      ],
      "input": [
        "struct  __ctx_buff * ctx __maybe_unused",
        " struct lb6_key * key __maybe_unused",
        " const struct ipv6_ct_tuple *tuple",
        " const struct lb6_service *svc"
      ],
      "output": "static__always_inline__u32",
      "helper": [
        "map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __u32 lb6_select_backend_id (struct  __ctx_buff * ctx __maybe_unused, struct lb6_key * key __maybe_unused, const struct ipv6_ct_tuple *tuple, const struct lb6_service *svc)\n",
        "{\n",
        "    __u32 zero = 0, index = svc->rev_nat_index;\n",
        "    __u32 *backend_ids;\n",
        "    void *maglev_lut;\n",
        "    maglev_lut = map_lookup_elem (& LB6_MAGLEV_MAP_OUTER, & index);\n",
        "    if (unlikely (!maglev_lut))\n",
        "        return 0;\n",
        "    backend_ids = map_lookup_elem (maglev_lut, & zero);\n",
        "    if (unlikely (!backend_ids))\n",
        "        return 0;\n",
        "    index = hash_from_tuple_v6 (tuple) % LB_MAGLEV_LUT_SIZE;\n",
        "    return map_array_get_32 (backend_ids, index, (LB_MAGLEV_LUT_SIZE - 1) << 2);\n",
        "}\n"
      ],
      "called_function_list": [
        "hash_from_tuple_v6",
        "lb6_lookup_backend_slot",
        "map_array_get_32"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "lb6_xlate": [
    {
      "capabilities": [
        {
          "capability": "read_skb",
          "read_skb": [
            {
              "Project": "cilium",
              "Return Type": "s64",
              "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ",
              "Return": " The checksum result, or a negative error code in case of failure.",
              "Function Name": "csum_diff",
              "Input Params": [
                "{Type: __be32 ,Var: *from}",
                "{Type:  u32 ,Var: from_size}",
                "{Type:  __be32 ,Var: *to}",
                "{Type:  u32 ,Var: to_size}",
                "{Type:  __wsum ,Var: seed}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "xdp",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "lwt_seg6local"
              ],
              "capabilities": [
                "read_skb"
              ]
            }
          ]
        },
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 654,
      "endLine": 689,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "lb6_xlate",
      "developer_inline_comments": [
        {
          "start_line": 652,
          "end_line": 652,
          "text": "/* LB_SELECTION */"
        },
        {
          "start_line": 681,
          "end_line": 681,
          "text": "/* Port offsets for UDP and TCP are the same */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " const union v6addr *new_dst",
        " __u8 nexthdr",
        " int l3_off",
        " int l4_off",
        " struct csum_offset *csum_off",
        " const struct lb6_key *key",
        " const struct lb6_backend *backend",
        " const bool skip_l3_xlate"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "csum_diff",
        "CTX_ACT_OK"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "static __always_inline int lb6_xlate (struct  __ctx_buff *ctx, const union v6addr *new_dst, __u8 nexthdr, int l3_off, int l4_off, struct csum_offset *csum_off, const struct lb6_key *key, const struct lb6_backend *backend, const bool skip_l3_xlate)\n",
        "{\n",
        "    if (skip_l3_xlate)\n",
        "        goto l4_xlate;\n",
        "    ipv6_store_daddr (ctx, new_dst->addr, l3_off);\n",
        "    if (csum_off) {\n",
        "        __be32 sum = csum_diff (key -> address.addr, 16, new_dst -> addr, 16, 0);\n",
        "        if (csum_l4_replace (ctx, l4_off, csum_off, 0, sum, BPF_F_PSEUDO_HDR) < 0)\n",
        "            return DROP_CSUM_L4;\n",
        "    }\n",
        "l4_xlate :\n",
        "    if (likely (backend->port) && key->dport != backend->port && (nexthdr == IPPROTO_TCP || nexthdr == IPPROTO_UDP)) {\n",
        "        __be16 tmp = backend->port;\n",
        "        int ret;\n",
        "        ret = l4_modify_port (ctx, l4_off, TCP_DPORT_OFF, csum_off, tmp, key -> dport);\n",
        "        if (IS_ERR (ret))\n",
        "            return ret;\n",
        "    }\n",
        "    return CTX_ACT_OK;\n",
        "}\n"
      ],
      "called_function_list": [
        "ipv6_store_daddr",
        "csum_l4_replace",
        "l4_modify_port"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__lb6_affinity_backend_id": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 692,
      "endLine": 728,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "__lb6_affinity_backend_id",
      "developer_inline_comments": [],
      "updateMaps": [
        " LB6_AFFINITY_MAP"
      ],
      "readMaps": [
        " LB_AFFINITY_MATCH_MAP",
        "  LB6_AFFINITY_MAP"
      ],
      "input": [
        "const struct lb6_service *svc",
        " bool netns_cookie",
        " union lb6_affinity_client_id *id"
      ],
      "output": "static__always_inline__u32",
      "helper": [
        "map_delete_elem",
        "map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __u32 __lb6_affinity_backend_id (const struct lb6_service *svc, bool netns_cookie, union lb6_affinity_client_id *id)\n",
        "{\n",
        "    struct lb6_affinity_key key = {\n",
        "        .rev_nat_id = svc->rev_nat_index,\n",
        "        .netns_cookie = netns_cookie,}\n",
        "    ;\n",
        "    struct lb_affinity_val *val;\n",
        "    ipv6_addr_copy (&key.client_id.client_ip, &id->client_ip);\n",
        "    val = map_lookup_elem (& LB6_AFFINITY_MAP, & key);\n",
        "    if (val != NULL) {\n",
        "        __u32 now = bpf_mono_now ();\n",
        "        struct lb_affinity_match match = {\n",
        "            .rev_nat_id = svc->rev_nat_index,\n",
        "            .backend_id = val->backend_id,}\n",
        "        ;\n",
        "        if (READ_ONCE (val->last_used) + bpf_sec_to_mono (svc->affinity_timeout) <= now) {\n",
        "            map_delete_elem (&LB6_AFFINITY_MAP, &key);\n",
        "            return 0;\n",
        "        }\n",
        "        if (!map_lookup_elem (&LB_AFFINITY_MATCH_MAP, &match)) {\n",
        "            map_delete_elem (&LB6_AFFINITY_MAP, &key);\n",
        "            return 0;\n",
        "        }\n",
        "        WRITE_ONCE (val->last_used, now);\n",
        "        return val->backend_id;\n",
        "    }\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "ipv6_addr_copy"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "lb6_affinity_backend_id_by_addr": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 730,
      "endLine": 735,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "lb6_affinity_backend_id_by_addr",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct lb6_service *svc",
        " union lb6_affinity_client_id *id"
      ],
      "output": "static__always_inline__u32",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __u32 lb6_affinity_backend_id_by_addr (const struct lb6_service *svc, union lb6_affinity_client_id *id)\n",
        "{\n",
        "    return __lb6_affinity_backend_id (svc, false, id);\n",
        "}\n"
      ],
      "called_function_list": [
        "__lb6_affinity_backend_id"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__lb6_update_affinity": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 737,
      "endLine": 754,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "__lb6_update_affinity",
      "developer_inline_comments": [],
      "updateMaps": [
        " LB6_AFFINITY_MAP"
      ],
      "readMaps": [],
      "input": [
        "const struct lb6_service *svc",
        " bool netns_cookie",
        " union lb6_affinity_client_id *id",
        " __u32 backend_id"
      ],
      "output": "static__always_inlinevoid",
      "helper": [
        "map_update_elem"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void __lb6_update_affinity (const struct lb6_service *svc, bool netns_cookie, union lb6_affinity_client_id *id, __u32 backend_id)\n",
        "{\n",
        "    __u32 now = bpf_mono_now ();\n",
        "    struct lb6_affinity_key key = {\n",
        "        .rev_nat_id = svc->rev_nat_index,\n",
        "        .netns_cookie = netns_cookie,}\n",
        "    ;\n",
        "    struct lb_affinity_val val = {\n",
        "        .backend_id = backend_id,\n",
        "        .last_used = now,}\n",
        "    ;\n",
        "    ipv6_addr_copy (&key.client_id.client_ip, &id->client_ip);\n",
        "    map_update_elem (&LB6_AFFINITY_MAP, &key, &val, 0);\n",
        "}\n"
      ],
      "called_function_list": [
        "ipv6_addr_copy"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "lb6_update_affinity_by_addr": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 756,
      "endLine": 761,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "lb6_update_affinity_by_addr",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct lb6_service *svc",
        " union lb6_affinity_client_id *id",
        " __u32 backend_id"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void lb6_update_affinity_by_addr (const struct lb6_service *svc, union lb6_affinity_client_id *id, __u32 backend_id)\n",
        "{\n",
        "    __lb6_update_affinity (svc, false, id, backend_id);\n",
        "}\n"
      ],
      "called_function_list": [
        "__lb6_update_affinity"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "lb6_affinity_backend_id_by_netns": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 764,
      "endLine": 773,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "lb6_affinity_backend_id_by_netns",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct lb6_service * svc __maybe_unused",
        " union lb6_affinity_client_id * id __maybe_unused"
      ],
      "output": "static__always_inline__u32",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __u32 lb6_affinity_backend_id_by_netns (const struct lb6_service * svc __maybe_unused, union lb6_affinity_client_id * id __maybe_unused)\n",
        "{\n",
        "\n",
        "#if defined(ENABLE_SESSION_AFFINITY)\n",
        "    return __lb6_affinity_backend_id (svc, true, id);\n",
        "\n",
        "#else\n",
        "    return 0;\n",
        "\n",
        "#endif\n",
        "}\n"
      ],
      "called_function_list": [
        "__lb6_affinity_backend_id"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "lb6_update_affinity_by_netns": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 775,
      "endLine": 783,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "lb6_update_affinity_by_netns",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct lb6_service * svc __maybe_unused",
        " union lb6_affinity_client_id * id __maybe_unused",
        " __u32 backend_id __maybe_unused"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void lb6_update_affinity_by_netns (const struct lb6_service * svc __maybe_unused, union lb6_affinity_client_id * id __maybe_unused, __u32 backend_id __maybe_unused)\n",
        "{\n",
        "\n",
        "#if defined(ENABLE_SESSION_AFFINITY)\n",
        "    __lb6_update_affinity (svc, true, id, backend_id);\n",
        "\n",
        "#endif\n",
        "}\n"
      ],
      "called_function_list": [
        "__lb6_update_affinity"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "lb6_to_lb4": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 785,
      "endLine": 799,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "lb6_to_lb4",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff * ctx __maybe_unused",
        " const struct ipv6hdr * ip6 __maybe_unused"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int lb6_to_lb4 (struct  __ctx_buff * ctx __maybe_unused, const struct ipv6hdr * ip6 __maybe_unused)\n",
        "{\n",
        "\n",
        "#ifdef ENABLE_NAT_46X64\n",
        "    __be32 src4, dst4;\n",
        "    build_v4_from_v6 ((const union v6addr *) &ip6->saddr, &src4);\n",
        "    build_v4_from_v6 ((const union v6addr *) &ip6->daddr, &dst4);\n",
        "    return ipv6_to_ipv4 (ctx, src4, dst4);\n",
        "\n",
        "#else\n",
        "    return DROP_NAT_46X64_DISABLED;\n",
        "\n",
        "#endif\n",
        "}\n"
      ],
      "called_function_list": [
        "ipv6_to_ipv4",
        "build_v4_from_v6"
      ],
      "call_depth": 4,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "lb6_local": [
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 801,
      "endLine": 926,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "lb6_local",
      "developer_inline_comments": [
        {
          "start_line": 810,
          "end_line": 810,
          "text": "/* Deliberately ignored; regular CT will determine monitoring. */"
        },
        {
          "start_line": 822,
          "end_line": 822,
          "text": "/* See lb4_local comments re svc endpoint lookup process */"
        },
        {
          "start_line": 847,
          "end_line": 849,
          "text": "/* Fail closed, if the conntrack entry create fails drop\n\t\t * service lookup.\n\t\t */"
        },
        {
          "start_line": 857,
          "end_line": 857,
          "text": "/* See lb4_local comment */"
        },
        {
          "start_line": 867,
          "end_line": 867,
          "text": "/* See lb4_local comment */"
        },
        {
          "start_line": 885,
          "end_line": 888,
          "text": "/* If the lookup fails it means the user deleted the backend out from\n\t * underneath us. To resolve this fall back to hash. If this is a TCP\n\t * session we are likely to get a TCP RST.\n\t */"
        },
        {
          "start_line": 891,
          "end_line": 893,
          "text": "/* Drain existing connections, but redirect new ones to only\n\t\t * active backends.\n\t\t */"
        },
        {
          "start_line": 908,
          "end_line": 910,
          "text": "/* Restore flags so that SERVICE flag is only used in used when the\n\t * service lookup happens and future lookups use EGRESS or INGRESS.\n\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const void *map",
        " struct  __ctx_buff *ctx",
        " int l3_off",
        " int l4_off",
        " struct csum_offset *csum_off",
        " struct lb6_key *key",
        " struct ipv6_ct_tuple *tuple",
        " const struct lb6_service *svc",
        " struct ct_state *state",
        " const bool skip_l3_xlate"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "CTX_ACT_OK"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "static __always_inline int lb6_local (const void *map, struct  __ctx_buff *ctx, int l3_off, int l4_off, struct csum_offset *csum_off, struct lb6_key *key, struct ipv6_ct_tuple *tuple, const struct lb6_service *svc, struct ct_state *state, const bool skip_l3_xlate)\n",
        "{\n",
        "    __u32 monitor;\n",
        "    union v6addr *addr;\n",
        "    __u8 flags = tuple->flags;\n",
        "    struct lb6_backend *backend;\n",
        "    __u32 backend_id = 0;\n",
        "    int ret;\n",
        "\n",
        "#ifdef ENABLE_SESSION_AFFINITY\n",
        "    union lb6_affinity_client_id client_id;\n",
        "    ipv6_addr_copy (&client_id.client_ip, &tuple->saddr);\n",
        "\n",
        "#endif\n",
        "    ret = ct_lookup6 (map, tuple, ctx, l4_off, CT_SERVICE, state, & monitor);\n",
        "    switch (ret) {\n",
        "    case CT_NEW :\n",
        "\n",
        "#ifdef ENABLE_SESSION_AFFINITY\n",
        "        if (lb6_svc_is_affinity (svc)) {\n",
        "            backend_id = lb6_affinity_backend_id_by_addr (svc, & client_id);\n",
        "            if (backend_id != 0) {\n",
        "                backend = lb6_lookup_backend (ctx, backend_id);\n",
        "                if (backend == NULL)\n",
        "                    backend_id = 0;\n",
        "            }\n",
        "        }\n",
        "\n",
        "#endif\n",
        "        if (backend_id == 0) {\n",
        "            backend_id = lb6_select_backend_id (ctx, key, tuple, svc);\n",
        "            backend = lb6_lookup_backend (ctx, backend_id);\n",
        "            if (backend == NULL)\n",
        "                goto drop_no_service;\n",
        "        }\n",
        "        state->backend_id = backend_id;\n",
        "        state->rev_nat_index = svc->rev_nat_index;\n",
        "        ret = ct_create6 (map, NULL, tuple, ctx, CT_SERVICE, state, false, false);\n",
        "        if (IS_ERR (ret))\n",
        "            goto drop_no_service;\n",
        "        goto update_state;\n",
        "    case CT_REOPENED :\n",
        "    case CT_ESTABLISHED :\n",
        "    case CT_RELATED :\n",
        "    case CT_REPLY :\n",
        "        if (state->rev_nat_index == 0) {\n",
        "            state->rev_nat_index = svc->rev_nat_index;\n",
        "            ct_update6_rev_nat_index (map, tuple, state);\n",
        "        }\n",
        "        break;\n",
        "    default :\n",
        "        goto drop_no_service;\n",
        "    }\n",
        "    if (state->rev_nat_index != svc->rev_nat_index) {\n",
        "\n",
        "#ifdef ENABLE_SESSION_AFFINITY\n",
        "        if (lb6_svc_is_affinity (svc))\n",
        "            backend_id = lb6_affinity_backend_id_by_addr (svc, &client_id);\n",
        "\n",
        "#endif\n",
        "        if (!backend_id) {\n",
        "            backend_id = lb6_select_backend_id (ctx, key, tuple, svc);\n",
        "            if (!backend_id)\n",
        "                goto drop_no_service;\n",
        "        }\n",
        "        state->backend_id = backend_id;\n",
        "        ct_update6_backend_id (map, tuple, state);\n",
        "        state->rev_nat_index = svc->rev_nat_index;\n",
        "        ct_update6_rev_nat_index (map, tuple, state);\n",
        "    }\n",
        "    backend = lb6_lookup_backend (ctx, state -> backend_id);\n",
        "    if (unlikely (!backend || backend->flags != BE_STATE_ACTIVE)) {\n",
        "        if (backend && !state->syn)\n",
        "            goto update_state;\n",
        "        key->backend_slot = 0;\n",
        "        svc = lb6_lookup_service (key, false);\n",
        "        if (!svc)\n",
        "            goto drop_no_service;\n",
        "        backend_id = lb6_select_backend_id (ctx, key, tuple, svc);\n",
        "        backend = lb6_lookup_backend (ctx, backend_id);\n",
        "        if (!backend)\n",
        "            goto drop_no_service;\n",
        "        state->backend_id = backend_id;\n",
        "        ct_update6_backend_id (map, tuple, state);\n",
        "    }\n",
        "update_state :\n",
        "    tuple->flags = flags;\n",
        "    ipv6_addr_copy (&tuple->daddr, &backend->address);\n",
        "    addr = &tuple->daddr;\n",
        "    state->rev_nat_index = svc->rev_nat_index;\n",
        "\n",
        "#ifdef ENABLE_SESSION_AFFINITY\n",
        "    if (lb6_svc_is_affinity (svc))\n",
        "        lb6_update_affinity_by_addr (svc, &client_id, state->backend_id);\n",
        "\n",
        "#endif\n",
        "    return lb_skip_l4_dnat () ? CTX_ACT_OK : lb6_xlate (ctx, addr, tuple->nexthdr, l3_off, l4_off, csum_off, key, backend, skip_l3_xlate);\n",
        "drop_no_service :\n",
        "    tuple->flags = flags;\n",
        "    return DROP_NO_SERVICE;\n",
        "}\n"
      ],
      "called_function_list": [
        "lb6_update_affinity_by_addr",
        "lb6_svc_is_affinity",
        "ct_update6_rev_nat_index",
        "lb6_lookup_service",
        "lb_skip_l4_dnat",
        "ct_update6_backend_id",
        "lb6_select_backend_id",
        "lb6_xlate",
        "lb6_lookup_backend",
        "lb6_affinity_backend_id_by_addr",
        "ipv6_addr_copy",
        "ct_create6",
        "ct_lookup6"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "lb6_ctx_store_state": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 935,
      "endLine": 942,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "lb6_ctx_store_state",
      "developer_inline_comments": [
        {
          "start_line": 928,
          "end_line": 934,
          "text": "/* lb6_ctx_store_state() stores per packet load balancing state to be picked\n * up on the continuation tail call.\n * Note that the IP headers are already xlated and the tuple is re-initialized\n * from the xlated headers before restoring state.\n * NOTE: if lb_skip_l4_dnat() this is not the case as xlate is skipped. We\n * lose the updated tuple daddr in that case.\n */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " const struct ct_state *state",
        " __u16 proxy_port"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void lb6_ctx_store_state (struct  __ctx_buff *ctx, const struct ct_state *state, __u16 proxy_port)\n",
        "{\n",
        "    ctx_store_meta (ctx, CB_PROXY_MAGIC, (__u32) proxy_port << 16);\n",
        "    ctx_store_meta (ctx, CB_BACKEND_ID, state->backend_id);\n",
        "    ctx_store_meta (ctx, CB_CT_STATE, (__u32) state->rev_nat_index);\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_store_meta"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "lb6_ctx_restore_state": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 949,
      "endLine": 965,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "lb6_ctx_restore_state",
      "developer_inline_comments": [
        {
          "start_line": 944,
          "end_line": 948,
          "text": "/* lb6_ctx_restore_state() restores per packet load balancing state from the\n * previous tail call.\n * tuple->flags does not need to be restored, as it will be reinitialized from\n * the packet.\n */"
        },
        {
          "start_line": 954,
          "end_line": 954,
          "text": "/* Clear to not leak state to later stages of the datapath. */"
        },
        {
          "start_line": 957,
          "end_line": 957,
          "text": "/* No loopback support for IPv6, see lb6_local() above. */"
        },
        {
          "start_line": 960,
          "end_line": 960,
          "text": "/* Must clear to avoid policy bypass as CB_BACKEND_ID aliases CB_POLICY. */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " struct ct_state *state",
        " __u16 *proxy_port"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void lb6_ctx_restore_state (struct  __ctx_buff *ctx, struct ct_state *state, __u16 *proxy_port)\n",
        "{\n",
        "    state->rev_nat_index = (__u16) ctx_load_meta (ctx, CB_CT_STATE);\n",
        "    ctx_store_meta (ctx, CB_CT_STATE, 0);\n",
        "    state->backend_id = ctx_load_meta (ctx, CB_BACKEND_ID);\n",
        "    ctx_store_meta (ctx, CB_BACKEND_ID, 0);\n",
        "    *proxy_port = ctx_load_meta (ctx, CB_PROXY_MAGIC) >> 16;\n",
        "    ctx_store_meta (ctx, CB_PROXY_MAGIC, 0);\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_load_meta",
        "ctx_store_meta"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__lb4_rev_nat": [
    {
      "capabilities": [
        {
          "capability": "read_skb",
          "read_skb": [
            {
              "Project": "cilium",
              "Return Type": "s64",
              "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ",
              "Return": " The checksum result, or a negative error code in case of failure.",
              "Function Name": "csum_diff",
              "Input Params": [
                "{Type: __be32 ,Var: *from}",
                "{Type:  u32 ,Var: from_size}",
                "{Type:  __be32 ,Var: *to}",
                "{Type:  u32 ,Var: to_size}",
                "{Type:  __wsum ,Var: seed}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "xdp",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "lwt_seg6local"
              ],
              "capabilities": [
                "read_skb"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 999,
      "endLine": 1066,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "__lb4_rev_nat",
      "developer_inline_comments": [
        {
          "start_line": 1028,
          "end_line": 1033,
          "text": "/* The packet was looped back to the sending endpoint on the\n\t\t * forward service translation. This implies that the original\n\t\t * source address of the packet is the source address of the\n\t\t * current packet. We therefore need to make the current source\n\t\t * address the new destination address.\n\t\t */"
        },
        {
          "start_line": 1048,
          "end_line": 1048,
          "text": "/* Update the tuple address which is representing the destination address */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " int l3_off",
        " int l4_off",
        " struct csum_offset *csum_off",
        " struct ipv4_ct_tuple *tuple",
        " int flags",
        " const struct lb4_reverse_nat *nat",
        " const struct ct_state *ct_state",
        " bool has_l4_header"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "csum_diff"
      ],
      "compatibleHookpoints": [
        "lwt_seg6local",
        "sched_act",
        "xdp",
        "lwt_xmit",
        "sched_cls",
        "lwt_in",
        "lwt_out"
      ],
      "source": [
        "static __always_inline int __lb4_rev_nat (struct  __ctx_buff *ctx, int l3_off, int l4_off, struct csum_offset *csum_off, struct ipv4_ct_tuple *tuple, int flags, const struct lb4_reverse_nat *nat, const struct ct_state *ct_state, bool has_l4_header)\n",
        "{\n",
        "    __be32 old_sip, new_sip, sum = 0;\n",
        "    int ret;\n",
        "    cilium_dbg_lb (ctx, DBG_LB4_REVERSE_NAT, nat->address, nat->port);\n",
        "    if (nat->port && has_l4_header) {\n",
        "        ret = reverse_map_l4_port (ctx, tuple -> nexthdr, nat -> port, l4_off, csum_off);\n",
        "        if (IS_ERR (ret))\n",
        "            return ret;\n",
        "    }\n",
        "    if (flags & REV_NAT_F_TUPLE_SADDR) {\n",
        "        old_sip = tuple->saddr;\n",
        "        tuple->saddr = new_sip = nat->address;\n",
        "    }\n",
        "    else {\n",
        "        ret = ctx_load_bytes (ctx, l3_off + offsetof (struct iphdr, saddr), & old_sip, 4);\n",
        "        if (IS_ERR (ret))\n",
        "            return ret;\n",
        "        new_sip = nat->address;\n",
        "    }\n",
        "    if (ct_state->loopback) {\n",
        "        __be32 old_dip;\n",
        "        ret = ctx_load_bytes (ctx, l3_off + offsetof (struct iphdr, daddr), & old_dip, 4);\n",
        "        if (IS_ERR (ret))\n",
        "            return ret;\n",
        "        cilium_dbg_lb (ctx, DBG_LB4_LOOPBACK_SNAT_REV, old_dip, old_sip);\n",
        "        ret = ctx_store_bytes (ctx, l3_off + offsetof (struct iphdr, daddr), & old_sip, 4, 0);\n",
        "        if (IS_ERR (ret))\n",
        "            return DROP_WRITE_ERROR;\n",
        "        sum = csum_diff (& old_dip, 4, & old_sip, 4, 0);\n",
        "        tuple->saddr = old_sip;\n",
        "    }\n",
        "    ret = ctx_store_bytes (ctx, l3_off + offsetof (struct iphdr, saddr), & new_sip, 4, 0);\n",
        "    if (IS_ERR (ret))\n",
        "        return DROP_WRITE_ERROR;\n",
        "    sum = csum_diff (& old_sip, 4, & new_sip, 4, sum);\n",
        "    if (l3_csum_replace (ctx, l3_off + offsetof (struct iphdr, check), 0, sum, 0) < 0)\n",
        "        return DROP_CSUM_L3;\n",
        "    if (csum_off->offset && csum_l4_replace (ctx, l4_off, csum_off, 0, sum, BPF_F_PSEUDO_HDR) < 0)\n",
        "        return DROP_CSUM_L4;\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "csum_l4_replace",
        "reverse_map_l4_port"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "lb4_rev_nat": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 1078,
      "endLine": 1092,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "lb4_rev_nat",
      "developer_inline_comments": [
        {
          "start_line": 1069,
          "end_line": 1077,
          "text": "/** Perform IPv4 reverse NAT based on reverse NAT index\n * @arg ctx\t\tpacket\n * @arg l3_off\t\toffset to L3\n * @arg l4_off\t\toffset to L4\n * @arg csum_off\toffset to L4 checksum field\n * @arg csum_flags\tchecksum flags\n * @arg index\t\treverse NAT index\n * @arg tuple\t\ttuple\n */"
        }
      ],
      "updateMaps": [],
      "readMaps": [
        "  LB4_REVERSE_NAT_MAP"
      ],
      "input": [
        "struct  __ctx_buff *ctx",
        " int l3_off",
        " int l4_off",
        " struct csum_offset *csum_off",
        " struct ct_state *ct_state",
        " struct ipv4_ct_tuple *tuple",
        " int flags",
        " bool has_l4_header"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int lb4_rev_nat (struct  __ctx_buff *ctx, int l3_off, int l4_off, struct csum_offset *csum_off, struct ct_state *ct_state, struct ipv4_ct_tuple *tuple, int flags, bool has_l4_header)\n",
        "{\n",
        "    struct lb4_reverse_nat *nat;\n",
        "    cilium_dbg_lb (ctx, DBG_LB4_REVERSE_NAT_LOOKUP, ct_state->rev_nat_index, 0);\n",
        "    nat = map_lookup_elem (& LB4_REVERSE_NAT_MAP, & ct_state -> rev_nat_index);\n",
        "    if (nat == NULL)\n",
        "        return 0;\n",
        "    return __lb4_rev_nat (ctx, l3_off, l4_off, csum_off, tuple, flags, nat, ct_state, has_l4_header);\n",
        "}\n"
      ],
      "called_function_list": [
        "__lb4_rev_nat"
      ],
      "call_depth": 4,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "lb4_extract_key": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1107,
      "endLine": 1121,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "lb4_extract_key",
      "developer_inline_comments": [
        {
          "start_line": 1094,
          "end_line": 1106,
          "text": "/** Extract IPv4 LB key from packet\n * @arg ctx\t\tPacket\n * @arg ip4\t\tPointer to L3 header\n * @arg l4_off\t\tOffset to L4 header\n * @arg key\t\tPointer to store LB key in\n * @arg csum_off\tPointer to store L4 checksum field offset  in\n * @arg dir\t\tFlow direction\n *\n * Returns:\n *   - CTX_ACT_OK on successful extraction\n *   - DROP_UNKNOWN_L4 if packet should be ignore (sent to stack)\n *   - Negative error code\n */"
        },
        {
          "start_line": 1114,
          "end_line": 1114,
          "text": "/* FIXME: set after adding support for different L4 protocols in LB */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff * ctx __maybe_unused",
        " struct iphdr *ip4",
        " int l4_off __maybe_unused",
        " struct lb4_key *key",
        " struct csum_offset *csum_off",
        " enum ct_dir dir"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int lb4_extract_key (struct  __ctx_buff * ctx __maybe_unused, struct iphdr *ip4, int l4_off __maybe_unused, struct lb4_key *key, struct csum_offset *csum_off, enum ct_dir dir)\n",
        "{\n",
        "    key->proto = 0;\n",
        "    key->address = (dir == CT_INGRESS) ? ip4->saddr : ip4->daddr;\n",
        "    if (ipv4_has_l4_header (ip4))\n",
        "        csum_l4_offset_and_flags (ip4->protocol, csum_off);\n",
        "    return extract_l4_port (ctx, ip4->protocol, l4_off, dir, &key->dport, ip4);\n",
        "}\n"
      ],
      "called_function_list": [
        "extract_l4_port",
        "ipv4_has_l4_header",
        "csum_l4_offset_and_flags"
      ],
      "call_depth": 6,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "lb4_src_range_ok": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1123,
      "endLine": 1146,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "lb4_src_range_ok",
      "developer_inline_comments": [
        {
          "start_line": 1145,
          "end_line": 1145,
          "text": "/* ENABLE_SRC_RANGE_CHECK */"
        }
      ],
      "updateMaps": [],
      "readMaps": [
        " LB4_SRC_RANGE_MAP"
      ],
      "input": [
        "const struct lb4_service * svc __maybe_unused",
        " __u32 saddr __maybe_unused"
      ],
      "output": "static__always_inlinebool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline bool lb4_src_range_ok (const struct lb4_service * svc __maybe_unused, __u32 saddr __maybe_unused)\n",
        "{\n",
        "\n",
        "#ifdef ENABLE_SRC_RANGE_CHECK\n",
        "    struct lb4_src_range_key key;\n",
        "    if (!lb4_svc_has_src_range_check (svc))\n",
        "        return true;\n",
        "    key = (typeof (key)) {\n",
        "        .lpm_key = {SRC_RANGE_STATIC_PREFIX (key),\n",
        "            {}},\n",
        "        .rev_nat_id = svc->rev_nat_index,\n",
        "        .addr = saddr,};\n",
        "    if (map_lookup_elem (&LB4_SRC_RANGE_MAP, &key))\n",
        "        return true;\n",
        "    return false;\n",
        "\n",
        "#else\n",
        "    return true;\n",
        "\n",
        "#endif /* ENABLE_SRC_RANGE_CHECK */\n",
        "}\n"
      ],
      "called_function_list": [
        "lb4_svc_has_src_range_check"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "lb4_populate_ports": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1148,
      "endLine": 1164,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "lb4_populate_ports",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " struct ipv4_ct_tuple *tuple",
        " int off"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int lb4_populate_ports (struct  __ctx_buff *ctx, struct ipv4_ct_tuple *tuple, int off)\n",
        "{\n",
        "    if (tuple->nexthdr == IPPROTO_TCP || tuple->nexthdr == IPPROTO_UDP) {\n",
        "        struct {\n",
        "            __be16 sport;\n",
        "            __be16 dport;\n",
        "        } l4hdr;\n",
        "\n",
        "        if (ctx_load_bytes (ctx, off, &l4hdr, sizeof (l4hdr)) < 0)\n",
        "            return -EFAULT;\n",
        "        tuple->sport = l4hdr.sport;\n",
        "        tuple->dport = l4hdr.dport;\n",
        "        return 0;\n",
        "    }\n",
        "    return -ENOTSUP;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "lb4_to_lb6_service": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1166,
      "endLine": 1174,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "lb4_to_lb6_service",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct lb4_service * svc __maybe_unused"
      ],
      "output": "static__always_inlinebool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline bool lb4_to_lb6_service (const struct lb4_service * svc __maybe_unused)\n",
        "{\n",
        "\n",
        "#ifdef ENABLE_NAT_46X64\n",
        "    return svc->flags2 & SVC_FLAG_NAT_46X64;\n",
        "\n",
        "#else\n",
        "    return false;\n",
        "\n",
        "#endif\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "lb4_lookup_service": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 1176,
      "endLine": 1197,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "lb4_lookup_service",
      "developer_inline_comments": [
        {
          "start_line": 1187,
          "end_line": 1187,
          "text": "/* Packets for L7 LB are redirected even when there are no backends. */"
        }
      ],
      "updateMaps": [],
      "readMaps": [
        "  LB4_SERVICES_MAP_V2"
      ],
      "input": [
        "struct lb4_key *key",
        " const bool scope_switch"
      ],
      "output": "static__always_inlinestructlb4_service",
      "helper": [
        "map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline struct lb4_service *lb4_lookup_service (struct lb4_key *key, const bool scope_switch)\n",
        "{\n",
        "    struct lb4_service *svc;\n",
        "    key->scope = LB_LOOKUP_SCOPE_EXT;\n",
        "    key->backend_slot = 0;\n",
        "    svc = map_lookup_elem (& LB4_SERVICES_MAP_V2, key);\n",
        "    if (svc) {\n",
        "        if (!scope_switch || !lb4_svc_is_local_scope (svc))\n",
        "            return (svc->count || lb4_to_lb6_service (svc) || lb4_svc_is_l7loadbalancer (svc)) ? svc : NULL;\n",
        "        key->scope = LB_LOOKUP_SCOPE_INT;\n",
        "        svc = map_lookup_elem (& LB4_SERVICES_MAP_V2, key);\n",
        "        if (svc && (svc->count || lb4_svc_is_l7loadbalancer (svc)))\n",
        "            return svc;\n",
        "    }\n",
        "    return NULL;\n",
        "}\n"
      ],
      "called_function_list": [
        "lb4_svc_is_local_scope",
        "lb4_svc_is_l7loadbalancer",
        "lb4_to_lb6_service"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__lb4_lookup_backend": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 1199,
      "endLine": 1202,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "__lb4_lookup_backend",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [
        " LB4_BACKEND_MAP_V2"
      ],
      "input": [
        "__u32 backend_id"
      ],
      "output": "static__always_inlinestructlb4_backend",
      "helper": [
        "map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline struct lb4_backend *__lb4_lookup_backend (__u32 backend_id)\n",
        "{\n",
        "    return map_lookup_elem (&LB4_BACKEND_MAP_V2, &backend_id);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "lb4_lookup_backend": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1204,
      "endLine": 1214,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "lb4_lookup_backend",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff * ctx __maybe_unused",
        " __u32 backend_id"
      ],
      "output": "static__always_inlinestructlb4_backend",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline struct lb4_backend *lb4_lookup_backend (struct  __ctx_buff * ctx __maybe_unused, __u32 backend_id)\n",
        "{\n",
        "    struct lb4_backend *backend;\n",
        "    backend = __lb4_lookup_backend (backend_id);\n",
        "    if (!backend)\n",
        "        cilium_dbg_lb (ctx, DBG_LB4_LOOKUP_BACKEND_FAIL, backend_id, 0);\n",
        "    return backend;\n",
        "}\n"
      ],
      "called_function_list": [
        "__lb4_lookup_backend"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__lb4_lookup_backend_slot": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 1216,
      "endLine": 1220,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "__lb4_lookup_backend_slot",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [
        " LB4_SERVICES_MAP_V2"
      ],
      "input": [
        "struct lb4_key *key"
      ],
      "output": "static__always_inlinestructlb4_service",
      "helper": [
        "map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline struct lb4_service *__lb4_lookup_backend_slot (struct lb4_key *key)\n",
        "{\n",
        "    return map_lookup_elem (&LB4_SERVICES_MAP_V2, key);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "lb4_lookup_backend_slot": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1222,
      "endLine": 1237,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "lb4_lookup_backend_slot",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff * ctx __maybe_unused",
        " struct lb4_key *key",
        " __u16 slot"
      ],
      "output": "static__always_inlinestructlb4_service",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline struct lb4_service *lb4_lookup_backend_slot (struct  __ctx_buff * ctx __maybe_unused, struct lb4_key *key, __u16 slot)\n",
        "{\n",
        "    struct lb4_service *svc;\n",
        "    key->backend_slot = slot;\n",
        "    cilium_dbg_lb (ctx, DBG_LB4_LOOKUP_BACKEND_SLOT, key->backend_slot, key->dport);\n",
        "    svc = __lb4_lookup_backend_slot (key);\n",
        "    if (svc)\n",
        "        return svc;\n",
        "    cilium_dbg_lb (ctx, DBG_LB4_LOOKUP_BACKEND_SLOT_V2_FAIL, key->backend_slot, key->dport);\n",
        "    return NULL;\n",
        "}\n"
      ],
      "called_function_list": [
        "__lb4_lookup_backend_slot"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "lb4_select_backend_id": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1241,
      "endLine": 1251,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "lb4_select_backend_id",
      "developer_inline_comments": [
        {
          "start_line": 1239,
          "end_line": 1239,
          "text": "/* Backend slot 0 is always reserved for the service frontend. */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " struct lb4_key *key",
        " const struct ipv4_ct_tuple * tuple __maybe_unused",
        " const struct lb4_service *svc"
      ],
      "output": "static__always_inline__u32",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __u32 lb4_select_backend_id (struct  __ctx_buff *ctx, struct lb4_key *key, const struct ipv4_ct_tuple * tuple __maybe_unused, const struct lb4_service *svc)\n",
        "{\n",
        "    __u16 slot = (get_prandom_u32 () % svc->count) + 1;\n",
        "    struct lb4_service *be = lb4_lookup_backend_slot (ctx, key, slot);\n",
        "    return be ? be->backend_id : 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "map_array_get_32",
        "lb4_lookup_backend_slot",
        "hash_from_tuple_v4"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 1253,
      "endLine": 1273,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "lb4_select_backend_id",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [
        " maglev_lut",
        "  LB4_MAGLEV_MAP_OUTER"
      ],
      "input": [
        "struct  __ctx_buff * ctx __maybe_unused",
        " struct lb4_key * key __maybe_unused",
        " const struct ipv4_ct_tuple *tuple",
        " const struct lb4_service *svc"
      ],
      "output": "static__always_inline__u32",
      "helper": [
        "map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __u32 lb4_select_backend_id (struct  __ctx_buff * ctx __maybe_unused, struct lb4_key * key __maybe_unused, const struct ipv4_ct_tuple *tuple, const struct lb4_service *svc)\n",
        "{\n",
        "    __u32 zero = 0, index = svc->rev_nat_index;\n",
        "    __u32 *backend_ids;\n",
        "    void *maglev_lut;\n",
        "    maglev_lut = map_lookup_elem (& LB4_MAGLEV_MAP_OUTER, & index);\n",
        "    if (unlikely (!maglev_lut))\n",
        "        return 0;\n",
        "    backend_ids = map_lookup_elem (maglev_lut, & zero);\n",
        "    if (unlikely (!backend_ids))\n",
        "        return 0;\n",
        "    index = hash_from_tuple_v4 (tuple) % LB_MAGLEV_LUT_SIZE;\n",
        "    return map_array_get_32 (backend_ids, index, (LB_MAGLEV_LUT_SIZE - 1) << 2);\n",
        "}\n"
      ],
      "called_function_list": [
        "map_array_get_32",
        "lb4_lookup_backend_slot",
        "hash_from_tuple_v4"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "lb4_xlate": [
    {
      "capabilities": [
        {
          "capability": "read_skb",
          "read_skb": [
            {
              "Project": "cilium",
              "Return Type": "s64",
              "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ",
              "Return": " The checksum result, or a negative error code in case of failure.",
              "Function Name": "csum_diff",
              "Input Params": [
                "{Type: __be32 ,Var: *from}",
                "{Type:  u32 ,Var: from_size}",
                "{Type:  __be32 ,Var: *to}",
                "{Type:  u32 ,Var: to_size}",
                "{Type:  __wsum ,Var: seed}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "xdp",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "lwt_seg6local"
              ],
              "capabilities": [
                "read_skb"
              ]
            }
          ]
        },
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 1278,
      "endLine": 1332,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "lb4_xlate",
      "developer_inline_comments": [
        {
          "start_line": 1276,
          "end_line": 1276,
          "text": "/* LB_SELECTION */"
        },
        {
          "start_line": 1308,
          "end_line": 1308,
          "text": "/* DISABLE_LOOPBACK_LB */"
        },
        {
          "start_line": 1324,
          "end_line": 1324,
          "text": "/* Port offsets for UDP and TCP are the same */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " __be32 *new_daddr",
        " __be32 * new_saddr __maybe_unused",
        " __be32 * old_saddr __maybe_unused",
        " __u8 nexthdr __maybe_unused",
        " int l3_off",
        " int l4_off",
        " struct csum_offset *csum_off",
        " struct lb4_key *key",
        " const struct lb4_backend * backend __maybe_unused",
        " bool has_l4_header",
        " const bool skip_l3_xlate"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "csum_diff",
        "CTX_ACT_OK"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "static __always_inline int lb4_xlate (struct  __ctx_buff *ctx, __be32 *new_daddr, __be32 * new_saddr __maybe_unused, __be32 * old_saddr __maybe_unused, __u8 nexthdr __maybe_unused, int l3_off, int l4_off, struct csum_offset *csum_off, struct lb4_key *key, const struct lb4_backend * backend __maybe_unused, bool has_l4_header, const bool skip_l3_xlate)\n",
        "{\n",
        "    __be32 sum;\n",
        "    int ret;\n",
        "    if (skip_l3_xlate)\n",
        "        goto l4_xlate;\n",
        "    ret = ctx_store_bytes (ctx, l3_off + offsetof (struct iphdr, daddr), new_daddr, 4, 0);\n",
        "    if (ret < 0)\n",
        "        return DROP_WRITE_ERROR;\n",
        "    sum = csum_diff (& key -> address, 4, new_daddr, 4, 0);\n",
        "\n",
        "#ifndef DISABLE_LOOPBACK_LB\n",
        "    if (new_saddr && *new_saddr) {\n",
        "        cilium_dbg_lb (ctx, DBG_LB4_LOOPBACK_SNAT, *old_saddr, *new_saddr);\n",
        "        ret = ctx_store_bytes (ctx, l3_off + offsetof (struct iphdr, saddr), new_saddr, 4, 0);\n",
        "        if (ret < 0)\n",
        "            return DROP_WRITE_ERROR;\n",
        "        sum = csum_diff (old_saddr, 4, new_saddr, 4, sum);\n",
        "    }\n",
        "\n",
        "#endif /* DISABLE_LOOPBACK_LB */\n",
        "    if (l3_csum_replace (ctx, l3_off + offsetof (struct iphdr, check), 0, sum, 0) < 0)\n",
        "        return DROP_CSUM_L3;\n",
        "    if (csum_off->offset) {\n",
        "        if (csum_l4_replace (ctx, l4_off, csum_off, 0, sum, BPF_F_PSEUDO_HDR) < 0)\n",
        "            return DROP_CSUM_L4;\n",
        "    }\n",
        "l4_xlate :\n",
        "    if (likely (backend->port) && key->dport != backend->port && (nexthdr == IPPROTO_TCP || nexthdr == IPPROTO_UDP) && has_l4_header) {\n",
        "        __be16 tmp = backend->port;\n",
        "        ret = l4_modify_port (ctx, l4_off, TCP_DPORT_OFF, csum_off, tmp, key -> dport);\n",
        "        if (IS_ERR (ret))\n",
        "            return ret;\n",
        "    }\n",
        "    return CTX_ACT_OK;\n",
        "}\n"
      ],
      "called_function_list": [
        "csum_l4_replace",
        "l4_modify_port"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__lb4_affinity_backend_id": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 1335,
      "endLine": 1375,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "__lb4_affinity_backend_id",
      "developer_inline_comments": [
        {
          "start_line": 1354,
          "end_line": 1358,
          "text": "/* We have seconds granularity for timing values here.\n\t\t * To ensure that session affinity timeout works properly we don't include\n\t\t * the upper bound from the time range.\n\t\t * Session is sticky for range [current, last_used + affinity_timeout)\n\t\t */"
        }
      ],
      "updateMaps": [
        " LB4_AFFINITY_MAP"
      ],
      "readMaps": [
        " LB_AFFINITY_MATCH_MAP",
        "  LB4_AFFINITY_MAP"
      ],
      "input": [
        "const struct lb4_service *svc",
        " bool netns_cookie",
        " const union lb4_affinity_client_id *id"
      ],
      "output": "static__always_inline__u32",
      "helper": [
        "map_delete_elem",
        "map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __u32 __lb4_affinity_backend_id (const struct lb4_service *svc, bool netns_cookie, const union lb4_affinity_client_id *id)\n",
        "{\n",
        "    struct lb4_affinity_key key = {\n",
        "        .rev_nat_id = svc->rev_nat_index,\n",
        "        .netns_cookie = netns_cookie,\n",
        "        .client_id = *id,}\n",
        "    ;\n",
        "    struct lb_affinity_val *val;\n",
        "    val = map_lookup_elem (& LB4_AFFINITY_MAP, & key);\n",
        "    if (val != NULL) {\n",
        "        __u32 now = bpf_mono_now ();\n",
        "        struct lb_affinity_match match = {\n",
        "            .rev_nat_id = svc->rev_nat_index,\n",
        "            .backend_id = val->backend_id,}\n",
        "        ;\n",
        "        if (READ_ONCE (val->last_used) + bpf_sec_to_mono (svc->affinity_timeout) <= now) {\n",
        "            map_delete_elem (&LB4_AFFINITY_MAP, &key);\n",
        "            return 0;\n",
        "        }\n",
        "        if (!map_lookup_elem (&LB_AFFINITY_MATCH_MAP, &match)) {\n",
        "            map_delete_elem (&LB4_AFFINITY_MAP, &key);\n",
        "            return 0;\n",
        "        }\n",
        "        WRITE_ONCE (val->last_used, now);\n",
        "        return val->backend_id;\n",
        "    }\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "lb4_affinity_backend_id_by_addr": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1377,
      "endLine": 1382,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "lb4_affinity_backend_id_by_addr",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct lb4_service *svc",
        " union lb4_affinity_client_id *id"
      ],
      "output": "static__always_inline__u32",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __u32 lb4_affinity_backend_id_by_addr (const struct lb4_service *svc, union lb4_affinity_client_id *id)\n",
        "{\n",
        "    return __lb4_affinity_backend_id (svc, false, id);\n",
        "}\n"
      ],
      "called_function_list": [
        "__lb4_affinity_backend_id"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__lb4_update_affinity": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1384,
      "endLine": 1401,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "__lb4_update_affinity",
      "developer_inline_comments": [],
      "updateMaps": [
        " LB4_AFFINITY_MAP"
      ],
      "readMaps": [],
      "input": [
        "const struct lb4_service *svc",
        " bool netns_cookie",
        " const union lb4_affinity_client_id *id",
        " __u32 backend_id"
      ],
      "output": "static__always_inlinevoid",
      "helper": [
        "map_update_elem"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void __lb4_update_affinity (const struct lb4_service *svc, bool netns_cookie, const union lb4_affinity_client_id *id, __u32 backend_id)\n",
        "{\n",
        "    __u32 now = bpf_mono_now ();\n",
        "    struct lb4_affinity_key key = {\n",
        "        .rev_nat_id = svc->rev_nat_index,\n",
        "        .netns_cookie = netns_cookie,\n",
        "        .client_id = *id,}\n",
        "    ;\n",
        "    struct lb_affinity_val val = {\n",
        "        .backend_id = backend_id,\n",
        "        .last_used = now,}\n",
        "    ;\n",
        "    map_update_elem (&LB4_AFFINITY_MAP, &key, &val, 0);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "lb4_update_affinity_by_addr": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1403,
      "endLine": 1408,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "lb4_update_affinity_by_addr",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct lb4_service *svc",
        " union lb4_affinity_client_id *id",
        " __u32 backend_id"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void lb4_update_affinity_by_addr (const struct lb4_service *svc, union lb4_affinity_client_id *id, __u32 backend_id)\n",
        "{\n",
        "    __lb4_update_affinity (svc, false, id, backend_id);\n",
        "}\n"
      ],
      "called_function_list": [
        "__lb4_update_affinity"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "lb4_affinity_backend_id_by_netns": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1411,
      "endLine": 1420,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "lb4_affinity_backend_id_by_netns",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct lb4_service * svc __maybe_unused",
        " union lb4_affinity_client_id * id __maybe_unused"
      ],
      "output": "static__always_inline__u32",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __u32 lb4_affinity_backend_id_by_netns (const struct lb4_service * svc __maybe_unused, union lb4_affinity_client_id * id __maybe_unused)\n",
        "{\n",
        "\n",
        "#if defined(ENABLE_SESSION_AFFINITY)\n",
        "    return __lb4_affinity_backend_id (svc, true, id);\n",
        "\n",
        "#else\n",
        "    return 0;\n",
        "\n",
        "#endif\n",
        "}\n"
      ],
      "called_function_list": [
        "__lb4_affinity_backend_id"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "lb4_update_affinity_by_netns": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1422,
      "endLine": 1430,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "lb4_update_affinity_by_netns",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct lb4_service * svc __maybe_unused",
        " union lb4_affinity_client_id * id __maybe_unused",
        " __u32 backend_id __maybe_unused"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void lb4_update_affinity_by_netns (const struct lb4_service * svc __maybe_unused, union lb4_affinity_client_id * id __maybe_unused, __u32 backend_id __maybe_unused)\n",
        "{\n",
        "\n",
        "#if defined(ENABLE_SESSION_AFFINITY)\n",
        "    __lb4_update_affinity (svc, true, id, backend_id);\n",
        "\n",
        "#endif\n",
        "}\n"
      ],
      "called_function_list": [
        "__lb4_update_affinity"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "lb4_to_lb6": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1432,
      "endLine": 1447,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "lb4_to_lb6",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff * ctx __maybe_unused",
        " const struct iphdr * ip4 __maybe_unused",
        " int l3_off __maybe_unused"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int lb4_to_lb6 (struct  __ctx_buff * ctx __maybe_unused, const struct iphdr * ip4 __maybe_unused, int l3_off __maybe_unused)\n",
        "{\n",
        "\n",
        "#ifdef ENABLE_NAT_46X64\n",
        "    union v6addr src6, dst6;\n",
        "    build_v4_in_v6 (&src6, ip4->saddr);\n",
        "    build_v4_in_v6 (&dst6, ip4->daddr);\n",
        "    return ipv4_to_ipv6 (ctx, l3_off, &src6, &dst6);\n",
        "\n",
        "#else\n",
        "    return DROP_NAT_46X64_DISABLED;\n",
        "\n",
        "#endif\n",
        "}\n"
      ],
      "called_function_list": [
        "ipv4_to_ipv6",
        "build_v4_in_v6"
      ],
      "call_depth": 4,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "lb4_local": [
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 1449,
      "endLine": 1604,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "lb4_local",
      "developer_inline_comments": [
        {
          "start_line": 1459,
          "end_line": 1459,
          "text": "/* Deliberately ignored; regular CT will determine monitoring. */"
        },
        {
          "start_line": 1484,
          "end_line": 1484,
          "text": "/* No CT entry has been found, so select a svc endpoint */"
        },
        {
          "start_line": 1495,
          "end_line": 1497,
          "text": "/* Fail closed, if the conntrack entry create fails drop\n\t\t * service lookup.\n\t\t */"
        },
        {
          "start_line": 1505,
          "end_line": 1510,
          "text": "/* For backward-compatibility we need to update reverse NAT\n\t\t * index in the CT_SERVICE entry for old connections, as later\n\t\t * in the code we check whether the right backend is used.\n\t\t * Having it set to 0 would trigger a new backend selection\n\t\t * which would in many cases would pick a different backend.\n\t\t */"
        },
        {
          "start_line": 1520,
          "end_line": 1526,
          "text": "/* If the CT_SERVICE entry is from a non-related connection (e.g.\n\t * endpoint has been removed, but its CT entries were not (it is\n\t * totally possible due to the bug in DumpReliablyWithCallback)),\n\t * then a wrong (=from unrelated service) backend can be selected.\n\t * To avoid this, check that reverse NAT indices match. If not,\n\t * select a new backend.\n\t */"
        },
        {
          "start_line": 1544,
          "end_line": 1547,
          "text": "/* If the lookup fails it means the user deleted the backend out from\n\t * underneath us. To resolve this fall back to hash. If this is a TCP\n\t * session we are likely to get a TCP RST.\n\t */"
        },
        {
          "start_line": 1550,
          "end_line": 1552,
          "text": "/* Drain existing connections, but redirect new ones to only\n\t\t * active backends.\n\t\t */"
        },
        {
          "start_line": 1567,
          "end_line": 1569,
          "text": "/* Restore flags so that SERVICE flag is only used in used when the\n\t * service lookup happens and future lookups use EGRESS or INGRESS.\n\t */"
        },
        {
          "start_line": 1579,
          "end_line": 1585,
          "text": "/* Special loopback case: The origin endpoint has transmitted to a\n\t * service which is being translated back to the source. This would\n\t * result in a packet with identical source and destination address.\n\t * Linux considers such packets as martian source and will drop unless\n\t * received on a loopback device. Perform NAT on the source address\n\t * to make it appear from an outside address.\n\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const void *map",
        " struct  __ctx_buff *ctx",
        " int l3_off",
        " int l4_off",
        " struct csum_offset *csum_off",
        " struct lb4_key *key",
        " struct ipv4_ct_tuple *tuple",
        " const struct lb4_service *svc",
        " struct ct_state *state",
        " __be32 saddr",
        " bool has_l4_header",
        " const bool skip_l3_xlate"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "CTX_ACT_OK"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "static __always_inline int lb4_local (const void *map, struct  __ctx_buff *ctx, int l3_off, int l4_off, struct csum_offset *csum_off, struct lb4_key *key, struct ipv4_ct_tuple *tuple, const struct lb4_service *svc, struct ct_state *state, __be32 saddr, bool has_l4_header, const bool skip_l3_xlate)\n",
        "{\n",
        "    __u32 monitor;\n",
        "    __be32 new_saddr = 0, new_daddr;\n",
        "    __u8 flags = tuple->flags;\n",
        "    struct lb4_backend *backend;\n",
        "    __u32 backend_id = 0;\n",
        "    int ret;\n",
        "\n",
        "#ifdef ENABLE_SESSION_AFFINITY\n",
        "    union lb4_affinity_client_id client_id = {\n",
        "        .client_ip = saddr,}\n",
        "    ;\n",
        "\n",
        "#endif\n",
        "    ret = ct_lookup4 (map, tuple, ctx, l4_off, CT_SERVICE, state, & monitor);\n",
        "    switch (ret) {\n",
        "    case CT_NEW :\n",
        "\n",
        "#ifdef ENABLE_SESSION_AFFINITY\n",
        "        if (lb4_svc_is_affinity (svc)) {\n",
        "            backend_id = lb4_affinity_backend_id_by_addr (svc, & client_id);\n",
        "            if (backend_id != 0) {\n",
        "                backend = lb4_lookup_backend (ctx, backend_id);\n",
        "                if (backend == NULL)\n",
        "                    backend_id = 0;\n",
        "            }\n",
        "        }\n",
        "\n",
        "#endif\n",
        "        if (backend_id == 0) {\n",
        "            backend_id = lb4_select_backend_id (ctx, key, tuple, svc);\n",
        "            backend = lb4_lookup_backend (ctx, backend_id);\n",
        "            if (backend == NULL)\n",
        "                goto drop_no_service;\n",
        "        }\n",
        "        state->backend_id = backend_id;\n",
        "        state->rev_nat_index = svc->rev_nat_index;\n",
        "        ret = ct_create4 (map, NULL, tuple, ctx, CT_SERVICE, state, false, false);\n",
        "        if (IS_ERR (ret))\n",
        "            goto drop_no_service;\n",
        "        goto update_state;\n",
        "    case CT_REOPENED :\n",
        "    case CT_ESTABLISHED :\n",
        "    case CT_RELATED :\n",
        "    case CT_REPLY :\n",
        "        if (unlikely (state->rev_nat_index == 0)) {\n",
        "            state->rev_nat_index = svc->rev_nat_index;\n",
        "            ct_update4_rev_nat_index (map, tuple, state);\n",
        "        }\n",
        "        break;\n",
        "    default :\n",
        "        goto drop_no_service;\n",
        "    }\n",
        "    if (state->rev_nat_index != svc->rev_nat_index) {\n",
        "\n",
        "#ifdef ENABLE_SESSION_AFFINITY\n",
        "        if (lb4_svc_is_affinity (svc))\n",
        "            backend_id = lb4_affinity_backend_id_by_addr (svc, &client_id);\n",
        "\n",
        "#endif\n",
        "        if (!backend_id) {\n",
        "            backend_id = lb4_select_backend_id (ctx, key, tuple, svc);\n",
        "            if (!backend_id)\n",
        "                goto drop_no_service;\n",
        "        }\n",
        "        state->backend_id = backend_id;\n",
        "        ct_update4_backend_id (map, tuple, state);\n",
        "        state->rev_nat_index = svc->rev_nat_index;\n",
        "        ct_update4_rev_nat_index (map, tuple, state);\n",
        "    }\n",
        "    backend = lb4_lookup_backend (ctx, state -> backend_id);\n",
        "    if (unlikely (!backend || backend->flags != BE_STATE_ACTIVE)) {\n",
        "        if (backend && !state->syn)\n",
        "            goto update_state;\n",
        "        key->backend_slot = 0;\n",
        "        svc = lb4_lookup_service (key, false);\n",
        "        if (!svc)\n",
        "            goto drop_no_service;\n",
        "        backend_id = lb4_select_backend_id (ctx, key, tuple, svc);\n",
        "        backend = lb4_lookup_backend (ctx, backend_id);\n",
        "        if (!backend)\n",
        "            goto drop_no_service;\n",
        "        state->backend_id = backend_id;\n",
        "        ct_update4_backend_id (map, tuple, state);\n",
        "    }\n",
        "update_state :\n",
        "    tuple->flags = flags;\n",
        "    state->rev_nat_index = svc->rev_nat_index;\n",
        "    state->addr = new_daddr = backend->address;\n",
        "\n",
        "#ifdef ENABLE_SESSION_AFFINITY\n",
        "    if (lb4_svc_is_affinity (svc))\n",
        "        lb4_update_affinity_by_addr (svc, &client_id, state->backend_id);\n",
        "\n",
        "#endif\n",
        "\n",
        "#ifndef DISABLE_LOOPBACK_LB\n",
        "    if (saddr == backend->address) {\n",
        "        new_saddr = IPV4_LOOPBACK;\n",
        "        state->loopback = 1;\n",
        "        state->addr = new_saddr;\n",
        "        state->svc_addr = saddr;\n",
        "    }\n",
        "    if (!state->loopback)\n",
        "\n",
        "#endif\n",
        "        tuple->daddr = backend->address;\n",
        "    return lb_skip_l4_dnat () ? CTX_ACT_OK : lb4_xlate (ctx, &new_daddr, &new_saddr, &saddr, tuple->nexthdr, l3_off, l4_off, csum_off, key, backend, has_l4_header, skip_l3_xlate);\n",
        "drop_no_service :\n",
        "    tuple->flags = flags;\n",
        "    return DROP_NO_SERVICE;\n",
        "}\n"
      ],
      "called_function_list": [
        "lb4_affinity_backend_id_by_addr",
        "lb4_update_affinity_by_addr",
        "lb_skip_l4_dnat",
        "ct_create4",
        "lb4_xlate",
        "ct_update4_rev_nat_index",
        "lb4_svc_is_affinity",
        "lb4_lookup_service",
        "lb4_select_backend_id",
        "lb4_lookup_backend",
        "ct_lookup4",
        "ct_update4_backend_id"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "lb4_ctx_store_state": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1613,
      "endLine": 1621,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "lb4_ctx_store_state",
      "developer_inline_comments": [
        {
          "start_line": 1606,
          "end_line": 1612,
          "text": "/* lb4_ctx_store_state() stores per packet load balancing state to be picked\n * up on the continuation tail call.\n * Note that the IP headers are already xlated and the tuple is re-initialized\n * from the xlated headers before restoring state.\n * NOTE: if lb_skip_l4_dnat() this is not the case as xlate is skipped. We\n * lose the updated tuple daddr in that case.\n */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " const struct ct_state *state",
        " __u16 proxy_port"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void lb4_ctx_store_state (struct  __ctx_buff *ctx, const struct ct_state *state, __u16 proxy_port)\n",
        "{\n",
        "    ctx_store_meta (ctx, CB_PROXY_MAGIC, (__u32) proxy_port << 16);\n",
        "    ctx_store_meta (ctx, CB_BACKEND_ID, state->backend_id);\n",
        "    ctx_store_meta (ctx, CB_CT_STATE, (__u32) state->rev_nat_index << 16 | state->loopback);\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_store_meta"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "lb4_ctx_restore_state": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1628,
      "endLine": 1651,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h",
      "funcName": "lb4_ctx_restore_state",
      "developer_inline_comments": [
        {
          "start_line": 1623,
          "end_line": 1627,
          "text": "/* lb4_ctx_restore_state() restores per packet load balancing state from the\n * previous tail call.\n * tuple->flags does not need to be restored, as it will be reinitialized from\n * the packet.\n */"
        },
        {
          "start_line": 1637,
          "end_line": 1637,
          "text": "/* backend address after xlate */"
        },
        {
          "start_line": 1642,
          "end_line": 1642,
          "text": "/* Clear to not leak state to later stages of the datapath. */"
        },
        {
          "start_line": 1646,
          "end_line": 1646,
          "text": "/* must clear to avoid policy bypass as CB_BACKEND_ID aliases CB_POLICY. */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " struct ct_state *state",
        " __u32 daddr __maybe_unused",
        " __u16 *proxy_port"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void lb4_ctx_restore_state (struct  __ctx_buff *ctx, struct ct_state *state, __u32 daddr __maybe_unused, __u16 *proxy_port)\n",
        "{\n",
        "    __u32 meta = ctx_load_meta (ctx, CB_CT_STATE);\n",
        "\n",
        "#ifndef DISABLE_LOOPBACK_LB\n",
        "    if (meta & 1) {\n",
        "        state->loopback = 1;\n",
        "        state->addr = IPV4_LOOPBACK;\n",
        "        state->svc_addr = daddr;\n",
        "    }\n",
        "\n",
        "#endif\n",
        "    state->rev_nat_index = meta >> 16;\n",
        "    ctx_store_meta (ctx, CB_CT_STATE, 0);\n",
        "    state->backend_id = ctx_load_meta (ctx, CB_BACKEND_ID);\n",
        "    ctx_store_meta (ctx, CB_BACKEND_ID, 0);\n",
        "    *proxy_port = ctx_load_meta (ctx, CB_PROXY_MAGIC) >> 16;\n",
        "    ctx_store_meta (ctx, CB_PROXY_MAGIC, 0);\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_load_meta",
        "ctx_store_meta"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "arp_check": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 21,
      "endLine": 30,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/arp.h",
      "funcName": "arp_check",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */"
        },
        {
          "start_line": 2,
          "end_line": 2,
          "text": "/* Copyright Authors of Cilium */"
        },
        {
          "start_line": 20,
          "end_line": 20,
          "text": "/* Check if packet is ARP request for IP */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct ethhdr *eth",
        " const struct arphdr *arp",
        " union macaddr *mac"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int arp_check (struct ethhdr *eth, const struct arphdr *arp, union macaddr *mac)\n",
        "{\n",
        "    union macaddr *dmac = (union macaddr *) &eth->h_dest;\n",
        "    return arp->ar_op == bpf_htons (ARPOP_REQUEST) && arp->ar_hrd == bpf_htons (ARPHRD_ETHER) && (eth_is_bcast (dmac) || !eth_addrcmp (dmac, mac));\n",
        "}\n"
      ],
      "called_function_list": [
        "eth_is_bcast",
        "eth_addrcmp"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "arp_prepare_response": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 32,
      "endLine": 49,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/arp.h",
      "funcName": "arp_prepare_response",
      "developer_inline_comments": [
        {
          "start_line": 41,
          "end_line": 41,
          "text": "/* sizeof(macadrr)=8 because of padding, use ETH_ALEN instead */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " union macaddr *smac",
        " __be32 sip",
        " union macaddr *dmac",
        " __be32 tip"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int arp_prepare_response (struct  __ctx_buff *ctx, union macaddr *smac, __be32 sip, union macaddr *dmac, __be32 tip)\n",
        "{\n",
        "    __be16 arpop = bpf_htons (ARPOP_REPLY);\n",
        "    if (eth_store_saddr (ctx, smac->addr, 0) < 0 || eth_store_daddr (ctx, dmac->addr, 0) < 0 || ctx_store_bytes (ctx, 20, &arpop, sizeof (arpop), 0) < 0 || ctx_store_bytes (ctx, 22, smac, ETH_ALEN, 0) < 0 || ctx_store_bytes (ctx, 28, &sip, sizeof (sip), 0) < 0 || ctx_store_bytes (ctx, 32, dmac, ETH_ALEN, 0) < 0 || ctx_store_bytes (ctx, 38, &tip, sizeof (tip), 0) < 0)\n",
        "        return DROP_WRITE_ERROR;\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "eth_store_saddr",
        "eth_store_daddr"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "arp_validate": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 51,
      "endLine": 73,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/arp.h",
      "funcName": "arp_validate",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct  __ctx_buff *ctx",
        " union macaddr *mac",
        " union macaddr *smac",
        " __be32 *sip",
        " __be32 *tip"
      ],
      "output": "static__always_inlinebool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline bool arp_validate (const struct  __ctx_buff *ctx, union macaddr *mac, union macaddr *smac, __be32 *sip, __be32 *tip)\n",
        "{\n",
        "    void *data_end = (void *) (long) ctx->data_end;\n",
        "    void *data = (void *) (long) ctx->data;\n",
        "    struct arphdr *arp = data + ETH_HLEN;\n",
        "    struct ethhdr *eth = data;\n",
        "    struct arp_eth *arp_eth;\n",
        "    if (data + ETH_HLEN + sizeof (*arp) + sizeof (*arp_eth) > data_end)\n",
        "        return false;\n",
        "    if (!arp_check (eth, arp, mac))\n",
        "        return false;\n",
        "    arp_eth = data + ETH_HLEN + sizeof (*arp);\n",
        "    *smac = *(unionmacaddr*) &eth->h_source;\n",
        "    *sip = arp_eth->ar_sip;\n",
        "    *tip = arp_eth->ar_tip;\n",
        "    return true;\n",
        "}\n"
      ],
      "called_function_list": [
        "arp_check"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "arp_respond": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 75,
      "endLine": 90,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/arp.h",
      "funcName": "arp_respond",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " union macaddr *smac",
        " __be32 sip",
        " union macaddr *dmac",
        " __be32 tip",
        " int direction"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int arp_respond (struct  __ctx_buff *ctx, union macaddr *smac, __be32 sip, union macaddr *dmac, __be32 tip, int direction)\n",
        "{\n",
        "    int ret = arp_prepare_response (ctx, smac, sip, dmac, tip);\n",
        "    if (unlikely (ret != 0))\n",
        "        goto error;\n",
        "    cilium_dbg_capture (ctx, DBG_CAPTURE_DELIVERY, ctx_get_ifindex (ctx));\n",
        "    return ctx_redirect (ctx, ctx_get_ifindex (ctx), direction);\n",
        "error :\n",
        "    return send_drop_notify_error (ctx, 0, ret, CTX_ACT_DROP, METRIC_EGRESS);\n",
        "}\n"
      ],
      "called_function_list": [
        "cilium_dbg_capture",
        "ctx_get_ifindex",
        "arp_prepare_response",
        "ctx_redirect"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "csum_l4_offset_and_flags": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 29,
      "endLine": 49,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/csum.h",
      "funcName": "csum_l4_offset_and_flags",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */"
        },
        {
          "start_line": 2,
          "end_line": 2,
          "text": "/* Copyright Authors of Cilium */"
        },
        {
          "start_line": 19,
          "end_line": 28,
          "text": "/**\n * Determins the L4 checksum field offset and required flags\n * @arg nexthdr\tL3 nextheader field\n * @arg off\tPointer to uninitialied struct csum_offset struct\n *\n * Sets off.offset to offset from start of L4 header to L4 checksum field\n * and off.flags to the required flags, namely BPF_F_MARK_MANGLED_0 for UDP.\n * For unknown L4 protocols or L4 protocols which do not have a checksum\n * field, off is initialied to 0.\n */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "__u8 nexthdr",
        " struct csum_offset *off"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void csum_l4_offset_and_flags (__u8 nexthdr, struct csum_offset *off)\n",
        "{\n",
        "    switch (nexthdr) {\n",
        "    case IPPROTO_TCP :\n",
        "        off->offset = TCP_CSUM_OFF;\n",
        "        break;\n",
        "    case IPPROTO_UDP :\n",
        "        off->offset = UDP_CSUM_OFF;\n",
        "        off->flags = BPF_F_MARK_MANGLED_0;\n",
        "        break;\n",
        "    case IPPROTO_ICMPV6 :\n",
        "        off->offset = offsetof (struct icmp6hdr, icmp6_cksum);\n",
        "        break;\n",
        "    case IPPROTO_ICMP :\n",
        "        break;\n",
        "    }\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "csum_l4_replace": [
    {
      "capabilities": [
        {
          "capability": "update_pkt",
          "update_pkt": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Description": "Recompute the layer 4 (e. g. TCP , UDP or ICMP) checksum for the packet associated <[ to ]>(IP: 3) skb. Computation is incremental , so the helper must know the former value of the header field that was modified (from) , the new value of this field (to) , and the number of bytes (2 or 4) for this field , stored on the lowest four bits of flags. Alternatively , it is possible <[ to ]>(IP: 3) store the difference between the previous and the new values of the header field in <[ to ]>(IP: 3) , by setting <[ from ]>(IP: 2) and the four lowest bits of <[ flags ]>(IP: 4) <[ to ]>(IP: 3) 0. For both methods , <[ offset ]>(IP: 1) indicates the location of the IP checksum within the packet. In addition <[ to ]>(IP: 3) the size of the field , <[ flags ]>(IP: 4) can be added (bitwise OR) actual flags. With BPF_F_MARK_MANGLED_0 , a null checksum is left untouched (unless BPF_F_MARK_ENFORCE is added as well) , and for updates resulting in a null checksum the value is set <[ to ]>(IP: 3) CSUM_MANGLED_0 instead. Flag BPF_F_PSEUDO_HDR indicates the checksum is <[ to ]>(IP: 3) be computed against a pseudo-header. This helper works in combination with csum_diff() , which does not update the checksum in-place , but offers more flexibility and can handle sizes larger than 2 or 4 for the checksum <[ to ]>(IP: 3) update. A call <[ to ]>(IP: 3) this helper is susceptible <[ to ]>(IP: 3) change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "l4_csum_replace",
              "Input Params": [
                "{Type: struct sk_buff ,Var: *skb}",
                "{Type:  u32 ,Var: offset}",
                "{Type:  u64 ,Var: from}",
                "{Type:  u64 ,Var: to}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "lwt_xmit"
              ],
              "capabilities": [
                "update_pkt"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 60,
      "endLine": 65,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/csum.h",
      "funcName": "csum_l4_replace",
      "developer_inline_comments": [
        {
          "start_line": 51,
          "end_line": 59,
          "text": "/**\n * Helper to change L4 checksum\n * @arg ctx\tPacket\n * @arg l4_off\tOffset to L4 header\n * @arg csum\tPointer to csum_offset as extracted by csum_l4_offset_and_flags()\n * @arg from\tFrom value or 0 if to contains csum diff\n * @arg to\tTo value or a csum diff\n * @arg flags\tAdditional flags to be passed to l4_csum_replace()\n */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " __u64 l4_off",
        " const struct csum_offset *csum",
        " __be32 from",
        " __be32 to",
        " int flags"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "l4_csum_replace"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "lwt_xmit"
      ],
      "source": [
        "static __always_inline int csum_l4_replace (struct  __ctx_buff *ctx, __u64 l4_off, const struct csum_offset *csum, __be32 from, __be32 to, int flags)\n",
        "{\n",
        "    return l4_csum_replace (ctx, l4_off + csum->offset, from, to, flags | csum->flags);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "policy_verdict_filter_allow": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 39,
      "endLine": 47,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/policy_log.h",
      "funcName": "policy_verdict_filter_allow",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */"
        },
        {
          "start_line": 2,
          "end_line": 2,
          "text": "/* Copyright Authors of Cilium */"
        },
        {
          "start_line": 4,
          "end_line": 12,
          "text": "/*\n * Policy verdict notification via perf event ring buffer.\n *\n * API:\n * void send_policy_verdict_notify(ctx, remote_label, dst_port, proto, dir,\n *                                 is_ipv6, verdict, match_type)\n *\n * If POLICY_VERDICT_NOTIFY is not defined, the API will be a non-op.\n */"
        },
        {
          "start_line": 36,
          "end_line": 36,
          "text": "/* align with 64 bits */"
        },
        {
          "start_line": 41,
          "end_line": 43,
          "text": "/* Make dir being volatile to avoid compiler optimizing out\n\t * filter (thinking it to be zero).\n\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "__u32 filter",
        " __u8 dir"
      ],
      "output": "static__always_inlinebool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline bool policy_verdict_filter_allow (__u32 filter, __u8 dir)\n",
        "{\n",
        "    volatile __u8 d = dir;\n",
        "    return ((filter & d) > 0);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "send_policy_verdict_notify": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 49,
      "endLine": 77,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/policy_log.h",
      "funcName": "send_policy_verdict_notify",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " __u32 remote_label",
        " __u16 dst_port",
        " __u8 proto",
        " __u8 dir",
        " __u8 is_ipv6",
        " int verdict",
        " __u8 match_type",
        " __u8 is_audited"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void send_policy_verdict_notify (struct  __ctx_buff *ctx, __u32 remote_label, __u16 dst_port, __u8 proto, __u8 dir, __u8 is_ipv6, int verdict, __u8 match_type, __u8 is_audited)\n",
        "{\n",
        "    __u64 ctx_len = ctx_full_len (ctx);\n",
        "    __u64 cap_len = min_t (__u64, TRACE_PAYLOAD_LEN, ctx_len);\n",
        "    struct policy_verdict_notify msg;\n",
        "    if (!policy_verdict_filter_allow (POLICY_VERDICT_LOG_FILTER, dir))\n",
        "        return;\n",
        "    msg = (typeof (msg)) {__notify_common_hdr (CILIUM_NOTIFY_POLICY_VERDICT, 0), __notify_pktcap_hdr (ctx_len, (__u16) cap_len),\n",
        "        .remote_label = remote_label,\n",
        "        .verdict = verdict,\n",
        "        .dst_port = bpf_ntohs (dst_port),\n",
        "        .match_type = match_type,\n",
        "        .proto = proto,\n",
        "        .dir = dir,\n",
        "        .ipv6 = is_ipv6,\n",
        "        .audited = is_audited,};\n",
        "    ctx_event_output (ctx, &EVENTS_MAP, (cap_len << 32) | BPF_F_CURRENT_CPU, &msg, sizeof (msg));\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_full_len",
        "policy_verdict_filter_allow"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 79,
      "endLine": 86,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/policy_log.h",
      "funcName": "send_policy_verdict_notify",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff * ctx __maybe_unused",
        " __u32 remote_label __maybe_unused",
        " __u16 dst_port __maybe_unused",
        " __u8 proto __maybe_unused",
        " __u8 dir __maybe_unused",
        " __u8 is_ipv6 __maybe_unused",
        " int verdict __maybe_unused",
        " __u8 match_type __maybe_unused",
        " __u8 is_audited __maybe_unused"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void send_policy_verdict_notify (struct  __ctx_buff * ctx __maybe_unused, __u32 remote_label __maybe_unused, __u16 dst_port __maybe_unused, __u8 proto __maybe_unused, __u8 dir __maybe_unused, __u8 is_ipv6 __maybe_unused, int verdict __maybe_unused, __u8 match_type __maybe_unused, __u8 is_audited __maybe_unused)\n",
        "{\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_full_len",
        "policy_verdict_filter_allow"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "eth_addrcmp": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 25,
      "endLine": 35,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/eth.h",
      "funcName": "eth_addrcmp",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */"
        },
        {
          "start_line": 2,
          "end_line": 2,
          "text": "/* Copyright Authors of Cilium */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const union macaddr *a",
        " const union macaddr *b"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int eth_addrcmp (const union macaddr *a, const union macaddr *b)\n",
        "{\n",
        "    int tmp;\n",
        "    tmp = a->p1 - b->p1;\n",
        "    if (!tmp)\n",
        "        tmp = a->p2 - b->p2;\n",
        "    return tmp;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "eth_is_bcast": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 37,
      "endLine": 48,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/eth.h",
      "funcName": "eth_is_bcast",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const union macaddr *a"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int eth_is_bcast (const union macaddr *a)\n",
        "{\n",
        "    union macaddr bcast;\n",
        "    bcast.p1 = 0xffffffff;\n",
        "    bcast.p2 = 0xffff;\n",
        "    if (!eth_addrcmp (a, &bcast))\n",
        "        return 1;\n",
        "    else\n",
        "        return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "eth_addrcmp"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "eth_load_saddr": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 50,
      "endLine": 54,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/eth.h",
      "funcName": "eth_load_saddr",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " __u8 *mac",
        " int off"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int eth_load_saddr (struct  __ctx_buff *ctx, __u8 *mac, int off)\n",
        "{\n",
        "    return ctx_load_bytes (ctx, off + ETH_ALEN, mac, ETH_ALEN);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "eth_store_saddr_aligned": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 56,
      "endLine": 60,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/eth.h",
      "funcName": "eth_store_saddr_aligned",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " const __u8 *mac",
        " int off"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int eth_store_saddr_aligned (struct  __ctx_buff *ctx, const __u8 *mac, int off)\n",
        "{\n",
        "    return ctx_store_bytes (ctx, off + ETH_ALEN, mac, ETH_ALEN, 0);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "eth_store_saddr": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 62,
      "endLine": 79,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/eth.h",
      "funcName": "eth_store_saddr",
      "developer_inline_comments": [
        {
          "start_line": 73,
          "end_line": 75,
          "text": "/* Need to use builtin here since mac came potentially from\n\t * struct bpf_fib_lookup where it's not aligned on stack. :(\n\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " const __u8 *mac",
        " int off"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int eth_store_saddr (struct  __ctx_buff *ctx, const __u8 *mac, int off)\n",
        "{\n",
        "\n",
        "#if !CTX_DIRECT_WRITE_OK\n",
        "    return eth_store_saddr_aligned (ctx, mac, off);\n",
        "\n",
        "#else\n",
        "    void *data_end = ctx_data_end (ctx);\n",
        "    void *data = ctx_data (ctx);\n",
        "    if (ctx_no_room (data + off + ETH_ALEN * 2, data_end))\n",
        "        return -EFAULT;\n",
        "    __bpf_memcpy_builtin (data + off + ETH_ALEN, mac, ETH_ALEN);\n",
        "    return 0;\n",
        "\n",
        "#endif\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_no_room",
        "ctx_data_end",
        "ctx_data",
        "eth_store_saddr_aligned",
        "__bpf_memcpy_builtin"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "eth_load_daddr": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 81,
      "endLine": 85,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/eth.h",
      "funcName": "eth_load_daddr",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " __u8 *mac",
        " int off"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int eth_load_daddr (struct  __ctx_buff *ctx, __u8 *mac, int off)\n",
        "{\n",
        "    return ctx_load_bytes (ctx, off, mac, ETH_ALEN);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "eth_store_daddr_aligned": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 87,
      "endLine": 91,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/eth.h",
      "funcName": "eth_store_daddr_aligned",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " const __u8 *mac",
        " int off"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int eth_store_daddr_aligned (struct  __ctx_buff *ctx, const __u8 *mac, int off)\n",
        "{\n",
        "    return ctx_store_bytes (ctx, off, mac, ETH_ALEN, 0);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "eth_store_daddr": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 93,
      "endLine": 110,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/eth.h",
      "funcName": "eth_store_daddr",
      "developer_inline_comments": [
        {
          "start_line": 104,
          "end_line": 106,
          "text": "/* Need to use builtin here since mac came potentially from\n\t * struct bpf_fib_lookup where it's not aligned on stack. :(\n\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " const __u8 *mac",
        " int off"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int eth_store_daddr (struct  __ctx_buff *ctx, const __u8 *mac, int off)\n",
        "{\n",
        "\n",
        "#if !CTX_DIRECT_WRITE_OK\n",
        "    return eth_store_daddr_aligned (ctx, mac, off);\n",
        "\n",
        "#else\n",
        "    void *data_end = ctx_data_end (ctx);\n",
        "    void *data = ctx_data (ctx);\n",
        "    if (ctx_no_room (data + off + ETH_ALEN, data_end))\n",
        "        return -EFAULT;\n",
        "    __bpf_memcpy_builtin (data + off, mac, ETH_ALEN);\n",
        "    return 0;\n",
        "\n",
        "#endif\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_no_room",
        "ctx_data_end",
        "ctx_data",
        "__bpf_memcpy_builtin",
        "eth_store_daddr_aligned"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "eth_store_proto": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 112,
      "endLine": 117,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/eth.h",
      "funcName": "eth_store_proto",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " const __u16 proto",
        " int off"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int eth_store_proto (struct  __ctx_buff *ctx, const __u16 proto, int off)\n",
        "{\n",
        "    return ctx_store_bytes (ctx, off + ETH_ALEN + ETH_ALEN, &proto, sizeof (proto), 0);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "is_v4_in_v6": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 22,
      "endLine": 35,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat_46x64.h",
      "funcName": "is_v4_in_v6",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */"
        },
        {
          "start_line": 2,
          "end_line": 2,
          "text": "/* Copyright Authors of Cilium */"
        },
        {
          "start_line": 24,
          "end_line": 24,
          "text": "/* Check for ::FFFF:<IPv4 address>. */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const union v6addr *daddr"
      ],
      "output": "static__always_inline__maybe_unusedbool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused bool is_v4_in_v6 (const union v6addr *daddr)\n",
        "{\n",
        "    union v6addr dprobe = {\n",
        "        .addr [10] = 0xff,\n",
        "        .addr [11] = 0xff,}\n",
        "    ;\n",
        "    union v6addr dmasked = {\n",
        "        .d1 = daddr->d1,}\n",
        "    ;\n",
        "    dmasked.p3 = daddr->p3;\n",
        "    return ipv6_addrcmp (&dprobe, &dmasked) == 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "ipv6_addrcmp"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "build_v4_in_v6": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 37,
      "endLine": 44,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat_46x64.h",
      "funcName": "build_v4_in_v6",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "union v6addr *daddr",
        " __be32 v4"
      ],
      "output": "static__always_inline__maybe_unusedvoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused void build_v4_in_v6 (union v6addr *daddr, __be32 v4)\n",
        "{\n",
        "    memset (daddr, 0, sizeof (*daddr));\n",
        "    daddr->addr[10] = 0xff;\n",
        "    daddr->addr[11] = 0xff;\n",
        "    daddr->p4 = v4;\n",
        "}\n"
      ],
      "called_function_list": [
        "memset"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "build_v4_from_v6": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 46,
      "endLine": 50,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat_46x64.h",
      "funcName": "build_v4_from_v6",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const union v6addr *v6",
        " __be32 *daddr"
      ],
      "output": "static__always_inline__maybe_unusedvoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused void build_v4_from_v6 (const union v6addr *v6, __be32 *daddr)\n",
        "{\n",
        "    *daddr = v6->p4;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "get_csum_offset": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 52,
      "endLine": 74,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat_46x64.h",
      "funcName": "get_csum_offset",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "__u8 protocol"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int get_csum_offset (__u8 protocol)\n",
        "{\n",
        "    int csum_off;\n",
        "    switch (protocol) {\n",
        "    case IPPROTO_TCP :\n",
        "        csum_off = TCP_CSUM_OFF;\n",
        "        break;\n",
        "    case IPPROTO_UDP :\n",
        "        csum_off = UDP_CSUM_OFF;\n",
        "        break;\n",
        "    case IPPROTO_ICMP :\n",
        "        csum_off = (offsetof (struct icmphdr, checksum));\n",
        "        break;\n",
        "    case IPPROTO_ICMPV6 :\n",
        "        csum_off = (offsetof (struct icmp6hdr, icmp6_cksum));\n",
        "        break;\n",
        "    default :\n",
        "        return DROP_UNKNOWN_L4;\n",
        "    }\n",
        "    return csum_off;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "icmp4_to_icmp6": [
    {
      "capabilities": [
        {
          "capability": "read_skb",
          "read_skb": [
            {
              "Project": "cilium",
              "Return Type": "s64",
              "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ",
              "Return": " The checksum result, or a negative error code in case of failure.",
              "Function Name": "csum_diff",
              "Input Params": [
                "{Type: __be32 ,Var: *from}",
                "{Type:  u32 ,Var: from_size}",
                "{Type:  __be32 ,Var: *to}",
                "{Type:  u32 ,Var: to_size}",
                "{Type:  __wsum ,Var: seed}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "xdp",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "lwt_seg6local"
              ],
              "capabilities": [
                "read_skb"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 76,
      "endLine": 154,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat_46x64.h",
      "funcName": "icmp4_to_icmp6",
      "developer_inline_comments": [
        {
          "start_line": 113,
          "end_line": 113,
          "text": "/* FIXME */"
        },
        {
          "start_line": 143,
          "end_line": 143,
          "text": "/* FIXME */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " int nh_off"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "csum_diff"
      ],
      "compatibleHookpoints": [
        "lwt_seg6local",
        "sched_act",
        "xdp",
        "lwt_xmit",
        "sched_cls",
        "lwt_in",
        "lwt_out"
      ],
      "source": [
        "static __always_inline int icmp4_to_icmp6 (struct  __ctx_buff *ctx, int nh_off)\n",
        "{\n",
        "    struct icmphdr icmp4 __align_stack_8;\n",
        "    struct icmp6hdr icmp6 __align_stack_8 = {}\n",
        "    ;\n",
        "    if (ctx_load_bytes (ctx, nh_off, &icmp4, sizeof (icmp4)) < 0)\n",
        "        return DROP_INVALID;\n",
        "    icmp6.icmp6_cksum = icmp4.checksum;\n",
        "    switch (icmp4.type) {\n",
        "    case ICMP_ECHO :\n",
        "        icmp6.icmp6_type = ICMPV6_ECHO_REQUEST;\n",
        "        icmp6.icmp6_identifier = icmp4.un.echo.id;\n",
        "        icmp6.icmp6_sequence = icmp4.un.echo.sequence;\n",
        "        break;\n",
        "    case ICMP_ECHOREPLY :\n",
        "        icmp6.icmp6_type = ICMPV6_ECHO_REPLY;\n",
        "        icmp6.icmp6_identifier = icmp4.un.echo.id;\n",
        "        icmp6.icmp6_sequence = icmp4.un.echo.sequence;\n",
        "        break;\n",
        "    case ICMP_DEST_UNREACH :\n",
        "        icmp6.icmp6_type = ICMPV6_DEST_UNREACH;\n",
        "        switch (icmp4.code) {\n",
        "        case ICMP_NET_UNREACH :\n",
        "        case ICMP_HOST_UNREACH :\n",
        "            icmp6.icmp6_code = ICMPV6_NOROUTE;\n",
        "            break;\n",
        "        case ICMP_PROT_UNREACH :\n",
        "            icmp6.icmp6_type = ICMPV6_PARAMPROB;\n",
        "            icmp6.icmp6_code = ICMPV6_UNK_NEXTHDR;\n",
        "            icmp6.icmp6_pointer = 6;\n",
        "            break;\n",
        "        case ICMP_PORT_UNREACH :\n",
        "            icmp6.icmp6_code = ICMPV6_PORT_UNREACH;\n",
        "            break;\n",
        "        case ICMP_FRAG_NEEDED :\n",
        "            icmp6.icmp6_type = ICMPV6_PKT_TOOBIG;\n",
        "            icmp6.icmp6_code = 0;\n",
        "            if (icmp4.un.frag.mtu)\n",
        "                icmp6.icmp6_mtu = bpf_htonl (bpf_ntohs (icmp4.un.frag.mtu));\n",
        "            else\n",
        "                icmp6.icmp6_mtu = bpf_htonl (1500);\n",
        "            break;\n",
        "        case ICMP_SR_FAILED :\n",
        "            icmp6.icmp6_code = ICMPV6_NOROUTE;\n",
        "            break;\n",
        "        case ICMP_NET_UNKNOWN :\n",
        "        case ICMP_HOST_UNKNOWN :\n",
        "        case ICMP_HOST_ISOLATED :\n",
        "        case ICMP_NET_UNR_TOS :\n",
        "        case ICMP_HOST_UNR_TOS :\n",
        "            icmp6.icmp6_code = 0;\n",
        "            break;\n",
        "        case ICMP_NET_ANO :\n",
        "        case ICMP_HOST_ANO :\n",
        "        case ICMP_PKT_FILTERED :\n",
        "            icmp6.icmp6_code = ICMPV6_ADM_PROHIBITED;\n",
        "            break;\n",
        "        default :\n",
        "            return DROP_UNKNOWN_ICMP_CODE;\n",
        "        }\n",
        "        break;\n",
        "    case ICMP_TIME_EXCEEDED :\n",
        "        icmp6.icmp6_type = ICMPV6_TIME_EXCEED;\n",
        "        break;\n",
        "    case ICMP_PARAMETERPROB :\n",
        "        icmp6.icmp6_type = ICMPV6_PARAMPROB;\n",
        "        icmp6.icmp6_pointer = 6;\n",
        "        break;\n",
        "    default :\n",
        "        return DROP_UNKNOWN_ICMP_TYPE;\n",
        "    }\n",
        "    if (ctx_store_bytes (ctx, nh_off, &icmp6, sizeof (icmp6), 0) < 0)\n",
        "        return DROP_WRITE_ERROR;\n",
        "    icmp4.checksum = 0;\n",
        "    icmp6.icmp6_cksum = 0;\n",
        "    return csum_diff (&icmp4, sizeof (icmp4), &icmp6, sizeof (icmp6), 0);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "icmp6_to_icmp4": [
    {
      "capabilities": [
        {
          "capability": "read_skb",
          "read_skb": [
            {
              "Project": "cilium",
              "Return Type": "s64",
              "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ",
              "Return": " The checksum result, or a negative error code in case of failure.",
              "Function Name": "csum_diff",
              "Input Params": [
                "{Type: __be32 ,Var: *from}",
                "{Type:  u32 ,Var: from_size}",
                "{Type:  __be32 ,Var: *to}",
                "{Type:  u32 ,Var: to_size}",
                "{Type:  __wsum ,Var: seed}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "xdp",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "lwt_seg6local"
              ],
              "capabilities": [
                "read_skb"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 156,
      "endLine": 231,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat_46x64.h",
      "funcName": "icmp6_to_icmp4",
      "developer_inline_comments": [
        {
          "start_line": 197,
          "end_line": 197,
          "text": "/* FIXME */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " int nh_off"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "csum_diff"
      ],
      "compatibleHookpoints": [
        "lwt_seg6local",
        "sched_act",
        "xdp",
        "lwt_xmit",
        "sched_cls",
        "lwt_in",
        "lwt_out"
      ],
      "source": [
        "static __always_inline int icmp6_to_icmp4 (struct  __ctx_buff *ctx, int nh_off)\n",
        "{\n",
        "    struct icmphdr icmp4 __align_stack_8 = {}\n",
        "    ;\n",
        "    struct icmp6hdr icmp6 __align_stack_8;\n",
        "    __u32 mtu;\n",
        "    if (ctx_load_bytes (ctx, nh_off, &icmp6, sizeof (icmp6)) < 0)\n",
        "        return DROP_INVALID;\n",
        "    icmp4.checksum = icmp6.icmp6_cksum;\n",
        "    switch (icmp6.icmp6_type) {\n",
        "    case ICMPV6_ECHO_REQUEST :\n",
        "        icmp4.type = ICMP_ECHO;\n",
        "        icmp4.un.echo.id = icmp6.icmp6_identifier;\n",
        "        icmp4.un.echo.sequence = icmp6.icmp6_sequence;\n",
        "        break;\n",
        "    case ICMPV6_ECHO_REPLY :\n",
        "        icmp4.type = ICMP_ECHOREPLY;\n",
        "        icmp4.un.echo.id = icmp6.icmp6_identifier;\n",
        "        icmp4.un.echo.sequence = icmp6.icmp6_sequence;\n",
        "        break;\n",
        "    case ICMPV6_DEST_UNREACH :\n",
        "        icmp4.type = ICMP_DEST_UNREACH;\n",
        "        switch (icmp6.icmp6_code) {\n",
        "        case ICMPV6_NOROUTE :\n",
        "        case ICMPV6_NOT_NEIGHBOUR :\n",
        "        case ICMPV6_ADDR_UNREACH :\n",
        "            icmp4.code = ICMP_HOST_UNREACH;\n",
        "            break;\n",
        "        case ICMPV6_ADM_PROHIBITED :\n",
        "            icmp4.code = ICMP_HOST_ANO;\n",
        "            break;\n",
        "        case ICMPV6_PORT_UNREACH :\n",
        "            icmp4.code = ICMP_PORT_UNREACH;\n",
        "            break;\n",
        "        default :\n",
        "            return DROP_UNKNOWN_ICMP6_CODE;\n",
        "        }\n",
        "        break;\n",
        "    case ICMPV6_PKT_TOOBIG :\n",
        "        icmp4.type = ICMP_DEST_UNREACH;\n",
        "        icmp4.code = ICMP_FRAG_NEEDED;\n",
        "        if (icmp6.icmp6_mtu) {\n",
        "            mtu = bpf_ntohl (icmp6.icmp6_mtu);\n",
        "            icmp4.un.frag.mtu = bpf_htons ((__u16) mtu);\n",
        "        }\n",
        "        else {\n",
        "            icmp4.un.frag.mtu = bpf_htons (1500);\n",
        "        }\n",
        "        break;\n",
        "    case ICMPV6_TIME_EXCEED :\n",
        "        icmp4.type = ICMP_TIME_EXCEEDED;\n",
        "        icmp4.code = icmp6.icmp6_code;\n",
        "        break;\n",
        "    case ICMPV6_PARAMPROB :\n",
        "        switch (icmp6.icmp6_code) {\n",
        "        case ICMPV6_HDR_FIELD :\n",
        "            icmp4.type = ICMP_PARAMETERPROB;\n",
        "            icmp4.code = 0;\n",
        "            break;\n",
        "        case ICMPV6_UNK_NEXTHDR :\n",
        "            icmp4.type = ICMP_DEST_UNREACH;\n",
        "            icmp4.code = ICMP_PROT_UNREACH;\n",
        "            break;\n",
        "        default :\n",
        "            return DROP_UNKNOWN_ICMP6_CODE;\n",
        "        }\n",
        "        break;\n",
        "    default :\n",
        "        return DROP_UNKNOWN_ICMP6_TYPE;\n",
        "    }\n",
        "    if (ctx_store_bytes (ctx, nh_off, &icmp4, sizeof (icmp4), 0) < 0)\n",
        "        return DROP_WRITE_ERROR;\n",
        "    icmp4.checksum = 0;\n",
        "    icmp6.icmp6_cksum = 0;\n",
        "    return csum_diff (&icmp6, sizeof (icmp6), &icmp4, sizeof (icmp4), 0);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ipv4_to_ipv6": [
    {
      "capabilities": [
        {
          "capability": "read_skb",
          "read_skb": [
            {
              "Project": "cilium",
              "Return Type": "s64",
              "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ",
              "Return": " The checksum result, or a negative error code in case of failure.",
              "Function Name": "csum_diff",
              "Input Params": [
                "{Type: __be32 ,Var: *from}",
                "{Type:  u32 ,Var: from_size}",
                "{Type:  __be32 ,Var: *to}",
                "{Type:  u32 ,Var: to_size}",
                "{Type:  __wsum ,Var: seed}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "xdp",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "lwt_seg6local"
              ],
              "capabilities": [
                "read_skb"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 233,
      "endLine": 288,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat_46x64.h",
      "funcName": "ipv4_to_ipv6",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " int nh_off",
        " const union v6addr *src6",
        " const union v6addr *dst6"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "csum_diff"
      ],
      "compatibleHookpoints": [
        "lwt_seg6local",
        "sched_act",
        "xdp",
        "lwt_xmit",
        "sched_cls",
        "lwt_in",
        "lwt_out"
      ],
      "source": [
        "static __always_inline int ipv4_to_ipv6 (struct  __ctx_buff *ctx, int nh_off, const union v6addr *src6, const union v6addr *dst6)\n",
        "{\n",
        "    __be16 protocol = bpf_htons (ETH_P_IPV6);\n",
        "    __u64 csum_flags = BPF_F_PSEUDO_HDR;\n",
        "    struct ipv6hdr v6 = {}\n",
        "    ;\n",
        "    struct iphdr v4;\n",
        "    int csum_off;\n",
        "    __be32 csum;\n",
        "    __be16 v4hdr_len;\n",
        "    if (ctx_load_bytes (ctx, nh_off, &v4, sizeof (v4)) < 0)\n",
        "        return DROP_INVALID;\n",
        "    if (ipv4_hdrlen (&v4) != sizeof (v4))\n",
        "        return DROP_INVALID_EXTHDR;\n",
        "    v6.version = 0x6;\n",
        "    v6.saddr.in6_u.u6_addr32[0] = src6->p1;\n",
        "    v6.saddr.in6_u.u6_addr32[1] = src6->p2;\n",
        "    v6.saddr.in6_u.u6_addr32[2] = src6->p3;\n",
        "    v6.saddr.in6_u.u6_addr32[3] = src6->p4;\n",
        "    v6.daddr.in6_u.u6_addr32[0] = dst6->p1;\n",
        "    v6.daddr.in6_u.u6_addr32[1] = dst6->p2;\n",
        "    v6.daddr.in6_u.u6_addr32[2] = dst6->p3;\n",
        "    v6.daddr.in6_u.u6_addr32[3] = dst6->p4;\n",
        "    if (v4.protocol == IPPROTO_ICMP)\n",
        "        v6.nexthdr = IPPROTO_ICMPV6;\n",
        "    else\n",
        "        v6.nexthdr = v4.protocol;\n",
        "    v6.hop_limit = v4.ttl;\n",
        "    v4hdr_len = (__be16) (v4.ihl << 2);\n",
        "    v6.payload_len = bpf_htons (bpf_ntohs (v4.tot_len) - v4hdr_len);\n",
        "    if (ctx_change_proto (ctx, bpf_htons (ETH_P_IPV6), 0) < 0)\n",
        "        return DROP_WRITE_ERROR;\n",
        "    if (ctx_store_bytes (ctx, nh_off, &v6, sizeof (v6), 0) < 0 || ctx_store_bytes (ctx, nh_off - 2, &protocol, 2, 0) < 0)\n",
        "        return DROP_WRITE_ERROR;\n",
        "    if (v4.protocol == IPPROTO_ICMP) {\n",
        "        csum = icmp4_to_icmp6 (ctx, nh_off + sizeof (v6));\n",
        "        csum = ipv6_pseudohdr_checksum (& v6, IPPROTO_ICMPV6, bpf_ntohs (v6.payload_len), csum);\n",
        "    }\n",
        "    else {\n",
        "        csum = 0;\n",
        "        csum = csum_diff (& v4.saddr, 4, & v6.saddr, 16, csum);\n",
        "        csum = csum_diff (& v4.daddr, 4, & v6.daddr, 16, csum);\n",
        "        if (v4.protocol == IPPROTO_UDP)\n",
        "            csum_flags |= BPF_F_MARK_MANGLED_0;\n",
        "    }\n",
        "    csum_off = get_csum_offset (v6.nexthdr);\n",
        "    if (csum_off < 0)\n",
        "        return csum_off;\n",
        "    csum_off += sizeof (struct ipv6hdr);\n",
        "    if (l4_csum_replace (ctx, nh_off + csum_off, 0, csum, csum_flags) < 0)\n",
        "        return DROP_CSUM_L4;\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "ipv4_hdrlen",
        "get_csum_offset",
        "icmp4_to_icmp6",
        "ipv6_pseudohdr_checksum",
        "ctx_change_proto"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ipv6_to_ipv4": [
    {
      "capabilities": [
        {
          "capability": "read_skb",
          "read_skb": [
            {
              "Project": "cilium",
              "Return Type": "s64",
              "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ",
              "Return": " The checksum result, or a negative error code in case of failure.",
              "Function Name": "csum_diff",
              "Input Params": [
                "{Type: __be32 ,Var: *from}",
                "{Type:  u32 ,Var: from_size}",
                "{Type:  __be32 ,Var: *to}",
                "{Type:  u32 ,Var: to_size}",
                "{Type:  __wsum ,Var: seed}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "xdp",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "lwt_seg6local"
              ],
              "capabilities": [
                "read_skb"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 290,
      "endLine": 345,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat_46x64.h",
      "funcName": "ipv6_to_ipv4",
      "developer_inline_comments": [
        {
          "start_line": 302,
          "end_line": 302,
          "text": "/* Drop frames which carry extensions headers */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " __be32 src4",
        " __be32 dst4"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "csum_diff"
      ],
      "compatibleHookpoints": [
        "lwt_seg6local",
        "sched_act",
        "xdp",
        "lwt_xmit",
        "sched_cls",
        "lwt_in",
        "lwt_out"
      ],
      "source": [
        "static __always_inline int ipv6_to_ipv4 (struct  __ctx_buff *ctx, __be32 src4, __be32 dst4)\n",
        "{\n",
        "    __be16 protocol = bpf_htons (ETH_P_IP);\n",
        "    __u64 csum_flags = BPF_F_PSEUDO_HDR;\n",
        "    int csum_off, nh_off = ETH_HLEN;\n",
        "    struct ipv6hdr v6;\n",
        "    struct iphdr v4 = {}\n",
        "    ;\n",
        "    __be32 csum = 0;\n",
        "    if (ctx_load_bytes (ctx, nh_off, &v6, sizeof (v6)) < 0)\n",
        "        return DROP_INVALID;\n",
        "    if (ipv6_hdrlen (ctx, &v6.nexthdr) != sizeof (v6))\n",
        "        return DROP_INVALID_EXTHDR;\n",
        "    v4.ihl = 0x5;\n",
        "    v4.version = 0x4;\n",
        "    v4.saddr = src4;\n",
        "    v4.daddr = dst4;\n",
        "    if (v6.nexthdr == IPPROTO_ICMPV6)\n",
        "        v4.protocol = IPPROTO_ICMP;\n",
        "    else\n",
        "        v4.protocol = v6.nexthdr;\n",
        "    v4.ttl = v6.hop_limit;\n",
        "    v4.tot_len = bpf_htons (bpf_ntohs (v6.payload_len) + sizeof (v4));\n",
        "    csum_off = offsetof (struct iphdr, check);\n",
        "    csum = csum_diff (NULL, 0, & v4, sizeof (v4), csum);\n",
        "    if (ctx_change_proto (ctx, bpf_htons (ETH_P_IP), 0) < 0)\n",
        "        return DROP_WRITE_ERROR;\n",
        "    if (ctx_store_bytes (ctx, nh_off, &v4, sizeof (v4), 0) < 0 || ctx_store_bytes (ctx, nh_off - 2, &protocol, 2, 0) < 0)\n",
        "        return DROP_WRITE_ERROR;\n",
        "    if (l3_csum_replace (ctx, nh_off + csum_off, 0, csum, 0) < 0)\n",
        "        return DROP_CSUM_L3;\n",
        "    if (v6.nexthdr == IPPROTO_ICMPV6) {\n",
        "        __be32 csum1 = 0;\n",
        "        csum = icmp6_to_icmp4 (ctx, nh_off + sizeof (v4));\n",
        "        csum1 = ipv6_pseudohdr_checksum (& v6, IPPROTO_ICMPV6, bpf_ntohs (v6.payload_len), 0);\n",
        "        csum = csum_sub (csum, csum1);\n",
        "    }\n",
        "    else {\n",
        "        csum = 0;\n",
        "        csum = csum_diff (& v6.saddr, 16, & v4.saddr, 4, csum);\n",
        "        csum = csum_diff (& v6.daddr, 16, & v4.daddr, 4, csum);\n",
        "        if (v4.protocol == IPPROTO_UDP)\n",
        "            csum_flags |= BPF_F_MARK_MANGLED_0;\n",
        "    }\n",
        "    csum_off = get_csum_offset (v4.protocol);\n",
        "    if (csum_off < 0)\n",
        "        return csum_off;\n",
        "    csum_off += sizeof (struct iphdr);\n",
        "    if (l4_csum_replace (ctx, nh_off + csum_off, 0, csum, csum_flags) < 0)\n",
        "        return DROP_CSUM_L4;\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "ipv6_hdrlen",
        "csum_sub",
        "get_csum_offset",
        "ipv6_pseudohdr_checksum",
        "icmp6_to_icmp4",
        "ctx_change_proto"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__snat_clamp_port_range": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 51,
      "endLine": 55,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h",
      "funcName": "__snat_clamp_port_range",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */"
        },
        {
          "start_line": 2,
          "end_line": 2,
          "text": "/* Copyright Authors of Cilium */"
        },
        {
          "start_line": 4,
          "end_line": 4,
          "text": "/* Simple NAT engine in BPF. */"
        },
        {
          "start_line": 30,
          "end_line": 30,
          "text": "/* Only single bit used. */"
        },
        {
          "start_line": 31,
          "end_line": 31,
          "text": "/* Future use. */"
        },
        {
          "start_line": 32,
          "end_line": 32,
          "text": "/* Future use. */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "__u16 start",
        " __u16 end",
        " __u16 val"
      ],
      "output": "static__always_inline__be16",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __be16 __snat_clamp_port_range (__u16 start, __u16 end, __u16 val)\n",
        "{\n",
        "    return (val % (__u16) (end - start)) + start;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__snat_try_keep_port": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 57,
      "endLine": 62,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h",
      "funcName": "__snat_try_keep_port",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "__u16 start",
        " __u16 end",
        " __u16 val"
      ],
      "output": "static__always_inline__maybe_unused__be16",
      "helper": [
        "get_prandom_u32"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused __be16 __snat_try_keep_port (__u16 start, __u16 end, __u16 val)\n",
        "{\n",
        "    return val >= start && val <= end ? val : __snat_clamp_port_range (start, end, (__u16) get_prandom_u32 ());\n",
        "}\n"
      ],
      "called_function_list": [
        "__snat_clamp_port_range"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__snat_lookup": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 64,
      "endLine": 68,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h",
      "funcName": "__snat_lookup",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [
        " map"
      ],
      "input": [
        "const void *map",
        " const void *tuple"
      ],
      "output": "static__always_inline__maybe_unusedvoid",
      "helper": [
        "map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused void *__snat_lookup (const void *map, const void *tuple)\n",
        "{\n",
        "    return map_lookup_elem (map, tuple);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__snat_update": [
    {
      "capabilities": [
        {
          "capability": "map_update",
          "map_update": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "map_update_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}",
                "{Type:  const void ,Var: *value}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_update"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 70,
      "endLine": 83,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h",
      "funcName": "__snat_update",
      "developer_inline_comments": [],
      "updateMaps": [
        " map"
      ],
      "readMaps": [],
      "input": [
        "const void *map",
        " const void *otuple",
        " const void *ostate",
        " const void *rtuple",
        " const void *rstate"
      ],
      "output": "static__always_inline__maybe_unusedint",
      "helper": [
        "map_update_elem",
        "map_delete_elem"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused int __snat_update (const void *map, const void *otuple, const void *ostate, const void *rtuple, const void *rstate)\n",
        "{\n",
        "    int ret;\n",
        "    ret = map_update_elem (map, rtuple, rstate, BPF_NOEXIST);\n",
        "    if (!ret) {\n",
        "        ret = map_update_elem (map, otuple, ostate, BPF_NOEXIST);\n",
        "        if (ret)\n",
        "            map_delete_elem (map, rtuple);\n",
        "    }\n",
        "    return ret;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__snat_delete": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 85,
      "endLine": 90,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h",
      "funcName": "__snat_delete",
      "developer_inline_comments": [],
      "updateMaps": [
        " map"
      ],
      "readMaps": [],
      "input": [
        "const void *map",
        " const void *otuple",
        " const void *rtuple"
      ],
      "output": "static__always_inline__maybe_unusedvoid",
      "helper": [
        "map_delete_elem"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused void __snat_delete (const void *map, const void *otuple, const void *rtuple)\n",
        "{\n",
        "    map_delete_elem (map, otuple);\n",
        "    map_delete_elem (map, rtuple);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "snat_v4_lookup": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 136,
      "endLine": 140,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h",
      "funcName": "snat_v4_lookup",
      "developer_inline_comments": [
        {
          "start_line": 108,
          "end_line": 108,
          "text": "/* host endianness */"
        },
        {
          "start_line": 109,
          "end_line": 109,
          "text": "/* host endianness */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct ipv4_ct_tuple *tuple"
      ],
      "output": "static__always_inlinestructipv4_nat_entry",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline struct ipv4_nat_entry *snat_v4_lookup (const struct ipv4_ct_tuple *tuple)\n",
        "{\n",
        "    return __snat_lookup (&SNAT_MAPPING_IPV4, tuple);\n",
        "}\n"
      ],
      "called_function_list": [
        "__snat_lookup"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "snat_v4_update": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 142,
      "endLine": 149,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h",
      "funcName": "snat_v4_update",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct ipv4_ct_tuple *otuple",
        " const struct ipv4_nat_entry *ostate",
        " const struct ipv4_ct_tuple *rtuple",
        " const struct ipv4_nat_entry *rstate"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int snat_v4_update (const struct ipv4_ct_tuple *otuple, const struct ipv4_nat_entry *ostate, const struct ipv4_ct_tuple *rtuple, const struct ipv4_nat_entry *rstate)\n",
        "{\n",
        "    return __snat_update (&SNAT_MAPPING_IPV4, otuple, ostate, rtuple, rstate);\n",
        "}\n"
      ],
      "called_function_list": [
        "__snat_update"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "snat_v4_delete": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 151,
      "endLine": 155,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h",
      "funcName": "snat_v4_delete",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct ipv4_ct_tuple *otuple",
        " const struct ipv4_ct_tuple *rtuple"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void snat_v4_delete (const struct ipv4_ct_tuple *otuple, const struct ipv4_ct_tuple *rtuple)\n",
        "{\n",
        "    __snat_delete (&SNAT_MAPPING_IPV4, otuple, rtuple);\n",
        "}\n"
      ],
      "called_function_list": [
        "__snat_delete"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "snat_v4_swap_tuple": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 157,
      "endLine": 168,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h",
      "funcName": "snat_v4_swap_tuple",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct ipv4_ct_tuple *otuple",
        " struct ipv4_ct_tuple *rtuple"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void snat_v4_swap_tuple (const struct ipv4_ct_tuple *otuple, struct ipv4_ct_tuple *rtuple)\n",
        "{\n",
        "    memset (rtuple, 0, sizeof (*rtuple));\n",
        "    rtuple->nexthdr = otuple->nexthdr;\n",
        "    rtuple->daddr = otuple->saddr;\n",
        "    rtuple->saddr = otuple->daddr;\n",
        "    rtuple->dport = otuple->sport;\n",
        "    rtuple->sport = otuple->dport;\n",
        "    rtuple->flags = otuple->flags == NAT_DIR_EGRESS ? NAT_DIR_INGRESS : NAT_DIR_EGRESS;\n",
        "}\n"
      ],
      "called_function_list": [
        "memset"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "snat_v4_reverse_tuple": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 170,
      "endLine": 183,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h",
      "funcName": "snat_v4_reverse_tuple",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct ipv4_ct_tuple *otuple",
        " struct ipv4_ct_tuple *rtuple"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int snat_v4_reverse_tuple (const struct ipv4_ct_tuple *otuple, struct ipv4_ct_tuple *rtuple)\n",
        "{\n",
        "    struct ipv4_nat_entry *ostate;\n",
        "    ostate = snat_v4_lookup (otuple);\n",
        "    if (ostate) {\n",
        "        snat_v4_swap_tuple (otuple, rtuple);\n",
        "        rtuple->daddr = ostate->to_saddr;\n",
        "        rtuple->dport = ostate->to_sport;\n",
        "    }\n",
        "    return ostate ? 0 : -1;\n",
        "}\n"
      ],
      "called_function_list": [
        "snat_v4_swap_tuple",
        "snat_v4_lookup"
      ],
      "call_depth": 4,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "snat_v4_ct_canonicalize": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 185,
      "endLine": 193,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h",
      "funcName": "snat_v4_ct_canonicalize",
      "developer_inline_comments": [
        {
          "start_line": 190,
          "end_line": 190,
          "text": "/* Workaround #5848. */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct ipv4_ct_tuple *otuple"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void snat_v4_ct_canonicalize (struct ipv4_ct_tuple *otuple)\n",
        "{\n",
        "    __be32 addr = otuple->saddr;\n",
        "    otuple->flags = NAT_DIR_EGRESS;\n",
        "    otuple->saddr = otuple->daddr;\n",
        "    otuple->daddr = addr;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "snat_v4_delete_tuples": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 195,
      "endLine": 204,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h",
      "funcName": "snat_v4_delete_tuples",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct ipv4_ct_tuple *otuple"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void snat_v4_delete_tuples (struct ipv4_ct_tuple *otuple)\n",
        "{\n",
        "    struct ipv4_ct_tuple rtuple;\n",
        "    if (otuple->flags & TUPLE_F_IN)\n",
        "        return;\n",
        "    snat_v4_ct_canonicalize (otuple);\n",
        "    if (!snat_v4_reverse_tuple (otuple, &rtuple))\n",
        "        snat_v4_delete (otuple, &rtuple);\n",
        "}\n"
      ],
      "called_function_list": [
        "snat_v4_delete",
        "snat_v4_reverse_tuple",
        "snat_v4_ct_canonicalize"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 583,
      "endLine": 586,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h",
      "funcName": "snat_v4_delete_tuples",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct ipv4_ct_tuple * tuple __maybe_unused"
      ],
      "output": "static__always_inline__maybe_unusedvoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused void snat_v4_delete_tuples (struct ipv4_ct_tuple * tuple __maybe_unused)\n",
        "{\n",
        "}\n"
      ],
      "called_function_list": [
        "snat_v4_delete",
        "snat_v4_reverse_tuple",
        "snat_v4_ct_canonicalize"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "snat_v4_new_mapping": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 206,
      "endLine": 258,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h",
      "funcName": "snat_v4_new_mapping",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " struct ipv4_ct_tuple *otuple",
        " struct ipv4_nat_entry *ostate",
        " const struct ipv4_nat_target *target"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "get_prandom_u32",
        "send_signal"
      ],
      "compatibleHookpoints": [
        "perf_event",
        "raw_tracepoint_writable",
        "kprobe",
        "tracepoint",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int snat_v4_new_mapping (struct  __ctx_buff *ctx, struct ipv4_ct_tuple *otuple, struct ipv4_nat_entry *ostate, const struct ipv4_nat_target *target)\n",
        "{\n",
        "    int ret = DROP_NAT_NO_MAPPING, retries;\n",
        "    struct ipv4_nat_entry rstate;\n",
        "    struct ipv4_ct_tuple rtuple;\n",
        "    __u16 port;\n",
        "    memset (&rstate, 0, sizeof (rstate));\n",
        "    memset (ostate, 0, sizeof (*ostate));\n",
        "    rstate.to_daddr = otuple->saddr;\n",
        "    rstate.to_dport = otuple->sport;\n",
        "    ostate->to_saddr = target->addr;\n",
        "    snat_v4_swap_tuple (otuple, &rtuple);\n",
        "    port = __snat_try_keep_port (target -> min_port, target -> max_port, bpf_ntohs (otuple -> sport));\n",
        "    rtuple.dport = ostate->to_sport = bpf_htons (port);\n",
        "    rtuple.daddr = target->addr;\n",
        "    if (otuple->saddr == target->addr) {\n",
        "        ostate->common.host_local = 1;\n",
        "        rstate.common.host_local = ostate->common.host_local;\n",
        "    }\n",
        "\n",
        "#pragma unroll\n",
        "    for (retries = 0; retries < SNAT_COLLISION_RETRIES; retries++) {\n",
        "        if (!snat_v4_lookup (&rtuple)) {\n",
        "            ostate->common.created = bpf_mono_now ();\n",
        "            rstate.common.created = ostate->common.created;\n",
        "            ret = snat_v4_update (otuple, ostate, & rtuple, & rstate);\n",
        "            if (!ret)\n",
        "                break;\n",
        "        }\n",
        "        port = __snat_clamp_port_range (target -> min_port, target -> max_port, retries ? port + 1 : (__u16) get_prandom_u32 ());\n",
        "        rtuple.dport = ostate->to_sport = bpf_htons (port);\n",
        "    }\n",
        "    if (retries > SNAT_SIGNAL_THRES)\n",
        "        send_signal_nat_fill_up (ctx, SIGNAL_PROTO_V4);\n",
        "    return !ret ? 0 : DROP_NAT_NO_MAPPING;\n",
        "}\n"
      ],
      "called_function_list": [
        "__snat_clamp_port_range",
        "snat_v4_swap_tuple",
        "memset",
        "__snat_try_keep_port",
        "snat_v4_update",
        "send_signal_nat_fill_up",
        "snat_v4_lookup"
      ],
      "call_depth": 4,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "snat_v4_track_local": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 260,
      "endLine": 299,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h",
      "funcName": "snat_v4_track_local",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " const struct ipv4_ct_tuple *tuple",
        " const struct ipv4_nat_entry *state",
        " enum nat_dir dir",
        " __u32 off",
        " const struct ipv4_nat_target *target"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int snat_v4_track_local (struct  __ctx_buff *ctx, const struct ipv4_ct_tuple *tuple, const struct ipv4_nat_entry *state, enum nat_dir dir, __u32 off, const struct ipv4_nat_target *target)\n",
        "{\n",
        "    struct ct_state ct_state;\n",
        "    struct ipv4_ct_tuple tmp;\n",
        "    bool needs_ct = false;\n",
        "    __u32 monitor = 0;\n",
        "    enum ct_dir where;\n",
        "    int ret;\n",
        "    if (state && state->common.host_local) {\n",
        "        needs_ct = true;\n",
        "    }\n",
        "    else if (!state && dir == NAT_DIR_EGRESS) {\n",
        "        if (tuple->saddr == target->addr)\n",
        "            needs_ct = true;\n",
        "    }\n",
        "    if (!needs_ct)\n",
        "        return 0;\n",
        "    memset (&ct_state, 0, sizeof (ct_state));\n",
        "    memcpy (&tmp, tuple, sizeof (tmp));\n",
        "    where = dir == NAT_DIR_INGRESS ? CT_INGRESS : CT_EGRESS;\n",
        "    ret = ct_lookup4 (get_ct_map4 (& tmp), & tmp, ctx, off, where, & ct_state, & monitor);\n",
        "    if (ret < 0) {\n",
        "        return ret;\n",
        "    }\n",
        "    else if (ret == CT_NEW) {\n",
        "        ret = ct_create4 (get_ct_map4 (& tmp), NULL, & tmp, ctx, where, & ct_state, false, false);\n",
        "        if (IS_ERR (ret))\n",
        "            return ret;\n",
        "    }\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "memset",
        "memcpy",
        "ct_create4",
        "get_ct_map4",
        "ct_lookup4"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "snat_v4_handle_mapping": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 301,
      "endLine": 322,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h",
      "funcName": "snat_v4_handle_mapping",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " struct ipv4_ct_tuple *tuple",
        " struct ipv4_nat_entry **state",
        " struct ipv4_nat_entry *tmp",
        " enum nat_dir dir",
        " __u32 off",
        " const struct ipv4_nat_target *target"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int snat_v4_handle_mapping (struct  __ctx_buff *ctx, struct ipv4_ct_tuple *tuple, struct ipv4_nat_entry **state, struct ipv4_nat_entry *tmp, enum nat_dir dir, __u32 off, const struct ipv4_nat_target *target)\n",
        "{\n",
        "    int ret;\n",
        "    *state = snat_v4_lookup (tuple);\n",
        "    ret = snat_v4_track_local (ctx, tuple, * state, dir, off, target);\n",
        "    if (ret < 0)\n",
        "        return ret;\n",
        "    else if (*state)\n",
        "        return NAT_CONTINUE_XLATE;\n",
        "    else if (dir == NAT_DIR_INGRESS)\n",
        "        return tuple->nexthdr != IPPROTO_ICMP && bpf_ntohs (tuple->dport) < target->min_port ? NAT_PUNT_TO_STACK : DROP_NAT_NO_MAPPING;\n",
        "    else\n",
        "        return snat_v4_new_mapping (ctx, tuple, (*state = tmp), target);\n",
        "}\n"
      ],
      "called_function_list": [
        "snat_v4_track_local",
        "snat_v4_new_mapping",
        "snat_v4_lookup"
      ],
      "call_depth": 5,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "snat_v4_rewrite_egress": [
    {
      "capabilities": [
        {
          "capability": "read_skb",
          "read_skb": [
            {
              "Project": "cilium",
              "Return Type": "s64",
              "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ",
              "Return": " The checksum result, or a negative error code in case of failure.",
              "Function Name": "csum_diff",
              "Input Params": [
                "{Type: __be32 ,Var: *from}",
                "{Type:  u32 ,Var: from_size}",
                "{Type:  __be32 ,Var: *to}",
                "{Type:  u32 ,Var: to_size}",
                "{Type:  __wsum ,Var: seed}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "xdp",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "lwt_seg6local"
              ],
              "capabilities": [
                "read_skb"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 324,
      "endLine": 380,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h",
      "funcName": "snat_v4_rewrite_egress",
      "developer_inline_comments": [
        {
          "start_line": 361,
          "end_line": 361,
          "text": "/* ICMPv4 has no pseudo-header */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " struct ipv4_ct_tuple *tuple",
        " struct ipv4_nat_entry *state",
        " __u32 off",
        " bool has_l4_header"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "csum_diff"
      ],
      "compatibleHookpoints": [
        "lwt_seg6local",
        "sched_act",
        "xdp",
        "lwt_xmit",
        "sched_cls",
        "lwt_in",
        "lwt_out"
      ],
      "source": [
        "static __always_inline int snat_v4_rewrite_egress (struct  __ctx_buff *ctx, struct ipv4_ct_tuple *tuple, struct ipv4_nat_entry *state, __u32 off, bool has_l4_header)\n",
        "{\n",
        "    int ret, flags = BPF_F_PSEUDO_HDR;\n",
        "    struct csum_offset csum = {}\n",
        "    ;\n",
        "    __be32 sum_l4 = 0, sum;\n",
        "    if (state->to_saddr == tuple->saddr && state->to_sport == tuple->sport)\n",
        "        return 0;\n",
        "    sum = csum_diff (& tuple -> saddr, 4, & state -> to_saddr, 4, 0);\n",
        "    if (has_l4_header) {\n",
        "        csum_l4_offset_and_flags (tuple->nexthdr, &csum);\n",
        "        if (state->to_sport != tuple->sport) {\n",
        "            switch (tuple->nexthdr) {\n",
        "            case IPPROTO_TCP :\n",
        "            case IPPROTO_UDP :\n",
        "                ret = l4_modify_port (ctx, off, offsetof (struct tcphdr, source), &csum, state->to_sport, tuple->sport);\n",
        "                if (ret < 0)\n",
        "                    return ret;\n",
        "                break;\n",
        "            case IPPROTO_ICMP :\n",
        "                {\n",
        "                    __be32 from, to;\n",
        "                    if (ctx_store_bytes (ctx, off + offsetof (struct icmphdr, un.echo.id), &state->to_sport, sizeof (state->to_sport), 0) < 0)\n",
        "                        return DROP_WRITE_ERROR;\n",
        "                    from = tuple->sport;\n",
        "                    to = state->to_sport;\n",
        "                    flags = 0;\n",
        "                    sum_l4 = csum_diff (& from, 4, & to, 4, 0);\n",
        "                    csum.offset = offsetof (struct icmphdr, checksum);\n",
        "                    break;\n",
        "                }\n",
        "            }\n",
        "        }\n",
        "    }\n",
        "    if (ctx_store_bytes (ctx, ETH_HLEN + offsetof (struct iphdr, saddr), &state->to_saddr, 4, 0) < 0)\n",
        "        return DROP_WRITE_ERROR;\n",
        "    if (l3_csum_replace (ctx, ETH_HLEN + offsetof (struct iphdr, check), 0, sum, 0) < 0)\n",
        "        return DROP_CSUM_L3;\n",
        "    if (tuple->nexthdr == IPPROTO_ICMP)\n",
        "        sum = sum_l4;\n",
        "    if (csum.offset && csum_l4_replace (ctx, off, &csum, 0, sum, flags) < 0)\n",
        "        return DROP_CSUM_L4;\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "csum_l4_replace",
        "l4_modify_port",
        "csum_l4_offset_and_flags"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "snat_v4_rewrite_ingress": [
    {
      "capabilities": [
        {
          "capability": "read_skb",
          "read_skb": [
            {
              "Project": "cilium",
              "Return Type": "s64",
              "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ",
              "Return": " The checksum result, or a negative error code in case of failure.",
              "Function Name": "csum_diff",
              "Input Params": [
                "{Type: __be32 ,Var: *from}",
                "{Type:  u32 ,Var: from_size}",
                "{Type:  __be32 ,Var: *to}",
                "{Type:  u32 ,Var: to_size}",
                "{Type:  __wsum ,Var: seed}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "xdp",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "lwt_seg6local"
              ],
              "capabilities": [
                "read_skb"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 382,
      "endLine": 435,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h",
      "funcName": "snat_v4_rewrite_ingress",
      "developer_inline_comments": [
        {
          "start_line": 417,
          "end_line": 417,
          "text": "/* ICMPv4 has no pseudo-header */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " struct ipv4_ct_tuple *tuple",
        " struct ipv4_nat_entry *state",
        " __u32 off"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "csum_diff"
      ],
      "compatibleHookpoints": [
        "lwt_seg6local",
        "sched_act",
        "xdp",
        "lwt_xmit",
        "sched_cls",
        "lwt_in",
        "lwt_out"
      ],
      "source": [
        "static __always_inline int snat_v4_rewrite_ingress (struct  __ctx_buff *ctx, struct ipv4_ct_tuple *tuple, struct ipv4_nat_entry *state, __u32 off)\n",
        "{\n",
        "    int ret, flags = BPF_F_PSEUDO_HDR;\n",
        "    struct csum_offset csum = {}\n",
        "    ;\n",
        "    __be32 sum_l4 = 0, sum;\n",
        "    if (state->to_daddr == tuple->daddr && state->to_dport == tuple->dport)\n",
        "        return 0;\n",
        "    sum = csum_diff (& tuple -> daddr, 4, & state -> to_daddr, 4, 0);\n",
        "    csum_l4_offset_and_flags (tuple->nexthdr, &csum);\n",
        "    if (state->to_dport != tuple->dport) {\n",
        "        switch (tuple->nexthdr) {\n",
        "        case IPPROTO_TCP :\n",
        "        case IPPROTO_UDP :\n",
        "            ret = l4_modify_port (ctx, off, offsetof (struct tcphdr, dest), &csum, state->to_dport, tuple->dport);\n",
        "            if (ret < 0)\n",
        "                return ret;\n",
        "            break;\n",
        "        case IPPROTO_ICMP :\n",
        "            {\n",
        "                __be32 from, to;\n",
        "                if (ctx_store_bytes (ctx, off + offsetof (struct icmphdr, un.echo.id), &state->to_dport, sizeof (state->to_dport), 0) < 0)\n",
        "                    return DROP_WRITE_ERROR;\n",
        "                from = tuple->dport;\n",
        "                to = state->to_dport;\n",
        "                flags = 0;\n",
        "                sum_l4 = csum_diff (& from, 4, & to, 4, 0);\n",
        "                csum.offset = offsetof (struct icmphdr, checksum);\n",
        "                break;\n",
        "            }\n",
        "        }\n",
        "    }\n",
        "    if (ctx_store_bytes (ctx, ETH_HLEN + offsetof (struct iphdr, daddr), &state->to_daddr, 4, 0) < 0)\n",
        "        return DROP_WRITE_ERROR;\n",
        "    if (l3_csum_replace (ctx, ETH_HLEN + offsetof (struct iphdr, check), 0, sum, 0) < 0)\n",
        "        return DROP_CSUM_L3;\n",
        "    if (tuple->nexthdr == IPPROTO_ICMP)\n",
        "        sum = sum_l4;\n",
        "    if (csum.offset && csum_l4_replace (ctx, off, &csum, 0, sum, flags) < 0)\n",
        "        return DROP_CSUM_L4;\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "csum_l4_replace",
        "l4_modify_port",
        "csum_l4_offset_and_flags"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "snat_v4_can_skip": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 437,
      "endLine": 452,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h",
      "funcName": "snat_v4_can_skip",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct ipv4_nat_target *target",
        " const struct ipv4_ct_tuple *tuple",
        " enum nat_dir dir",
        " bool from_endpoint",
        " bool icmp_echoreply"
      ],
      "output": "static__always_inlinebool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline bool snat_v4_can_skip (const struct ipv4_nat_target *target, const struct ipv4_ct_tuple *tuple, enum nat_dir dir, bool from_endpoint, bool icmp_echoreply)\n",
        "{\n",
        "    __u16 dport = bpf_ntohs (tuple->dport), sport = bpf_ntohs (tuple->sport);\n",
        "    if (dir == NAT_DIR_EGRESS && ((!from_endpoint && !target->src_from_world && sport < NAT_MIN_EGRESS) || icmp_echoreply))\n",
        "        return true;\n",
        "    if (dir == NAT_DIR_INGRESS && (dport < target->min_port || dport > target->max_port))\n",
        "        return true;\n",
        "    return false;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "snat_v4_create_dsr": [
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        },
        {
          "capability": "map_update",
          "map_update": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "map_update_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}",
                "{Type:  const void ,Var: *value}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_update"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 454,
      "endLine": 505,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h",
      "funcName": "snat_v4_create_dsr",
      "developer_inline_comments": [
        {
          "start_line": 490,
          "end_line": 492,
          "text": "/* NodePort svc can be reached only via TCP or UDP, so\n\t\t * drop the rest.\n\t\t */"
        }
      ],
      "updateMaps": [
        "  SNAT_MAPPING_IPV4"
      ],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " __be32 to_saddr",
        " __be16 to_sport"
      ],
      "output": "static__always_inline__maybe_unusedint",
      "helper": [
        "CTX_ACT_OK",
        "map_update_elem"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "static __always_inline __maybe_unused int snat_v4_create_dsr (struct  __ctx_buff *ctx, __be32 to_saddr, __be16 to_sport)\n",
        "{\n",
        "    void *data, *data_end;\n",
        "    struct ipv4_ct_tuple tuple = {}\n",
        "    ;\n",
        "    struct ipv4_nat_entry state = {}\n",
        "    ;\n",
        "    struct iphdr *ip4;\n",
        "    struct {\n",
        "        __be16 sport;\n",
        "        __be16 dport;\n",
        "    } l4hdr;\n",
        "\n",
        "    __u32 off;\n",
        "    int ret;\n",
        "    build_bug_on (sizeof (struct ipv4_nat_entry) > 64);\n",
        "    if (!revalidate_data (ctx, &data, &data_end, &ip4))\n",
        "        return DROP_INVALID;\n",
        "    tuple.nexthdr = ip4->protocol;\n",
        "    tuple.daddr = ip4->saddr;\n",
        "    tuple.saddr = ip4->daddr;\n",
        "    tuple.flags = NAT_DIR_EGRESS;\n",
        "    off = ((void *) ip4 - data) + ipv4_hdrlen (ip4);\n",
        "    switch (tuple.nexthdr) {\n",
        "    case IPPROTO_TCP :\n",
        "    case IPPROTO_UDP :\n",
        "        if (ctx_load_bytes (ctx, off, &l4hdr, sizeof (l4hdr)) < 0)\n",
        "            return DROP_INVALID;\n",
        "        tuple.dport = l4hdr.sport;\n",
        "        tuple.sport = l4hdr.dport;\n",
        "        break;\n",
        "    default :\n",
        "        return DROP_NAT_UNSUPP_PROTO;\n",
        "    }\n",
        "    state.common.created = bpf_mono_now ();\n",
        "    state.to_saddr = to_saddr;\n",
        "    state.to_sport = to_sport;\n",
        "    ret = map_update_elem (& SNAT_MAPPING_IPV4, & tuple, & state, 0);\n",
        "    if (ret)\n",
        "        return ret;\n",
        "    return CTX_ACT_OK;\n",
        "}\n"
      ],
      "called_function_list": [
        "ipv4_hdrlen"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "snat_v4_process": [
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 507,
      "endLine": 572,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h",
      "funcName": "snat_v4_process",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " enum nat_dir dir",
        " const struct ipv4_nat_target *target",
        " bool from_endpoint"
      ],
      "output": "static__always_inline__maybe_unusedint",
      "helper": [
        "CTX_ACT_OK"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "static __always_inline __maybe_unused int snat_v4_process (struct  __ctx_buff *ctx, enum nat_dir dir, const struct ipv4_nat_target *target, bool from_endpoint)\n",
        "{\n",
        "    struct icmphdr icmphdr __align_stack_8;\n",
        "    struct ipv4_nat_entry *state, tmp;\n",
        "    struct ipv4_ct_tuple tuple = {}\n",
        "    ;\n",
        "    void *data, *data_end;\n",
        "    struct iphdr *ip4;\n",
        "    struct {\n",
        "        __be16 sport;\n",
        "        __be16 dport;\n",
        "    } l4hdr;\n",
        "\n",
        "    bool icmp_echoreply = false;\n",
        "    __u64 off;\n",
        "    int ret;\n",
        "    build_bug_on (sizeof (struct ipv4_nat_entry) > 64);\n",
        "    if (!revalidate_data (ctx, &data, &data_end, &ip4))\n",
        "        return DROP_INVALID;\n",
        "    tuple.nexthdr = ip4->protocol;\n",
        "    tuple.daddr = ip4->daddr;\n",
        "    tuple.saddr = ip4->saddr;\n",
        "    tuple.flags = dir;\n",
        "    off = ((void *) ip4 - data) + ipv4_hdrlen (ip4);\n",
        "    switch (tuple.nexthdr) {\n",
        "    case IPPROTO_TCP :\n",
        "    case IPPROTO_UDP :\n",
        "        if (ctx_load_bytes (ctx, off, &l4hdr, sizeof (l4hdr)) < 0)\n",
        "            return DROP_INVALID;\n",
        "        tuple.dport = l4hdr.dport;\n",
        "        tuple.sport = l4hdr.sport;\n",
        "        break;\n",
        "    case IPPROTO_ICMP :\n",
        "        if (ctx_load_bytes (ctx, off, &icmphdr, sizeof (icmphdr)) < 0)\n",
        "            return DROP_INVALID;\n",
        "        if (icmphdr.type != ICMP_ECHO && icmphdr.type != ICMP_ECHOREPLY)\n",
        "            return DROP_NAT_UNSUPP_PROTO;\n",
        "        if (icmphdr.type == ICMP_ECHO) {\n",
        "            tuple.dport = 0;\n",
        "            tuple.sport = icmphdr.un.echo.id;\n",
        "        }\n",
        "        else {\n",
        "            tuple.dport = icmphdr.un.echo.id;\n",
        "            tuple.sport = 0;\n",
        "            icmp_echoreply = true;\n",
        "        }\n",
        "        break;\n",
        "    default :\n",
        "        return NAT_PUNT_TO_STACK;\n",
        "    }\n",
        "    if (snat_v4_can_skip (target, &tuple, dir, from_endpoint, icmp_echoreply))\n",
        "        return NAT_PUNT_TO_STACK;\n",
        "    ret = snat_v4_handle_mapping (ctx, & tuple, & state, & tmp, dir, off, target);\n",
        "    if (ret > 0)\n",
        "        return CTX_ACT_OK;\n",
        "    if (ret < 0)\n",
        "        return ret;\n",
        "    return dir == NAT_DIR_EGRESS ? snat_v4_rewrite_egress (ctx, &tuple, state, off, ipv4_has_l4_header (ip4)) : snat_v4_rewrite_ingress (ctx, &tuple, state, off);\n",
        "}\n"
      ],
      "called_function_list": [
        "ipv4_hdrlen",
        "ipv4_has_l4_header",
        "snat_v4_rewrite_ingress",
        "snat_v4_rewrite_egress",
        "snat_v4_can_skip",
        "snat_v4_handle_mapping"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 574,
      "endLine": 581,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h",
      "funcName": "snat_v4_process",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff * ctx __maybe_unused",
        " enum nat_dir dir __maybe_unused",
        " const struct ipv4_nat_target * target __maybe_unused",
        " bool from_endpoint __maybe_unused"
      ],
      "output": "static__always_inline__maybe_unusedint",
      "helper": [
        "CTX_ACT_OK"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "static __always_inline __maybe_unused int snat_v4_process (struct  __ctx_buff * ctx __maybe_unused, enum nat_dir dir __maybe_unused, const struct ipv4_nat_target * target __maybe_unused, bool from_endpoint __maybe_unused)\n",
        "{\n",
        "    return CTX_ACT_OK;\n",
        "}\n"
      ],
      "called_function_list": [
        "ipv4_hdrlen",
        "ipv4_has_l4_header",
        "snat_v4_rewrite_ingress",
        "snat_v4_rewrite_egress",
        "snat_v4_can_skip",
        "snat_v4_handle_mapping"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "snat_v6_lookup": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 622,
      "endLine": 626,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h",
      "funcName": "snat_v6_lookup",
      "developer_inline_comments": [
        {
          "start_line": 605,
          "end_line": 605,
          "text": "/* host endianness */"
        },
        {
          "start_line": 606,
          "end_line": 606,
          "text": "/* host endianness */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct ipv6_ct_tuple *tuple"
      ],
      "output": "static__always_inlinestructipv6_nat_entry",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline struct ipv6_nat_entry *snat_v6_lookup (struct ipv6_ct_tuple *tuple)\n",
        "{\n",
        "    return __snat_lookup (&SNAT_MAPPING_IPV6, tuple);\n",
        "}\n"
      ],
      "called_function_list": [
        "__snat_lookup"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "snat_v6_update": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 628,
      "endLine": 635,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h",
      "funcName": "snat_v6_update",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct ipv6_ct_tuple *otuple",
        " struct ipv6_nat_entry *ostate",
        " struct ipv6_ct_tuple *rtuple",
        " struct ipv6_nat_entry *rstate"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int snat_v6_update (struct ipv6_ct_tuple *otuple, struct ipv6_nat_entry *ostate, struct ipv6_ct_tuple *rtuple, struct ipv6_nat_entry *rstate)\n",
        "{\n",
        "    return __snat_update (&SNAT_MAPPING_IPV6, otuple, ostate, rtuple, rstate);\n",
        "}\n"
      ],
      "called_function_list": [
        "__snat_update"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "snat_v6_delete": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 637,
      "endLine": 641,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h",
      "funcName": "snat_v6_delete",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct ipv6_ct_tuple *otuple",
        " const struct ipv6_ct_tuple *rtuple"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void snat_v6_delete (const struct ipv6_ct_tuple *otuple, const struct ipv6_ct_tuple *rtuple)\n",
        "{\n",
        "    __snat_delete (&SNAT_MAPPING_IPV6, otuple, rtuple);\n",
        "}\n"
      ],
      "called_function_list": [
        "__snat_delete"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "snat_v6_swap_tuple": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 643,
      "endLine": 654,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h",
      "funcName": "snat_v6_swap_tuple",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct ipv6_ct_tuple *otuple",
        " struct ipv6_ct_tuple *rtuple"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void snat_v6_swap_tuple (const struct ipv6_ct_tuple *otuple, struct ipv6_ct_tuple *rtuple)\n",
        "{\n",
        "    memset (rtuple, 0, sizeof (*rtuple));\n",
        "    rtuple->nexthdr = otuple->nexthdr;\n",
        "    rtuple->daddr = otuple->saddr;\n",
        "    rtuple->saddr = otuple->daddr;\n",
        "    rtuple->dport = otuple->sport;\n",
        "    rtuple->sport = otuple->dport;\n",
        "    rtuple->flags = otuple->flags == NAT_DIR_EGRESS ? NAT_DIR_INGRESS : NAT_DIR_EGRESS;\n",
        "}\n"
      ],
      "called_function_list": [
        "memset"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "snat_v6_reverse_tuple": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 656,
      "endLine": 669,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h",
      "funcName": "snat_v6_reverse_tuple",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct ipv6_ct_tuple *otuple",
        " struct ipv6_ct_tuple *rtuple"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int snat_v6_reverse_tuple (struct ipv6_ct_tuple *otuple, struct ipv6_ct_tuple *rtuple)\n",
        "{\n",
        "    struct ipv6_nat_entry *ostate;\n",
        "    ostate = snat_v6_lookup (otuple);\n",
        "    if (ostate) {\n",
        "        snat_v6_swap_tuple (otuple, rtuple);\n",
        "        rtuple->daddr = ostate->to_saddr;\n",
        "        rtuple->dport = ostate->to_sport;\n",
        "    }\n",
        "    return ostate ? 0 : -1;\n",
        "}\n"
      ],
      "called_function_list": [
        "snat_v6_lookup",
        "snat_v6_swap_tuple"
      ],
      "call_depth": 4,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "snat_v6_ct_canonicalize": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 671,
      "endLine": 680,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h",
      "funcName": "snat_v6_ct_canonicalize",
      "developer_inline_comments": [
        {
          "start_line": 676,
          "end_line": 676,
          "text": "/* Workaround #5848. */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct ipv6_ct_tuple *otuple"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void snat_v6_ct_canonicalize (struct ipv6_ct_tuple *otuple)\n",
        "{\n",
        "    union v6addr addr = {}\n",
        "    ;\n",
        "    otuple->flags = NAT_DIR_EGRESS;\n",
        "    ipv6_addr_copy (&addr, &otuple->saddr);\n",
        "    ipv6_addr_copy (&otuple->saddr, &otuple->daddr);\n",
        "    ipv6_addr_copy (&otuple->daddr, &addr);\n",
        "}\n"
      ],
      "called_function_list": [
        "ipv6_addr_copy"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "snat_v6_delete_tuples": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 682,
      "endLine": 691,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h",
      "funcName": "snat_v6_delete_tuples",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct ipv6_ct_tuple *otuple"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void snat_v6_delete_tuples (struct ipv6_ct_tuple *otuple)\n",
        "{\n",
        "    struct ipv6_ct_tuple rtuple;\n",
        "    if (otuple->flags & TUPLE_F_IN)\n",
        "        return;\n",
        "    snat_v6_ct_canonicalize (otuple);\n",
        "    if (!snat_v6_reverse_tuple (otuple, &rtuple))\n",
        "        snat_v6_delete (otuple, &rtuple);\n",
        "}\n"
      ],
      "called_function_list": [
        "snat_v6_ct_canonicalize",
        "snat_v6_reverse_tuple",
        "snat_v6_delete"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1064,
      "endLine": 1067,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h",
      "funcName": "snat_v6_delete_tuples",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct ipv6_ct_tuple * tuple __maybe_unused"
      ],
      "output": "static__always_inline__maybe_unusedvoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused void snat_v6_delete_tuples (struct ipv6_ct_tuple * tuple __maybe_unused)\n",
        "{\n",
        "}\n"
      ],
      "called_function_list": [
        "snat_v6_ct_canonicalize",
        "snat_v6_reverse_tuple",
        "snat_v6_delete"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "snat_v6_new_mapping": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 693,
      "endLine": 745,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h",
      "funcName": "snat_v6_new_mapping",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " struct ipv6_ct_tuple *otuple",
        " struct ipv6_nat_entry *ostate",
        " const struct ipv6_nat_target *target"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "get_prandom_u32",
        "send_signal"
      ],
      "compatibleHookpoints": [
        "perf_event",
        "raw_tracepoint_writable",
        "kprobe",
        "tracepoint",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int snat_v6_new_mapping (struct  __ctx_buff *ctx, struct ipv6_ct_tuple *otuple, struct ipv6_nat_entry *ostate, const struct ipv6_nat_target *target)\n",
        "{\n",
        "    int ret = DROP_NAT_NO_MAPPING, retries;\n",
        "    struct ipv6_nat_entry rstate;\n",
        "    struct ipv6_ct_tuple rtuple;\n",
        "    __u16 port;\n",
        "    memset (&rstate, 0, sizeof (rstate));\n",
        "    memset (ostate, 0, sizeof (*ostate));\n",
        "    rstate.to_daddr = otuple->saddr;\n",
        "    rstate.to_dport = otuple->sport;\n",
        "    ostate->to_saddr = target->addr;\n",
        "    snat_v6_swap_tuple (otuple, &rtuple);\n",
        "    port = __snat_try_keep_port (target -> min_port, target -> max_port, bpf_ntohs (otuple -> sport));\n",
        "    rtuple.dport = ostate->to_sport = bpf_htons (port);\n",
        "    rtuple.daddr = target->addr;\n",
        "    if (!ipv6_addrcmp (&otuple->saddr, &rtuple.daddr)) {\n",
        "        ostate->common.host_local = 1;\n",
        "        rstate.common.host_local = ostate->common.host_local;\n",
        "    }\n",
        "\n",
        "#pragma unroll\n",
        "    for (retries = 0; retries < SNAT_COLLISION_RETRIES; retries++) {\n",
        "        if (!snat_v6_lookup (&rtuple)) {\n",
        "            ostate->common.created = bpf_mono_now ();\n",
        "            rstate.common.created = ostate->common.created;\n",
        "            ret = snat_v6_update (otuple, ostate, & rtuple, & rstate);\n",
        "            if (!ret)\n",
        "                break;\n",
        "        }\n",
        "        port = __snat_clamp_port_range (target -> min_port, target -> max_port, retries ? port + 1 : (__u16) get_prandom_u32 ());\n",
        "        rtuple.dport = ostate->to_sport = bpf_htons (port);\n",
        "    }\n",
        "    if (retries > SNAT_SIGNAL_THRES)\n",
        "        send_signal_nat_fill_up (ctx, SIGNAL_PROTO_V6);\n",
        "    return !ret ? 0 : DROP_NAT_NO_MAPPING;\n",
        "}\n"
      ],
      "called_function_list": [
        "__snat_clamp_port_range",
        "memset",
        "snat_v6_swap_tuple",
        "ipv6_addrcmp",
        "__snat_try_keep_port",
        "snat_v6_lookup",
        "send_signal_nat_fill_up",
        "snat_v6_update"
      ],
      "call_depth": 4,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "snat_v6_track_local": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 747,
      "endLine": 785,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h",
      "funcName": "snat_v6_track_local",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " struct ipv6_ct_tuple *tuple",
        " const struct ipv6_nat_entry *state",
        " enum nat_dir dir",
        " __u32 off",
        " const struct ipv6_nat_target *target"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int snat_v6_track_local (struct  __ctx_buff *ctx, struct ipv6_ct_tuple *tuple, const struct ipv6_nat_entry *state, enum nat_dir dir, __u32 off, const struct ipv6_nat_target *target)\n",
        "{\n",
        "    struct ct_state ct_state;\n",
        "    struct ipv6_ct_tuple tmp;\n",
        "    bool needs_ct = false;\n",
        "    __u32 monitor = 0;\n",
        "    int ret, where;\n",
        "    if (state && state->common.host_local) {\n",
        "        needs_ct = true;\n",
        "    }\n",
        "    else if (!state && dir == NAT_DIR_EGRESS) {\n",
        "        if (!ipv6_addrcmp (&tuple->saddr, (void *) &target->addr))\n",
        "            needs_ct = true;\n",
        "    }\n",
        "    if (!needs_ct)\n",
        "        return 0;\n",
        "    memset (&ct_state, 0, sizeof (ct_state));\n",
        "    memcpy (&tmp, tuple, sizeof (tmp));\n",
        "    where = dir == NAT_DIR_INGRESS ? CT_INGRESS : CT_EGRESS;\n",
        "    ret = ct_lookup6 (get_ct_map6 (& tmp), & tmp, ctx, off, where, & ct_state, & monitor);\n",
        "    if (ret < 0) {\n",
        "        return ret;\n",
        "    }\n",
        "    else if (ret == CT_NEW) {\n",
        "        ret = ct_create6 (get_ct_map6 (& tmp), NULL, & tmp, ctx, where, & ct_state, false, false);\n",
        "        if (IS_ERR (ret))\n",
        "            return ret;\n",
        "    }\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "get_ct_map6",
        "memset",
        "memcpy",
        "ipv6_addrcmp",
        "ct_create6",
        "ct_lookup6"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "snat_v6_handle_mapping": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 787,
      "endLine": 808,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h",
      "funcName": "snat_v6_handle_mapping",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " struct ipv6_ct_tuple *tuple",
        " struct ipv6_nat_entry **state",
        " struct ipv6_nat_entry *tmp",
        " enum nat_dir dir",
        " __u32 off",
        " const struct ipv6_nat_target *target"
      ],
      "output": "static__always_inlineint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline int snat_v6_handle_mapping (struct  __ctx_buff *ctx, struct ipv6_ct_tuple *tuple, struct ipv6_nat_entry **state, struct ipv6_nat_entry *tmp, enum nat_dir dir, __u32 off, const struct ipv6_nat_target *target)\n",
        "{\n",
        "    int ret;\n",
        "    *state = snat_v6_lookup (tuple);\n",
        "    ret = snat_v6_track_local (ctx, tuple, * state, dir, off, target);\n",
        "    if (ret < 0)\n",
        "        return ret;\n",
        "    else if (*state)\n",
        "        return NAT_CONTINUE_XLATE;\n",
        "    else if (dir == NAT_DIR_INGRESS)\n",
        "        return tuple->nexthdr != IPPROTO_ICMPV6 && bpf_ntohs (tuple->dport) < target->min_port ? NAT_PUNT_TO_STACK : DROP_NAT_NO_MAPPING;\n",
        "    else\n",
        "        return snat_v6_new_mapping (ctx, tuple, (*state = tmp), target);\n",
        "}\n"
      ],
      "called_function_list": [
        "snat_v6_lookup",
        "snat_v6_new_mapping",
        "snat_v6_track_local"
      ],
      "call_depth": 5,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "snat_v6_rewrite_egress": [
    {
      "capabilities": [
        {
          "capability": "read_skb",
          "read_skb": [
            {
              "Project": "cilium",
              "Return Type": "s64",
              "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ",
              "Return": " The checksum result, or a negative error code in case of failure.",
              "Function Name": "csum_diff",
              "Input Params": [
                "{Type: __be32 ,Var: *from}",
                "{Type:  u32 ,Var: from_size}",
                "{Type:  __be32 ,Var: *to}",
                "{Type:  u32 ,Var: to_size}",
                "{Type:  __wsum ,Var: seed}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "xdp",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "lwt_seg6local"
              ],
              "capabilities": [
                "read_skb"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 810,
      "endLine": 855,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h",
      "funcName": "snat_v6_rewrite_egress",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " struct ipv6_ct_tuple *tuple",
        " struct ipv6_nat_entry *state",
        " __u32 off"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "csum_diff"
      ],
      "compatibleHookpoints": [
        "lwt_seg6local",
        "sched_act",
        "xdp",
        "lwt_xmit",
        "sched_cls",
        "lwt_in",
        "lwt_out"
      ],
      "source": [
        "static __always_inline int snat_v6_rewrite_egress (struct  __ctx_buff *ctx, struct ipv6_ct_tuple *tuple, struct ipv6_nat_entry *state, __u32 off)\n",
        "{\n",
        "    struct csum_offset csum = {}\n",
        "    ;\n",
        "    __be32 sum;\n",
        "    int ret;\n",
        "    if (!ipv6_addrcmp (&state->to_saddr, &tuple->saddr) && state->to_sport == tuple->sport)\n",
        "        return 0;\n",
        "    sum = csum_diff (& tuple -> saddr, 16, & state -> to_saddr, 16, 0);\n",
        "    csum_l4_offset_and_flags (tuple->nexthdr, &csum);\n",
        "    if (state->to_sport != tuple->sport) {\n",
        "        switch (tuple->nexthdr) {\n",
        "        case IPPROTO_TCP :\n",
        "        case IPPROTO_UDP :\n",
        "            ret = l4_modify_port (ctx, off, offsetof (struct tcphdr, source), &csum, state->to_sport, tuple->sport);\n",
        "            if (ret < 0)\n",
        "                return ret;\n",
        "            break;\n",
        "        case IPPROTO_ICMPV6 :\n",
        "            {\n",
        "                __be32 from, to;\n",
        "                if (ctx_store_bytes (ctx, off + offsetof (struct icmp6hdr, icmp6_dataun.u_echo.identifier), &state->to_sport, sizeof (state->to_sport), 0) < 0)\n",
        "                    return DROP_WRITE_ERROR;\n",
        "                from = tuple->sport;\n",
        "                to = state->to_sport;\n",
        "                sum = csum_diff (& from, 4, & to, 4, sum);\n",
        "                break;\n",
        "            }\n",
        "        }\n",
        "    }\n",
        "    if (ctx_store_bytes (ctx, ETH_HLEN + offsetof (struct ipv6hdr, saddr), &state->to_saddr, 16, 0) < 0)\n",
        "        return DROP_WRITE_ERROR;\n",
        "    if (csum.offset && csum_l4_replace (ctx, off, &csum, 0, sum, BPF_F_PSEUDO_HDR) < 0)\n",
        "        return DROP_CSUM_L4;\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "ipv6_addrcmp",
        "csum_l4_replace",
        "l4_modify_port",
        "csum_l4_offset_and_flags"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "snat_v6_rewrite_ingress": [
    {
      "capabilities": [
        {
          "capability": "read_skb",
          "read_skb": [
            {
              "Project": "cilium",
              "Return Type": "s64",
              "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ",
              "Return": " The checksum result, or a negative error code in case of failure.",
              "Function Name": "csum_diff",
              "Input Params": [
                "{Type: __be32 ,Var: *from}",
                "{Type:  u32 ,Var: from_size}",
                "{Type:  __be32 ,Var: *to}",
                "{Type:  u32 ,Var: to_size}",
                "{Type:  __wsum ,Var: seed}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "xdp",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "lwt_seg6local"
              ],
              "capabilities": [
                "read_skb"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 857,
      "endLine": 904,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h",
      "funcName": "snat_v6_rewrite_ingress",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " struct ipv6_ct_tuple *tuple",
        " struct ipv6_nat_entry *state",
        " __u32 off"
      ],
      "output": "static__always_inlineint",
      "helper": [
        "csum_diff"
      ],
      "compatibleHookpoints": [
        "lwt_seg6local",
        "sched_act",
        "xdp",
        "lwt_xmit",
        "sched_cls",
        "lwt_in",
        "lwt_out"
      ],
      "source": [
        "static __always_inline int snat_v6_rewrite_ingress (struct  __ctx_buff *ctx, struct ipv6_ct_tuple *tuple, struct ipv6_nat_entry *state, __u32 off)\n",
        "{\n",
        "    struct csum_offset csum = {}\n",
        "    ;\n",
        "    __be32 sum;\n",
        "    int ret;\n",
        "    if (!ipv6_addrcmp (&state->to_daddr, &tuple->daddr) && state->to_dport == tuple->dport)\n",
        "        return 0;\n",
        "    sum = csum_diff (& tuple -> daddr, 16, & state -> to_daddr, 16, 0);\n",
        "    csum_l4_offset_and_flags (tuple->nexthdr, &csum);\n",
        "    if (state->to_dport != tuple->dport) {\n",
        "        switch (tuple->nexthdr) {\n",
        "        case IPPROTO_TCP :\n",
        "        case IPPROTO_UDP :\n",
        "            ret = l4_modify_port (ctx, off, offsetof (struct tcphdr, dest), &csum, state->to_dport, tuple->dport);\n",
        "            if (ret < 0)\n",
        "                return ret;\n",
        "            break;\n",
        "        case IPPROTO_ICMPV6 :\n",
        "            {\n",
        "                __be32 from, to;\n",
        "                if (ctx_store_bytes (ctx, off + offsetof (struct icmp6hdr, icmp6_dataun.u_echo.identifier), &state->to_dport, sizeof (state->to_dport), 0) < 0)\n",
        "                    return DROP_WRITE_ERROR;\n",
        "                from = tuple->dport;\n",
        "                to = state->to_dport;\n",
        "                sum = csum_diff (& from, 4, & to, 4, sum);\n",
        "                break;\n",
        "            }\n",
        "        }\n",
        "    }\n",
        "    if (ctx_store_bytes (ctx, ETH_HLEN + offsetof (struct ipv6hdr, daddr), &state->to_daddr, 16, 0) < 0)\n",
        "        return DROP_WRITE_ERROR;\n",
        "    if (csum.offset && csum_l4_replace (ctx, off, &csum, 0, sum, BPF_F_PSEUDO_HDR) < 0)\n",
        "        return DROP_CSUM_L4;\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [
        "ipv6_addrcmp",
        "csum_l4_replace",
        "l4_modify_port",
        "csum_l4_offset_and_flags"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "snat_v6_can_skip": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 906,
      "endLine": 920,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h",
      "funcName": "snat_v6_can_skip",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct ipv6_nat_target *target",
        " const struct ipv6_ct_tuple *tuple",
        " enum nat_dir dir",
        " bool icmp_echoreply"
      ],
      "output": "static__always_inlinebool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline bool snat_v6_can_skip (const struct ipv6_nat_target *target, const struct ipv6_ct_tuple *tuple, enum nat_dir dir, bool icmp_echoreply)\n",
        "{\n",
        "    __u16 dport = bpf_ntohs (tuple->dport), sport = bpf_ntohs (tuple->sport);\n",
        "    if (dir == NAT_DIR_EGRESS && ((!target->src_from_world && sport < NAT_MIN_EGRESS) || icmp_echoreply))\n",
        "        return true;\n",
        "    if (dir == NAT_DIR_INGRESS && (dport < target->min_port || dport > target->max_port))\n",
        "        return true;\n",
        "    return false;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "snat_v6_create_dsr": [
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        },
        {
          "capability": "map_update",
          "map_update": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "map_update_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}",
                "{Type:  const void ,Var: *value}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_update"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 922,
      "endLine": 977,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h",
      "funcName": "snat_v6_create_dsr",
      "developer_inline_comments": [
        {
          "start_line": 962,
          "end_line": 964,
          "text": "/* NodePort svc can be reached only via TCP or UDP, so\n\t\t * drop the rest.\n\t\t */"
        }
      ],
      "updateMaps": [
        "  SNAT_MAPPING_IPV6"
      ],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " const union v6addr *to_saddr",
        " __be16 to_sport"
      ],
      "output": "static__always_inline__maybe_unusedint",
      "helper": [
        "CTX_ACT_OK",
        "map_update_elem"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "static __always_inline __maybe_unused int snat_v6_create_dsr (struct  __ctx_buff *ctx, const union v6addr *to_saddr, __be16 to_sport)\n",
        "{\n",
        "    void *data, *data_end;\n",
        "    struct ipv6_ct_tuple tuple = {}\n",
        "    ;\n",
        "    struct ipv6_nat_entry state = {}\n",
        "    ;\n",
        "    struct ipv6hdr *ip6;\n",
        "    struct {\n",
        "        __be16 sport;\n",
        "        __be16 dport;\n",
        "    } l4hdr;\n",
        "\n",
        "    int ret, hdrlen;\n",
        "    __u32 off;\n",
        "    build_bug_on (sizeof (struct ipv6_nat_entry) > 64);\n",
        "    if (!revalidate_data (ctx, &data, &data_end, &ip6))\n",
        "        return DROP_INVALID;\n",
        "    tuple.nexthdr = ip6->nexthdr;\n",
        "    hdrlen = ipv6_hdrlen (ctx, & tuple.nexthdr);\n",
        "    if (hdrlen < 0)\n",
        "        return hdrlen;\n",
        "    ipv6_addr_copy (&tuple.daddr, (union v6addr *) &ip6->saddr);\n",
        "    ipv6_addr_copy (&tuple.saddr, (union v6addr *) &ip6->daddr);\n",
        "    tuple.flags = NAT_DIR_EGRESS;\n",
        "    off = ((void *) ip6 - data) + hdrlen;\n",
        "    switch (tuple.nexthdr) {\n",
        "    case IPPROTO_TCP :\n",
        "    case IPPROTO_UDP :\n",
        "        if (ctx_load_bytes (ctx, off, &l4hdr, sizeof (l4hdr)) < 0)\n",
        "            return DROP_INVALID;\n",
        "        tuple.dport = l4hdr.sport;\n",
        "        tuple.sport = l4hdr.dport;\n",
        "        break;\n",
        "    default :\n",
        "        return DROP_NAT_UNSUPP_PROTO;\n",
        "    }\n",
        "    state.common.created = bpf_mono_now ();\n",
        "    ipv6_addr_copy (&state.to_saddr, to_saddr);\n",
        "    state.to_sport = to_sport;\n",
        "    ret = map_update_elem (& SNAT_MAPPING_IPV6, & tuple, & state, 0);\n",
        "    if (ret)\n",
        "        return ret;\n",
        "    return CTX_ACT_OK;\n",
        "}\n"
      ],
      "called_function_list": [
        "ipv6_hdrlen",
        "ipv6_addr_copy"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "snat_v6_process": [
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 979,
      "endLine": 1054,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h",
      "funcName": "snat_v6_process",
      "developer_inline_comments": [
        {
          "start_line": 1023,
          "end_line": 1023,
          "text": "/* Letting neighbor solicitation / advertisement pass through. */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " enum nat_dir dir",
        " const struct ipv6_nat_target *target"
      ],
      "output": "static__always_inline__maybe_unusedint",
      "helper": [
        "CTX_ACT_OK"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "static __always_inline __maybe_unused int snat_v6_process (struct  __ctx_buff *ctx, enum nat_dir dir, const struct ipv6_nat_target *target)\n",
        "{\n",
        "    struct icmp6hdr icmp6hdr __align_stack_8;\n",
        "    struct ipv6_nat_entry *state, tmp;\n",
        "    struct ipv6_ct_tuple tuple = {}\n",
        "    ;\n",
        "    void *data, *data_end;\n",
        "    struct ipv6hdr *ip6;\n",
        "    int ret, hdrlen;\n",
        "    struct {\n",
        "        __be16 sport;\n",
        "        __be16 dport;\n",
        "    } l4hdr;\n",
        "\n",
        "    __u8 nexthdr;\n",
        "    __u32 off;\n",
        "    bool icmp_echoreply = false;\n",
        "    build_bug_on (sizeof (struct ipv6_nat_entry) > 64);\n",
        "    if (!revalidate_data (ctx, &data, &data_end, &ip6))\n",
        "        return DROP_INVALID;\n",
        "    nexthdr = ip6->nexthdr;\n",
        "    hdrlen = ipv6_hdrlen (ctx, & nexthdr);\n",
        "    if (hdrlen < 0)\n",
        "        return hdrlen;\n",
        "    tuple.nexthdr = nexthdr;\n",
        "    ipv6_addr_copy (&tuple.daddr, (union v6addr *) &ip6->daddr);\n",
        "    ipv6_addr_copy (&tuple.saddr, (union v6addr *) &ip6->saddr);\n",
        "    tuple.flags = dir;\n",
        "    off = ((void *) ip6 - data) + hdrlen;\n",
        "    switch (tuple.nexthdr) {\n",
        "    case IPPROTO_TCP :\n",
        "    case IPPROTO_UDP :\n",
        "        if (ctx_load_bytes (ctx, off, &l4hdr, sizeof (l4hdr)) < 0)\n",
        "            return DROP_INVALID;\n",
        "        tuple.dport = l4hdr.dport;\n",
        "        tuple.sport = l4hdr.sport;\n",
        "        break;\n",
        "    case IPPROTO_ICMPV6 :\n",
        "        if (ctx_load_bytes (ctx, off, &icmp6hdr, sizeof (icmp6hdr)) < 0)\n",
        "            return DROP_INVALID;\n",
        "        if (icmp6hdr.icmp6_type == ICMP6_NS_MSG_TYPE || icmp6hdr.icmp6_type == ICMP6_NA_MSG_TYPE)\n",
        "            return CTX_ACT_OK;\n",
        "        if (icmp6hdr.icmp6_type != ICMPV6_ECHO_REQUEST && icmp6hdr.icmp6_type != ICMPV6_ECHO_REPLY)\n",
        "            return DROP_NAT_UNSUPP_PROTO;\n",
        "        if (icmp6hdr.icmp6_type == ICMPV6_ECHO_REQUEST) {\n",
        "            tuple.dport = 0;\n",
        "            tuple.sport = icmp6hdr.icmp6_dataun.u_echo.identifier;\n",
        "        }\n",
        "        else {\n",
        "            tuple.dport = icmp6hdr.icmp6_dataun.u_echo.identifier;\n",
        "            tuple.sport = 0;\n",
        "            icmp_echoreply = true;\n",
        "        }\n",
        "        break;\n",
        "    default :\n",
        "        return NAT_PUNT_TO_STACK;\n",
        "    }\n",
        "    if (snat_v6_can_skip (target, &tuple, dir, icmp_echoreply))\n",
        "        return NAT_PUNT_TO_STACK;\n",
        "    ret = snat_v6_handle_mapping (ctx, & tuple, & state, & tmp, dir, off, target);\n",
        "    if (ret > 0)\n",
        "        return CTX_ACT_OK;\n",
        "    if (ret < 0)\n",
        "        return ret;\n",
        "    return dir == NAT_DIR_EGRESS ? snat_v6_rewrite_egress (ctx, &tuple, state, off) : snat_v6_rewrite_ingress (ctx, &tuple, state, off);\n",
        "}\n"
      ],
      "called_function_list": [
        "snat_v6_rewrite_egress",
        "ipv6_hdrlen",
        "snat_v6_handle_mapping",
        "snat_v6_can_skip",
        "snat_v6_rewrite_ingress",
        "ipv6_addr_copy"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [
        {
          "capability": "pkt_go_to_next_module",
          "pkt_go_to_next_module": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "TC_ACT_OK",
              "Return": 0,
              "Description": "will terminate the packet processing pipeline and allows the packet to proceed. Pass the skb onwards either to upper layers of the stack on ingress or down to the networking device driver for transmission on egress, respectively. TC_ACT_OK sets skb->tc_index based on the classid the tc BPF program set. The latter is set out of the tc BPF program itself through skb->tc_classid from the BPF context.",
              "compatible_hookpoints": [
                "xdp",
                "sched_cls",
                "sched_act"
              ],
              "capabilities": [
                "pkt_go_to_next_module"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 1056,
      "endLine": 1062,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h",
      "funcName": "snat_v6_process",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff * ctx __maybe_unused",
        " enum nat_dir dir __maybe_unused",
        " const struct ipv6_nat_target * target __maybe_unused"
      ],
      "output": "static__always_inline__maybe_unusedint",
      "helper": [
        "CTX_ACT_OK"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp"
      ],
      "source": [
        "static __always_inline __maybe_unused int snat_v6_process (struct  __ctx_buff * ctx __maybe_unused, enum nat_dir dir __maybe_unused, const struct ipv6_nat_target * target __maybe_unused)\n",
        "{\n",
        "    return CTX_ACT_OK;\n",
        "}\n"
      ],
      "called_function_list": [
        "snat_v6_rewrite_egress",
        "ipv6_hdrlen",
        "snat_v6_handle_mapping",
        "snat_v6_can_skip",
        "snat_v6_rewrite_ingress",
        "ipv6_addr_copy"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "snat_v6_has_v4_match": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 1070,
      "endLine": 1088,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h",
      "funcName": "snat_v6_has_v4_match",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct ipv4_ct_tuple * tuple4 __maybe_unused"
      ],
      "output": "static__always_inlinebool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline bool snat_v6_has_v4_match (const struct ipv4_ct_tuple * tuple4 __maybe_unused)\n",
        "{\n",
        "\n",
        "#if defined(ENABLE_IPV6) && defined(ENABLE_NODEPORT)\n",
        "    struct ipv6_ct_tuple tuple6;\n",
        "    memset (&tuple6, 0, sizeof (tuple6));\n",
        "    tuple6.nexthdr = tuple4->nexthdr;\n",
        "    build_v4_in_v6 (&tuple6.saddr, tuple4->saddr);\n",
        "    build_v4_in_v6 (&tuple6.daddr, tuple4->daddr);\n",
        "    tuple6.sport = tuple4->sport;\n",
        "    tuple6.dport = tuple4->dport;\n",
        "    tuple6.flags = NAT_DIR_INGRESS;\n",
        "    return snat_v6_lookup (&tuple6);\n",
        "\n",
        "#else\n",
        "    return false;\n",
        "\n",
        "#endif\n",
        "}\n"
      ],
      "called_function_list": [
        "snat_v6_lookup",
        "memset",
        "build_v4_in_v6"
      ],
      "call_depth": 4,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ct_delete4": [
    {
      "capabilities": [
        {
          "capability": "map_update",
          "map_update": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Description": "Delete entry with <[ key ]>(IP: 1) from map. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "map_delete_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_update"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 1090,
      "endLine": 1100,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h",
      "funcName": "ct_delete4",
      "developer_inline_comments": [],
      "updateMaps": [
        "",
        " map"
      ],
      "readMaps": [],
      "input": [
        "const void *map",
        " struct ipv4_ct_tuple *tuple",
        " struct  __ctx_buff *ctx"
      ],
      "output": "static__always_inline__maybe_unusedvoid",
      "helper": [
        "map_delete_elem"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused void ct_delete4 (const void *map, struct ipv4_ct_tuple *tuple, struct  __ctx_buff *ctx)\n",
        "{\n",
        "    int err;\n",
        "    err = map_delete_elem (map, tuple);\n",
        "    if (err < 0)\n",
        "        cilium_dbg (ctx, DBG_ERROR_RET, BPF_FUNC_map_delete_elem, err);\n",
        "    else\n",
        "        snat_v4_delete_tuples (tuple);\n",
        "}\n"
      ],
      "called_function_list": [
        "snat_v4_delete_tuples",
        "cilium_dbg"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ct_delete6": [
    {
      "capabilities": [
        {
          "capability": "map_update",
          "map_update": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Description": "Delete entry with <[ key ]>(IP: 1) from map. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "map_delete_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_update"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 1102,
      "endLine": 1112,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h",
      "funcName": "ct_delete6",
      "developer_inline_comments": [],
      "updateMaps": [
        "",
        " map"
      ],
      "readMaps": [],
      "input": [
        "const void *map",
        " struct ipv6_ct_tuple *tuple",
        " struct  __ctx_buff *ctx"
      ],
      "output": "static__always_inline__maybe_unusedvoid",
      "helper": [
        "map_delete_elem"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused void ct_delete6 (const void *map, struct ipv6_ct_tuple *tuple, struct  __ctx_buff *ctx)\n",
        "{\n",
        "    int err;\n",
        "    err = map_delete_elem (map, tuple);\n",
        "    if (err < 0)\n",
        "        cilium_dbg (ctx, DBG_ERROR_RET, BPF_FUNC_map_delete_elem, err);\n",
        "    else\n",
        "        snat_v6_delete_tuples (tuple);\n",
        "}\n"
      ],
      "called_function_list": [
        "cilium_dbg",
        "snat_v6_delete_tuples"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "hash_32": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 31,
      "endLine": 35,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/ghash.h",
      "funcName": "hash_32",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": "/* SPDX-License-Identifier: GPL-2.0 */"
        },
        {
          "start_line": 2,
          "end_line": 2,
          "text": "/* Copyright (C) 2002-2020 Authors of the Linux kernel */"
        },
        {
          "start_line": 3,
          "end_line": 3,
          "text": "/* Copyright Authors of Cilium */"
        },
        {
          "start_line": 11,
          "end_line": 27,
          "text": "/*\n * This hash multiplies the input by a large odd number and takes the\n * high bits.  Since multiplication propagates changes to the most\n * significant end only, it is essential that the high bits of the\n * product be used for the hash value.\n *\n * Chuck Lever verified the effectiveness of this technique:\n * http://www.citi.umich.edu/techreports/reports/citi-tr-00-1.pdf\n *\n * Although a random odd number will do, it turns out that the golden\n * ratio phi = (sqrt(5)-1)/2, or its negative, has particularly nice\n * properties.  (See Knuth vol 3, section 6.4, exercise 9.)\n *\n * These are the negative, (1 - phi) = phi**2 = (3 - sqrt(5))/2,\n * which is very slightly easier to multiply by and makes no\n * difference to the hash distribution.\n */"
        },
        {
          "start_line": 33,
          "end_line": 33,
          "text": "/* High bits are more random, so use them. */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "__u32 val",
        " __u32 bits"
      ],
      "output": "static__always_inline__u32",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __u32 hash_32 (__u32 val, __u32 bits)\n",
        "{\n",
        "    return (val * GOLDEN_RATIO_32) >> (32 - bits);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "hash_64": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 37,
      "endLine": 40,
      "File": "/home/sayandes/opened_extraction/examples/cilium/lib/ghash.h",
      "funcName": "hash_64",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "__u64 val",
        " __u32 bits"
      ],
      "output": "static__always_inline__u32",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __u32 hash_64 (__u64 val, __u32 bits)\n",
        "{\n",
        "    return (val * GOLDEN_RATIO_64) >> (64 - bits);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "custom_prog": [
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 11,
      "endLine": 24,
      "File": "/home/sayandes/opened_extraction/examples/cilium/custom/bytecount.h",
      "funcName": "custom_prog",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */"
        },
        {
          "start_line": 2,
          "end_line": 2,
          "text": "/* Copyright Authors of Cilium */"
        },
        {
          "start_line": 22,
          "end_line": 22,
          "text": "/* No entry for endpoint in hashmap, attempt to create one */"
        }
      ],
      "updateMaps": [
        " bytecount_map"
      ],
      "readMaps": [
        "  bytecount_map"
      ],
      "input": [
        "const struct  __ctx_buff *ctx",
        " __u32 identity"
      ],
      "output": "static__always_inlinevoid",
      "helper": [
        "map_update_elem",
        "map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void custom_prog (const struct  __ctx_buff *ctx, __u32 identity)\n",
        "{\n",
        "    __u64 len, *bytecount;\n",
        "    len = ctx_full_len (ctx);\n",
        "    bytecount = map_lookup_elem (& bytecount_map, & identity);\n",
        "    if (bytecount)\n",
        "        __sync_fetch_and_add (bytecount, len);\n",
        "    else\n",
        "        map_update_elem (&bytecount_map, &identity, &len, BPF_ANY);\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_full_len"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__fswab16": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 46,
      "endLine": 55,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/swab.h",
      "funcName": "__fswab16",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": "/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */"
        },
        {
          "start_line": 2,
          "end_line": 2,
          "text": "/* Copyright Authors of the Linux kernel */"
        },
        {
          "start_line": 8,
          "end_line": 11,
          "text": "/*\n * casts are necessary for constants, because we never know how for sure\n * how U/UL/ULL map to __u16, __u32, __u64. At least not in a portable way.\n */"
        },
        {
          "start_line": 40,
          "end_line": 44,
          "text": "/*\n * Implement the following as inlines, but define the interface using\n * macros to allow constant folding when possible:\n * ___swab16, ___swab32, ___swab64, ___swahw32, ___swahb32\n */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "__u16 val"
      ],
      "output": "static__inline____u16",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __inline__ __u16 __fswab16 (__u16 val)\n",
        "{\n",
        "\n",
        "#ifdef __HAVE_BUILTIN_BSWAP16__\n",
        "    return __builtin_bswap16 (val);\n",
        "\n",
        "#elif defined (__arch_swab16)\n",
        "    return __arch_swab16 (val);\n",
        "\n",
        "#else\n",
        "    return ___constant_swab16 (val);\n",
        "\n",
        "#endif\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__fswab32": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 57,
      "endLine": 66,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/swab.h",
      "funcName": "__fswab32",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "__u32 val"
      ],
      "output": "static__inline____u32",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __inline__ __u32 __fswab32 (__u32 val)\n",
        "{\n",
        "\n",
        "#ifdef __HAVE_BUILTIN_BSWAP32__\n",
        "    return __builtin_bswap32 (val);\n",
        "\n",
        "#elif defined(__arch_swab32)\n",
        "    return __arch_swab32 (val);\n",
        "\n",
        "#else\n",
        "    return ___constant_swab32 (val);\n",
        "\n",
        "#endif\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__fswab64": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 68,
      "endLine": 81,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/swab.h",
      "funcName": "__fswab64",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "__u64 val"
      ],
      "output": "static__inline____u64",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __inline__ __u64 __fswab64 (__u64 val)\n",
        "{\n",
        "\n",
        "#ifdef __HAVE_BUILTIN_BSWAP64__\n",
        "    return __builtin_bswap64 (val);\n",
        "\n",
        "#elif defined (__arch_swab64)\n",
        "    return __arch_swab64 (val);\n",
        "\n",
        "#elif defined(__SWAB_64_THRU_32__)\n",
        "    __u32 h = val >> 32;\n",
        "    __u32 l = val & ((1ULL << 32) - 1);\n",
        "    return (((__u64) __fswab32 (l)) << 32) | ((__u64) (__fswab32 (h)));\n",
        "\n",
        "#else\n",
        "    return ___constant_swab64 (val);\n",
        "\n",
        "#endif\n",
        "}\n"
      ],
      "called_function_list": [
        "__fswab32"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__fswahw32": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 83,
      "endLine": 90,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/swab.h",
      "funcName": "__fswahw32",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "__u32 val"
      ],
      "output": "static__inline____u32",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __inline__ __u32 __fswahw32 (__u32 val)\n",
        "{\n",
        "\n",
        "#ifdef __arch_swahw32\n",
        "    return __arch_swahw32 (val);\n",
        "\n",
        "#else\n",
        "    return ___constant_swahw32 (val);\n",
        "\n",
        "#endif\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__fswahb32": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 92,
      "endLine": 99,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/swab.h",
      "funcName": "__fswahb32",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "__u32 val"
      ],
      "output": "static__inline____u32",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __inline__ __u32 __fswahb32 (__u32 val)\n",
        "{\n",
        "\n",
        "#ifdef __arch_swahb32\n",
        "    return __arch_swahb32 (val);\n",
        "\n",
        "#else\n",
        "    return ___constant_swahb32 (val);\n",
        "\n",
        "#endif\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__swab16p": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 154,
      "endLine": 161,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/swab.h",
      "funcName": "__swab16p",
      "developer_inline_comments": [
        {
          "start_line": 101,
          "end_line": 104,
          "text": "/**\n * __swab16 - return a byteswapped 16-bit value\n * @x: value to byteswap\n */"
        },
        {
          "start_line": 110,
          "end_line": 113,
          "text": "/**\n * __swab32 - return a byteswapped 32-bit value\n * @x: value to byteswap\n */"
        },
        {
          "start_line": 119,
          "end_line": 122,
          "text": "/**\n * __swab64 - return a byteswapped 64-bit value\n * @x: value to byteswap\n */"
        },
        {
          "start_line": 128,
          "end_line": 133,
          "text": "/**\n * __swahw32 - return a word-swapped 32-bit value\n * @x: value to wordswap\n *\n * __swahw32(0x12340000) is 0x00001234\n */"
        },
        {
          "start_line": 139,
          "end_line": 144,
          "text": "/**\n * __swahb32 - return a high and low byte-swapped 32-bit value\n * @x: value to byteswap\n *\n * __swahb32(0x12345678) is 0x34127856\n */"
        },
        {
          "start_line": 150,
          "end_line": 153,
          "text": "/**\n * __swab16p - return a byteswapped 16-bit value from a pointer\n * @p: pointer to a naturally-aligned 16-bit value\n */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const __u16 *p"
      ],
      "output": "static__inline____u16",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __inline__ __u16 __swab16p (const __u16 *p)\n",
        "{\n",
        "\n",
        "#ifdef __arch_swab16p\n",
        "    return __arch_swab16p (p);\n",
        "\n",
        "#else\n",
        "    return __swab16 (*p);\n",
        "\n",
        "#endif\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__swab32p": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 167,
      "endLine": 174,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/swab.h",
      "funcName": "__swab32p",
      "developer_inline_comments": [
        {
          "start_line": 163,
          "end_line": 166,
          "text": "/**\n * __swab32p - return a byteswapped 32-bit value from a pointer\n * @p: pointer to a naturally-aligned 32-bit value\n */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const __u32 *p"
      ],
      "output": "static__inline____u32",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __inline__ __u32 __swab32p (const __u32 *p)\n",
        "{\n",
        "\n",
        "#ifdef __arch_swab32p\n",
        "    return __arch_swab32p (p);\n",
        "\n",
        "#else\n",
        "    return __swab32 (*p);\n",
        "\n",
        "#endif\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__swab64p": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 180,
      "endLine": 187,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/swab.h",
      "funcName": "__swab64p",
      "developer_inline_comments": [
        {
          "start_line": 176,
          "end_line": 179,
          "text": "/**\n * __swab64p - return a byteswapped 64-bit value from a pointer\n * @p: pointer to a naturally-aligned 64-bit value\n */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const __u64 *p"
      ],
      "output": "static__inline____u64",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __inline__ __u64 __swab64p (const __u64 *p)\n",
        "{\n",
        "\n",
        "#ifdef __arch_swab64p\n",
        "    return __arch_swab64p (p);\n",
        "\n",
        "#else\n",
        "    return __swab64 (*p);\n",
        "\n",
        "#endif\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__swahw32p": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 195,
      "endLine": 202,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/swab.h",
      "funcName": "__swahw32p",
      "developer_inline_comments": [
        {
          "start_line": 189,
          "end_line": 194,
          "text": "/**\n * __swahw32p - return a wordswapped 32-bit value from a pointer\n * @p: pointer to a naturally-aligned 32-bit value\n *\n * See __swahw32() for details of wordswapping.\n */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const __u32 *p"
      ],
      "output": "static__inline____u32",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __inline__ __u32 __swahw32p (const __u32 *p)\n",
        "{\n",
        "\n",
        "#ifdef __arch_swahw32p\n",
        "    return __arch_swahw32p (p);\n",
        "\n",
        "#else\n",
        "    return __swahw32 (*p);\n",
        "\n",
        "#endif\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__swahb32p": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 210,
      "endLine": 217,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/swab.h",
      "funcName": "__swahb32p",
      "developer_inline_comments": [
        {
          "start_line": 204,
          "end_line": 209,
          "text": "/**\n * __swahb32p - return a high and low byteswapped 32-bit value from a pointer\n * @p: pointer to a naturally-aligned 32-bit value\n *\n * See __swahb32() for details of high/low byteswapping.\n */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const __u32 *p"
      ],
      "output": "static__inline____u32",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __inline__ __u32 __swahb32p (const __u32 *p)\n",
        "{\n",
        "\n",
        "#ifdef __arch_swahb32p\n",
        "    return __arch_swahb32p (p);\n",
        "\n",
        "#else\n",
        "    return __swahb32 (*p);\n",
        "\n",
        "#endif\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__swab16s": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 223,
      "endLine": 230,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/swab.h",
      "funcName": "__swab16s",
      "developer_inline_comments": [
        {
          "start_line": 219,
          "end_line": 222,
          "text": "/**\n * __swab16s - byteswap a 16-bit value in-place\n * @p: pointer to a naturally-aligned 16-bit value\n */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "__u16 *p"
      ],
      "output": "static__inline__void",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __inline__ void __swab16s (__u16 *p)\n",
        "{\n",
        "\n",
        "#ifdef __arch_swab16s\n",
        "    __arch_swab16s (p);\n",
        "\n",
        "#else\n",
        "    *p = __swab16p (p);\n",
        "\n",
        "#endif\n",
        "}\n"
      ],
      "called_function_list": [
        "__swab16p"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__swab32s": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 235,
      "endLine": 242,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/swab.h",
      "funcName": "__swab32s",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "__u32 *p"
      ],
      "output": "static__inline__void",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __inline__ void __swab32s (__u32 *p)\n",
        "{\n",
        "\n",
        "#ifdef __arch_swab32s\n",
        "    __arch_swab32s (p);\n",
        "\n",
        "#else\n",
        "    *p = __swab32p (p);\n",
        "\n",
        "#endif\n",
        "}\n"
      ],
      "called_function_list": [
        "__swab32p"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__swab64s": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 248,
      "endLine": 255,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/swab.h",
      "funcName": "__swab64s",
      "developer_inline_comments": [
        {
          "start_line": 244,
          "end_line": 247,
          "text": "/**\n * __swab64s - byteswap a 64-bit value in-place\n * @p: pointer to a naturally-aligned 64-bit value\n */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "__u64 *p"
      ],
      "output": "static__inline__void",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __inline__ void __swab64s (__u64 *p)\n",
        "{\n",
        "\n",
        "#ifdef __arch_swab64s\n",
        "    __arch_swab64s (p);\n",
        "\n",
        "#else\n",
        "    *p = __swab64p (p);\n",
        "\n",
        "#endif\n",
        "}\n"
      ],
      "called_function_list": [
        "__swab64p"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__swahw32s": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 263,
      "endLine": 270,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/swab.h",
      "funcName": "__swahw32s",
      "developer_inline_comments": [
        {
          "start_line": 257,
          "end_line": 262,
          "text": "/**\n * __swahw32s - wordswap a 32-bit value in-place\n * @p: pointer to a naturally-aligned 32-bit value\n *\n * See __swahw32() for details of wordswapping\n */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "__u32 *p"
      ],
      "output": "static__inline__void",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __inline__ void __swahw32s (__u32 *p)\n",
        "{\n",
        "\n",
        "#ifdef __arch_swahw32s\n",
        "    __arch_swahw32s (p);\n",
        "\n",
        "#else\n",
        "    *p = __swahw32p (p);\n",
        "\n",
        "#endif\n",
        "}\n"
      ],
      "called_function_list": [
        "__swahw32p"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__swahb32s": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 278,
      "endLine": 285,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/swab.h",
      "funcName": "__swahb32s",
      "developer_inline_comments": [
        {
          "start_line": 272,
          "end_line": 277,
          "text": "/**\n * __swahb32s - high and low byteswap a 32-bit value in-place\n * @p: pointer to a naturally-aligned 32-bit value\n *\n * See __swahb32() for details of high and low byte swapping\n */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "__u32 *p"
      ],
      "output": "static__inline__void",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __inline__ void __swahb32s (__u32 *p)\n",
        "{\n",
        "\n",
        "#ifdef __arch_swahb32s\n",
        "    __arch_swahb32s (p);\n",
        "\n",
        "#else\n",
        "    *p = __swahb32p (p);\n",
        "\n",
        "#endif\n",
        "}\n"
      ],
      "called_function_list": [
        "__swahb32p"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__cpu_to_le64p": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 45,
      "endLine": 48,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/big_endian.h",
      "funcName": "__cpu_to_le64p",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": "/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */"
        },
        {
          "start_line": 2,
          "end_line": 2,
          "text": "/* Copyright Authors of the Linux kernel */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const __u64 *p"
      ],
      "output": "static__inline____le64",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __inline__ __le64 __cpu_to_le64p (const __u64 *p)\n",
        "{\n",
        "    return (__le64) __swab64p (p);\n",
        "}\n"
      ],
      "called_function_list": [
        "__swab64p"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 45,
      "endLine": 48,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/little_endian.h",
      "funcName": "__cpu_to_le64p",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": "/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */"
        },
        {
          "start_line": 2,
          "end_line": 2,
          "text": "/* Copyright Authors of the Linux kernel */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const __u64 *p"
      ],
      "output": "static__inline____le64",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __inline__ __le64 __cpu_to_le64p (const __u64 *p)\n",
        "{\n",
        "    return (__le64) *p;\n",
        "}\n"
      ],
      "called_function_list": [
        "__swab64p"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__le64_to_cpup": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 49,
      "endLine": 52,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/big_endian.h",
      "funcName": "__le64_to_cpup",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const __le64 *p"
      ],
      "output": "static__inline____u64",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __inline__ __u64 __le64_to_cpup (const __le64 *p)\n",
        "{\n",
        "    return __swab64p ((__u64 *) p);\n",
        "}\n"
      ],
      "called_function_list": [
        "__swab64p"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 49,
      "endLine": 52,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/little_endian.h",
      "funcName": "__le64_to_cpup",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const __le64 *p"
      ],
      "output": "static__inline____u64",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __inline__ __u64 __le64_to_cpup (const __le64 *p)\n",
        "{\n",
        "    return (__u64) *p;\n",
        "}\n"
      ],
      "called_function_list": [
        "__swab64p"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__cpu_to_le32p": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 53,
      "endLine": 56,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/big_endian.h",
      "funcName": "__cpu_to_le32p",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const __u32 *p"
      ],
      "output": "static__inline____le32",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __inline__ __le32 __cpu_to_le32p (const __u32 *p)\n",
        "{\n",
        "    return (__le32) __swab32p (p);\n",
        "}\n"
      ],
      "called_function_list": [
        "__swab32p"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 53,
      "endLine": 56,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/little_endian.h",
      "funcName": "__cpu_to_le32p",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const __u32 *p"
      ],
      "output": "static__inline____le32",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __inline__ __le32 __cpu_to_le32p (const __u32 *p)\n",
        "{\n",
        "    return (__le32) *p;\n",
        "}\n"
      ],
      "called_function_list": [
        "__swab32p"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__le32_to_cpup": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 57,
      "endLine": 60,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/big_endian.h",
      "funcName": "__le32_to_cpup",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const __le32 *p"
      ],
      "output": "static__inline____u32",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __inline__ __u32 __le32_to_cpup (const __le32 *p)\n",
        "{\n",
        "    return __swab32p ((__u32 *) p);\n",
        "}\n"
      ],
      "called_function_list": [
        "__swab32p"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 57,
      "endLine": 60,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/little_endian.h",
      "funcName": "__le32_to_cpup",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const __le32 *p"
      ],
      "output": "static__inline____u32",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __inline__ __u32 __le32_to_cpup (const __le32 *p)\n",
        "{\n",
        "    return (__u32) *p;\n",
        "}\n"
      ],
      "called_function_list": [
        "__swab32p"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__cpu_to_le16p": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 61,
      "endLine": 64,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/big_endian.h",
      "funcName": "__cpu_to_le16p",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const __u16 *p"
      ],
      "output": "static__inline____le16",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __inline__ __le16 __cpu_to_le16p (const __u16 *p)\n",
        "{\n",
        "    return (__le16) __swab16p (p);\n",
        "}\n"
      ],
      "called_function_list": [
        "__swab16p"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 61,
      "endLine": 64,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/little_endian.h",
      "funcName": "__cpu_to_le16p",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const __u16 *p"
      ],
      "output": "static__inline____le16",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __inline__ __le16 __cpu_to_le16p (const __u16 *p)\n",
        "{\n",
        "    return (__le16) *p;\n",
        "}\n"
      ],
      "called_function_list": [
        "__swab16p"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__le16_to_cpup": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 65,
      "endLine": 68,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/big_endian.h",
      "funcName": "__le16_to_cpup",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const __le16 *p"
      ],
      "output": "static__inline____u16",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __inline__ __u16 __le16_to_cpup (const __le16 *p)\n",
        "{\n",
        "    return __swab16p ((__u16 *) p);\n",
        "}\n"
      ],
      "called_function_list": [
        "__swab16p"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 65,
      "endLine": 68,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/little_endian.h",
      "funcName": "__le16_to_cpup",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const __le16 *p"
      ],
      "output": "static__inline____u16",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __inline__ __u16 __le16_to_cpup (const __le16 *p)\n",
        "{\n",
        "    return (__u16) *p;\n",
        "}\n"
      ],
      "called_function_list": [
        "__swab16p"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__cpu_to_be64p": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 69,
      "endLine": 72,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/big_endian.h",
      "funcName": "__cpu_to_be64p",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const __u64 *p"
      ],
      "output": "static__inline____be64",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __inline__ __be64 __cpu_to_be64p (const __u64 *p)\n",
        "{\n",
        "    return (__be64) *p;\n",
        "}\n"
      ],
      "called_function_list": [
        "__swab64p"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 69,
      "endLine": 72,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/little_endian.h",
      "funcName": "__cpu_to_be64p",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const __u64 *p"
      ],
      "output": "static__inline____be64",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __inline__ __be64 __cpu_to_be64p (const __u64 *p)\n",
        "{\n",
        "    return (__be64) __swab64p (p);\n",
        "}\n"
      ],
      "called_function_list": [
        "__swab64p"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__be64_to_cpup": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 73,
      "endLine": 76,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/big_endian.h",
      "funcName": "__be64_to_cpup",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const __be64 *p"
      ],
      "output": "static__inline____u64",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __inline__ __u64 __be64_to_cpup (const __be64 *p)\n",
        "{\n",
        "    return (__u64) *p;\n",
        "}\n"
      ],
      "called_function_list": [
        "__swab64p"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 73,
      "endLine": 76,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/little_endian.h",
      "funcName": "__be64_to_cpup",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const __be64 *p"
      ],
      "output": "static__inline____u64",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __inline__ __u64 __be64_to_cpup (const __be64 *p)\n",
        "{\n",
        "    return __swab64p ((__u64 *) p);\n",
        "}\n"
      ],
      "called_function_list": [
        "__swab64p"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__cpu_to_be32p": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 77,
      "endLine": 80,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/big_endian.h",
      "funcName": "__cpu_to_be32p",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const __u32 *p"
      ],
      "output": "static__inline____be32",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __inline__ __be32 __cpu_to_be32p (const __u32 *p)\n",
        "{\n",
        "    return (__be32) *p;\n",
        "}\n"
      ],
      "called_function_list": [
        "__swab32p"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 77,
      "endLine": 80,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/little_endian.h",
      "funcName": "__cpu_to_be32p",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const __u32 *p"
      ],
      "output": "static__inline____be32",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __inline__ __be32 __cpu_to_be32p (const __u32 *p)\n",
        "{\n",
        "    return (__be32) __swab32p (p);\n",
        "}\n"
      ],
      "called_function_list": [
        "__swab32p"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__be32_to_cpup": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 81,
      "endLine": 84,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/big_endian.h",
      "funcName": "__be32_to_cpup",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const __be32 *p"
      ],
      "output": "static__inline____u32",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __inline__ __u32 __be32_to_cpup (const __be32 *p)\n",
        "{\n",
        "    return (__u32) *p;\n",
        "}\n"
      ],
      "called_function_list": [
        "__swab32p"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 81,
      "endLine": 84,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/little_endian.h",
      "funcName": "__be32_to_cpup",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const __be32 *p"
      ],
      "output": "static__inline____u32",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __inline__ __u32 __be32_to_cpup (const __be32 *p)\n",
        "{\n",
        "    return __swab32p ((__u32 *) p);\n",
        "}\n"
      ],
      "called_function_list": [
        "__swab32p"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__cpu_to_be16p": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 85,
      "endLine": 88,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/big_endian.h",
      "funcName": "__cpu_to_be16p",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const __u16 *p"
      ],
      "output": "static__inline____be16",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __inline__ __be16 __cpu_to_be16p (const __u16 *p)\n",
        "{\n",
        "    return (__be16) *p;\n",
        "}\n"
      ],
      "called_function_list": [
        "__swab16p"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 85,
      "endLine": 88,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/little_endian.h",
      "funcName": "__cpu_to_be16p",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const __u16 *p"
      ],
      "output": "static__inline____be16",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __inline__ __be16 __cpu_to_be16p (const __u16 *p)\n",
        "{\n",
        "    return (__be16) __swab16p (p);\n",
        "}\n"
      ],
      "called_function_list": [
        "__swab16p"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__be16_to_cpup": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 89,
      "endLine": 92,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/big_endian.h",
      "funcName": "__be16_to_cpup",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const __be16 *p"
      ],
      "output": "static__inline____u16",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __inline__ __u16 __be16_to_cpup (const __be16 *p)\n",
        "{\n",
        "    return (__u16) *p;\n",
        "}\n"
      ],
      "called_function_list": [
        "__swab16p"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 89,
      "endLine": 92,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/little_endian.h",
      "funcName": "__be16_to_cpup",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const __be16 *p"
      ],
      "output": "static__inline____u16",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __inline__ __u16 __be16_to_cpup (const __be16 *p)\n",
        "{\n",
        "    return __swab16p ((__u16 *) p);\n",
        "}\n"
      ],
      "called_function_list": [
        "__swab16p"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__bpf_memset_builtin": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 38,
      "endLine": 45,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/builtins.h",
      "funcName": "__bpf_memset_builtin",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */"
        },
        {
          "start_line": 2,
          "end_line": 2,
          "text": "/* Copyright Authors of Cilium */"
        },
        {
          "start_line": 15,
          "end_line": 21,
          "text": "/* Unfortunately verifier forces aligned stack access while other memory\n * do not have to be aligned (map, pkt, etc). Mark those on the /stack/\n * for objects > 8 bytes in order to force-align such memcpy candidates\n * when we really need them to be aligned, this is not needed for objects\n * of size <= 8 bytes and in case of > 8 bytes /only/ when 8 byte is not\n * the natural object alignment (e.g. __u8 foo[12]).\n */"
        },
        {
          "start_line": 24,
          "end_line": 24,
          "text": "/* Memory iterators used below. */"
        },
        {
          "start_line": 28,
          "end_line": 28,
          "text": "/* Memory operators used below. */"
        },
        {
          "start_line": 41,
          "end_line": 43,
          "text": "/* Everything non-zero or non-const (currently unsupported) as c\n\t * gets handled here.\n\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *d",
        " __u8 c",
        " __u64 len"
      ],
      "output": "static__always_inline__maybe_unusedvoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused void __bpf_memset_builtin (void *d, __u8 c, __u64 len)\n",
        "{\n",
        "    __builtin_memset (d, c, len);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__bpf_memzero": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 47,
      "endLine": 126,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/builtins.h",
      "funcName": "__bpf_memzero",
      "developer_inline_comments": [
        {
          "start_line": 116,
          "end_line": 120,
          "text": "/* __builtin_memset() is crappy slow since it cannot\n\t\t * make any assumptions about alignment & underlying\n\t\t * efficient unaligned access on the target we're\n\t\t * running.\n\t\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *d",
        " __u64 len"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void __bpf_memzero (void *d, __u64 len)\n",
        "{\n",
        "\n",
        "#if __clang_major__ >= 10\n",
        "    if (!__builtin_constant_p (len))\n",
        "        __throw_build_bug ();\n",
        "    d += len;\n",
        "    switch (len) {\n",
        "    case 96 :\n",
        "        __it_set (d, 64);\n",
        "    case 88 :\n",
        "    jmp_88 :\n",
        "        __it_set (d, 64);\n",
        "    case 80 :\n",
        "    jmp_80 :\n",
        "        __it_set (d, 64);\n",
        "    case 72 :\n",
        "    jmp_72 :\n",
        "        __it_set (d, 64);\n",
        "    case 64 :\n",
        "    jmp_64 :\n",
        "        __it_set (d, 64);\n",
        "    case 56 :\n",
        "    jmp_56 :\n",
        "        __it_set (d, 64);\n",
        "    case 48 :\n",
        "    jmp_48 :\n",
        "        __it_set (d, 64);\n",
        "    case 40 :\n",
        "    jmp_40 :\n",
        "        __it_set (d, 64);\n",
        "    case 32 :\n",
        "    jmp_32 :\n",
        "        __it_set (d, 64);\n",
        "    case 24 :\n",
        "    jmp_24 :\n",
        "        __it_set (d, 64);\n",
        "    case 16 :\n",
        "    jmp_16 :\n",
        "        __it_set (d, 64);\n",
        "    case 8 :\n",
        "    jmp_8 :\n",
        "        __it_set (d, 64);\n",
        "        break;\n",
        "    case 94 :\n",
        "        __it_set (d, 16);\n",
        "        __it_set (d, 32);\n",
        "        goto jmp_88;\n",
        "    case 86 :\n",
        "        __it_set (d, 16);\n",
        "        __it_set (d, 32);\n",
        "        goto jmp_80;\n",
        "    case 78 :\n",
        "        __it_set (d, 16);\n",
        "        __it_set (d, 32);\n",
        "        goto jmp_72;\n",
        "    case 70 :\n",
        "        __it_set (d, 16);\n",
        "        __it_set (d, 32);\n",
        "        goto jmp_64;\n",
        "    case 62 :\n",
        "        __it_set (d, 16);\n",
        "        __it_set (d, 32);\n",
        "        goto jmp_56;\n",
        "    case 54 :\n",
        "        __it_set (d, 16);\n",
        "        __it_set (d, 32);\n",
        "        goto jmp_48;\n",
        "    case 46 :\n",
        "        __it_set (d, 16);\n",
        "        __it_set (d, 32);\n",
        "        goto jmp_40;\n",
        "    case 38 :\n",
        "        __it_set (d, 16);\n",
        "        __it_set (d, 32);\n",
        "        goto jmp_32;\n",
        "    case 30 :\n",
        "        __it_set (d, 16);\n",
        "        __it_set (d, 32);\n",
        "        goto jmp_24;\n",
        "    case 22 :\n",
        "        __it_set (d, 16);\n",
        "        __it_set (d, 32);\n",
        "        goto jmp_16;\n",
        "    case 14 :\n",
        "        __it_set (d, 16);\n",
        "        __it_set (d, 32);\n",
        "        goto jmp_8;\n",
        "    case 6 :\n",
        "        __it_set (d, 16);\n",
        "        __it_set (d, 32);\n",
        "        break;\n",
        "    case 92 :\n",
        "        __it_set (d, 32);\n",
        "        goto jmp_88;\n",
        "    case 84 :\n",
        "        __it_set (d, 32);\n",
        "        goto jmp_80;\n",
        "    case 76 :\n",
        "        __it_set (d, 32);\n",
        "        goto jmp_72;\n",
        "    case 68 :\n",
        "        __it_set (d, 32);\n",
        "        goto jmp_64;\n",
        "    case 60 :\n",
        "        __it_set (d, 32);\n",
        "        goto jmp_56;\n",
        "    case 52 :\n",
        "        __it_set (d, 32);\n",
        "        goto jmp_48;\n",
        "    case 44 :\n",
        "        __it_set (d, 32);\n",
        "        goto jmp_40;\n",
        "    case 36 :\n",
        "        __it_set (d, 32);\n",
        "        goto jmp_32;\n",
        "    case 28 :\n",
        "        __it_set (d, 32);\n",
        "        goto jmp_24;\n",
        "    case 20 :\n",
        "        __it_set (d, 32);\n",
        "        goto jmp_16;\n",
        "    case 12 :\n",
        "        __it_set (d, 32);\n",
        "        goto jmp_8;\n",
        "    case 4 :\n",
        "        __it_set (d, 32);\n",
        "        break;\n",
        "    case 90 :\n",
        "        __it_set (d, 16);\n",
        "        goto jmp_88;\n",
        "    case 82 :\n",
        "        __it_set (d, 16);\n",
        "        goto jmp_80;\n",
        "    case 74 :\n",
        "        __it_set (d, 16);\n",
        "        goto jmp_72;\n",
        "    case 66 :\n",
        "        __it_set (d, 16);\n",
        "        goto jmp_64;\n",
        "    case 58 :\n",
        "        __it_set (d, 16);\n",
        "        goto jmp_56;\n",
        "    case 50 :\n",
        "        __it_set (d, 16);\n",
        "        goto jmp_48;\n",
        "    case 42 :\n",
        "        __it_set (d, 16);\n",
        "        goto jmp_40;\n",
        "    case 34 :\n",
        "        __it_set (d, 16);\n",
        "        goto jmp_32;\n",
        "    case 26 :\n",
        "        __it_set (d, 16);\n",
        "        goto jmp_24;\n",
        "    case 18 :\n",
        "        __it_set (d, 16);\n",
        "        goto jmp_16;\n",
        "    case 10 :\n",
        "        __it_set (d, 16);\n",
        "        goto jmp_8;\n",
        "    case 2 :\n",
        "        __it_set (d, 16);\n",
        "        break;\n",
        "    case 1 :\n",
        "        __it_set (d, 8);\n",
        "        break;\n",
        "    default :\n",
        "        __throw_build_bug ();\n",
        "    }\n",
        "\n",
        "#else\n",
        "    __bpf_memset_builtin (d, 0, len);\n",
        "\n",
        "#endif\n",
        "}\n"
      ],
      "called_function_list": [
        "__bpf_memset_builtin"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__bpf_no_builtin_memset": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 128,
      "endLine": 133,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/builtins.h",
      "funcName": "__bpf_no_builtin_memset",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void * d __maybe_unused",
        " __u8 c __maybe_unused",
        " __u64 len __maybe_unused"
      ],
      "output": "static__always_inline__maybe_unusedvoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused void __bpf_no_builtin_memset (void * d __maybe_unused, __u8 c __maybe_unused, __u64 len __maybe_unused)\n",
        "{\n",
        "    __throw_build_bug ();\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "memset": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 138,
      "endLine": 145,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/builtins.h",
      "funcName": "memset",
      "developer_inline_comments": [
        {
          "start_line": 135,
          "end_line": 135,
          "text": "/* Redirect any direct use in our code to throw an error. */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *d",
        " int c",
        " __u64 len"
      ],
      "output": "\\memset\\)void",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline  __nobuiltin (\"memset\") void memset (void *d, int c, __u64 len)\n",
        "{\n",
        "    if (__builtin_constant_p (len) && __builtin_constant_p (c) && c == 0)\n",
        "        __bpf_memzero (d, len);\n",
        "    else\n",
        "        __bpf_memset_builtin (d, (__u8) c, len);\n",
        "}\n"
      ],
      "called_function_list": [
        "__bpf_memzero",
        "__bpf_memset_builtin"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__bpf_memcpy_builtin": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 147,
      "endLine": 152,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/builtins.h",
      "funcName": "__bpf_memcpy_builtin",
      "developer_inline_comments": [
        {
          "start_line": 150,
          "end_line": 150,
          "text": "/* Explicit opt-in for __builtin_memcpy(). */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *d",
        " const void *s",
        " __u64 len"
      ],
      "output": "static__always_inline__maybe_unusedvoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused void __bpf_memcpy_builtin (void *d, const void *s, __u64 len)\n",
        "{\n",
        "    __builtin_memcpy (d, s, len);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__bpf_memcpy": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 154,
      "endLine": 239,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/builtins.h",
      "funcName": "__bpf_memcpy",
      "developer_inline_comments": [
        {
          "start_line": 229,
          "end_line": 233,
          "text": "/* __builtin_memcpy() is crappy slow since it cannot\n\t\t * make any assumptions about alignment & underlying\n\t\t * efficient unaligned access on the target we're\n\t\t * running.\n\t\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *d",
        " const void *s",
        " __u64 len"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void __bpf_memcpy (void *d, const void *s, __u64 len)\n",
        "{\n",
        "\n",
        "#if __clang_major__ >= 10\n",
        "    if (!__builtin_constant_p (len))\n",
        "        __throw_build_bug ();\n",
        "    d += len;\n",
        "    s += len;\n",
        "    if (len > 1 && len % 2 == 1) {\n",
        "        __it_mob (d, s, 8);\n",
        "        len -= 1;\n",
        "    }\n",
        "    switch (len) {\n",
        "    case 96 :\n",
        "        __it_mob (d, s, 64);\n",
        "    case 88 :\n",
        "    jmp_88 :\n",
        "        __it_mob (d, s, 64);\n",
        "    case 80 :\n",
        "    jmp_80 :\n",
        "        __it_mob (d, s, 64);\n",
        "    case 72 :\n",
        "    jmp_72 :\n",
        "        __it_mob (d, s, 64);\n",
        "    case 64 :\n",
        "    jmp_64 :\n",
        "        __it_mob (d, s, 64);\n",
        "    case 56 :\n",
        "    jmp_56 :\n",
        "        __it_mob (d, s, 64);\n",
        "    case 48 :\n",
        "    jmp_48 :\n",
        "        __it_mob (d, s, 64);\n",
        "    case 40 :\n",
        "    jmp_40 :\n",
        "        __it_mob (d, s, 64);\n",
        "    case 32 :\n",
        "    jmp_32 :\n",
        "        __it_mob (d, s, 64);\n",
        "    case 24 :\n",
        "    jmp_24 :\n",
        "        __it_mob (d, s, 64);\n",
        "    case 16 :\n",
        "    jmp_16 :\n",
        "        __it_mob (d, s, 64);\n",
        "    case 8 :\n",
        "    jmp_8 :\n",
        "        __it_mob (d, s, 64);\n",
        "        break;\n",
        "    case 94 :\n",
        "        __it_mob (d, s, 16);\n",
        "        __it_mob (d, s, 32);\n",
        "        goto jmp_88;\n",
        "    case 86 :\n",
        "        __it_mob (d, s, 16);\n",
        "        __it_mob (d, s, 32);\n",
        "        goto jmp_80;\n",
        "    case 78 :\n",
        "        __it_mob (d, s, 16);\n",
        "        __it_mob (d, s, 32);\n",
        "        goto jmp_72;\n",
        "    case 70 :\n",
        "        __it_mob (d, s, 16);\n",
        "        __it_mob (d, s, 32);\n",
        "        goto jmp_64;\n",
        "    case 62 :\n",
        "        __it_mob (d, s, 16);\n",
        "        __it_mob (d, s, 32);\n",
        "        goto jmp_56;\n",
        "    case 54 :\n",
        "        __it_mob (d, s, 16);\n",
        "        __it_mob (d, s, 32);\n",
        "        goto jmp_48;\n",
        "    case 46 :\n",
        "        __it_mob (d, s, 16);\n",
        "        __it_mob (d, s, 32);\n",
        "        goto jmp_40;\n",
        "    case 38 :\n",
        "        __it_mob (d, s, 16);\n",
        "        __it_mob (d, s, 32);\n",
        "        goto jmp_32;\n",
        "    case 30 :\n",
        "        __it_mob (d, s, 16);\n",
        "        __it_mob (d, s, 32);\n",
        "        goto jmp_24;\n",
        "    case 22 :\n",
        "        __it_mob (d, s, 16);\n",
        "        __it_mob (d, s, 32);\n",
        "        goto jmp_16;\n",
        "    case 14 :\n",
        "        __it_mob (d, s, 16);\n",
        "        __it_mob (d, s, 32);\n",
        "        goto jmp_8;\n",
        "    case 6 :\n",
        "        __it_mob (d, s, 16);\n",
        "        __it_mob (d, s, 32);\n",
        "        break;\n",
        "    case 92 :\n",
        "        __it_mob (d, s, 32);\n",
        "        goto jmp_88;\n",
        "    case 84 :\n",
        "        __it_mob (d, s, 32);\n",
        "        goto jmp_80;\n",
        "    case 76 :\n",
        "        __it_mob (d, s, 32);\n",
        "        goto jmp_72;\n",
        "    case 68 :\n",
        "        __it_mob (d, s, 32);\n",
        "        goto jmp_64;\n",
        "    case 60 :\n",
        "        __it_mob (d, s, 32);\n",
        "        goto jmp_56;\n",
        "    case 52 :\n",
        "        __it_mob (d, s, 32);\n",
        "        goto jmp_48;\n",
        "    case 44 :\n",
        "        __it_mob (d, s, 32);\n",
        "        goto jmp_40;\n",
        "    case 36 :\n",
        "        __it_mob (d, s, 32);\n",
        "        goto jmp_32;\n",
        "    case 28 :\n",
        "        __it_mob (d, s, 32);\n",
        "        goto jmp_24;\n",
        "    case 20 :\n",
        "        __it_mob (d, s, 32);\n",
        "        goto jmp_16;\n",
        "    case 12 :\n",
        "        __it_mob (d, s, 32);\n",
        "        goto jmp_8;\n",
        "    case 4 :\n",
        "        __it_mob (d, s, 32);\n",
        "        break;\n",
        "    case 90 :\n",
        "        __it_mob (d, s, 16);\n",
        "        goto jmp_88;\n",
        "    case 82 :\n",
        "        __it_mob (d, s, 16);\n",
        "        goto jmp_80;\n",
        "    case 74 :\n",
        "        __it_mob (d, s, 16);\n",
        "        goto jmp_72;\n",
        "    case 66 :\n",
        "        __it_mob (d, s, 16);\n",
        "        goto jmp_64;\n",
        "    case 58 :\n",
        "        __it_mob (d, s, 16);\n",
        "        goto jmp_56;\n",
        "    case 50 :\n",
        "        __it_mob (d, s, 16);\n",
        "        goto jmp_48;\n",
        "    case 42 :\n",
        "        __it_mob (d, s, 16);\n",
        "        goto jmp_40;\n",
        "    case 34 :\n",
        "        __it_mob (d, s, 16);\n",
        "        goto jmp_32;\n",
        "    case 26 :\n",
        "        __it_mob (d, s, 16);\n",
        "        goto jmp_24;\n",
        "    case 18 :\n",
        "        __it_mob (d, s, 16);\n",
        "        goto jmp_16;\n",
        "    case 10 :\n",
        "        __it_mob (d, s, 16);\n",
        "        goto jmp_8;\n",
        "    case 2 :\n",
        "        __it_mob (d, s, 16);\n",
        "        break;\n",
        "    case 1 :\n",
        "        __it_mob (d, s, 8);\n",
        "        break;\n",
        "    default :\n",
        "        __throw_build_bug ();\n",
        "    }\n",
        "\n",
        "#else\n",
        "    __bpf_memcpy_builtin (d, s, len);\n",
        "\n",
        "#endif\n",
        "}\n"
      ],
      "called_function_list": [
        "__bpf_memcpy_builtin"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__bpf_no_builtin_memcpy": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 241,
      "endLine": 246,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/builtins.h",
      "funcName": "__bpf_no_builtin_memcpy",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void * d __maybe_unused",
        " const void * s __maybe_unused",
        " __u64 len __maybe_unused"
      ],
      "output": "static__always_inline__maybe_unusedvoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused void __bpf_no_builtin_memcpy (void * d __maybe_unused, const void * s __maybe_unused, __u64 len __maybe_unused)\n",
        "{\n",
        "    __throw_build_bug ();\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "memcpy": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 251,
      "endLine": 255,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/builtins.h",
      "funcName": "memcpy",
      "developer_inline_comments": [
        {
          "start_line": 248,
          "end_line": 248,
          "text": "/* Redirect any direct use in our code to throw an error. */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *d",
        " const void *s",
        " __u64 len"
      ],
      "output": "\\memcpy\\)void",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline  __nobuiltin (\"memcpy\") void memcpy (void *d, const void *s, __u64 len)\n",
        "{\n",
        "    return __bpf_memcpy (d, s, len);\n",
        "}\n"
      ],
      "called_function_list": [
        "__bpf_memcpy"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__bpf_memcmp_builtin": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 257,
      "endLine": 270,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/builtins.h",
      "funcName": "__bpf_memcmp_builtin",
      "developer_inline_comments": [
        {
          "start_line": 260,
          "end_line": 268,
          "text": "/* Explicit opt-in for __builtin_memcmp(). We use the bcmp builtin\n\t * here for two reasons: i) we only need to know equal or non-equal\n\t * similar as in __bpf_memcmp(), and ii) if __bpf_memcmp() ends up\n\t * selecting __bpf_memcmp_builtin(), clang generats a memcmp loop.\n\t * That is, (*) -> __bpf_memcmp() -> __bpf_memcmp_builtin() ->\n\t * __builtin_memcmp() -> memcmp() -> (*), meaning it will end up\n\t * selecting our memcmp() from here. Remapping to __builtin_bcmp()\n\t * breaks this loop and resolves both needs at once.\n\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const void *x",
        " const void *y",
        " __u64 len"
      ],
      "output": "static__always_inline__maybe_unused__u64",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused __u64 __bpf_memcmp_builtin (const void *x, const void *y, __u64 len)\n",
        "{\n",
        "    return __builtin_bcmp (x, y, len);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__bpf_memcmp": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 272,
      "endLine": 345,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/builtins.h",
      "funcName": "__bpf_memcmp",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const void *x",
        " const void *y",
        " __u64 len"
      ],
      "output": "static__always_inline__u64",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __u64 __bpf_memcmp (const void *x, const void *y, __u64 len)\n",
        "{\n",
        "\n",
        "#if __clang_major__ >= 10\n",
        "    __u64 r = 0;\n",
        "    if (!__builtin_constant_p (len))\n",
        "        __throw_build_bug ();\n",
        "    x += len;\n",
        "    y += len;\n",
        "    if (len > 1 && len % 2 == 1) {\n",
        "        __it_xor (x, y, r, 8);\n",
        "        len -= 1;\n",
        "    }\n",
        "    switch (len) {\n",
        "    case 72 :\n",
        "        __it_xor (x, y, r, 64);\n",
        "    case 64 :\n",
        "    jmp_64 :\n",
        "        __it_xor (x, y, r, 64);\n",
        "    case 56 :\n",
        "    jmp_56 :\n",
        "        __it_xor (x, y, r, 64);\n",
        "    case 48 :\n",
        "    jmp_48 :\n",
        "        __it_xor (x, y, r, 64);\n",
        "    case 40 :\n",
        "    jmp_40 :\n",
        "        __it_xor (x, y, r, 64);\n",
        "    case 32 :\n",
        "    jmp_32 :\n",
        "        __it_xor (x, y, r, 64);\n",
        "    case 24 :\n",
        "    jmp_24 :\n",
        "        __it_xor (x, y, r, 64);\n",
        "    case 16 :\n",
        "    jmp_16 :\n",
        "        __it_xor (x, y, r, 64);\n",
        "    case 8 :\n",
        "    jmp_8 :\n",
        "        __it_xor (x, y, r, 64);\n",
        "        break;\n",
        "    case 70 :\n",
        "        __it_xor (x, y, r, 16);\n",
        "        __it_xor (x, y, r, 32);\n",
        "        goto jmp_64;\n",
        "    case 62 :\n",
        "        __it_xor (x, y, r, 16);\n",
        "        __it_xor (x, y, r, 32);\n",
        "        goto jmp_56;\n",
        "    case 54 :\n",
        "        __it_xor (x, y, r, 16);\n",
        "        __it_xor (x, y, r, 32);\n",
        "        goto jmp_48;\n",
        "    case 46 :\n",
        "        __it_xor (x, y, r, 16);\n",
        "        __it_xor (x, y, r, 32);\n",
        "        goto jmp_40;\n",
        "    case 38 :\n",
        "        __it_xor (x, y, r, 16);\n",
        "        __it_xor (x, y, r, 32);\n",
        "        goto jmp_32;\n",
        "    case 30 :\n",
        "        __it_xor (x, y, r, 16);\n",
        "        __it_xor (x, y, r, 32);\n",
        "        goto jmp_24;\n",
        "    case 22 :\n",
        "        __it_xor (x, y, r, 16);\n",
        "        __it_xor (x, y, r, 32);\n",
        "        goto jmp_16;\n",
        "    case 14 :\n",
        "        __it_xor (x, y, r, 16);\n",
        "        __it_xor (x, y, r, 32);\n",
        "        goto jmp_8;\n",
        "    case 6 :\n",
        "        __it_xor (x, y, r, 16);\n",
        "        __it_xor (x, y, r, 32);\n",
        "        break;\n",
        "    case 68 :\n",
        "        __it_xor (x, y, r, 32);\n",
        "        goto jmp_64;\n",
        "    case 60 :\n",
        "        __it_xor (x, y, r, 32);\n",
        "        goto jmp_56;\n",
        "    case 52 :\n",
        "        __it_xor (x, y, r, 32);\n",
        "        goto jmp_48;\n",
        "    case 44 :\n",
        "        __it_xor (x, y, r, 32);\n",
        "        goto jmp_40;\n",
        "    case 36 :\n",
        "        __it_xor (x, y, r, 32);\n",
        "        goto jmp_32;\n",
        "    case 28 :\n",
        "        __it_xor (x, y, r, 32);\n",
        "        goto jmp_24;\n",
        "    case 20 :\n",
        "        __it_xor (x, y, r, 32);\n",
        "        goto jmp_16;\n",
        "    case 12 :\n",
        "        __it_xor (x, y, r, 32);\n",
        "        goto jmp_8;\n",
        "    case 4 :\n",
        "        __it_xor (x, y, r, 32);\n",
        "        break;\n",
        "    case 66 :\n",
        "        __it_xor (x, y, r, 16);\n",
        "        goto jmp_64;\n",
        "    case 58 :\n",
        "        __it_xor (x, y, r, 16);\n",
        "        goto jmp_56;\n",
        "    case 50 :\n",
        "        __it_xor (x, y, r, 16);\n",
        "        goto jmp_48;\n",
        "    case 42 :\n",
        "        __it_xor (x, y, r, 16);\n",
        "        goto jmp_40;\n",
        "    case 34 :\n",
        "        __it_xor (x, y, r, 16);\n",
        "        goto jmp_32;\n",
        "    case 26 :\n",
        "        __it_xor (x, y, r, 16);\n",
        "        goto jmp_24;\n",
        "    case 18 :\n",
        "        __it_xor (x, y, r, 16);\n",
        "        goto jmp_16;\n",
        "    case 10 :\n",
        "        __it_xor (x, y, r, 16);\n",
        "        goto jmp_8;\n",
        "    case 2 :\n",
        "        __it_xor (x, y, r, 16);\n",
        "        break;\n",
        "    case 1 :\n",
        "        __it_xor (x, y, r, 8);\n",
        "        break;\n",
        "    default :\n",
        "        __throw_build_bug ();\n",
        "    }\n",
        "    return r;\n",
        "\n",
        "#else\n",
        "    return __bpf_memcmp_builtin (x, y, len);\n",
        "\n",
        "#endif\n",
        "}\n"
      ],
      "called_function_list": [
        "__bpf_memcmp_builtin"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__bpf_no_builtin_memcmp": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 347,
      "endLine": 353,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/builtins.h",
      "funcName": "__bpf_no_builtin_memcmp",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const void * x __maybe_unused",
        " const void * y __maybe_unused",
        " __u64 len __maybe_unused"
      ],
      "output": "static__always_inline__maybe_unused__u64",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused __u64 __bpf_no_builtin_memcmp (const void * x __maybe_unused, const void * y __maybe_unused, __u64 len __maybe_unused)\n",
        "{\n",
        "    __throw_build_bug ();\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "memcmp": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 361,
      "endLine": 366,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/builtins.h",
      "funcName": "memcmp",
      "developer_inline_comments": [
        {
          "start_line": 355,
          "end_line": 355,
          "text": "/* Redirect any direct use in our code to throw an error. */"
        },
        {
          "start_line": 358,
          "end_line": 360,
          "text": "/* Modified for our needs in that we only return either zero (x and y\n * are equal) or non-zero (x and y are non-equal).\n */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const void *x",
        " const void *y",
        " __u64 len"
      ],
      "output": "\\memcmp\\)__u64",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline  __nobuiltin (\"memcmp\") __u64 memcmp (const void *x, const void *y, __u64 len)\n",
        "{\n",
        "    return __bpf_memcmp (x, y, len);\n",
        "}\n"
      ],
      "called_function_list": [
        "__bpf_memcmp"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__bpf_memmove_builtin": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 368,
      "endLine": 373,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/builtins.h",
      "funcName": "__bpf_memmove_builtin",
      "developer_inline_comments": [
        {
          "start_line": 371,
          "end_line": 371,
          "text": "/* Explicit opt-in for __builtin_memmove(). */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *d",
        " const void *s",
        " __u64 len"
      ],
      "output": "static__always_inline__maybe_unusedvoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused void __bpf_memmove_builtin (void *d, const void *s, __u64 len)\n",
        "{\n",
        "    __builtin_memmove (d, s, len);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__bpf_memmove_bwd": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 375,
      "endLine": 379,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/builtins.h",
      "funcName": "__bpf_memmove_bwd",
      "developer_inline_comments": [
        {
          "start_line": 377,
          "end_line": 377,
          "text": "/* Our internal memcpy implementation walks backwards by default. */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *d",
        " const void *s",
        " __u64 len"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void __bpf_memmove_bwd (void *d, const void *s, __u64 len)\n",
        "{\n",
        "    __bpf_memcpy (d, s, len);\n",
        "}\n"
      ],
      "called_function_list": [
        "__bpf_memcpy"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__bpf_memmove_fwd": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 381,
      "endLine": 458,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/builtins.h",
      "funcName": "__bpf_memmove_fwd",
      "developer_inline_comments": [
        {
          "start_line": 448,
          "end_line": 452,
          "text": "/* __builtin_memmove() is crappy slow since it cannot\n\t\t * make any assumptions about alignment & underlying\n\t\t * efficient unaligned access on the target we're\n\t\t * running.\n\t\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *d",
        " const void *s",
        " __u64 len"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void __bpf_memmove_fwd (void *d, const void *s, __u64 len)\n",
        "{\n",
        "\n",
        "#if __clang_major__ >= 10\n",
        "    if (!__builtin_constant_p (len))\n",
        "        __throw_build_bug ();\n",
        "    switch (len) {\n",
        "    case 96 :\n",
        "        __it_mof (d, s, 64);\n",
        "    case 88 :\n",
        "    jmp_88 :\n",
        "        __it_mof (d, s, 64);\n",
        "    case 80 :\n",
        "    jmp_80 :\n",
        "        __it_mof (d, s, 64);\n",
        "    case 72 :\n",
        "    jmp_72 :\n",
        "        __it_mof (d, s, 64);\n",
        "    case 64 :\n",
        "    jmp_64 :\n",
        "        __it_mof (d, s, 64);\n",
        "    case 56 :\n",
        "    jmp_56 :\n",
        "        __it_mof (d, s, 64);\n",
        "    case 48 :\n",
        "    jmp_48 :\n",
        "        __it_mof (d, s, 64);\n",
        "    case 40 :\n",
        "    jmp_40 :\n",
        "        __it_mof (d, s, 64);\n",
        "    case 32 :\n",
        "    jmp_32 :\n",
        "        __it_mof (d, s, 64);\n",
        "    case 24 :\n",
        "    jmp_24 :\n",
        "        __it_mof (d, s, 64);\n",
        "    case 16 :\n",
        "    jmp_16 :\n",
        "        __it_mof (d, s, 64);\n",
        "    case 8 :\n",
        "    jmp_8 :\n",
        "        __it_mof (d, s, 64);\n",
        "        break;\n",
        "    case 94 :\n",
        "        __it_mof (d, s, 16);\n",
        "        __it_mof (d, s, 32);\n",
        "        goto jmp_88;\n",
        "    case 86 :\n",
        "        __it_mof (d, s, 16);\n",
        "        __it_mof (d, s, 32);\n",
        "        goto jmp_80;\n",
        "    case 78 :\n",
        "        __it_mof (d, s, 16);\n",
        "        __it_mof (d, s, 32);\n",
        "        goto jmp_72;\n",
        "    case 70 :\n",
        "        __it_mof (d, s, 16);\n",
        "        __it_mof (d, s, 32);\n",
        "        goto jmp_64;\n",
        "    case 62 :\n",
        "        __it_mof (d, s, 16);\n",
        "        __it_mof (d, s, 32);\n",
        "        goto jmp_56;\n",
        "    case 54 :\n",
        "        __it_mof (d, s, 16);\n",
        "        __it_mof (d, s, 32);\n",
        "        goto jmp_48;\n",
        "    case 46 :\n",
        "        __it_mof (d, s, 16);\n",
        "        __it_mof (d, s, 32);\n",
        "        goto jmp_40;\n",
        "    case 38 :\n",
        "        __it_mof (d, s, 16);\n",
        "        __it_mof (d, s, 32);\n",
        "        goto jmp_32;\n",
        "    case 30 :\n",
        "        __it_mof (d, s, 16);\n",
        "        __it_mof (d, s, 32);\n",
        "        goto jmp_24;\n",
        "    case 22 :\n",
        "        __it_mof (d, s, 16);\n",
        "        __it_mof (d, s, 32);\n",
        "        goto jmp_16;\n",
        "    case 14 :\n",
        "        __it_mof (d, s, 16);\n",
        "        __it_mof (d, s, 32);\n",
        "        goto jmp_8;\n",
        "    case 6 :\n",
        "        __it_mof (d, s, 16);\n",
        "        __it_mof (d, s, 32);\n",
        "        break;\n",
        "    case 92 :\n",
        "        __it_mof (d, s, 32);\n",
        "        goto jmp_88;\n",
        "    case 84 :\n",
        "        __it_mof (d, s, 32);\n",
        "        goto jmp_80;\n",
        "    case 76 :\n",
        "        __it_mof (d, s, 32);\n",
        "        goto jmp_72;\n",
        "    case 68 :\n",
        "        __it_mof (d, s, 32);\n",
        "        goto jmp_64;\n",
        "    case 60 :\n",
        "        __it_mof (d, s, 32);\n",
        "        goto jmp_56;\n",
        "    case 52 :\n",
        "        __it_mof (d, s, 32);\n",
        "        goto jmp_48;\n",
        "    case 44 :\n",
        "        __it_mof (d, s, 32);\n",
        "        goto jmp_40;\n",
        "    case 36 :\n",
        "        __it_mof (d, s, 32);\n",
        "        goto jmp_32;\n",
        "    case 28 :\n",
        "        __it_mof (d, s, 32);\n",
        "        goto jmp_24;\n",
        "    case 20 :\n",
        "        __it_mof (d, s, 32);\n",
        "        goto jmp_16;\n",
        "    case 12 :\n",
        "        __it_mof (d, s, 32);\n",
        "        goto jmp_8;\n",
        "    case 4 :\n",
        "        __it_mof (d, s, 32);\n",
        "        break;\n",
        "    case 90 :\n",
        "        __it_mof (d, s, 16);\n",
        "        goto jmp_88;\n",
        "    case 82 :\n",
        "        __it_mof (d, s, 16);\n",
        "        goto jmp_80;\n",
        "    case 74 :\n",
        "        __it_mof (d, s, 16);\n",
        "        goto jmp_72;\n",
        "    case 66 :\n",
        "        __it_mof (d, s, 16);\n",
        "        goto jmp_64;\n",
        "    case 58 :\n",
        "        __it_mof (d, s, 16);\n",
        "        goto jmp_56;\n",
        "    case 50 :\n",
        "        __it_mof (d, s, 16);\n",
        "        goto jmp_48;\n",
        "    case 42 :\n",
        "        __it_mof (d, s, 16);\n",
        "        goto jmp_40;\n",
        "    case 34 :\n",
        "        __it_mof (d, s, 16);\n",
        "        goto jmp_32;\n",
        "    case 26 :\n",
        "        __it_mof (d, s, 16);\n",
        "        goto jmp_24;\n",
        "    case 18 :\n",
        "        __it_mof (d, s, 16);\n",
        "        goto jmp_16;\n",
        "    case 10 :\n",
        "        __it_mof (d, s, 16);\n",
        "        goto jmp_8;\n",
        "    case 2 :\n",
        "        __it_mof (d, s, 16);\n",
        "        break;\n",
        "    case 1 :\n",
        "        __it_mof (d, s, 8);\n",
        "        break;\n",
        "    default :\n",
        "        __throw_build_bug ();\n",
        "    }\n",
        "\n",
        "#else\n",
        "    __bpf_memmove_builtin (d, s, len);\n",
        "\n",
        "#endif\n",
        "}\n"
      ],
      "called_function_list": [
        "__bpf_memmove_builtin"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__bpf_no_builtin_memmove": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 460,
      "endLine": 465,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/builtins.h",
      "funcName": "__bpf_no_builtin_memmove",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void * d __maybe_unused",
        " const void * s __maybe_unused",
        " __u64 len __maybe_unused"
      ],
      "output": "static__always_inline__maybe_unusedvoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused void __bpf_no_builtin_memmove (void * d __maybe_unused, const void * s __maybe_unused, __u64 len __maybe_unused)\n",
        "{\n",
        "    __throw_build_bug ();\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__bpf_memmove": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 470,
      "endLine": 485,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/builtins.h",
      "funcName": "__bpf_memmove",
      "developer_inline_comments": [
        {
          "start_line": 467,
          "end_line": 467,
          "text": "/* Redirect any direct use in our code to throw an error. */"
        },
        {
          "start_line": 472,
          "end_line": 480,
          "text": "/* Note, the forward walking memmove() might not work with on-stack data\n\t * since we'll end up walking the memory unaligned even when __align_stack_8\n\t * is set. Should not matter much since we'll use memmove() mostly or only\n\t * on pkt data.\n\t *\n\t * Example with d, s, len = 12 bytes:\n\t *   * __bpf_memmove_fwd() emits: mov_32 d[0],s[0]; mov_64 d[4],s[4]\n\t *   * __bpf_memmove_bwd() emits: mov_32 d[8],s[8]; mov_64 d[0],s[0]\n\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *d",
        " const void *s",
        " __u64 len"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void __bpf_memmove (void *d, const void *s, __u64 len)\n",
        "{\n",
        "    if (d <= s)\n",
        "        return __bpf_memmove_fwd (d, s, len);\n",
        "    else\n",
        "        return __bpf_memmove_bwd (d, s, len);\n",
        "}\n"
      ],
      "called_function_list": [
        "__bpf_memmove_fwd",
        "__bpf_memmove_bwd"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "memmove": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 487,
      "endLine": 492,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/builtins.h",
      "funcName": "memmove",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void *d",
        " const void *s",
        " __u64 len"
      ],
      "output": "\\memmove\\)void",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline  __nobuiltin (\"memmove\") void memmove (void *d, const void *s, __u64 len)\n",
        "{\n",
        "    return __bpf_memmove (d, s, len);\n",
        "}\n"
      ],
      "called_function_list": [
        "__bpf_memmove"
      ],
      "call_depth": 4,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "tail_call_static": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 10,
      "endLine": 33,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/tailcall.h",
      "funcName": "tail_call_static",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */"
        },
        {
          "start_line": 2,
          "end_line": 2,
          "text": "/* Copyright Authors of Cilium */"
        },
        {
          "start_line": 17,
          "end_line": 26,
          "text": "/* Don't gamble, but _guarantee_ that LLVM won't optimize setting\n\t * r2 and r3 from different paths ending up at the same call insn as\n\t * otherwise we won't be able to use the jmpq/nopl retpoline-free\n\t * patching by the x86-64 JIT in the kernel.\n\t *\n\t * Note on clobber list: we need to stay in-line with BPF calling\n\t * convention, so even if we don't end up using r0, r4, r5, we need\n\t * to mark them as clobber so that LLVM doesn't end up using them\n\t * before / after the call.\n\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct  __ctx_buff *ctx",
        " const void *map",
        " const __u32 slot"
      ],
      "output": "static__always_inline__maybe_unusedvoid",
      "helper": [
        "tail_call"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused void tail_call_static (const struct  __ctx_buff *ctx, const void *map, const __u32 slot)\n",
        "{\n",
        "    if (!__builtin_constant_p (slot))\n",
        "        __throw_build_bug ();\n",
        "    asm volatile (\"r1 = %[ctx]\\n\\t\"\n",
        "        \"r2 = %[map]\\n\\t\"\n",
        "        \"r3 = %[slot]\\n\\t\"\n",
        "        \"call 12\\n\\t\"\n",
        "        : : [ctx] \"r\"\n",
        "        (ctx), [map] \"r\"\n",
        "        (map), [slot] \"i\"\n",
        "        (slot) : \"r0\",\n",
        "        \"r1\",\n",
        "        \"r2\",\n",
        "        \"r3\",\n",
        "        \"r4\",\n",
        "        \"r5\"\n",
        "        );\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "tail_call_dynamic": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 35,
      "endLine": 46,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/tailcall.h",
      "funcName": "tail_call_dynamic",
      "developer_inline_comments": [
        {
          "start_line": 41,
          "end_line": 44,
          "text": "/* Only for the case where slot is not known at compilation time,\n\t * we give LLVM a free pass to optimize since we cannot do much\n\t * here anyway as x86-64 JIT will emit a retpoline for this case.\n\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __ctx_buff *ctx",
        " const void *map",
        " __u32 slot"
      ],
      "output": "static__always_inline__maybe_unusedvoid",
      "helper": [
        "tail_call"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused void tail_call_dynamic (struct  __ctx_buff *ctx, const void *map, __u32 slot)\n",
        "{\n",
        "    if (__builtin_constant_p (slot))\n",
        "        __throw_build_bug ();\n",
        "    tail_call (ctx, map, slot);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "relax_verifier": [
    {
      "capabilities": [
        {
          "capability": "read_sys_info",
          "read_sys_info": [
            {
              "Project": "cilium",
              "Return Type": "u32",
              "Description": "Get the SMP (symmetric multiprocessing) processor id. Note that all programs run with preemption disabled , which means that the SMP processor id is stable during all the execution of the program. ",
              "Return": " The SMP id of the processor running the program.",
              "Function Name": "get_smp_processor_id",
              "Input Params": [
                "{Type: voi ,Var: void}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "read_sys_info"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 13,
      "endLine": 18,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/verifier.h",
      "funcName": "relax_verifier",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */"
        },
        {
          "start_line": 2,
          "end_line": 2,
          "text": "/* Copyright Authors of Cilium */"
        },
        {
          "start_line": 9,
          "end_line": 12,
          "text": "/* relax_verifier is a dummy helper call to introduce a pruning checkpoint\n * to help relax the verifier to avoid reaching complexity limits on older\n * kernels.\n */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void"
      ],
      "output": "static__always_inlinevoid",
      "helper": [
        "get_smp_processor_id"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void relax_verifier (void)\n",
        "{\n",
        "\n",
        "#ifndef HAVE_LARGE_INSN_LIMIT\n",
        "    volatile int __maybe_unused id = get_smp_processor_id ();\n",
        "\n",
        "#endif\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "map_array_get_32": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 10,
      "endLine": 33,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/access.h",
      "funcName": "map_array_get_32",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */"
        },
        {
          "start_line": 2,
          "end_line": 2,
          "text": "/* Copyright Authors of Cilium */"
        },
        {
          "start_line": 19,
          "end_line": 23,
          "text": "/* LLVM tends to optimize code away that is needed for the verifier to\n\t * understand dynamic map access. Input constraint is that index < limit\n\t * for this util function, so we never fail here, and returned datum is\n\t * always valid.\n\t */"
        },
        {
          "start_line": 30,
          "end_line": 30,
          "text": "/* no clobbers */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const __u32 *array",
        " __u32 index",
        " const __u32 limit"
      ],
      "output": "static__always_inline__maybe_unused__u32",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused __u32 map_array_get_32 (const __u32 *array, __u32 index, const __u32 limit)\n",
        "{\n",
        "    __u32 datum = 0;\n",
        "    if (__builtin_constant_p (index) || !__builtin_constant_p (limit))\n",
        "        __throw_build_bug ();\n",
        "    asm volatile (\"%[index] <<= 2\\n\\t\"\n",
        "        \"if %[index] > %[limit] goto +1\\n\\t\"\n",
        "        \"%[array] += %[index]\\n\\t\"\n",
        "        \"%[datum] = *(u32 *)(%[array] + 0)\\n\\t\"\n",
        "        : [datum] \"=r\"\n",
        "        (datum) : [limit] \"i\"\n",
        "        (limit), [array] \"r\"\n",
        "        (array), [index] \"r\"\n",
        "        (index) :);\n",
        "    return datum;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "csum_fold": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 10,
      "endLine": 15,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/csum.h",
      "funcName": "csum_fold",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */"
        },
        {
          "start_line": 2,
          "end_line": 2,
          "text": "/* Copyright Authors of Cilium */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "__wsum csum"
      ],
      "output": "static__always_inline__sum16",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __sum16 csum_fold (__wsum csum)\n",
        "{\n",
        "    csum = (csum & 0xffff) + (csum >> 16);\n",
        "    csum = (csum & 0xffff) + (csum >> 16);\n",
        "    return (__sum16) ~csum;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "csum_unfold": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 17,
      "endLine": 20,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/csum.h",
      "funcName": "csum_unfold",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "__sum16 csum"
      ],
      "output": "static__always_inline__wsum",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __wsum csum_unfold (__sum16 csum)\n",
        "{\n",
        "    return (__wsum) csum;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "csum_add": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 22,
      "endLine": 26,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/csum.h",
      "funcName": "csum_add",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "__wsum csum",
        " __wsum addend"
      ],
      "output": "static__always_inline__wsum",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __wsum csum_add (__wsum csum, __wsum addend)\n",
        "{\n",
        "    csum += addend;\n",
        "    return csum + (csum < addend);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "csum_sub": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 28,
      "endLine": 31,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/csum.h",
      "funcName": "csum_sub",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "__wsum csum",
        " __wsum addend"
      ],
      "output": "static__always_inline__wsum",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __wsum csum_sub (__wsum csum, __wsum addend)\n",
        "{\n",
        "    return csum_add (csum, ~addend);\n",
        "}\n"
      ],
      "called_function_list": [
        "csum_add"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "csum_diff": [
    {
      "capabilities": [
        {
          "capability": "read_skb",
          "read_skb": [
            {
              "Project": "cilium",
              "Return Type": "s64",
              "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ",
              "Return": " The checksum result, or a negative error code in case of failure.",
              "Function Name": "csum_diff",
              "Input Params": [
                "{Type: __be32 ,Var: *from}",
                "{Type:  u32 ,Var: from_size}",
                "{Type:  __be32 ,Var: *to}",
                "{Type:  u32 ,Var: to_size}",
                "{Type:  __wsum ,Var: seed}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "xdp",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "lwt_seg6local"
              ],
              "capabilities": [
                "read_skb"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 33,
      "endLine": 52,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/csum.h",
      "funcName": "csum_diff",
      "developer_inline_comments": [
        {
          "start_line": 39,
          "end_line": 41,
          "text": "/* Optimizations for frequent hot-path cases that are tiny to just\n\t\t * inline into the code instead of calling more expensive helper.\n\t\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const void *from",
        " __u32 size_from",
        " const void *to",
        " __u32 size_to",
        " __u32 seed"
      ],
      "output": "static__always_inline__wsum",
      "helper": [
        "csum_diff"
      ],
      "compatibleHookpoints": [
        "lwt_seg6local",
        "sched_act",
        "xdp",
        "lwt_xmit",
        "sched_cls",
        "lwt_in",
        "lwt_out"
      ],
      "source": [
        "static __always_inline __wsum csum_diff (const void *from, __u32 size_from, const void *to, __u32 size_to, __u32 seed)\n",
        "{\n",
        "    if (__builtin_constant_p (size_from) && __builtin_constant_p (size_to)) {\n",
        "        if (size_from == 4 && size_to == 4 && __builtin_constant_p (seed) && seed == 0)\n",
        "            return csum_add (~(*(__u32*) from), *(__u32*) to);\n",
        "        if (size_from == 4 && size_to == 4)\n",
        "            return csum_add (seed, csum_add (~(*(__u32*) from), *(__u32*) to));\n",
        "    }\n",
        "    return csum_diff_external (from, size_from, to, size_to, seed);\n",
        "}\n"
      ],
      "called_function_list": [
        "csum_add"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "bpf_barrier": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 86,
      "endLine": 93,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/compiler.h",
      "funcName": "bpf_barrier",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */"
        },
        {
          "start_line": 2,
          "end_line": 2,
          "text": "/* Copyright Authors of Cilium */"
        },
        {
          "start_line": 47,
          "end_line": 47,
          "text": "/* Mainly for documentation purpose. */"
        },
        {
          "start_line": 51,
          "end_line": 51,
          "text": "/* stddef.h defines its own */"
        },
        {
          "start_line": 88,
          "end_line": 91,
          "text": "/* Workaround to avoid verifier complaint:\n\t * \"dereference of modified ctx ptr R5 off=48+0, ctx+const is allowed,\n\t *        ctx+const+const is not\"\n\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "void"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void bpf_barrier (void)\n",
        "{\n",
        "    barrier ();\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ctx_redirect": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 60,
      "endLine": 64,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/skb.h",
      "funcName": "ctx_redirect",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */"
        },
        {
          "start_line": 2,
          "end_line": 2,
          "text": "/* Copyright Authors of Cilium */"
        },
        {
          "start_line": 30,
          "end_line": 30,
          "text": "/* Discouraged since prologue will unclone full skb. */"
        },
        {
          "start_line": 53,
          "end_line": 56,
          "text": "/* Avoid expensive calls into the kernel flow dissector if it's not an L4\n * hash. We currently only use the hash for debugging. If needed later, we\n * can map it to BPF_FUNC(get_hash_recalc) to get the L4 hash.\n */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct  __sk_buff * ctx __maybe_unused",
        " int ifindex",
        " __u32 flags"
      ],
      "output": "static__always_inline__maybe_unusedint",
      "helper": [
        "redirect"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp",
        "lwt_xmit"
      ],
      "source": [
        "static __always_inline __maybe_unused int ctx_redirect (const struct  __sk_buff * ctx __maybe_unused, int ifindex, __u32 flags)\n",
        "{\n",
        "    return redirect (ifindex, flags);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [
        {
          "capability": "pkt_alter_or_redo_processing_or_interface",
          "pkt_alter_or_redo_processing_or_interface": [
            {
              "Project": "libbpf",
              "Return Type": "int",
              "Input Params": [],
              "Function Name": "XDP_TX",
              "Return": 3,
              "Description": "an efficient option to transmit the network packet out of the same NIC it just arrived on again. This is typically useful when few nodes are implementing, for example, firewalling with subsequent load balancing in a cluster and thus act as a hairpinned load balancer pushing the incoming packets back into the switch after rewriting them in XDP BPF.",
              "compatible_hookpoints": [
                "xdp"
              ],
              "capabilities": [
                "pkt_alter_or_redo_processing_or_interface"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 291,
      "endLine": 298,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/xdp.h",
      "funcName": "ctx_redirect",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct xdp_md *ctx",
        " int ifindex",
        " const __u32 flags"
      ],
      "output": "static__always_inline__maybe_unusedint",
      "helper": [
        "redirect",
        "XDP_TX"
      ],
      "compatibleHookpoints": [
        "xdp"
      ],
      "source": [
        "static __always_inline __maybe_unused int ctx_redirect (const struct xdp_md *ctx, int ifindex, const __u32 flags)\n",
        "{\n",
        "    if ((__u32) ifindex == ctx->ingress_ifindex)\n",
        "        return XDP_TX;\n",
        "    return redirect (ifindex, flags);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ctx_redirect_peer": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 66,
      "endLine": 70,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/skb.h",
      "funcName": "ctx_redirect_peer",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct  __sk_buff * ctx __maybe_unused",
        " int ifindex",
        " __u32 flags"
      ],
      "output": "static__always_inline__maybe_unusedint",
      "helper": [
        "redirect"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "xdp",
        "lwt_xmit"
      ],
      "source": [
        "static __always_inline __maybe_unused int ctx_redirect_peer (const struct  __sk_buff * ctx __maybe_unused, int ifindex, __u32 flags)\n",
        "{\n",
        "    return redirect_peer (ifindex, flags);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 300,
      "endLine": 307,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/xdp.h",
      "funcName": "ctx_redirect_peer",
      "developer_inline_comments": [
        {
          "start_line": 305,
          "end_line": 305,
          "text": "/* bpf_redirect_peer() is available only in TC BPF. */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct xdp_md * ctx __maybe_unused",
        " int ifindex __maybe_unused",
        " const __u32 flags __maybe_unused"
      ],
      "output": "static__always_inline__maybe_unusedint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused int ctx_redirect_peer (const struct xdp_md * ctx __maybe_unused, int ifindex __maybe_unused, const __u32 flags __maybe_unused)\n",
        "{\n",
        "    return -ENOTSUP;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ctx_adjust_troom": [
    {
      "capabilities": [
        {
          "capability": "update_pkt",
          "update_pkt": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Description": "Resize (trim or grow) the packet associated to <[ skb ]>(IP: 0) to the new len. The <[ flags ]>(IP: 2) are reserved for future usage , and must be left at zero. The basic idea is that the helper performs the needed work to change the size of the packet , then the eBPF program rewrites the rest via helpers like skb_store_bytes() , l3_csum_replace() , l3_csum_replace() and others. This helper is a slow path utility intended for replies with control messages. And because it is targeted for slow path , the helper itself can afford to be slow: it implicitly linearizes , unclones and drops offloads from the skb. A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "skb_change_tail",
              "Input Params": [
                "{Type: struct sk_buff ,Var: *skb}",
                "{Type:  u32 ,Var: len}",
                "{Type:  u64 ,Var: flags}"
              ],
              "compatible_hookpoints": [
                "sched_cls",
                "sched_act",
                "lwt_xmit",
                "sk_skb"
              ],
              "capabilities": [
                "update_pkt"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 72,
      "endLine": 76,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/skb.h",
      "funcName": "ctx_adjust_troom",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __sk_buff *ctx",
        " const __s32 len_diff"
      ],
      "output": "static__always_inline__maybe_unusedint",
      "helper": [
        "skb_change_tail"
      ],
      "compatibleHookpoints": [
        "sk_skb",
        "sched_cls",
        "sched_act",
        "lwt_xmit"
      ],
      "source": [
        "static __always_inline __maybe_unused int ctx_adjust_troom (struct  __sk_buff *ctx, const __s32 len_diff)\n",
        "{\n",
        "    return skb_change_tail (ctx, ctx->len + len_diff, 0);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [
        {
          "capability": "update_pkt",
          "update_pkt": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Description": "Adjust (move) xdp_md->data_end by <[ delta ]>(IP: 1) bytes. It is only possible to shrink the packet as of this writing , therefore <[ delta ]>(IP: 1) must be a negative integer. A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "xdp_adjust_tail",
              "Input Params": [
                "{Type: struct xdp_buff ,Var: *xdp_md}",
                "{Type:  int ,Var: delta}"
              ],
              "compatible_hookpoints": [
                "xdp"
              ],
              "capabilities": [
                "update_pkt"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 236,
      "endLine": 240,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/xdp.h",
      "funcName": "ctx_adjust_troom",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct xdp_md *ctx",
        " const __s32 len_diff"
      ],
      "output": "static__always_inline__maybe_unusedint",
      "helper": [
        "xdp_adjust_tail"
      ],
      "compatibleHookpoints": [
        "xdp"
      ],
      "source": [
        "static __always_inline __maybe_unused int ctx_adjust_troom (struct xdp_md *ctx, const __s32 len_diff)\n",
        "{\n",
        "    return xdp_adjust_tail (ctx, len_diff);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ctx_full_len": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 78,
      "endLine": 82,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/skb.h",
      "funcName": "ctx_full_len",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct  __sk_buff *ctx"
      ],
      "output": "static__always_inline__maybe_unused__u64",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused __u64 ctx_full_len (const struct  __sk_buff *ctx)\n",
        "{\n",
        "    return ctx->len;\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_data",
        "ctx_data_end"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 309,
      "endLine": 314,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/xdp.h",
      "funcName": "ctx_full_len",
      "developer_inline_comments": [
        {
          "start_line": 312,
          "end_line": 312,
          "text": "/* No non-linear section in XDP. */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct xdp_md *ctx"
      ],
      "output": "static__always_inline__maybe_unused__u64",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused __u64 ctx_full_len (const struct xdp_md *ctx)\n",
        "{\n",
        "    return ctx_data_end (ctx) - ctx_data (ctx);\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_data",
        "ctx_data_end"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ctx_wire_len": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 84,
      "endLine": 88,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/skb.h",
      "funcName": "ctx_wire_len",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct  __sk_buff *ctx"
      ],
      "output": "static__always_inline__maybe_unused__u32",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused __u32 ctx_wire_len (const struct  __sk_buff *ctx)\n",
        "{\n",
        "    return ctx->wire_len;\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_full_len"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 316,
      "endLine": 320,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/xdp.h",
      "funcName": "ctx_wire_len",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct xdp_md *ctx"
      ],
      "output": "static__always_inline__maybe_unused__u32",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused __u32 ctx_wire_len (const struct xdp_md *ctx)\n",
        "{\n",
        "    return ctx_full_len (ctx);\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_full_len"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ctx_store_meta": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 90,
      "endLine": 94,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/skb.h",
      "funcName": "ctx_store_meta",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct  __sk_buff *ctx",
        " const __u32 off",
        " __u32 data"
      ],
      "output": "static__always_inline__maybe_unusedvoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused void ctx_store_meta (struct  __sk_buff *ctx, const __u32 off, __u32 data)\n",
        "{\n",
        "    ctx->cb[off] = data;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 330,
      "endLine": 338,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/xdp.h",
      "funcName": "ctx_store_meta",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [
        " cilium_xdp_scratch"
      ],
      "input": [
        "struct xdp_md * ctx __maybe_unused",
        " const __u64 off",
        " __u32 datum"
      ],
      "output": "static__always_inline__maybe_unusedvoid",
      "helper": [
        "map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused void ctx_store_meta (struct xdp_md * ctx __maybe_unused, const __u64 off, __u32 datum)\n",
        "{\n",
        "    __u32 zero = 0, *data_meta = map_lookup_elem (&cilium_xdp_scratch, &zero);\n",
        "    if (always_succeeds (data_meta))\n",
        "        data_meta[off] = datum;\n",
        "    build_bug_on ((off + 1) * sizeof (__u32) > META_PIVOT);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ctx_load_meta": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 96,
      "endLine": 100,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/skb.h",
      "funcName": "ctx_load_meta",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct  __sk_buff *ctx",
        " const __u32 off"
      ],
      "output": "static__always_inline__maybe_unused__u32",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused __u32 ctx_load_meta (const struct  __sk_buff *ctx, const __u32 off)\n",
        "{\n",
        "    return ctx->cb[off];\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [
        {
          "capability": "map_read",
          "map_read": [
            {
              "Project": "cilium",
              "Return Type": "void*",
              "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ",
              "Return": " Map value associated to key, or NULL if no entry was found.",
              "Function Name": "map_lookup_elem",
              "Input Params": [
                "{Type: struct map ,Var: *map}",
                "{Type:  const void ,Var: *key}"
              ],
              "compatible_hookpoints": [
                "socket_filter",
                "kprobe",
                "sched_cls",
                "sched_act",
                "tracepoint",
                "xdp",
                "perf_event",
                "cgroup_skb",
                "cgroup_sock",
                "lwt_in",
                "lwt_out",
                "lwt_xmit",
                "sock_ops",
                "sk_skb",
                "cgroup_device",
                "sk_msg",
                "raw_tracepoint",
                "cgroup_sock_addr",
                "lwt_seg6local",
                "sk_reuseport",
                "flow_dissector",
                "cgroup_sysctl",
                "raw_tracepoint_writable"
              ],
              "capabilities": [
                "map_read"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 340,
      "endLine": 349,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/xdp.h",
      "funcName": "ctx_load_meta",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [
        " cilium_xdp_scratch"
      ],
      "input": [
        "const struct xdp_md * ctx __maybe_unused",
        " const __u64 off"
      ],
      "output": "static__always_inline__maybe_unused__u32",
      "helper": [
        "map_lookup_elem"
      ],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused __u32 ctx_load_meta (const struct xdp_md * ctx __maybe_unused, const __u64 off)\n",
        "{\n",
        "    __u32 zero = 0, *data_meta = map_lookup_elem (&cilium_xdp_scratch, &zero);\n",
        "    if (always_succeeds (data_meta))\n",
        "        return data_meta[off];\n",
        "    build_bug_on ((off + 1) * sizeof (__u32) > META_PIVOT);\n",
        "    return 0;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ctx_get_protocol": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 102,
      "endLine": 106,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/skb.h",
      "funcName": "ctx_get_protocol",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct  __sk_buff *ctx"
      ],
      "output": "static__always_inline__maybe_unused__u16",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused __u16 ctx_get_protocol (const struct  __sk_buff *ctx)\n",
        "{\n",
        "    return (__u16) ctx->protocol;\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_no_room",
        "ctx_data",
        "ctx_data_end"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 351,
      "endLine": 361,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/xdp.h",
      "funcName": "ctx_get_protocol",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct xdp_md *ctx"
      ],
      "output": "static__always_inline__maybe_unused__u16",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused __u16 ctx_get_protocol (const struct xdp_md *ctx)\n",
        "{\n",
        "    void *data_end = ctx_data_end (ctx);\n",
        "    struct ethhdr *eth = ctx_data (ctx);\n",
        "    if (ctx_no_room (eth + 1, data_end))\n",
        "        return 0;\n",
        "    return eth->h_proto;\n",
        "}\n"
      ],
      "called_function_list": [
        "ctx_no_room",
        "ctx_data",
        "ctx_data_end"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ctx_get_ifindex": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 108,
      "endLine": 112,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/skb.h",
      "funcName": "ctx_get_ifindex",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct  __sk_buff *ctx"
      ],
      "output": "static__always_inline__maybe_unused__u32",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused __u32 ctx_get_ifindex (const struct  __sk_buff *ctx)\n",
        "{\n",
        "    return ctx->ifindex;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    },
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 363,
      "endLine": 367,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/xdp.h",
      "funcName": "ctx_get_ifindex",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct xdp_md *ctx"
      ],
      "output": "static__always_inline__maybe_unused__u32",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused __u32 ctx_get_ifindex (const struct xdp_md *ctx)\n",
        "{\n",
        "    return ctx->ingress_ifindex;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ctx_data": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 16,
      "endLine": 19,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/common.h",
      "funcName": "ctx_data",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */"
        },
        {
          "start_line": 2,
          "end_line": 2,
          "text": "/* Copyright Authors of Cilium */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct  __ctx_buff *ctx"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void *ctx_data (const struct  __ctx_buff *ctx)\n",
        "{\n",
        "    return (void *) (unsigned long) ctx->data;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ctx_data_meta": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 21,
      "endLine": 24,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/common.h",
      "funcName": "ctx_data_meta",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct  __ctx_buff *ctx"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void *ctx_data_meta (const struct  __ctx_buff *ctx)\n",
        "{\n",
        "    return (void *) (unsigned long) ctx->data_meta;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ctx_data_end": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 26,
      "endLine": 29,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/common.h",
      "funcName": "ctx_data_end",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct  __ctx_buff *ctx"
      ],
      "output": "static__always_inlinevoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline void *ctx_data_end (const struct  __ctx_buff *ctx)\n",
        "{\n",
        "    return (void *) (unsigned long) ctx->data_end;\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ctx_no_room": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 31,
      "endLine": 34,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/common.h",
      "funcName": "ctx_no_room",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const void *needed",
        " const void *limit"
      ],
      "output": "static__always_inlinebool",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline bool ctx_no_room (const void *needed, const void *limit)\n",
        "{\n",
        "    return unlikely (needed > limit);\n",
        "}\n"
      ],
      "called_function_list": [],
      "call_depth": 0,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "xdp_load_bytes": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 34,
      "endLine": 60,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/xdp.h",
      "funcName": "xdp_load_bytes",
      "developer_inline_comments": [
        {
          "start_line": 1,
          "end_line": 1,
          "text": "/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */"
        },
        {
          "start_line": 2,
          "end_line": 2,
          "text": "/* Copyright Authors of Cilium */"
        },
        {
          "start_line": 22,
          "end_line": 22,
          "text": "/* hairpin only */"
        },
        {
          "start_line": 27,
          "end_line": 27,
          "text": "/* cb + RECIRC_MARKER + XFER_MARKER */"
        },
        {
          "start_line": 31,
          "end_line": 31,
          "text": "/* This must be a mask and all offsets guaranteed to be less than that. */"
        },
        {
          "start_line": 39,
          "end_line": 42,
          "text": "/* LLVM tends to generate code that verifier doesn't understand,\n\t * so force it the way we want it in order to open up a range\n\t * on the reg.\n\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct xdp_md *ctx",
        " __u64 off",
        " void *to",
        " const __u64 len"
      ],
      "output": "static__always_inline__maybe_unusedint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused int xdp_load_bytes (const struct xdp_md *ctx, __u64 off, void *to, const __u64 len)\n",
        "{\n",
        "    void *from;\n",
        "    int ret;\n",
        "    asm volatile (\"r1 = *(u32 *)(%[ctx] +0)\\n\\t\"\n",
        "        \"r2 = *(u32 *)(%[ctx] +4)\\n\\t\"\n",
        "        \"%[off] &= %[offmax]\\n\\t\"\n",
        "        \"r1 += %[off]\\n\\t\"\n",
        "        \"%[from] = r1\\n\\t\"\n",
        "        \"r1 += %[len]\\n\\t\"\n",
        "        \"if r1 > r2 goto +2\\n\\t\"\n",
        "        \"%[ret] = 0\\n\\t\"\n",
        "        \"goto +1\\n\\t\"\n",
        "        \"%[ret] = %[errno]\\n\\t\"\n",
        "        : [ret] \"=r\"\n",
        "        (ret), [from] \"=r\"\n",
        "        (from) : [ctx] \"r\"\n",
        "        (ctx), [off] \"r\"\n",
        "        (off), [len] \"ri\"\n",
        "        (len), [offmax] \"i\"\n",
        "        (__CTX_OFF_MAX), [errno] \"i\"\n",
        "        (- EINVAL) : \"r1\",\n",
        "        \"r2\"\n",
        "        );\n",
        "    if (!ret)\n",
        "        memcpy (to, from, len);\n",
        "    return ret;\n",
        "}\n"
      ],
      "called_function_list": [
        "memcpy"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "xdp_store_bytes": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 62,
      "endLine": 86,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/xdp.h",
      "funcName": "xdp_store_bytes",
      "developer_inline_comments": [
        {
          "start_line": 68,
          "end_line": 68,
          "text": "/* See xdp_load_bytes(). */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct xdp_md *ctx",
        " __u64 off",
        " const void *from",
        " const __u64 len",
        " __u64 flags __maybe_unused"
      ],
      "output": "static__always_inline__maybe_unusedint",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused int xdp_store_bytes (const struct xdp_md *ctx, __u64 off, const void *from, const __u64 len, __u64 flags __maybe_unused)\n",
        "{\n",
        "    void *to;\n",
        "    int ret;\n",
        "    asm volatile (\"r1 = *(u32 *)(%[ctx] +0)\\n\\t\"\n",
        "        \"r2 = *(u32 *)(%[ctx] +4)\\n\\t\"\n",
        "        \"%[off] &= %[offmax]\\n\\t\"\n",
        "        \"r1 += %[off]\\n\\t\"\n",
        "        \"%[to] = r1\\n\\t\"\n",
        "        \"r1 += %[len]\\n\\t\"\n",
        "        \"if r1 > r2 goto +2\\n\\t\"\n",
        "        \"%[ret] = 0\\n\\t\"\n",
        "        \"goto +1\\n\\t\"\n",
        "        \"%[ret] = %[errno]\\n\\t\"\n",
        "        : [ret] \"=r\"\n",
        "        (ret), [to] \"=r\"\n",
        "        (to) : [ctx] \"r\"\n",
        "        (ctx), [off] \"r\"\n",
        "        (off), [len] \"ri\"\n",
        "        (len), [offmax] \"i\"\n",
        "        (__CTX_OFF_MAX), [errno] \"i\"\n",
        "        (- EINVAL) : \"r1\",\n",
        "        \"r2\"\n",
        "        );\n",
        "    if (!ret)\n",
        "        memcpy (to, from, len);\n",
        "    return ret;\n",
        "}\n"
      ],
      "called_function_list": [
        "memcpy"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__csum_replace_by_diff": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 110,
      "endLine": 114,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/xdp.h",
      "funcName": "__csum_replace_by_diff",
      "developer_inline_comments": [
        {
          "start_line": 91,
          "end_line": 93,
          "text": "/* Fyi, remapping to stubs helps to assert that the code is not in\n * use since it otherwise triggers a verifier error.\n */"
        },
        {
          "start_line": 98,
          "end_line": 98,
          "text": "/* Already linear. */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "__sum16 *sum",
        " __wsum diff"
      ],
      "output": "static__always_inline__maybe_unusedvoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused void __csum_replace_by_diff (__sum16 *sum, __wsum diff)\n",
        "{\n",
        "    *sum = csum_fold (csum_add (diff, ~csum_unfold (*sum)));\n",
        "}\n"
      ],
      "called_function_list": [
        "csum_fold",
        "csum_add",
        "csum_unfold"
      ],
      "call_depth": 1,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "__csum_replace_by_4": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 116,
      "endLine": 120,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/xdp.h",
      "funcName": "__csum_replace_by_4",
      "developer_inline_comments": [],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "__sum16 *sum",
        " __wsum from",
        " __wsum to"
      ],
      "output": "static__always_inline__maybe_unusedvoid",
      "helper": [],
      "compatibleHookpoints": [
        "cgroup_sock",
        "cgroup_sock_addr",
        "lwt_xmit",
        "sk_skb",
        "sock_ops",
        "sk_reuseport",
        "perf_event",
        "cgroup_skb",
        "tracepoint",
        "lwt_seg6local",
        "cgroup_sysctl",
        "socket_filter",
        "flow_dissector",
        "sched_cls",
        "lwt_in",
        "lwt_out",
        "sk_msg",
        "cgroup_device",
        "raw_tracepoint_writable",
        "kprobe",
        "sched_act",
        "xdp",
        "raw_tracepoint"
      ],
      "source": [
        "static __always_inline __maybe_unused void __csum_replace_by_4 (__sum16 *sum, __wsum from, __wsum to)\n",
        "{\n",
        "    __csum_replace_by_diff (sum, csum_add (~from, to));\n",
        "}\n"
      ],
      "called_function_list": [
        "__csum_replace_by_diff",
        "csum_add"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "l3_csum_replace": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 122,
      "endLine": 154,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/xdp.h",
      "funcName": "l3_csum_replace",
      "developer_inline_comments": [
        {
          "start_line": 135,
          "end_line": 135,
          "text": "/* See xdp_load_bytes(). */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct xdp_md *ctx",
        " __u64 off",
        " const __u32 from",
        " __u32 to",
        " __u32 flags"
      ],
      "output": "static__always_inline__maybe_unusedint",
      "helper": [
        "l3_csum_replace"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "lwt_xmit"
      ],
      "source": [
        "static __always_inline __maybe_unused int l3_csum_replace (const struct xdp_md *ctx, __u64 off, const __u32 from, __u32 to, __u32 flags)\n",
        "{\n",
        "    __u32 size = flags & BPF_F_HDR_FIELD_MASK;\n",
        "    __sum16 *sum;\n",
        "    int ret;\n",
        "    if (unlikely (flags & ~(BPF_F_HDR_FIELD_MASK)))\n",
        "        return -EINVAL;\n",
        "    if (unlikely (size != 0 && size != 2))\n",
        "        return -EINVAL;\n",
        "    asm volatile (\"r1 = *(u32 *)(%[ctx] +0)\\n\\t\"\n",
        "        \"r2 = *(u32 *)(%[ctx] +4)\\n\\t\"\n",
        "        \"%[off] &= %[offmax]\\n\\t\"\n",
        "        \"r1 += %[off]\\n\\t\"\n",
        "        \"%[sum] = r1\\n\\t\"\n",
        "        \"r1 += 2\\n\\t\"\n",
        "        \"if r1 > r2 goto +2\\n\\t\"\n",
        "        \"%[ret] = 0\\n\\t\"\n",
        "        \"goto +1\\n\\t\"\n",
        "        \"%[ret] = %[errno]\\n\\t\"\n",
        "        : [ret] \"=r\"\n",
        "        (ret), [sum] \"=r\"\n",
        "        (sum) : [ctx] \"r\"\n",
        "        (ctx), [off] \"r\"\n",
        "        (off), [offmax] \"i\"\n",
        "        (__CTX_OFF_MAX), [errno] \"i\"\n",
        "        (- EINVAL) : \"r1\",\n",
        "        \"r2\"\n",
        "        );\n",
        "    if (!ret)\n",
        "        from ? __csum_replace_by_4 (sum, from, to) : __csum_replace_by_diff (sum, to);\n",
        "    return ret;\n",
        "}\n"
      ],
      "called_function_list": [
        "__csum_replace_by_diff",
        "__csum_replace_by_4"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "l4_csum_replace": [
    {
      "capabilities": [],
      "helperCallParams": {},
      "startLine": 158,
      "endLine": 196,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/xdp.h",
      "funcName": "l4_csum_replace",
      "developer_inline_comments": [
        {
          "start_line": 172,
          "end_line": 172,
          "text": "/* See xdp_load_bytes(). */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "const struct xdp_md *ctx",
        " __u64 off",
        " __u32 from",
        " __u32 to",
        " __u32 flags"
      ],
      "output": "static__always_inline__maybe_unusedint",
      "helper": [
        "l4_csum_replace"
      ],
      "compatibleHookpoints": [
        "sched_cls",
        "sched_act",
        "lwt_xmit"
      ],
      "source": [
        "static __always_inline __maybe_unused int l4_csum_replace (const struct xdp_md *ctx, __u64 off, __u32 from, __u32 to, __u32 flags)\n",
        "{\n",
        "    bool is_mmzero = flags & BPF_F_MARK_MANGLED_0;\n",
        "    __u32 size = flags & BPF_F_HDR_FIELD_MASK;\n",
        "    __sum16 *sum;\n",
        "    int ret;\n",
        "    if (unlikely (flags & ~(BPF_F_MARK_MANGLED_0 | BPF_F_PSEUDO_HDR | BPF_F_HDR_FIELD_MASK)))\n",
        "        return -EINVAL;\n",
        "    if (unlikely (size != 0 && size != 2))\n",
        "        return -EINVAL;\n",
        "    asm volatile (\"r1 = *(u32 *)(%[ctx] +0)\\n\\t\"\n",
        "        \"r2 = *(u32 *)(%[ctx] +4)\\n\\t\"\n",
        "        \"%[off] &= %[offmax]\\n\\t\"\n",
        "        \"r1 += %[off]\\n\\t\"\n",
        "        \"%[sum] = r1\\n\\t\"\n",
        "        \"r1 += 2\\n\\t\"\n",
        "        \"if r1 > r2 goto +2\\n\\t\"\n",
        "        \"%[ret] = 0\\n\\t\"\n",
        "        \"goto +1\\n\\t\"\n",
        "        \"%[ret] = %[errno]\\n\\t\"\n",
        "        : [ret] \"=r\"\n",
        "        (ret), [sum] \"=r\"\n",
        "        (sum) : [ctx] \"r\"\n",
        "        (ctx), [off] \"r\"\n",
        "        (off), [offmax] \"i\"\n",
        "        (__CTX_OFF_MAX), [errno] \"i\"\n",
        "        (- EINVAL) : \"r1\",\n",
        "        \"r2\"\n",
        "        );\n",
        "    if (!ret) {\n",
        "        if (is_mmzero && !*sum)\n",
        "            return 0;\n",
        "        from ? __csum_replace_by_4 (sum, from, to) : __csum_replace_by_diff (sum, to);\n",
        "        if (is_mmzero && !*sum)\n",
        "            *sum = CSUM_MANGLED_0;\n",
        "    }\n",
        "    return ret;\n",
        "}\n"
      ],
      "called_function_list": [
        "__csum_replace_by_diff",
        "__csum_replace_by_4"
      ],
      "call_depth": 3,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ctx_change_proto": [
    {
      "capabilities": [
        {
          "capability": "update_pkt",
          "update_pkt": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Description": "Adjust (move) xdp_md->data by <[ delta ]>(IP: 1) bytes. Note that it is possible to use a negative value for delta. This helper can be used to prepare the packet for pushing or popping headers. A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "xdp_adjust_head",
              "Input Params": [
                "{Type: struct xdp_buff ,Var: *xdp_md}",
                "{Type:  int ,Var: delta}"
              ],
              "compatible_hookpoints": [
                "xdp"
              ],
              "capabilities": [
                "update_pkt"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 198,
      "endLine": 234,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/xdp.h",
      "funcName": "ctx_change_proto",
      "developer_inline_comments": [
        {
          "start_line": 204,
          "end_line": 204,
          "text": "/* 4->6 */"
        },
        {
          "start_line": 204,
          "end_line": 204,
          "text": "/* 6->4 */"
        },
        {
          "start_line": 209,
          "end_line": 211,
          "text": "/* We make the assumption that when ctx_change_proto() is called\n\t * the target proto != current proto.\n\t */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct xdp_md * ctx __maybe_unused",
        " const __be16 proto __maybe_unused",
        " const __u64 flags __maybe_unused"
      ],
      "output": "static__always_inline__maybe_unusedint",
      "helper": [
        "xdp_adjust_head"
      ],
      "compatibleHookpoints": [
        "xdp"
      ],
      "source": [
        "static __always_inline __maybe_unused int ctx_change_proto (struct xdp_md * ctx __maybe_unused, const __be16 proto __maybe_unused, const __u64 flags __maybe_unused)\n",
        "{\n",
        "    const __s32 len_diff = proto == __constant_htons (ETH_P_IPV6) ? 20 : -20;\n",
        "    const __u32 move_len = 14;\n",
        "    void *data, *data_end;\n",
        "    int ret;\n",
        "    build_bug_on (flags != 0);\n",
        "    build_bug_on (proto != __constant_htons (ETH_P_IPV6) && proto != __constant_htons (ETH_P_IP));\n",
        "    if (len_diff < 0) {\n",
        "        data_end = ctx_data_end (ctx);\n",
        "        data = ctx_data (ctx);\n",
        "        if (data + move_len + -len_diff <= data_end)\n",
        "            __bpf_memmove_fwd (data + -len_diff, data, move_len);\n",
        "        else\n",
        "            return -EFAULT;\n",
        "    }\n",
        "    ret = xdp_adjust_head (ctx, - len_diff);\n",
        "    if (!ret && len_diff > 0) {\n",
        "        data_end = ctx_data_end (ctx);\n",
        "        data = ctx_data (ctx);\n",
        "        if (data + move_len + len_diff <= data_end)\n",
        "            __bpf_memmove_fwd (data, data + len_diff, move_len);\n",
        "        else\n",
        "            return -EFAULT;\n",
        "    }\n",
        "    return ret;\n",
        "}\n"
      ],
      "called_function_list": [
        "__bpf_memmove_fwd",
        "ctx_data_end",
        "ctx_data"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ],
  "ctx_adjust_hroom": [
    {
      "capabilities": [
        {
          "capability": "update_pkt",
          "update_pkt": [
            {
              "Project": "cilium",
              "Return Type": "int",
              "Description": "Adjust (move) xdp_md->data by <[ delta ]>(IP: 1) bytes. Note that it is possible to use a negative value for delta. This helper can be used to prepare the packet for pushing or popping headers. A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ",
              "Return": " 0 on success, or a negative error in case of failure.",
              "Function Name": "xdp_adjust_head",
              "Input Params": [
                "{Type: struct xdp_buff ,Var: *xdp_md}",
                "{Type:  int ,Var: delta}"
              ],
              "compatible_hookpoints": [
                "xdp"
              ],
              "capabilities": [
                "update_pkt"
              ]
            }
          ]
        }
      ],
      "helperCallParams": {},
      "startLine": 242,
      "endLine": 289,
      "File": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/xdp.h",
      "funcName": "ctx_adjust_hroom",
      "developer_inline_comments": [
        {
          "start_line": 256,
          "end_line": 259,
          "text": "/* XXX: Note, this hack is currently tailored to NodePort DSR\n\t * requirements and not a generic helper. If needed elsewhere,\n\t * this must be made more generic.\n\t */"
        },
        {
          "start_line": 264,
          "end_line": 264,
          "text": "/* struct {iphdr + icmphdr} */"
        },
        {
          "start_line": 266,
          "end_line": 266,
          "text": "/* struct iphdr */"
        },
        {
          "start_line": 267,
          "end_line": 267,
          "text": "/* __u32 opt[2] */"
        },
        {
          "start_line": 274,
          "end_line": 274,
          "text": "/* struct {ipv6hdr + icmp6hdr} */"
        },
        {
          "start_line": 276,
          "end_line": 276,
          "text": "/* struct ipv6hdr */"
        },
        {
          "start_line": 277,
          "end_line": 277,
          "text": "/* struct dsr_opt_v6 */"
        }
      ],
      "updateMaps": [],
      "readMaps": [],
      "input": [
        "struct xdp_md *ctx",
        " const __s32 len_diff",
        " const __u32 mode",
        " const __u64 flags __maybe_unused"
      ],
      "output": "static__always_inline__maybe_unusedint",
      "helper": [
        "xdp_adjust_head"
      ],
      "compatibleHookpoints": [
        "xdp"
      ],
      "source": [
        "static __always_inline __maybe_unused int ctx_adjust_hroom (struct xdp_md *ctx, const __s32 len_diff, const __u32 mode, const __u64 flags __maybe_unused)\n",
        "{\n",
        "    const __u32 move_len_v4 = 14 + 20;\n",
        "    const __u32 move_len_v6 = 14 + 40;\n",
        "    void *data, *data_end;\n",
        "    int ret;\n",
        "    build_bug_on (len_diff <= 0 || len_diff >= 64);\n",
        "    build_bug_on (mode != BPF_ADJ_ROOM_NET);\n",
        "    ret = xdp_adjust_head (ctx, - len_diff);\n",
        "    if (!ret) {\n",
        "        data_end = ctx_data_end (ctx);\n",
        "        data = ctx_data (ctx);\n",
        "        switch (len_diff) {\n",
        "        case 28 :\n",
        "            break;\n",
        "        case 20 :\n",
        "        case 8 :\n",
        "            if (data + move_len_v4 + len_diff <= data_end)\n",
        "                __bpf_memmove_fwd (data, data + len_diff, move_len_v4);\n",
        "            else\n",
        "                ret = -EFAULT;\n",
        "            break;\n",
        "        case 48 :\n",
        "            break;\n",
        "        case 40 :\n",
        "        case 24 :\n",
        "            if (data + move_len_v6 + len_diff <= data_end)\n",
        "                __bpf_memmove_fwd (data, data + len_diff, move_len_v6);\n",
        "            else\n",
        "                ret = -EFAULT;\n",
        "            break;\n",
        "        default :\n",
        "            __throw_build_bug ();\n",
        "        }\n",
        "    }\n",
        "    return ret;\n",
        "}\n"
      ],
      "called_function_list": [
        "__bpf_memmove_fwd",
        "ctx_data_end",
        "ctx_data"
      ],
      "call_depth": 2,
      "humanFuncDescription": [
        null
      ],
      "AI_func_description": [
        {
          "description": "",
          "author": "",
          "authorEmail": "",
          "date": "",
          "invocationParameters": ""
        }
      ]
    }
  ]
}