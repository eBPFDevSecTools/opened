{"main": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_alignchecker.c", "startLine": "44", "endLine": "99", "capability": {"capabilities": [], "helperCallParams": {}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/cilium-probe-kernel-hz.c", "startLine": "152", "endLine": "194", "capability": {"capabilities": [], "helperCallParams": {}}}], "bpf_xdp_exit": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_xdp.c", "startLine": "96", "endLine": "117", "capability": {"capabilities": [], "helperCallParams": {}}}], "tail_lb_ipv4": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_xdp.c", "startLine": "122", "endLine": "140", "capability": {"capabilities": [], "helperCallParams": {"tail_call": [{"opVar": "NA", "inpVar": ["\t\t\tep_ctx", " CILIUM_CALL_IPV6_FROM_NETDEV"]}]}}}], "check_v4_lb": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_xdp.c", "startLine": "142", "endLine": "147", "capability": {"capabilities": [], "helperCallParams": {"tail_call": [{"opVar": "NA", "inpVar": ["\tep_ctx", " CILIUM_CALL_IPV4_FROM_NETDEV"]}]}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_xdp.c", "startLine": "149", "endLine": "152", "capability": {"capabilities": [], "helperCallParams": {}}}], "check_v4": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_xdp.c", "startLine": "156", "endLine": "179", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"map_lookup_elem": [{"opVar": "NA", "inpVar": ["#ifdef CIDR4_LPM_PREFILTER\tif &CIDR4_LMAP_NAME", " &pfx\t\treturn CTX_ACT_DROP"]}, {"opVar": "NA", "inpVar": ["#endif \treturn &CIDR4_HMAP_NAME", " &pfx ?\t\tCTX_ACT_DROP : check_v4_lbctx"]}]}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_xdp.c", "startLine": "181", "endLine": "184", "capability": {"capabilities": [], "helperCallParams": {}}}], "tail_lb_ipv6": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_xdp.c", "startLine": "191", "endLine": "203", "capability": {"capabilities": [], "helperCallParams": {}}}], "check_v6_lb": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_xdp.c", "startLine": "205", "endLine": "210", "capability": {"capabilities": [], "helperCallParams": {"tail_call": [{"opVar": "NA", "inpVar": ["\tep_ctx", " CILIUM_CALL_IPV6_FROM_NETDEV"]}]}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_xdp.c", "startLine": "212", "endLine": "215", "capability": {"capabilities": [], "helperCallParams": {}}}], "check_v6": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_xdp.c", "startLine": "219", "endLine": "242", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"map_lookup_elem": [{"opVar": "NA", "inpVar": ["#ifdef CIDR6_LPM_PREFILTER\tif &CIDR6_LMAP_NAME", " &pfx\t\treturn CTX_ACT_DROP"]}, {"opVar": "NA", "inpVar": ["#endif \treturn &CIDR6_HMAP_NAME", " &pfx ?\t\tCTX_ACT_DROP : check_v6_lbctx"]}]}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_xdp.c", "startLine": "244", "endLine": "247", "capability": {"capabilities": [], "helperCallParams": {}}}], "check_filters": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_xdp.c", "startLine": "251", "endLine": "278", "capability": {"capabilities": [], "helperCallParams": {}}}], "bpf_xdp_entry": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_xdp.c", "startLine": "281", "endLine": "284", "capability": {"capabilities": [], "helperCallParams": {}}}], "from_network": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_network.c", "startLine": "15", "endLine": "88", "capability": {"capabilities": [], "helperCallParams": {}}}], "handle_ipv6": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_overlay.c", "startLine": "46", "endLine": "180", "capability": {"capabilities": [], "helperCallParams": {"redirect": [{"opVar": "NA", "inpVar": ["\t\treturn ctx_ctx", " HOST_IFINDEX", " 0"]}]}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c", "startLine": "178", "endLine": "351", "capability": {"capabilities": [], "helperCallParams": {"redirect": [{"opVar": "\tbool skip_redirect ", "inpVar": [" false"]}, {"opVar": "\t#endif #if defined(NO_REDIRECT) && !defined(ENABLE_HOST_ROUTING)\t\tif (!from_host)\t\tskip_redirect ", "inpVar": [" true"]}, {"opVar": "NA", "inpVar": ["\t#endif \tif skip_\t\treturn CTX_ACT_OK"]}, {"opVar": "\t\tret ", "inpVar": [" encap_and__with_nodeidctx", " info->tunnel_endpoint", "\t\t\t\t\t\t     info->key", " secctx", " &trace"]}, {"opVar": "\t\tret ", "inpVar": [" encap_and__netdevctx", " &key", " secctx", " &trace"]}], "tail_call": [{"opVar": "NA", "inpVar": ["\t\t\t\t\t\tep_ctx", " CILIUM_CALL_SRV6_DECAP"]}]}}}], "tail_handle_ipv6": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_overlay.c", "startLine": "183", "endLine": "192", "capability": {"capabilities": [], "helperCallParams": {}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_lxc.c", "startLine": "697", "endLine": "705", "capability": {"capabilities": [], "helperCallParams": {}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c", "startLine": "353", "endLine": "366", "capability": {"capabilities": [], "helperCallParams": {}}}], "handle_ipv4": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_overlay.c", "startLine": "196", "endLine": "333", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"map_lookup_elem": [{"opVar": "\t\t\tinfo ", "inpVar": [" &VTEP_MAP", " &vkey"]}], "redirect": [{"opVar": "NA", "inpVar": ["\t\treturn ctx_ctx", " HOST_IFINDEX", " 0"]}]}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c", "startLine": "471", "endLine": "671", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"redirect": [{"opVar": "\tbool skip_redirect ", "inpVar": [" false"]}, {"opVar": "\t#endif #if defined(NO_REDIRECT) && !defined(ENABLE_HOST_ROUTING)\t\tif (!from_host)\t\tskip_redirect ", "inpVar": [" true"]}, {"opVar": "NA", "inpVar": ["\t#endif \tif skip_\t\treturn CTX_ACT_OK"]}, {"opVar": "NA", "inpVar": ["\t\t\treturn __encap_and__with_nodeidctx", " vtep->tunnel_endpoint", "\t\t\t\t\t\t\t\tsecctx", " WORLD_ID", " &trace"]}, {"opVar": "\t\tret ", "inpVar": [" encap_and__with_nodeidctx", " info->tunnel_endpoint", "\t\t\t\t\t\t     info->key", " secctx", " &trace"]}, {"opVar": "\t\tret ", "inpVar": [" encap_and__netdevctx", " &key", " secctx", " &trace"]}], "tail_call": [{"opVar": "NA", "inpVar": ["\t\t\t\tep_ctx", " CILIUM_CALL_IPV6_FROM_NETDEV"]}], "map_lookup_elem": [{"opVar": "\t\tvtep ", "inpVar": [" &VTEP_MAP", " &vkey"]}]}}}], "tail_handle_ipv4": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_overlay.c", "startLine": "336", "endLine": "345", "capability": {"capabilities": [], "helperCallParams": {}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_lxc.c", "startLine": "1259", "endLine": "1267", "capability": {"capabilities": [], "helperCallParams": {}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c", "startLine": "673", "endLine": "686", "capability": {"capabilities": [], "helperCallParams": {}}}], "tail_handle_arp": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_overlay.c", "startLine": "353", "endLine": "395", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"map_lookup_elem": [{"opVar": "\tinfo ", "inpVar": [" &VTEP_MAP", " &vkey"]}], "redirect": [{"opVar": "NA", "inpVar": ["\tif info->tunnel_endpoint\t\treturn __encap_and__with_nodeidctx", "\t\t\t\t\t\t\tinfo->tunnel_endpoint", "\t\t\t\t\t\t\tSECLABEL", "\t\t\t\t\t\t\tWORLD_ID", "\t\t\t\t\t\t\t&trace"]}]}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_lxc.c", "startLine": "1275", "endLine": "1300", "capability": {"capabilities": [], "helperCallParams": {}}}], "is_esp": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_overlay.c", "startLine": "401", "endLine": "428", "capability": {"capabilities": [], "helperCallParams": {}}}], "from_overlay": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_overlay.c", "startLine": "435", "endLine": "527", "capability": {"capabilities": [], "helperCallParams": {"tail_call": [{"opVar": "NA", "inpVar": ["\tcase bpf_htonsETH_P_IPV6:#ifdef ENABLE_IPV6\t\tep_ctx", " CILIUM_CALL_IPV6_FROM_OVERLAY"]}, {"opVar": "NA", "inpVar": ["\tcase bpf_htonsETH_P_IP:#ifdef ENABLE_IPV4\t\tep_ctx", " CILIUM_CALL_IPV4_FROM_OVERLAY"]}, {"opVar": "NA", "inpVar": ["#ifdef ENABLE_VTEP\tcase bpf_htonsETH_P_ARP:\t\tep_ctx", " CILIUM_CALL_ARP"]}]}}}], "to_overlay": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_overlay.c", "startLine": "533", "endLine": "568", "capability": {"capabilities": [], "helperCallParams": {}}}], "redirect_to_proxy": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_lxc.c", "startLine": "157", "endLine": "162", "capability": {"capabilities": [], "helperCallParams": {"redirect": [{"opVar": "NA", "inpVar": ["_to_proxyint verdict", " enum ct_status status"]}]}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/sockops/bpf_sockops.c", "startLine": "50", "endLine": "53", "capability": {"capabilities": [], "helperCallParams": {}}}], "encode_custom_prog_meta": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_lxc.c", "startLine": "174", "endLine": "189", "capability": {"capabilities": [], "helperCallParams": {}}}], "handle_ipv6_from_lxc": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_lxc.c", "startLine": "214", "endLine": "581", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"map_lookup_elem": [{"opVar": "\t#endif \tct_buffer ", "inpVar": [" &CT_TAIL_CALL_BUFFER6", " &zero"]}], "redirect": [{"opVar": "\t#endif \t\tif ((ct_status ", "inpVar": [""]}, {"opVar": "NA", "inpVar": ["\t\t\t\treturn ctx__to_proxy6ctx", " tuple", " 0", " false"]}, {"opVar": "NA", "inpVar": ["\t\tif !from_l7lb && _to_proxyverdict", " ct_status "]}, {"opVar": "NA", "inpVar": ["\t\treturn ctx__to_proxy6ctx", " tuple", " proxy_port", " false"]}, {"opVar": "\t\t\t\tret ", "inpVar": [" encap_and__lxcctx", " tunnel_endpoint", " encrypt_key", "\t\t\t\t\t     &key", " SECLABEL", " &trace"]}, {"opVar": "NA", "inpVar": ["\t#endif\tif is_definedENABLE_HOST_ROUTING\t\treturn _direct_v6ctx", " ETH_HLEN", " ip6"]}, {"opVar": "NA", "inpVar": ["\t\treturn ctx_ctx", " HOST_IFINDEX", " BPF_F_INGRESS"]}], "tail_call": [{"opVar": "NA", "inpVar": ["\t\t\tep_ctx", " CILIUM_CALL_IPV6_NODEPORT_REVNAT"]}, {"opVar": "NA", "inpVar": ["\t\t_staticctx", " &POLICY_CALL_MAP", " HOST_EP_ID"]}]}}}], "tail_handle_ipv6_cont": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_lxc.c", "startLine": "584", "endLine": "603", "capability": {"capabilities": [], "helperCallParams": {"tail_call": [{"opVar": "NA", "inpVar": ["\t\t_staticctx", " &CUSTOM_CALLS_MAP", "\t\t\t\t CUSTOM_CALLS_IDX_IPV6_EGRESS"]}]}}}], "__tail_handle_ipv6": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_lxc.c", "startLine": "609", "endLine": "694", "capability": {"capabilities": [], "helperCallParams": {}}}], "handle_ipv4_from_lxc": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_lxc.c", "startLine": "728", "endLine": "1157", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"map_lookup_elem": [{"opVar": "\tct_buffer ", "inpVar": [" &CT_TAIL_CALL_BUFFER4", " &zero"]}, {"opVar": "\t\tvtep ", "inpVar": [" &VTEP_MAP", " &vkey"]}], "redirect": [{"opVar": "\t#endif \t\tif ((ct_status ", "inpVar": [""]}, {"opVar": "NA", "inpVar": ["\t\t\t\treturn ctx__to_proxy4ctx", " tuple", " 0", " false"]}, {"opVar": "NA", "inpVar": ["\t\tif !from_l7lb && _to_proxyverdict", " ct_status "]}, {"opVar": "NA", "inpVar": ["\t\treturn ctx__to_proxy4ctx", " tuple", " proxy_port", " false"]}, {"opVar": "\t\t\t\tret ", "inpVar": [" encap_and__lxcctx", " egress_gw_policy->gateway_ip", " encrypt_key", "\t\t\t\t\t     &key", " SECLABEL", " &trace"]}, {"opVar": "NA", "inpVar": ["\t\t\treturn __encap_and__with_nodeidctx", " vtep->tunnel_endpoint", "\t\t\t\t\t\t\t\tSECLABEL", " WORLD_ID", " &trace"]}, {"opVar": "\t\tret ", "inpVar": [" encap_and__lxcctx", " tunnel_endpoint", " encrypt_key", "\t\t\t\t\t     &key", " SECLABEL", " &trace"]}, {"opVar": "NA", "inpVar": ["\t#endif \tif is_definedENABLE_HOST_ROUTING\t\treturn _direct_v4ctx", " ETH_HLEN", " ip4"]}, {"opVar": "NA", "inpVar": ["\t\treturn ctx_ctx", " HOST_IFINDEX", " BPF_F_INGRESS"]}], "tail_call": [{"opVar": "NA", "inpVar": ["\t\t\tep_ctx", " CILIUM_CALL_IPV4_NODEPORT_REVNAT"]}, {"opVar": "NA", "inpVar": ["\t\t_staticctx", " &POLICY_CALL_MAP", " HOST_EP_ID"]}]}}}], "tail_handle_ipv4_cont": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_lxc.c", "startLine": "1160", "endLine": "1179", "capability": {"capabilities": [], "helperCallParams": {"tail_call": [{"opVar": "NA", "inpVar": ["\t\t_staticctx", " &CUSTOM_CALLS_MAP", "\t\t\t\t CUSTOM_CALLS_IDX_IPV4_EGRESS"]}]}}}], "__tail_handle_ipv4": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_lxc.c", "startLine": "1185", "endLine": "1256", "capability": {"capabilities": [], "helperCallParams": {}}}], "handle_xgress": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_lxc.c", "startLine": "1308", "endLine": "1358", "capability": {"capabilities": [], "helperCallParams": {"tail_call": [{"opVar": "NA", "inpVar": ["\t\tep_ctx", " CILIUM_CALL_IPV6_FROM_LXC"]}, {"opVar": "NA", "inpVar": ["\t\tep_ctx", " CILIUM_CALL_IPV4_FROM_LXC"]}, {"opVar": "NA", "inpVar": ["#elif definedENABLE_ARP_RESPONDER\tcase bpf_htonsETH_P_ARP:\t\tep_ctx", " CILIUM_CALL_ARP"]}]}}}], "ipv6_policy": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_lxc.c", "startLine": "1361", "endLine": "1536", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"map_lookup_elem": [{"opVar": "\tct_buffer ", "inpVar": [" &CT_TAIL_CALL_BUFFER6", " &zero"]}], "redirect": [{"opVar": "\t\tif ((ret ", "inpVar": [""]}, {"opVar": "NA", "inpVar": ["\tif _to_proxyverdict", " *ct_status "]}, {"opVar": "NA", "inpVar": ["\tif ifindex\t\treturn _epctx", " ifindex", " from_host"]}]}}}], "tail_ipv6_policy": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_lxc.c", "startLine": "1540", "endLine": "1581", "capability": {"capabilities": [], "helperCallParams": {"redirect": [{"opVar": "\tbool proxy_redirect __maybe_unused ", "inpVar": [" false"]}, {"opVar": "\t\tret ", "inpVar": [" ctx__to_proxy6ctx", " &tuple", " proxy_port", " from_host"]}, {"opVar": "\t\tproxy_redirect ", "inpVar": [" true"]}, {"opVar": "NA", "inpVar": ["#ifdef ENABLE_CUSTOM_CALLS\t\tif !proxy_ && !encode_custom_prog_metactx", " ret", " src_label "]}], "tail_call": [{"opVar": "NA", "inpVar": ["\t\t_staticctx", " &CUSTOM_CALLS_MAP", "\t\t\t\t CUSTOM_CALLS_IDX_IPV6_INGRESS"]}]}}}], "tail_ipv6_to_endpoint": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_lxc.c", "startLine": "1584", "endLine": "1659", "capability": {"capabilities": [], "helperCallParams": {"redirect": [{"opVar": "\tbool proxy_redirect __maybe_unused ", "inpVar": [" false"]}, {"opVar": "\t\tret ", "inpVar": [" ctx__to_proxy_hairpin_ipv6ctx", " proxy_port"]}, {"opVar": "\t\tproxy_redirect ", "inpVar": [" true"]}, {"opVar": "NA", "inpVar": ["#ifdef ENABLE_CUSTOM_CALLS\t\tif !proxy_ &&\t    !encode_custom_prog_metactx", " ret", " src_identity "]}], "tail_call": [{"opVar": "NA", "inpVar": ["\t\t_staticctx", " &CUSTOM_CALLS_MAP", "\t\t\t\t CUSTOM_CALLS_IDX_IPV6_INGRESS"]}]}}}], "ipv4_policy": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_lxc.c", "startLine": "1671", "endLine": "1879", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"map_lookup_elem": [{"opVar": "#endif\tct_buffer ", "inpVar": [" &CT_TAIL_CALL_BUFFER4", " &zero"]}], "redirect": [{"opVar": "\tif ((ret ", "inpVar": [""]}, {"opVar": "NA", "inpVar": ["\tif _to_proxyverdict", " *ct_status "]}, {"opVar": "NA", "inpVar": ["\tif ifindex\t\treturn _epctx", " ifindex", " from_host"]}]}}}], "tail_ipv4_policy": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_lxc.c", "startLine": "1883", "endLine": "1924", "capability": {"capabilities": [], "helperCallParams": {"redirect": [{"opVar": "\tbool proxy_redirect __maybe_unused ", "inpVar": [" false"]}, {"opVar": "\t\tret ", "inpVar": [" ctx__to_proxy4ctx", " &tuple", " proxy_port", " from_host"]}, {"opVar": "\t\tproxy_redirect ", "inpVar": [" true"]}, {"opVar": "NA", "inpVar": ["#ifdef ENABLE_CUSTOM_CALLS\t\tif !proxy_ && !encode_custom_prog_metactx", " ret", " src_label "]}], "tail_call": [{"opVar": "NA", "inpVar": ["\t\t_staticctx", " &CUSTOM_CALLS_MAP", "\t\t\t\t CUSTOM_CALLS_IDX_IPV4_INGRESS"]}]}}}], "tail_ipv4_to_endpoint": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_lxc.c", "startLine": "1927", "endLine": "2001", "capability": {"capabilities": [], "helperCallParams": {"redirect": [{"opVar": "\tbool proxy_redirect __maybe_unused ", "inpVar": [" false"]}, {"opVar": "\t\tret ", "inpVar": [" ctx__to_proxy_hairpin_ipv4ctx", " proxy_port"]}, {"opVar": "\t\tproxy_redirect ", "inpVar": [" true"]}, {"opVar": "NA", "inpVar": ["#ifdef ENABLE_CUSTOM_CALLS\t\tif !proxy_ &&\t    !encode_custom_prog_metactx", " ret", " src_identity "]}], "tail_call": [{"opVar": "NA", "inpVar": ["\t\t_staticctx", " &CUSTOM_CALLS_MAP", "\t\t\t\t CUSTOM_CALLS_IDX_IPV4_INGRESS"]}]}}}], "handle_policy": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_lxc.c", "startLine": "2024", "endLine": "2061", "capability": {"capabilities": [], "helperCallParams": {}}}], "handle_policy_egress": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_lxc.c", "startLine": "2072", "endLine": "2113", "capability": {"capabilities": [], "helperCallParams": {"tail_call": [{"opVar": "NA", "inpVar": ["#ifdef ENABLE_IPV6\tcase bpf_htonsETH_P_IPV6:\t\tep_ctx", " CILIUM_CALL_IPV6_FROM_LXC"]}, {"opVar": "NA", "inpVar": ["#endif #ifdef ENABLE_IPV4\tcase bpf_htonsETH_P_IP:\t\tep_ctx", " CILIUM_CALL_IPV4_FROM_LXC"]}]}}}], "handle_to_container": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_lxc.c", "startLine": "2120", "endLine": "2195", "capability": {"capabilities": [], "helperCallParams": {"tail_call": [{"opVar": "NA", "inpVar": ["\t\t_dynamicctx", " &POLICY_EGRESSCALL_MAP", " identity"]}, {"opVar": "NA", "inpVar": ["\t\t_staticctx", " &POLICY_CALL_MAP", " HOST_EP_ID"]}, {"opVar": "NA", "inpVar": ["#endif#ifdef ENABLE_IPV6\tcase bpf_htonsETH_P_IPV6:\t\tep_ctx", " CILIUM_CALL_IPV6_CT_INGRESS"]}, {"opVar": "NA", "inpVar": ["#endif #ifdef ENABLE_IPV4\tcase bpf_htonsETH_P_IP:\t\tep_ctx", " CILIUM_CALL_IPV4_CT_INGRESS"]}]}}}], "is_v4_loopback": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "startLine": "27", "endLine": "31", "capability": {"capabilities": [], "helperCallParams": {}}}], "is_v6_loopback": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "startLine": "33", "endLine": "39", "capability": {"capabilities": [], "helperCallParams": {}}}], "ctx_dst_port": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "startLine": "42", "endLine": "48", "capability": {"capabilities": [], "helperCallParams": {}}}], "ctx_src_port": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "startLine": "50", "endLine": "56", "capability": {"capabilities": [], "helperCallParams": {}}}], "ctx_set_port": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "startLine": "58", "endLine": "62", "capability": {"capabilities": [], "helperCallParams": {}}}], "task_in_extended_hostns": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "startLine": "64", "endLine": "72", "capability": {"capabilities": [{"capability": "read_sys_info", "read_sys_info": [{"Project": "cilium", "Return Type": "u32", "Description": "Retrieve the classid for the current task , i. e. for the net_cls cgroup to which <[ skb ]>(IP: 0) belongs. This helper can be used on TC egress path , but not on ingress. The net_cls cgroup provides an interface to tag network packets based on a user-provided identifier for all traffic coming from the tasks belonging to the related cgroup. See also the related kernel documentation , available from the Linux sources in file Documentation/admin-guide/cgroup-v1/net_cls. rst. The Linux kernel has two versions for cgroups: there are cgroups v1 and cgroups v2. Both are available to users , who can use a mixture of them , but note that the net_cls cgroup is for cgroup v1 only. This makes it incompatible with BPF programs run on cgroups , which is a cgroup-v2-only feature (a socket can only hold data for one version of cgroups at a time). This helper is only available is the kernel was compiled with the CONFIG_CGROUP_NET_CLASSID configuration option set to \"y\" or to \"m\" ", "Return": " The classid, or 0 for the default unconfigured classid.", "Function Name": "get_cgroup_classid", "Input Params": ["{Type: struct sk_buff ,Var: *skb}"]}]}], "helperCallParams": {"get_cgroup_classid": [{"opVar": "#ifdef ENABLE_MKE\t\treturn get_cgroup_classid() ", "inpVar": [""]}]}}}], "ctx_in_hostns": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "startLine": "74", "endLine": "89", "capability": {"capabilities": [], "helperCallParams": {}}}], "sock_local_cookie": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "startLine": "91", "endLine": "119", "capability": {"capabilities": [{"capability": "read_sys_info", "read_sys_info": [{"Project": "cilium", "Return Type": "u64", "Description": "Equivalent to get_socket_cookie() helper that accepts skb , but gets socket from struct sock_ops context. ", "Return": " A 8-byte long non-decreasing number.", "Function Name": "get_socket_cookie", "Input Params": ["{Type: struct sock_ops ,Var: *ctx}"]}, {"Project": "cilium", "Return Type": "u32", "Description": "Get a pseudo-random number. From a security point of view , this helper uses its own pseudo-random internal state , and cannot be used to infer the seed of other random functions in the kernel. However , it is essential to note that the generator used by the helper is not cryptographically secure. ", "Return": " A random 32-bit unsigned value.", "Function Name": "get_prandom_u32", "Input Params": ["{Type: voi ,Var: void}"]}]}], "helperCallParams": {"get_socket_cookie": [{"opVar": "NA", "inpVar": ["#ifdef BPF_HAVE_SOCKET_COOKIE\t\treturn ctx"]}], "get_prandom_u32": [{"opVar": "#else\treturn ctx->protocol ", "inpVar": [""]}]}}}], "sock_is_health_check": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "startLine": "121", "endLine": "131", "capability": {"capabilities": [], "helperCallParams": {}}}], "sock_select_slot": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "startLine": "133", "endLine": "138", "capability": {"capabilities": [{"capability": "read_sys_info", "read_sys_info": [{"Project": "cilium", "Return Type": "u32", "Description": "Get a pseudo-random number. From a security point of view , this helper uses its own pseudo-random internal state , and cannot be used to infer the seed of other random functions in the kernel. However , it is essential to note that the generator used by the helper is not cryptographically secure. ", "Return": " A random 32-bit unsigned value.", "Function Name": "get_prandom_u32", "Input Params": ["{Type: voi ,Var: void}"]}]}], "helperCallParams": {"get_prandom_u32": [{"opVar": "\treturn ctx->protocol ", "inpVar": [""]}]}}}], "sock_proto_enabled": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "startLine": "140", "endLine": "156", "capability": {"capabilities": [], "helperCallParams": {}}}], "sock4_update_revnat": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "startLine": "168", "endLine": "190", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}, {"capability": "map_update", "map_update": [{"Project": "cilium", "Return Type": "int", "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "map_update_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}", "{Type:  const void ,Var: *value}", "{Type:  u64 ,Var: flags}"]}]}], "helperCallParams": {"map_lookup_elem": [{"opVar": "\ttmp ", "inpVar": [" &LB4_REVERSE_NAT_SK_MAP", " &key"]}], "map_update_elem": [{"opVar": "\tif (!tmp || memcmp(tmp, &val, sizeof(val)))\t\tret ", "inpVar": [" &LB4_REVERSE_NAT_SK_MAP", " &key", "\t\t\t\t      &val", " 0"]}]}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "startLine": "192", "endLine": "199", "capability": {"capabilities": [], "helperCallParams": {}}}], "sock4_skip_xlate": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "startLine": "202", "endLine": "218", "capability": {"capabilities": [], "helperCallParams": {}}}], "*sock4_wildcard_lookup": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "startLine": "221", "endLine": "251", "capability": {"capabilities": [], "helperCallParams": {}}}], "*sock4_wildcard_lookup_full": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "startLine": "254", "endLine": "272", "capability": {"capabilities": [], "helperCallParams": {}}}], "sock4_skip_xlate_if_same_netns": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "startLine": "293", "endLine": "321", "capability": {"capabilities": [{"capability": "read_sys_info", "read_sys_info": [{"Project": "cilium", "Return Type": "struct sock*", "Description": "Look for UDP socket matching <[ tuple ]>(IP: 1) , optionally in a child network namespace netns. The return value must be checked , and if non-NULL , released via sk_release(). The <[ ctx ]>(IP: 0) should point to the context of the program , such as the skb or socket (depending on the hook in use). This is used to determine the base network namespace for the lookup. <[ tuple_size ]>(IP: 2) must be one of: sizeof(tuple->ipv4) Look for an IPv4 socket. sizeof(tuple->ipv6) Look for an IPv6 socket. If the <[ netns ]>(IP: 3) is a negative signed 32-bit integer , then the socket lookup table in the <[ netns ]>(IP: 3) associated with the <[ ctx ]>(IP: 0) will will be used. For the TC hooks , this is the <[ netns ]>(IP: 3) of the device in the skb. For socket hooks , this is the <[ netns ]>(IP: 3) of the socket. If <[ netns ]>(IP: 3) is any other signed 32-bit value greater than or equal to zero then it specifies the ID of the <[ netns ]>(IP: 3) relative to the <[ netns ]>(IP: 3) associated with the ctx. <[ netns ]>(IP: 3) values beyond the range of 32-bit integers are reserved for future use. All values for <[ flags ]>(IP: 4) are reserved for future usage , and must be left at zero. This helper is available only if the kernel was compiled with CONFIG_NET configuration option. ", "Return": " Pointer  to  struct  sock, or NULL in case of failure.  For sockets with                     reuseport option, the struct  sock result is  from  reuse->socks[]  using                     the hash of the tuple.", "Function Name": "sk_lookup_udp", "Input Params": ["{Type: void ,Var: *ctx}", "{Type:  struct sock_tuple ,Var: *tuple}", "{Type:  u32 ,Var: tuple_size}", "{Type:  u64 ,Var: netns}", "{Type:  u64 ,Var: flags}"]}, {"Project": "cilium", "Return Type": "struct sock*", "Description": "Look for TCP socket matching <[ tuple ]>(IP: 1) , optionally in a child network namespace netns. The return value must be checked , and if non-NULL , released via sk_release(). The <[ ctx ]>(IP: 0) should point to the context of the program , such as the skb or socket (depending on the hook in use). This is used to determine the base network namespace for the lookup. <[ tuple_size ]>(IP: 2) must be one of: sizeof(tuple->ipv4) Look for an IPv4 socket. sizeof(tuple->ipv6) Look for an IPv6 socket. If the <[ netns ]>(IP: 3) is a negative signed 32-bit integer , then the socket lookup table in the <[ netns ]>(IP: 3) associated with the <[ ctx ]>(IP: 0) will will be used. For the TC hooks , this is the <[ netns ]>(IP: 3) of the device in the skb. For socket hooks , this is the <[ netns ]>(IP: 3) of the socket. If <[ netns ]>(IP: 3) is any other signed 32-bit value greater than or equal to zero then it specifies the ID of the <[ netns ]>(IP: 3) relative to the <[ netns ]>(IP: 3) associated with the ctx. <[ netns ]>(IP: 3) values beyond the range of 32-bit integers are reserved for future use. All values for <[ flags ]>(IP: 4) are reserved for future usage , and must be left at zero. This helper is available only if the kernel was compiled with CONFIG_NET configuration option. ", "Return": " Pointer to struct  sock, or NULL in case of failure.   For  sockets  with                     reuseport  option,  the  struct  sock result is from reuse->socks[] using                     the hash of the tuple.", "Function Name": "sk_lookup_tcp", "Input Params": ["{Type: void ,Var: *ctx}", "{Type:  struct sock_tuple ,Var: *tuple}", "{Type:  u32 ,Var: tuple_size}", "{Type:  u64 ,Var: netns}", "{Type:  u64 ,Var: flags}"]}]}], "helperCallParams": {"sk_lookup_tcp": [{"opVar": "\tcase IPPROTO_TCP:\t\tsk ", "inpVar": [" ctx", " &tuple", " sizeoftuple.ipv4", "\t\t\t\t   BPF_F_CURRENT_NETNS", " 0"]}], "sk_lookup_udp": [{"opVar": "\tcase IPPROTO_UDP:\t\tsk ", "inpVar": [" ctx", " &tuple", " sizeoftuple.ipv4", "\t\t\t\t   BPF_F_CURRENT_NETNS", " 0"]}], "sk_release": [{"opVar": "NA", "inpVar": ["\t\tsk"]}]}}}], "__sock4_xlate_fwd": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "startLine": "323", "endLine": "458", "capability": {"capabilities": [], "helperCallParams": {"redirect": [{"opVar": "NA", "inpVar": ["\t\tif lb4_svc_is_localsvc &&\t    sock4_skip_xlate_if_same_netnsctx_full", " backend\t\treturn -ENXIO"]}]}}}], "__sock4_health_fwd": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "startLine": "460", "endLine": "476", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}, {"capability": "read_sys_info", "read_sys_info": [{"Project": "cilium", "Return Type": "u64", "Description": "Equivalent to get_socket_cookie() helper that accepts skb , but gets socket from struct sock_ops context. ", "Return": " A 8-byte long non-decreasing number.", "Function Name": "get_socket_cookie", "Input Params": ["{Type: struct sock_ops ,Var: *ctx}"]}]}], "helperCallParams": {"get_socket_cookie": [{"opVar": "#ifdef ENABLE_HEALTH_CHECK\t__sock_cookie key ", "inpVar": [" ctx"]}], "map_lookup_elem": [{"opVar": "\tif (!lb_skip_l4_dnat())\t\tval ", "inpVar": [" &LB4_HEALTH_MAP", " &key"]}]}}}], "sock4_connect": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "startLine": "479", "endLine": "486", "capability": {"capabilities": [], "helperCallParams": {}}}], "__sock4_post_bind": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "startLine": "489", "endLine": "520", "capability": {"capabilities": [], "helperCallParams": {}}}], "sock4_post_bind": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "startLine": "523", "endLine": "529", "capability": {"capabilities": [], "helperCallParams": {"bind": [{"opVar": "NA", "inpVar": ["\tif __sock4_post_ctx", " ctx < 0\t\treturn SYS_REJECT"]}]}}}], "sock4_auto_bind": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "startLine": "533", "endLine": "537", "capability": {"capabilities": [], "helperCallParams": {}}}], "__sock4_pre_bind": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "startLine": "539", "endLine": "559", "capability": {"capabilities": [{"capability": "map_update", "map_update": [{"Project": "cilium", "Return Type": "int", "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "map_update_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}", "{Type:  const void ,Var: *value}", "{Type:  u64 ,Var: flags}"]}]}, {"capability": "read_sys_info", "read_sys_info": [{"Project": "cilium", "Return Type": "u64", "Description": "Equivalent to get_socket_cookie() helper that accepts skb , but gets socket from struct sock_ops context. ", "Return": " A 8-byte long non-decreasing number.", "Function Name": "get_socket_cookie", "Input Params": ["{Type: struct sock_ops ,Var: *ctx}"]}]}], "helperCallParams": {"get_socket_cookie": [{"opVar": "\t\t__sock_cookie key ", "inpVar": [" ctx_full"]}], "map_update_elem": [{"opVar": "\tret ", "inpVar": [" &LB4_HEALTH_MAP", " &key", " &val", " 0"]}], "bind": [{"opVar": "NA", "inpVar": ["\tif !ret\t\tsock4_auto_ctx"]}]}}}], "sock4_pre_bind": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "startLine": "562", "endLine": "573", "capability": {"capabilities": [], "helperCallParams": {"bind": [{"opVar": "\tif (sock_is_health_check(ctx) &&\t    __sock4_pre_bind(ctx, ctx))\t\tret ", "inpVar": [" SYS_REJECT"]}]}}}], "__sock4_xlate_rev": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "startLine": "577", "endLine": "611", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}, {"capability": "map_update", "map_update": [{"Project": "cilium", "Return Type": "int", "Description": "Delete entry with <[ key ]>(IP: 1) from map. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "map_delete_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"map_lookup_elem": [{"opVar": "\tval ", "inpVar": [" &LB4_REVERSE_NAT_SK_MAP", " &key"]}], "map_delete_elem": [{"opVar": "NA", "inpVar": ["\t\t\t&LB4_REVERSE_NAT_SK_MAP", " &key"]}]}}}], "sock4_sendmsg": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "startLine": "614", "endLine": "618", "capability": {"capabilities": [], "helperCallParams": {}}}], "sock4_recvmsg": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "startLine": "621", "endLine": "625", "capability": {"capabilities": [], "helperCallParams": {}}}], "sock4_getpeername": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "startLine": "628", "endLine": "632", "capability": {"capabilities": [], "helperCallParams": {}}}], "sock6_update_revnat": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "startLine": "647", "endLine": "669", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}, {"capability": "map_update", "map_update": [{"Project": "cilium", "Return Type": "int", "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "map_update_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}", "{Type:  const void ,Var: *value}", "{Type:  u64 ,Var: flags}"]}]}], "helperCallParams": {"map_lookup_elem": [{"opVar": "\ttmp ", "inpVar": [" &LB6_REVERSE_NAT_SK_MAP", " &key"]}], "map_update_elem": [{"opVar": "\tif (!tmp || memcmp(tmp, &val, sizeof(val)))\t\tret ", "inpVar": [" &LB6_REVERSE_NAT_SK_MAP", " &key", "\t\t\t\t      &val", " 0"]}]}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "startLine": "671", "endLine": "678", "capability": {"capabilities": [], "helperCallParams": {}}}], "ctx_get_v6_address": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "startLine": "682", "endLine": "693", "capability": {"capabilities": [], "helperCallParams": {}}}], "ctx_get_v6_src_address": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "startLine": "696", "endLine": "707", "capability": {"capabilities": [], "helperCallParams": {}}}], "ctx_set_v6_address": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "startLine": "710", "endLine": "721", "capability": {"capabilities": [], "helperCallParams": {}}}], "sock6_skip_xlate": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "startLine": "723", "endLine": "739", "capability": {"capabilities": [], "helperCallParams": {}}}], "*sock6_wildcard_lookup": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "startLine": "742", "endLine": "772", "capability": {"capabilities": [], "helperCallParams": {}}}], "*sock6_wildcard_lookup_full": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "startLine": "775", "endLine": "793", "capability": {"capabilities": [], "helperCallParams": {}}}], "sock6_xlate_v4_in_v6": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "startLine": "795", "endLine": "824", "capability": {"capabilities": [], "helperCallParams": {}}}], "sock6_post_bind_v4_in_v6": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "startLine": "827", "endLine": "846", "capability": {"capabilities": [], "helperCallParams": {"bind": [{"opVar": "NA", "inpVar": ["sock6_post__v4_in_v6struct bpf_sock *ctx __maybe_unused"]}, {"opVar": "NA", "inpVar": ["\treturn __sock4_post_&fake_ctx", " ctx"]}]}}}], "__sock6_post_bind": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "startLine": "848", "endLine": "874", "capability": {"capabilities": [], "helperCallParams": {"bind": [{"opVar": "NA", "inpVar": ["\t\tif !svc\t\t\treturn sock6_post__v4_in_v6ctx"]}]}}}], "sock6_post_bind": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "startLine": "877", "endLine": "883", "capability": {"capabilities": [], "helperCallParams": {"bind": [{"opVar": "NA", "inpVar": ["\tif __sock6_post_ctx < 0\t\treturn SYS_REJECT"]}]}}}], "sock6_pre_bind_v4_in_v6": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "startLine": "887", "endLine": "911", "capability": {"capabilities": [], "helperCallParams": {"bind": [{"opVar": "NA", "inpVar": ["sock6_pre__v4_in_v6struct bpf_sock_addr *ctx __maybe_unused"]}, {"opVar": "\tret ", "inpVar": [" __sock4_pre_&fake_ctx", " ctx"]}]}}}], "sock6_auto_bind": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "startLine": "914", "endLine": "920", "capability": {"capabilities": [], "helperCallParams": {}}}], "__sock6_pre_bind": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "startLine": "923", "endLine": "944", "capability": {"capabilities": [{"capability": "map_update", "map_update": [{"Project": "cilium", "Return Type": "int", "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "map_update_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}", "{Type:  const void ,Var: *value}", "{Type:  u64 ,Var: flags}"]}]}, {"capability": "read_sys_info", "read_sys_info": [{"Project": "cilium", "Return Type": "u64", "Description": "Equivalent to get_socket_cookie() helper that accepts skb , but gets socket from struct sock_ops context. ", "Return": " A 8-byte long non-decreasing number.", "Function Name": "get_socket_cookie", "Input Params": ["{Type: struct sock_ops ,Var: *ctx}"]}]}], "helperCallParams": {"bind": [{"opVar": "NA", "inpVar": ["\tif is_v4_in_v6&val.peer.address\t\treturn sock6_pre__v4_in_v6ctx"]}, {"opVar": "NA", "inpVar": ["\tif !ret\t\tsock6_auto_ctx"]}], "get_socket_cookie": [{"opVar": "#ifdef ENABLE_IPV6\tkey ", "inpVar": [" ctx"]}], "map_update_elem": [{"opVar": "\tret ", "inpVar": [" &LB6_HEALTH_MAP", " &key", " &val", " 0"]}]}}}], "sock6_pre_bind": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "startLine": "947", "endLine": "958", "capability": {"capabilities": [], "helperCallParams": {"bind": [{"opVar": "\tif (sock_is_health_check(ctx) &&\t    __sock6_pre_bind(ctx))\t\tret ", "inpVar": [" SYS_REJECT"]}]}}}], "__sock6_xlate_fwd": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "startLine": "961", "endLine": "1062", "capability": {"capabilities": [], "helperCallParams": {}}}], "__sock6_health_fwd": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "startLine": "1064", "endLine": "1089", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}, {"capability": "read_sys_info", "read_sys_info": [{"Project": "cilium", "Return Type": "u64", "Description": "Equivalent to get_socket_cookie() helper that accepts skb , but gets socket from struct sock_ops context. ", "Return": " A 8-byte long non-decreasing number.", "Function Name": "get_socket_cookie", "Input Params": ["{Type: struct sock_ops ,Var: *ctx}"]}]}], "helperCallParams": {"get_socket_cookie": [{"opVar": "#ifdef ENABLE_IPV6\t\t__sock_cookie key ", "inpVar": [" ctx"]}], "map_lookup_elem": [{"opVar": "\t\tif (!lb_skip_l4_dnat())\t\t\tval ", "inpVar": [" &LB6_HEALTH_MAP", " &key"]}]}}}], "sock6_connect": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "startLine": "1092", "endLine": "1099", "capability": {"capabilities": [], "helperCallParams": {}}}], "sock6_xlate_rev_v4_in_v6": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "startLine": "1102", "endLine": "1130", "capability": {"capabilities": [], "helperCallParams": {}}}], "__sock6_xlate_rev": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "startLine": "1132", "endLine": "1167", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}, {"capability": "map_update", "map_update": [{"Project": "cilium", "Return Type": "int", "Description": "Delete entry with <[ key ]>(IP: 1) from map. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "map_delete_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"map_lookup_elem": [{"opVar": "\tval ", "inpVar": [" &LB6_REVERSE_NAT_SK_MAP", " &key"]}], "map_delete_elem": [{"opVar": "NA", "inpVar": ["\t\t\t&LB6_REVERSE_NAT_SK_MAP", " &key"]}]}}}], "sock6_sendmsg": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "startLine": "1170", "endLine": "1174", "capability": {"capabilities": [], "helperCallParams": {}}}], "sock6_recvmsg": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "startLine": "1177", "endLine": "1181", "capability": {"capabilities": [], "helperCallParams": {}}}], "sock6_getpeername": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_sock.c", "startLine": "1184", "endLine": "1188", "capability": {"capabilities": [], "helperCallParams": {}}}], "allow_vlan": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c", "startLine": "62", "endLine": "64", "capability": {"capabilities": [], "helperCallParams": {}}}], "rewrite_dmac_to_host": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c", "startLine": "67", "endLine": "82", "capability": {"capabilities": [], "helperCallParams": {}}}], "identity_from_ipcache_ok": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c", "startLine": "89", "endLine": "92", "capability": {"capabilities": [], "helperCallParams": {}}}], "derive_src_id": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c", "startLine": "96", "endLine": "112", "capability": {"capabilities": [], "helperCallParams": {}}}], "ipcache_lookup_srcid6": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c", "startLine": "115", "endLine": "133", "capability": {"capabilities": [], "helperCallParams": {}}}], "resolve_srcid_ipv6": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c", "startLine": "136", "endLine": "176", "capability": {"capabilities": [], "helperCallParams": {}}}], "tail_handle_ipv6_from_host": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c", "startLine": "369", "endLine": "372", "capability": {"capabilities": [], "helperCallParams": {}}}], "tail_handle_ipv6_from_netdev": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c", "startLine": "375", "endLine": "378", "capability": {"capabilities": [], "helperCallParams": {}}}], "handle_to_netdev_ipv6": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c", "startLine": "381", "endLine": "409", "capability": {"capabilities": [], "helperCallParams": {}}}], "resolve_srcid_ipv4": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c", "startLine": "414", "endLine": "469", "capability": {"capabilities": [], "helperCallParams": {}}}], "tail_handle_ipv4_from_host": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c", "startLine": "689", "endLine": "699", "capability": {"capabilities": [], "helperCallParams": {}}}], "tail_handle_ipv4_from_netdev": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c", "startLine": "702", "endLine": "705", "capability": {"capabilities": [], "helperCallParams": {}}}], "handle_to_netdev_ipv4": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c", "startLine": "708", "endLine": "727", "capability": {"capabilities": [], "helperCallParams": {}}}], "do_netdev_encrypt_pools": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c", "startLine": "733", "endLine": "788", "capability": {"capabilities": [{"capability": "read_skb", "read_skb": [{"Project": "cilium", "Return Type": "s64", "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ", "Return": " The checksum result, or a negative error code in case of failure.", "Function Name": "csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"]}]}, {"capability": "update_pkt", "update_pkt": [{"Project": "cilium", "Return Type": "int", "Description": "Recompute the layer 3 (e. g. IP) checksum for the packet associated <[ to ]>(IP: 3) skb. Computation is incremental , so the helper must know the former value of the header field that was modified (from) , the new value of this field (to) , and the number of bytes (2 or 4) for this field , stored in size. Alternatively , it is possible <[ to ]>(IP: 3) store the difference between the previous and the new values of the header field in <[ to ]>(IP: 3) , by setting <[ from ]>(IP: 2) and <[ size ]>(IP: 4) <[ to ]>(IP: 3) 0. For both methods , <[ offset ]>(IP: 1) indicates the location of the IP checksum within the packet. This helper works in combination with csum_diff() , which does not update the checksum in-place , but offers more flexibility and can handle sizes larger than 2 or 4 for the checksum <[ to ]>(IP: 3) update. A call <[ to ]>(IP: 3) this helper is susceptible <[ to ]>(IP: 3) change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "l3_csum_replace", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  u32 ,Var: offset}", "{Type:  u64 ,Var: from}", "{Type:  u64 ,Var: to}", "{Type:  u64 ,Var: size}"]}]}], "helperCallParams": {"csum_diff": [{"opVar": "\t\t\tsum ", "inpVar": [" &iphdr->daddr", " 4", " &tunnel_endpoint", " 4", " 0"]}, {"opVar": "\t\tsum ", "inpVar": [" &iphdr->saddr", " 4", " &tunnel_source", " 4", " 0"]}], "l3_csum_replace": [{"opVar": "NA", "inpVar": ["\t\tif ctx", " ETH_HLEN + offsetofstruct iphdr", " check", "\t    0", " sum", " 0 < 0 "]}, {"opVar": "NA", "inpVar": ["\t\tif ctx", " ETH_HLEN + offsetofstruct iphdr", " check", "\t    0", " sum", " 0 < 0 "]}]}}}], "do_netdev_encrypt_fib": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c", "startLine": "790", "endLine": "853", "capability": {"capabilities": [{"capability": "read_sys_info", "read_sys_info": [{"Project": "libbpf", "Return Type": "int", "Description": "Do FIB lookup in kernel tables using parameters in params. If lookup is successful and result shows packet is to be forwarded , the neighbor tables are searched for the nexthop. If successful (ie. , FIB lookup shows forwarding and nexthop is resolved) , the nexthop address is returned in ipv4_dst or ipv6_dst based on family , smac is set to mac address of egress device , dmac is set to nexthop mac address , rt_metric is set to metric from route (IPv4/IPv6 only) , and ifindex is set to the device index of the nexthop from the FIB lookup. <[ plen ]>(IP: 2) argument is the size of the passed in struct. <[ flags ]>(IP: 3) argument can be a combination of one or more of the following values: BPF_FIB_LOOKUP_DIRECT Do a direct table lookup vs full lookup using FIB rules. BPF_FIB_LOOKUP_OUTPUT Perform lookup from an egress perspective (default is ingress). <[ ctx ]>(IP: 0) is either struct xdp_md for XDP programs or struct sk_buff tc cls_act programs. Return \u00b7 < 0 if any input argument is invalid \u00b7 0 on success (packet is forwarded , nexthop neighbor exists) \u00b7 > 0 one of BPF_FIB_LKUP_RET_ codes explaining why the packet is not forwarded or needs assist from full stack ", "Function Name": "bpf_fib_lookup", "Input Params": ["{Type: void ,Var: *ctx}", "{Type:  struct bpf_fib_lookup ,Var: *params}", "{Type:  int ,Var: plen}", "{Type:  u32 ,Var: flags}"]}, {"Project": "cilium", "Return Type": "int", "Description": "Do FIB lookup in kernel tables using parameters in params. If lookup is successful and result shows packet is to be forwarded , the neighbor tables are searched for the nexthop. If successful (ie. , FIB lookup shows forwarding and nexthop is resolved) , the nexthop address is returned in ipv4_dst or ipv6_dst based on family , smac is set to mac address of egress device , dmac is set to nexthop mac address , rt_metric is set to metric from route (IPv4/IPv6 only) , and ifindex is set to the device index of the nexthop from the FIB lookup. <[ plen ]>(IP: 2) argument is the size of the passed in struct. <[ flags ]>(IP: 3) argument can be a combination of one or more of the following values: BPF_FIB_LOOKUP_DIRECT Do a direct table lookup vs full lookup using FIB rules. BPF_FIB_LOOKUP_OUTPUT Perform lookup from an egress perspective (default is ingress). <[ ctx ]>(IP: 0) is either struct xdp_md for XDP programs or struct sk_buff tc cls_act programs. Return \u00b7 < 0 if any input argument is invalid \u00b7 0 on success (packet is forwarded , nexthop neighbor exists) \u00b7 > 0 one of BPF_FIB_LKUP_RET_ codes explaining why the packet is not forwarded or needs assist from full stack ", "Function Name": "fib_lookup", "Input Params": ["{Type: void ,Var: *ctx}", "{Type:  struct fib_lookup ,Var: *params}", "{Type:  int ,Var: plen}", "{Type:  u32 ,Var: flags}"]}]}], "helperCallParams": {"bpf_fib_lookup": [{"opVar": "\t#if defined(BPF_HAVE_FIB_LOOKUP) && defined(ENCRYPT_IFACE)\tstruct bpf_fib_lookup fib_params ", "inpVar": [" "]}], "fib_lookup": [{"opVar": "\terr ", "inpVar": [" ctx", " &fib_params", " sizeoffib_params", "\t\t    BPF_FIB_LOOKUP_DIRECT | BPF_FIB_LOOKUP_OUTPUT"]}]}}}], "do_netdev_encrypt": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c", "startLine": "855", "endLine": "885", "capability": {"capabilities": [], "helperCallParams": {"redirect": [{"opVar": "NA", "inpVar": ["#ifdef BPF_HAVE_FIB_LOOKUP\t\tif encrypt_iface\t\treturn ctx_ctx", " encrypt_iface", " 0"]}]}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c", "startLine": "904", "endLine": "908", "capability": {"capabilities": [], "helperCallParams": {}}}], "do_netdev_encrypt_encap": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c", "startLine": "888", "endLine": "902", "capability": {"capabilities": [], "helperCallParams": {"redirect": [{"opVar": "NA", "inpVar": ["\treturn __encap_and__with_nodeidctx", " tunnel_endpoint", " src_id", "\t\t\t\t\t\tNOT_VTEP_DST", " &trace"]}]}}}], "do_netdev": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c", "startLine": "912", "endLine": "1022", "capability": {"capabilities": [], "helperCallParams": {"tail_call": [{"opVar": "NA", "inpVar": ["\t\t\t_dynamicctx", " &POLICY_EGRESSCALL_MAP", " lxc_id"]}, {"opVar": "NA", "inpVar": ["\t\tif from_host\t\t\tep_ctx", " CILIUM_CALL_IPV6_FROM_HOST"]}, {"opVar": "NA", "inpVar": ["\t\telse\t\t\tep_ctx", " CILIUM_CALL_IPV6_FROM_NETDEV"]}, {"opVar": "NA", "inpVar": ["# endif\t\t\tep_ctx", " CILIUM_CALL_IPV4_FROM_HOST"]}, {"opVar": "NA", "inpVar": ["\t\t\tep_ctx", " CILIUM_CALL_IPV4_FROM_NETDEV"]}]}}}], "handle_netdev": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c", "startLine": "1031", "endLine": "1051", "capability": {"capabilities": [], "helperCallParams": {}}}], "handle_srv6": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c", "startLine": "1054", "endLine": "1142", "capability": {"capabilities": [], "helperCallParams": {"tail_call": [{"opVar": "NA", "inpVar": ["\t\t\tep_ctx", " CILIUM_CALL_SRV6_REPLY"]}, {"opVar": "NA", "inpVar": ["\t\tep_ctx", " CILIUM_CALL_SRV6_ENCAP"]}, {"opVar": "NA", "inpVar": ["\t\t\tep_ctx", " CILIUM_CALL_SRV6_REPLY"]}, {"opVar": "NA", "inpVar": ["\t\tep_ctx", " CILIUM_CALL_SRV6_ENCAP"]}]}}}], "from_netdev": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c", "startLine": "1152", "endLine": "1170", "capability": {"capabilities": [], "helperCallParams": {}}}], "from_host": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c", "startLine": "1177", "endLine": "1184", "capability": {"capabilities": [], "helperCallParams": {}}}], "to_netdev": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c", "startLine": "1193", "endLine": "1319", "capability": {"capabilities": [], "helperCallParams": {"tail_call": [{"opVar": "NA", "inpVar": ["\t\t\t_dynamicctx", " &POLICY_EGRESSCALL_MAP", " lxc_id"]}]}}}], "to_host": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c", "startLine": "1326", "endLine": "1406", "capability": {"capabilities": [], "helperCallParams": {"redirect": [{"opVar": "\t\tret ", "inpVar": [" ctx__to_proxy_firstctx", " port"]}]}}}], "tail_ipv6_host_policy_ingress": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c", "startLine": "1412", "endLine": "1426", "capability": {"capabilities": [], "helperCallParams": {}}}], "tail_ipv4_host_policy_ingress": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c", "startLine": "1432", "endLine": "1446", "capability": {"capabilities": [], "helperCallParams": {}}}], "to_host_from_lxc": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c", "startLine": "1449", "endLine": "1497", "capability": {"capabilities": [], "helperCallParams": {}}}], "from_host_to_lxc": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c", "startLine": "1503", "endLine": "1545", "capability": {"capabilities": [], "helperCallParams": {}}}], "handle_lxc_traffic": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/bpf_host.c", "startLine": "1553", "endLine": "1572", "capability": {"capabilities": [], "helperCallParams": {"tail_call": [{"opVar": "NA", "inpVar": ["\t\t_dynamicctx", " &POLICY_CALL_MAP", " lxc_id"]}]}}}], "pin_to_cpu": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/cilium-probe-kernel-hz.c", "startLine": "30", "endLine": "38", "capability": {"capabilities": [], "helperCallParams": {}}}], "fix_priority": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/cilium-probe-kernel-hz.c", "startLine": "40", "endLine": "47", "capability": {"capabilities": [], "helperCallParams": {}}}], "*timer_list_open": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/cilium-probe-kernel-hz.c", "startLine": "49", "endLine": "52", "capability": {"capabilities": [], "helperCallParams": {}}}], "timer_list_close": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/cilium-probe-kernel-hz.c", "startLine": "54", "endLine": "57", "capability": {"capabilities": [], "helperCallParams": {}}}], "prep_kern_jiffies": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/cilium-probe-kernel-hz.c", "startLine": "59", "endLine": "92", "capability": {"capabilities": [], "helperCallParams": {}}}], "fetch_kern_jiffies": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/cilium-probe-kernel-hz.c", "startLine": "94", "endLine": "113", "capability": {"capabilities": [], "helperCallParams": {}}}], "dump_kern_jiffies": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/cilium-probe-kernel-hz.c", "startLine": "115", "endLine": "150", "capability": {"capabilities": [], "helperCallParams": {}}}], "sk_extract4_key": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/sockops/bpf_sockops.c", "startLine": "26", "endLine": "40", "capability": {"capabilities": [], "helperCallParams": {}}}], "sk_lb4_key": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/sockops/bpf_sockops.c", "startLine": "42", "endLine": "48", "capability": {"capabilities": [], "helperCallParams": {}}}], "bpf_sock_ops_ipv4": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/sockops/bpf_sockops.c", "startLine": "55", "endLine": "118", "capability": {"capabilities": [], "helperCallParams": {"redirect": [{"opVar": "NA", "inpVar": ["\tif _to_proxyverdict "]}], "sock_hash_update": [{"opVar": "NA", "inpVar": ["\t\tskops", " &SOCK_OPS_MAP", " &key", " BPF_NOEXIST"]}, {"opVar": "NA", "inpVar": ["\tskops", " &SOCK_OPS_MAP", " &key", " BPF_NOEXIST"]}]}}}], "bpf_sock_ops_ipv6": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/sockops/bpf_sockops.c", "startLine": "122", "endLine": "126", "capability": {"capabilities": [], "helperCallParams": {}}}], "bpf_sockmap": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/sockops/bpf_sockops.c", "startLine": "130", "endLine": "154", "capability": {"capabilities": [], "helperCallParams": {}}}], "sk_msg_extract4_key": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/sockops/bpf_redir.c", "startLine": "25", "endLine": "39", "capability": {"capabilities": [], "helperCallParams": {}}}], "bpf_redir_proxy": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/sockops/bpf_redir.c", "startLine": "42", "endLine": "67", "capability": {"capabilities": [], "helperCallParams": {"msg_redirect_hash": [{"opVar": "\tif (verdict >", "inpVar": [" 0\t\tmsg", " &SOCK_OPS_MAP", " &key", " flags"]}]}}}], "custom_hook": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/custom/bpf_custom.c", "startLine": "32", "endLine": "45", "capability": {"capabilities": [], "helperCallParams": {}}}], "l4_modify_port": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/l4.h", "startLine": "36", "endLine": "47", "capability": {"capabilities": [], "helperCallParams": {}}}], "l4_load_port": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/l4.h", "startLine": "49", "endLine": "53", "capability": {"capabilities": [], "helperCallParams": {}}}], "cilium_capture": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/pcap.h", "startLine": "48", "endLine": "75", "capability": {"capabilities": [], "helperCallParams": {}}}], "__cilium_capture_in": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/pcap.h", "startLine": "77", "endLine": "86", "capability": {"capabilities": [], "helperCallParams": {}}}], "__cilium_capture_out": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/pcap.h", "startLine": "88", "endLine": "93", "capability": {"capabilities": [], "helperCallParams": {}}}], "cilium_capture4_masked_key": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/pcap.h", "startLine": "158", "endLine": "170", "capability": {"capabilities": [], "helperCallParams": {}}}], "*cilium_capture4_classify_wcard": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/pcap.h", "startLine": "217", "endLine": "257", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"map_lookup_elem": [{"opVar": "\t\tmatch ", "inpVar": [" &CAPTURE4_RULES", " &lkey"]}]}}}], "cilium_capture6_masked_key": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/pcap.h", "startLine": "270", "endLine": "284", "capability": {"capabilities": [], "helperCallParams": {}}}], "*cilium_capture6_classify_wcard": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/pcap.h", "startLine": "339", "endLine": "382", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"map_lookup_elem": [{"opVar": "\t\tmatch ", "inpVar": [" &CAPTURE6_RULES", " &lkey"]}]}}}], "*cilium_capture_classify_wcard": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/pcap.h", "startLine": "385", "endLine": "408", "capability": {"capabilities": [], "helperCallParams": {}}}], "cilium_capture_candidate": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/pcap.h", "startLine": "410", "endLine": "432", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"map_lookup_elem": [{"opVar": "\t\tc ", "inpVar": [" &cilium_capture_cache", " &zero"]}]}}}], "cilium_capture_cached": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/pcap.h", "startLine": "434", "endLine": "455", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"map_lookup_elem": [{"opVar": "\t\t\t\tc ", "inpVar": [" &cilium_capture_cache", " &zero"]}]}}}], "cilium_capture_in": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/pcap.h", "startLine": "457", "endLine": "465", "capability": {"capabilities": [], "helperCallParams": {}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/pcap.h", "startLine": "483", "endLine": "486", "capability": {"capabilities": [], "helperCallParams": {}}}], "cilium_capture_out": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/pcap.h", "startLine": "467", "endLine": "479", "capability": {"capabilities": [], "helperCallParams": {}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/pcap.h", "startLine": "488", "endLine": "491", "capability": {"capabilities": [], "helperCallParams": {}}}], "hash_from_tuple_v4": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/hash.h", "startLine": "13", "endLine": "18", "capability": {"capabilities": [], "helperCallParams": {}}}], "hash_from_tuple_v6": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/hash.h", "startLine": "20", "endLine": "35", "capability": {"capabilities": [], "helperCallParams": {}}}], "*get_ct_map6": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack_map.h", "startLine": "40", "endLine": "47", "capability": {"capabilities": [], "helperCallParams": {}}}], "*get_ct_map4": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack_map.h", "startLine": "73", "endLine": "80", "capability": {"capabilities": [], "helperCallParams": {}}}], "*lookup_ip4_egress_gw_policy": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/egress_policies.h", "startLine": "20", "endLine": "29", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"map_lookup_elem": [{"opVar": "NA", "inpVar": ["\treturn &EGRESS_POLICY_MAP", " &key"]}]}}}], "*srv6_lookup_vrf4": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/egress_policies.h", "startLine": "44", "endLine": "53", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"map_lookup_elem": [{"opVar": "NA", "inpVar": ["\treturn &SRV6_VRF_MAP4", " &key"]}]}}}], "*srv6_lookup_policy4": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/egress_policies.h", "startLine": "63", "endLine": "72", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"map_lookup_elem": [{"opVar": "NA", "inpVar": ["\treturn &SRV6_POLICY_MAP4", " &key"]}]}}}], "*srv6_lookup_vrf6": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/egress_policies.h", "startLine": "83", "endLine": "92", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"map_lookup_elem": [{"opVar": "NA", "inpVar": ["\treturn &SRV6_VRF_MAP6", " &key"]}]}}}], "*srv6_lookup_policy6": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/egress_policies.h", "startLine": "103", "endLine": "112", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"map_lookup_elem": [{"opVar": "NA", "inpVar": ["\treturn &SRV6_POLICY_MAP6", " &key"]}]}}}], "srv6_lookup_sid": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/egress_policies.h", "startLine": "114", "endLine": "123", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"map_lookup_elem": [{"opVar": "\tvrf_id ", "inpVar": [" &SRV6_SID_MAP", " sid"]}]}}}], "is_srv6_packet": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/egress_policies.h", "startLine": "125", "endLine": "134", "capability": {"capabilities": [], "helperCallParams": {}}}], "ctx_adjust_hroom_flags": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/egress_policies.h", "startLine": "137", "endLine": "144", "capability": {"capabilities": [], "helperCallParams": {}}}], "srv6_encapsulation": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/egress_policies.h", "startLine": "146", "endLine": "171", "capability": {"capabilities": [], "helperCallParams": {}}}], "srv6_decapsulation": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/egress_policies.h", "startLine": "173", "endLine": "210", "capability": {"capabilities": [], "helperCallParams": {}}}], "srv6_create_state_entry": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/egress_policies.h", "startLine": "212", "endLine": "252", "capability": {"capabilities": [{"capability": "map_update", "map_update": [{"Project": "cilium", "Return Type": "int", "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "map_update_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}", "{Type:  const void ,Var: *value}", "{Type:  u64 ,Var: flags}"]}]}], "helperCallParams": {"map_update_elem": [{"opVar": "NA", "inpVar": ["\t\tif &SRV6_STATE_MAP6", " inner_ips", " outer_ips", " 0 < 0\t\t\treturn DROP_INVALID"]}, {"opVar": "NA", "inpVar": ["\t\tif &SRV6_STATE_MAP4", " inner_ips", " outer_ips", " 0 < 0\t\t\treturn DROP_INVALID"]}]}}}], "*srv6_lookup_state_entry4": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/egress_policies.h", "startLine": "255", "endLine": "260", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"map_lookup_elem": [{"opVar": "NA", "inpVar": ["\treturn &SRV6_STATE_MAP4", "\t\t\t       struct srv6_ipv4_2tuple *&ip4->saddr"]}]}}}], "*srv6_lookup_state_entry6": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/egress_policies.h", "startLine": "263", "endLine": "268", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"map_lookup_elem": [{"opVar": "NA", "inpVar": ["\treturn &SRV6_STATE_MAP6", "\t\t\t       struct srv6_ipv6_2tuple *&ip6->saddr"]}]}}}], "srv6_handling4": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/egress_policies.h", "startLine": "270", "endLine": "310", "capability": {"capabilities": [], "helperCallParams": {}}}], "srv6_handling6": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/egress_policies.h", "startLine": "312", "endLine": "331", "capability": {"capabilities": [], "helperCallParams": {}}}], "srv6_handling": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/egress_policies.h", "startLine": "333", "endLine": "373", "capability": {"capabilities": [], "helperCallParams": {}}}], "srv6_reply": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/egress_policies.h", "startLine": "375", "endLine": "413", "capability": {"capabilities": [], "helperCallParams": {}}}], "srv6_load_meta_sid": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/egress_policies.h", "startLine": "415", "endLine": "422", "capability": {"capabilities": [], "helperCallParams": {}}}], "srv6_store_meta_sid": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/egress_policies.h", "startLine": "424", "endLine": "431", "capability": {"capabilities": [], "helperCallParams": {}}}], "tail_srv6_encap": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/egress_policies.h", "startLine": "434", "endLine": "452", "capability": {"capabilities": [], "helperCallParams": {}}}], "tail_srv6_decap": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/egress_policies.h", "startLine": "455", "endLine": "473", "capability": {"capabilities": [], "helperCallParams": {}}}], "tail_srv6_reply": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/egress_policies.h", "startLine": "476", "endLine": "485", "capability": {"capabilities": [], "helperCallParams": {}}}], "update_trace_metrics": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/trace.h", "startLine": "80", "endLine": "124", "capability": {"capabilities": [], "helperCallParams": {}}}], "emit_trace_notify": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/trace.h", "startLine": "154", "endLine": "182", "capability": {"capabilities": [], "helperCallParams": {}}}], "send_trace_notify": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/trace.h", "startLine": "184", "endLine": "213", "capability": {"capabilities": [], "helperCallParams": {}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/trace.h", "startLine": "281", "endLine": "288", "capability": {"capabilities": [], "helperCallParams": {}}}], "send_trace_notify4": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/trace.h", "startLine": "215", "endLine": "245", "capability": {"capabilities": [], "helperCallParams": {}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/trace.h", "startLine": "290", "endLine": "298", "capability": {"capabilities": [], "helperCallParams": {}}}], "send_trace_notify6": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/trace.h", "startLine": "247", "endLine": "279", "capability": {"capabilities": [], "helperCallParams": {}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/trace.h", "startLine": "300", "endLine": "308", "capability": {"capabilities": [], "helperCallParams": {}}}], "bpf_clear_meta": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_skb.h", "startLine": "7", "endLine": "17", "capability": {"capabilities": [], "helperCallParams": {}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_xdp.h", "startLine": "7", "endLine": "10", "capability": {"capabilities": [], "helperCallParams": {}}}], "get_identity": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_skb.h", "startLine": "22", "endLine": "26", "capability": {"capabilities": [], "helperCallParams": {}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_xdp.h", "startLine": "12", "endLine": "16", "capability": {"capabilities": [], "helperCallParams": {}}}], "get_epid": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_skb.h", "startLine": "31", "endLine": "35", "capability": {"capabilities": [], "helperCallParams": {}}}], "set_encrypt_dip": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_skb.h", "startLine": "37", "endLine": "41", "capability": {"capabilities": [], "helperCallParams": {}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_xdp.h", "startLine": "18", "endLine": "22", "capability": {"capabilities": [], "helperCallParams": {}}}], "set_identity_mark": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_skb.h", "startLine": "46", "endLine": "51", "capability": {"capabilities": [], "helperCallParams": {}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_xdp.h", "startLine": "24", "endLine": "27", "capability": {"capabilities": [], "helperCallParams": {}}}], "set_identity_meta": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_skb.h", "startLine": "53", "endLine": "57", "capability": {"capabilities": [], "helperCallParams": {}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_xdp.h", "startLine": "29", "endLine": "33", "capability": {"capabilities": [], "helperCallParams": {}}}], "set_encrypt_key_mark": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_skb.h", "startLine": "62", "endLine": "66", "capability": {"capabilities": [], "helperCallParams": {}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_xdp.h", "startLine": "35", "endLine": "38", "capability": {"capabilities": [], "helperCallParams": {}}}], "set_encrypt_key_meta": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_skb.h", "startLine": "68", "endLine": "72", "capability": {"capabilities": [], "helperCallParams": {}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_xdp.h", "startLine": "40", "endLine": "43", "capability": {"capabilities": [], "helperCallParams": {}}}], "set_encrypt_mark": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_skb.h", "startLine": "79", "endLine": "83", "capability": {"capabilities": [], "helperCallParams": {}}}], "redirect_self": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_skb.h", "startLine": "85", "endLine": "99", "capability": {"capabilities": [], "helperCallParams": {"redirect": [{"opVar": "NA", "inpVar": ["_selfconst struct __sk_buff *ctx"]}, {"opVar": "NA", "inpVar": ["\t#ifdef ENABLE_HOST_REDIRECT\treturn ctx_ctx", " ctx->ifindex", " 0"]}, {"opVar": "NA", "inpVar": ["#else\treturn ctx_ctx", " ctx->ifindex", " BPF_F_INGRESS"]}]}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_xdp.h", "startLine": "45", "endLine": "53", "capability": {"capabilities": [], "helperCallParams": {"redirect": [{"opVar": "NA", "inpVar": ["_selfstruct xdp_md *ctx __maybe_unused"]}]}}}], "ctx_skip_nodeport_clear": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_skb.h", "startLine": "101", "endLine": "107", "capability": {"capabilities": [], "helperCallParams": {}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_xdp.h", "startLine": "58", "endLine": "64", "capability": {"capabilities": [], "helperCallParams": {}}}], "ctx_skip_nodeport_set": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_skb.h", "startLine": "109", "endLine": "115", "capability": {"capabilities": [], "helperCallParams": {}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_xdp.h", "startLine": "66", "endLine": "72", "capability": {"capabilities": [], "helperCallParams": {}}}], "ctx_skip_nodeport": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_skb.h", "startLine": "117", "endLine": "127", "capability": {"capabilities": [], "helperCallParams": {}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_xdp.h", "startLine": "74", "endLine": "82", "capability": {"capabilities": [], "helperCallParams": {}}}], "ctx_skip_host_fw_set": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_skb.h", "startLine": "130", "endLine": "134", "capability": {"capabilities": [], "helperCallParams": {}}}], "ctx_skip_host_fw": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_skb.h", "startLine": "136", "endLine": "143", "capability": {"capabilities": [], "helperCallParams": {}}}], "ctx_get_xfer": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_skb.h", "startLine": "146", "endLine": "152", "capability": {"capabilities": [], "helperCallParams": {}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_xdp.h", "startLine": "84", "endLine": "88", "capability": {"capabilities": [], "helperCallParams": {}}}], "ctx_set_xfer": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_skb.h", "startLine": "154", "endLine": "158", "capability": {"capabilities": [], "helperCallParams": {}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_xdp.h", "startLine": "90", "endLine": "94", "capability": {"capabilities": [], "helperCallParams": {}}}], "ctx_change_head": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_skb.h", "startLine": "160", "endLine": "164", "capability": {"capabilities": [{"capability": "update_pkt", "update_pkt": [{"Project": "cilium", "Return Type": "int", "Description": "Grows headroom of packet associated to <[ skb ]>(IP: 0) and adjusts the offset of the MAC header accordingly , adding <[ len ]>(IP: 1) bytes of space. It automatically extends and reallocates memory as required. This helper can be used on a layer 3 <[ skb ]>(IP: 0) to push a MAC header for redirection into a layer 2 device. All values for <[ flags ]>(IP: 2) are reserved for future usage , and must be left at zero. A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "skb_change_head", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  u32 ,Var: len}", "{Type:  u64 ,Var: flags}"]}]}], "helperCallParams": {"skb_change_head": [{"opVar": "NA", "inpVar": ["\treturn ctx", " head_room", " flags"]}]}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/overloadable_xdp.h", "startLine": "96", "endLine": "102", "capability": {"capabilities": [], "helperCallParams": {}}}], "ipv6_host_policy_egress": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/host_firewall.h", "startLine": "17", "endLine": "100", "capability": {"capabilities": [], "helperCallParams": {}}}], "ipv6_host_policy_ingress": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/host_firewall.h", "startLine": "102", "endLine": "199", "capability": {"capabilities": [], "helperCallParams": {}}}], "whitelist_snated_egress_connections": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/host_firewall.h", "startLine": "204", "endLine": "249", "capability": {"capabilities": [], "helperCallParams": {}}}], "ipv4_host_policy_egress": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/host_firewall.h", "startLine": "252", "endLine": "337", "capability": {"capabilities": [], "helperCallParams": {}}}], "ipv4_host_policy_ingress": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/host_firewall.h", "startLine": "339", "endLine": "439", "capability": {"capabilities": [], "helperCallParams": {}}}], "ipv6_l3": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/l3.h", "startLine": "18", "endLine": "38", "capability": {"capabilities": [], "helperCallParams": {}}}], "ipv4_l3": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/l3.h", "startLine": "41", "endLine": "56", "capability": {"capabilities": [], "helperCallParams": {}}}], "ipv6_local_delivery": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/l3.h", "startLine": "65", "endLine": "106", "capability": {"capabilities": [], "helperCallParams": {"redirect": [{"opVar": "NA", "inpVar": ["\treturn _epctx", " ep->ifindex", " from_host"]}], "tail_call": [{"opVar": "NA", "inpVar": ["\t_dynamicctx", " &POLICY_CALL_MAP", " ep->lxc_id"]}]}}}], "ipv4_local_delivery": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/l3.h", "startLine": "114", "endLine": "154", "capability": {"capabilities": [], "helperCallParams": {"redirect": [{"opVar": "NA", "inpVar": ["\treturn _epctx", " ep->ifindex", " from_host"]}], "tail_call": [{"opVar": "NA", "inpVar": ["\t_dynamicctx", " &POLICY_CALL_MAP", " ep->lxc_id"]}]}}}], "get_min_encrypt_key": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/l3.h", "startLine": "157", "endLine": "185", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"map_lookup_elem": [{"opVar": "\tcfg ", "inpVar": [" &ENCRYPT_MAP", " &encrypt_key"]}]}}}], "send_signal": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/signal.h", "startLine": "36", "endLine": "41", "capability": {"capabilities": [], "helperCallParams": {}}}], "send_signal_nat_fill_up": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/signal.h", "startLine": "43", "endLine": "52", "capability": {"capabilities": [], "helperCallParams": {"send_signal": [{"opVar": "NA", "inpVar": ["\tctx", " &msg"]}]}}}], "send_signal_ct_fill_up": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/signal.h", "startLine": "54", "endLine": "63", "capability": {"capabilities": [], "helperCallParams": {"send_signal": [{"opVar": "NA", "inpVar": ["\tctx", " &msg"]}]}}}], "ct_entry_seen_both_syns": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h", "startLine": "26", "endLine": "32", "capability": {"capabilities": [], "helperCallParams": {}}}], "__ct_update_timeout": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h", "startLine": "62", "endLine": "126", "capability": {"capabilities": [], "helperCallParams": {}}}], "ct_update_timeout": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h", "startLine": "134", "endLine": "156", "capability": {"capabilities": [], "helperCallParams": {}}}], "ct_reset_closing": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h", "startLine": "158", "endLine": "162", "capability": {"capabilities": [], "helperCallParams": {}}}], "ct_entry_alive": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h", "startLine": "164", "endLine": "167", "capability": {"capabilities": [], "helperCallParams": {}}}], "ct_entry_closing": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h", "startLine": "169", "endLine": "172", "capability": {"capabilities": [], "helperCallParams": {}}}], "ct_entry_expired_rebalance": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h", "startLine": "174", "endLine": "183", "capability": {"capabilities": [], "helperCallParams": {}}}], "__ct_lookup": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h", "startLine": "185", "endLine": "273", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"map_lookup_elem": [{"opVar": "\tentry ", "inpVar": [" map", " tuple"]}], "redirect": [{"opVar": "\t\t\tct_state->proxy_redirect ", "inpVar": [" entry->proxy_"]}]}}}], "ipv6_extract_tuple": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h", "startLine": "275", "endLine": "303", "capability": {"capabilities": [], "helperCallParams": {}}}], "ct_flip_tuple_dir6": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h", "startLine": "305", "endLine": "311", "capability": {"capabilities": [], "helperCallParams": {}}}], "__ipv6_ct_tuple_reverse": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h", "startLine": "313", "endLine": "326", "capability": {"capabilities": [], "helperCallParams": {}}}], "ipv6_ct_tuple_reverse": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h", "startLine": "328", "endLine": "333", "capability": {"capabilities": [], "helperCallParams": {}}}], "ct_lookup6": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h", "startLine": "336", "endLine": "459", "capability": {"capabilities": [], "helperCallParams": {}}}], "ipv4_extract_tuple": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h", "startLine": "461", "endLine": "483", "capability": {"capabilities": [], "helperCallParams": {}}}], "ct_flip_tuple_dir4": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h", "startLine": "485", "endLine": "491", "capability": {"capabilities": [], "helperCallParams": {}}}], "__ipv4_ct_tuple_reverse": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h", "startLine": "493", "endLine": "505", "capability": {"capabilities": [], "helperCallParams": {}}}], "ipv4_ct_tuple_reverse": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h", "startLine": "507", "endLine": "512", "capability": {"capabilities": [], "helperCallParams": {}}}], "ipv4_ct_extract_l4_ports": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h", "startLine": "514", "endLine": "540", "capability": {"capabilities": [], "helperCallParams": {}}}], "ct4_cilium_dbg_tuple": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h", "startLine": "542", "endLine": "549", "capability": {"capabilities": [], "helperCallParams": {}}}], "ct_extract_ports4": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h", "startLine": "551", "endLine": "606", "capability": {"capabilities": [], "helperCallParams": {}}}], "ct_is_reply4": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h", "startLine": "616", "endLine": "631", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"map_lookup_elem": [{"opVar": "\t*is_reply ", "inpVar": [" map", " tuple !"]}]}}}], "ct_lookup4": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h", "startLine": "634", "endLine": "757", "capability": {"capabilities": [], "helperCallParams": {}}}], "ct_update6_backend_id": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h", "startLine": "759", "endLine": "770", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"map_lookup_elem": [{"opVar": "\tentry ", "inpVar": [" map", " tuple"]}]}}}], "ct_update6_rev_nat_index": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h", "startLine": "772", "endLine": "783", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"map_lookup_elem": [{"opVar": "\tentry ", "inpVar": [" map", " tuple"]}]}}}], "ct_update6_dsr": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h", "startLine": "785", "endLine": "796", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"map_lookup_elem": [{"opVar": "\tentry ", "inpVar": [" map", " tuple"]}]}}}], "ct_create6": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h", "startLine": "799", "endLine": "865", "capability": {"capabilities": [{"capability": "map_update", "map_update": [{"Project": "cilium", "Return Type": "int", "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "map_update_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}", "{Type:  const void ,Var: *value}", "{Type:  u64 ,Var: flags}"]}]}], "helperCallParams": {"redirect": [{"opVar": "NA", "inpVar": ["\t\t\t\t      struct ipv6_ct_tuple *tuple", "\t\t\t\t      struct __ctx_buff *ctx", " const int dir", "\t\t\t\t      const struct ct_state *ct_state", "\t\t\t\t      bool proxy_", " bool from_l7lb"]}, {"opVar": "\t\tentry.proxy_redirect ", "inpVar": [" proxy_"]}], "map_update_elem": [{"opVar": "NA", "inpVar": ["\tif map_main", " tuple", " &entry", " 0 < 0 "]}, {"opVar": "NA", "inpVar": ["\t\tif map_related", " &icmp_tuple", " &entry", " 0 < 0 "]}], "send_signal": [{"opVar": "NA", "inpVar": ["\t\t_ct_fill_upctx", " SIGNAL_PROTO_V6"]}, {"opVar": "NA", "inpVar": ["\t\t\t_ct_fill_upctx", " SIGNAL_PROTO_V6"]}]}}}], "ct_update4_backend_id": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h", "startLine": "867", "endLine": "878", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"map_lookup_elem": [{"opVar": "\tentry ", "inpVar": [" map", " tuple"]}]}}}], "ct_update4_rev_nat_index": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h", "startLine": "880", "endLine": "891", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"map_lookup_elem": [{"opVar": "\tentry ", "inpVar": [" map", " tuple"]}]}}}], "ct_update4_dsr": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h", "startLine": "893", "endLine": "904", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"map_lookup_elem": [{"opVar": "\tentry ", "inpVar": [" map", " tuple"]}]}}}], "ct_create4": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h", "startLine": "906", "endLine": "1006", "capability": {"capabilities": [{"capability": "map_update", "map_update": [{"Project": "cilium", "Return Type": "int", "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "map_update_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}", "{Type:  const void ,Var: *value}", "{Type:  u64 ,Var: flags}"]}]}], "helperCallParams": {"redirect": [{"opVar": "NA", "inpVar": ["\t\t\t\t      const void *map_related", "\t\t\t\t      struct ipv4_ct_tuple *tuple", "\t\t\t\t      struct __ctx_buff *ctx", " const int dir", "\t\t\t\t      const struct ct_state *ct_state", "\t\t\t\t      bool proxy_", " bool from_l7lb"]}, {"opVar": "\t\tentry.proxy_redirect ", "inpVar": [" proxy_"]}], "map_update_elem": [{"opVar": "NA", "inpVar": ["\tif map_main", " tuple", " &entry", " 0 < 0 "]}, {"opVar": "NA", "inpVar": ["\t\t\t\tif map_main", " tuple", " &entry", " 0 < 0 "]}, {"opVar": "NA", "inpVar": [" \t\t\t\tif map_related", " &icmp_tuple", " &entry", " 0 < 0 "]}], "send_signal": [{"opVar": "NA", "inpVar": ["\t\t_ct_fill_upctx", " SIGNAL_PROTO_V4"]}, {"opVar": "NA", "inpVar": ["\t\t\t_ct_fill_upctx", " SIGNAL_PROTO_V4"]}, {"opVar": "NA", "inpVar": ["\t\t\t_ct_fill_upctx", " SIGNAL_PROTO_V4"]}]}}}], "ct_has_nodeport_egress_entry4": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h", "startLine": "1017", "endLine": "1032", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"map_lookup_elem": [{"opVar": "\tentry ", "inpVar": [" map", " ingress_tuple"]}]}}}], "ct_has_nodeport_egress_entry6": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h", "startLine": "1034", "endLine": "1049", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"map_lookup_elem": [{"opVar": "\tentry ", "inpVar": [" map", " ingress_tuple"]}]}}}], "ct_update_nodeport": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/conntrack.h", "startLine": "1051", "endLine": "1061", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"map_lookup_elem": [{"opVar": "\tentry ", "inpVar": [" map", " tuple"]}]}}}], "update_metrics": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/metrics.h", "startLine": "24", "endLine": "43", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}, {"capability": "map_update", "map_update": [{"Project": "cilium", "Return Type": "int", "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "map_update_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}", "{Type:  const void ,Var: *value}", "{Type:  u64 ,Var: flags}"]}]}], "helperCallParams": {"map_lookup_elem": [{"opVar": "\tentry ", "inpVar": [" &METRICS_MAP", " &key"]}], "map_update_elem": [{"opVar": "NA", "inpVar": ["\t\t&METRICS_MAP", " &key", " &new_entry", " 0"]}]}}}], "ct_to_metrics_dir": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/metrics.h", "startLine": "50", "endLine": "62", "capability": {"capabilities": [], "helperCallParams": {}}}], "rol32": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/jhash.h", "startLine": "14", "endLine": "17", "capability": {"capabilities": [], "helperCallParams": {}}}], "jhash": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/jhash.h", "startLine": "40", "endLine": "81", "capability": {"capabilities": [], "helperCallParams": {}}}], "__jhash_nwords": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/jhash.h", "startLine": "83", "endLine": "91", "capability": {"capabilities": [], "helperCallParams": {}}}], "jhash_3words": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/jhash.h", "startLine": "93", "endLine": "97", "capability": {"capabilities": [], "helperCallParams": {}}}], "jhash_2words": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/jhash.h", "startLine": "99", "endLine": "102", "capability": {"capabilities": [], "helperCallParams": {}}}], "jhash_1word": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/jhash.h", "startLine": "104", "endLine": "107", "capability": {"capabilities": [], "helperCallParams": {}}}], "ep_tail_call": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/maps.h", "startLine": "276", "endLine": "280", "capability": {"capabilities": [], "helperCallParams": {"tail_call": [{"opVar": "NA", "inpVar": ["\t_staticctx", " &CALLS_MAP", " index"]}]}}}], "*__lookup_ip6_endpoint": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/eps.h", "startLine": "12", "endLine": "21", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"map_lookup_elem": [{"opVar": "NA", "inpVar": ["\treturn &ENDPOINTS_MAP", " &key"]}]}}}], "*lookup_ip6_endpoint": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/eps.h", "startLine": "23", "endLine": "27", "capability": {"capabilities": [], "helperCallParams": {}}}], "*__lookup_ip4_endpoint": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/eps.h", "startLine": "29", "endLine": "38", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"map_lookup_elem": [{"opVar": "NA", "inpVar": ["\treturn &ENDPOINTS_MAP", " &key"]}]}}}], "*lookup_ip4_endpoint": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/eps.h", "startLine": "40", "endLine": "44", "capability": {"capabilities": [], "helperCallParams": {}}}], "*lookup_ip4_endpoint_policy_map": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/eps.h", "startLine": "47", "endLine": "56", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"map_lookup_elem": [{"opVar": "NA", "inpVar": ["\treturn &EP_POLICY_MAP", " &key"]}]}}}], "*ipcache_lookup6": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/eps.h", "startLine": "67", "endLine": "78", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"map_lookup_elem": [{"opVar": "NA", "inpVar": ["\treturn map", " &key"]}]}}}], "*ipcache_lookup4": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/eps.h", "startLine": "82", "endLine": "92", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"map_lookup_elem": [{"opVar": "NA", "inpVar": ["\treturn map", " &key"]}]}}}], "bpf_skip_nodeport_clear": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "startLine": "31", "endLine": "35", "capability": {"capabilities": [], "helperCallParams": {}}}], "bpf_skip_nodeport_set": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "startLine": "37", "endLine": "41", "capability": {"capabilities": [], "helperCallParams": {}}}], "bpf_skip_nodeport": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "startLine": "43", "endLine": "47", "capability": {"capabilities": [], "helperCallParams": {}}}], "nodeport_uses_dsr": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "startLine": "81", "endLine": "92", "capability": {"capabilities": [], "helperCallParams": {}}}], "bpf_mark_snat_done": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "startLine": "94", "endLine": "103", "capability": {"capabilities": [], "helperCallParams": {}}}], "bpf_skip_recirculation": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "startLine": "105", "endLine": "116", "capability": {"capabilities": [], "helperCallParams": {}}}], "ctx_adjust_hroom_dsr_flags": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "startLine": "118", "endLine": "125", "capability": {"capabilities": [], "helperCallParams": {}}}], "dsr_fail_needs_reply": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "startLine": "127", "endLine": "134", "capability": {"capabilities": [], "helperCallParams": {}}}], "dsr_is_too_big": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "startLine": "136", "endLine": "144", "capability": {"capabilities": [], "helperCallParams": {}}}], "maybe_add_l2_hdr": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "startLine": "146", "endLine": "170", "capability": {"capabilities": [], "helperCallParams": {}}}], "nodeport_uses_dsr6": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "startLine": "173", "endLine": "176", "capability": {"capabilities": [], "helperCallParams": {}}}], "snat_v6_needed": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "startLine": "181", "endLine": "203", "capability": {"capabilities": [], "helperCallParams": {}}}], "nodeport_nat_ipv6_fwd": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "startLine": "205", "endLine": "221", "capability": {"capabilities": [], "helperCallParams": {}}}], "rss_gen_src6": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "startLine": "225", "endLine": "252", "capability": {"capabilities": [], "helperCallParams": {}}}], "dsr_set_ipip6": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "startLine": "254", "endLine": "292", "capability": {"capabilities": [], "helperCallParams": {}}}], "dsr_set_ext6": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "startLine": "294", "endLine": "327", "capability": {"capabilities": [], "helperCallParams": {}}}], "find_dsr_v6": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "startLine": "330", "endLine": "378", "capability": {"capabilities": [], "helperCallParams": {}}}], "handle_dsr_v6": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "startLine": "380", "endLine": "400", "capability": {"capabilities": [], "helperCallParams": {}}}], "xlate_dsr_v6": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "startLine": "402", "endLine": "418", "capability": {"capabilities": [], "helperCallParams": {}}}], "dsr_reply_icmp6": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "startLine": "420", "endLine": "492", "capability": {"capabilities": [{"capability": "read_skb", "read_skb": [{"Project": "cilium", "Return Type": "s64", "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ", "Return": " The checksum result, or a negative error code in case of failure.", "Function Name": "csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"]}]}], "helperCallParams": {"csum_diff": [{"opVar": "\ticmp.icmp6_cksum ", "inpVar": [" csum_foldNULL", " 0", " data + off", " l3_max", "\t\t\t\t\t       NULL", " 0", " &icmp", "\t\t\t\t\t\t\t sizeoficmp", " wsum"]}], "redirect": [{"opVar": "NA", "inpVar": ["\treturn ctx_ctx", " ctx_get_ifindexctx", " 0"]}]}}}], "tail_nodeport_ipv6_dsr": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "startLine": "495", "endLine": "571", "capability": {"capabilities": [{"capability": "read_sys_info", "read_sys_info": [{"Project": "libbpf", "Return Type": "int", "Description": "Do FIB lookup in kernel tables using parameters in params. If lookup is successful and result shows packet is to be forwarded , the neighbor tables are searched for the nexthop. If successful (ie. , FIB lookup shows forwarding and nexthop is resolved) , the nexthop address is returned in ipv4_dst or ipv6_dst based on family , smac is set to mac address of egress device , dmac is set to nexthop mac address , rt_metric is set to metric from route (IPv4/IPv6 only) , and ifindex is set to the device index of the nexthop from the FIB lookup. <[ plen ]>(IP: 2) argument is the size of the passed in struct. <[ flags ]>(IP: 3) argument can be a combination of one or more of the following values: BPF_FIB_LOOKUP_DIRECT Do a direct table lookup vs full lookup using FIB rules. BPF_FIB_LOOKUP_OUTPUT Perform lookup from an egress perspective (default is ingress). <[ ctx ]>(IP: 0) is either struct xdp_md for XDP programs or struct sk_buff tc cls_act programs. Return \u00b7 < 0 if any input argument is invalid \u00b7 0 on success (packet is forwarded , nexthop neighbor exists) \u00b7 > 0 one of BPF_FIB_LKUP_RET_ codes explaining why the packet is not forwarded or needs assist from full stack ", "Function Name": "bpf_fib_lookup", "Input Params": ["{Type: void ,Var: *ctx}", "{Type:  struct bpf_fib_lookup ,Var: *params}", "{Type:  int ,Var: plen}", "{Type:  u32 ,Var: flags}"]}, {"Project": "cilium", "Return Type": "int", "Description": "Do FIB lookup in kernel tables using parameters in params. If lookup is successful and result shows packet is to be forwarded , the neighbor tables are searched for the nexthop. If successful (ie. , FIB lookup shows forwarding and nexthop is resolved) , the nexthop address is returned in ipv4_dst or ipv6_dst based on family , smac is set to mac address of egress device , dmac is set to nexthop mac address , rt_metric is set to metric from route (IPv4/IPv6 only) , and ifindex is set to the device index of the nexthop from the FIB lookup. <[ plen ]>(IP: 2) argument is the size of the passed in struct. <[ flags ]>(IP: 3) argument can be a combination of one or more of the following values: BPF_FIB_LOOKUP_DIRECT Do a direct table lookup vs full lookup using FIB rules. BPF_FIB_LOOKUP_OUTPUT Perform lookup from an egress perspective (default is ingress). <[ ctx ]>(IP: 0) is either struct xdp_md for XDP programs or struct sk_buff tc cls_act programs. Return \u00b7 < 0 if any input argument is invalid \u00b7 0 on success (packet is forwarded , nexthop neighbor exists) \u00b7 > 0 one of BPF_FIB_LKUP_RET_ codes explaining why the packet is not forwarded or needs assist from full stack ", "Function Name": "fib_lookup", "Input Params": ["{Type: void ,Var: *ctx}", "{Type:  struct fib_lookup ,Var: *params}", "{Type:  int ,Var: plen}", "{Type:  u32 ,Var: flags}"]}]}], "helperCallParams": {"bpf_fib_lookup": [{"opVar": "\tstruct bpf_fib_lookup_padded fib_params ", "inpVar": [" "]}], "fib_lookup": [{"opVar": "\tret ", "inpVar": [" ctx", " &fib_params.l", " sizeoffib_params", " 0"]}], "redirect": [{"opVar": "NA", "inpVar": ["\treturn ctx_ctx", " fib_params.l.ifindex", " 0"]}]}}}], "tail_nodeport_nat_ipv6": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "startLine": "575", "endLine": "715", "capability": {"capabilities": [{"capability": "read_sys_info", "read_sys_info": [{"Project": "libbpf", "Return Type": "int", "Description": "Do FIB lookup in kernel tables using parameters in params. If lookup is successful and result shows packet is to be forwarded , the neighbor tables are searched for the nexthop. If successful (ie. , FIB lookup shows forwarding and nexthop is resolved) , the nexthop address is returned in ipv4_dst or ipv6_dst based on family , smac is set to mac address of egress device , dmac is set to nexthop mac address , rt_metric is set to metric from route (IPv4/IPv6 only) , and ifindex is set to the device index of the nexthop from the FIB lookup. <[ plen ]>(IP: 2) argument is the size of the passed in struct. <[ flags ]>(IP: 3) argument can be a combination of one or more of the following values: BPF_FIB_LOOKUP_DIRECT Do a direct table lookup vs full lookup using FIB rules. BPF_FIB_LOOKUP_OUTPUT Perform lookup from an egress perspective (default is ingress). <[ ctx ]>(IP: 0) is either struct xdp_md for XDP programs or struct sk_buff tc cls_act programs. Return \u00b7 < 0 if any input argument is invalid \u00b7 0 on success (packet is forwarded , nexthop neighbor exists) \u00b7 > 0 one of BPF_FIB_LKUP_RET_ codes explaining why the packet is not forwarded or needs assist from full stack ", "Function Name": "bpf_fib_lookup", "Input Params": ["{Type: void ,Var: *ctx}", "{Type:  struct bpf_fib_lookup ,Var: *params}", "{Type:  int ,Var: plen}", "{Type:  u32 ,Var: flags}"]}, {"Project": "cilium", "Return Type": "int", "Description": "Do FIB lookup in kernel tables using parameters in params. If lookup is successful and result shows packet is to be forwarded , the neighbor tables are searched for the nexthop. If successful (ie. , FIB lookup shows forwarding and nexthop is resolved) , the nexthop address is returned in ipv4_dst or ipv6_dst based on family , smac is set to mac address of egress device , dmac is set to nexthop mac address , rt_metric is set to metric from route (IPv4/IPv6 only) , and ifindex is set to the device index of the nexthop from the FIB lookup. <[ plen ]>(IP: 2) argument is the size of the passed in struct. <[ flags ]>(IP: 3) argument can be a combination of one or more of the following values: BPF_FIB_LOOKUP_DIRECT Do a direct table lookup vs full lookup using FIB rules. BPF_FIB_LOOKUP_OUTPUT Perform lookup from an egress perspective (default is ingress). <[ ctx ]>(IP: 0) is either struct xdp_md for XDP programs or struct sk_buff tc cls_act programs. Return \u00b7 < 0 if any input argument is invalid \u00b7 0 on success (packet is forwarded , nexthop neighbor exists) \u00b7 > 0 one of BPF_FIB_LKUP_RET_ codes explaining why the packet is not forwarded or needs assist from full stack ", "Function Name": "fib_lookup", "Input Params": ["{Type: void ,Var: *ctx}", "{Type:  struct fib_lookup ,Var: *params}", "{Type:  int ,Var: plen}", "{Type:  u32 ,Var: flags}"]}]}], "helperCallParams": {"bpf_fib_lookup": [{"opVar": "\tstruct bpf_fib_lookup_padded fib_params ", "inpVar": [" "]}], "tail_call": [{"opVar": "NA", "inpVar": ["\t\t\tep_ctx", " CILIUM_CALL_IPV6_FROM_NETDEV"]}, {"opVar": "NA", "inpVar": ["\t\tep_ctx", " CILIUM_CALL_IPV6_NODEPORT_REVNAT"]}], "fib_lookup": [{"opVar": "\t\tret ", "inpVar": [" ctx", " &fib_params.l", " sizeoffib_params", " 0"]}], "redirect": [{"opVar": "NA", "inpVar": ["\treturn ctx_ctx", " fib_params.l.ifindex", " 0"]}]}}}], "nodeport_lb6": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "startLine": "718", "endLine": "881", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}, {"capability": "map_update", "map_update": [{"Project": "cilium", "Return Type": "int", "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "map_update_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}", "{Type:  const void ,Var: *value}", "{Type:  u64 ,Var: flags}"]}]}], "helperCallParams": {"redirect": [{"opVar": "NA", "inpVar": ["\t\t\treturn ctx__to_proxy_hairpin_ipv6ctx", "\t\t\t\t\t\t\t\t  __be16svc->l7_lb_proxy_port"]}], "tail_call": [{"opVar": "NA", "inpVar": ["\t\tep_ctx", " CILIUM_CALL_IPV6_NODEPORT_NAT"]}, {"opVar": "NA", "inpVar": ["#endif \t\t\tep_ctx", " CILIUM_CALL_IPV6_NODEPORT_DSR"]}, {"opVar": "NA", "inpVar": ["\t\t\tep_ctx", " CILIUM_CALL_IPV6_NODEPORT_NAT"]}], "map_lookup_elem": [{"opVar": "\t\tmac ", "inpVar": [" &NODEPORT_NEIGH6", " &ip6->saddr"]}], "map_update_elem": [{"opVar": "\t\t\tret ", "inpVar": [" &NODEPORT_NEIGH6", " &ip6->saddr", "\t\t\t\t\t      &smac", " 0"]}]}}}], "rev_nodeport_lb6": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "startLine": "884", "endLine": "1006", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}, {"capability": "read_sys_info", "read_sys_info": [{"Project": "libbpf", "Return Type": "int", "Description": "Do FIB lookup in kernel tables using parameters in params. If lookup is successful and result shows packet is to be forwarded , the neighbor tables are searched for the nexthop. If successful (ie. , FIB lookup shows forwarding and nexthop is resolved) , the nexthop address is returned in ipv4_dst or ipv6_dst based on family , smac is set to mac address of egress device , dmac is set to nexthop mac address , rt_metric is set to metric from route (IPv4/IPv6 only) , and ifindex is set to the device index of the nexthop from the FIB lookup. <[ plen ]>(IP: 2) argument is the size of the passed in struct. <[ flags ]>(IP: 3) argument can be a combination of one or more of the following values: BPF_FIB_LOOKUP_DIRECT Do a direct table lookup vs full lookup using FIB rules. BPF_FIB_LOOKUP_OUTPUT Perform lookup from an egress perspective (default is ingress). <[ ctx ]>(IP: 0) is either struct xdp_md for XDP programs or struct sk_buff tc cls_act programs. Return \u00b7 < 0 if any input argument is invalid \u00b7 0 on success (packet is forwarded , nexthop neighbor exists) \u00b7 > 0 one of BPF_FIB_LKUP_RET_ codes explaining why the packet is not forwarded or needs assist from full stack ", "Function Name": "bpf_fib_lookup", "Input Params": ["{Type: void ,Var: *ctx}", "{Type:  struct bpf_fib_lookup ,Var: *params}", "{Type:  int ,Var: plen}", "{Type:  u32 ,Var: flags}"]}, {"Project": "cilium", "Return Type": "int", "Description": "Do FIB lookup in kernel tables using parameters in params. If lookup is successful and result shows packet is to be forwarded , the neighbor tables are searched for the nexthop. If successful (ie. , FIB lookup shows forwarding and nexthop is resolved) , the nexthop address is returned in ipv4_dst or ipv6_dst based on family , smac is set to mac address of egress device , dmac is set to nexthop mac address , rt_metric is set to metric from route (IPv4/IPv6 only) , and ifindex is set to the device index of the nexthop from the FIB lookup. <[ plen ]>(IP: 2) argument is the size of the passed in struct. <[ flags ]>(IP: 3) argument can be a combination of one or more of the following values: BPF_FIB_LOOKUP_DIRECT Do a direct table lookup vs full lookup using FIB rules. BPF_FIB_LOOKUP_OUTPUT Perform lookup from an egress perspective (default is ingress). <[ ctx ]>(IP: 0) is either struct xdp_md for XDP programs or struct sk_buff tc cls_act programs. Return \u00b7 < 0 if any input argument is invalid \u00b7 0 on success (packet is forwarded , nexthop neighbor exists) \u00b7 > 0 one of BPF_FIB_LKUP_RET_ codes explaining why the packet is not forwarded or needs assist from full stack ", "Function Name": "fib_lookup", "Input Params": ["{Type: void ,Var: *ctx}", "{Type:  struct fib_lookup ,Var: *params}", "{Type:  int ,Var: plen}", "{Type:  u32 ,Var: flags}"]}]}], "helperCallParams": {"bpf_fib_lookup": [{"opVar": "\tstruct bpf_fib_lookup fib_params ", "inpVar": [" "]}], "fib_lookup": [{"opVar": "\t\tfib_ret ", "inpVar": [" ctx", " &fib_params", " sizeoffib_params", " 0"]}], "map_lookup_elem": [{"opVar": "\t\t\t\t\t\t\t\t\tdmac ", "inpVar": [" &NODEPORT_NEIGH6", " &tuple.daddr"]}], "tail_call": [{"opVar": "NA", "inpVar": ["\t\t\tep_ctx", " CILIUM_CALL_IPV6_FROM_NETDEV"]}]}}}], "tail_rev_nodeport_lb6": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "startLine": "1009", "endLine": "1052", "capability": {"capabilities": [], "helperCallParams": {"redirect": [{"opVar": "NA", "inpVar": ["\treturn ctx_ctx", " ifindex", " 0"]}]}}}], "tail_handle_nat_fwd_ipv6": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "startLine": "1059", "endLine": "1078", "capability": {"capabilities": [], "helperCallParams": {}}}], "nodeport_uses_dsr4": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "startLine": "1082", "endLine": "1085", "capability": {"capabilities": [], "helperCallParams": {}}}], "snat_v4_needed": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "startLine": "1101", "endLine": "1259", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"map_lookup_elem": [{"opVar": "NA", "inpVar": ["\t\tif &IP_MASQ_AGENT_IPV4", " &pfx\t\t\treturn false"]}]}}}], "nodeport_nat_ipv4_fwd": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "startLine": "1261", "endLine": "1278", "capability": {"capabilities": [], "helperCallParams": {}}}], "rss_gen_src4": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "startLine": "1282", "endLine": "1290", "capability": {"capabilities": [], "helperCallParams": {}}}], "dsr_set_ipip4": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "startLine": "1298", "endLine": "1350", "capability": {"capabilities": [{"capability": "read_skb", "read_skb": [{"Project": "cilium", "Return Type": "s64", "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ", "Return": " The checksum result, or a negative error code in case of failure.", "Function Name": "csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"]}]}, {"capability": "update_pkt", "update_pkt": [{"Project": "cilium", "Return Type": "int", "Description": "Recompute the layer 3 (e. g. IP) checksum for the packet associated <[ to ]>(IP: 3) skb. Computation is incremental , so the helper must know the former value of the header field that was modified (from) , the new value of this field (to) , and the number of bytes (2 or 4) for this field , stored in size. Alternatively , it is possible <[ to ]>(IP: 3) store the difference between the previous and the new values of the header field in <[ to ]>(IP: 3) , by setting <[ from ]>(IP: 2) and <[ size ]>(IP: 4) <[ to ]>(IP: 3) 0. For both methods , <[ offset ]>(IP: 1) indicates the location of the IP checksum within the packet. This helper works in combination with csum_diff() , which does not update the checksum in-place , but offers more flexibility and can handle sizes larger than 2 or 4 for the checksum <[ to ]>(IP: 3) update. A call <[ to ]>(IP: 3) this helper is susceptible <[ to ]>(IP: 3) change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "l3_csum_replace", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  u32 ,Var: offset}", "{Type:  u64 ,Var: from}", "{Type:  u64 ,Var: to}", "{Type:  u64 ,Var: size}"]}]}], "helperCallParams": {"csum_diff": [{"opVar": "\tsum ", "inpVar": [" &tp_old", " 16", " &tp_new", " 16", " 0"]}], "l3_csum_replace": [{"opVar": "NA", "inpVar": ["\tif ctx", " l3_off + offsetofstruct iphdr", " check", "\t\t\t    0", " sum", " 0 < 0\t\treturn DROP_CSUM_L3"]}]}}}], "dsr_set_opt4": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "startLine": "1352", "endLine": "1404", "capability": {"capabilities": [{"capability": "read_skb", "read_skb": [{"Project": "cilium", "Return Type": "s64", "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ", "Return": " The checksum result, or a negative error code in case of failure.", "Function Name": "csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"]}]}, {"capability": "update_pkt", "update_pkt": [{"Project": "cilium", "Return Type": "int", "Description": "Recompute the layer 3 (e. g. IP) checksum for the packet associated <[ to ]>(IP: 3) skb. Computation is incremental , so the helper must know the former value of the header field that was modified (from) , the new value of this field (to) , and the number of bytes (2 or 4) for this field , stored in size. Alternatively , it is possible <[ to ]>(IP: 3) store the difference between the previous and the new values of the header field in <[ to ]>(IP: 3) , by setting <[ from ]>(IP: 2) and <[ size ]>(IP: 4) <[ to ]>(IP: 3) 0. For both methods , <[ offset ]>(IP: 1) indicates the location of the IP checksum within the packet. This helper works in combination with csum_diff() , which does not update the checksum in-place , but offers more flexibility and can handle sizes larger than 2 or 4 for the checksum <[ to ]>(IP: 3) update. A call <[ to ]>(IP: 3) this helper is susceptible <[ to ]>(IP: 3) change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "l3_csum_replace", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  u32 ,Var: offset}", "{Type:  u64 ,Var: from}", "{Type:  u64 ,Var: to}", "{Type:  u64 ,Var: size}"]}]}], "helperCallParams": {"csum_diff": [{"opVar": "\tsum ", "inpVar": [" &iph_old", " 4", " &iph_new", " 4", " 0"]}, {"opVar": "\tsum ", "inpVar": [" NULL", " 0", " &opt", " sizeofopt", " sum"]}], "l3_csum_replace": [{"opVar": "NA", "inpVar": ["\tif ctx", " ETH_HLEN + offsetofstruct iphdr", " check", "\t\t\t    0", " sum", " 0 < 0\t\treturn DROP_CSUM_L3"]}]}}}], "handle_dsr_v4": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "startLine": "1407", "endLine": "1446", "capability": {"capabilities": [], "helperCallParams": {}}}], "xlate_dsr_v4": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "startLine": "1448", "endLine": "1464", "capability": {"capabilities": [], "helperCallParams": {}}}], "dsr_reply_icmp4": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "startLine": "1466", "endLine": "1549", "capability": {"capabilities": [{"capability": "read_skb", "read_skb": [{"Project": "cilium", "Return Type": "s64", "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ", "Return": " The checksum result, or a negative error code in case of failure.", "Function Name": "csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"]}]}], "helperCallParams": {"csum_diff": [{"opVar": "\tip.check ", "inpVar": [" csum_foldNULL", " 0", " &ip", " sizeofip", " 0"]}, {"opVar": "\ticmp.checksum ", "inpVar": [" csum_foldNULL", " 0", " tmp", " sizeoftmp", "\t\t\t\t\t    NULL", " 0", " &icmp", "\t\t\t\t\t\t      sizeoficmp", " 0"]}], "redirect": [{"opVar": "NA", "inpVar": ["\treturn ctx_ctx", " ctx_get_ifindexctx", " 0"]}]}}}], "tail_nodeport_ipv4_dsr": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "startLine": "1552", "endLine": "1621", "capability": {"capabilities": [{"capability": "read_sys_info", "read_sys_info": [{"Project": "libbpf", "Return Type": "int", "Description": "Do FIB lookup in kernel tables using parameters in params. If lookup is successful and result shows packet is to be forwarded , the neighbor tables are searched for the nexthop. If successful (ie. , FIB lookup shows forwarding and nexthop is resolved) , the nexthop address is returned in ipv4_dst or ipv6_dst based on family , smac is set to mac address of egress device , dmac is set to nexthop mac address , rt_metric is set to metric from route (IPv4/IPv6 only) , and ifindex is set to the device index of the nexthop from the FIB lookup. <[ plen ]>(IP: 2) argument is the size of the passed in struct. <[ flags ]>(IP: 3) argument can be a combination of one or more of the following values: BPF_FIB_LOOKUP_DIRECT Do a direct table lookup vs full lookup using FIB rules. BPF_FIB_LOOKUP_OUTPUT Perform lookup from an egress perspective (default is ingress). <[ ctx ]>(IP: 0) is either struct xdp_md for XDP programs or struct sk_buff tc cls_act programs. Return \u00b7 < 0 if any input argument is invalid \u00b7 0 on success (packet is forwarded , nexthop neighbor exists) \u00b7 > 0 one of BPF_FIB_LKUP_RET_ codes explaining why the packet is not forwarded or needs assist from full stack ", "Function Name": "bpf_fib_lookup", "Input Params": ["{Type: void ,Var: *ctx}", "{Type:  struct bpf_fib_lookup ,Var: *params}", "{Type:  int ,Var: plen}", "{Type:  u32 ,Var: flags}"]}, {"Project": "cilium", "Return Type": "int", "Description": "Do FIB lookup in kernel tables using parameters in params. If lookup is successful and result shows packet is to be forwarded , the neighbor tables are searched for the nexthop. If successful (ie. , FIB lookup shows forwarding and nexthop is resolved) , the nexthop address is returned in ipv4_dst or ipv6_dst based on family , smac is set to mac address of egress device , dmac is set to nexthop mac address , rt_metric is set to metric from route (IPv4/IPv6 only) , and ifindex is set to the device index of the nexthop from the FIB lookup. <[ plen ]>(IP: 2) argument is the size of the passed in struct. <[ flags ]>(IP: 3) argument can be a combination of one or more of the following values: BPF_FIB_LOOKUP_DIRECT Do a direct table lookup vs full lookup using FIB rules. BPF_FIB_LOOKUP_OUTPUT Perform lookup from an egress perspective (default is ingress). <[ ctx ]>(IP: 0) is either struct xdp_md for XDP programs or struct sk_buff tc cls_act programs. Return \u00b7 < 0 if any input argument is invalid \u00b7 0 on success (packet is forwarded , nexthop neighbor exists) \u00b7 > 0 one of BPF_FIB_LKUP_RET_ codes explaining why the packet is not forwarded or needs assist from full stack ", "Function Name": "fib_lookup", "Input Params": ["{Type: void ,Var: *ctx}", "{Type:  struct fib_lookup ,Var: *params}", "{Type:  int ,Var: plen}", "{Type:  u32 ,Var: flags}"]}]}], "helperCallParams": {"bpf_fib_lookup": [{"opVar": "\tstruct bpf_fib_lookup_padded fib_params ", "inpVar": [" "]}], "fib_lookup": [{"opVar": "\tret ", "inpVar": [" ctx", " &fib_params.l", " sizeoffib_params", " 0"]}], "redirect": [{"opVar": "NA", "inpVar": ["\treturn ctx_ctx", " fib_params.l.ifindex", " 0"]}]}}}], "tail_nodeport_nat_ipv4": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "startLine": "1625", "endLine": "1767", "capability": {"capabilities": [{"capability": "read_sys_info", "read_sys_info": [{"Project": "libbpf", "Return Type": "int", "Description": "Do FIB lookup in kernel tables using parameters in params. If lookup is successful and result shows packet is to be forwarded , the neighbor tables are searched for the nexthop. If successful (ie. , FIB lookup shows forwarding and nexthop is resolved) , the nexthop address is returned in ipv4_dst or ipv6_dst based on family , smac is set to mac address of egress device , dmac is set to nexthop mac address , rt_metric is set to metric from route (IPv4/IPv6 only) , and ifindex is set to the device index of the nexthop from the FIB lookup. <[ plen ]>(IP: 2) argument is the size of the passed in struct. <[ flags ]>(IP: 3) argument can be a combination of one or more of the following values: BPF_FIB_LOOKUP_DIRECT Do a direct table lookup vs full lookup using FIB rules. BPF_FIB_LOOKUP_OUTPUT Perform lookup from an egress perspective (default is ingress). <[ ctx ]>(IP: 0) is either struct xdp_md for XDP programs or struct sk_buff tc cls_act programs. Return \u00b7 < 0 if any input argument is invalid \u00b7 0 on success (packet is forwarded , nexthop neighbor exists) \u00b7 > 0 one of BPF_FIB_LKUP_RET_ codes explaining why the packet is not forwarded or needs assist from full stack ", "Function Name": "bpf_fib_lookup", "Input Params": ["{Type: void ,Var: *ctx}", "{Type:  struct bpf_fib_lookup ,Var: *params}", "{Type:  int ,Var: plen}", "{Type:  u32 ,Var: flags}"]}, {"Project": "cilium", "Return Type": "int", "Description": "Do FIB lookup in kernel tables using parameters in params. If lookup is successful and result shows packet is to be forwarded , the neighbor tables are searched for the nexthop. If successful (ie. , FIB lookup shows forwarding and nexthop is resolved) , the nexthop address is returned in ipv4_dst or ipv6_dst based on family , smac is set to mac address of egress device , dmac is set to nexthop mac address , rt_metric is set to metric from route (IPv4/IPv6 only) , and ifindex is set to the device index of the nexthop from the FIB lookup. <[ plen ]>(IP: 2) argument is the size of the passed in struct. <[ flags ]>(IP: 3) argument can be a combination of one or more of the following values: BPF_FIB_LOOKUP_DIRECT Do a direct table lookup vs full lookup using FIB rules. BPF_FIB_LOOKUP_OUTPUT Perform lookup from an egress perspective (default is ingress). <[ ctx ]>(IP: 0) is either struct xdp_md for XDP programs or struct sk_buff tc cls_act programs. Return \u00b7 < 0 if any input argument is invalid \u00b7 0 on success (packet is forwarded , nexthop neighbor exists) \u00b7 > 0 one of BPF_FIB_LKUP_RET_ codes explaining why the packet is not forwarded or needs assist from full stack ", "Function Name": "fib_lookup", "Input Params": ["{Type: void ,Var: *ctx}", "{Type:  struct fib_lookup ,Var: *params}", "{Type:  int ,Var: plen}", "{Type:  u32 ,Var: flags}"]}]}], "helperCallParams": {"bpf_fib_lookup": [{"opVar": "\tstruct bpf_fib_lookup_padded fib_params ", "inpVar": [" "]}], "tail_call": [{"opVar": "NA", "inpVar": ["\t\t\tep_ctx", " CILIUM_CALL_IPV4_FROM_NETDEV"]}, {"opVar": "NA", "inpVar": ["\t\t\t\tep_ctx", " CILIUM_CALL_IPV4_NODEPORT_REVNAT"]}], "fib_lookup": [{"opVar": "\tret ", "inpVar": [" ctx", " &fib_params.l", " sizeoffib_params", " 0"]}], "redirect": [{"opVar": "NA", "inpVar": ["\treturn ctx_ctx", " fib_params.l.ifindex", " 0"]}]}}}], "nodeport_lb4": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "startLine": "1773", "endLine": "1943", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}, {"capability": "map_update", "map_update": [{"Project": "cilium", "Return Type": "int", "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "map_update_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}", "{Type:  const void ,Var: *value}", "{Type:  u64 ,Var: flags}"]}]}], "helperCallParams": {"redirect": [{"opVar": "NA", "inpVar": ["\t\t\treturn ctx__to_proxy_hairpin_ipv4ctx", "\t\t\t\t\t\t\t\t  __be16svc->l7_lb_proxy_port"]}], "tail_call": [{"opVar": "NA", "inpVar": ["\t\t\tep_ctx", " CILIUM_CALL_IPV6_NODEPORT_NAT"]}, {"opVar": "NA", "inpVar": ["\t\t\tep_ctx", " CILIUM_CALL_IPV4_NODEPORT_NAT"]}, {"opVar": "NA", "inpVar": ["#endif \t\t\tep_ctx", " CILIUM_CALL_IPV4_NODEPORT_DSR"]}, {"opVar": "NA", "inpVar": ["\t\t\tep_ctx", " CILIUM_CALL_IPV4_NODEPORT_NAT"]}], "map_lookup_elem": [{"opVar": "\t\tmac ", "inpVar": [" &NODEPORT_NEIGH4", " &ip4->saddr"]}], "map_update_elem": [{"opVar": "\t\t\tret ", "inpVar": [" &NODEPORT_NEIGH4", " &ip4->saddr", "\t\t\t\t\t      &smac", " 0"]}]}}}], "rev_nodeport_lb4": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "startLine": "1955", "endLine": "2126", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}, {"capability": "read_sys_info", "read_sys_info": [{"Project": "libbpf", "Return Type": "int", "Description": "Do FIB lookup in kernel tables using parameters in params. If lookup is successful and result shows packet is to be forwarded , the neighbor tables are searched for the nexthop. If successful (ie. , FIB lookup shows forwarding and nexthop is resolved) , the nexthop address is returned in ipv4_dst or ipv6_dst based on family , smac is set to mac address of egress device , dmac is set to nexthop mac address , rt_metric is set to metric from route (IPv4/IPv6 only) , and ifindex is set to the device index of the nexthop from the FIB lookup. <[ plen ]>(IP: 2) argument is the size of the passed in struct. <[ flags ]>(IP: 3) argument can be a combination of one or more of the following values: BPF_FIB_LOOKUP_DIRECT Do a direct table lookup vs full lookup using FIB rules. BPF_FIB_LOOKUP_OUTPUT Perform lookup from an egress perspective (default is ingress). <[ ctx ]>(IP: 0) is either struct xdp_md for XDP programs or struct sk_buff tc cls_act programs. Return \u00b7 < 0 if any input argument is invalid \u00b7 0 on success (packet is forwarded , nexthop neighbor exists) \u00b7 > 0 one of BPF_FIB_LKUP_RET_ codes explaining why the packet is not forwarded or needs assist from full stack ", "Function Name": "bpf_fib_lookup", "Input Params": ["{Type: void ,Var: *ctx}", "{Type:  struct bpf_fib_lookup ,Var: *params}", "{Type:  int ,Var: plen}", "{Type:  u32 ,Var: flags}"]}, {"Project": "cilium", "Return Type": "int", "Description": "Do FIB lookup in kernel tables using parameters in params. If lookup is successful and result shows packet is to be forwarded , the neighbor tables are searched for the nexthop. If successful (ie. , FIB lookup shows forwarding and nexthop is resolved) , the nexthop address is returned in ipv4_dst or ipv6_dst based on family , smac is set to mac address of egress device , dmac is set to nexthop mac address , rt_metric is set to metric from route (IPv4/IPv6 only) , and ifindex is set to the device index of the nexthop from the FIB lookup. <[ plen ]>(IP: 2) argument is the size of the passed in struct. <[ flags ]>(IP: 3) argument can be a combination of one or more of the following values: BPF_FIB_LOOKUP_DIRECT Do a direct table lookup vs full lookup using FIB rules. BPF_FIB_LOOKUP_OUTPUT Perform lookup from an egress perspective (default is ingress). <[ ctx ]>(IP: 0) is either struct xdp_md for XDP programs or struct sk_buff tc cls_act programs. Return \u00b7 < 0 if any input argument is invalid \u00b7 0 on success (packet is forwarded , nexthop neighbor exists) \u00b7 > 0 one of BPF_FIB_LKUP_RET_ codes explaining why the packet is not forwarded or needs assist from full stack ", "Function Name": "fib_lookup", "Input Params": ["{Type: void ,Var: *ctx}", "{Type:  struct fib_lookup ,Var: *params}", "{Type:  int ,Var: plen}", "{Type:  u32 ,Var: flags}"]}]}], "helperCallParams": {"bpf_fib_lookup": [{"opVar": "\tstruct bpf_fib_lookup fib_params ", "inpVar": [" "]}], "redirect": [{"opVar": "NA", "inpVar": ["\t\t\t\tgoto encap_"]}, {"opVar": "NA", "inpVar": ["\t\t\t\tgoto encap_"]}, {"opVar": "#if (defined(ENABLE_EGRESS_GATEWAY) || defined(TUNNEL_MODE)) && \\\t__ctx_is !", "inpVar": [" __ctx_xdpencap_:\tret "]}], "fib_lookup": [{"opVar": "\t\tfib_ret ", "inpVar": [" ctx", " &fib_params", " sizeoffib_params", " 0"]}], "map_lookup_elem": [{"opVar": "\t\t\t\t\t\t\t\t\tdmac ", "inpVar": [" &NODEPORT_NEIGH4", " &tuple.daddr"]}], "tail_call": [{"opVar": "NA", "inpVar": ["\t\t\tep_ctx", " CILIUM_CALL_IPV4_FROM_NETDEV"]}]}}}], "tail_rev_nodeport_lb4": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "startLine": "2129", "endLine": "2162", "capability": {"capabilities": [], "helperCallParams": {"redirect": [{"opVar": "NA", "inpVar": ["\treturn ctx_ctx", " ifindex", " 0"]}]}}}], "tail_handle_nat_fwd_ipv4": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "startLine": "2170", "endLine": "2188", "capability": {"capabilities": [], "helperCallParams": {}}}], "health_encap_v4": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "startLine": "2192", "endLine": "2211", "capability": {"capabilities": [], "helperCallParams": {}}}], "health_encap_v6": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "startLine": "2213", "endLine": "2232", "capability": {"capabilities": [], "helperCallParams": {}}}], "lb_handle_health": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "startLine": "2234", "endLine": "2280", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}, {"capability": "read_sys_info", "read_sys_info": [{"Project": "cilium", "Return Type": "u64", "Description": "Equivalent to get_socket_cookie() helper that accepts skb , but gets socket from struct sock_ops context. ", "Return": " A 8-byte long non-decreasing number.", "Function Name": "get_socket_cookie", "Input Params": ["{Type: struct sock_ops ,Var: *ctx}"]}]}], "helperCallParams": {"get_socket_cookie": [{"opVar": "\t\tkey ", "inpVar": [" ctx"]}, {"opVar": "\t\tkey ", "inpVar": [" ctx"]}], "map_lookup_elem": [{"opVar": "\t\tval ", "inpVar": [" &LB4_HEALTH_MAP", " &key"]}, {"opVar": "\t\tval ", "inpVar": [" &LB6_HEALTH_MAP", " &key"]}], "redirect": [{"opVar": "NA", "inpVar": ["\t\treturn ctx_ctx", " ENCAP4_IFINDEX", " 0"]}, {"opVar": "NA", "inpVar": ["\t\treturn ctx_ctx", " ENCAP6_IFINDEX", " 0"]}]}}}], "handle_nat_fwd": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nodeport.h", "startLine": "2283", "endLine": "2319", "capability": {"capabilities": [], "helperCallParams": {}}}], "identity_in_range": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/identity.h", "startLine": "9", "endLine": "12", "capability": {"capabilities": [], "helperCallParams": {}}}], "identity_is_remote_node": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/identity.h", "startLine": "14", "endLine": "32", "capability": {"capabilities": [], "helperCallParams": {}}}], "identity_is_node": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/identity.h", "startLine": "34", "endLine": "37", "capability": {"capabilities": [], "helperCallParams": {}}}], "identity_is_reserved": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/identity.h", "startLine": "57", "endLine": "60", "capability": {"capabilities": [], "helperCallParams": {}}}], "identity_is_cluster": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/identity.h", "startLine": "80", "endLine": "90", "capability": {"capabilities": [], "helperCallParams": {}}}], "inherit_identity_from_host": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/identity.h", "startLine": "93", "endLine": "137", "capability": {"capabilities": [], "helperCallParams": {}}}], "ipv4_load_daddr": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv4.h", "startLine": "35", "endLine": "39", "capability": {"capabilities": [], "helperCallParams": {}}}], "ipv4_dec_ttl": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv4.h", "startLine": "41", "endLine": "55", "capability": {"capabilities": [{"capability": "update_pkt", "update_pkt": [{"Project": "cilium", "Return Type": "int", "Description": "Recompute the layer 3 (e. g. IP) checksum for the packet associated <[ to ]>(IP: 3) skb. Computation is incremental , so the helper must know the former value of the header field that was modified (from) , the new value of this field (to) , and the number of bytes (2 or 4) for this field , stored in size. Alternatively , it is possible <[ to ]>(IP: 3) store the difference between the previous and the new values of the header field in <[ to ]>(IP: 3) , by setting <[ from ]>(IP: 2) and <[ size ]>(IP: 4) <[ to ]>(IP: 3) 0. For both methods , <[ offset ]>(IP: 1) indicates the location of the IP checksum within the packet. This helper works in combination with csum_diff() , which does not update the checksum in-place , but offers more flexibility and can handle sizes larger than 2 or 4 for the checksum <[ to ]>(IP: 3) update. A call <[ to ]>(IP: 3) this helper is susceptible <[ to ]>(IP: 3) change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "l3_csum_replace", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  u32 ,Var: offset}", "{Type:  u64 ,Var: from}", "{Type:  u64 ,Var: to}", "{Type:  u64 ,Var: size}"]}]}], "helperCallParams": {"l3_csum_replace": [{"opVar": "NA", "inpVar": ["\t\tctx", " off + offsetofstruct iphdr", " check", " ttl", " new_ttl", " 2"]}]}}}], "ipv4_hdrlen": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv4.h", "startLine": "57", "endLine": "60", "capability": {"capabilities": [], "helperCallParams": {}}}], "ipv4_is_fragment": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv4.h", "startLine": "62", "endLine": "74", "capability": {"capabilities": [], "helperCallParams": {}}}], "ipv4_is_not_first_fragment": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv4.h", "startLine": "76", "endLine": "80", "capability": {"capabilities": [], "helperCallParams": {}}}], "ipv4_has_l4_header": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv4.h", "startLine": "83", "endLine": "86", "capability": {"capabilities": [], "helperCallParams": {}}}], "ipv4_is_in_subnet": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv4.h", "startLine": "88", "endLine": "92", "capability": {"capabilities": [], "helperCallParams": {}}}], "ipv4_frag_get_l4ports": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv4.h", "startLine": "95", "endLine": "108", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"map_lookup_elem": [{"opVar": "\ttmp ", "inpVar": [" &IPV4_FRAG_DATAGRAMS_MAP", " frag_id"]}]}}}], "ipv4_handle_fragmentation": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv4.h", "startLine": "110", "endLine": "161", "capability": {"capabilities": [{"capability": "map_update", "map_update": [{"Project": "cilium", "Return Type": "int", "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "map_update_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}", "{Type:  const void ,Var: *value}", "{Type:  u64 ,Var: flags}"]}]}], "helperCallParams": {"map_update_elem": [{"opVar": "NA", "inpVar": ["\t\t\t\tif &IPV4_FRAG_DATAGRAMS_MAP", " &frag_id", " ports", " BPF_ANY\t\t\tupdate_metricsctx_full_lenctx", " dir", " REASON_FRAG_PACKET_UPDATE"]}]}}}], "ipv6_optlen": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv6.h", "startLine": "38", "endLine": "41", "capability": {"capabilities": [], "helperCallParams": {}}}], "ipv6_authlen": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv6.h", "startLine": "43", "endLine": "46", "capability": {"capabilities": [], "helperCallParams": {}}}], "ipv6_hdrlen": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv6.h", "startLine": "48", "endLine": "85", "capability": {"capabilities": [], "helperCallParams": {}}}], "ipv6_addr_copy": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv6.h", "startLine": "87", "endLine": "92", "capability": {"capabilities": [], "helperCallParams": {}}}], "ipv6_addrcmp": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv6.h", "startLine": "94", "endLine": "103", "capability": {"capabilities": [], "helperCallParams": {}}}], "ipv6_addr_in_net": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv6.h", "startLine": "106", "endLine": "116", "capability": {"capabilities": [], "helperCallParams": {}}}], "ipv6_addr_clear_suffix": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv6.h", "startLine": "122", "endLine": "132", "capability": {"capabilities": [], "helperCallParams": {}}}], "ipv6_match_prefix_64": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv6.h", "startLine": "134", "endLine": "144", "capability": {"capabilities": [], "helperCallParams": {}}}], "ipv6_dec_hoplimit": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv6.h", "startLine": "146", "endLine": "161", "capability": {"capabilities": [], "helperCallParams": {}}}], "ipv6_load_saddr": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv6.h", "startLine": "163", "endLine": "168", "capability": {"capabilities": [], "helperCallParams": {}}}], "ipv6_store_saddr": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv6.h", "startLine": "171", "endLine": "175", "capability": {"capabilities": [], "helperCallParams": {}}}], "ipv6_load_daddr": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv6.h", "startLine": "177", "endLine": "182", "capability": {"capabilities": [], "helperCallParams": {}}}], "ipv6_store_daddr": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv6.h", "startLine": "185", "endLine": "189", "capability": {"capabilities": [], "helperCallParams": {}}}], "ipv6_load_nexthdr": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv6.h", "startLine": "191", "endLine": "196", "capability": {"capabilities": [], "helperCallParams": {}}}], "ipv6_store_nexthdr": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv6.h", "startLine": "199", "endLine": "204", "capability": {"capabilities": [], "helperCallParams": {}}}], "ipv6_load_paylen": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv6.h", "startLine": "206", "endLine": "211", "capability": {"capabilities": [], "helperCallParams": {}}}], "ipv6_store_paylen": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv6.h", "startLine": "214", "endLine": "219", "capability": {"capabilities": [], "helperCallParams": {}}}], "ipv6_store_flowlabel": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv6.h", "startLine": "221", "endLine": "237", "capability": {"capabilities": [], "helperCallParams": {}}}], "ipv6_pseudohdr_checksum": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv6.h", "startLine": "239", "endLine": "252", "capability": {"capabilities": [{"capability": "read_skb", "read_skb": [{"Project": "cilium", "Return Type": "s64", "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ", "Return": " The checksum result, or a negative error code in case of failure.", "Function Name": "csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"]}]}], "helperCallParams": {"csum_diff": [{"opVar": "\tsum ", "inpVar": [" NULL", " 0", " &hdr->saddr", " sizeofstruct in6_addr", " sum"]}, {"opVar": "\tsum ", "inpVar": [" NULL", " 0", " &hdr->daddr", " sizeofstruct in6_addr", " sum"]}, {"opVar": "\tsum ", "inpVar": [" NULL", " 0", " &len", " sizeoflen", " sum"]}, {"opVar": "\tsum ", "inpVar": [" NULL", " 0", " &nexthdr", " sizeofnexthdr", " sum"]}]}}}], "ipv6_addr_is_mapped": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/ipv6.h", "startLine": "257", "endLine": "260", "capability": {"capabilities": [], "helperCallParams": {}}}], "reset_queue_mapping": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/qm.h", "startLine": "9", "endLine": "22", "capability": {"capabilities": [], "helperCallParams": {}}}], "ctx_redirect_to_proxy_hairpin": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/proxy_hairpin.h", "startLine": "22", "endLine": "63", "capability": {"capabilities": [], "helperCallParams": {"redirect": [{"opVar": "NA", "inpVar": ["ctx__to_proxy_hairpinstruct __ctx_buff *ctx", " __be16 proxy_port", " const bool is_ipv6"]}, {"opVar": "NA", "inpVar": ["\t\treturn ctx_ctx", " HOST_IFINDEX", " 0"]}]}}}], "ctx_redirect_to_proxy_hairpin_ipv4": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/proxy_hairpin.h", "startLine": "66", "endLine": "70", "capability": {"capabilities": [], "helperCallParams": {"redirect": [{"opVar": "NA", "inpVar": ["ctx__to_proxy_hairpin_ipv4struct __ctx_buff *ctx", " __be16 proxy_port"]}, {"opVar": "NA", "inpVar": ["\treturn ctx__to_proxy_hairpinctx", " proxy_port", " false"]}]}}}], "ctx_redirect_to_proxy_hairpin_ipv6": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/proxy_hairpin.h", "startLine": "74", "endLine": "78", "capability": {"capabilities": [], "helperCallParams": {"redirect": [{"opVar": "NA", "inpVar": ["ctx__to_proxy_hairpin_ipv6struct __ctx_buff *ctx", " __be16 proxy_port"]}, {"opVar": "NA", "inpVar": ["\treturn ctx__to_proxy_hairpinctx", " proxy_port", " true"]}]}}}], "edt_set_aggregate": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/edt.h", "startLine": "17", "endLine": "22", "capability": {"capabilities": [], "helperCallParams": {}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/edt.h", "startLine": "79", "endLine": "83", "capability": {"capabilities": [], "helperCallParams": {}}}], "edt_get_aggregate": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/edt.h", "startLine": "24", "endLine": "34", "capability": {"capabilities": [], "helperCallParams": {}}}], "edt_sched_departure": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/edt.h", "startLine": "36", "endLine": "77", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}, {"capability": "read_sys_info", "read_sys_info": [{"Project": "cilium", "Return Type": "u64", "Description": "Return the time elapsed since system boot , in nanoseconds. ", "Return": " Current ktime.", "Function Name": "ktime_get_ns", "Input Params": ["{Type: voi ,Var: void}"]}]}], "helperCallParams": {"map_lookup_elem": [{"opVar": "\tinfo ", "inpVar": [" &THROTTLE_MAP", " &aggregate"]}], "ktime_get_ns": [{"opVar": "\tnow ", "inpVar": [" "]}]}}}], "policy_sk_egress": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/policy.h", "startLine": "15", "endLine": "79", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"map_lookup_elem": [{"opVar": "\t\tpolicy ", "inpVar": [" map", " &key"]}, {"opVar": "\tpolicy ", "inpVar": [" map", " &key"]}, {"opVar": "\tpolicy ", "inpVar": [" map", " &key"]}, {"opVar": "\tpolicy ", "inpVar": [" map", " &key"]}]}}}], "account": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/policy.h", "startLine": "81", "endLine": "87", "capability": {"capabilities": [], "helperCallParams": {}}}], "__policy_can_access": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/policy.h", "startLine": "89", "endLine": "222", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"map_lookup_elem": [{"opVar": "\t\t\t\tpolicy ", "inpVar": [" map", " &key"]}, {"opVar": "\t\tpolicy ", "inpVar": [" map", " &key"]}, {"opVar": "\tpolicy ", "inpVar": [" map", " &key"]}, {"opVar": "\tpolicy ", "inpVar": [" map", " &key"]}]}}}], "policy_can_access_ingress": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/policy.h", "startLine": "240", "endLine": "264", "capability": {"capabilities": [], "helperCallParams": {}}}], "is_encap": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/policy.h", "startLine": "267", "endLine": "270", "capability": {"capabilities": [], "helperCallParams": {}}}], "policy_can_egress": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/policy.h", "startLine": "273", "endLine": "296", "capability": {"capabilities": [], "helperCallParams": {}}}], "policy_can_egress6": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/policy.h", "startLine": "298", "endLine": "305", "capability": {"capabilities": [], "helperCallParams": {}}}], "policy_can_egress4": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/policy.h", "startLine": "307", "endLine": "314", "capability": {"capabilities": [], "helperCallParams": {}}}], "policy_mark_skip": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/policy.h", "startLine": "323", "endLine": "326", "capability": {"capabilities": [], "helperCallParams": {}}}], "policy_clear_mark": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/policy.h", "startLine": "328", "endLine": "331", "capability": {"capabilities": [], "helperCallParams": {}}}], "validate_ethertype": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/common.h", "startLine": "121", "endLine": "142", "capability": {"capabilities": [], "helperCallParams": {}}}], "____revalidate_data_pull": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/common.h", "startLine": "144", "endLine": "167", "capability": {"capabilities": [], "helperCallParams": {}}}], "__revalidate_data_pull": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/common.h", "startLine": "169", "endLine": "175", "capability": {"capabilities": [], "helperCallParams": {}}}], "or_encrypt_key": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/common.h", "startLine": "605", "endLine": "608", "capability": {"capabilities": [], "helperCallParams": {}}}], "ct_state_is_from_l7lb": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/common.h", "startLine": "958", "endLine": "965", "capability": {"capabilities": [], "helperCallParams": {}}}], "redirect_ep": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/common.h", "startLine": "984", "endLine": "1012", "capability": {"capabilities": [], "helperCallParams": {"redirect": [{"opVar": "NA", "inpVar": ["\t\treturn ctx_ctx", " ifindex", " 0"]}, {"opVar": "NA", "inpVar": ["# endif \t\treturn ctx__peerctx", " ifindex", " 0"]}]}}}], "__send_drop_notify": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/drop.h", "startLine": "52", "endLine": "80", "capability": {"capabilities": [], "helperCallParams": {}}}], "_send_drop_notify": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/drop.h", "startLine": "95", "endLine": "116", "capability": {"capabilities": [], "helperCallParams": {"tail_call": [{"opVar": "NA", "inpVar": ["\tep_ctx", " CILIUM_CALL_DROP_NOTIFY"]}]}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/drop.h", "startLine": "118", "endLine": "126", "capability": {"capabilities": [], "helperCallParams": {}}}], "cilium_dbg": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/dbg.h", "startLine": "183", "endLine": "194", "capability": {"capabilities": [], "helperCallParams": {}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/dbg.h", "startLine": "242", "endLine": "246", "capability": {"capabilities": [], "helperCallParams": {}}}], "cilium_dbg3": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/dbg.h", "startLine": "196", "endLine": "208", "capability": {"capabilities": [], "helperCallParams": {}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/dbg.h", "startLine": "248", "endLine": "253", "capability": {"capabilities": [], "helperCallParams": {}}}], "cilium_dbg_capture2": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/dbg.h", "startLine": "216", "endLine": "231", "capability": {"capabilities": [], "helperCallParams": {}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/dbg.h", "startLine": "261", "endLine": "266", "capability": {"capabilities": [], "helperCallParams": {}}}], "cilium_dbg_capture": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/dbg.h", "startLine": "233", "endLine": "237", "capability": {"capabilities": [], "helperCallParams": {}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/dbg.h", "startLine": "255", "endLine": "259", "capability": {"capabilities": [], "helperCallParams": {}}}], "do_decrypt": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/encrypt.h", "startLine": "15", "endLine": "75", "capability": {"capabilities": [], "helperCallParams": {"redirect": [{"opVar": "NA", "inpVar": ["#else\treturn ctx_ctx", " CILIUM_IFINDEX", " 0"]}]}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/encrypt.h", "startLine": "77", "endLine": "81", "capability": {"capabilities": [], "helperCallParams": {}}}], "assign_socket_tcp": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/proxy.h", "startLine": "14", "endLine": "42", "capability": {"capabilities": [{"capability": "read_sys_info", "read_sys_info": [{"Project": "cilium", "Return Type": "struct sock*", "Description": "Look for TCP socket matching <[ tuple ]>(IP: 1) , optionally in a child network namespace netns. The return value must be checked , and if non-NULL , released via sk_release(). This function is identical to sk_lookup_tcp() , except that it also returns timewait or request sockets. Use sk_fullsock() or tcp_sock() to access the full structure. This helper is available only if the kernel was compiled with CONFIG_NET configuration option. ", "Return": " Pointer  to  struct  sock, or NULL in case of failure.  For sockets with                     reuseport option, the struct  sock result is  from  reuse->socks[]  using                     the hash of the tuple.", "Function Name": "skc_lookup_tcp", "Input Params": ["{Type: void ,Var: *ctx}", "{Type:  struct sock_tuple ,Var: *tuple}", "{Type:  u32 ,Var: tuple_size}", "{Type:  u64 ,Var: netns}", "{Type:  u64 ,Var: flags}"]}]}], "helperCallParams": {"skc_lookup_tcp": [{"opVar": "\tsk ", "inpVar": [" ctx", " tuple", " len", " BPF_F_CURRENT_NETNS", " 0"]}], "sk_release": [{"opVar": "NA", "inpVar": ["release:\tsk"]}]}}}], "assign_socket_udp": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/proxy.h", "startLine": "44", "endLine": "67", "capability": {"capabilities": [{"capability": "read_sys_info", "read_sys_info": [{"Project": "cilium", "Return Type": "struct sock*", "Description": "Look for UDP socket matching <[ tuple ]>(IP: 1) , optionally in a child network namespace netns. The return value must be checked , and if non-NULL , released via sk_release(). The <[ ctx ]>(IP: 0) should point to the context of the program , such as the skb or socket (depending on the hook in use). This is used to determine the base network namespace for the lookup. <[ tuple_size ]>(IP: 2) must be one of: sizeof(tuple->ipv4) Look for an IPv4 socket. sizeof(tuple->ipv6) Look for an IPv6 socket. If the <[ netns ]>(IP: 3) is a negative signed 32-bit integer , then the socket lookup table in the <[ netns ]>(IP: 3) associated with the <[ ctx ]>(IP: 0) will will be used. For the TC hooks , this is the <[ netns ]>(IP: 3) of the device in the skb. For socket hooks , this is the <[ netns ]>(IP: 3) of the socket. If <[ netns ]>(IP: 3) is any other signed 32-bit value greater than or equal to zero then it specifies the ID of the <[ netns ]>(IP: 3) relative to the <[ netns ]>(IP: 3) associated with the ctx. <[ netns ]>(IP: 3) values beyond the range of 32-bit integers are reserved for future use. All values for <[ flags ]>(IP: 4) are reserved for future usage , and must be left at zero. This helper is available only if the kernel was compiled with CONFIG_NET configuration option. ", "Return": " Pointer  to  struct  sock, or NULL in case of failure.  For sockets with                     reuseport option, the struct  sock result is  from  reuse->socks[]  using                     the hash of the tuple.", "Function Name": "sk_lookup_udp", "Input Params": ["{Type: void ,Var: *ctx}", "{Type:  struct sock_tuple ,Var: *tuple}", "{Type:  u32 ,Var: tuple_size}", "{Type:  u64 ,Var: netns}", "{Type:  u64 ,Var: flags}"]}]}], "helperCallParams": {"sk_lookup_udp": [{"opVar": "\tsk ", "inpVar": [" ctx", " tuple", " len", " BPF_F_CURRENT_NETNS", " 0"]}], "sk_release": [{"opVar": "NA", "inpVar": ["\tsk"]}]}}}], "assign_socket": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/proxy.h", "startLine": "69", "endLine": "86", "capability": {"capabilities": [], "helperCallParams": {}}}], "combine_ports": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/proxy.h", "startLine": "92", "endLine": "96", "capability": {"capabilities": [], "helperCallParams": {}}}], "__ctx_redirect_to_proxy": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/proxy.h", "startLine": "190", "endLine": "220", "capability": {"capabilities": [], "helperCallParams": {"redirect": [{"opVar": "NA", "inpVar": ["__ctx__to_proxystruct __ctx_buff *ctx", " void *tuple __maybe_unused", "\t\t\t__be16 proxy_port", " bool from_host __maybe_unused", "\t\t\tbool ipv4 __maybe_unused"]}, {"opVar": "#ifdef ENABLE_IPV4\t\tif (ipv4)\t\t\tresult ", "inpVar": [" ctx__to_proxy_ingress4ctx", " tuple", " proxy_port"]}, {"opVar": "#endif #ifdef ENABLE_IPV6\t\tif (!ipv4)\t\t\tresult ", "inpVar": [" ctx__to_proxy_ingress6ctx", " tuple", " proxy_port"]}]}}}], "ctx_redirect_to_proxy4": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/proxy.h", "startLine": "223", "endLine": "228", "capability": {"capabilities": [], "helperCallParams": {"redirect": [{"opVar": "NA", "inpVar": ["ctx__to_proxy4struct __ctx_buff *ctx", " void *tuple __maybe_unused", "\t\t       __be16 proxy_port", " bool from_host __maybe_unused"]}, {"opVar": "NA", "inpVar": ["\treturn __ctx__to_proxyctx", " tuple", " proxy_port", " from_host", " true"]}]}}}], "ctx_redirect_to_proxy6": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/proxy.h", "startLine": "232", "endLine": "237", "capability": {"capabilities": [], "helperCallParams": {"redirect": [{"opVar": "NA", "inpVar": ["ctx__to_proxy6struct __ctx_buff *ctx", " void *tuple __maybe_unused", "\t\t       __be16 proxy_port", " bool from_host __maybe_unused"]}, {"opVar": "NA", "inpVar": ["\treturn __ctx__to_proxyctx", " tuple", " proxy_port", " from_host", " false"]}]}}}], "ctx_redirect_to_proxy_first": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/proxy.h", "startLine": "280", "endLine": "337", "capability": {"capabilities": [], "helperCallParams": {"redirect": [{"opVar": "NA", "inpVar": ["ctx__to_proxy_firststruct __ctx_buff *ctx", " __be16 proxy_port"]}, {"opVar": "\t\tret ", "inpVar": [" ctx__to_proxy_ingress6ctx", " &tuple", " proxy_port"]}, {"opVar": "\t\tret ", "inpVar": [" ctx__to_proxy_ingress4ctx", " &tuple", " proxy_port"]}]}}}], "tc_index_skip_ingress_proxy": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/proxy.h", "startLine": "342", "endLine": "351", "capability": {"capabilities": [], "helperCallParams": {}}}], "tc_index_skip_egress_proxy": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/proxy.h", "startLine": "356", "endLine": "365", "capability": {"capabilities": [], "helperCallParams": {}}}], "is_valid_lxc_src_ip": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lxc.h", "startLine": "22", "endLine": "34", "capability": {"capabilities": [], "helperCallParams": {}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lxc.h", "startLine": "47", "endLine": "51", "capability": {"capabilities": [], "helperCallParams": {}}}], "is_valid_lxc_src_ipv4": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lxc.h", "startLine": "36", "endLine": "45", "capability": {"capabilities": [], "helperCallParams": {}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lxc.h", "startLine": "53", "endLine": "57", "capability": {"capabilities": [], "helperCallParams": {}}}], "redirect_direct_v6": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/fib.h", "startLine": "14", "endLine": "66", "capability": {"capabilities": [{"capability": "read_sys_info", "read_sys_info": [{"Project": "libbpf", "Return Type": "int", "Description": "Do FIB lookup in kernel tables using parameters in params. If lookup is successful and result shows packet is to be forwarded , the neighbor tables are searched for the nexthop. If successful (ie. , FIB lookup shows forwarding and nexthop is resolved) , the nexthop address is returned in ipv4_dst or ipv6_dst based on family , smac is set to mac address of egress device , dmac is set to nexthop mac address , rt_metric is set to metric from route (IPv4/IPv6 only) , and ifindex is set to the device index of the nexthop from the FIB lookup. <[ plen ]>(IP: 2) argument is the size of the passed in struct. <[ flags ]>(IP: 3) argument can be a combination of one or more of the following values: BPF_FIB_LOOKUP_DIRECT Do a direct table lookup vs full lookup using FIB rules. BPF_FIB_LOOKUP_OUTPUT Perform lookup from an egress perspective (default is ingress). <[ ctx ]>(IP: 0) is either struct xdp_md for XDP programs or struct sk_buff tc cls_act programs. Return \u00b7 < 0 if any input argument is invalid \u00b7 0 on success (packet is forwarded , nexthop neighbor exists) \u00b7 > 0 one of BPF_FIB_LKUP_RET_ codes explaining why the packet is not forwarded or needs assist from full stack ", "Function Name": "bpf_fib_lookup", "Input Params": ["{Type: void ,Var: *ctx}", "{Type:  struct bpf_fib_lookup ,Var: *params}", "{Type:  int ,Var: plen}", "{Type:  u32 ,Var: flags}"]}, {"Project": "cilium", "Return Type": "int", "Description": "Do FIB lookup in kernel tables using parameters in params. If lookup is successful and result shows packet is to be forwarded , the neighbor tables are searched for the nexthop. If successful (ie. , FIB lookup shows forwarding and nexthop is resolved) , the nexthop address is returned in ipv4_dst or ipv6_dst based on family , smac is set to mac address of egress device , dmac is set to nexthop mac address , rt_metric is set to metric from route (IPv4/IPv6 only) , and ifindex is set to the device index of the nexthop from the FIB lookup. <[ plen ]>(IP: 2) argument is the size of the passed in struct. <[ flags ]>(IP: 3) argument can be a combination of one or more of the following values: BPF_FIB_LOOKUP_DIRECT Do a direct table lookup vs full lookup using FIB rules. BPF_FIB_LOOKUP_OUTPUT Perform lookup from an egress perspective (default is ingress). <[ ctx ]>(IP: 0) is either struct xdp_md for XDP programs or struct sk_buff tc cls_act programs. Return \u00b7 < 0 if any input argument is invalid \u00b7 0 on success (packet is forwarded , nexthop neighbor exists) \u00b7 > 0 one of BPF_FIB_LKUP_RET_ codes explaining why the packet is not forwarded or needs assist from full stack ", "Function Name": "fib_lookup", "Input Params": ["{Type: void ,Var: *ctx}", "{Type:  struct fib_lookup ,Var: *params}", "{Type:  int ,Var: plen}", "{Type:  u32 ,Var: flags}"]}]}], "helperCallParams": {"redirect": [{"opVar": "NA", "inpVar": ["_direct_v6struct __ctx_buff *ctx __maybe_unused", "\t\t   int l3_off __maybe_unused", "\t\t   struct ipv6hdr *ip6 __maybe_unused"]}, {"opVar": "NA", "inpVar": ["\tif no_neigh\t\treturn _neighoif", " nh", " nh ? sizeof*nh : 0", " 0"]}, {"opVar": "NA", "inpVar": ["\treturn ctx_ctx", " oif", " 0"]}], "bpf_fib_lookup": [{"opVar": "\tstruct bpf_fib_lookup fib_params ", "inpVar": [" "]}], "fib_lookup": [{"opVar": "\tret ", "inpVar": [" ctx", " &fib_params", " sizeoffib_params", "\t\t\t BPF_FIB_LOOKUP_DIRECT"]}]}}}], "redirect_direct_v4": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/fib.h", "startLine": "70", "endLine": "126", "capability": {"capabilities": [{"capability": "read_sys_info", "read_sys_info": [{"Project": "libbpf", "Return Type": "int", "Description": "Do FIB lookup in kernel tables using parameters in params. If lookup is successful and result shows packet is to be forwarded , the neighbor tables are searched for the nexthop. If successful (ie. , FIB lookup shows forwarding and nexthop is resolved) , the nexthop address is returned in ipv4_dst or ipv6_dst based on family , smac is set to mac address of egress device , dmac is set to nexthop mac address , rt_metric is set to metric from route (IPv4/IPv6 only) , and ifindex is set to the device index of the nexthop from the FIB lookup. <[ plen ]>(IP: 2) argument is the size of the passed in struct. <[ flags ]>(IP: 3) argument can be a combination of one or more of the following values: BPF_FIB_LOOKUP_DIRECT Do a direct table lookup vs full lookup using FIB rules. BPF_FIB_LOOKUP_OUTPUT Perform lookup from an egress perspective (default is ingress). <[ ctx ]>(IP: 0) is either struct xdp_md for XDP programs or struct sk_buff tc cls_act programs. Return \u00b7 < 0 if any input argument is invalid \u00b7 0 on success (packet is forwarded , nexthop neighbor exists) \u00b7 > 0 one of BPF_FIB_LKUP_RET_ codes explaining why the packet is not forwarded or needs assist from full stack ", "Function Name": "bpf_fib_lookup", "Input Params": ["{Type: void ,Var: *ctx}", "{Type:  struct bpf_fib_lookup ,Var: *params}", "{Type:  int ,Var: plen}", "{Type:  u32 ,Var: flags}"]}, {"Project": "cilium", "Return Type": "int", "Description": "Do FIB lookup in kernel tables using parameters in params. If lookup is successful and result shows packet is to be forwarded , the neighbor tables are searched for the nexthop. If successful (ie. , FIB lookup shows forwarding and nexthop is resolved) , the nexthop address is returned in ipv4_dst or ipv6_dst based on family , smac is set to mac address of egress device , dmac is set to nexthop mac address , rt_metric is set to metric from route (IPv4/IPv6 only) , and ifindex is set to the device index of the nexthop from the FIB lookup. <[ plen ]>(IP: 2) argument is the size of the passed in struct. <[ flags ]>(IP: 3) argument can be a combination of one or more of the following values: BPF_FIB_LOOKUP_DIRECT Do a direct table lookup vs full lookup using FIB rules. BPF_FIB_LOOKUP_OUTPUT Perform lookup from an egress perspective (default is ingress). <[ ctx ]>(IP: 0) is either struct xdp_md for XDP programs or struct sk_buff tc cls_act programs. Return \u00b7 < 0 if any input argument is invalid \u00b7 0 on success (packet is forwarded , nexthop neighbor exists) \u00b7 > 0 one of BPF_FIB_LKUP_RET_ codes explaining why the packet is not forwarded or needs assist from full stack ", "Function Name": "fib_lookup", "Input Params": ["{Type: void ,Var: *ctx}", "{Type:  struct fib_lookup ,Var: *params}", "{Type:  int ,Var: plen}", "{Type:  u32 ,Var: flags}"]}]}], "helperCallParams": {"redirect": [{"opVar": "NA", "inpVar": ["_direct_v4struct __ctx_buff *ctx __maybe_unused", "\t\t   int l3_off __maybe_unused", "\t\t   struct iphdr *ip4 __maybe_unused"]}, {"opVar": "NA", "inpVar": ["\tif no_neigh\t\treturn _neighoif", " nh", " nh ? sizeof*nh : 0", " 0"]}, {"opVar": "NA", "inpVar": ["\treturn ctx_ctx", " oif", " 0"]}], "bpf_fib_lookup": [{"opVar": "\tstruct bpf_fib_lookup fib_params ", "inpVar": [" "]}], "fib_lookup": [{"opVar": "\tret ", "inpVar": [" ctx", " &fib_params", " sizeoffib_params", "\t\t\t BPF_FIB_LOOKUP_DIRECT"]}]}}}], "encap_and_redirect_nomark_ipsec": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/encap.h", "startLine": "18", "endLine": "40", "capability": {"capabilities": [], "helperCallParams": {"redirect": [{"opVar": "NA", "inpVar": ["encap_and__nomark_ipsecstruct __ctx_buff *ctx", " __u32 tunnel_endpoint", "\t\t\t\t__u8 key", " __u32 seclabel"]}]}}}], "encap_and_redirect_ipsec": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/encap.h", "startLine": "42", "endLine": "57", "capability": {"capabilities": [], "helperCallParams": {"redirect": [{"opVar": "NA", "inpVar": ["encap_and__ipsecstruct __ctx_buff *ctx", " __u32 tunnel_endpoint", "\t\t\t __u8 key", " __u32 seclabel"]}]}}}], "encap_remap_v6_host_address": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/encap.h", "startLine": "60", "endLine": "117", "capability": {"capabilities": [{"capability": "read_skb", "read_skb": [{"Project": "cilium", "Return Type": "s64", "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ", "Return": " The checksum result, or a negative error code in case of failure.", "Function Name": "csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"]}]}], "helperCallParams": {"csum_diff": [{"opVar": "\t\tsum ", "inpVar": [" which", " 16", " &host_ip", " 16", " 0"]}]}}}], "__encap_with_nodeid": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/encap.h", "startLine": "119", "endLine": "154", "capability": {"capabilities": [], "helperCallParams": {}}}], "__encap_and_redirect_with_nodeid": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/encap.h", "startLine": "156", "endLine": "167", "capability": {"capabilities": [], "helperCallParams": {"redirect": [{"opVar": "NA", "inpVar": ["__encap_and__with_nodeidstruct __ctx_buff *ctx", " __u32 tunnel_endpoint", "\t\t\t\t __u32 seclabel", " __u32 vni", "\t\t\t\t const struct trace_ctx *trace"]}, {"opVar": "NA", "inpVar": ["\treturn ctx_ctx", " ENCAP_IFINDEX", " 0"]}]}}}], "encap_and_redirect_with_nodeid": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/encap.h", "startLine": "174", "endLine": "185", "capability": {"capabilities": [], "helperCallParams": {"redirect": [{"opVar": "NA", "inpVar": ["encap_and__with_nodeidstruct __ctx_buff *ctx", " __u32 tunnel_endpoint", "\t\t\t       __u8 key __maybe_unused", " __u32 seclabel", "\t\t\t       const struct trace_ctx *trace"]}, {"opVar": "NA", "inpVar": ["#ifdef ENABLE_IPSEC\tif key\t\treturn encap_and__nomark_ipsecctx", " tunnel_endpoint", " key", " seclabel"]}, {"opVar": "NA", "inpVar": ["#endif\treturn __encap_and__with_nodeidctx", " tunnel_endpoint", " seclabel", " NOT_VTEP_DST", "\t\t\t\t\t\ttrace"]}]}}}], "encap_and_redirect_lxc": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/encap.h", "startLine": "197", "endLine": "242", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"redirect": [{"opVar": "NA", "inpVar": ["encap_and__lxcstruct __ctx_buff *ctx", " __u32 tunnel_endpoint", "\t\t       __u8 encrypt_key __maybe_unused", "\t\t       struct endpoint_key *key", " __u32 seclabel", "\t\t       const struct trace_ctx *trace"]}, {"opVar": "NA", "inpVar": ["#ifdef ENABLE_IPSEC\t\tif encrypt_key\t\t\treturn encap_and__ipsecctx", " tunnel_endpoint", "\t\t\t\t\t\t\tencrypt_key", " seclabel"]}, {"opVar": "NA", "inpVar": ["#else\t\treturn __encap_and__with_nodeidctx", " tunnel_endpoint", "\t\t\t\t\t\t\tseclabel", " NOT_VTEP_DST", " trace"]}, {"opVar": "NA", "inpVar": ["\t\treturn encap_and__ipsecctx", " tunnel->ip4", "\t\t\t\t\t\tmin_encrypt_key", "\t\t\t\t\t\tseclabel"]}, {"opVar": "NA", "inpVar": ["\t#endif\treturn __encap_and__with_nodeidctx", " tunnel->ip4", " seclabel", "\t\t\t\t\t\tNOT_VTEP_DST", " trace"]}], "map_lookup_elem": [{"opVar": "#endif \t\ttunnel ", "inpVar": [" &TUNNEL_MAP", " key"]}]}}}], "encap_and_redirect_netdev": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/encap.h", "startLine": "244", "endLine": "264", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"redirect": [{"opVar": "NA", "inpVar": ["encap_and__netdevstruct __ctx_buff *ctx", " struct endpoint_key *k", "\t\t\t  __u32 seclabel", " const struct trace_ctx *trace"]}, {"opVar": "NA", "inpVar": ["\t\treturn encap_and__nomark_ipsecctx", " tunnel->ip4", "\t\t\t\t\t\t       key", " seclabel"]}, {"opVar": "NA", "inpVar": ["\t#endif\treturn __encap_and__with_nodeidctx", " tunnel->ip4", " seclabel", "\t\t\t\t\t\tNOT_VTEP_DST", " trace"]}], "map_lookup_elem": [{"opVar": "\ttunnel ", "inpVar": [" &TUNNEL_MAP", " k"]}]}}}], "icmp6_load_type": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/icmp6.h", "startLine": "43", "endLine": "49", "capability": {"capabilities": [], "helperCallParams": {}}}], "icmp6_send_reply": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/icmp6.h", "startLine": "51", "endLine": "90", "capability": {"capabilities": [{"capability": "read_skb", "read_skb": [{"Project": "cilium", "Return Type": "s64", "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ", "Return": " The checksum result, or a negative error code in case of failure.", "Function Name": "csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"]}]}, {"capability": "update_pkt", "update_pkt": [{"Project": "cilium", "Return Type": "int", "Description": "Recompute the layer 4 (e. g. TCP , UDP or ICMP) checksum for the packet associated <[ to ]>(IP: 3) skb. Computation is incremental , so the helper must know the former value of the header field that was modified (from) , the new value of this field (to) , and the number of bytes (2 or 4) for this field , stored on the lowest four bits of flags. Alternatively , it is possible <[ to ]>(IP: 3) store the difference between the previous and the new values of the header field in <[ to ]>(IP: 3) , by setting <[ from ]>(IP: 2) and the four lowest bits of <[ flags ]>(IP: 4) <[ to ]>(IP: 3) 0. For both methods , <[ offset ]>(IP: 1) indicates the location of the IP checksum within the packet. In addition <[ to ]>(IP: 3) the size of the field , <[ flags ]>(IP: 4) can be added (bitwise OR) actual flags. With BPF_F_MARK_MANGLED_0 , a null checksum is left untouched (unless BPF_F_MARK_ENFORCE is added as well) , and for updates resulting in a null checksum the value is set <[ to ]>(IP: 3) CSUM_MANGLED_0 instead. Flag BPF_F_PSEUDO_HDR indicates the checksum is <[ to ]>(IP: 3) be computed against a pseudo-header. This helper works in combination with csum_diff() , which does not update the checksum in-place , but offers more flexibility and can handle sizes larger than 2 or 4 for the checksum <[ to ]>(IP: 3) update. A call <[ to ]>(IP: 3) this helper is susceptible <[ to ]>(IP: 3) change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "l4_csum_replace", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  u32 ,Var: offset}", "{Type:  u64 ,Var: from}", "{Type:  u64 ,Var: to}", "{Type:  u64 ,Var: flags}"]}]}], "helperCallParams": {"csum_diff": [{"opVar": "\t\tsum ", "inpVar": [" sip.addr", " 16", " router_ip.addr", " 16", " 0"]}, {"opVar": "\tsum ", "inpVar": [" dip.addr", " 16", " sip.addr", " 16", " 0"]}], "l4_csum_replace": [{"opVar": "NA", "inpVar": ["\tif ctx", " csum_off", " 0", " sum", " BPF_F_PSEUDO_HDR < 0\t\treturn DROP_CSUM_L4"]}, {"opVar": "NA", "inpVar": ["\tif ctx", " csum_off", " 0", " sum", " BPF_F_PSEUDO_HDR < 0\t\treturn DROP_CSUM_L4"]}], "redirect": [{"opVar": "NA", "inpVar": ["\treturn _selfctx"]}]}}}], "__icmp6_send_echo_reply": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/icmp6.h", "startLine": "92", "endLine": "125", "capability": {"capabilities": [{"capability": "read_skb", "read_skb": [{"Project": "cilium", "Return Type": "s64", "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ", "Return": " The checksum result, or a negative error code in case of failure.", "Function Name": "csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"]}]}, {"capability": "update_pkt", "update_pkt": [{"Project": "cilium", "Return Type": "int", "Description": "Recompute the layer 4 (e. g. TCP , UDP or ICMP) checksum for the packet associated <[ to ]>(IP: 3) skb. Computation is incremental , so the helper must know the former value of the header field that was modified (from) , the new value of this field (to) , and the number of bytes (2 or 4) for this field , stored on the lowest four bits of flags. Alternatively , it is possible <[ to ]>(IP: 3) store the difference between the previous and the new values of the header field in <[ to ]>(IP: 3) , by setting <[ from ]>(IP: 2) and the four lowest bits of <[ flags ]>(IP: 4) <[ to ]>(IP: 3) 0. For both methods , <[ offset ]>(IP: 1) indicates the location of the IP checksum within the packet. In addition <[ to ]>(IP: 3) the size of the field , <[ flags ]>(IP: 4) can be added (bitwise OR) actual flags. With BPF_F_MARK_MANGLED_0 , a null checksum is left untouched (unless BPF_F_MARK_ENFORCE is added as well) , and for updates resulting in a null checksum the value is set <[ to ]>(IP: 3) CSUM_MANGLED_0 instead. Flag BPF_F_PSEUDO_HDR indicates the checksum is <[ to ]>(IP: 3) be computed against a pseudo-header. This helper works in combination with csum_diff() , which does not update the checksum in-place , but offers more flexibility and can handle sizes larger than 2 or 4 for the checksum <[ to ]>(IP: 3) update. A call <[ to ]>(IP: 3) this helper is susceptible <[ to ]>(IP: 3) change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "l4_csum_replace", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  u32 ,Var: offset}", "{Type:  u64 ,Var: from}", "{Type:  u64 ,Var: to}", "{Type:  u64 ,Var: flags}"]}]}], "helperCallParams": {"csum_diff": [{"opVar": "\t\tsum ", "inpVar": [" &icmp6hdr_old", " sizeoficmp6hdr_old", "\t\t\t&icmp6hdr", " sizeoficmp6hdr", " 0"]}], "l4_csum_replace": [{"opVar": "NA", "inpVar": ["\tif ctx", " csum_off", " 0", " sum", " BPF_F_PSEUDO_HDR < 0\t\treturn DROP_CSUM_L4"]}]}}}], "tail_icmp6_send_echo_reply": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/icmp6.h", "startLine": "129", "endLine": "139", "capability": {"capabilities": [], "helperCallParams": {}}}], "icmp6_send_echo_reply": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/icmp6.h", "startLine": "151", "endLine": "160", "capability": {"capabilities": [], "helperCallParams": {"tail_call": [{"opVar": "NA", "inpVar": ["\tep_ctx", " CILIUM_CALL_SEND_ICMP6_ECHO_REPLY"]}]}}}], "send_icmp6_ndisc_adv": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/icmp6.h", "startLine": "171", "endLine": "232", "capability": {"capabilities": [{"capability": "read_skb", "read_skb": [{"Project": "cilium", "Return Type": "s64", "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ", "Return": " The checksum result, or a negative error code in case of failure.", "Function Name": "csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"]}]}, {"capability": "update_pkt", "update_pkt": [{"Project": "cilium", "Return Type": "int", "Description": "Recompute the layer 4 (e. g. TCP , UDP or ICMP) checksum for the packet associated <[ to ]>(IP: 3) skb. Computation is incremental , so the helper must know the former value of the header field that was modified (from) , the new value of this field (to) , and the number of bytes (2 or 4) for this field , stored on the lowest four bits of flags. Alternatively , it is possible <[ to ]>(IP: 3) store the difference between the previous and the new values of the header field in <[ to ]>(IP: 3) , by setting <[ from ]>(IP: 2) and the four lowest bits of <[ flags ]>(IP: 4) <[ to ]>(IP: 3) 0. For both methods , <[ offset ]>(IP: 1) indicates the location of the IP checksum within the packet. In addition <[ to ]>(IP: 3) the size of the field , <[ flags ]>(IP: 4) can be added (bitwise OR) actual flags. With BPF_F_MARK_MANGLED_0 , a null checksum is left untouched (unless BPF_F_MARK_ENFORCE is added as well) , and for updates resulting in a null checksum the value is set <[ to ]>(IP: 3) CSUM_MANGLED_0 instead. Flag BPF_F_PSEUDO_HDR indicates the checksum is <[ to ]>(IP: 3) be computed against a pseudo-header. This helper works in combination with csum_diff() , which does not update the checksum in-place , but offers more flexibility and can handle sizes larger than 2 or 4 for the checksum <[ to ]>(IP: 3) update. A call <[ to ]>(IP: 3) this helper is susceptible <[ to ]>(IP: 3) change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "l4_csum_replace", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  u32 ,Var: offset}", "{Type:  u64 ,Var: from}", "{Type:  u64 ,Var: to}", "{Type:  u64 ,Var: flags}"]}]}], "helperCallParams": {"csum_diff": [{"opVar": "\t\tsum ", "inpVar": [" &icmp6hdr_old", " sizeoficmp6hdr_old", "\t\t\t&icmp6hdr", " sizeoficmp6hdr", " 0"]}, {"opVar": "\t\tsum ", "inpVar": [" opts_old", " sizeofopts_old", " opts", " sizeofopts", " 0"]}], "l4_csum_replace": [{"opVar": "NA", "inpVar": ["\tif ctx", " csum_off", " 0", " sum", " BPF_F_PSEUDO_HDR < 0\t\treturn DROP_CSUM_L4"]}, {"opVar": "NA", "inpVar": ["\tif ctx", " csum_off", " 0", " sum", " BPF_F_PSEUDO_HDR < 0\t\treturn DROP_CSUM_L4"]}]}}}], "compute_icmp6_csum": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/icmp6.h", "startLine": "234", "endLine": "244", "capability": {"capabilities": [{"capability": "read_skb", "read_skb": [{"Project": "cilium", "Return Type": "s64", "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ", "Return": " The checksum result, or a negative error code in case of failure.", "Function Name": "csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"]}]}], "helperCallParams": {"csum_diff": [{"opVar": "\t\tsum ", "inpVar": [" NULL", " 0", " data", " payload_len", " 0"]}]}}}], "__icmp6_send_time_exceeded": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/icmp6.h", "startLine": "247", "endLine": "327", "capability": {"capabilities": [{"capability": "update_pkt", "update_pkt": [{"Project": "cilium", "Return Type": "int", "Description": "Recompute the layer 4 (e. g. TCP , UDP or ICMP) checksum for the packet associated <[ to ]>(IP: 3) skb. Computation is incremental , so the helper must know the former value of the header field that was modified (from) , the new value of this field (to) , and the number of bytes (2 or 4) for this field , stored on the lowest four bits of flags. Alternatively , it is possible <[ to ]>(IP: 3) store the difference between the previous and the new values of the header field in <[ to ]>(IP: 3) , by setting <[ from ]>(IP: 2) and the four lowest bits of <[ flags ]>(IP: 4) <[ to ]>(IP: 3) 0. For both methods , <[ offset ]>(IP: 1) indicates the location of the IP checksum within the packet. In addition <[ to ]>(IP: 3) the size of the field , <[ flags ]>(IP: 4) can be added (bitwise OR) actual flags. With BPF_F_MARK_MANGLED_0 , a null checksum is left untouched (unless BPF_F_MARK_ENFORCE is added as well) , and for updates resulting in a null checksum the value is set <[ to ]>(IP: 3) CSUM_MANGLED_0 instead. Flag BPF_F_PSEUDO_HDR indicates the checksum is <[ to ]>(IP: 3) be computed against a pseudo-header. This helper works in combination with csum_diff() , which does not update the checksum in-place , but offers more flexibility and can handle sizes larger than 2 or 4 for the checksum <[ to ]>(IP: 3) update. A call <[ to ]>(IP: 3) this helper is susceptible <[ to ]>(IP: 3) change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "l4_csum_replace", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  u32 ,Var: offset}", "{Type:  u64 ,Var: from}", "{Type:  u64 ,Var: to}", "{Type:  u64 ,Var: flags}"]}]}], "helperCallParams": {"l4_csum_replace": [{"opVar": "NA", "inpVar": ["\t\tif ctx", " csum_off", " 0", " sum", " BPF_F_PSEUDO_HDR < 0\t\treturn DROP_CSUM_L4"]}]}}}], "tail_icmp6_send_time_exceeded": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/icmp6.h", "startLine": "332", "endLine": "347", "capability": {"capabilities": [], "helperCallParams": {}}}], "icmp6_send_time_exceeded": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/icmp6.h", "startLine": "359", "endLine": "368", "capability": {"capabilities": [], "helperCallParams": {"tail_call": [{"opVar": "NA", "inpVar": ["\tep_ctx", " CILIUM_CALL_SEND_ICMP6_TIME_EXCEEDED"]}]}}}], "__icmp6_handle_ns": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/icmp6.h", "startLine": "370", "endLine": "398", "capability": {"capabilities": [], "helperCallParams": {}}}], "tail_icmp6_handle_ns": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/icmp6.h", "startLine": "402", "endLine": "412", "capability": {"capabilities": [], "helperCallParams": {}}}], "icmp6_handle_ns": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/icmp6.h", "startLine": "425", "endLine": "434", "capability": {"capabilities": [], "helperCallParams": {"tail_call": [{"opVar": "NA", "inpVar": ["\tep_ctx", " CILIUM_CALL_HANDLE_ICMP6_NS"]}]}}}], "icmp6_handle": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/icmp6.h", "startLine": "436", "endLine": "458", "capability": {"capabilities": [], "helperCallParams": {}}}], "icmp6_host_handle": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/icmp6.h", "startLine": "460", "endLine": "531", "capability": {"capabilities": [], "helperCallParams": {}}}], "lb4_svc_is_loadbalancer": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "192", "endLine": "196", "capability": {"capabilities": [], "helperCallParams": {}}}], "lb6_svc_is_loadbalancer": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "198", "endLine": "202", "capability": {"capabilities": [], "helperCallParams": {}}}], "lb4_svc_is_nodeport": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "204", "endLine": "212", "capability": {"capabilities": [], "helperCallParams": {}}}], "lb6_svc_is_nodeport": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "214", "endLine": "222", "capability": {"capabilities": [], "helperCallParams": {}}}], "lb4_svc_is_external_ip": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "224", "endLine": "228", "capability": {"capabilities": [], "helperCallParams": {}}}], "lb6_svc_is_external_ip": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "230", "endLine": "234", "capability": {"capabilities": [], "helperCallParams": {}}}], "lb4_svc_is_hostport": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "236", "endLine": "240", "capability": {"capabilities": [], "helperCallParams": {}}}], "lb6_svc_is_hostport": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "242", "endLine": "246", "capability": {"capabilities": [], "helperCallParams": {}}}], "lb4_svc_has_src_range_check": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "248", "endLine": "256", "capability": {"capabilities": [], "helperCallParams": {}}}], "lb6_svc_has_src_range_check": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "258", "endLine": "266", "capability": {"capabilities": [], "helperCallParams": {}}}], "lb_skip_l4_dnat": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "268", "endLine": "271", "capability": {"capabilities": [], "helperCallParams": {}}}], "lb4_svc_is_local_scope": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "273", "endLine": "277", "capability": {"capabilities": [], "helperCallParams": {}}}], "lb6_svc_is_local_scope": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "279", "endLine": "283", "capability": {"capabilities": [], "helperCallParams": {}}}], "lb4_svc_is_affinity": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "285", "endLine": "289", "capability": {"capabilities": [], "helperCallParams": {}}}], "lb6_svc_is_affinity": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "291", "endLine": "295", "capability": {"capabilities": [], "helperCallParams": {}}}], "__lb_svc_is_routable": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "297", "endLine": "300", "capability": {"capabilities": [], "helperCallParams": {}}}], "lb4_svc_is_routable": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "302", "endLine": "306", "capability": {"capabilities": [], "helperCallParams": {}}}], "lb6_svc_is_routable": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "308", "endLine": "312", "capability": {"capabilities": [], "helperCallParams": {}}}], "lb4_svc_is_localredirect": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "314", "endLine": "318", "capability": {"capabilities": [], "helperCallParams": {"redirect": [{"opVar": "NA", "inpVar": ["bool lb4_svc_is_localconst struct lb4_service *svc"]}]}}}], "lb4_svc_is_l7loadbalancer": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "320", "endLine": "328", "capability": {"capabilities": [], "helperCallParams": {}}}], "lb6_svc_is_l7loadbalancer": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "330", "endLine": "338", "capability": {"capabilities": [], "helperCallParams": {}}}], "extract_l4_port": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "340", "endLine": "380", "capability": {"capabilities": [], "helperCallParams": {}}}], "reverse_map_l4_port": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "382", "endLine": "416", "capability": {"capabilities": [], "helperCallParams": {}}}], "__lb6_rev_nat": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "419", "endLine": "459", "capability": {"capabilities": [{"capability": "read_skb", "read_skb": [{"Project": "cilium", "Return Type": "s64", "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ", "Return": " The checksum result, or a negative error code in case of failure.", "Function Name": "csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"]}]}], "helperCallParams": {"csum_diff": [{"opVar": "\tsum ", "inpVar": [" old_saddr.addr", " 16", " new_saddr", " 16", " 0"]}]}}}], "lb6_rev_nat": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "470", "endLine": "482", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"map_lookup_elem": [{"opVar": "\tnat ", "inpVar": [" &LB6_REVERSE_NAT_MAP", " &index"]}]}}}], "lb6_extract_key": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "500", "endLine": "516", "capability": {"capabilities": [], "helperCallParams": {}}}], "lb6_src_range_ok": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "518", "endLine": "541", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"map_lookup_elem": [{"opVar": "NA", "inpVar": ["\tif &LB6_SRC_RANGE_MAP", " &key\t\treturn true"]}]}}}], "lb6_to_lb4_service": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "543", "endLine": "551", "capability": {"capabilities": [], "helperCallParams": {}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "991", "endLine": "995", "capability": {"capabilities": [], "helperCallParams": {}}}], "*lb6_lookup_service": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "553", "endLine": "573", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"map_lookup_elem": [{"opVar": "\tsvc ", "inpVar": [" &LB6_SERVICES_MAP_V2", " key"]}, {"opVar": "\t\tsvc ", "inpVar": [" &LB6_SERVICES_MAP_V2", " key"]}]}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "972", "endLine": "977", "capability": {"capabilities": [], "helperCallParams": {}}}], "*__lb6_lookup_backend": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "575", "endLine": "578", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"map_lookup_elem": [{"opVar": "NA", "inpVar": ["\treturn &LB6_BACKEND_MAP_V2", " &backend_id"]}]}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "985", "endLine": "989", "capability": {"capabilities": [], "helperCallParams": {}}}], "*lb6_lookup_backend": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "580", "endLine": "590", "capability": {"capabilities": [], "helperCallParams": {}}}], "*__lb6_lookup_backend_slot": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "592", "endLine": "596", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"map_lookup_elem": [{"opVar": "NA", "inpVar": ["\treturn &LB6_SERVICES_MAP_V2", " key"]}]}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "979", "endLine": "983", "capability": {"capabilities": [], "helperCallParams": {}}}], "*lb6_lookup_backend_slot": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "598", "endLine": "613", "capability": {"capabilities": [], "helperCallParams": {}}}], "lb6_select_backend_id": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "617", "endLine": "627", "capability": {"capabilities": [{"capability": "read_sys_info", "read_sys_info": [{"Project": "cilium", "Return Type": "u32", "Description": "Get a pseudo-random number. From a security point of view , this helper uses its own pseudo-random internal state , and cannot be used to infer the seed of other random functions in the kernel. However , it is essential to note that the generator used by the helper is not cryptographically secure. ", "Return": " A random 32-bit unsigned value.", "Function Name": "get_prandom_u32", "Input Params": ["{Type: voi ,Var: void}"]}]}], "helperCallParams": {"get_prandom_u32": [{"opVar": "\t__u16 slot ", "inpVar": ["  % svc->count + 1"]}]}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "629", "endLine": "649", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"map_lookup_elem": [{"opVar": "\tmaglev_lut ", "inpVar": [" &LB6_MAGLEV_MAP_OUTER", " &index"]}, {"opVar": "\tbackend_ids ", "inpVar": [" maglev_lut", " &zero"]}]}}}], "lb6_xlate": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "654", "endLine": "689", "capability": {"capabilities": [{"capability": "read_skb", "read_skb": [{"Project": "cilium", "Return Type": "s64", "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ", "Return": " The checksum result, or a negative error code in case of failure.", "Function Name": "csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"]}]}], "helperCallParams": {"csum_diff": [{"opVar": "\t\t__be32 sum ", "inpVar": [" key->address.addr", " 16", " new_dst->addr", "\t\t\t\t       16", " 0"]}]}}}], "__lb6_affinity_backend_id": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "692", "endLine": "728", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}, {"capability": "map_update", "map_update": [{"Project": "cilium", "Return Type": "int", "Description": "Delete entry with <[ key ]>(IP: 1) from map. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "map_delete_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"map_lookup_elem": [{"opVar": "\tval ", "inpVar": [" &LB6_AFFINITY_MAP", " &key"]}, {"opVar": "NA", "inpVar": ["\t\t\t\tif !&LB_AFFINITY_MATCH_MAP", " &match "]}], "map_delete_elem": [{"opVar": "NA", "inpVar": ["\t\t\t&LB6_AFFINITY_MAP", " &key"]}, {"opVar": "NA", "inpVar": ["\t\t\t&LB6_AFFINITY_MAP", " &key"]}]}}}], "lb6_affinity_backend_id_by_addr": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "730", "endLine": "735", "capability": {"capabilities": [], "helperCallParams": {}}}], "__lb6_update_affinity": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "737", "endLine": "754", "capability": {"capabilities": [{"capability": "map_update", "map_update": [{"Project": "cilium", "Return Type": "int", "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "map_update_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}", "{Type:  const void ,Var: *value}", "{Type:  u64 ,Var: flags}"]}]}], "helperCallParams": {"map_update_elem": [{"opVar": "NA", "inpVar": ["\t&LB6_AFFINITY_MAP", " &key", " &val", " 0"]}]}}}], "lb6_update_affinity_by_addr": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "756", "endLine": "761", "capability": {"capabilities": [], "helperCallParams": {}}}], "lb6_affinity_backend_id_by_netns": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "764", "endLine": "773", "capability": {"capabilities": [], "helperCallParams": {}}}], "lb6_update_affinity_by_netns": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "775", "endLine": "783", "capability": {"capabilities": [], "helperCallParams": {}}}], "lb6_to_lb4": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "785", "endLine": "799", "capability": {"capabilities": [], "helperCallParams": {}}}], "lb6_local": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "801", "endLine": "926", "capability": {"capabilities": [], "helperCallParams": {}}}], "lb6_ctx_store_state": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "935", "endLine": "942", "capability": {"capabilities": [], "helperCallParams": {}}}], "lb6_ctx_restore_state": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "949", "endLine": "965", "capability": {"capabilities": [], "helperCallParams": {}}}], "__lb4_rev_nat": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "999", "endLine": "1066", "capability": {"capabilities": [{"capability": "read_skb", "read_skb": [{"Project": "cilium", "Return Type": "s64", "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ", "Return": " The checksum result, or a negative error code in case of failure.", "Function Name": "csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"]}]}, {"capability": "update_pkt", "update_pkt": [{"Project": "cilium", "Return Type": "int", "Description": "Recompute the layer 3 (e. g. IP) checksum for the packet associated <[ to ]>(IP: 3) skb. Computation is incremental , so the helper must know the former value of the header field that was modified (from) , the new value of this field (to) , and the number of bytes (2 or 4) for this field , stored in size. Alternatively , it is possible <[ to ]>(IP: 3) store the difference between the previous and the new values of the header field in <[ to ]>(IP: 3) , by setting <[ from ]>(IP: 2) and <[ size ]>(IP: 4) <[ to ]>(IP: 3) 0. For both methods , <[ offset ]>(IP: 1) indicates the location of the IP checksum within the packet. This helper works in combination with csum_diff() , which does not update the checksum in-place , but offers more flexibility and can handle sizes larger than 2 or 4 for the checksum <[ to ]>(IP: 3) update. A call <[ to ]>(IP: 3) this helper is susceptible <[ to ]>(IP: 3) change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "l3_csum_replace", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  u32 ,Var: offset}", "{Type:  u64 ,Var: from}", "{Type:  u64 ,Var: to}", "{Type:  u64 ,Var: size}"]}]}], "helperCallParams": {"csum_diff": [{"opVar": "\t\tsum ", "inpVar": [" &old_dip", " 4", " &old_sip", " 4", " 0"]}, {"opVar": "\tsum ", "inpVar": [" &old_sip", " 4", " &new_sip", " 4", " sum"]}], "l3_csum_replace": [{"opVar": "NA", "inpVar": ["\tif ctx", " l3_off + offsetofstruct iphdr", " check", " 0", " sum", " 0 < 0\t\treturn DROP_CSUM_L3"]}]}}}], "lb4_rev_nat": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "1078", "endLine": "1092", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"map_lookup_elem": [{"opVar": "\tnat ", "inpVar": [" &LB4_REVERSE_NAT_MAP", " &ct_state->rev_nat_index"]}]}}}], "lb4_extract_key": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "1107", "endLine": "1121", "capability": {"capabilities": [], "helperCallParams": {}}}], "lb4_src_range_ok": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "1123", "endLine": "1146", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"map_lookup_elem": [{"opVar": "NA", "inpVar": ["\tif &LB4_SRC_RANGE_MAP", " &key\t\treturn true"]}]}}}], "lb4_populate_ports": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "1148", "endLine": "1164", "capability": {"capabilities": [], "helperCallParams": {}}}], "lb4_to_lb6_service": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "1166", "endLine": "1174", "capability": {"capabilities": [], "helperCallParams": {}}}], "*lb4_lookup_service": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "1176", "endLine": "1197", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"map_lookup_elem": [{"opVar": "\tsvc ", "inpVar": [" &LB4_SERVICES_MAP_V2", " key"]}, {"opVar": "\t\tsvc ", "inpVar": [" &LB4_SERVICES_MAP_V2", " key"]}]}}}], "*__lb4_lookup_backend": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "1199", "endLine": "1202", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"map_lookup_elem": [{"opVar": "NA", "inpVar": ["\treturn &LB4_BACKEND_MAP_V2", " &backend_id"]}]}}}], "*lb4_lookup_backend": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "1204", "endLine": "1214", "capability": {"capabilities": [], "helperCallParams": {}}}], "*__lb4_lookup_backend_slot": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "1216", "endLine": "1220", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"map_lookup_elem": [{"opVar": "NA", "inpVar": ["\treturn &LB4_SERVICES_MAP_V2", " key"]}]}}}], "*lb4_lookup_backend_slot": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "1222", "endLine": "1237", "capability": {"capabilities": [], "helperCallParams": {}}}], "lb4_select_backend_id": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "1241", "endLine": "1251", "capability": {"capabilities": [{"capability": "read_sys_info", "read_sys_info": [{"Project": "cilium", "Return Type": "u32", "Description": "Get a pseudo-random number. From a security point of view , this helper uses its own pseudo-random internal state , and cannot be used to infer the seed of other random functions in the kernel. However , it is essential to note that the generator used by the helper is not cryptographically secure. ", "Return": " A random 32-bit unsigned value.", "Function Name": "get_prandom_u32", "Input Params": ["{Type: voi ,Var: void}"]}]}], "helperCallParams": {"get_prandom_u32": [{"opVar": "\t__u16 slot ", "inpVar": ["  % svc->count + 1"]}]}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "1253", "endLine": "1273", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"map_lookup_elem": [{"opVar": "\tmaglev_lut ", "inpVar": [" &LB4_MAGLEV_MAP_OUTER", " &index"]}, {"opVar": "\tbackend_ids ", "inpVar": [" maglev_lut", " &zero"]}]}}}], "lb4_xlate": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "1278", "endLine": "1332", "capability": {"capabilities": [{"capability": "read_skb", "read_skb": [{"Project": "cilium", "Return Type": "s64", "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ", "Return": " The checksum result, or a negative error code in case of failure.", "Function Name": "csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"]}]}, {"capability": "update_pkt", "update_pkt": [{"Project": "cilium", "Return Type": "int", "Description": "Recompute the layer 3 (e. g. IP) checksum for the packet associated <[ to ]>(IP: 3) skb. Computation is incremental , so the helper must know the former value of the header field that was modified (from) , the new value of this field (to) , and the number of bytes (2 or 4) for this field , stored in size. Alternatively , it is possible <[ to ]>(IP: 3) store the difference between the previous and the new values of the header field in <[ to ]>(IP: 3) , by setting <[ from ]>(IP: 2) and <[ size ]>(IP: 4) <[ to ]>(IP: 3) 0. For both methods , <[ offset ]>(IP: 1) indicates the location of the IP checksum within the packet. This helper works in combination with csum_diff() , which does not update the checksum in-place , but offers more flexibility and can handle sizes larger than 2 or 4 for the checksum <[ to ]>(IP: 3) update. A call <[ to ]>(IP: 3) this helper is susceptible <[ to ]>(IP: 3) change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "l3_csum_replace", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  u32 ,Var: offset}", "{Type:  u64 ,Var: from}", "{Type:  u64 ,Var: to}", "{Type:  u64 ,Var: size}"]}]}], "helperCallParams": {"csum_diff": [{"opVar": "\tsum ", "inpVar": [" &key->address", " 4", " new_daddr", " 4", " 0"]}, {"opVar": "\t\tsum ", "inpVar": [" old_saddr", " 4", " new_saddr", " 4", " sum"]}], "l3_csum_replace": [{"opVar": "NA", "inpVar": ["\t#endif \tif ctx", " l3_off + offsetofstruct iphdr", " check", "\t\t\t    0", " sum", " 0 < 0\t\treturn DROP_CSUM_L3"]}]}}}], "__lb4_affinity_backend_id": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "1335", "endLine": "1375", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}, {"capability": "map_update", "map_update": [{"Project": "cilium", "Return Type": "int", "Description": "Delete entry with <[ key ]>(IP: 1) from map. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "map_delete_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"map_lookup_elem": [{"opVar": "\tval ", "inpVar": [" &LB4_AFFINITY_MAP", " &key"]}, {"opVar": "NA", "inpVar": ["\t\t\t\tif !&LB_AFFINITY_MATCH_MAP", " &match "]}], "map_delete_elem": [{"opVar": "NA", "inpVar": ["\t\t\t&LB4_AFFINITY_MAP", " &key"]}, {"opVar": "NA", "inpVar": ["\t\t\t&LB4_AFFINITY_MAP", " &key"]}]}}}], "lb4_affinity_backend_id_by_addr": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "1377", "endLine": "1382", "capability": {"capabilities": [], "helperCallParams": {}}}], "__lb4_update_affinity": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "1384", "endLine": "1401", "capability": {"capabilities": [{"capability": "map_update", "map_update": [{"Project": "cilium", "Return Type": "int", "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "map_update_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}", "{Type:  const void ,Var: *value}", "{Type:  u64 ,Var: flags}"]}]}], "helperCallParams": {"map_update_elem": [{"opVar": "NA", "inpVar": ["\t&LB4_AFFINITY_MAP", " &key", " &val", " 0"]}]}}}], "lb4_update_affinity_by_addr": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "1403", "endLine": "1408", "capability": {"capabilities": [], "helperCallParams": {}}}], "lb4_affinity_backend_id_by_netns": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "1411", "endLine": "1420", "capability": {"capabilities": [], "helperCallParams": {}}}], "lb4_update_affinity_by_netns": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "1422", "endLine": "1430", "capability": {"capabilities": [], "helperCallParams": {}}}], "lb4_to_lb6": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "1432", "endLine": "1447", "capability": {"capabilities": [], "helperCallParams": {}}}], "lb4_local": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "1449", "endLine": "1604", "capability": {"capabilities": [], "helperCallParams": {}}}], "lb4_ctx_store_state": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "1613", "endLine": "1621", "capability": {"capabilities": [], "helperCallParams": {}}}], "lb4_ctx_restore_state": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/lb.h", "startLine": "1628", "endLine": "1651", "capability": {"capabilities": [], "helperCallParams": {}}}], "arp_check": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/arp.h", "startLine": "21", "endLine": "30", "capability": {"capabilities": [], "helperCallParams": {}}}], "arp_prepare_response": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/arp.h", "startLine": "32", "endLine": "49", "capability": {"capabilities": [], "helperCallParams": {}}}], "arp_validate": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/arp.h", "startLine": "51", "endLine": "73", "capability": {"capabilities": [], "helperCallParams": {}}}], "arp_respond": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/arp.h", "startLine": "75", "endLine": "90", "capability": {"capabilities": [], "helperCallParams": {"redirect": [{"opVar": "NA", "inpVar": ["\treturn ctx_ctx", " ctx_get_ifindexctx", " direction"]}]}}}], "csum_l4_offset_and_flags": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/csum.h", "startLine": "29", "endLine": "49", "capability": {"capabilities": [], "helperCallParams": {}}}], "csum_l4_replace": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/csum.h", "startLine": "60", "endLine": "65", "capability": {"capabilities": [{"capability": "update_pkt", "update_pkt": [{"Project": "cilium", "Return Type": "int", "Description": "Recompute the layer 4 (e. g. TCP , UDP or ICMP) checksum for the packet associated <[ to ]>(IP: 3) skb. Computation is incremental , so the helper must know the former value of the header field that was modified (from) , the new value of this field (to) , and the number of bytes (2 or 4) for this field , stored on the lowest four bits of flags. Alternatively , it is possible <[ to ]>(IP: 3) store the difference between the previous and the new values of the header field in <[ to ]>(IP: 3) , by setting <[ from ]>(IP: 2) and the four lowest bits of <[ flags ]>(IP: 4) <[ to ]>(IP: 3) 0. For both methods , <[ offset ]>(IP: 1) indicates the location of the IP checksum within the packet. In addition <[ to ]>(IP: 3) the size of the field , <[ flags ]>(IP: 4) can be added (bitwise OR) actual flags. With BPF_F_MARK_MANGLED_0 , a null checksum is left untouched (unless BPF_F_MARK_ENFORCE is added as well) , and for updates resulting in a null checksum the value is set <[ to ]>(IP: 3) CSUM_MANGLED_0 instead. Flag BPF_F_PSEUDO_HDR indicates the checksum is <[ to ]>(IP: 3) be computed against a pseudo-header. This helper works in combination with csum_diff() , which does not update the checksum in-place , but offers more flexibility and can handle sizes larger than 2 or 4 for the checksum <[ to ]>(IP: 3) update. A call <[ to ]>(IP: 3) this helper is susceptible <[ to ]>(IP: 3) change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "l4_csum_replace", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  u32 ,Var: offset}", "{Type:  u64 ,Var: from}", "{Type:  u64 ,Var: to}", "{Type:  u64 ,Var: flags}"]}]}], "helperCallParams": {"l4_csum_replace": [{"opVar": "NA", "inpVar": ["\treturn ctx", " l4_off + csum->offset", " from", " to", " flags | csum->flags"]}]}}}], "policy_verdict_filter_allow": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/policy_log.h", "startLine": "39", "endLine": "47", "capability": {"capabilities": [], "helperCallParams": {}}}], "send_policy_verdict_notify": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/policy_log.h", "startLine": "49", "endLine": "77", "capability": {"capabilities": [], "helperCallParams": {}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/policy_log.h", "startLine": "79", "endLine": "86", "capability": {"capabilities": [], "helperCallParams": {}}}], "eth_addrcmp": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/eth.h", "startLine": "25", "endLine": "35", "capability": {"capabilities": [], "helperCallParams": {}}}], "eth_is_bcast": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/eth.h", "startLine": "37", "endLine": "48", "capability": {"capabilities": [], "helperCallParams": {}}}], "eth_load_saddr": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/eth.h", "startLine": "50", "endLine": "54", "capability": {"capabilities": [], "helperCallParams": {}}}], "eth_store_saddr_aligned": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/eth.h", "startLine": "56", "endLine": "60", "capability": {"capabilities": [], "helperCallParams": {}}}], "eth_store_saddr": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/eth.h", "startLine": "62", "endLine": "79", "capability": {"capabilities": [], "helperCallParams": {}}}], "eth_load_daddr": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/eth.h", "startLine": "81", "endLine": "85", "capability": {"capabilities": [], "helperCallParams": {}}}], "eth_store_daddr_aligned": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/eth.h", "startLine": "87", "endLine": "91", "capability": {"capabilities": [], "helperCallParams": {}}}], "eth_store_daddr": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/eth.h", "startLine": "93", "endLine": "110", "capability": {"capabilities": [], "helperCallParams": {}}}], "eth_store_proto": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/eth.h", "startLine": "112", "endLine": "117", "capability": {"capabilities": [], "helperCallParams": {}}}], "is_v4_in_v6": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nat_46x64.h", "startLine": "22", "endLine": "35", "capability": {"capabilities": [], "helperCallParams": {}}}], "build_v4_in_v6": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nat_46x64.h", "startLine": "37", "endLine": "44", "capability": {"capabilities": [], "helperCallParams": {}}}], "build_v4_from_v6": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nat_46x64.h", "startLine": "46", "endLine": "50", "capability": {"capabilities": [], "helperCallParams": {}}}], "get_csum_offset": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nat_46x64.h", "startLine": "52", "endLine": "74", "capability": {"capabilities": [], "helperCallParams": {}}}], "icmp4_to_icmp6": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nat_46x64.h", "startLine": "76", "endLine": "154", "capability": {"capabilities": [{"capability": "read_skb", "read_skb": [{"Project": "cilium", "Return Type": "s64", "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ", "Return": " The checksum result, or a negative error code in case of failure.", "Function Name": "csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"]}]}], "helperCallParams": {"csum_diff": [{"opVar": "NA", "inpVar": ["\treturn &icmp4", " sizeoficmp4", " &icmp6", " sizeoficmp6", " 0"]}]}}}], "icmp6_to_icmp4": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nat_46x64.h", "startLine": "156", "endLine": "231", "capability": {"capabilities": [{"capability": "read_skb", "read_skb": [{"Project": "cilium", "Return Type": "s64", "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ", "Return": " The checksum result, or a negative error code in case of failure.", "Function Name": "csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"]}]}], "helperCallParams": {"csum_diff": [{"opVar": "NA", "inpVar": ["\treturn &icmp6", " sizeoficmp6", " &icmp4", " sizeoficmp4", " 0"]}]}}}], "ipv4_to_ipv6": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nat_46x64.h", "startLine": "233", "endLine": "288", "capability": {"capabilities": [{"capability": "read_skb", "read_skb": [{"Project": "cilium", "Return Type": "s64", "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ", "Return": " The checksum result, or a negative error code in case of failure.", "Function Name": "csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"]}]}, {"capability": "update_pkt", "update_pkt": [{"Project": "cilium", "Return Type": "int", "Description": "Recompute the layer 4 (e. g. TCP , UDP or ICMP) checksum for the packet associated <[ to ]>(IP: 3) skb. Computation is incremental , so the helper must know the former value of the header field that was modified (from) , the new value of this field (to) , and the number of bytes (2 or 4) for this field , stored on the lowest four bits of flags. Alternatively , it is possible <[ to ]>(IP: 3) store the difference between the previous and the new values of the header field in <[ to ]>(IP: 3) , by setting <[ from ]>(IP: 2) and the four lowest bits of <[ flags ]>(IP: 4) <[ to ]>(IP: 3) 0. For both methods , <[ offset ]>(IP: 1) indicates the location of the IP checksum within the packet. In addition <[ to ]>(IP: 3) the size of the field , <[ flags ]>(IP: 4) can be added (bitwise OR) actual flags. With BPF_F_MARK_MANGLED_0 , a null checksum is left untouched (unless BPF_F_MARK_ENFORCE is added as well) , and for updates resulting in a null checksum the value is set <[ to ]>(IP: 3) CSUM_MANGLED_0 instead. Flag BPF_F_PSEUDO_HDR indicates the checksum is <[ to ]>(IP: 3) be computed against a pseudo-header. This helper works in combination with csum_diff() , which does not update the checksum in-place , but offers more flexibility and can handle sizes larger than 2 or 4 for the checksum <[ to ]>(IP: 3) update. A call <[ to ]>(IP: 3) this helper is susceptible <[ to ]>(IP: 3) change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "l4_csum_replace", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  u32 ,Var: offset}", "{Type:  u64 ,Var: from}", "{Type:  u64 ,Var: to}", "{Type:  u64 ,Var: flags}"]}]}], "helperCallParams": {"csum_diff": [{"opVar": "\t\tcsum ", "inpVar": [" &v4.saddr", " 4", " &v6.saddr", " 16", " csum"]}, {"opVar": "\t\tcsum ", "inpVar": [" &v4.daddr", " 4", " &v6.daddr", " 16", " csum"]}], "l4_csum_replace": [{"opVar": "NA", "inpVar": ["\tif ctx", " nh_off + csum_off", " 0", " csum", " csum_flags < 0\t\treturn DROP_CSUM_L4"]}]}}}], "ipv6_to_ipv4": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nat_46x64.h", "startLine": "290", "endLine": "345", "capability": {"capabilities": [{"capability": "read_skb", "read_skb": [{"Project": "cilium", "Return Type": "s64", "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ", "Return": " The checksum result, or a negative error code in case of failure.", "Function Name": "csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"]}]}, {"capability": "update_pkt", "update_pkt": [{"Project": "cilium", "Return Type": "int", "Description": "Recompute the layer 4 (e. g. TCP , UDP or ICMP) checksum for the packet associated <[ to ]>(IP: 3) skb. Computation is incremental , so the helper must know the former value of the header field that was modified (from) , the new value of this field (to) , and the number of bytes (2 or 4) for this field , stored on the lowest four bits of flags. Alternatively , it is possible <[ to ]>(IP: 3) store the difference between the previous and the new values of the header field in <[ to ]>(IP: 3) , by setting <[ from ]>(IP: 2) and the four lowest bits of <[ flags ]>(IP: 4) <[ to ]>(IP: 3) 0. For both methods , <[ offset ]>(IP: 1) indicates the location of the IP checksum within the packet. In addition <[ to ]>(IP: 3) the size of the field , <[ flags ]>(IP: 4) can be added (bitwise OR) actual flags. With BPF_F_MARK_MANGLED_0 , a null checksum is left untouched (unless BPF_F_MARK_ENFORCE is added as well) , and for updates resulting in a null checksum the value is set <[ to ]>(IP: 3) CSUM_MANGLED_0 instead. Flag BPF_F_PSEUDO_HDR indicates the checksum is <[ to ]>(IP: 3) be computed against a pseudo-header. This helper works in combination with csum_diff() , which does not update the checksum in-place , but offers more flexibility and can handle sizes larger than 2 or 4 for the checksum <[ to ]>(IP: 3) update. A call <[ to ]>(IP: 3) this helper is susceptible <[ to ]>(IP: 3) change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "l4_csum_replace", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  u32 ,Var: offset}", "{Type:  u64 ,Var: from}", "{Type:  u64 ,Var: to}", "{Type:  u64 ,Var: flags}"]}, {"Project": "cilium", "Return Type": "int", "Description": "Recompute the layer 3 (e. g. IP) checksum for the packet associated <[ to ]>(IP: 3) skb. Computation is incremental , so the helper must know the former value of the header field that was modified (from) , the new value of this field (to) , and the number of bytes (2 or 4) for this field , stored in size. Alternatively , it is possible <[ to ]>(IP: 3) store the difference between the previous and the new values of the header field in <[ to ]>(IP: 3) , by setting <[ from ]>(IP: 2) and <[ size ]>(IP: 4) <[ to ]>(IP: 3) 0. For both methods , <[ offset ]>(IP: 1) indicates the location of the IP checksum within the packet. This helper works in combination with csum_diff() , which does not update the checksum in-place , but offers more flexibility and can handle sizes larger than 2 or 4 for the checksum <[ to ]>(IP: 3) update. A call <[ to ]>(IP: 3) this helper is susceptible <[ to ]>(IP: 3) change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "l3_csum_replace", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  u32 ,Var: offset}", "{Type:  u64 ,Var: from}", "{Type:  u64 ,Var: to}", "{Type:  u64 ,Var: size}"]}]}], "helperCallParams": {"csum_diff": [{"opVar": "\tcsum ", "inpVar": [" NULL", " 0", " &v4", " sizeofv4", " csum"]}, {"opVar": "\t\tcsum ", "inpVar": [" &v6.saddr", " 16", " &v4.saddr", " 4", " csum"]}, {"opVar": "\t\tcsum ", "inpVar": [" &v6.daddr", " 16", " &v4.daddr", " 4", " csum"]}], "l3_csum_replace": [{"opVar": "NA", "inpVar": ["\tif ctx", " nh_off + csum_off", " 0", " csum", " 0 < 0\t\treturn DROP_CSUM_L3"]}], "l4_csum_replace": [{"opVar": "NA", "inpVar": ["\tif ctx", " nh_off + csum_off", " 0", " csum", " csum_flags < 0\t\treturn DROP_CSUM_L4"]}]}}}], "__snat_clamp_port_range": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "startLine": "51", "endLine": "55", "capability": {"capabilities": [], "helperCallParams": {}}}], "__snat_try_keep_port": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "startLine": "57", "endLine": "62", "capability": {"capabilities": [{"capability": "read_sys_info", "read_sys_info": [{"Project": "cilium", "Return Type": "u32", "Description": "Get a pseudo-random number. From a security point of view , this helper uses its own pseudo-random internal state , and cannot be used to infer the seed of other random functions in the kernel. However , it is essential to note that the generator used by the helper is not cryptographically secure. ", "Return": " A random 32-bit unsigned value.", "Function Name": "get_prandom_u32", "Input Params": ["{Type: voi ,Var: void}"]}]}], "helperCallParams": {"get_prandom_u32": [{"opVar": "\treturn val >", "inpVar": [" start && val <"]}]}}}], "*__snat_lookup": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "startLine": "64", "endLine": "68", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"map_lookup_elem": [{"opVar": "NA", "inpVar": ["\treturn map", " tuple"]}]}}}], "__snat_update": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "startLine": "70", "endLine": "83", "capability": {"capabilities": [{"capability": "map_update", "map_update": [{"Project": "cilium", "Return Type": "int", "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "map_update_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}", "{Type:  const void ,Var: *value}", "{Type:  u64 ,Var: flags}"]}, {"Project": "cilium", "Return Type": "int", "Description": "Delete entry with <[ key ]>(IP: 1) from map. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "map_delete_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"map_update_elem": [{"opVar": "\tret ", "inpVar": [" map", " rtuple", " rstate", " BPF_NOEXIST"]}, {"opVar": "\t\tret ", "inpVar": [" map", " otuple", " ostate", " BPF_NOEXIST"]}], "map_delete_elem": [{"opVar": "NA", "inpVar": ["\t\tif ret\t\t\tmap", " rtuple"]}]}}}], "__snat_delete": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "startLine": "85", "endLine": "90", "capability": {"capabilities": [{"capability": "map_update", "map_update": [{"Project": "cilium", "Return Type": "int", "Description": "Delete entry with <[ key ]>(IP: 1) from map. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "map_delete_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"map_delete_elem": [{"opVar": "NA", "inpVar": ["\tmap", " otuple"]}, {"opVar": "NA", "inpVar": ["\tmap", " rtuple"]}]}}}], "*snat_v4_lookup": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "startLine": "136", "endLine": "140", "capability": {"capabilities": [], "helperCallParams": {}}}], "snat_v4_update": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "startLine": "142", "endLine": "149", "capability": {"capabilities": [], "helperCallParams": {}}}], "snat_v4_delete": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "startLine": "151", "endLine": "155", "capability": {"capabilities": [], "helperCallParams": {}}}], "snat_v4_swap_tuple": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "startLine": "157", "endLine": "168", "capability": {"capabilities": [], "helperCallParams": {}}}], "snat_v4_reverse_tuple": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "startLine": "170", "endLine": "183", "capability": {"capabilities": [], "helperCallParams": {}}}], "snat_v4_ct_canonicalize": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "startLine": "185", "endLine": "193", "capability": {"capabilities": [], "helperCallParams": {}}}], "snat_v4_delete_tuples": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "startLine": "195", "endLine": "204", "capability": {"capabilities": [], "helperCallParams": {}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "startLine": "583", "endLine": "586", "capability": {"capabilities": [], "helperCallParams": {}}}], "snat_v4_new_mapping": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "startLine": "206", "endLine": "258", "capability": {"capabilities": [{"capability": "read_sys_info", "read_sys_info": [{"Project": "cilium", "Return Type": "u32", "Description": "Get a pseudo-random number. From a security point of view , this helper uses its own pseudo-random internal state , and cannot be used to infer the seed of other random functions in the kernel. However , it is essential to note that the generator used by the helper is not cryptographically secure. ", "Return": " A random 32-bit unsigned value.", "Function Name": "get_prandom_u32", "Input Params": ["{Type: voi ,Var: void}"]}]}], "helperCallParams": {"get_prandom_u32": [{"opVar": "\t\t\t\tport ", "inpVar": [" __snat_clamp_port_rangetarget->min_port", "\t\t\t\t\t       target->max_port", "\t\t\t\t\t       retries ? port + 1 :\t\t\t\t\t       __u16"]}], "send_signal": [{"opVar": "NA", "inpVar": ["\t\tif retries > SNAT_SIGNAL_THRES\t\t_nat_fill_upctx", " SIGNAL_PROTO_V4"]}]}}}], "snat_v4_track_local": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "startLine": "260", "endLine": "299", "capability": {"capabilities": [], "helperCallParams": {}}}], "snat_v4_handle_mapping": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "startLine": "301", "endLine": "322", "capability": {"capabilities": [], "helperCallParams": {}}}], "snat_v4_rewrite_egress": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "startLine": "324", "endLine": "380", "capability": {"capabilities": [{"capability": "read_skb", "read_skb": [{"Project": "cilium", "Return Type": "s64", "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ", "Return": " The checksum result, or a negative error code in case of failure.", "Function Name": "csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"]}]}, {"capability": "update_pkt", "update_pkt": [{"Project": "cilium", "Return Type": "int", "Description": "Recompute the layer 3 (e. g. IP) checksum for the packet associated <[ to ]>(IP: 3) skb. Computation is incremental , so the helper must know the former value of the header field that was modified (from) , the new value of this field (to) , and the number of bytes (2 or 4) for this field , stored in size. Alternatively , it is possible <[ to ]>(IP: 3) store the difference between the previous and the new values of the header field in <[ to ]>(IP: 3) , by setting <[ from ]>(IP: 2) and <[ size ]>(IP: 4) <[ to ]>(IP: 3) 0. For both methods , <[ offset ]>(IP: 1) indicates the location of the IP checksum within the packet. This helper works in combination with csum_diff() , which does not update the checksum in-place , but offers more flexibility and can handle sizes larger than 2 or 4 for the checksum <[ to ]>(IP: 3) update. A call <[ to ]>(IP: 3) this helper is susceptible <[ to ]>(IP: 3) change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "l3_csum_replace", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  u32 ,Var: offset}", "{Type:  u64 ,Var: from}", "{Type:  u64 ,Var: to}", "{Type:  u64 ,Var: size}"]}]}], "helperCallParams": {"csum_diff": [{"opVar": "\tsum ", "inpVar": [" &tuple->saddr", " 4", " &state->to_saddr", " 4", " 0"]}, {"opVar": " \t\t\t\tsum_l4 ", "inpVar": [" &from", " 4", " &to", " 4", " 0"]}], "l3_csum_replace": [{"opVar": "NA", "inpVar": ["\tif ctx", " ETH_HLEN + offsetofstruct iphdr", " check", "\t\t\t    0", " sum", " 0 < 0\t\treturn DROP_CSUM_L3"]}]}}}], "snat_v4_rewrite_ingress": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "startLine": "382", "endLine": "435", "capability": {"capabilities": [{"capability": "read_skb", "read_skb": [{"Project": "cilium", "Return Type": "s64", "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ", "Return": " The checksum result, or a negative error code in case of failure.", "Function Name": "csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"]}]}, {"capability": "update_pkt", "update_pkt": [{"Project": "cilium", "Return Type": "int", "Description": "Recompute the layer 3 (e. g. IP) checksum for the packet associated <[ to ]>(IP: 3) skb. Computation is incremental , so the helper must know the former value of the header field that was modified (from) , the new value of this field (to) , and the number of bytes (2 or 4) for this field , stored in size. Alternatively , it is possible <[ to ]>(IP: 3) store the difference between the previous and the new values of the header field in <[ to ]>(IP: 3) , by setting <[ from ]>(IP: 2) and <[ size ]>(IP: 4) <[ to ]>(IP: 3) 0. For both methods , <[ offset ]>(IP: 1) indicates the location of the IP checksum within the packet. This helper works in combination with csum_diff() , which does not update the checksum in-place , but offers more flexibility and can handle sizes larger than 2 or 4 for the checksum <[ to ]>(IP: 3) update. A call <[ to ]>(IP: 3) this helper is susceptible <[ to ]>(IP: 3) change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "l3_csum_replace", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  u32 ,Var: offset}", "{Type:  u64 ,Var: from}", "{Type:  u64 ,Var: to}", "{Type:  u64 ,Var: size}"]}]}], "helperCallParams": {"csum_diff": [{"opVar": "\tsum ", "inpVar": [" &tuple->daddr", " 4", " &state->to_daddr", " 4", " 0"]}, {"opVar": " \t\t\tsum_l4 ", "inpVar": [" &from", " 4", " &to", " 4", " 0"]}], "l3_csum_replace": [{"opVar": "NA", "inpVar": ["\tif ctx", " ETH_HLEN + offsetofstruct iphdr", " check", "\t\t\t    0", " sum", " 0 < 0\t\treturn DROP_CSUM_L3"]}]}}}], "snat_v4_can_skip": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "startLine": "437", "endLine": "452", "capability": {"capabilities": [], "helperCallParams": {}}}], "snat_v4_create_dsr": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "startLine": "454", "endLine": "505", "capability": {"capabilities": [{"capability": "map_update", "map_update": [{"Project": "cilium", "Return Type": "int", "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "map_update_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}", "{Type:  const void ,Var: *value}", "{Type:  u64 ,Var: flags}"]}]}], "helperCallParams": {"map_update_elem": [{"opVar": "\tret ", "inpVar": [" &SNAT_MAPPING_IPV4", " &tuple", " &state", " 0"]}]}}}], "snat_v4_process": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "startLine": "507", "endLine": "572", "capability": {"capabilities": [], "helperCallParams": {}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "startLine": "574", "endLine": "581", "capability": {"capabilities": [], "helperCallParams": {}}}], "*snat_v6_lookup": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "startLine": "622", "endLine": "626", "capability": {"capabilities": [], "helperCallParams": {}}}], "snat_v6_update": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "startLine": "628", "endLine": "635", "capability": {"capabilities": [], "helperCallParams": {}}}], "snat_v6_delete": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "startLine": "637", "endLine": "641", "capability": {"capabilities": [], "helperCallParams": {}}}], "snat_v6_swap_tuple": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "startLine": "643", "endLine": "654", "capability": {"capabilities": [], "helperCallParams": {}}}], "snat_v6_reverse_tuple": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "startLine": "656", "endLine": "669", "capability": {"capabilities": [], "helperCallParams": {}}}], "snat_v6_ct_canonicalize": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "startLine": "671", "endLine": "680", "capability": {"capabilities": [], "helperCallParams": {}}}], "snat_v6_delete_tuples": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "startLine": "682", "endLine": "691", "capability": {"capabilities": [], "helperCallParams": {}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "startLine": "1064", "endLine": "1067", "capability": {"capabilities": [], "helperCallParams": {}}}], "snat_v6_new_mapping": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "startLine": "693", "endLine": "745", "capability": {"capabilities": [{"capability": "read_sys_info", "read_sys_info": [{"Project": "cilium", "Return Type": "u32", "Description": "Get a pseudo-random number. From a security point of view , this helper uses its own pseudo-random internal state , and cannot be used to infer the seed of other random functions in the kernel. However , it is essential to note that the generator used by the helper is not cryptographically secure. ", "Return": " A random 32-bit unsigned value.", "Function Name": "get_prandom_u32", "Input Params": ["{Type: voi ,Var: void}"]}]}], "helperCallParams": {"get_prandom_u32": [{"opVar": "\t\t\t\tport ", "inpVar": [" __snat_clamp_port_rangetarget->min_port", "\t\t\t\t\t       target->max_port", "\t\t\t\t\t       retries ? port + 1 :\t\t\t\t\t       __u16"]}], "send_signal": [{"opVar": "NA", "inpVar": ["\t\tif retries > SNAT_SIGNAL_THRES\t\t_nat_fill_upctx", " SIGNAL_PROTO_V6"]}]}}}], "snat_v6_track_local": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "startLine": "747", "endLine": "785", "capability": {"capabilities": [], "helperCallParams": {}}}], "snat_v6_handle_mapping": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "startLine": "787", "endLine": "808", "capability": {"capabilities": [], "helperCallParams": {}}}], "snat_v6_rewrite_egress": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "startLine": "810", "endLine": "855", "capability": {"capabilities": [{"capability": "read_skb", "read_skb": [{"Project": "cilium", "Return Type": "s64", "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ", "Return": " The checksum result, or a negative error code in case of failure.", "Function Name": "csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"]}]}], "helperCallParams": {"csum_diff": [{"opVar": "\tsum ", "inpVar": [" &tuple->saddr", " 16", " &state->to_saddr", " 16", " 0"]}, {"opVar": "\t\t\tsum ", "inpVar": [" &from", " 4", " &to", " 4", " sum"]}]}}}], "snat_v6_rewrite_ingress": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "startLine": "857", "endLine": "904", "capability": {"capabilities": [{"capability": "read_skb", "read_skb": [{"Project": "cilium", "Return Type": "s64", "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ", "Return": " The checksum result, or a negative error code in case of failure.", "Function Name": "csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"]}]}], "helperCallParams": {"csum_diff": [{"opVar": "\tsum ", "inpVar": [" &tuple->daddr", " 16", " &state->to_daddr", " 16", " 0"]}, {"opVar": "\t\t\tsum ", "inpVar": [" &from", " 4", " &to", " 4", " sum"]}]}}}], "snat_v6_can_skip": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "startLine": "906", "endLine": "920", "capability": {"capabilities": [], "helperCallParams": {}}}], "snat_v6_create_dsr": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "startLine": "922", "endLine": "977", "capability": {"capabilities": [{"capability": "map_update", "map_update": [{"Project": "cilium", "Return Type": "int", "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "map_update_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}", "{Type:  const void ,Var: *value}", "{Type:  u64 ,Var: flags}"]}]}], "helperCallParams": {"map_update_elem": [{"opVar": "\tret ", "inpVar": [" &SNAT_MAPPING_IPV6", " &tuple", " &state", " 0"]}]}}}], "snat_v6_process": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "startLine": "979", "endLine": "1054", "capability": {"capabilities": [], "helperCallParams": {}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "startLine": "1056", "endLine": "1062", "capability": {"capabilities": [], "helperCallParams": {}}}], "snat_v6_has_v4_match": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "startLine": "1070", "endLine": "1088", "capability": {"capabilities": [], "helperCallParams": {}}}], "ct_delete4": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "startLine": "1090", "endLine": "1100", "capability": {"capabilities": [{"capability": "map_update", "map_update": [{"Project": "cilium", "Return Type": "int", "Description": "Delete entry with <[ key ]>(IP: 1) from map. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "map_delete_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"map_delete_elem": [{"opVar": "\terr ", "inpVar": [" map", " tuple"]}, {"opVar": "NA", "inpVar": ["\tif err < 0\t\tcilium_dbgctx", " DBG_ERROR_RET", " BPF_FUNC_", " err"]}]}}}], "ct_delete6": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/nat.h", "startLine": "1102", "endLine": "1112", "capability": {"capabilities": [{"capability": "map_update", "map_update": [{"Project": "cilium", "Return Type": "int", "Description": "Delete entry with <[ key ]>(IP: 1) from map. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "map_delete_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"map_delete_elem": [{"opVar": "\terr ", "inpVar": [" map", " tuple"]}, {"opVar": "NA", "inpVar": ["\tif err < 0\t\tcilium_dbgctx", " DBG_ERROR_RET", " BPF_FUNC_", " err"]}]}}}], "hash_32": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/ghash.h", "startLine": "31", "endLine": "35", "capability": {"capabilities": [], "helperCallParams": {}}}], "hash_64": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/lib/ghash.h", "startLine": "37", "endLine": "40", "capability": {"capabilities": [], "helperCallParams": {}}}], "custom_prog": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/custom/bytecount.h", "startLine": "11", "endLine": "24", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}, {"capability": "map_update", "map_update": [{"Project": "cilium", "Return Type": "int", "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "map_update_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}", "{Type:  const void ,Var: *value}", "{Type:  u64 ,Var: flags}"]}]}], "helperCallParams": {"map_lookup_elem": [{"opVar": "\tbytecount ", "inpVar": [" &bytecount_map", " &identity"]}], "map_update_elem": [{"opVar": "NA", "inpVar": ["\telse\t\t\t\t&bytecount_map", " &identity", " &len", " BPF_ANY"]}]}}}], "__fswab16": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/linux/swab.h", "startLine": "46", "endLine": "55", "capability": {"capabilities": [], "helperCallParams": {}}}], "__fswab32": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/linux/swab.h", "startLine": "57", "endLine": "66", "capability": {"capabilities": [], "helperCallParams": {}}}], "__fswab64": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/linux/swab.h", "startLine": "68", "endLine": "81", "capability": {"capabilities": [], "helperCallParams": {}}}], "__fswahw32": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/linux/swab.h", "startLine": "83", "endLine": "90", "capability": {"capabilities": [], "helperCallParams": {}}}], "__fswahb32": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/linux/swab.h", "startLine": "92", "endLine": "99", "capability": {"capabilities": [], "helperCallParams": {}}}], "__swab16p": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/linux/swab.h", "startLine": "154", "endLine": "161", "capability": {"capabilities": [], "helperCallParams": {}}}], "__swab32p": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/linux/swab.h", "startLine": "167", "endLine": "174", "capability": {"capabilities": [], "helperCallParams": {}}}], "__swab64p": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/linux/swab.h", "startLine": "180", "endLine": "187", "capability": {"capabilities": [], "helperCallParams": {}}}], "__swahw32p": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/linux/swab.h", "startLine": "195", "endLine": "202", "capability": {"capabilities": [], "helperCallParams": {}}}], "__swahb32p": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/linux/swab.h", "startLine": "210", "endLine": "217", "capability": {"capabilities": [], "helperCallParams": {}}}], "__swab16s": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/linux/swab.h", "startLine": "223", "endLine": "230", "capability": {"capabilities": [], "helperCallParams": {}}}], "__swab32s": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/linux/swab.h", "startLine": "235", "endLine": "242", "capability": {"capabilities": [], "helperCallParams": {}}}], "__swab64s": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/linux/swab.h", "startLine": "248", "endLine": "255", "capability": {"capabilities": [], "helperCallParams": {}}}], "__swahw32s": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/linux/swab.h", "startLine": "263", "endLine": "270", "capability": {"capabilities": [], "helperCallParams": {}}}], "__swahb32s": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/linux/swab.h", "startLine": "278", "endLine": "285", "capability": {"capabilities": [], "helperCallParams": {}}}], "__cpu_to_le64p": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/big_endian.h", "startLine": "45", "endLine": "48", "capability": {"capabilities": [], "helperCallParams": {}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/little_endian.h", "startLine": "45", "endLine": "48", "capability": {"capabilities": [], "helperCallParams": {}}}], "__le64_to_cpup": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/big_endian.h", "startLine": "49", "endLine": "52", "capability": {"capabilities": [], "helperCallParams": {}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/little_endian.h", "startLine": "49", "endLine": "52", "capability": {"capabilities": [], "helperCallParams": {}}}], "__cpu_to_le32p": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/big_endian.h", "startLine": "53", "endLine": "56", "capability": {"capabilities": [], "helperCallParams": {}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/little_endian.h", "startLine": "53", "endLine": "56", "capability": {"capabilities": [], "helperCallParams": {}}}], "__le32_to_cpup": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/big_endian.h", "startLine": "57", "endLine": "60", "capability": {"capabilities": [], "helperCallParams": {}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/little_endian.h", "startLine": "57", "endLine": "60", "capability": {"capabilities": [], "helperCallParams": {}}}], "__cpu_to_le16p": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/big_endian.h", "startLine": "61", "endLine": "64", "capability": {"capabilities": [], "helperCallParams": {}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/little_endian.h", "startLine": "61", "endLine": "64", "capability": {"capabilities": [], "helperCallParams": {}}}], "__le16_to_cpup": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/big_endian.h", "startLine": "65", "endLine": "68", "capability": {"capabilities": [], "helperCallParams": {}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/little_endian.h", "startLine": "65", "endLine": "68", "capability": {"capabilities": [], "helperCallParams": {}}}], "__cpu_to_be64p": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/big_endian.h", "startLine": "69", "endLine": "72", "capability": {"capabilities": [], "helperCallParams": {}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/little_endian.h", "startLine": "69", "endLine": "72", "capability": {"capabilities": [], "helperCallParams": {}}}], "__be64_to_cpup": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/big_endian.h", "startLine": "73", "endLine": "76", "capability": {"capabilities": [], "helperCallParams": {}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/little_endian.h", "startLine": "73", "endLine": "76", "capability": {"capabilities": [], "helperCallParams": {}}}], "__cpu_to_be32p": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/big_endian.h", "startLine": "77", "endLine": "80", "capability": {"capabilities": [], "helperCallParams": {}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/little_endian.h", "startLine": "77", "endLine": "80", "capability": {"capabilities": [], "helperCallParams": {}}}], "__be32_to_cpup": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/big_endian.h", "startLine": "81", "endLine": "84", "capability": {"capabilities": [], "helperCallParams": {}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/little_endian.h", "startLine": "81", "endLine": "84", "capability": {"capabilities": [], "helperCallParams": {}}}], "__cpu_to_be16p": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/big_endian.h", "startLine": "85", "endLine": "88", "capability": {"capabilities": [], "helperCallParams": {}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/little_endian.h", "startLine": "85", "endLine": "88", "capability": {"capabilities": [], "helperCallParams": {}}}], "__be16_to_cpup": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/big_endian.h", "startLine": "89", "endLine": "92", "capability": {"capabilities": [], "helperCallParams": {}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/linux/byteorder/little_endian.h", "startLine": "89", "endLine": "92", "capability": {"capabilities": [], "helperCallParams": {}}}], "__bpf_memset_builtin": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/builtins.h", "startLine": "38", "endLine": "45", "capability": {"capabilities": [], "helperCallParams": {}}}], "__bpf_memzero": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/builtins.h", "startLine": "47", "endLine": "126", "capability": {"capabilities": [], "helperCallParams": {}}}], "__bpf_no_builtin_memset": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/builtins.h", "startLine": "128", "endLine": "133", "capability": {"capabilities": [], "helperCallParams": {}}}], "memset": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/builtins.h", "startLine": "138", "endLine": "145", "capability": {"capabilities": [], "helperCallParams": {}}}], "__bpf_memcpy_builtin": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/builtins.h", "startLine": "147", "endLine": "152", "capability": {"capabilities": [], "helperCallParams": {}}}], "__bpf_memcpy": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/builtins.h", "startLine": "154", "endLine": "239", "capability": {"capabilities": [], "helperCallParams": {}}}], "__bpf_no_builtin_memcpy": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/builtins.h", "startLine": "241", "endLine": "246", "capability": {"capabilities": [], "helperCallParams": {}}}], "memcpy": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/builtins.h", "startLine": "251", "endLine": "255", "capability": {"capabilities": [], "helperCallParams": {}}}], "__bpf_memcmp_builtin": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/builtins.h", "startLine": "257", "endLine": "270", "capability": {"capabilities": [], "helperCallParams": {}}}], "__bpf_memcmp": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/builtins.h", "startLine": "272", "endLine": "345", "capability": {"capabilities": [], "helperCallParams": {}}}], "__bpf_no_builtin_memcmp": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/builtins.h", "startLine": "347", "endLine": "353", "capability": {"capabilities": [], "helperCallParams": {}}}], "memcmp": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/builtins.h", "startLine": "361", "endLine": "366", "capability": {"capabilities": [], "helperCallParams": {}}}], "__bpf_memmove_builtin": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/builtins.h", "startLine": "368", "endLine": "373", "capability": {"capabilities": [], "helperCallParams": {}}}], "__bpf_memmove_bwd": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/builtins.h", "startLine": "375", "endLine": "379", "capability": {"capabilities": [], "helperCallParams": {}}}], "__bpf_memmove_fwd": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/builtins.h", "startLine": "381", "endLine": "458", "capability": {"capabilities": [], "helperCallParams": {}}}], "__bpf_no_builtin_memmove": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/builtins.h", "startLine": "460", "endLine": "465", "capability": {"capabilities": [], "helperCallParams": {}}}], "__bpf_memmove": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/builtins.h", "startLine": "470", "endLine": "485", "capability": {"capabilities": [], "helperCallParams": {}}}], "memmove": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/builtins.h", "startLine": "487", "endLine": "492", "capability": {"capabilities": [], "helperCallParams": {}}}], "tail_call_static": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/tailcall.h", "startLine": "10", "endLine": "33", "capability": {"capabilities": [], "helperCallParams": {"tail_call": [{"opVar": "NA", "inpVar": ["_staticconst struct __ctx_buff *ctx", " const void *map", "\t\t const __u32 slot"]}]}}}], "tail_call_dynamic": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/tailcall.h", "startLine": "35", "endLine": "46", "capability": {"capabilities": [], "helperCallParams": {"tail_call": [{"opVar": "NA", "inpVar": ["_dynamicstruct __ctx_buff *ctx", " const void *map", " __u32 slot"]}, {"opVar": "NA", "inpVar": ["\t\tctx", " map", " slot"]}]}}}], "relax_verifier": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/verifier.h", "startLine": "13", "endLine": "18", "capability": {"capabilities": [{"capability": "read_sys_info", "read_sys_info": [{"Project": "cilium", "Return Type": "u32", "Description": "Get the SMP (symmetric multiprocessing) processor id. Note that all programs run with preemption disabled , which means that the SMP processor id is stable during all the execution of the program. ", "Return": " The SMP id of the processor running the program.", "Function Name": "get_smp_processor_id", "Input Params": ["{Type: voi ,Var: void}"]}]}], "helperCallParams": {"get_smp_processor_id": [{"opVar": "#ifndef HAVE_LARGE_INSN_LIMIT       volatile int __maybe_unused id ", "inpVar": [" "]}]}}}], "map_array_get_32": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/access.h", "startLine": "10", "endLine": "33", "capability": {"capabilities": [], "helperCallParams": {}}}], "csum_fold": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/csum.h", "startLine": "10", "endLine": "15", "capability": {"capabilities": [], "helperCallParams": {}}}], "csum_unfold": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/csum.h", "startLine": "17", "endLine": "20", "capability": {"capabilities": [], "helperCallParams": {}}}], "csum_add": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/csum.h", "startLine": "22", "endLine": "26", "capability": {"capabilities": [], "helperCallParams": {}}}], "csum_sub": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/csum.h", "startLine": "28", "endLine": "31", "capability": {"capabilities": [], "helperCallParams": {}}}], "csum_diff": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/csum.h", "startLine": "33", "endLine": "52", "capability": {"capabilities": [{"capability": "read_skb", "read_skb": [{"Project": "cilium", "Return Type": "s64", "Description": "Compute a checksum difference , <[ from ]>(IP: 0) the raw buffer pointed by <[ from ]>(IP: 0) , of length <[ from_size ]>(IP: 1) (that must be a multiple of 4) , towards the raw buffer pointed by <[ to ]>(IP: 2) , of size <[ to_size ]>(IP: 3) (same remark). An optional <[ seed ]>(IP: 4) can be added <[ to ]>(IP: 2) the value (this can be cascaded , the <[ seed ]>(IP: 4) may come <[ from ]>(IP: 0) a previous call <[ to ]>(IP: 2) the helper). This is flexible enough <[ to ]>(IP: 2) be used in several ways: \u00b7 With <[ from_size ]>(IP: 1) == 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when pushing new data. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) == 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) checksum , it can be used when removing data <[ from ]>(IP: 0) a packet. \u00b7 With <[ from_size ]>(IP: 1) > 0 , <[ to_size ]>(IP: 3) > 0 and <[ seed ]>(IP: 4) set <[ to ]>(IP: 2) 0 , it can be used <[ to ]>(IP: 2) compute a diff. Note that <[ from_size ]>(IP: 1) and <[ to_size ]>(IP: 3) do not need <[ to ]>(IP: 2) be equal. This helper can be used in combination with l3_csum_replace() and l4_csum_replace() , <[ to ]>(IP: 2) which one can feed in the difference computed with csum_diff(). ", "Return": " The checksum result, or a negative error code in case of failure.", "Function Name": "csum_diff", "Input Params": ["{Type: __be32 ,Var: *from}", "{Type:  u32 ,Var: from_size}", "{Type:  __be32 ,Var: *to}", "{Type:  u32 ,Var: to_size}", "{Type:  __wsum ,Var: seed}"]}]}], "helperCallParams": {"csum_diff": [{"opVar": "NA", "inpVar": ["\t\treturn _externalfrom", " size_from", " to", " size_to", " seed"]}]}}}], "bpf_barrier": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/compiler.h", "startLine": "86", "endLine": "93", "capability": {"capabilities": [], "helperCallParams": {}}}], "ctx_redirect": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/skb.h", "startLine": "60", "endLine": "64", "capability": {"capabilities": [], "helperCallParams": {"redirect": [{"opVar": "NA", "inpVar": ["ctx_const struct __sk_buff *ctx __maybe_unused", " int ifindex", " __u32 flags"]}, {"opVar": "NA", "inpVar": ["\treturn ifindex", " flags"]}]}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/xdp.h", "startLine": "291", "endLine": "298", "capability": {"capabilities": [], "helperCallParams": {"redirect": [{"opVar": "NA", "inpVar": ["ctx_const struct xdp_md *ctx", " int ifindex", " const __u32 flags"]}, {"opVar": "NA", "inpVar": ["\treturn ifindex", " flags"]}]}}}], "ctx_redirect_peer": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/skb.h", "startLine": "66", "endLine": "70", "capability": {"capabilities": [], "helperCallParams": {"redirect": [{"opVar": "NA", "inpVar": ["ctx__peerconst struct __sk_buff *ctx __maybe_unused", " int ifindex", " __u32 flags"]}, {"opVar": "NA", "inpVar": ["\treturn _peerifindex", " flags"]}]}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/xdp.h", "startLine": "300", "endLine": "307", "capability": {"capabilities": [], "helperCallParams": {"redirect": [{"opVar": "NA", "inpVar": ["ctx__peerconst struct xdp_md *ctx __maybe_unused", "\t\t  int ifindex __maybe_unused", "\t\t  const __u32 flags __maybe_unused"]}]}}}], "ctx_adjust_troom": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/skb.h", "startLine": "72", "endLine": "76", "capability": {"capabilities": [{"capability": "update_pkt", "update_pkt": [{"Project": "cilium", "Return Type": "int", "Description": "Resize (trim or grow) the packet associated to <[ skb ]>(IP: 0) to the new len. The <[ flags ]>(IP: 2) are reserved for future usage , and must be left at zero. The basic idea is that the helper performs the needed work to change the size of the packet , then the eBPF program rewrites the rest via helpers like skb_store_bytes() , l3_csum_replace() , l3_csum_replace() and others. This helper is a slow path utility intended for replies with control messages. And because it is targeted for slow path , the helper itself can afford to be slow: it implicitly linearizes , unclones and drops offloads from the skb. A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "skb_change_tail", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  u32 ,Var: len}", "{Type:  u64 ,Var: flags}"]}]}], "helperCallParams": {"skb_change_tail": [{"opVar": "NA", "inpVar": ["\treturn ctx", " ctx->len + len_diff", " 0"]}]}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/xdp.h", "startLine": "236", "endLine": "240", "capability": {"capabilities": [{"capability": "update_pkt", "update_pkt": [{"Project": "cilium", "Return Type": "int", "Description": "Adjust (move) xdp_md->data_end by <[ delta ]>(IP: 1) bytes. It is only possible to shrink the packet as of this writing , therefore <[ delta ]>(IP: 1) must be a negative integer. A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "xdp_adjust_tail", "Input Params": ["{Type: struct xdp_buff ,Var: *xdp_md}", "{Type:  int ,Var: delta}"]}]}], "helperCallParams": {"xdp_adjust_tail": [{"opVar": "NA", "inpVar": ["\treturn ctx", " len_diff"]}]}}}], "ctx_full_len": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/skb.h", "startLine": "78", "endLine": "82", "capability": {"capabilities": [], "helperCallParams": {}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/xdp.h", "startLine": "309", "endLine": "314", "capability": {"capabilities": [], "helperCallParams": {}}}], "ctx_wire_len": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/skb.h", "startLine": "84", "endLine": "88", "capability": {"capabilities": [], "helperCallParams": {}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/xdp.h", "startLine": "316", "endLine": "320", "capability": {"capabilities": [], "helperCallParams": {}}}], "ctx_store_meta": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/skb.h", "startLine": "90", "endLine": "94", "capability": {"capabilities": [], "helperCallParams": {}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/xdp.h", "startLine": "330", "endLine": "338", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"map_lookup_elem": [{"opVar": "\t__u32 zero ", "inpVar": [" 0", " *data_meta "]}]}}}], "ctx_load_meta": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/skb.h", "startLine": "96", "endLine": "100", "capability": {"capabilities": [], "helperCallParams": {}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/xdp.h", "startLine": "340", "endLine": "349", "capability": {"capabilities": [{"capability": "map_read", "map_read": [{"Project": "cilium", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "map_lookup_elem", "Input Params": ["{Type: struct map ,Var: *map}", "{Type:  const void ,Var: *key}"]}]}], "helperCallParams": {"map_lookup_elem": [{"opVar": "\t__u32 zero ", "inpVar": [" 0", " *data_meta "]}]}}}], "ctx_get_protocol": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/skb.h", "startLine": "102", "endLine": "106", "capability": {"capabilities": [], "helperCallParams": {}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/xdp.h", "startLine": "351", "endLine": "361", "capability": {"capabilities": [], "helperCallParams": {}}}], "ctx_get_ifindex": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/skb.h", "startLine": "108", "endLine": "112", "capability": {"capabilities": [], "helperCallParams": {}}}, {"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/xdp.h", "startLine": "363", "endLine": "367", "capability": {"capabilities": [], "helperCallParams": {}}}], "*ctx_data": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/common.h", "startLine": "16", "endLine": "19", "capability": {"capabilities": [], "helperCallParams": {}}}], "*ctx_data_meta": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/common.h", "startLine": "21", "endLine": "24", "capability": {"capabilities": [], "helperCallParams": {}}}], "*ctx_data_end": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/common.h", "startLine": "26", "endLine": "29", "capability": {"capabilities": [], "helperCallParams": {}}}], "ctx_no_room": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/common.h", "startLine": "31", "endLine": "34", "capability": {"capabilities": [], "helperCallParams": {}}}], "xdp_load_bytes": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/xdp.h", "startLine": "34", "endLine": "60", "capability": {"capabilities": [], "helperCallParams": {}}}], "xdp_store_bytes": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/xdp.h", "startLine": "62", "endLine": "86", "capability": {"capabilities": [], "helperCallParams": {}}}], "__csum_replace_by_diff": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/xdp.h", "startLine": "110", "endLine": "114", "capability": {"capabilities": [], "helperCallParams": {}}}], "__csum_replace_by_4": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/xdp.h", "startLine": "116", "endLine": "120", "capability": {"capabilities": [], "helperCallParams": {}}}], "l3_csum_replace": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/xdp.h", "startLine": "122", "endLine": "154", "capability": {"capabilities": [{"capability": "update_pkt", "update_pkt": [{"Project": "cilium", "Return Type": "int", "Description": "Recompute the layer 3 (e. g. IP) checksum for the packet associated <[ to ]>(IP: 3) skb. Computation is incremental , so the helper must know the former value of the header field that was modified (from) , the new value of this field (to) , and the number of bytes (2 or 4) for this field , stored in size. Alternatively , it is possible <[ to ]>(IP: 3) store the difference between the previous and the new values of the header field in <[ to ]>(IP: 3) , by setting <[ from ]>(IP: 2) and <[ size ]>(IP: 4) <[ to ]>(IP: 3) 0. For both methods , <[ offset ]>(IP: 1) indicates the location of the IP checksum within the packet. This helper works in combination with csum_diff() , which does not update the checksum in-place , but offers more flexibility and can handle sizes larger than 2 or 4 for the checksum <[ to ]>(IP: 3) update. A call <[ to ]>(IP: 3) this helper is susceptible <[ to ]>(IP: 3) change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "l3_csum_replace", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  u32 ,Var: offset}", "{Type:  u64 ,Var: from}", "{Type:  u64 ,Var: to}", "{Type:  u64 ,Var: size}"]}]}], "helperCallParams": {"l3_csum_replace": [{"opVar": "NA", "inpVar": ["const struct xdp_md *ctx", " __u64 off", " const __u32 from", "\t\t__u32 to", "\t\t__u32 flags"]}]}}}], "l4_csum_replace": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/xdp.h", "startLine": "158", "endLine": "196", "capability": {"capabilities": [{"capability": "update_pkt", "update_pkt": [{"Project": "cilium", "Return Type": "int", "Description": "Recompute the layer 4 (e. g. TCP , UDP or ICMP) checksum for the packet associated <[ to ]>(IP: 3) skb. Computation is incremental , so the helper must know the former value of the header field that was modified (from) , the new value of this field (to) , and the number of bytes (2 or 4) for this field , stored on the lowest four bits of flags. Alternatively , it is possible <[ to ]>(IP: 3) store the difference between the previous and the new values of the header field in <[ to ]>(IP: 3) , by setting <[ from ]>(IP: 2) and the four lowest bits of <[ flags ]>(IP: 4) <[ to ]>(IP: 3) 0. For both methods , <[ offset ]>(IP: 1) indicates the location of the IP checksum within the packet. In addition <[ to ]>(IP: 3) the size of the field , <[ flags ]>(IP: 4) can be added (bitwise OR) actual flags. With BPF_F_MARK_MANGLED_0 , a null checksum is left untouched (unless BPF_F_MARK_ENFORCE is added as well) , and for updates resulting in a null checksum the value is set <[ to ]>(IP: 3) CSUM_MANGLED_0 instead. Flag BPF_F_PSEUDO_HDR indicates the checksum is <[ to ]>(IP: 3) be computed against a pseudo-header. This helper works in combination with csum_diff() , which does not update the checksum in-place , but offers more flexibility and can handle sizes larger than 2 or 4 for the checksum <[ to ]>(IP: 3) update. A call <[ to ]>(IP: 3) this helper is susceptible <[ to ]>(IP: 3) change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "l4_csum_replace", "Input Params": ["{Type: struct sk_buff ,Var: *skb}", "{Type:  u32 ,Var: offset}", "{Type:  u64 ,Var: from}", "{Type:  u64 ,Var: to}", "{Type:  u64 ,Var: flags}"]}]}], "helperCallParams": {"l4_csum_replace": [{"opVar": "NA", "inpVar": ["const struct xdp_md *ctx", " __u64 off", " __u32 from", " __u32 to", "\t\t__u32 flags"]}]}}}], "ctx_change_proto": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/xdp.h", "startLine": "198", "endLine": "234", "capability": {"capabilities": [{"capability": "update_pkt", "update_pkt": [{"Project": "cilium", "Return Type": "int", "Description": "Adjust (move) xdp_md->data by <[ delta ]>(IP: 1) bytes. Note that it is possible to use a negative value for delta. This helper can be used to prepare the packet for pushing or popping headers. A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "xdp_adjust_head", "Input Params": ["{Type: struct xdp_buff ,Var: *xdp_md}", "{Type:  int ,Var: delta}"]}]}], "helperCallParams": {"xdp_adjust_head": [{"opVar": "\t\tret ", "inpVar": [" ctx", " -len_diff"]}]}}}], "ctx_adjust_hroom": [{"fileName": "/home/sayandes/opened_extraction/examples/cilium/include/bpf/ctx/xdp.h", "startLine": "242", "endLine": "289", "capability": {"capabilities": [{"capability": "update_pkt", "update_pkt": [{"Project": "cilium", "Return Type": "int", "Description": "Adjust (move) xdp_md->data by <[ delta ]>(IP: 1) bytes. Note that it is possible to use a negative value for delta. This helper can be used to prepare the packet for pushing or popping headers. A call to this helper is susceptible to change the underlying packet buffer. Therefore , at load time , all checks on pointers previously done by the verifier are invalidated and must be performed again , if the helper is used in combination with direct packet access. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "xdp_adjust_head", "Input Params": ["{Type: struct xdp_buff ,Var: *xdp_md}", "{Type:  int ,Var: delta}"]}]}], "helperCallParams": {"xdp_adjust_head": [{"opVar": "\tret ", "inpVar": [" ctx", " -len_diff"]}]}}}]}