{"_default": {"1": {"capability": [{"capability": "read_sys_info", "read_sys_info": [{"Return Type": "int", "Description": "For tracing programs , safely attempt to read <[ size ]>(IP: 1) bytes from address <[ src ]>(IP: 2) and store the data in dst. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_probe_read", "Input Params": ["{Type: void ,Var: *dst}", "{Type:  u32 ,Var: size}", "{Type:  const void ,Var: *src}"]}, {"Return Type": "u64", "Return": " A 64-bit integer containing the current tgid and pid, and created  as  such:                     current_task->tgid << 32 | current_task->pid.", "Function Name": "bpf_get_current_pid_tgid", "Input Params": ["{Type: voi ,Var: void}"], "Description": "A 64-bit integer containing the current tgid and pid , and created as such: current_task->tgid << 32 | current_task->pid. "}]}], "helperCallParams": {"bpf_get_current_pid_tgid": [{"opVar": "    u64 pid_tgid ", "inpVar": [" "]}], "bpf_probe_read": [{"opVar": "NA", "inpVar": ["    data->pkt", " data_len", " iodata"]}]}, "startLine": 24, "endLine": 51, "File": "/root/examples/bcc/undump.c", "funcName": "trace_unix_stream_read_actor", "updateMaps": [], "readMaps": [], "input": ["struct pt_regs *ctx"], "output": "int", "helper": ["bpf_probe_read", "bpf_get_current_pid_tgid"], "compatibleHookpoints": ["raw_tracepoint", "perf_event", "raw_tracepoint_writable", "kprobe", "tracepoint"], "humanFuncDescription": [{"description": "The structure 'recv_data_t' stores the length of the receive data in a variable named 'recv_len' of type u32 and the array 'pkt' store the received packet data which is of type u8. The array 'pkt' can store maximum 512B of data. BPF_PERCPU_ARRAY(unix_data, struct recv_data_t, 1) creates creates per_cpu_array map with a single element where key is of type int and value recv_data_t.BPF_PERF_OUTPUT(unix_recv_events) Creates a BPF table named 'unix_recv_events' for pushing out custom event data to user space via a perf ring buffer, When there is an incoming UNIX packet received on a socket, this fucntion is invoked to trace the packet data. If a particular process id is given it traces the data received by that process. When the recieve event occurs, it push the context and data to the perf buffer 'unix_recv_event'.The function also allows tracing data only for specific pids.", "author": "Utkalika", "authorEmail": "utkalika.satapathy01@gmail.com", "date": "19.01.2023"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "2": {"capability": [{"capability": "read_sys_info", "read_sys_info": [{"Return Type": "u64", "Description": "Return the time elapsed since system boot , in nanoseconds. ", "Return": " Current ktime.", "Function Name": "bpf_ktime_get_ns", "Input Params": ["{Type: voi ,Var: void}"]}]}], "helperCallParams": {"bpf_ktime_get_ns": [{"opVar": "        delta ", "inpVar": ["  - *tsp"]}, {"opVar": "            ts ", "inpVar": [" "]}], "bpf_trace_printk": [{"opVar": "NA", "inpVar": ["                        \"%d\\\\n\"", " delta / 1000000"]}]}, "startLine": 5, "endLine": 23, "File": "/root/examples/bcc/sync_timing.c", "funcName": "do_trace", "updateMaps": [], "readMaps": [], "input": ["struct pt_regs *ctx"], "output": "int", "helper": ["bpf_ktime_get_ns", "bpf_trace_printk"], "compatibleHookpoints": ["sock_ops", "sched_cls", "xdp", "lwt_seg6local", "cgroup_sock", "sk_reuseport", "perf_event", "lwt_xmit", "raw_tracepoint_writable", "lwt_out", "socket_filter", "raw_tracepoint", "sk_msg", "kprobe", "flow_dissector", "cgroup_skb", "sk_skb", "lwt_in", "tracepoint", "cgroup_sock_addr", "sched_act"], "humanFuncDescription": [{"description": " A BPF hash map named 'last' has created which store the timestamps.\n                       This function is invoked every time a system call 'sync' is made.\n                       It calculate the time difference between current timestamp and the last timestamp stored in the map,\n                       and store it variable 'delta' which indicates the time elapsed after that.\n                       If 'delta' is less than 1 nano second, then it is printed out to userspace.\n                       Once printed the value, that entry gets deleted from 'last' map and then the current timestamp is pushed to the map.", "author": "Utkalika Satapathy", "authorEmail": "utkalika.satapathy01@gmail.com", "date": "02.02.2023"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "3": {"capability": [], "helperCallParams": {"bpf_trace_printk": [{"opVar": "NA", "inpVar": ["  \"Hello", " World!\\\\n\""]}]}, "startLine": 1, "endLine": 4, "File": "/root/examples/bcc/trace_fields.c", "funcName": "hello", "updateMaps": [], "readMaps": [], "input": ["void *ctx"], "output": "int", "helper": ["bpf_trace_printk"], "compatibleHookpoints": ["sock_ops", "sched_cls", "cgroup_device", "xdp", "lwt_seg6local", "cgroup_sock", "sk_reuseport", "perf_event", "lwt_xmit", "raw_tracepoint_writable", "lwt_out", "socket_filter", "raw_tracepoint", "sk_msg", "kprobe", "flow_dissector", "cgroup_skb", "sk_skb", "lwt_in", "tracepoint", "cgroup_sock_addr", "sched_act", "cgroup_sysctl"], "humanFuncDescription": [{"description": "This prints out a trace line every time the clone system call is called.\n                      This will instrument the kernel sys_clone() function, which will then run the BPF defined hello() function each time it is called.", "author": "Utkalika Satapathy", "authorEmail": "utkalika.satapathy01@gmail.com", "date": "02.02.2023"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "4": {"capability": [], "helperCallParams": {}, "startLine": 8, "endLine": 12, "File": "/root/examples/bcc/nflatency.c", "funcName": "*skb_to_tcphdr", "updateMaps": [], "readMaps": [], "input": ["const struct sk_buff *skb"], "output": "staticstructtcphdr", "helper": [], "compatibleHookpoints": ["All_hookpoints"], "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "5": {"capability": [], "helperCallParams": {}, "startLine": 14, "endLine": 18, "File": "/root/examples/bcc/nflatency.c", "funcName": "*skb_to_iphdr", "updateMaps": [], "readMaps": [], "input": ["const struct sk_buff *skb"], "output": "staticinlinestructiphdr", "helper": [], "compatibleHookpoints": ["All_hookpoints"], "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "6": {"capability": [], "helperCallParams": {}, "startLine": 20, "endLine": 24, "File": "/root/examples/bcc/nflatency.c", "funcName": "*skb_to_ip6hdr", "updateMaps": [], "readMaps": [], "input": ["const struct sk_buff *skb"], "output": "staticinlinestructipv6hdr", "helper": [], "compatibleHookpoints": ["All_hookpoints"], "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "7": {"capability": [{"capability": "read_sys_info", "read_sys_info": [{"Return Type": "u64", "Description": "Return the time elapsed since system boot , in nanoseconds. ", "Return": " Current ktime.", "Function Name": "bpf_ktime_get_ns", "Input Params": ["{Type: voi ,Var: void}"]}]}], "helperCallParams": {"bpf_ktime_get_ns": [{"opVar": "    data.ts ", "inpVar": [" "]}]}, "startLine": 49, "endLine": 88, "File": "/root/examples/bcc/nflatency.c", "funcName": "kprobe__nf_hook_slow", "updateMaps": [], "readMaps": [], "input": ["struct pt_regs *ctx", " struct sk_buff *skb", " struct nf_hook_state *state"], "output": "int", "helper": ["bpf_ktime_get_ns"], "compatibleHookpoints": ["sock_ops", "sched_cls", "xdp", "lwt_seg6local", "cgroup_sock", "sk_reuseport", "perf_event", "lwt_xmit", "raw_tracepoint_writable", "lwt_out", "socket_filter", "raw_tracepoint", "sk_msg", "kprobe", "flow_dissector", "cgroup_skb", "sk_skb", "lwt_in", "tracepoint", "cgroup_sock_addr", "sched_act"], "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "8": {"capability": [{"capability": "read_sys_info", "read_sys_info": [{"Return Type": "u64", "Description": "Return the time elapsed since system boot , in nanoseconds. ", "Return": " Current ktime.", "Function Name": "bpf_ktime_get_ns", "Input Params": ["{Type: voi ,Var: void}"]}]}], "helperCallParams": {"bpf_ktime_get_ns": [{"opVar": "        s->ts ", "inpVar": ["  - s->ts"]}]}, "startLine": 90, "endLine": 111, "File": "/root/examples/bcc/nflatency.c", "funcName": "kretprobe__nf_hook_slow", "updateMaps": [], "readMaps": [], "input": ["struct pt_regs *ctx"], "output": "int", "helper": ["bpf_ktime_get_ns"], "compatibleHookpoints": ["sock_ops", "sched_cls", "xdp", "lwt_seg6local", "cgroup_sock", "sk_reuseport", "perf_event", "lwt_xmit", "raw_tracepoint_writable", "lwt_out", "socket_filter", "raw_tracepoint", "sk_msg", "kprobe", "flow_dissector", "cgroup_skb", "sk_skb", "lwt_in", "tracepoint", "cgroup_sock_addr", "sched_act"], "humanFuncDescription": [{"description": "", "author": "", "authorEmail": "", "date": ""}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "9": {"capability": [], "helperCallParams": {}, "startLine": 6, "endLine": 18, "File": "/root/examples/bcc/mallocstacks.c", "funcName": "alloc_enter", "updateMaps": [], "readMaps": [], "input": ["struct pt_regs *ctx", " size_t size"], "output": "int", "helper": [], "compatibleHookpoints": ["All_hookpoints"], "humanFuncDescription": [{"description": "alloc_enter() function takes as input a structure ctx\n                      of type pt_regs and a variable size of type size_t. It \n                      stores the kernel stack's id in 'key'. To achieve this, \n                      the helper needs ctx, which is a pointer to the context \n                      on which the tracing program is executed, and a pointer \n                      to a map of type BPF_MAP_TYPE_STACK_TRACE. The counter \n                      is then incremented in calls while mapping it to the \n                      respective stack which is identified by the above defined \n                      key. Function returns 0 on completion.", "author": "Neha Chowdhary", "authorEmail": "nehaniket79@gmail.com", "date": "01.02.2023"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "10": {"capability": [], "helperCallParams": {"bpf_trace_printk": [{"opVar": "NA", "inpVar": ["    \"%d\\\\n\"", " args->got_bits"]}]}, "startLine": 11, "endLine": 14, "File": "/root/examples/bcc/urandomread-explicit.c", "funcName": "printarg", "updateMaps": [], "readMaps": [], "input": ["struct urandom_read_args *args"], "output": "int", "helper": ["bpf_trace_printk"], "compatibleHookpoints": ["sock_ops", "sched_cls", "cgroup_device", "xdp", "lwt_seg6local", "cgroup_sock", "sk_reuseport", "perf_event", "lwt_xmit", "raw_tracepoint_writable", "lwt_out", "socket_filter", "raw_tracepoint", "sk_msg", "kprobe", "flow_dissector", "cgroup_skb", "sk_skb", "lwt_in", "tracepoint", "cgroup_sock_addr", "sched_act", "cgroup_sysctl"], "humanFuncDescription": [{"description": "This is an explicit way to instrument tracepoints. This is an older example of instrumenting a tracepoint, which defines the argument struct and makes an explicit call to attach_tracepoint().", "author": "Utkalika Satapathy", "authorEmail": "utkalika.satapathy01@gmail.com", "date": "02.02.2023"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "11": {"capability": [{"capability": "read_sys_info", "read_sys_info": [{"Return Type": "u64", "Description": "Return the time elapsed since system boot , in nanoseconds. ", "Return": " Current ktime.", "Function Name": "bpf_ktime_get_ns", "Input Params": ["{Type: voi ,Var: void}"]}, {"Return Type": "u64", "Return": " A 64-bit integer containing the current tgid and pid, and created  as  such:                     current_task->tgid << 32 | current_task->pid.", "Function Name": "bpf_get_current_pid_tgid", "Input Params": ["{Type: voi ,Var: void}"], "Description": "A 64-bit integer containing the current tgid and pid , and created as such: current_task->tgid << 32 | current_task->pid. "}]}], "helperCallParams": {"bpf_get_current_pid_tgid": [{"opVar": "\tpid ", "inpVar": [" "]}], "bpf_ktime_get_ns": [{"opVar": "\tts ", "inpVar": [" "]}]}, "startLine": 18, "endLine": 27, "File": "/root/examples/bcc/vfsreadlat.c", "funcName": "do_entry", "updateMaps": [], "readMaps": [], "input": ["struct pt_regs *ctx"], "output": "int", "helper": ["bpf_ktime_get_ns", "bpf_get_current_pid_tgid"], "compatibleHookpoints": ["raw_tracepoint", "perf_event", "raw_tracepoint_writable", "kprobe", "tracepoint"], "humanFuncDescription": [{"description": "Using BPF_HASH a hash (which is also a BPF map) named 'start' is created. \n                      The key feild of this map stores the pid of datatype u32 and the corresponding value field stores the timestamp of datatype u64.\n                      When the function do_entry is invoked, the map 'start' saves the timestamp for the pid when it starts it's execution. \n                      This function is attached with 'vfs_read' entry event in the bpf loader program.", "author": "Utkalika Satapathy", "authorEmail": "utkalika.satapathy01@gmail.com", "date": "18.01.2023"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "12": {"capability": [{"capability": "read_sys_info", "read_sys_info": [{"Return Type": "u64", "Description": "Return the time elapsed since system boot , in nanoseconds. ", "Return": " Current ktime.", "Function Name": "bpf_ktime_get_ns", "Input Params": ["{Type: voi ,Var: void}"]}, {"Return Type": "u64", "Return": " A 64-bit integer containing the current tgid and pid, and created  as  such:                     current_task->tgid << 32 | current_task->pid.", "Function Name": "bpf_get_current_pid_tgid", "Input Params": ["{Type: voi ,Var: void}"], "Description": "A 64-bit integer containing the current tgid and pid , and created as such: current_task->tgid << 32 | current_task->pid. "}]}], "helperCallParams": {"bpf_get_current_pid_tgid": [{"opVar": "\tpid ", "inpVar": [" "]}], "bpf_ktime_get_ns": [{"opVar": "\t\tdelta ", "inpVar": ["  - *tsp"]}]}, "startLine": 29, "endLine": 44, "File": "/root/examples/bcc/vfsreadlat.c", "funcName": "do_return", "updateMaps": [], "readMaps": [], "input": ["struct pt_regs *ctx"], "output": "int", "helper": ["bpf_ktime_get_ns", "bpf_get_current_pid_tgid"], "compatibleHookpoints": ["raw_tracepoint", "perf_event", "raw_tracepoint_writable", "kprobe", "tracepoint"], "humanFuncDescription": [{"description": "do_return function is attached at the exit point of vfs_read event.\n                     This function calculate the toltal amount of time taken to execute the process\n                     Using the bpf helper function, it first get the current pid and search the same pid in the 'start' bpf map to find it's start time and store it in 'tsp'\n                    'delta' stores the time taken to execute the function by substrating the start time of of the function from current system time\n                    'dist' is a histogram, which defaults to 64 buckets indexed by keys of type int and whose value gets increated by the log-2 value of delta/1000", "author": "Utkalika Satapathy", "authorEmail": "utkalika.satapathy01@gmail.com", "date": "18.01.2023"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "13": {"capability": [{"capability": "read_sys_info", "read_sys_info": [{"Return Type": "int", "Description": "Copy the comm attribute of the current task into <[ buf ]>(IP: 0) of size_of_buf. The comm attribute contains the name of the executable (excluding the path) for the current task. The <[ size_of_buf ]>(IP: 1) must be strictly positive. On success , the helper makes sure that the <[ buf ]>(IP: 0) is NUL-terminated. On failure , it is filled with zeroes. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_get_current_comm", "Input Params": ["{Type: char ,Var: *buf}", "{Type:  u32 ,Var: size_of_buf}"]}, {"Return Type": "u64", "Return": " A 64-bit integer containing the current tgid and pid, and created  as  such:                     current_task->tgid << 32 | current_task->pid.", "Function Name": "bpf_get_current_pid_tgid", "Input Params": ["{Type: voi ,Var: void}"], "Description": "A 64-bit integer containing the current tgid and pid , and created as such: current_task->tgid << 32 | current_task->pid. "}]}], "helperCallParams": {"bpf_get_current_pid_tgid": [{"opVar": "    u32 pid ", "inpVar": ["  >> 32"]}], "bpf_get_current_comm": [{"opVar": "NA", "inpVar": ["    &key.name", " sizeofkey.name"]}]}, "startLine": 13, "endLine": 26, "File": "/root/examples/bcc/stack_buildid_example.c", "funcName": "do_perf_event", "updateMaps": [], "readMaps": [], "input": ["struct bpf_perf_event_data *ctx"], "output": "int", "helper": ["bpf_get_current_comm", "bpf_get_current_pid_tgid"], "compatibleHookpoints": ["raw_tracepoint", "perf_event", "raw_tracepoint_writable", "kprobe", "tracepoint"], "humanFuncDescription": [{"description": "do_perf_event() function takes as input a structure ctx \n                      of type bpf_perf_event_data. It uses helper function \n                      bpf_get_current_pid_tgid() to get process id and thread \n                      id and then filters only the pid (32 bits). A map is \n                      created to map the key to current PID. Helper function \n                      bpf_get_current_comm then populates the name mapped to \n                      the key's address with the current process command. Then \n                      it calls get_Stackid() to find unique id for this \n                      stack trace. If this is greater than zero then we increment\n                      the key. This gives us a count of the number of times this \n                      PID command combination has been seen. Function returns 0 on\n                      successful completion.", "author": "Neha Chowdhary", "authorEmail": "nehaniket79@gmail.com", "date": "01.02.2023"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "14": {"capability": [{"capability": "read_sys_info", "read_sys_info": [{"Return Type": "u64", "Description": "Return the time elapsed since system boot , in nanoseconds. ", "Return": " Current ktime.", "Function Name": "bpf_ktime_get_ns", "Input Params": ["{Type: voi ,Var: void}"]}]}], "helperCallParams": {"bpf_ktime_get_ns": [{"opVar": "        dur ", "inpVar": ["  - rq->io_start_time_ns"]}]}, "startLine": 10, "endLine": 36, "File": "/root/examples/bcc/biolatpcts.c", "funcName": "RAW_TRACEPOINT_PROBE", "updateMaps": [], "readMaps": [], "input": ["block_rq_complete"], "output": "NA", "helper": ["bpf_ktime_get_ns"], "compatibleHookpoints": ["sock_ops", "sched_cls", "xdp", "lwt_seg6local", "cgroup_sock", "sk_reuseport", "perf_event", "lwt_xmit", "raw_tracepoint_writable", "lwt_out", "socket_filter", "raw_tracepoint", "sk_msg", "kprobe", "flow_dissector", "cgroup_skb", "sk_skb", "lwt_in", "tracepoint", "cgroup_sock_addr", "sched_act"], "humanFuncDescription": [{"description": "biolatpcts_RAW_TRACEPOINT_PROBE function takes as input a block_req_complete\n                      and calculates the duration of the i/o time 'dur' by subtracting kernel time \n                      with start time. It uses helper bpf_ktime_get_ns() to get the kernel time. It \n                      then divides it into three slots:\n                      dur>100ms, 100ms>dur>1ms and 10microsec<dur<1ms and increments the count of each \n                      slot if the duration falls in the slot. biolatpcts_RAW_TRACEPOINT_PROBE returns 0\n                      when the slots are valid or the io start time for request is 0.", "author": "Neha Chowdhary", "authorEmail": "nehaniket79@gmail.com", "date": "01.02.2023"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "15": {"capability": [{"capability": "read_sys_info", "read_sys_info": [{"Return Type": "u64", "Description": "Return the time elapsed since system boot , in nanoseconds. ", "Return": " Current ktime.", "Function Name": "bpf_ktime_get_ns", "Input Params": ["{Type: voi ,Var: void}"]}]}], "helperCallParams": {"bpf_ktime_get_ns": [{"opVar": "        rcv_packets_ts_inter ", "inpVar": ["  - *rcv_packets_ts_ptr"]}, {"opVar": "                rcv_packets_ts_inter ", "inpVar": [" "]}]}, "startLine": 15, "endLine": 61, "File": "/root/examples/bcc/dddos.c", "funcName": "detect_ddos", "updateMaps": [], "readMaps": [], "input": ["struct pt_regs *ctx", " void *skb"], "output": "int", "helper": ["bpf_ktime_get_ns"], "compatibleHookpoints": ["sock_ops", "sched_cls", "xdp", "lwt_seg6local", "cgroup_sock", "sk_reuseport", "perf_event", "lwt_xmit", "raw_tracepoint_writable", "lwt_out", "socket_filter", "raw_tracepoint", "sk_msg", "kprobe", "flow_dissector", "cgroup_skb", "sk_skb", "lwt_in", "tracepoint", "cgroup_sock_addr", "sched_act"], "humanFuncDescription": [{"description": "detect_ddos() function checks if rate of incoming packets is greater than a user \n                      defined threshold. If the rate is greater the packet is dropped, if its lower the \n                      packet is passed to next module. It takes as input a structure pointer \n                      ctx of type pt_regs and a void pointer of type skb. It store two pointers - \n                      no of packets received and time stamp between two successive packets. If the \n                      number of packets received in less than legal time, then increase the count, else \n                      ignore. If number of packets exceeds the max number of packets then trigger an \n                      alert. Ends with updating the number of packets and time elapsed for each packet \n                      in the end. Function returns 0 on successful completion.", "author": "Neha Chowdhary", "authorEmail": "nehaniket79@gmail.com", "date": "01.02.2023"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "16": {"capability": [{"capability": "read_sys_info", "read_sys_info": [{"Return Type": "int", "Description": "For tracing programs , safely attempt to read <[ size ]>(IP: 1) bytes from address <[ src ]>(IP: 2) and store the data in dst. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_probe_read", "Input Params": ["{Type: void ,Var: *dst}", "{Type:  u32 ,Var: size}", "{Type:  const void ,Var: *src}"]}]}], "helperCallParams": {"bpf_probe_read": [{"opVar": "NA", "inpVar": ["    _user&query", " sizeofquery", " void *addr"]}], "bpf_trace_printk": [{"opVar": "NA", "inpVar": ["    \"%s\\\\n\"", " query"]}]}, "startLine": 2, "endLine": 15, "File": "/root/examples/bcc/mysqld_query.c", "funcName": "do_trace", "updateMaps": [], "readMaps": [], "input": ["struct pt_regs *ctx"], "output": "int", "helper": ["bpf_probe_read", "bpf_trace_printk"], "compatibleHookpoints": ["raw_tracepoint", "perf_event", "raw_tracepoint_writable", "kprobe", "tracepoint"], "humanFuncDescription": [{"description": "mysqld_query_do_trace() function is used for tracing mysql \n                      queries. It takes as argument a structure ctx of type pt_regs.\n                      It uses bpf_usdt_readarg() to store the first argument into \n                      'addr' variable. Then the function bpf_probe_read_user() is \n                      used to store value at memory 'addr' in 'query'. Value in \n                      query is then printed using helper function bpf_trace_printk().\n                      It reads the first argument from the query-start probe, which \n                      is the query. The format of this probe is \n                      \"query-start(query, connectionid, database, user, host)\". Refer to\n                      https://dev.mysql.com/doc/refman/5.7/en/dba-dtrace-ref-query.html.\n                      Function returns 0 on successful completion.", "author": "Neha Chowdhary", "authorEmail": "nehaniket79@gmail.com", "date": "01.02.2023"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "17": {"capability": [], "helperCallParams": {"bpf_trace_printk": [{"opVar": "NA", "inpVar": ["    \"Hello", " World!\\\\n\""]}]}, "startLine": 1, "endLine": 4, "File": "/root/examples/bcc/hello_fields.c", "funcName": "hello", "updateMaps": [], "readMaps": [], "input": ["void *ctx"], "output": "int", "helper": ["bpf_trace_printk"], "compatibleHookpoints": ["sock_ops", "sched_cls", "cgroup_device", "xdp", "lwt_seg6local", "cgroup_sock", "sk_reuseport", "perf_event", "lwt_xmit", "raw_tracepoint_writable", "lwt_out", "socket_filter", "raw_tracepoint", "sk_msg", "kprobe", "flow_dissector", "cgroup_skb", "sk_skb", "lwt_in", "tracepoint", "cgroup_sock_addr", "sched_act", "cgroup_sysctl"], "humanFuncDescription": [{"description": "hello() function takes as input a void pointer ctx. It uses \n                      the bpf_trace_printk helper to print the message which is passed \n                      as argument. bpf_trace_printk is a printk()-like facility that \n                      prints message defined in it. Function returns 0 on completion.", "author": "Neha Chowdhary", "authorEmail": "nehaniket79@gmail.com", "date": "01.02.2023"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "18": {"capability": [{"capability": "read_sys_info", "read_sys_info": [{"Return Type": "u64", "Return": " A 64-bit integer containing the current tgid and pid, and created  as  such:                     current_task->tgid << 32 | current_task->pid.", "Function Name": "bpf_get_current_pid_tgid", "Input Params": ["{Type: voi ,Var: void}"], "Description": "A 64-bit integer containing the current tgid and pid , and created as such: current_task->tgid << 32 | current_task->pid. "}]}], "helperCallParams": {"bpf_get_current_pid_tgid": [{"opVar": "\tu32 pid ", "inpVar": [" "]}]}, "startLine": 7, "endLine": 15, "File": "/root/examples/bcc/tcpv4connect.c", "funcName": "kprobe__tcp_v4_connect", "updateMaps": [], "readMaps": [], "input": ["struct pt_regs *ctx", " struct sock *sk"], "output": "int", "helper": ["bpf_get_current_pid_tgid"], "compatibleHookpoints": ["raw_tracepoint", "perf_event", "kprobe", "raw_tracepoint_writable", "tracepoint"], "humanFuncDescription": [{"description": "BPF_HASH(currsock, u32, struct sock *) creates a hash named currsock where the key is a struct sock * , and the value is of type u32. \n                      This hash is used by the tcpv4connect.py for saving pid for each TCP connection request established via connect system call, where the key is the process id and the value is the struct *sock, which is the socket data.\n                      This instruments the tcp_v4_connect() kernel function using a kprobe, with the following arguments: struct pt_regs *ctx: Registers and BPF context and struct sock *sk: First argument to tcp_v4_connect().\n                      This saves pid for each TCP connection request established via connect system call, where the key is the process id and the value is the struct *sock, which is the socket data.", "author": "Utkalika Satapathy", "authorEmail": "utkalika.satapathy01@gmail.com", "date": "13.02.2023"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "19": {"capability": [{"capability": "read_sys_info", "read_sys_info": [{"Return Type": "u64", "Return": " A 64-bit integer containing the current tgid and pid, and created  as  such:                     current_task->tgid << 32 | current_task->pid.", "Function Name": "bpf_get_current_pid_tgid", "Input Params": ["{Type: voi ,Var: void}"], "Description": "A 64-bit integer containing the current tgid and pid , and created as such: current_task->tgid << 32 | current_task->pid. "}]}], "helperCallParams": {"bpf_get_current_pid_tgid": [{"opVar": "\tu32 pid ", "inpVar": [" "]}], "bpf_trace_printk": [{"opVar": "NA", "inpVar": ["\t\t\"trace_tcp4connect %x %x %d\\\\n\"", " saddr", " daddr", " ntohsdport"]}]}, "startLine": 17, "endLine": 47, "File": "/root/examples/bcc/tcpv4connect.c", "funcName": "kretprobe__tcp_v4_connect", "updateMaps": [], "readMaps": [], "input": ["struct pt_regs *ctx"], "output": "int", "helper": ["bpf_trace_printk", "bpf_get_current_pid_tgid"], "compatibleHookpoints": ["raw_tracepoint", "perf_event", "raw_tracepoint_writable", "kprobe", "tracepoint"], "humanFuncDescription": [{"description": "BPF_HASH(currsock, u32, struct sock *) creates a hash named currsock where the key is a struct sock * , and the value is of type u32. \n                      This hash is used by the tcpv4connect.py for saving pid for each TCP connection request established via connect system call, where the key is the process id and the value is the struct *sock, which is the socket data.", "author": "Utkalika Satapathy", "authorEmail": "utkalika.satapathy01@gmail.com", "date": "20.01.2023"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "20": {"capability": [], "helperCallParams": {"bpf_trace_printk": [{"opVar": "NA", "inpVar": ["        \"KVM_EXIT exit_reason : %d\\\\n\"", " args->exit_reason"]}]}, "startLine": 4, "endLine": 12, "File": "/root/examples/bcc/kvm_hypercall.c", "funcName": "TRACEPOINT_PROBE", "updateMaps": [], "readMaps": [], "input": ["kvm", " kvm_exit"], "output": "NA", "helper": ["bpf_trace_printk"], "compatibleHookpoints": ["sock_ops", "sched_cls", "cgroup_device", "xdp", "lwt_seg6local", "cgroup_sock", "sk_reuseport", "perf_event", "lwt_xmit", "raw_tracepoint_writable", "lwt_out", "socket_filter", "raw_tracepoint", "sk_msg", "kprobe", "flow_dissector", "cgroup_skb", "sk_skb", "lwt_in", "tracepoint", "cgroup_sock_addr", "sched_act", "cgroup_sysctl"], "humanFuncDescription": [{"description": "kvm_hypercall_TRACEPOINT_PROBE function is triggered in case of kvm exit\n                      event. It takes as input two parameters 'kvm' and 'kvm_exit. Function stores\n                      checks if the reason for exit is 'EXIT_REASON'. If yes, it prints the reason \n                      and stores 1 in start map. Basically keeping a note wether the next exit reason \n                      of type 'EXIT_REASON' was triggered by same event reason. Functions returns 0 on\n                      success.", "author": "Neha Chowdhary", "authorEmail": "nehaniket79@gmail.com", "date": "01.02.2023"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "21": {"capability": [], "helperCallParams": {"bpf_trace_printk": [{"opVar": "NA", "inpVar": ["        \"KVM_ENTRY vcpu_id : %u\\\\n\"", " args->vcpu_id"]}]}, "startLine": 14, "endLine": 23, "File": "/root/examples/bcc/kvm_hypercall.c", "funcName": "TRACEPOINT_PROBE", "updateMaps": [], "readMaps": [], "input": ["kvm", " kvm_entry"], "output": "NA", "helper": ["bpf_trace_printk"], "compatibleHookpoints": ["sock_ops", "sched_cls", "cgroup_device", "xdp", "lwt_seg6local", "cgroup_sock", "sk_reuseport", "perf_event", "lwt_xmit", "raw_tracepoint_writable", "lwt_out", "socket_filter", "raw_tracepoint", "sk_msg", "kprobe", "flow_dissector", "cgroup_skb", "sk_skb", "lwt_in", "tracepoint", "cgroup_sock_addr", "sched_act", "cgroup_sysctl"], "humanFuncDescription": [{"description": "kvm_hypercal_TRACEPOINT_PROBE() checks kvm entry events. It checks \n                      if the reason for exit is EXIT_REASON and if it is, then it prints \n                      out the vcpu id of that event. It also resets start to 0. Function\n                      returns 0 on success.", "author": "Neha Chowdhary", "authorEmail": "", "date": ""}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "22": {"capability": [], "helperCallParams": {"bpf_trace_printk": [{"opVar": "NA", "inpVar": ["        \"HYPERCALL nr : %d\\\\n\"", " args->nr"]}]}, "startLine": 25, "endLine": 33, "File": "/root/examples/bcc/kvm_hypercall.c", "funcName": "TRACEPOINT_PROBE", "updateMaps": [], "readMaps": [], "input": ["kvm", " kvm_hypercall"], "output": "NA", "helper": ["bpf_trace_printk"], "compatibleHookpoints": ["sock_ops", "sched_cls", "cgroup_device", "xdp", "lwt_seg6local", "cgroup_sock", "sk_reuseport", "perf_event", "lwt_xmit", "raw_tracepoint_writable", "lwt_out", "socket_filter", "raw_tracepoint", "sk_msg", "kprobe", "flow_dissector", "cgroup_skb", "sk_skb", "lwt_in", "tracepoint", "cgroup_sock_addr", "sched_act", "cgroup_sysctl"], "humanFuncDescription": [{"description": "kvm_hypercall_TRACEPOINT_PROBE() checks whether a kvm hypercall\n                      occurs or not and whether the reason for it's exit is \n                      EXTI_REASON. If yes then we print args->nr related to the\n                      hypercall. Function returns 0 on success.", "author": "Neha Chowdhary", "authorEmail": "", "date": ""}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "23": {"capability": [], "helperCallParams": {}, "startLine": 3, "endLine": 6, "File": "/root/examples/bcc/strlen_hist.c", "funcName": "count", "updateMaps": [], "readMaps": [], "input": ["struct pt_regs *ctx"], "output": "int", "helper": [], "compatibleHookpoints": ["All_hookpoints"], "humanFuncDescription": [{"description": "  A histogram named dist is created, which defaults to 64 buckets (0-63) indexed by keys of type int.  \n                        This function increments the value of dist by 1. Each bin represents one bit of the return code from the syscall being traced.\n                        PT_REGS_RC(ctx) returned value from BPF register for the specific context *ctx.\n                        This function basically counts the strlen() and updates its histogram.", "author": "Utkalika Satapathy", "authorEmail": "utkalika.satapathy01@gmail.com", "date": "02.02.2023"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "24": {"capability": [{"capability": "read_sys_info", "read_sys_info": [{"Return Type": "int", "Description": "Copy the comm attribute of the current task into <[ buf ]>(IP: 0) of size_of_buf. The comm attribute contains the name of the executable (excluding the path) for the current task. The <[ size_of_buf ]>(IP: 1) must be strictly positive. On success , the helper makes sure that the <[ buf ]>(IP: 0) is NUL-terminated. On failure , it is filled with zeroes. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_get_current_comm", "Input Params": ["{Type: char ,Var: *buf}", "{Type:  u32 ,Var: size_of_buf}"]}, {"Return Type": "u64", "Return": " A 64-bit integer containing the current tgid and pid, and created  as  such:                     current_task->tgid << 32 | current_task->pid.", "Function Name": "bpf_get_current_pid_tgid", "Input Params": ["{Type: voi ,Var: void}"], "Description": "A 64-bit integer containing the current tgid and pid , and created as such: current_task->tgid << 32 | current_task->pid. "}]}], "helperCallParams": {"bpf_get_current_pid_tgid": [{"opVar": "    u32 pid ", "inpVar": ["  >> 32"]}], "bpf_get_current_comm": [{"opVar": "NA", "inpVar": ["    &data.comm", " sizeofdata.comm"]}]}, "startLine": 13, "endLine": 21, "File": "/root/examples/bcc/stacksnoop.c", "funcName": "trace_stack", "updateMaps": [], "readMaps": [], "input": ["struct pt_regs *ctx"], "output": "void", "helper": ["bpf_get_current_comm", "bpf_get_current_pid_tgid"], "compatibleHookpoints": ["raw_tracepoint", "perf_event", "raw_tracepoint_writable", "kprobe", "tracepoint"], "humanFuncDescription": [{"description": "A stack trace map named stack_traces is created to store the stack trace of processes, with a maximum number of stack trace entries of 1024.\n                      A BPF table named events is created to push event data to user space via a perf ring buffer.\n                      Using bpf_get_current_pid_tgid() helper function the upper 32 bits is extracted which is the pid to the userspace view.\n                      A structure named data_t stores the stack_id of type u64, pid of type u32 and a character array named comm of size 16.\n                      stack_traces.get_stackid(ctx, 0) walks the stack found via the struct pt_regs in ctx, saves it in the stack trace map, and returns a unique ID for the stack trace.\n                      bpf_get_current_comm(&data.comm, sizeof(data.comm)) populates the first argument address with the current process name.\n                      The data is pushed to the event map using perf_submit so that the userspace can read these data.", "author": "Utkalika Satapathy", "authorEmail": "utkalika.satapathy01@gmail.com", "date": "02.02.2023"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "25": {"capability": [{"capability": "read_sys_info", "read_sys_info": [{"Return Type": "u64", "Description": "Return the time elapsed since system boot , in nanoseconds. ", "Return": " Current ktime.", "Function Name": "bpf_ktime_get_ns", "Input Params": ["{Type: voi ,Var: void}"]}, {"Return Type": "int", "Description": "Copy the comm attribute of the current task into <[ buf ]>(IP: 0) of size_of_buf. The comm attribute contains the name of the executable (excluding the path) for the current task. The <[ size_of_buf ]>(IP: 1) must be strictly positive. On success , the helper makes sure that the <[ buf ]>(IP: 0) is NUL-terminated. On failure , it is filled with zeroes. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_get_current_comm", "Input Params": ["{Type: char ,Var: *buf}", "{Type:  u32 ,Var: size_of_buf}"]}]}], "helperCallParams": {"bpf_ktime_get_ns": [{"opVar": "    data.ts ", "inpVar": [" "]}], "bpf_get_current_comm": [{"opVar": "NA", "inpVar": ["    &data.comm", " sizeofdata.comm"]}]}, "startLine": 11, "endLine": 24, "File": "/root/examples/bcc/hello_perf_output_using_ns.c", "funcName": "hello", "updateMaps": [], "readMaps": [], "input": ["struct pt_regs *ctx"], "output": "int", "helper": ["bpf_ktime_get_ns", "bpf_get_current_comm"], "compatibleHookpoints": ["raw_tracepoint", "perf_event", "raw_tracepoint_writable", "kprobe", "tracepoint"], "humanFuncDescription": [{"description": "hello() function takes as input a structure ctx of type pt_regs.\n                      It has two data structures 'data' to store data of an event and 'ns' \n                      to store PID namespace of the event. bpf_get_ns_current_pid_tgid() \n                      helper function returns values for pid and tgid as seen from the \n                      current namespace will be returned in 'ns'. Accordingly the PID and \n                      timestamp are updated for the event. Then we populate the first argument \n                      address 'data.comm' with the current process command and submit the event for\n                      user space to read via a perf ring buffer. Function returns 0 on success.", "author": "Neha Chowdhary", "authorEmail": "nehaniket79@gmail.com", "date": "01.02.2023"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "26": {"capability": [{"capability": "read_sys_info", "read_sys_info": [{"Return Type": "int", "Description": "For tracing programs , safely attempt to read <[ size ]>(IP: 1) bytes from address <[ src ]>(IP: 2) and store the data in dst. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_probe_read", "Input Params": ["{Type: void ,Var: *dst}", "{Type:  u32 ,Var: size}", "{Type:  const void ,Var: *src}"]}]}], "helperCallParams": {"bpf_probe_read": [{"opVar": "NA", "inpVar": ["    _user&path", " sizeofpath", " void *addr"]}], "bpf_trace_printk": [{"opVar": "NA", "inpVar": ["    \"path:%s\\\\n\"", " path"]}]}, "startLine": 2, "endLine": 9, "File": "/root/examples/bcc/nodejs_http_server.c", "funcName": "do_trace", "updateMaps": [], "readMaps": [], "input": ["struct pt_regs *ctx"], "output": "int", "helper": ["bpf_probe_read", "bpf_trace_printk"], "compatibleHookpoints": ["raw_tracepoint", "perf_event", "raw_tracepoint_writable", "kprobe", "tracepoint"], "humanFuncDescription": [{"description": "nodejs_http_server_do_trace() pulls out an address from ctx, \n                      finds the respective file path and then prints it. It takes as\n                      argument a structure ctx of type pt_regs. It uses bpf_usdt_readarg() \n                      to read the sixth parameter and then pulls it in as a string to \n                      path. Then we make addr point to path using bpf_probe_read_user() \n                      and then use bpf_trace_printk() helper function to print the \n                      path as string. Function returns 0 on successful completion.", "author": "Neha Chowdhary", "authorEmail": "nehaniket79@gmail.com", "date": "01.02.2023"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "27": {"capability": [{"capability": "read_sys_info", "read_sys_info": [{"Return Type": "u64", "Description": "Return the time elapsed since system boot , in nanoseconds. ", "Return": " Current ktime.", "Function Name": "bpf_ktime_get_ns", "Input Params": ["{Type: voi ,Var: void}"]}, {"Return Type": "int", "Description": "Copy the comm attribute of the current task into <[ buf ]>(IP: 0) of size_of_buf. The comm attribute contains the name of the executable (excluding the path) for the current task. The <[ size_of_buf ]>(IP: 1) must be strictly positive. On success , the helper makes sure that the <[ buf ]>(IP: 0) is NUL-terminated. On failure , it is filled with zeroes. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_get_current_comm", "Input Params": ["{Type: char ,Var: *buf}", "{Type:  u32 ,Var: size_of_buf}"]}, {"Return Type": "u64", "Return": " A 64-bit integer containing the current tgid and pid, and created  as  such:                     current_task->tgid << 32 | current_task->pid.", "Function Name": "bpf_get_current_pid_tgid", "Input Params": ["{Type: voi ,Var: void}"], "Description": "A 64-bit integer containing the current tgid and pid , and created as such: current_task->tgid << 32 | current_task->pid. "}]}], "helperCallParams": {"bpf_get_current_pid_tgid": [{"opVar": "    data.pid ", "inpVar": [" "]}], "bpf_ktime_get_ns": [{"opVar": "    data.ts ", "inpVar": [" "]}], "bpf_get_current_comm": [{"opVar": "NA", "inpVar": ["    &data.comm", " sizeofdata.comm"]}]}, "startLine": 11, "endLine": 21, "File": "/root/examples/bcc/hello_perf_output.c", "funcName": "hello", "updateMaps": [], "readMaps": [], "input": ["struct pt_regs *ctx"], "output": "int", "helper": ["bpf_ktime_get_ns", "bpf_get_current_comm", "bpf_get_current_pid_tgid"], "compatibleHookpoints": ["raw_tracepoint", "perf_event", "raw_tracepoint_writable", "kprobe", "tracepoint"], "humanFuncDescription": [{"description": "hello() function takes as input a structure ctx of type pt_regs. It\n                      has one data structure named 'data' of type data_t to store data of \n                      events. Helper function bpf_get_current_pid_tgid() is used to get and\n                      store the current event's tgid and pid in 'data'. bpf_ktime_get_ns()\n                      helper function is used to return the time elapsed since system boot\n                      and store it in 'data.ts'. Then we populate the first argument address\n                      'data.comm' with the current process command and submit the event for\n                      user space to read via a perf ring buffer. Function returns 0 on success.", "author": "Neha Chowdhary", "authorEmail": "nehaniket79@gmail.com", "date": "01.02.2023"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "28": {"capability": [{"capability": "read_sys_info", "read_sys_info": [{"Return Type": "int", "Description": "For tracing programs , safely attempt to read <[ size ]>(IP: 1) bytes from address <[ src ]>(IP: 2) and store the data in dst. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_probe_read", "Input Params": ["{Type: void ,Var: *dst}", "{Type:  u32 ,Var: size}", "{Type:  const void ,Var: *src}"]}, {"Return Type": "u64", "Return": " A 64-bit integer containing the current tgid and pid, and created  as  such:                     current_task->tgid << 32 | current_task->pid.", "Function Name": "bpf_get_current_pid_tgid", "Input Params": ["{Type: voi ,Var: void}"], "Description": "A 64-bit integer containing the current tgid and pid , and created as such: current_task->tgid << 32 | current_task->pid. "}]}], "helperCallParams": {"bpf_get_current_pid_tgid": [{"opVar": "    u32 pid ", "inpVar": [" "]}], "bpf_probe_read": [{"opVar": "NA", "inpVar": ["    _user&str", " sizeofstr", " void *PT_REGS_PARM1ctx"]}], "bpf_trace_printk": [{"opVar": "NA", "inpVar": ["    \"%s\\\\n\"", " &str"]}]}, "startLine": 2, "endLine": 15, "File": "/root/examples/bcc/strlen_snoop.c", "funcName": "printarg", "updateMaps": [], "readMaps": [], "input": ["struct pt_regs *ctx"], "output": "int", "helper": ["bpf_probe_read", "bpf_trace_printk", "bpf_get_current_pid_tgid"], "compatibleHookpoints": ["raw_tracepoint", "perf_event", "raw_tracepoint_writable", "kprobe", "tracepoint"], "humanFuncDescription": [{"description": "This function is attached to uprobes. \n                      It instruments the user-level function 'strlen' from 'c' binary using user-level dynamic tracing of the function entry, and attach our C defined function (count) to be called whenever the user-level function is called.\n                      Everytime strlen() function in called for a process id, bpf_probe_read_user() read size bytes from user address space to the BPF stack.\n                      The data is printed in userspace using bpf_trace_printk", "author": "Utkalika Satapathy", "authorEmail": "utkalika.satapathy01@gmail.com", "date": "02.02.2023"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "29": {"capability": [], "helperCallParams": {"bpf_trace_printk": [{"opVar": "NA", "inpVar": ["        \"%d\\\\n\"", " args->got_bits"]}]}, "startLine": 1, "endLine": 5, "File": "/root/examples/bcc/urandomread.c", "funcName": "TRACEPOINT_PROBE", "updateMaps": [], "readMaps": [], "input": ["random", " urandom_read"], "output": "NA", "helper": ["bpf_trace_printk"], "compatibleHookpoints": ["sock_ops", "sched_cls", "cgroup_device", "xdp", "lwt_seg6local", "cgroup_sock", "sk_reuseport", "perf_event", "lwt_xmit", "raw_tracepoint_writable", "lwt_out", "socket_filter", "raw_tracepoint", "sk_msg", "kprobe", "flow_dissector", "cgroup_skb", "sk_skb", "lwt_in", "tracepoint", "cgroup_sock_addr", "sched_act", "cgroup_sysctl"], "humanFuncDescription": [{"description": "TRACEPOINT_PROBE(random, urandom_read) is a macro that instruments the tracepoint defined by random:urandom_read and prints the tracepoint argument got_bits.", "author": "Utkalika Satapathy", "authorEmail": "utkalika.satapathy01@gmail.com", "date": "02.02.2023"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "30": {"capability": [{"capability": "read_sys_info", "read_sys_info": [{"Return Type": "u64", "Description": "Return the time elapsed since system boot , in nanoseconds. ", "Return": " Current ktime.", "Function Name": "bpf_ktime_get_ns", "Input Params": ["{Type: voi ,Var: void}"]}]}], "helperCallParams": {"bpf_ktime_get_ns": [{"opVar": "NA", "inpVar": ["", " 0x12345678"]}], "bpf_trace_printk": [{"opVar": "  if ((rc ", "inpVar": [" events.perf_submitctx", " &data", " sizeofdata < 0    \"perf_output failed: %d\\\\n\"", " rc"]}]}, "startLine": 3, "endLine": 15, "File": "/root/examples/bcc/trace_perf_output.c", "funcName": "do_sys_clone", "updateMaps": [], "readMaps": [], "input": ["void *ctx"], "output": "int", "helper": ["bpf_ktime_get_ns", "bpf_trace_printk"], "compatibleHookpoints": ["sock_ops", "sched_cls", "xdp", "lwt_seg6local", "cgroup_sock", "sk_reuseport", "perf_event", "lwt_xmit", "raw_tracepoint_writable", "lwt_out", "socket_filter", "raw_tracepoint", "sk_msg", "kprobe", "flow_dissector", "cgroup_skb", "sk_skb", "lwt_in", "tracepoint", "cgroup_sock_addr", "sched_act"], "humanFuncDescription": [{"description": " BPF_ARRAY(counters, u64, 10) creates a array named 'counter' with 10 buckets and u64 values.\n                      BPF_PERF_OUTPUT(events) creates a BPF table named 'events' for pushing out custom event data to user space via a perf ring buffer.\n                      This function in attahced with system call 'clone'.\n                      Whenever the event occurs, the event data gets submitted to user space via a perf ring buffer.\n                      The event data is a structure consist of system current time and the magic number i.e. 0x12345678\n                      Once the event data is submmited to the perf buffer successfully, it increaments the counter value which indicates the number of times the event has been occured", "author": "Utkalika Satapathy", "authorEmail": "utkalika.satapathy01@gmail.com", "date": "19.01.2023 "}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "31": {"capability": [], "helperCallParams": {}, "startLine": 7, "endLine": 12, "File": "/root/examples/bcc/bitehist.c", "funcName": "trace_req_done", "updateMaps": [], "readMaps": [], "input": ["struct pt_regs *ctx", " struct request *req"], "output": "int", "helper": [], "compatibleHookpoints": ["All_hookpoints"], "humanFuncDescription": [{"description": "bitehist_trace_req_done function taakes as input a structure\n                      pointer ctx of type pt_regs and another structure pointer  req of \n                      type request. The function increments a BPF map histogram named\n                      'dist' linearly and by power of two when a specific event occurs.\n                      Function returns 0 on success.", "author": "Neha Chowdhary", "authorEmail": "nehaniket79@gmail.com", "date": "01.02.2023"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "32": {"capability": [{"capability": "read_sys_info", "read_sys_info": [{"Return Type": "u64", "Description": "Return the time elapsed since system boot , in nanoseconds. ", "Return": " Current ktime.", "Function Name": "bpf_ktime_get_ns", "Input Params": ["{Type: voi ,Var: void}"]}]}], "helperCallParams": {"bpf_ktime_get_ns": [{"opVar": "\t\tu64 ts ", "inpVar": [" "]}]}, "startLine": 6, "endLine": 11, "File": "/root/examples/bcc/disksnoop.c", "funcName": "trace_start", "updateMaps": [], "readMaps": [], "input": ["struct pt_regs *ctx", " struct request *req"], "output": "void", "helper": ["bpf_ktime_get_ns"], "compatibleHookpoints": ["sock_ops", "sched_cls", "xdp", "lwt_seg6local", "cgroup_sock", "sk_reuseport", "perf_event", "lwt_xmit", "raw_tracepoint_writable", "lwt_out", "socket_filter", "raw_tracepoint", "sk_msg", "kprobe", "flow_dissector", "cgroup_skb", "sk_skb", "lwt_in", "tracepoint", "cgroup_sock_addr", "sched_act"], "humanFuncDescription": [{"description": "disksnoop_trace_start() function takes as input a structure \n                      pointer ctx of type pt_regs and another structure pointer req\n                      of type request. The function uses helper function bpf_ktime_get_ns()\n                      to get the current kernel time in nanosec and stores it \n                      in a variable 'ts' of size 64 bits. It then updates the map\n                      with req being the key and ts being the value.", "author": "Neha Chowdhary", "authorEmail": "nehaniket79@gmail.com", "date": "01.02.2023"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "33": {"capability": [{"capability": "read_sys_info", "read_sys_info": [{"Return Type": "u64", "Description": "Return the time elapsed since system boot , in nanoseconds. ", "Return": " Current ktime.", "Function Name": "bpf_ktime_get_ns", "Input Params": ["{Type: voi ,Var: void}"]}]}], "helperCallParams": {"bpf_ktime_get_ns": [{"opVar": "\t\tdelta ", "inpVar": ["  - *tsp"]}], "bpf_trace_printk": [{"opVar": "NA", "inpVar": ["\t\t\"%d %x %d\\\\n\"", " req->__data_len", "\t\t    req->cmd_flags", " delta / 1000"]}]}, "startLine": 13, "endLine": 23, "File": "/root/examples/bcc/disksnoop.c", "funcName": "trace_completion", "updateMaps": [], "readMaps": [], "input": ["struct pt_regs *ctx", " struct request *req"], "output": "void", "helper": ["bpf_ktime_get_ns", "bpf_trace_printk"], "compatibleHookpoints": ["sock_ops", "sched_cls", "xdp", "lwt_seg6local", "cgroup_sock", "sk_reuseport", "perf_event", "lwt_xmit", "raw_tracepoint_writable", "lwt_out", "socket_filter", "raw_tracepoint", "sk_msg", "kprobe", "flow_dissector", "cgroup_skb", "sk_skb", "lwt_in", "tracepoint", "cgroup_sock_addr", "sched_act"], "humanFuncDescription": [{"description": "disksnoop_trace_completion() takes as input a structure \n                      pointer ctx of type pt_regs and another structure pointer req\n                      of type request. It retrieves the startup time and stores it in \n                      'tsp'. If tsp is non-zero, then the difference in startup time\n                      and current kernel time which is calculated using helper function\n                      bpf_ktime_get_ns(), is stored in variable 'delta'. According to \n                      this delta, the data length, cmd flags and delta/1000 is \n                      printed using helper function bpf_trace_printk(). The map is then \n\t\t      updated to remove the req entry.", "author": "Neha Chowdhary", "authorEmail": "nehaniket79@gmail.com", "date": "01.02.2023"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "34": {"capability": [{"capability": "read_sys_info", "read_sys_info": [{"Return Type": "int", "Description": "For tracing programs , safely attempt to read <[ size ]>(IP: 1) bytes from address <[ src ]>(IP: 2) and store the data in dst. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_probe_read", "Input Params": ["{Type: void ,Var: *dst}", "{Type:  u32 ,Var: size}", "{Type:  const void ,Var: *src}"]}]}], "helperCallParams": {"bpf_probe_read": [{"opVar": "NA", "inpVar": ["    _user&key.c", " sizeofkey.c", " void *PT_REGS_PARM1ctx"]}]}, "startLine": 8, "endLine": 22, "File": "/root/examples/bcc/strlen_count.c", "funcName": "count", "updateMaps": [], "readMaps": [], "input": ["struct pt_regs *ctx"], "output": "int", "helper": ["bpf_probe_read"], "compatibleHookpoints": ["raw_tracepoint", "perf_event", "kprobe", "raw_tracepoint_writable", "tracepoint"], "humanFuncDescription": [{"description": "This function is attached to uprobes. \n                      It instruments the user-level function 'strlen' from 'c' binary using user-level dynamic tracing of the function entry, and attach our C defined function (count) to be called whenever the user-level function is called.\n                      A BPF HASH named 'counts' is created which stores struct key_t.\n                      Everytime strlen() function in called, bpf_probe_read_user() read key.c bytes from user address space to the BPF stack.\n                      A lookup operation is made on the counts map with the key. \n                      If it exist then increament it's values otherwise initialize with 0.\n                      ", "author": "Utkalika Satapathy", "authorEmail": "utkalika.satapathy01@gmail.com", "date": "02.02.2023"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "35": {"capability": [], "helperCallParams": {}, "startLine": 4, "endLine": 7, "File": "/root/examples/bcc/strlen_hist_ifunc.c", "funcName": "count", "updateMaps": [], "readMaps": [], "input": ["struct pt_regs *ctx"], "output": "int", "helper": [], "compatibleHookpoints": ["All_hookpoints"], "humanFuncDescription": [{"description": "  A histogram named dist is created, which defaults to 64 buckets (0-63) indexed by keys of type int.  \n                        This function increments the value of dist by 1. Each bin represents one bit of the return code from the syscall being traced.\n                        PT_REGS_RC(ctx) returned value from BPF register for the specific context *ctx.\n                        This function basically counts the strlen() and updates its histogram.", "author": "Utkalika Satapathy", "authorEmail": "utkalika.satapathy01@gmail.com", "date": "02.02.2023"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "36": {"capability": [], "helperCallParams": {}, "startLine": 11, "endLine": 14, "File": "/root/examples/bcc/strlen_hist_ifunc.c", "funcName": "submit_impl_func_addr", "updateMaps": [], "readMaps": [], "input": ["struct pt_regs *ctx"], "output": "void", "helper": [], "compatibleHookpoints": ["All_hookpoints"], "humanFuncDescription": [{"description": " Using BPF_PERF_OUTPUT a Perf event map is declared named impl_func_addr. \n                       This will instrument strlen() function from libc, and call our BPF function submit_impl_func_addr() when it returns.\n                       PT_REGS_RC is a macro that\u2019s going to read the returned value from BPF register for this specific context and will be stored in the addr varibale of type u64.\n                       perf_submit function updates the Perf impl_func_addr map with the returned address value.", "author": "Utkalika Satapathy", "authorEmail": "utkalika.satapathy01@gmail.com", "date": "13.02.2023"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "37": {"capability": [], "helperCallParams": {}, "startLine": 18, "endLine": 22, "File": "/root/examples/bcc/strlen_hist_ifunc.c", "funcName": "submit_resolv_func_addr", "updateMaps": [], "readMaps": [], "input": ["struct pt_regs *ctx"], "output": "int", "helper": [], "compatibleHookpoints": ["All_hookpoints"], "humanFuncDescription": [{"description": "Using BPF_PERF_OUTPUT a Perf event map is declared named resolv_func_addr. \n                      This will instrument strlen() function from libc, and when it is called, the BPF function submit_resolv_func_addr() will be called.\n                      PT_REGS_IP is a macro that\u2019s going to read the returned value from BPF register for this specific context and will be stored in the rip varibale of type u64.\n                      perf_submit function updates the Perf resolv_func_addr map with the returned address value.", "author": "Utkalika Satapathy", "authorEmail": "utkalika.satapathy01@gmail.com", "date": "13.02.2023"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}, "38": {"capability": [{"capability": "read_sys_info", "read_sys_info": [{"Return Type": "u64", "Return": " A 64-bit integer containing the current tgid and pid, and created  as  such:                     current_task->tgid << 32 | current_task->pid.", "Function Name": "bpf_get_current_pid_tgid", "Input Params": ["{Type: voi ,Var: void}"], "Description": "A 64-bit integer containing the current tgid and pid , and created as such: current_task->tgid << 32 | current_task->pid. "}]}], "helperCallParams": {"bpf_get_current_pid_tgid": [{"opVar": "    key.curr_pid ", "inpVar": [" "]}]}, "startLine": 10, "endLine": 23, "File": "/root/examples/bcc/task_switch.c", "funcName": "count_sched", "updateMaps": [], "readMaps": [], "input": ["struct pt_regs *ctx", " struct task_struct *prev"], "output": "int", "helper": ["bpf_get_current_pid_tgid"], "compatibleHookpoints": ["raw_tracepoint", "perf_event", "kprobe", "raw_tracepoint_writable", "tracepoint"], "humanFuncDescription": [{"description": "A BPF map named 'stats' is created where the key is struct *key_t. key_t stores the current pid and previous process's id\n                      This function is invoked everytime a context switch occurs.\n                      When there is a task switch, it stores the pid as prev pid and the new process pid in curr_pid of struct key.\n                      Then a look up is performed with the key in the stats BPF map. \n                      If the pid does not present in the map, it initializes it with 0, otherwise the count is increased by 1 for the pid", "author": "Utkalika Satapathy", "authorEmail": "utkalika.satapathy01@gmail.com", "date": "21.01.2023"}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}}}