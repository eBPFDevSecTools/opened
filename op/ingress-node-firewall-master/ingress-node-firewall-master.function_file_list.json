{"ip_extract_l4info": [{"capabilities": [], "helperCallParams": {}, "startLine": 84, "endLine": 160, "File": "/home/sayandes/opened_extraction/examples/ingress-node-firewall-master/bpf/ingress_node_firewall_kernel.c", "funcName": "ip_extract_l4info", "updateMaps": [], "readMaps": [], "input": ["void *dataStart", " void *dataEnd", " __u8 *proto", " __u16 *dstPort", " __u8 *icmpType", " __u8 *icmpCode", " __u8 is_v4"], "output": "staticinlineint", "helper": [], "compatibleHookpoints": ["xdp", "sock_ops", "sk_msg", "sk_reuseport", "lwt_xmit", "raw_tracepoint_writable", "raw_tracepoint", "cgroup_sock", "perf_event", "sched_cls", "flow_dissector", "lwt_in", "cgroup_sock_addr", "lwt_seg6local", "tracepoint", "cgroup_skb", "cgroup_sysctl", "sched_act", "kprobe", "socket_filter", "cgroup_device", "sk_skb", "lwt_out"], "source": ["static inline int ip_extract_l4info (void *dataStart, void *dataEnd, __u8 *proto, __u16 *dstPort, __u8 *icmpType, __u8 *icmpCode, __u8 is_v4)\n", "{\n", "    if (likely (is_v4)) {\n", "        struct iphdr *iph = dataStart;\n", "        dataStart += sizeof (struct iphdr);\n", "        if (unlikely (dataStart > dataEnd)) {\n", "            return -1;\n", "        }\n", "        *proto = iph->protocol;\n", "    }\n", "    else {\n", "        struct ipv6hdr *iph = dataStart;\n", "        dataStart += sizeof (struct ipv6hdr);\n", "        if (unlikely (dataStart > dataEnd)) {\n", "            return -1;\n", "        }\n", "        *proto = iph->nexthdr;\n", "    }\n", "    switch (*proto) {\n", "    case IPPROTO_TCP :\n", "        {\n", "            struct tcphdr *tcph = (struct tcphdr *) dataStart;\n", "            dataStart += sizeof (struct tcphdr);\n", "            if (unlikely (dataStart > dataEnd)) {\n", "                return -1;\n", "            }\n", "            *dstPort = tcph->dest;\n", "            break;\n", "        }\n", "    case IPPROTO_UDP :\n", "        {\n", "            struct udphdr *udph = (struct udphdr *) dataStart;\n", "            dataStart += sizeof (struct udphdr);\n", "            if (unlikely (dataStart > dataEnd)) {\n", "                return -1;\n", "            }\n", "            *dstPort = udph->dest;\n", "            break;\n", "        }\n", "    case IPPROTO_SCTP :\n", "        {\n", "            struct sctphdr *sctph = (struct sctphdr *) dataStart;\n", "            dataStart += sizeof (struct sctphdr);\n", "            if (unlikely (dataStart > dataEnd)) {\n", "                return -1;\n", "            }\n", "            *dstPort = sctph->dest;\n", "            break;\n", "        }\n", "    case IPPROTO_ICMP :\n", "        {\n", "            struct icmphdr *icmph = (struct icmphdr *) dataStart;\n", "            dataStart += sizeof (struct icmphdr);\n", "            if (unlikely (dataStart > dataEnd)) {\n", "                return -1;\n", "            }\n", "            *icmpType = icmph->type;\n", "            *icmpCode = icmph->code;\n", "            break;\n", "        }\n", "    case IPPROTO_ICMPV6 :\n", "        {\n", "            struct icmp6hdr *icmp6h = (struct icmp6hdr *) dataStart;\n", "            dataStart += sizeof (struct icmp6hdr);\n", "            if (unlikely (dataStart > dataEnd)) {\n", "                return -1;\n", "            }\n", "            *icmpType = icmp6h->icmp6_type;\n", "            *icmpCode = icmp6h->icmp6_code;\n", "            break;\n", "        }\n", "    default :\n", "        return -1;\n", "    }\n", "    return 0;\n", "}\n"], "called_function_list": ["unlikely", "likely"], "call_depth": -1, "humanFuncDescription": [{}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ipv4_firewall_lookup": [{"capabilities": [], "helperCallParams": {}, "startLine": 176, "endLine": 242, "File": "/home/sayandes/opened_extraction/examples/ingress-node-firewall-master/bpf/ingress_node_firewall_kernel.c", "funcName": "ipv4_firewall_lookup", "updateMaps": [], "readMaps": [" ingress_node_firewall_table_map"], "input": ["void *dataStart", " void *dataEnd", " __u32 ifId"], "output": "staticinline__u32", "helper": ["bpf_map_lookup_elem"], "compatibleHookpoints": ["xdp", "sock_ops", "sk_msg", "sk_reuseport", "lwt_xmit", "raw_tracepoint_writable", "raw_tracepoint", "cgroup_sock", "perf_event", "sched_cls", "flow_dissector", "lwt_in", "cgroup_sock_addr", "lwt_seg6local", "tracepoint", "cgroup_skb", "cgroup_sysctl", "sched_act", "kprobe", "socket_filter", "cgroup_device", "sk_skb", "lwt_out"], "source": ["static inline __u32 ipv4_firewall_lookup (void *dataStart, void *dataEnd, __u32 ifId)\n", "{\n", "    struct iphdr *iph = dataStart;\n", "    struct lpm_ip_key_st key;\n", "    __u32 srcAddr = iph->saddr;\n", "    __u16 dstPort = 0;\n", "    __u8 icmpCode = 0, icmpType = 0, proto = 0;\n", "    int i;\n", "    if (ip_extract_l4info (dataStart, dataEnd, &proto, &dstPort, &icmpType, &icmpCode, 1) < 0) {\n", "        bpf_printk (\"failed to extract l4 info\");\n", "        return SET_ACTION (UNDEF);\n", "    }\n", "    memset (&key, 0, sizeof (key));\n", "    key.prefixLen = 64;\n", "    key.ip_data[0] = srcAddr & 0xFF;\n", "    key.ip_data[1] = (srcAddr >> 8) & 0xFF;\n", "    key.ip_data[2] = (srcAddr >> 16) & 0xFF;\n", "    key.ip_data[3] = (srcAddr >> 24) & 0xFF;\n", "    key.ingress_ifindex = ifId;\n", "    struct rulesVal_st *rulesVal = (struct rulesVal_st *) bpf_map_lookup_elem (&ingress_node_firewall_table_map, &key);\n", "    if (likely (NULL != rulesVal)) {\n", "\n", "#pragma clang loop unroll(full)\n", "        for (i = 0; i < MAX_RULES_PER_TARGET; ++i) {\n", "            struct ruleType_st *rule = &rulesVal->rules[i];\n", "            if (rule->ruleId == INVALID_RULE_ID) {\n", "                continue;\n", "            }\n", "            if (likely ((rule->protocol != 0) && (rule->protocol == proto))) {\n", "                bpf_printk (\"ruleInfo (protocol %d, Id %d, action %d)\", rule->protocol, rule->ruleId, rule->action);\n", "                if ((rule->protocol == IPPROTO_TCP) || (rule->protocol == IPPROTO_UDP) || (rule->protocol == IPPROTO_SCTP)) {\n", "                    bpf_printk (\"TCP/UDP/SCTP packet rule_dstPortStart %d rule_dstPortEnd %d pkt_dstPort %d\", rule->dstPortStart, rule->dstPortEnd, bpf_ntohs (dstPort));\n", "                    if (rule->dstPortEnd == 0) {\n", "                        if (rule->dstPortStart == bpf_ntohs (dstPort)) {\n", "                            return SET_ACTIONRULE_RESPONSE (rule->action, rule->ruleId);\n", "                        }\n", "                    }\n", "                    else {\n", "                        if ((bpf_ntohs (dstPort) >= rule->dstPortStart) && (bpf_ntohs (dstPort) < rule->dstPortEnd)) {\n", "                            return SET_ACTIONRULE_RESPONSE (rule->action, rule->ruleId);\n", "                        }\n", "                    }\n", "                }\n", "                if (rule->protocol == IPPROTO_ICMP) {\n", "                    bpf_printk (\"ICMP packet rule(type:%d, code:%d) pkt(type:%d, code %d)\", rule->icmpType, rule->icmpCode, icmpType, icmpCode);\n", "                    if ((rule->icmpType == icmpType) && (rule->icmpCode == icmpCode)) {\n", "                        return SET_ACTIONRULE_RESPONSE (rule->action, rule->ruleId);\n", "                    }\n", "                }\n", "            }\n", "            if (rule->protocol == 0) {\n", "                return SET_ACTIONRULE_RESPONSE (rule->action, rule->ruleId);\n", "            }\n", "        }\n", "        bpf_printk (\"Packet didn't match any rule proto %d port %d\", proto, bpf_ntohs (dstPort));\n", "    }\n", "    return SET_ACTION (UNDEF);\n", "}\n"], "called_function_list": ["memset", "likely", "ip_extract_l4info", "unroll", "bpf_printk", "SET_ACTION", "bpf_ntohs", "SET_ACTIONRULE_RESPONSE"], "call_depth": -1, "humanFuncDescription": [{}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ipv6_firewall_lookup": [{"capabilities": [], "helperCallParams": {}, "startLine": 258, "endLine": 318, "File": "/home/sayandes/opened_extraction/examples/ingress-node-firewall-master/bpf/ingress_node_firewall_kernel.c", "funcName": "ipv6_firewall_lookup", "updateMaps": [], "readMaps": [" ingress_node_firewall_table_map"], "input": ["void *dataStart", " void *dataEnd", " __u32 ifId"], "output": "staticinline__u32", "helper": ["bpf_map_lookup_elem"], "compatibleHookpoints": ["xdp", "sock_ops", "sk_msg", "sk_reuseport", "lwt_xmit", "raw_tracepoint_writable", "raw_tracepoint", "cgroup_sock", "perf_event", "sched_cls", "flow_dissector", "lwt_in", "cgroup_sock_addr", "lwt_seg6local", "tracepoint", "cgroup_skb", "cgroup_sysctl", "sched_act", "kprobe", "socket_filter", "cgroup_device", "sk_skb", "lwt_out"], "source": ["static inline __u32 ipv6_firewall_lookup (void *dataStart, void *dataEnd, __u32 ifId)\n", "{\n", "    struct ipv6hdr *iph = dataStart;\n", "    struct lpm_ip_key_st key;\n", "    __u8 *srcAddr = iph->saddr.in6_u.u6_addr8;\n", "    __u16 dstPort = 0;\n", "    __u8 icmpCode = 0, icmpType = 0, proto = 0;\n", "    int i;\n", "    if (ip_extract_l4info (dataStart, dataEnd, &proto, &dstPort, &icmpType, &icmpCode, 0) < 0) {\n", "        return SET_ACTION (UNDEF);\n", "    }\n", "    memset (&key, 0, sizeof (key));\n", "    key.prefixLen = 160;\n", "    memcpy (key.ip_data, srcAddr, 16);\n", "    key.ingress_ifindex = ifId;\n", "    struct rulesVal_st *rulesVal = (struct rulesVal_st *) bpf_map_lookup_elem (&ingress_node_firewall_table_map, &key);\n", "    if (NULL != rulesVal) {\n", "\n", "#pragma clang loop unroll(full)\n", "        for (i = 0; i < MAX_RULES_PER_TARGET; ++i) {\n", "            struct ruleType_st *rule = &rulesVal->rules[i];\n", "            if (rule->ruleId == INVALID_RULE_ID) {\n", "                continue;\n", "            }\n", "            if (likely ((rule->protocol != 0) && (rule->protocol == proto))) {\n", "                bpf_printk (\"ruleInfo (protocol %d, Id %d, action %d)\", rule->protocol, rule->ruleId, rule->action);\n", "                if ((rule->protocol == IPPROTO_TCP) || (rule->protocol == IPPROTO_UDP) || (rule->protocol == IPPROTO_SCTP)) {\n", "                    bpf_printk (\"TCP/UDP/SCTP packet rule_dstPortStart %d rule_dstPortEnd %d pkt_dstPort %d\", rule->dstPortStart, rule->dstPortEnd, bpf_ntohs (dstPort));\n", "                    if (rule->dstPortEnd == 0) {\n", "                        if (rule->dstPortStart == bpf_ntohs (dstPort)) {\n", "                            return SET_ACTIONRULE_RESPONSE (rule->action, rule->ruleId);\n", "                        }\n", "                    }\n", "                    else {\n", "                        if ((bpf_ntohs (dstPort) >= rule->dstPortStart) && (bpf_ntohs (dstPort) < rule->dstPortEnd)) {\n", "                            return SET_ACTIONRULE_RESPONSE (rule->action, rule->ruleId);\n", "                        }\n", "                    }\n", "                }\n", "                if (rule->protocol == IPPROTO_ICMPV6) {\n", "                    bpf_printk (\"ICMPV6 packet rule(type:%d, code:%d) pkt(type:%d, code %d)\", rule->icmpType, rule->icmpCode, icmpType, icmpCode);\n", "                    if ((rule->icmpType == icmpType) && (rule->icmpCode == icmpCode)) {\n", "                        return SET_ACTIONRULE_RESPONSE (rule->action, rule->ruleId);\n", "                    }\n", "                }\n", "            }\n", "            if (rule->protocol == 0) {\n", "                return SET_ACTIONRULE_RESPONSE (rule->action, rule->ruleId);\n", "            }\n", "        }\n", "        bpf_printk (\"Packet didn't match any rule proto %d port %d\", proto, bpf_ntohs (dstPort));\n", "    }\n", "    return SET_ACTION (UNDEF);\n", "}\n"], "called_function_list": ["memset", "likely", "ip_extract_l4info", "unroll", "bpf_printk", "SET_ACTION", "memcpy", "bpf_ntohs", "SET_ACTIONRULE_RESPONSE"], "call_depth": -1, "humanFuncDescription": [{}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "generate_event_and_update_statistics": [{"capabilities": [{"capability": "map_read", "map_read": [{"Project": "libbpf", "Return Type": "void*", "Description": "Perform a lookup in <[ map ]>(IP: 0) for an entry associated to key. ", "Return": " Map value associated to key, or NULL if no entry was found.", "Function Name": "bpf_map_lookup_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_read"]}]}, {"capability": "map_update", "map_update": [{"Project": "libbpf", "Return Type": "int", "Description": "Add or update the <[ value ]>(IP: 2) of the entry associated to <[ key ]>(IP: 1) in <[ map ]>(IP: 0) with value. <[ flags ]>(IP: 3) is one of: BPF_NOEXIST The entry for <[ key ]>(IP: 1) must not exist in the map. BPF_EXIST The entry for <[ key ]>(IP: 1) must already exist in the map. BPF_ANY No condition on the existence of the entry for key. Flag <[ value ]>(IP: 2) BPF_NOEXIST cannot be used for maps of types BPF_MAP_TYPE_ARRAY or BPF_MAP_TYPE_PERCPU_ARRAY (all elements always exist) , the helper would return an error. ", "Return": " 0 on success, or a negative error in case of failure.", "Function Name": "bpf_map_update_elem", "Input Params": ["{Type: struct bpf_map ,Var: *map}", "{Type:  const void ,Var: *key}", "{Type:  const void ,Var: *value}", "{Type:  u64 ,Var: flags}"], "compatible_hookpoints": ["socket_filter", "kprobe", "sched_cls", "sched_act", "tracepoint", "xdp", "perf_event", "cgroup_skb", "cgroup_sock", "lwt_in", "lwt_out", "lwt_xmit", "sock_ops", "sk_skb", "cgroup_device", "sk_msg", "raw_tracepoint", "cgroup_sock_addr", "lwt_seg6local", "sk_reuseport", "flow_dissector", "cgroup_sysctl", "raw_tracepoint_writable"], "capabilities": ["map_update"]}]}], "helperCallParams": {}, "startLine": 335, "endLine": 374, "File": "/home/sayandes/opened_extraction/examples/ingress-node-firewall-master/bpf/ingress_node_firewall_kernel.c", "funcName": "generate_event_and_update_statistics", "updateMaps": [" ingress_node_firewall_statistics_map"], "readMaps": ["  ingress_node_firewall_statistics_map"], "input": ["struct xdp_md *ctx", " __u16 packet_len", " __u8 action", " __u16 ruleId", " __u8 generateEvent", " __u32 ifId"], "output": "staticinlinevoid", "helper": ["bpf_map_lookup_elem", "bpf_perf_event_output", "bpf_map_update_elem"], "compatibleHookpoints": ["kprobe", "xdp", "sched_cls", "lwt_in", "sock_ops", "lwt_out", "socket_filter", "raw_tracepoint", "lwt_seg6local", "lwt_xmit", "sk_skb", "raw_tracepoint_writable", "tracepoint", "cgroup_skb", "perf_event", "sched_act"], "source": ["static inline void generate_event_and_update_statistics (struct xdp_md *ctx, __u16 packet_len, __u8 action, __u16 ruleId, __u8 generateEvent, __u32 ifId)\n", "{\n", "    struct ruleStatistics_st *statistics, initialStats;\n", "    struct event_hdr_st hdr;\n", "    __u64 flags = BPF_F_CURRENT_CPU;\n", "    __u16 headerSize;\n", "    __u32 key = ruleId;\n", "    memset (&hdr, 0, sizeof (hdr));\n", "    hdr.ruleId = ruleId;\n", "    hdr.action = action;\n", "    hdr.pktLength = (__u16) packet_len;\n", "    hdr.ifId = (__u16) ifId;\n", "    memset (&initialStats, 0, sizeof (initialStats));\n", "    statistics = bpf_map_lookup_elem (& ingress_node_firewall_statistics_map, & key);\n", "    if (likely (statistics)) {\n", "        switch (action) {\n", "        case ALLOW :\n", "            __sync_fetch_and_add (&statistics->allow_stats.packets, 1);\n", "            __sync_fetch_and_add (&statistics->allow_stats.bytes, packet_len);\n", "            break;\n", "        case DENY :\n", "            __sync_fetch_and_add (&statistics->deny_stats.packets, 1);\n", "            __sync_fetch_and_add (&statistics->deny_stats.bytes, packet_len);\n", "            break;\n", "        }\n", "    }\n", "    else {\n", "        bpf_map_update_elem (&ingress_node_firewall_statistics_map, &key, &initialStats, BPF_ANY);\n", "    }\n", "    if (generateEvent) {\n", "        headerSize = packet_len < MAX_EVENT_DATA ? packet_len : MAX_EVENT_DATA;\n", "        flags |= (__u64) headerSize << 32;\n", "        (void) bpf_perf_event_output (ctx, &ingress_node_firewall_events_map, flags, &hdr, sizeof (hdr));\n", "    }\n", "}\n"], "called_function_list": ["__sync_fetch_and_add", "likely", "memset"], "call_depth": -1, "humanFuncDescription": [{}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ingress_node_firewall_main": [{"capabilities": [{"capability": "pkt_go_to_next_module", "pkt_go_to_next_module": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_PASS", "Return": 2, "Description": "The XDP_PASS return code means that the packet is allowed to be passed up to the kernel\u2019s networking stack. Meaning, the current CPU that was processing this packet now allocates a skb, populates it, and passes it onwards into the GRO engine. This would be equivalent to the default packet handling behavior without XDP.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_go_to_next_module"]}]}, {"capability": "pkt_stop_processing_drop_packet", "pkt_stop_processing_drop_packet": [{"Project": "libbpf", "Return Type": "int", "Input Params": [], "Function Name": "XDP_DROP", "Return": 1, "Description": "will drop the packet right at the driver level without wasting any further resources. This is in particular useful for BPF programs implementing DDoS mitigation mechanisms or firewalling in general.", "compatible_hookpoints": ["xdp"], "capabilities": ["pkt_stop_processing_drop_packet"]}]}], "helperCallParams": {}, "startLine": 386, "endLine": 431, "File": "/home/sayandes/opened_extraction/examples/ingress-node-firewall-master/bpf/ingress_node_firewall_kernel.c", "funcName": "ingress_node_firewall_main", "updateMaps": [], "readMaps": [], "input": ["struct xdp_md *ctx"], "output": "staticinlineint", "helper": ["XDP_PASS", "XDP_DROP"], "compatibleHookpoints": ["xdp"], "source": ["static inline int ingress_node_firewall_main (struct xdp_md *ctx)\n", "{\n", "    void *data = (void *) (long) ctx->data;\n", "    void *dataEnd = (void *) (long) ctx->data_end;\n", "    struct ethhdr *eth = data;\n", "    void *dataStart = data + sizeof (struct ethhdr);\n", "    __u32 result = UNDEF;\n", "    __u32 ifId = ctx->ingress_ifindex;\n", "    bpf_printk (\"Ingress node firewall start processing a packet on %d\", ifId);\n", "    if (unlikely (dataStart > dataEnd)) {\n", "        bpf_printk (\"Ingress node firewall bad packet XDP_DROP\");\n", "        return XDP_DROP;\n", "    }\n", "    switch (eth->h_proto) {\n", "    case bpf_htons (ETH_P_IP) :\n", "        bpf_printk (\"Ingress node firewall process IPv4 packet\");\n", "        result = ipv4_firewall_lookup (dataStart, dataEnd, ifId);\n", "        break;\n", "    case bpf_htons (ETH_P_IPV6) :\n", "        bpf_printk (\"Ingress node firewall process IPv6 packet\");\n", "        result = ipv6_firewall_lookup (dataStart, dataEnd, ifId);\n", "        break;\n", "    default :\n", "        bpf_printk (\"Ingress node firewall unknown L3 protocol XDP_PASS\");\n", "        return XDP_PASS;\n", "    }\n", "    __u16 ruleId = GET_RULE_ID (result);\n", "    __u8 action = GET_ACTION (result);\n", "    switch (action) {\n", "    case DENY :\n", "        generate_event_and_update_statistics (ctx, (__u16) (dataEnd - data), DENY, ruleId, 1, ifId);\n", "        bpf_printk (\"Ingress node firewall action DENY -> XDP_DROP\");\n", "        return XDP_DROP;\n", "    case ALLOW :\n", "        generate_event_and_update_statistics (ctx, (__u16) (dataEnd - data), ALLOW, ruleId, 0, ifId);\n", "        bpf_printk (\"Ingress node firewall action ALLOW -> XDP_PASS\");\n", "        return XDP_PASS;\n", "    default :\n", "        bpf_printk (\"Ingress node firewall action UNDEF\");\n", "        return XDP_PASS;\n", "    }\n", "}\n"], "called_function_list": ["GET_ACTION", "bpf_htons", "ipv4_firewall_lookup", "unlikely", "GET_RULE_ID", "generate_event_and_update_statistics", "bpf_printk", "ipv6_firewall_lookup"], "call_depth": -1, "humanFuncDescription": [{}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "ingress_node_firewall_process": [{"capabilities": [], "helperCallParams": {}, "startLine": 434, "endLine": 436, "File": "/home/sayandes/opened_extraction/examples/ingress-node-firewall-master/bpf/ingress_node_firewall_kernel.c", "funcName": "ingress_node_firewall_process", "updateMaps": [], "readMaps": [], "input": ["struct xdp_md *ctx"], "output": "int", "helper": [], "compatibleHookpoints": ["xdp", "sock_ops", "sk_msg", "sk_reuseport", "lwt_xmit", "raw_tracepoint_writable", "raw_tracepoint", "cgroup_sock", "perf_event", "sched_cls", "flow_dissector", "lwt_in", "cgroup_sock_addr", "lwt_seg6local", "tracepoint", "cgroup_skb", "cgroup_sysctl", "sched_act", "kprobe", "socket_filter", "cgroup_device", "sk_skb", "lwt_out"], "source": ["int ingress_node_firewall_process (struct xdp_md *ctx)\n", "{\n", "    return ingress_node_firewall_main (ctx);\n", "}\n"], "called_function_list": ["ingress_node_firewall_main"], "call_depth": -1, "humanFuncDescription": [{}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}], "bpf_tail_call_static": [{"capabilities": [], "helperCallParams": {}, "startLine": 98, "endLine": 123, "File": "/home/sayandes/opened_extraction/examples/ingress-node-firewall-master/bpf/headers/bpf_helpers.h", "funcName": "bpf_tail_call_static", "updateMaps": [], "readMaps": [], "input": ["void *ctx", " const void *map", " const __u32 slot"], "output": "static__always_inlinevoid", "helper": ["bpf_tail_call"], "compatibleHookpoints": ["xdp", "sock_ops", "sk_msg", "sk_reuseport", "lwt_xmit", "raw_tracepoint_writable", "raw_tracepoint", "cgroup_sock", "perf_event", "sched_cls", "flow_dissector", "lwt_in", "cgroup_sock_addr", "lwt_seg6local", "tracepoint", "cgroup_skb", "sched_act", "kprobe", "socket_filter", "sk_skb", "lwt_out"], "source": ["static __always_inline void bpf_tail_call_static (void *ctx, const void *map, const __u32 slot)\n", "{\n", "    if (!__builtin_constant_p (slot))\n", "        __bpf_unreachable ();\n", "    asm volatile (\"r1 = %[ctx]\\n\\t\"\n", "        \"r2 = %[map]\\n\\t\"\n", "        \"r3 = %[slot]\\n\\t\"\n", "        \"call 12\"\n", "        : : [ctx] \"r\"\n", "        (ctx), [map] \"r\"\n", "        (map), [slot] \"i\"\n", "        (slot) : \"r0\",\n", "        \"r1\",\n", "        \"r2\",\n", "        \"r3\",\n", "        \"r4\",\n", "        \"r5\"\n", "        );\n", "}\n"], "called_function_list": ["__bpf_unreachable", "__builtin_constant_p"], "call_depth": -1, "humanFuncDescription": [{}], "AI_func_description": [{"description": "", "author": "", "authorEmail": "", "date": "", "invocationParameters": ""}]}]}